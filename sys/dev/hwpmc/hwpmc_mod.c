begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2006 Joseph Koshy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmckern.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmclog.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_comment
comment|/* needs to be after<sys/malloc.h> */
end_comment

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_comment
comment|/*  * Types  */
end_comment

begin_enum
enum|enum
name|pmc_flags
block|{
name|PMC_FLAG_NONE
init|=
literal|0x00
block|,
comment|/* do nothing */
name|PMC_FLAG_REMOVE
init|=
literal|0x01
block|,
comment|/* atomically remove entry from hash */
name|PMC_FLAG_ALLOCATE
init|=
literal|0x02
block|,
comment|/* add entry to hash if not found */
block|}
enum|;
end_enum

begin_comment
comment|/*  * The offset in sysent where the syscall is allocated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmc_syscall_num
init|=
name|NO_SYSCALL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pmc_cpu
modifier|*
modifier|*
name|pmc_pcpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* per-cpu state */
end_comment

begin_decl_stmt
name|pmc_value_t
modifier|*
name|pmc_pcpu_saved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* saved PMC values: CSW handling */
end_comment

begin_define
define|#
directive|define
name|PMC_PCPU_SAVED
parameter_list|(
name|C
parameter_list|,
name|R
parameter_list|)
value|pmc_pcpu_saved[(R) + md->pmd_npmc*(C)]
end_define

begin_decl_stmt
name|struct
name|mtx_pool
modifier|*
name|pmc_mtxpool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|pmc_pmcdisp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PMC row dispositions */
end_comment

begin_define
define|#
directive|define
name|PMC_ROW_DISP_IS_FREE
parameter_list|(
name|R
parameter_list|)
value|(pmc_pmcdisp[(R)] == 0)
end_define

begin_define
define|#
directive|define
name|PMC_ROW_DISP_IS_THREAD
parameter_list|(
name|R
parameter_list|)
value|(pmc_pmcdisp[(R)]> 0)
end_define

begin_define
define|#
directive|define
name|PMC_ROW_DISP_IS_STANDALONE
parameter_list|(
name|R
parameter_list|)
value|(pmc_pmcdisp[(R)]< 0)
end_define

begin_define
define|#
directive|define
name|PMC_MARK_ROW_FREE
parameter_list|(
name|R
parameter_list|)
value|do {					  \ 	pmc_pmcdisp[(R)] = 0;						  \ } while (0)
end_define

begin_define
define|#
directive|define
name|PMC_MARK_ROW_STANDALONE
parameter_list|(
name|R
parameter_list|)
value|do {					  \ 	KASSERT(pmc_pmcdisp[(R)]<= 0, ("[pmc,%d] row disposition error", \ 		    __LINE__));						  \ 	atomic_add_int(&pmc_pmcdisp[(R)], -1);				  \ 	KASSERT(pmc_pmcdisp[(R)]>= (-mp_ncpus), ("[pmc,%d] row "	  \ 		"disposition error", __LINE__));			  \ } while (0)
end_define

begin_define
define|#
directive|define
name|PMC_UNMARK_ROW_STANDALONE
parameter_list|(
name|R
parameter_list|)
value|do { 				  \ 	atomic_add_int(&pmc_pmcdisp[(R)], 1);				  \ 	KASSERT(pmc_pmcdisp[(R)]<= 0, ("[pmc,%d] row disposition error", \ 		    __LINE__));						  \ } while (0)
end_define

begin_define
define|#
directive|define
name|PMC_MARK_ROW_THREAD
parameter_list|(
name|R
parameter_list|)
value|do {					  \ 	KASSERT(pmc_pmcdisp[(R)]>= 0, ("[pmc,%d] row disposition error", \ 		    __LINE__));						  \ 	atomic_add_int(&pmc_pmcdisp[(R)], 1);				  \ } while (0)
end_define

begin_define
define|#
directive|define
name|PMC_UNMARK_ROW_THREAD
parameter_list|(
name|R
parameter_list|)
value|do {					  \ 	atomic_add_int(&pmc_pmcdisp[(R)], -1);				  \ 	KASSERT(pmc_pmcdisp[(R)]>= 0, ("[pmc,%d] row disposition error", \ 		    __LINE__));						  \ } while (0)
end_define

begin_comment
comment|/* various event handlers */
end_comment

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|pmc_exit_tag
decl_stmt|,
name|pmc_fork_tag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Module statistics */
end_comment

begin_decl_stmt
name|struct
name|pmc_op_getdriverstats
name|pmc_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Machine/processor dependent operations */
end_comment

begin_decl_stmt
name|struct
name|pmc_mdep
modifier|*
name|md
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hash tables mapping owner processes and target threads to PMCs.  */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|pmc_processhash_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* spin mutex */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|pmc_processhashmask
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
name|pmc_processhash
argument_list|,
name|pmc_process
argument_list|)
operator|*
name|pmc_processhash
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Hash table of PMC owner descriptors.  This table is protected by  * the shared PMC "sx" lock.  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|pmc_ownerhashmask
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
name|pmc_ownerhash
argument_list|,
name|pmc_owner
argument_list|)
operator|*
name|pmc_ownerhash
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * List of PMC owners with system-wide sampling PMCs.  */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|pmc_owner
argument_list|)
name|pmc_ss_owners
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Prototypes  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|int
name|pmc_debugflags_sysctl_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_debugflags_parse
parameter_list|(
name|char
modifier|*
name|newstr
parameter_list|,
name|char
modifier|*
name|fence
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|load
parameter_list|(
name|struct
name|module
modifier|*
name|module
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_attach_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pmc
modifier|*
name|pmc_allocate_pmc_descriptor
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pmc_owner
modifier|*
name|pmc_allocate_owner_descriptor
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_attach_one_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_can_allocate_rowindex
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
name|ri
parameter_list|,
name|int
name|cpu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_can_attach
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_cleanup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_detach_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_detach_one_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_destroy_owner_descriptor
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pmc_owner
modifier|*
name|pmc_find_owner_descriptor
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_find_pmc
parameter_list|(
name|pmc_id_t
name|pmcid
parameter_list|,
name|struct
name|pmc
modifier|*
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pmc
modifier|*
name|pmc_find_pmc_descriptor_in_process
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|pmc_id_t
name|pmc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pmc_process
modifier|*
name|pmc_find_process_descriptor
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|uint32_t
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_force_context_switch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_link_target_process
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_maybe_remove_owner
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_process_csw_in
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_process_csw_out
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_process_exit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_process_fork
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
name|struct
name|proc
modifier|*
name|p2
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_process_samples
parameter_list|(
name|int
name|cpu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_release_pmc_descriptor
parameter_list|(
name|struct
name|pmc
modifier|*
name|pmc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_remove_owner
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_remove_process_descriptor
parameter_list|(
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_restore_cpu_binding
parameter_list|(
name|struct
name|pmc_binding
modifier|*
name|pb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_save_cpu_binding
parameter_list|(
name|struct
name|pmc_binding
modifier|*
name|pb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_select_cpu
parameter_list|(
name|int
name|cpu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_start
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_stop
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_syscall_handler
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|syscall_args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_unlink_target_process
parameter_list|(
name|struct
name|pmc
modifier|*
name|pmc
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Kernel tunables and sysctl(8) interface.  */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|hwpmc
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"HWPMC parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|struct
name|pmc_debugflags
name|pmc_debugflags
init|=
name|PMC_DEBUG_DEFAULT_FLAGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|pmc_debugstr
index|[
name|PMC_DEBUG_STRSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_STR
argument_list|(
name|PMC_SYSCTL_NAME_PREFIX
literal|"debugflags"
argument_list|,
name|pmc_debugstr
argument_list|,
sizeof|sizeof
argument_list|(
name|pmc_debugstr
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_hwpmc
argument_list|,
name|OID_AUTO
argument_list|,
name|debugflags
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pmc_debugflags_sysctl_handler
argument_list|,
literal|"A"
argument_list|,
literal|"debug flags"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * kern.hwpmc.hashrows -- determines the number of rows in the  * of the hash table used to look up threads  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmc_hashsize
init|=
name|PMC_HASH_SIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
name|PMC_SYSCTL_NAME_PREFIX
literal|"hashsize"
argument_list|,
operator|&
name|pmc_hashsize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_hwpmc
argument_list|,
name|OID_AUTO
argument_list|,
name|hashsize
argument_list|,
name|CTLFLAG_TUN
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmc_hashsize
argument_list|,
literal|0
argument_list|,
literal|"rows in hash tables"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * kern.hwpmc.nsamples --- number of PC samples per CPU  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmc_nsamples
init|=
name|PMC_NSAMPLES
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
name|PMC_SYSCTL_NAME_PREFIX
literal|"nsamples"
argument_list|,
operator|&
name|pmc_nsamples
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_hwpmc
argument_list|,
name|OID_AUTO
argument_list|,
name|nsamples
argument_list|,
name|CTLFLAG_TUN
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmc_nsamples
argument_list|,
literal|0
argument_list|,
literal|"number of PC samples per CPU"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * kern.hwpmc.mtxpoolsize -- number of mutexes in the mutex pool.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmc_mtxpool_size
init|=
name|PMC_MTXPOOL_SIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
name|PMC_SYSCTL_NAME_PREFIX
literal|"mtxpoolsize"
argument_list|,
operator|&
name|pmc_mtxpool_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_hwpmc
argument_list|,
name|OID_AUTO
argument_list|,
name|mtxpoolsize
argument_list|,
name|CTLFLAG_TUN
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmc_mtxpool_size
argument_list|,
literal|0
argument_list|,
literal|"size of spin mutex pool"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * security.bsd.unprivileged_syspmcs -- allow non-root processes to  * allocate system-wide PMCs.  *  * Allowing unprivileged processes to allocate system PMCs is convenient  * if system-wide measurements need to be taken concurrently with other  * per-process measurements.  This feature is turned off by default.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmc_unprivileged_syspmcs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"security.bsd.unprivileged_syspmcs"
argument_list|,
operator|&
name|pmc_unprivileged_syspmcs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_security_bsd
argument_list|,
name|OID_AUTO
argument_list|,
name|unprivileged_syspmcs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pmc_unprivileged_syspmcs
argument_list|,
literal|0
argument_list|,
literal|"allow unprivileged process to allocate system PMCs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Hash function.  Discard the lower 2 bits of the pointer since  * these are always zero for our uses.  The hash multiplier is  * round((2^LONG_BIT) * ((sqrt(5)-1)/2)).  */
end_comment

begin_if
if|#
directive|if
name|LONG_BIT
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|_PMC_HM
value|11400714819323198486u
end_define

begin_elif
elif|#
directive|elif
name|LONG_BIT
operator|==
literal|32
end_elif

begin_define
define|#
directive|define
name|_PMC_HM
value|2654435769u
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|Must know the size of 'long' to compile
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PMC_HASH_PTR
parameter_list|(
name|P
parameter_list|,
name|M
parameter_list|)
value|((((unsigned long) (P)>> 2) * _PMC_HM)& (M))
end_define

begin_comment
comment|/*  * Syscall structures  */
end_comment

begin_comment
comment|/* The `sysent' for the new syscall */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sysent
name|pmc_sysent
init|=
block|{
literal|2
block|,
comment|/* sy_narg */
name|pmc_syscall_handler
comment|/* sy_call */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|syscall_module_data
name|pmc_syscall_mod
init|=
block|{
name|load
block|,
name|NULL
block|,
operator|&
name|pmc_syscall_num
block|,
operator|&
name|pmc_sysent
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|moduledata_t
name|pmc_mod
init|=
block|{
name|PMC_MODULE_NAME
block|,
name|syscall_module_handler
block|,
operator|&
name|pmc_syscall_mod
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|pmc
argument_list|,
name|pmc_mod
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|pmc
argument_list|,
name|PMC_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_enum
enum|enum
name|pmc_dbgparse_state
block|{
name|PMCDS_WS
block|,
comment|/* in whitespace */
name|PMCDS_MAJOR
block|,
comment|/* seen a major keyword */
name|PMCDS_MINOR
block|}
enum|;
end_enum

begin_function
specifier|static
name|int
name|pmc_debugflags_parse
parameter_list|(
name|char
modifier|*
name|newstr
parameter_list|,
name|char
modifier|*
name|fence
parameter_list|)
block|{
name|char
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|pmc_debugflags
modifier|*
name|tmpflags
decl_stmt|;
name|int
name|error
decl_stmt|,
name|found
decl_stmt|,
modifier|*
name|newbits
decl_stmt|,
name|tmp
decl_stmt|;
name|size_t
name|kwlen
decl_stmt|;
name|MALLOC
argument_list|(
name|tmpflags
argument_list|,
expr|struct
name|pmc_debugflags
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmpflags
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|p
operator|=
name|newstr
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|fence
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|)
condition|;
name|p
operator|++
control|)
block|{
comment|/* skip white space */
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
continue|continue;
comment|/* look for a keyword followed by "=" */
for|for
control|(
name|q
operator|=
name|p
init|;
name|p
operator|<
name|fence
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|&&
name|c
operator|!=
literal|'='
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'='
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|kwlen
operator|=
name|p
operator|-
name|q
expr_stmt|;
name|newbits
operator|=
name|NULL
expr_stmt|;
comment|/* lookup flag group name */
define|#
directive|define
name|DBG_SET_FLAG_MAJ
parameter_list|(
name|S
parameter_list|,
name|F
parameter_list|)
define|\
value|if (kwlen == sizeof(S)-1&& strncmp(q, S, kwlen) == 0)	\ 			newbits =&tmpflags->pdb_ ## F;
name|DBG_SET_FLAG_MAJ
argument_list|(
literal|"cpu"
argument_list|,
name|CPU
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MAJ
argument_list|(
literal|"csw"
argument_list|,
name|CSW
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MAJ
argument_list|(
literal|"logging"
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MAJ
argument_list|(
literal|"module"
argument_list|,
name|MOD
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MAJ
argument_list|(
literal|"md"
argument_list|,
name|MDP
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MAJ
argument_list|(
literal|"owner"
argument_list|,
name|OWN
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MAJ
argument_list|(
literal|"pmc"
argument_list|,
name|PMC
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MAJ
argument_list|(
literal|"process"
argument_list|,
name|PRC
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MAJ
argument_list|(
literal|"sampling"
argument_list|,
name|SAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbits
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|p
operator|++
expr_stmt|;
comment|/* skip the '=' */
comment|/* Now parse the individual flags */
name|tmp
operator|=
literal|0
expr_stmt|;
name|newflag
label|:
for|for
control|(
name|q
operator|=
name|p
init|;
name|p
operator|<
name|fence
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|)
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|','
condition|)
break|break;
comment|/* p == fence or c == ws or c == "," or c == 0 */
if|if
condition|(
operator|(
name|kwlen
operator|=
name|p
operator|-
name|q
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|newbits
operator|=
name|tmp
expr_stmt|;
continue|continue;
block|}
name|found
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|DBG_SET_FLAG_MIN
parameter_list|(
name|S
parameter_list|,
name|F
parameter_list|)
define|\
value|if (kwlen == sizeof(S)-1&& strncmp(q, S, kwlen) == 0)	\ 			tmp |= found = (1<< PMC_DEBUG_MIN_ ## F)
comment|/* a '*' denotes all possible flags in the group */
if|if
condition|(
name|kwlen
operator|==
literal|1
operator|&&
operator|*
name|q
operator|==
literal|'*'
condition|)
name|tmp
operator|=
name|found
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* look for individual flag names */
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"allocaterow"
argument_list|,
name|ALR
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"allocate"
argument_list|,
name|ALL
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"attach"
argument_list|,
name|ATT
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"bind"
argument_list|,
name|BND
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"config"
argument_list|,
name|CFG
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"exec"
argument_list|,
name|EXC
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"exit"
argument_list|,
name|EXT
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"find"
argument_list|,
name|FND
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"flush"
argument_list|,
name|FLS
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"fork"
argument_list|,
name|FRK
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"getbuf"
argument_list|,
name|GTB
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"hook"
argument_list|,
name|PMH
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"init"
argument_list|,
name|INI
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"intr"
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"linktarget"
argument_list|,
name|TLK
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"mayberemove"
argument_list|,
name|OMR
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"ops"
argument_list|,
name|OPS
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"read"
argument_list|,
name|REA
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"register"
argument_list|,
name|REG
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"release"
argument_list|,
name|REL
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"remove"
argument_list|,
name|ORM
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"sample"
argument_list|,
name|SAM
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"scheduleio"
argument_list|,
name|SIO
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"select"
argument_list|,
name|SEL
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"signal"
argument_list|,
name|SIG
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"swi"
argument_list|,
name|SWI
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"swo"
argument_list|,
name|SWO
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"start"
argument_list|,
name|STA
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"stop"
argument_list|,
name|STO
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"syscall"
argument_list|,
name|PMS
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"unlinktarget"
argument_list|,
name|TUL
argument_list|)
expr_stmt|;
name|DBG_SET_FLAG_MIN
argument_list|(
literal|"write"
argument_list|,
name|WRI
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
comment|/* unrecognized flag name */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
comment|/* end of flag group */
operator|*
name|newbits
operator|=
name|tmp
expr_stmt|;
continue|continue;
block|}
name|p
operator|++
expr_stmt|;
goto|goto
name|newflag
goto|;
block|}
comment|/* save the new flag set */
name|bcopy
argument_list|(
name|tmpflags
argument_list|,
operator|&
name|pmc_debugflags
argument_list|,
sizeof|sizeof
argument_list|(
name|pmc_debugflags
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
name|FREE
argument_list|(
name|tmpflags
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmc_debugflags_sysctl_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
modifier|*
name|fence
decl_stmt|,
modifier|*
name|newstr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
operator|(
name|void
operator|)
name|arg1
expr_stmt|;
operator|(
name|void
operator|)
name|arg2
expr_stmt|;
comment|/* unused parameters */
name|n
operator|=
sizeof|sizeof
argument_list|(
name|pmc_debugstr
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|newstr
argument_list|,
name|char
operator|*
argument_list|,
name|n
argument_list|,
name|M_PMC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|newstr
argument_list|,
name|pmc_debugstr
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|newstr
argument_list|,
name|n
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* if there is a new string, parse and copy it */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
name|fence
operator|=
name|newstr
operator|+
operator|(
name|n
operator|<
name|req
operator|->
name|newlen
condition|?
name|n
else|:
name|req
operator|->
name|newlen
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_debugflags_parse
argument_list|(
name|newstr
argument_list|,
name|fence
argument_list|)
operator|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pmc_debugstr
argument_list|,
name|newstr
argument_list|,
sizeof|sizeof
argument_list|(
name|pmc_debugstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|newstr
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Concurrency Control  *  * The driver manages the following data structures:  *  *   - target process descriptors, one per target process  *   - owner process descriptors (and attached lists), one per owner process  *   - lookup hash tables for owner and target processes  *   - PMC descriptors (and attached lists)  *   - per-cpu hardware state  *   - the 'hook' variable through which the kernel calls into  *     this module  *   - the machine hardware state (managed by the MD layer)  *  * These data structures are accessed from:  *  * - thread context-switch code  * - interrupt handlers (possibly on multiple cpus)  * - kernel threads on multiple cpus running on behalf of user  *   processes doing system calls  * - this driver's private kernel threads  *  * = Locks and Locking strategy =  *  * The driver uses four locking strategies for its operation:  *  * - The global SX lock "pmc_sx" is used to protect internal  *   data structures.  *  *   Calls into the module by syscall() start with this lock being  *   held in exclusive mode.  Depending on the requested operation,  *   the lock may be downgraded to 'shared' mode to allow more  *   concurrent readers into the module.  Calls into the module from  *   other parts of the kernel acquire the lock in shared mode.  *  *   This SX lock is held in exclusive mode for any operations that  *   modify the linkages between the driver's internal data structures.  *  *   The 'pmc_hook' function pointer is also protected by this lock.  *   It is only examined with the sx lock held in exclusive mode.  The  *   kernel module is allowed to be unloaded only with the sx lock held  *   in exclusive mode.  In normal syscall handling, after acquiring the  *   pmc_sx lock we first check that 'pmc_hook' is non-null before  *   proceeding.  This prevents races between the thread unloading the module  *   and other threads seeking to use the module.  *  * - Lookups of target process structures and owner process structures  *   cannot use the global "pmc_sx" SX lock because these lookups need  *   to happen during context switches and in other critical sections  *   where sleeping is not allowed.  We protect these lookup tables  *   with their own private spin-mutexes, "pmc_processhash_mtx" and  *   "pmc_ownerhash_mtx".  *  * - Interrupt handlers work in a lock free manner.  At interrupt  *   time, handlers look at the PMC pointer (phw->phw_pmc) configured  *   when the PMC was started.  If this pointer is NULL, the interrupt  *   is ignored after updating driver statistics.  We ensure that this  *   pointer is set (using an atomic operation if necessary) before the  *   PMC hardware is started.  Conversely, this pointer is unset atomically  *   only after the PMC hardware is stopped.  *  *   We ensure that everything needed for the operation of an  *   interrupt handler is available without it needing to acquire any  *   locks.  We also ensure that a PMC's software state is destroyed only  *   after the PMC is taken off hardware (on all CPUs).  *  * - Context-switch handling with process-private PMCs needs more  *   care.  *  *   A given process may be the target of multiple PMCs.  For example,  *   PMCATTACH and PMCDETACH may be requested by a process on one CPU  *   while the target process is running on another.  A PMC could also  *   be getting released because its owner is exiting.  We tackle  *   these situations in the following manner:  *  *   - each target process structure 'pmc_process' has an array  *     of 'struct pmc *' pointers, one for each hardware PMC.  *  *   - At context switch IN time, each "target" PMC in RUNNING state  *     gets started on hardware and a pointer to each PMC is copied into  *     the per-cpu phw array.  The 'runcount' for the PMC is  *     incremented.  *  *   - At context switch OUT time, all process-virtual PMCs are stopped  *     on hardware.  The saved value is added to the PMCs value field  *     only if the PMC is in a non-deleted state (the PMCs state could  *     have changed during the current time slice).  *  *     Note that since in-between a switch IN on a processor and a switch  *     OUT, the PMC could have been released on another CPU.  Therefore  *     context switch OUT always looks at the hardware state to turn  *     OFF PMCs and will update a PMC's saved value only if reachable  *     from the target process record.  *  *   - OP PMCRELEASE could be called on a PMC at any time (the PMC could  *     be attached to many processes at the time of the call and could  *     be active on multiple CPUs).  *  *     We prevent further scheduling of the PMC by marking it as in  *     state 'DELETED'.  If the runcount of the PMC is non-zero then  *     this PMC is currently running on a CPU somewhere.  The thread  *     doing the PMCRELEASE operation waits by repeatedly doing a  *     pause() till the runcount comes to zero.  *  * The contents of a PMC descriptor (struct pmc) are protected using  * a spin-mutex.  In order to save space, we use a mutex pool.  *  * In terms of lock types used by witness(4), we use:  * - Type "pmc-sx", used by the global SX lock.  * - Type "pmc-sleep", for sleep mutexes used by logger threads.  * - Type "pmc-per-proc", for protecting PMC owner descriptors.  * - Type "pmc-leaf", used for all other spin mutexes.  */
end_comment

begin_comment
comment|/*  * save the cpu binding of the current kthread  */
end_comment

begin_function
specifier|static
name|void
name|pmc_save_cpu_binding
parameter_list|(
name|struct
name|pmc_binding
modifier|*
name|pb
parameter_list|)
block|{
name|PMCDBG
argument_list|(
name|CPU
argument_list|,
name|BND
argument_list|,
literal|2
argument_list|,
literal|"%s"
argument_list|,
literal|"save-cpu"
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|pb
operator|->
name|pb_bound
operator|=
name|sched_is_bound
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|pb
operator|->
name|pb_cpu
operator|=
name|curthread
operator|->
name|td_oncpu
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|CPU
argument_list|,
name|BND
argument_list|,
literal|2
argument_list|,
literal|"save-cpu cpu=%d"
argument_list|,
name|pb
operator|->
name|pb_cpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * restore the cpu binding of the current thread  */
end_comment

begin_function
specifier|static
name|void
name|pmc_restore_cpu_binding
parameter_list|(
name|struct
name|pmc_binding
modifier|*
name|pb
parameter_list|)
block|{
name|PMCDBG
argument_list|(
name|CPU
argument_list|,
name|BND
argument_list|,
literal|2
argument_list|,
literal|"restore-cpu curcpu=%d restore=%d"
argument_list|,
name|curthread
operator|->
name|td_oncpu
argument_list|,
name|pb
operator|->
name|pb_cpu
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|pb_bound
condition|)
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|pb
operator|->
name|pb_cpu
argument_list|)
expr_stmt|;
else|else
name|sched_unbind
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|CPU
argument_list|,
name|BND
argument_list|,
literal|2
argument_list|,
literal|"%s"
argument_list|,
literal|"restore-cpu done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * move execution over the specified cpu and bind it there.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_select_cpu
parameter_list|(
name|int
name|cpu
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[pmc,%d] bad cpu number %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
comment|/* never move to a disabled CPU */
name|KASSERT
argument_list|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] selecting "
literal|"disabled CPU %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|CPU
argument_list|,
name|SEL
argument_list|,
literal|2
argument_list|,
literal|"select-cpu cpu=%d"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|curthread
operator|->
name|td_oncpu
operator|==
name|cpu
argument_list|,
operator|(
literal|"[pmc,%d] CPU not bound [cpu=%d, curr=%d]"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|curthread
operator|->
name|td_oncpu
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|CPU
argument_list|,
name|SEL
argument_list|,
literal|2
argument_list|,
literal|"select-cpu cpu=%d ok"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Force a context switch.  *  * We do this by pause'ing for 1 tick -- invoking mi_switch() is not  * guaranteed to force a context switch.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_force_context_switch
parameter_list|(
name|void
parameter_list|)
block|{
name|pause
argument_list|(
literal|"pmcctx"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the file name for an executable.  This is a simple wrapper  * around vn_fullpath(9).  */
end_comment

begin_function
specifier|static
name|void
name|pmc_getfilename
parameter_list|(
name|struct
name|vnode
modifier|*
name|v
parameter_list|,
name|char
modifier|*
modifier|*
name|fullpath
parameter_list|,
name|char
modifier|*
modifier|*
name|freepath
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
operator|*
name|fullpath
operator|=
literal|"unknown"
expr_stmt|;
operator|*
name|freepath
operator|=
name|NULL
expr_stmt|;
name|vn_lock
argument_list|(
name|v
argument_list|,
name|LK_CANRECURSE
operator||
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_fullpath
argument_list|(
name|td
argument_list|,
name|v
argument_list|,
name|fullpath
argument_list|,
name|freepath
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove an process owning PMCs  */
end_comment

begin_function
name|void
name|pmc_remove_owner
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
block|{
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|OWN
argument_list|,
name|ORM
argument_list|,
literal|1
argument_list|,
literal|"remove-owner po=%p"
argument_list|,
name|po
argument_list|)
expr_stmt|;
comment|/* Remove descriptor from the owner hash table */
name|LIST_REMOVE
argument_list|(
name|po
argument_list|,
name|po_next
argument_list|)
expr_stmt|;
comment|/* release all owned PMC descriptors */
name|LIST_FOREACH_SAFE
argument_list|(
argument|pm
argument_list|,
argument|&po->po_pmcs
argument_list|,
argument|pm_next
argument_list|,
argument|tmp
argument_list|)
block|{
name|PMCDBG
argument_list|(
name|OWN
argument_list|,
name|ORM
argument_list|,
literal|2
argument_list|,
literal|"pmc=%p"
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_owner
operator|==
name|po
argument_list|,
operator|(
literal|"[pmc,%d] owner %p != po %p"
operator|,
name|__LINE__
operator|,
name|pm
operator|->
name|pm_owner
operator|,
name|po
operator|)
argument_list|)
expr_stmt|;
name|pmc_release_pmc_descriptor
argument_list|(
name|pm
argument_list|)
expr_stmt|;
comment|/* will unlink from the list */
block|}
name|KASSERT
argument_list|(
name|po
operator|->
name|po_sscount
operator|==
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] SS count not zero"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|po
operator|->
name|po_pmcs
argument_list|)
argument_list|,
operator|(
literal|"[pmc,%d] PMC list not empty"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
comment|/* de-configure the log file if present */
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
name|pmclog_deconfigure_log
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove an owner process record if all conditions are met.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_maybe_remove_owner
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
block|{
name|PMCDBG
argument_list|(
name|OWN
argument_list|,
name|OMR
argument_list|,
literal|1
argument_list|,
literal|"maybe-remove-owner po=%p"
argument_list|,
name|po
argument_list|)
expr_stmt|;
comment|/* 	 * Remove owner record if 	 * - this process does not own any PMCs 	 * - this process has not allocated a system-wide sampling buffer 	 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|po
operator|->
name|po_pmcs
argument_list|)
operator|&&
operator|(
operator|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|pmc_remove_owner
argument_list|(
name|po
argument_list|)
expr_stmt|;
name|pmc_destroy_owner_descriptor
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add an association between a target process and a PMC.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_link_target_process
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|ri
decl_stmt|;
name|struct
name|pmc_target
modifier|*
name|pt
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
operator|&&
name|pp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] Null pm %p or pp %p"
operator|,
name|__LINE__
operator|,
name|pm
operator|,
name|pp
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
argument_list|,
operator|(
literal|"[pmc,%d] Attaching a non-process-virtual pmc=%p to pid=%d"
operator|,
name|__LINE__
operator|,
name|pm
operator|,
name|pp
operator|->
name|pp_proc
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_refcnt
operator|>=
literal|0
operator|&&
name|pp
operator|->
name|pp_refcnt
operator|<
operator|(
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
operator|-
literal|1
operator|)
argument_list|,
operator|(
literal|"[pmc,%d] Illegal reference count %d for process record %p"
operator|,
name|__LINE__
operator|,
name|pp
operator|->
name|pp_refcnt
operator|,
operator|(
name|void
operator|*
operator|)
name|pp
operator|)
argument_list|)
expr_stmt|;
name|ri
operator|=
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|TLK
argument_list|,
literal|1
argument_list|,
literal|"link-target pmc=%p ri=%d pmc-process=%p"
argument_list|,
name|pm
argument_list|,
name|ri
argument_list|,
name|pp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|LIST_FOREACH
argument_list|(
argument|pt
argument_list|,
argument|&pm->pm_targets
argument_list|,
argument|pt_next
argument_list|)
if|if
condition|(
name|pt
operator|->
name|pt_process
operator|==
name|pp
condition|)
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] pp %p already in pmc %p targets"
operator|,
name|__LINE__
operator|,
name|pp
operator|,
name|pm
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MALLOC
argument_list|(
name|pt
argument_list|,
expr|struct
name|pmc_target
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_target
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|pt
operator|->
name|pt_process
operator|=
name|pp
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pm
operator|->
name|pm_targets
argument_list|,
name|pt
argument_list|,
name|pt_next
argument_list|)
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
argument_list|,
operator|(
name|uintptr_t
operator|)
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_owner
operator|->
name|po_owner
operator|==
name|pp
operator|->
name|pp_proc
condition|)
name|pm
operator|->
name|pm_flags
operator||=
name|PMC_F_ATTACHED_TO_OWNER
expr_stmt|;
comment|/* 	 * Initialize the per-process values at this row index. 	 */
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmcval
operator|=
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
operator|==
name|PMC_MODE_TS
condition|?
name|pm
operator|->
name|pm_sc
operator|.
name|pm_reloadcount
else|:
literal|0
expr_stmt|;
name|pp
operator|->
name|pp_refcnt
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Removes the association between a target process and a PMC.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_unlink_target_process
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|ri
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pmc_target
modifier|*
name|ptgt
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
operator|&&
name|pp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] Null pm %p or pp %p"
operator|,
name|__LINE__
operator|,
name|pm
operator|,
name|pp
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_refcnt
operator|>=
literal|1
operator|&&
name|pp
operator|->
name|pp_refcnt
operator|<
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
argument_list|,
operator|(
literal|"[pmc,%d] Illegal ref count %d on process record %p"
operator|,
name|__LINE__
operator|,
name|pp
operator|->
name|pp_refcnt
operator|,
operator|(
name|void
operator|*
operator|)
name|pp
operator|)
argument_list|)
expr_stmt|;
name|ri
operator|=
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|TUL
argument_list|,
literal|1
argument_list|,
literal|"unlink-target pmc=%p ri=%d pmc-process=%p"
argument_list|,
name|pm
argument_list|,
name|ri
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|==
name|pm
argument_list|,
operator|(
literal|"[pmc,%d] PMC ri %d mismatch pmc %p pp->[ri] %p"
operator|,
name|__LINE__
operator|,
name|ri
operator|,
name|pm
operator|,
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|=
name|NULL
expr_stmt|;
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmcval
operator|=
operator|(
name|pmc_value_t
operator|)
literal|0
expr_stmt|;
comment|/* Remove owner-specific flags */
if|if
condition|(
name|pm
operator|->
name|pm_owner
operator|->
name|po_owner
operator|==
name|pp
operator|->
name|pp_proc
condition|)
block|{
name|pp
operator|->
name|pp_flags
operator|&=
operator|~
name|PMC_PP_ENABLE_MSR_ACCESS
expr_stmt|;
name|pm
operator|->
name|pm_flags
operator|&=
operator|~
name|PMC_F_ATTACHED_TO_OWNER
expr_stmt|;
block|}
name|pp
operator|->
name|pp_refcnt
operator|--
expr_stmt|;
comment|/* Remove the target process from the PMC structure */
name|LIST_FOREACH
argument_list|(
argument|ptgt
argument_list|,
argument|&pm->pm_targets
argument_list|,
argument|pt_next
argument_list|)
if|if
condition|(
name|ptgt
operator|->
name|pt_process
operator|==
name|pp
condition|)
break|break;
name|KASSERT
argument_list|(
name|ptgt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] process %p (pp: %p) not found "
literal|"in pmc %p"
operator|,
name|__LINE__
operator|,
name|pp
operator|->
name|pp_proc
operator|,
name|pp
operator|,
name|pm
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ptgt
argument_list|,
name|pt_next
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ptgt
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
comment|/* if the PMC now lacks targets, send the owner a SIGIO */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|pm
operator|->
name|pm_targets
argument_list|)
condition|)
block|{
name|p
operator|=
name|pm
operator|->
name|pm_owner
operator|->
name|po_owner
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|SIG
argument_list|,
literal|2
argument_list|,
literal|"signalling proc=%p signal=%d"
argument_list|,
name|p
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check if PMC 'pm' may be attached to target process 't'.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_can_attach
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|proc
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|o
decl_stmt|;
comment|/* pmc owner */
name|struct
name|ucred
modifier|*
name|oc
decl_stmt|,
modifier|*
name|tc
decl_stmt|;
comment|/* owner, target credentials */
name|int
name|decline_attach
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * A PMC's owner can always attach that PMC to itself. 	 */
if|if
condition|(
operator|(
name|o
operator|=
name|pm
operator|->
name|pm_owner
operator|->
name|po_owner
operator|)
operator|==
name|t
condition|)
return|return
literal|0
return|;
name|PROC_LOCK
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|oc
operator|=
name|o
operator|->
name|p_ucred
expr_stmt|;
name|crhold
argument_list|(
name|oc
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tc
operator|=
name|t
operator|->
name|p_ucred
expr_stmt|;
name|crhold
argument_list|(
name|tc
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* 	 * The effective uid of the PMC owner should match at least one 	 * of the {effective,real,saved} uids of the target process. 	 */
name|decline_attach
operator|=
name|oc
operator|->
name|cr_uid
operator|!=
name|tc
operator|->
name|cr_uid
operator|&&
name|oc
operator|->
name|cr_uid
operator|!=
name|tc
operator|->
name|cr_svuid
operator|&&
name|oc
operator|->
name|cr_uid
operator|!=
name|tc
operator|->
name|cr_ruid
expr_stmt|;
comment|/* 	 * Every one of the target's group ids, must be in the owner's 	 * group list. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|decline_attach
operator|&&
name|i
operator|<
name|tc
operator|->
name|cr_ngroups
condition|;
name|i
operator|++
control|)
name|decline_attach
operator|=
operator|!
name|groupmember
argument_list|(
name|tc
operator|->
name|cr_groups
index|[
name|i
index|]
argument_list|,
name|oc
argument_list|)
expr_stmt|;
comment|/* check the read and saved gids too */
if|if
condition|(
name|decline_attach
operator|==
literal|0
condition|)
name|decline_attach
operator|=
operator|!
name|groupmember
argument_list|(
name|tc
operator|->
name|cr_rgid
argument_list|,
name|oc
argument_list|)
operator|||
operator|!
name|groupmember
argument_list|(
name|tc
operator|->
name|cr_svgid
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|tc
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oc
argument_list|)
expr_stmt|;
return|return
operator|!
name|decline_attach
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a process to a PMC.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_attach_one_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|int
name|ri
decl_stmt|;
name|char
modifier|*
name|fullpath
decl_stmt|,
modifier|*
name|freepath
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|ATT
argument_list|,
literal|2
argument_list|,
literal|"attach-one pm=%p ri=%d proc=%p (%d, %s)"
argument_list|,
name|pm
argument_list|,
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
comment|/* 	 * Locate the process descriptor corresponding to process 'p', 	 * allocating space as needed. 	 * 	 * Verify that rowindex 'pm_rowindex' is free in the process 	 * descriptor. 	 * 	 * If not, allocate space for a descriptor and link the 	 * process descriptor and PMC. 	 */
name|ri
operator|=
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|p
argument_list|,
name|PMC_FLAG_ALLOCATE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|==
name|pm
condition|)
comment|/* already present at slot [ri] */
return|return
name|EEXIST
return|;
if|if
condition|(
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|!=
name|NULL
condition|)
return|return
name|EBUSY
return|;
name|pmc_link_target_process
argument_list|(
name|pm
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
operator|&&
operator|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_ATTACHED_TO_OWNER
operator|)
operator|==
literal|0
condition|)
name|pm
operator|->
name|pm_flags
operator||=
name|PMC_F_NEEDS_LOGFILE
expr_stmt|;
name|pm
operator|->
name|pm_flags
operator||=
name|PMC_F_ATTACH_DONE
expr_stmt|;
comment|/* mark as attached */
comment|/* issue an attach event to a configured log file */
if|if
condition|(
name|pm
operator|->
name|pm_owner
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
block|{
name|pmc_getfilename
argument_list|(
name|p
operator|->
name|p_textvp
argument_list|,
operator|&
name|fullpath
argument_list|,
operator|&
name|freepath
argument_list|)
expr_stmt|;
name|pmclog_process_pmcattach
argument_list|(
name|pm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|fullpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|freepath
condition|)
name|FREE
argument_list|(
name|freepath
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
comment|/* mark process as using HWPMCs */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a process and optionally its children  */
end_comment

begin_function
specifier|static
name|int
name|pmc_attach_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|top
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|ATT
argument_list|,
literal|1
argument_list|,
literal|"attach pm=%p ri=%d proc=%p (%d, %s)"
argument_list|,
name|pm
argument_list|,
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
comment|/* 	 * If this PMC successfully allowed a GETMSR operation 	 * in the past, disallow further ATTACHes. 	 */
if|if
condition|(
operator|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_PP_ENABLE_MSR_ACCESS
operator|)
operator|!=
literal|0
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
operator|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_DESCENDANTS
operator|)
operator|==
literal|0
condition|)
return|return
name|pmc_attach_one_process
argument_list|(
name|p
argument_list|,
name|pm
argument_list|)
return|;
comment|/* 	 * Traverse all child processes, attaching them to 	 * this PMC. 	 */
name|sx_slock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|top
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_attach_one_process
argument_list|(
name|p
argument_list|,
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|p
operator|->
name|p_children
argument_list|)
condition|)
name|p
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_children
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|==
name|top
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_sibling
argument_list|)
condition|)
block|{
name|p
operator|=
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|p
operator|->
name|p_pptr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
operator|(
name|void
operator|)
name|pmc_detach_process
argument_list|(
name|top
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|done
label|:
name|sx_sunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Detach a process from a PMC.  If there are no other PMCs tracking  * this process, remove the process structure from its hash table.  If  * 'flags' contains PMC_FLAG_REMOVE, then free the process structure.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_detach_one_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|ri
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] null pm pointer"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|ri
operator|=
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|ATT
argument_list|,
literal|2
argument_list|,
literal|"detach-one pm=%p ri=%d proc=%p (%d, %s) flags=0x%x"
argument_list|,
name|pm
argument_list|,
name|ri
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ESRCH
return|;
if|if
condition|(
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|!=
name|pm
condition|)
return|return
name|EINVAL
return|;
name|pmc_unlink_target_process
argument_list|(
name|pm
argument_list|,
name|pp
argument_list|)
expr_stmt|;
comment|/* Issue a detach entry if a log file is configured */
if|if
condition|(
name|pm
operator|->
name|pm_owner
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
name|pmclog_process_pmcdetach
argument_list|(
name|pm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
comment|/* 	 * If there are no PMCs targetting this process, we remove its 	 * descriptor from the target hash table and unset the P_HWPMC 	 * flag in the struct proc. 	 */
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_refcnt
operator|>=
literal|0
operator|&&
name|pp
operator|->
name|pp_refcnt
operator|<
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
argument_list|,
operator|(
literal|"[pmc,%d] Illegal refcnt %d for process struct %p"
operator|,
name|__LINE__
operator|,
name|pp
operator|->
name|pp_refcnt
operator|,
name|pp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|pp_refcnt
operator|!=
literal|0
condition|)
comment|/* still a target of some PMC */
return|return
literal|0
return|;
name|pmc_remove_process_descriptor
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PMC_FLAG_REMOVE
condition|)
name|FREE
argument_list|(
name|pp
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Detach a process and optionally its descendants from a PMC.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_detach_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|top
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|ATT
argument_list|,
literal|1
argument_list|,
literal|"detach pm=%p ri=%d proc=%p (%d, %s)"
argument_list|,
name|pm
argument_list|,
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_DESCENDANTS
operator|)
operator|==
literal|0
condition|)
return|return
name|pmc_detach_one_process
argument_list|(
name|p
argument_list|,
name|pm
argument_list|,
name|PMC_FLAG_REMOVE
argument_list|)
return|;
comment|/* 	 * Traverse all children, detaching them from this PMC.  We 	 * ignore errors since we could be detaching a PMC from a 	 * partially attached proc tree. 	 */
name|sx_slock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|top
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|pmc_detach_one_process
argument_list|(
name|p
argument_list|,
name|pm
argument_list|,
name|PMC_FLAG_REMOVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|p
operator|->
name|p_children
argument_list|)
condition|)
name|p
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_children
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|==
name|top
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_sibling
argument_list|)
condition|)
block|{
name|p
operator|=
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|p
operator|->
name|p_pptr
expr_stmt|;
block|}
block|}
name|done
label|:
name|sx_sunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|pm
operator|->
name|pm_targets
argument_list|)
condition|)
name|pm
operator|->
name|pm_flags
operator|&=
operator|~
name|PMC_F_ATTACH_DONE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Thread context switch IN  */
end_comment

begin_function
specifier|static
name|void
name|pmc_process_csw_in
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
name|unsigned
name|int
name|ri
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pmc_cpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|pmc_value_t
name|newvalue
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|p
argument_list|,
name|PMC_FLAG_NONE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_proc
operator|==
name|td
operator|->
name|td_proc
argument_list|,
operator|(
literal|"[pmc,%d] not my thread state"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
comment|/* no preemption from this point */
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
comment|/* td->td_oncpu is invalid */
name|PMCDBG
argument_list|(
name|CSW
argument_list|,
name|SWI
argument_list|,
literal|1
argument_list|,
literal|"cpu=%d proc=%p (%d, %s) pp=%p"
argument_list|,
name|cpu
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[pmc,%d] wierd CPU id %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
expr_stmt|;
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pm
operator|=
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|KASSERT
argument_list|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
argument_list|,
operator|(
literal|"[pmc,%d] Target PMC in non-virtual mode (%d)"
operator|,
name|__LINE__
operator|,
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
operator|==
name|ri
argument_list|,
operator|(
literal|"[pmc,%d] Row index mismatch pmc %d != ri %d"
operator|,
name|__LINE__
operator|,
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Only PMCs that are marked as 'RUNNING' need 		 * be placed on hardware. 		 */
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_RUNNING
condition|)
continue|continue;
comment|/* increment PMC runcount */
name|atomic_add_rel_32
argument_list|(
operator|&
name|pm
operator|->
name|pm_runcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* configure the HWPMC we are going to use. */
name|md
operator|->
name|pmd_config_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|phw
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] null hw pointer"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|phw
operator|->
name|phw_pmc
operator|==
name|pm
argument_list|,
operator|(
literal|"[pmc,%d] hw->pmc %p != pmc %p"
operator|,
name|__LINE__
operator|,
name|phw
operator|->
name|phw_pmc
operator|,
name|pm
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Write out saved value and start the PMC. 		 * 		 * Sampling PMCs use a per-process value, while 		 * counting mode PMCs use a per-pmc value that is 		 * inherited across descendants. 		 */
if|if
condition|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
operator|==
name|PMC_MODE_TS
condition|)
block|{
name|mtx_pool_lock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|newvalue
operator|=
name|PMC_PCPU_SAVED
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
operator|=
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmcval
expr_stmt|;
name|mtx_pool_unlock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
operator|==
name|PMC_MODE_TC
argument_list|,
operator|(
literal|"[pmc,%d] illegal mode=%d"
operator|,
name|__LINE__
operator|,
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mtx_pool_lock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|newvalue
operator|=
name|PMC_PCPU_SAVED
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
operator|=
name|pm
operator|->
name|pm_gv
operator|.
name|pm_savedvalue
expr_stmt|;
name|mtx_pool_unlock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
name|PMCDBG
argument_list|(
name|CSW
argument_list|,
name|SWI
argument_list|,
literal|1
argument_list|,
literal|"cpu=%d ri=%d new=%jd"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|,
name|newvalue
argument_list|)
expr_stmt|;
name|md
operator|->
name|pmd_write_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|newvalue
argument_list|)
expr_stmt|;
name|md
operator|->
name|pmd_start_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * perform any other architecture/cpu dependent thread 	 * switch-in actions. 	 */
call|(
name|void
call|)
argument_list|(
operator|*
name|md
operator|->
name|pmd_switch_in
argument_list|)
argument_list|(
name|pc
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Thread context switch OUT.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_process_csw_out
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
name|enum
name|pmc_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|ri
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pmc_cpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|int64_t
name|tmp
decl_stmt|;
name|pmc_value_t
name|newvalue
decl_stmt|;
comment|/* 	 * Locate our process descriptor; this may be NULL if 	 * this process is exiting and we have already removed 	 * the process from the target process table. 	 * 	 * Note that due to kernel preemption, multiple 	 * context switches may happen while the process is 	 * exiting. 	 * 	 * Note also that if the target process cannot be 	 * found we still need to deconfigure any PMCs that 	 * are currently running on hardware. 	 */
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|p
argument_list|,
name|PMC_FLAG_NONE
argument_list|)
expr_stmt|;
comment|/* 	 * save PMCs 	 */
name|critical_enter
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
comment|/* td->td_oncpu is invalid */
name|PMCDBG
argument_list|(
name|CSW
argument_list|,
name|SWO
argument_list|,
literal|1
argument_list|,
literal|"cpu=%d proc=%p (%d, %s) pp=%p"
argument_list|,
name|cpu
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[pmc,%d wierd CPU id %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
expr_stmt|;
comment|/* 	 * When a PMC gets unlinked from a target PMC, it will 	 * be removed from the target's pp_pmc[] array. 	 * 	 * However, on a MP system, the target could have been 	 * executing on another CPU at the time of the unlink. 	 * So, at context switch OUT time, we need to look at 	 * the hardware to determine if a PMC is scheduled on 	 * it. 	 */
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
block|{
name|pm
operator|=
name|NULL
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|md
operator|->
name|pmd_get_config
argument_list|)
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
operator|&
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|NULL
condition|)
comment|/* nothing at this row index */
continue|continue;
name|mode
operator|=
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|mode
argument_list|)
condition|)
continue|continue;
comment|/* not a process virtual PMC */
name|KASSERT
argument_list|(
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
operator|==
name|ri
argument_list|,
operator|(
literal|"[pmc,%d] ri mismatch pmc(%d) ri(%d)"
operator|,
name|__LINE__
operator|,
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
comment|/* Stop hardware if not already stopped */
if|if
condition|(
name|pm
operator|->
name|pm_stalled
operator|==
literal|0
condition|)
name|md
operator|->
name|pmd_stop_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
comment|/* reduce this PMC's runcount */
name|atomic_subtract_rel_32
argument_list|(
operator|&
name|pm
operator|->
name|pm_runcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * If this PMC is associated with this process, 		 * save the reading. 		 */
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|&&
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|pm
operator|==
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
argument_list|,
operator|(
literal|"[pmc,%d] pm %p != pp_pmcs[%d] %p"
operator|,
name|__LINE__
operator|,
name|pm
operator|,
name|ri
operator|,
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_refcnt
operator|>
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] pp refcnt = %d"
operator|,
name|__LINE__
operator|,
name|pp
operator|->
name|pp_refcnt
operator|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|pmd_read_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
operator|&
name|newvalue
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|newvalue
operator|-
name|PMC_PCPU_SAVED
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|CSW
argument_list|,
name|SWI
argument_list|,
literal|1
argument_list|,
literal|"cpu=%d ri=%d tmp=%jd"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|PMC_MODE_TS
condition|)
block|{
comment|/* 				 * For sampling process-virtual PMCs, 				 * we expect the count to be 				 * decreasing as the 'value' 				 * programmed into the PMC is the 				 * number of events to be seen till 				 * the next sampling interrupt. 				 */
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
name|tmp
operator|+=
name|pm
operator|->
name|pm_sc
operator|.
name|pm_reloadcount
expr_stmt|;
name|mtx_pool_lock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmcval
operator|-=
name|tmp
expr_stmt|;
if|if
condition|(
operator|(
name|int64_t
operator|)
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmcval
operator|<
literal|0
condition|)
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmcval
operator|+=
name|pm
operator|->
name|pm_sc
operator|.
name|pm_reloadcount
expr_stmt|;
name|mtx_pool_unlock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * For counting process-virtual PMCs, 				 * we expect the count to be 				 * increasing monotonically, modulo a 64 				 * bit wraparound. 				 */
name|KASSERT
argument_list|(
operator|(
name|int64_t
operator|)
name|tmp
operator|>=
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] negative increment cpu=%d "
literal|"ri=%d newvalue=%jx saved=%jx "
literal|"incr=%jx"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|,
name|newvalue
operator|,
name|PMC_PCPU_SAVED
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
operator|,
name|tmp
operator|)
argument_list|)
expr_stmt|;
name|mtx_pool_lock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_gv
operator|.
name|pm_savedvalue
operator|+=
name|tmp
expr_stmt|;
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmcval
operator|+=
name|tmp
expr_stmt|;
name|mtx_pool_unlock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_LOG_PROCCSW
condition|)
name|pmclog_process_proccsw
argument_list|(
name|pm
argument_list|,
name|pp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* mark hardware as free */
name|md
operator|->
name|pmd_config_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * perform any other architecture/cpu dependent thread 	 * switch out functions. 	 */
call|(
name|void
call|)
argument_list|(
operator|*
name|md
operator|->
name|pmd_switch_out
argument_list|)
argument_list|(
name|pc
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log a KLD operation.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_process_kld_load
parameter_list|(
name|struct
name|pmckern_map_in
modifier|*
name|pkm
parameter_list|)
block|{
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
comment|/* 	 * Notify owners of system sampling PMCs about KLD operations. 	 */
name|LIST_FOREACH
argument_list|(
argument|po
argument_list|,
argument|&pmc_ss_owners
argument_list|,
argument|po_ssnext
argument_list|)
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
name|pmclog_process_map_in
argument_list|(
name|po
argument_list|,
operator|(
name|pid_t
operator|)
operator|-
literal|1
argument_list|,
name|pkm
operator|->
name|pm_address
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkm
operator|->
name|pm_file
argument_list|)
expr_stmt|;
comment|/* 	 * TODO: Notify owners of (all) process-sampling PMCs too. 	 */
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|pmc_process_kld_unload
parameter_list|(
name|struct
name|pmckern_map_out
modifier|*
name|pkm
parameter_list|)
block|{
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|po
argument_list|,
argument|&pmc_ss_owners
argument_list|,
argument|po_ssnext
argument_list|)
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
name|pmclog_process_map_out
argument_list|(
name|po
argument_list|,
operator|(
name|pid_t
operator|)
operator|-
literal|1
argument_list|,
name|pkm
operator|->
name|pm_address
argument_list|,
name|pkm
operator|->
name|pm_address
operator|+
name|pkm
operator|->
name|pm_size
argument_list|)
expr_stmt|;
comment|/* 	 * TODO: Notify owners of process-sampling PMCs. 	 */
block|}
end_function

begin_comment
comment|/*  * A mapping change for a process.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_process_mmap
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|pmckern_map_in
modifier|*
name|pkm
parameter_list|)
block|{
name|int
name|ri
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|char
modifier|*
name|fullpath
decl_stmt|,
modifier|*
name|freepath
decl_stmt|;
specifier|const
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
specifier|const
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|freepath
operator|=
name|fullpath
operator|=
name|NULL
expr_stmt|;
name|pmc_getfilename
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|pkm
operator|->
name|pm_file
argument_list|,
operator|&
name|fullpath
argument_list|,
operator|&
name|freepath
argument_list|)
expr_stmt|;
name|pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
comment|/* Inform owners of all system-wide sampling PMCs. */
name|LIST_FOREACH
argument_list|(
argument|po
argument_list|,
argument|&pmc_ss_owners
argument_list|,
argument|po_ssnext
argument_list|)
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
name|pmclog_process_map_in
argument_list|(
name|po
argument_list|,
name|pid
argument_list|,
name|pkm
operator|->
name|pm_address
argument_list|,
name|fullpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Inform sampling PMC owners tracking this process. 	 */
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
if|if
condition|(
operator|(
name|pm
operator|=
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
operator|!=
name|NULL
operator|&&
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
name|pmclog_process_map_in
argument_list|(
name|pm
operator|->
name|pm_owner
argument_list|,
name|pid
argument_list|,
name|pkm
operator|->
name|pm_address
argument_list|,
name|fullpath
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|freepath
condition|)
name|FREE
argument_list|(
name|freepath
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log an munmap request.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_process_munmap
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|pmckern_map_out
modifier|*
name|pkm
parameter_list|)
block|{
name|int
name|ri
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
specifier|const
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
specifier|const
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|po
argument_list|,
argument|&pmc_ss_owners
argument_list|,
argument|po_ssnext
argument_list|)
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
name|pmclog_process_map_out
argument_list|(
name|po
argument_list|,
name|pid
argument_list|,
name|pkm
operator|->
name|pm_address
argument_list|,
name|pkm
operator|->
name|pm_address
operator|+
name|pkm
operator|->
name|pm_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
if|if
condition|(
operator|(
name|pm
operator|=
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
operator|!=
name|NULL
operator|&&
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
name|pmclog_process_map_out
argument_list|(
name|pm
operator|->
name|pm_owner
argument_list|,
name|pid
argument_list|,
name|pkm
operator|->
name|pm_address
argument_list|,
name|pkm
operator|->
name|pm_address
operator|+
name|pkm
operator|->
name|pm_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The 'hook' invoked from the kernel proper  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|pmc_hooknames
index|[]
init|=
block|{
comment|/* these strings correspond to PMC_FN_* in<sys/pmckern.h> */
literal|""
block|,
literal|"EXEC"
block|,
literal|"CSW-IN"
block|,
literal|"CSW-OUT"
block|,
literal|"SAMPLE"
block|,
literal|"KLDLOAD"
block|,
literal|"KLDUNLOAD"
block|,
literal|"MMAP"
block|,
literal|"MUNMAP"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|pmc_hook_handler
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|function
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|PMH
argument_list|,
literal|1
argument_list|,
literal|"hook td=%p func=%d \"%s\" arg=%p"
argument_list|,
name|td
argument_list|,
name|function
argument_list|,
name|pmc_hooknames
index|[
name|function
index|]
argument_list|,
name|arg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|function
condition|)
block|{
comment|/* 	 * Process exec() 	 */
case|case
name|PMC_FN_PROCESS_EXEC
case|:
block|{
name|char
modifier|*
name|fullpath
decl_stmt|,
modifier|*
name|freepath
decl_stmt|;
name|unsigned
name|int
name|ri
decl_stmt|;
name|int
name|is_using_hwpmcs
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|struct
name|pmckern_procexec
modifier|*
name|pk
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|pmc_getfilename
argument_list|(
name|p
operator|->
name|p_textvp
argument_list|,
operator|&
name|fullpath
argument_list|,
operator|&
name|freepath
argument_list|)
expr_stmt|;
name|pk
operator|=
operator|(
expr|struct
name|pmckern_procexec
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Inform owners of SS mode PMCs of the exec event. */
name|LIST_FOREACH
argument_list|(
argument|po
argument_list|,
argument|&pmc_ss_owners
argument_list|,
argument|po_ssnext
argument_list|)
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
name|pmclog_process_procexec
argument_list|(
name|po
argument_list|,
name|PMC_ID_INVALID
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|pk
operator|->
name|pm_entryaddr
argument_list|,
name|fullpath
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|is_using_hwpmcs
operator|=
name|p
operator|->
name|p_flag
operator|&
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_using_hwpmcs
condition|)
block|{
if|if
condition|(
name|freepath
condition|)
name|FREE
argument_list|(
name|freepath
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * PMCs are not inherited across an exec():  remove any 		 * PMCs that this process is the owner of. 		 */
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_find_owner_descriptor
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pmc_remove_owner
argument_list|(
name|po
argument_list|)
expr_stmt|;
name|pmc_destroy_owner_descriptor
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the process being exec'ed is not the target of any 		 * PMC, we are done. 		 */
if|if
condition|(
operator|(
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|freepath
condition|)
name|FREE
argument_list|(
name|freepath
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Log the exec event to all monitoring owners.  Skip 		 * owners who have already recieved the event because 		 * they had system sampling PMCs active. 		 */
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
if|if
condition|(
operator|(
name|pm
operator|=
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
operator|!=
name|NULL
condition|)
block|{
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
if|if
condition|(
name|po
operator|->
name|po_sscount
operator|==
literal|0
operator|&&
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
name|pmclog_process_procexec
argument_list|(
name|po
argument_list|,
name|pm
operator|->
name|pm_id
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|pk
operator|->
name|pm_entryaddr
argument_list|,
name|fullpath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freepath
condition|)
name|FREE
argument_list|(
name|freepath
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|EXC
argument_list|,
literal|1
argument_list|,
literal|"exec proc=%p (%d, %s) cred-changed=%d"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|pk
operator|->
name|pm_credentialschanged
argument_list|)
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|pm_credentialschanged
operator|==
literal|0
condition|)
comment|/* no change */
break|break;
comment|/* 		 * If the newly exec()'ed process has a different credential 		 * than before, allow it to be the target of a PMC only if 		 * the PMC's owner has sufficient priviledge. 		 */
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
if|if
condition|(
operator|(
name|pm
operator|=
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|pmc_can_attach
argument_list|(
name|pm
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
operator|!=
literal|0
condition|)
name|pmc_detach_one_process
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|pm
argument_list|,
name|PMC_FLAG_NONE
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_refcnt
operator|>=
literal|0
operator|&&
name|pp
operator|->
name|pp_refcnt
operator|<
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
argument_list|,
operator|(
literal|"[pmc,%d] Illegal ref count %d on pp %p"
operator|,
name|__LINE__
operator|,
name|pp
operator|->
name|pp_refcnt
operator|,
name|pp
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * If this process is no longer the target of any 		 * PMCs, we can remove the process entry and free 		 * up space. 		 */
if|if
condition|(
name|pp
operator|->
name|pp_refcnt
operator|==
literal|0
condition|)
block|{
name|pmc_remove_process_descriptor
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pp
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|PMC_FN_CSW_IN
case|:
name|pmc_process_csw_in
argument_list|(
name|td
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMC_FN_CSW_OUT
case|:
name|pmc_process_csw_out
argument_list|(
name|td
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Process accumulated PC samples. 	 * 	 * This function is expected to be called by hardclock() for 	 * each CPU that has accumulated PC samples. 	 * 	 * This function is to be executed on the CPU whose samples 	 * are being processed. 	 */
case|case
name|PMC_FN_DO_SAMPLES
case|:
comment|/* 		 * Clear the cpu specific bit in the CPU mask before 		 * do the rest of the processing.  If the NMI handler 		 * gets invoked after the "atomic_clear_int()" call 		 * below but before "pmc_process_samples()" gets 		 * around to processing the interrupt, then we will 		 * come back here at the next hardclock() tick (and 		 * may find nothing to do if "pmc_process_samples()" 		 * had already processed the interrupt).  We don't 		 * lose the interrupt sample. 		 */
name|atomic_clear_int
argument_list|(
operator|&
name|pmc_cpumask
argument_list|,
operator|(
literal|1
operator|<<
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|pmc_process_samples
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMC_FN_KLD_LOAD
case|:
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|pmc_process_kld_load
argument_list|(
operator|(
expr|struct
name|pmckern_map_in
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMC_FN_KLD_UNLOAD
case|:
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|pmc_process_kld_unload
argument_list|(
operator|(
expr|struct
name|pmckern_map_out
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMC_FN_MMAP
case|:
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|pmc_process_mmap
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|pmckern_map_in
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMC_FN_MUNMAP
case|:
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|pmc_process_munmap
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|pmckern_map_out
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] unknown hook %d\n"
operator|,
name|__LINE__
operator|,
name|function
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * allocate a 'struct pmc_owner' descriptor in the owner hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|pmc_owner
modifier|*
name|pmc_allocate_owner_descriptor
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
name|hindex
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_ownerhash
modifier|*
name|poh
decl_stmt|;
name|hindex
operator|=
name|PMC_HASH_PTR
argument_list|(
name|p
argument_list|,
name|pmc_ownerhashmask
argument_list|)
expr_stmt|;
name|poh
operator|=
operator|&
name|pmc_ownerhash
index|[
name|hindex
index|]
expr_stmt|;
comment|/* allocate space for N pointers and one descriptor struct */
name|MALLOC
argument_list|(
name|po
argument_list|,
expr|struct
name|pmc_owner
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_owner
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|po
operator|->
name|po_sscount
operator|=
name|po
operator|->
name|po_error
operator|=
name|po
operator|->
name|po_flags
operator|=
literal|0
expr_stmt|;
name|po
operator|->
name|po_file
operator|=
name|NULL
expr_stmt|;
name|po
operator|->
name|po_owner
operator|=
name|p
expr_stmt|;
name|po
operator|->
name|po_kthread
operator|=
name|NULL
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|po
operator|->
name|po_pmcs
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|poh
argument_list|,
name|po
argument_list|,
name|po_next
argument_list|)
expr_stmt|;
comment|/* insert into hash table */
name|TAILQ_INIT
argument_list|(
operator|&
name|po
operator|->
name|po_logbuffers
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|,
literal|"pmc-owner-mtx"
argument_list|,
literal|"pmc-per-proc"
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|OWN
argument_list|,
name|ALL
argument_list|,
literal|1
argument_list|,
literal|"allocate-owner proc=%p (%d, %s) pmc-owner=%p"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|po
argument_list|)
expr_stmt|;
return|return
name|po
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmc_destroy_owner_descriptor
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
block|{
name|PMCDBG
argument_list|(
name|OWN
argument_list|,
name|REL
argument_list|,
literal|1
argument_list|,
literal|"destroy-owner po=%p proc=%p (%d, %s)"
argument_list|,
name|po
argument_list|,
name|po
operator|->
name|po_owner
argument_list|,
name|po
operator|->
name|po_owner
operator|->
name|p_pid
argument_list|,
name|po
operator|->
name|po_owner
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|po
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * find the descriptor corresponding to process 'p', adding or removing it  * as specified by 'mode'.  */
end_comment

begin_function
specifier|static
name|struct
name|pmc_process
modifier|*
name|pmc_find_process_descriptor
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|uint32_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|hindex
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|,
modifier|*
name|ppnew
decl_stmt|;
name|struct
name|pmc_processhash
modifier|*
name|pph
decl_stmt|;
name|hindex
operator|=
name|PMC_HASH_PTR
argument_list|(
name|p
argument_list|,
name|pmc_processhashmask
argument_list|)
expr_stmt|;
name|pph
operator|=
operator|&
name|pmc_processhash
index|[
name|hindex
index|]
expr_stmt|;
name|ppnew
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Pre-allocate memory in the FIND_ALLOCATE case since we 	 * cannot call malloc(9) once we hold a spin lock. 	 */
if|if
condition|(
name|mode
operator|&
name|PMC_FLAG_ALLOCATE
condition|)
block|{
comment|/* allocate additional space for 'n' pmc pointers */
name|MALLOC
argument_list|(
name|ppnew
argument_list|,
expr|struct
name|pmc_process
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_process
argument_list|)
operator|+
name|md
operator|->
name|pmd_npmc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_targetstate
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|pmc_processhash_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|pph
argument_list|,
argument|pp_next
argument_list|)
if|if
condition|(
name|pp
operator|->
name|pp_proc
operator|==
name|p
condition|)
break|break;
if|if
condition|(
operator|(
name|mode
operator|&
name|PMC_FLAG_REMOVE
operator|)
operator|&&
name|pp
operator|!=
name|NULL
condition|)
name|LIST_REMOVE
argument_list|(
name|pp
argument_list|,
name|pp_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|PMC_FLAG_ALLOCATE
operator|)
operator|&&
name|pp
operator|==
name|NULL
operator|&&
name|ppnew
operator|!=
name|NULL
condition|)
block|{
name|ppnew
operator|->
name|pp_proc
operator|=
name|p
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|pph
argument_list|,
name|ppnew
argument_list|,
name|pp_next
argument_list|)
expr_stmt|;
name|pp
operator|=
name|ppnew
expr_stmt|;
name|ppnew
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|pmc_processhash_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|&&
name|ppnew
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|ppnew
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
return|return
name|pp
return|;
block|}
end_function

begin_comment
comment|/*  * remove a process descriptor from the process hash table.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_remove_process_descriptor
parameter_list|(
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_refcnt
operator|==
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] Removing process descriptor %p with count %d"
operator|,
name|__LINE__
operator|,
name|pp
operator|,
name|pp
operator|->
name|pp_refcnt
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|pmc_processhash_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pp
argument_list|,
name|pp_next
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|pmc_processhash_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * find an owner descriptor corresponding to proc 'p'  */
end_comment

begin_function
specifier|static
name|struct
name|pmc_owner
modifier|*
name|pmc_find_owner_descriptor
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
name|hindex
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_ownerhash
modifier|*
name|poh
decl_stmt|;
name|hindex
operator|=
name|PMC_HASH_PTR
argument_list|(
name|p
argument_list|,
name|pmc_ownerhashmask
argument_list|)
expr_stmt|;
name|poh
operator|=
operator|&
name|pmc_ownerhash
index|[
name|hindex
index|]
expr_stmt|;
name|po
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|po
argument_list|,
argument|poh
argument_list|,
argument|po_next
argument_list|)
if|if
condition|(
name|po
operator|->
name|po_owner
operator|==
name|p
condition|)
break|break;
name|PMCDBG
argument_list|(
name|OWN
argument_list|,
name|FND
argument_list|,
literal|1
argument_list|,
literal|"find-owner proc=%p (%d, %s) hindex=0x%x -> "
literal|"pmc-owner=%p"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|hindex
argument_list|,
name|po
argument_list|)
expr_stmt|;
return|return
name|po
return|;
block|}
end_function

begin_comment
comment|/*  * pmc_allocate_pmc_descriptor  *  * Allocate a pmc descriptor and initialize its  * fields.  */
end_comment

begin_function
specifier|static
name|struct
name|pmc
modifier|*
name|pmc_allocate_pmc_descriptor
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pmc
modifier|*
name|pmc
decl_stmt|;
name|MALLOC
argument_list|(
name|pmc
argument_list|,
expr|struct
name|pmc
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmc
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc
operator|!=
name|NULL
condition|)
block|{
name|pmc
operator|->
name|pm_owner
operator|=
name|NULL
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|pmc
operator|->
name|pm_targets
argument_list|)
expr_stmt|;
block|}
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|ALL
argument_list|,
literal|1
argument_list|,
literal|"allocate-pmc -> pmc=%p"
argument_list|,
name|pmc
argument_list|)
expr_stmt|;
return|return
name|pmc
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a pmc descriptor.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_destroy_pmc_descriptor
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pm
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_DELETED
operator|||
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_FREE
argument_list|,
operator|(
literal|"[pmc,%d] destroying non-deleted PMC"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|pm
operator|->
name|pm_targets
argument_list|)
argument_list|,
operator|(
literal|"[pmc,%d] destroying pmc with targets"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_owner
operator|==
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] destroying pmc attached to an owner"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_runcount
operator|==
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] pmc has non-zero run count %d"
operator|,
name|__LINE__
operator|,
name|pm
operator|->
name|pm_runcount
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|pmc_wait_for_pmc_idle
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
specifier|volatile
name|int
name|maxloop
decl_stmt|;
name|maxloop
operator|=
literal|100
operator|*
name|mp_ncpus
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Loop (with a forced context switch) till the PMC's runcount 	 * comes down to zero. 	 */
while|while
condition|(
name|atomic_load_acq_32
argument_list|(
operator|&
name|pm
operator|->
name|pm_runcount
argument_list|)
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|maxloop
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|maxloop
operator|>
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] (ri%d, rc%d) waiting too long for "
literal|"pmc to be free"
operator|,
name|__LINE__
operator|,
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
operator|,
name|pm
operator|->
name|pm_runcount
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmc_force_context_switch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function does the following things:  *  *  - detaches the PMC from hardware  *  - unlinks all target threads that were attached to it  *  - removes the PMC from its owner's list  *  - destroy's the PMC private mutex  *  * Once this function completes, the given pmc pointer can be safely  * FREE'd by the caller.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_release_pmc_descriptor
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|u_int
name|ri
decl_stmt|,
name|cpu
decl_stmt|;
name|enum
name|pmc_mode
name|mode
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|struct
name|pmc_target
modifier|*
name|ptgt
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
argument_list|,
operator|(
literal|"[pmc,%d] null pmc"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|ri
operator|=
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|mode
operator|=
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|REL
argument_list|,
literal|1
argument_list|,
literal|"release-pmc pmc=%p ri=%d mode=%d"
argument_list|,
name|pm
argument_list|,
name|ri
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* 	 * First, we take the PMC off hardware. 	 */
name|cpu
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* 		 * A system mode PMC runs on a specific CPU.  Switch 		 * to this CPU and turn hardware off. 		 */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|PMC_TO_CPU
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
comment|/* switch off non-stalled CPUs */
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
operator|&&
name|pm
operator|->
name|pm_stalled
operator|==
literal|0
condition|)
block|{
name|phw
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|phw
operator|->
name|phw_pmc
operator|==
name|pm
argument_list|,
operator|(
literal|"[pmc, %d] pmc ptr ri(%d) hw(%p) pm(%p)"
operator|,
name|__LINE__
operator|,
name|ri
operator|,
name|phw
operator|->
name|phw_pmc
operator|,
name|pm
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|REL
argument_list|,
literal|2
argument_list|,
literal|"stopping cpu=%d ri=%d"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|md
operator|->
name|pmd_stop_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|REL
argument_list|,
literal|2
argument_list|,
literal|"decfg cpu=%d ri=%d"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|md
operator|->
name|pmd_config_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
comment|/* adjust the global and process count of SS mode PMCs */
if|if
condition|(
name|mode
operator|==
name|PMC_MODE_SS
operator|&&
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
condition|)
block|{
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
name|po
operator|->
name|po_sscount
operator|--
expr_stmt|;
if|if
condition|(
name|po
operator|->
name|po_sscount
operator|==
literal|0
condition|)
block|{
name|atomic_subtract_rel_int
argument_list|(
operator|&
name|pmc_ss_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|po
argument_list|,
name|po_ssnext
argument_list|)
expr_stmt|;
block|}
block|}
name|pm
operator|->
name|pm_state
operator|=
name|PMC_STATE_DELETED
expr_stmt|;
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
comment|/* 		 * We could have references to this PMC structure in 		 * the per-cpu sample queues.  Wait for the queue to 		 * drain. 		 */
name|pmc_wait_for_pmc_idle
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* 		 * A virtual PMC could be running on multiple CPUs at 		 * a given instant. 		 * 		 * By marking its state as DELETED, we ensure that 		 * this PMC is never further scheduled on hardware. 		 * 		 * Then we wait till all CPUs are done with this PMC. 		 */
name|pm
operator|->
name|pm_state
operator|=
name|PMC_STATE_DELETED
expr_stmt|;
comment|/* Wait for the PMCs runcount to come to zero. */
name|pmc_wait_for_pmc_idle
argument_list|(
name|pm
argument_list|)
expr_stmt|;
comment|/* 		 * At this point the PMC is off all CPUs and cannot be 		 * freshly scheduled onto a CPU.  It is now safe to 		 * unlink all targets from this PMC.  If a 		 * process-record's refcount falls to zero, we remove 		 * it from the hash table.  The module-wide SX lock 		 * protects us from races. 		 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|ptgt
argument_list|,
argument|&pm->pm_targets
argument_list|,
argument|pt_next
argument_list|,
argument|tmp
argument_list|)
block|{
name|pp
operator|=
name|ptgt
operator|->
name|pt_process
expr_stmt|;
name|pmc_unlink_target_process
argument_list|(
name|pm
argument_list|,
name|pp
argument_list|)
expr_stmt|;
comment|/* frees 'ptgt' */
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|REL
argument_list|,
literal|3
argument_list|,
literal|"pp->refcnt=%d"
argument_list|,
name|pp
operator|->
name|pp_refcnt
argument_list|)
expr_stmt|;
comment|/* 			 * If the target process record shows that no 			 * PMCs are attached to it, reclaim its space. 			 */
if|if
condition|(
name|pp
operator|->
name|pp_refcnt
operator|==
literal|0
condition|)
block|{
name|pmc_remove_process_descriptor
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pp
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
block|}
name|cpu
operator|=
name|curthread
operator|->
name|td_oncpu
expr_stmt|;
comment|/* setup cpu for pmd_release() */
block|}
comment|/* 	 * Release any MD resources 	 */
operator|(
name|void
operator|)
name|md
operator|->
name|pmd_release_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|pm
argument_list|)
expr_stmt|;
comment|/* 	 * Update row disposition 	 */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
name|PMC_UNMARK_ROW_STANDALONE
argument_list|(
name|ri
argument_list|)
expr_stmt|;
else|else
name|PMC_UNMARK_ROW_THREAD
argument_list|(
name|ri
argument_list|)
expr_stmt|;
comment|/* unlink from the owner's list */
if|if
condition|(
name|pm
operator|->
name|pm_owner
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|pm
argument_list|,
name|pm_next
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_owner
operator|=
name|NULL
expr_stmt|;
block|}
name|pmc_destroy_pmc_descriptor
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Register an owner and a pmc.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_register_owner
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pmc
parameter_list|)
block|{
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_find_owner_descriptor
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_allocate_owner_descriptor
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|KASSERT
argument_list|(
name|pmc
operator|->
name|pm_owner
operator|==
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] attempting to own an initialized PMC"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|pmc
operator|->
name|pm_owner
operator|=
name|po
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|po
operator|->
name|po_pmcs
argument_list|,
name|pmc
argument_list|,
name|pm_next
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
name|pmclog_process_pmcallocate
argument_list|(
name|pmc
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|REG
argument_list|,
literal|1
argument_list|,
literal|"register-owner pmc-owner=%p pmc=%p"
argument_list|,
name|po
argument_list|,
name|pmc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current row disposition:  * == 0 => FREE  *> 0 => PROCESS MODE  *< 0 => SYSTEM MODE  */
end_comment

begin_function
name|int
name|pmc_getrowdisp
parameter_list|(
name|int
name|ri
parameter_list|)
block|{
return|return
name|pmc_pmcdisp
index|[
name|ri
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Check if a PMC at row index 'ri' can be allocated to the current  * process.  *  * Allocation can fail if:  *   - the current process is already being profiled by a PMC at index 'ri',  *     attached to it via OP_PMCATTACH.  *   - the current process has already allocated a PMC at index 'ri'  *     via OP_ALLOCATE.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_can_allocate_rowindex
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
name|ri
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
name|enum
name|pmc_mode
name|mode
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|ALR
argument_list|,
literal|1
argument_list|,
literal|"can-allocate-rowindex proc=%p (%d, %s) ri=%d "
literal|"cpu=%d"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|ri
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
comment|/* 	 * We shouldn't have already allocated a process-mode PMC at 	 * row index 'ri'. 	 * 	 * We shouldn't have allocated a system-wide PMC on the same 	 * CPU and same RI. 	 */
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_find_owner_descriptor
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|LIST_FOREACH
argument_list|(
argument|pm
argument_list|,
argument|&po->po_pmcs
argument_list|,
argument|pm_next
argument_list|)
block|{
if|if
condition|(
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
operator|==
name|ri
condition|)
block|{
name|mode
operator|=
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|EEXIST
return|;
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|int
operator|)
name|PMC_TO_CPU
argument_list|(
name|pm
argument_list|)
operator|==
name|cpu
condition|)
return|return
name|EEXIST
return|;
block|}
block|}
comment|/* 	 * We also shouldn't be the target of any PMC at this index 	 * since otherwise a PMC_ATTACH to ourselves will fail. 	 */
if|if
condition|(
operator|(
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
condition|)
return|return
name|EEXIST
return|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|ALR
argument_list|,
literal|2
argument_list|,
literal|"can-allocate-rowindex proc=%p (%d, %s) ri=%d ok"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|ri
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Check if a given PMC at row index 'ri' can be currently used in  * mode 'mode'.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_can_allocate_row
parameter_list|(
name|int
name|ri
parameter_list|,
name|enum
name|pmc_mode
name|mode
parameter_list|)
block|{
name|enum
name|pmc_disp
name|disp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|ALR
argument_list|,
literal|1
argument_list|,
literal|"can-allocate-row ri=%d mode=%d"
argument_list|,
name|ri
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
condition|)
name|disp
operator|=
name|PMC_DISP_STANDALONE
expr_stmt|;
else|else
name|disp
operator|=
name|PMC_DISP_THREAD
expr_stmt|;
comment|/* 	 * check disposition for PMC row 'ri': 	 * 	 * Expected disposition		Row-disposition		Result 	 * 	 * STANDALONE			STANDALONE or FREE	proceed 	 * STANDALONE			THREAD			fail 	 * THREAD			THREAD or FREE		proceed 	 * THREAD			STANDALONE		fail 	 */
if|if
condition|(
operator|!
name|PMC_ROW_DISP_IS_FREE
argument_list|(
name|ri
argument_list|)
operator|&&
operator|!
operator|(
name|disp
operator|==
name|PMC_DISP_THREAD
operator|&&
name|PMC_ROW_DISP_IS_THREAD
argument_list|(
name|ri
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|disp
operator|==
name|PMC_DISP_STANDALONE
operator|&&
name|PMC_ROW_DISP_IS_STANDALONE
argument_list|(
name|ri
argument_list|)
operator|)
condition|)
return|return
name|EBUSY
return|;
comment|/* 	 * All OK 	 */
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|ALR
argument_list|,
literal|2
argument_list|,
literal|"can-allocate-row ri=%d mode=%d ok"
argument_list|,
name|ri
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Find a PMC descriptor with user handle 'pmcid' for thread 'td'.  */
end_comment

begin_function
specifier|static
name|struct
name|pmc
modifier|*
name|pmc_find_pmc_descriptor_in_process
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|pmc_id_t
name|pmcid
parameter_list|)
block|{
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|KASSERT
argument_list|(
name|PMC_ID_TO_ROWINDEX
argument_list|(
name|pmcid
argument_list|)
operator|<
name|md
operator|->
name|pmd_npmc
argument_list|,
operator|(
literal|"[pmc,%d] Illegal pmc index %d (max %d)"
operator|,
name|__LINE__
operator|,
name|PMC_ID_TO_ROWINDEX
argument_list|(
name|pmcid
argument_list|)
operator|,
name|md
operator|->
name|pmd_npmc
operator|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pm
argument_list|,
argument|&po->po_pmcs
argument_list|,
argument|pm_next
argument_list|)
if|if
condition|(
name|pm
operator|->
name|pm_id
operator|==
name|pmcid
condition|)
return|return
name|pm
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmc_find_pmc
parameter_list|(
name|pmc_id_t
name|pmcid
parameter_list|,
name|struct
name|pmc
modifier|*
modifier|*
name|pmc
parameter_list|)
block|{
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|FND
argument_list|,
literal|1
argument_list|,
literal|"find-pmc id=%d"
argument_list|,
name|pmcid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_find_owner_descriptor
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ESRCH
return|;
if|if
condition|(
operator|(
name|pm
operator|=
name|pmc_find_pmc_descriptor_in_process
argument_list|(
name|po
argument_list|,
name|pmcid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|FND
argument_list|,
literal|2
argument_list|,
literal|"find-pmc id=%d -> pmc=%p"
argument_list|,
name|pmcid
argument_list|,
name|pm
argument_list|)
expr_stmt|;
operator|*
name|pmc
operator|=
name|pm
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Start a PMC.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_start
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|cpu
decl_stmt|,
name|ri
decl_stmt|;
name|enum
name|pmc_mode
name|mode
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] null pm"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|ri
operator|=
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|OPS
argument_list|,
literal|1
argument_list|,
literal|"start pmc=%p mode=%d ri=%d"
argument_list|,
name|pm
argument_list|,
name|mode
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
if|if
condition|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* 		 * If a PMCATTACH has never been done on this PMC, 		 * attach it to its owner process. 		 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|pm
operator|->
name|pm_targets
argument_list|)
condition|)
name|error
operator|=
operator|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_ATTACH_DONE
operator|)
condition|?
name|ESRCH
else|:
name|pmc_attach_process
argument_list|(
name|po
operator|->
name|po_owner
argument_list|,
name|pm
argument_list|)
expr_stmt|;
comment|/* 		 * Disallow PMCSTART if a logfile is required but has not 		 * been configured yet. 		 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_NEEDS_LOGFILE
operator|)
operator|&&
operator|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EDOOFUS
expr_stmt|;
comment|/* 		 * If the PMC is attached to its owner, then force a context 		 * switch to ensure that the MD state gets set correctly. 		 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|pm
operator|->
name|pm_state
operator|=
name|PMC_STATE_RUNNING
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_ATTACHED_TO_OWNER
condition|)
name|pmc_force_context_switch
argument_list|()
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
comment|/* 	 * A system-wide PMC. 	 */
if|if
condition|(
operator|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_NEEDS_LOGFILE
operator|)
operator|&&
operator|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
operator|)
operator|==
literal|0
condition|)
return|return
name|EDOOFUS
return|;
comment|/* programming error */
comment|/* 	 * Add the owner to the global list if this is a system-wide 	 * sampling PMC. 	 */
if|if
condition|(
name|mode
operator|==
name|PMC_MODE_SS
condition|)
block|{
if|if
condition|(
name|po
operator|->
name|po_sscount
operator|==
literal|0
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pmc_ss_owners
argument_list|,
name|po
argument_list|,
name|po_ssnext
argument_list|)
expr_stmt|;
name|atomic_add_rel_int
argument_list|(
operator|&
name|pmc_ss_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|OPS
argument_list|,
literal|1
argument_list|,
literal|"po=%p in global list"
argument_list|,
name|po
argument_list|)
expr_stmt|;
block|}
name|po
operator|->
name|po_sscount
operator|++
expr_stmt|;
block|}
comment|/* TODO: dump system wide process mappings to the log? */
comment|/* 	 * Move to the CPU associated with this 	 * PMC, and start the hardware. 	 */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|PMC_TO_CPU
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
comment|/* 	 * global PMCs are configured at allocation time 	 * so write out the initial value and start the PMC. 	 */
name|pm
operator|->
name|pm_state
operator|=
name|PMC_STATE_RUNNING
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|md
operator|->
name|pmd_write_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|mode
argument_list|)
condition|?
name|pm
operator|->
name|pm_sc
operator|.
name|pm_reloadcount
else|:
name|pm
operator|->
name|pm_sc
operator|.
name|pm_initial
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|md
operator|->
name|pmd_start_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Stop a PMC.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_stop
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|,
name|error
decl_stmt|,
name|ri
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] null pmc"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|OPS
argument_list|,
literal|1
argument_list|,
literal|"stop pmc=%p mode=%d ri=%d"
argument_list|,
name|pm
argument_list|,
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|,
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_state
operator|=
name|PMC_STATE_STOPPED
expr_stmt|;
comment|/* 	 * If the PMC is a virtual mode one, changing the state to 	 * non-RUNNING is enough to ensure that the PMC never gets 	 * scheduled. 	 * 	 * If this PMC is current running on a CPU, then it will 	 * handled correctly at the time its target process is context 	 * switched out. 	 */
if|if
condition|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * A system-mode PMC.  Move to the CPU associated with 	 * this PMC, and stop the hardware.  We update the 	 * 'initial count' so that a subsequent PMCSTART will 	 * resume counting from the current hardware count. 	 */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|PMC_TO_CPU
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[pmc,%d] illegal cpu=%d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|ri
operator|=
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|md
operator|->
name|pmd_stop_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|md
operator|->
name|pmd_read_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
operator|&
name|pm
operator|->
name|pm_sc
operator|.
name|pm_initial
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
comment|/* remove this owner from the global list of SS PMC owners */
if|if
condition|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
operator|==
name|PMC_MODE_SS
condition|)
block|{
name|po
operator|->
name|po_sscount
operator|--
expr_stmt|;
if|if
condition|(
name|po
operator|->
name|po_sscount
operator|==
literal|0
condition|)
block|{
name|atomic_subtract_rel_int
argument_list|(
operator|&
name|pmc_ss_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|po
argument_list|,
name|po_ssnext
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|OPS
argument_list|,
literal|2
argument_list|,
literal|"po=%p removed from global list"
argument_list|,
name|po
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|pmc_op_to_name
index|[]
init|=
block|{
undef|#
directive|undef
name|__PMC_OP
define|#
directive|define
name|__PMC_OP
parameter_list|(
name|N
parameter_list|,
name|D
parameter_list|)
value|#N ,
name|__PMC_OPS
argument_list|()
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The syscall interface  */
end_comment

begin_define
define|#
directive|define
name|PMC_GET_SX_XLOCK
parameter_list|(
modifier|...
parameter_list|)
value|do {		\ 	sx_xlock(&pmc_sx);			\ 	if (pmc_hook == NULL) {			\ 		sx_xunlock(&pmc_sx);		\ 		return __VA_ARGS__;		\ 	}					\ } while (0)
end_define

begin_define
define|#
directive|define
name|PMC_DOWNGRADE_SX
parameter_list|()
value|do {			\ 	sx_downgrade(&pmc_sx);			\ 	is_sx_downgraded = 1;			\ } while (0)
end_define

begin_function
specifier|static
name|int
name|pmc_syscall_handler
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|syscall_args
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|is_sx_downgraded
decl_stmt|,
name|op
decl_stmt|;
name|struct
name|pmc_syscall_args
modifier|*
name|c
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|PMC_GET_SX_XLOCK
argument_list|(
name|ENOSYS
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|is_sx_downgraded
operator|=
literal|0
expr_stmt|;
name|c
operator|=
operator|(
expr|struct
name|pmc_syscall_args
operator|*
operator|)
name|syscall_args
expr_stmt|;
name|op
operator|=
name|c
operator|->
name|pmop_code
expr_stmt|;
name|arg
operator|=
name|c
operator|->
name|pmop_data
expr_stmt|;
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|PMS
argument_list|,
literal|1
argument_list|,
literal|"syscall op=%d \"%s\" arg=%p"
argument_list|,
name|op
argument_list|,
name|pmc_op_to_name
index|[
name|op
index|]
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|pmc_stats
operator|.
name|pm_syscalls
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* 	 * Configure a log file. 	 * 	 * XXX This OP will be reworked. 	 */
case|case
name|PMC_OP_CONFIGURELOG
case|:
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmckern_map_in
modifier|*
name|km
decl_stmt|,
modifier|*
name|kmbase
decl_stmt|;
name|struct
name|pmc_op_configurelog
name|cl
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|cl
argument_list|,
sizeof|sizeof
argument_list|(
name|cl
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* mark this process as owning a log file */
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_find_owner_descriptor
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_allocate_owner_descriptor
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
comment|/* 		 * If a valid fd was passed in, try to configure that, 		 * otherwise if 'fd' was less than zero and there was 		 * a log file configured, flush its buffers and 		 * de-configure it. 		 */
if|if
condition|(
name|cl
operator|.
name|pm_logfd
operator|>=
literal|0
condition|)
name|error
operator|=
name|pmclog_configure_log
argument_list|(
name|po
argument_list|,
name|cl
operator|.
name|pm_logfd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
block|{
name|pmclog_process_closelog
argument_list|(
name|po
argument_list|)
expr_stmt|;
name|error
operator|=
name|pmclog_flush
argument_list|(
name|po
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|pm
argument_list|,
argument|&po->po_pmcs
argument_list|,
argument|pm_next
argument_list|)
if|if
condition|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_NEEDS_LOGFILE
operator|&&
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
condition|)
name|pmc_stop
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|error
operator|=
name|pmclog_deconfigure_log
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* 		 * Log the current set of kernel modules. 		 */
name|kmbase
operator|=
name|linker_hwpmc_list_objects
argument_list|()
expr_stmt|;
for|for
control|(
name|km
operator|=
name|kmbase
init|;
name|km
operator|->
name|pm_file
operator|!=
name|NULL
condition|;
name|km
operator|++
control|)
block|{
name|PMCDBG
argument_list|(
name|LOG
argument_list|,
name|REG
argument_list|,
literal|1
argument_list|,
literal|"%s %p"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|km
operator|->
name|pm_file
argument_list|,
operator|(
name|void
operator|*
operator|)
name|km
operator|->
name|pm_address
argument_list|)
expr_stmt|;
name|pmclog_process_map_in
argument_list|(
name|po
argument_list|,
operator|(
name|pid_t
operator|)
operator|-
literal|1
argument_list|,
name|km
operator|->
name|pm_address
argument_list|,
name|km
operator|->
name|pm_file
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|kmbase
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Flush a log file. 	 */
case|case
name|PMC_OP_FLUSHLOG
case|:
block|{
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_find_owner_descriptor
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pmclog_flush
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Retrieve hardware configuration. 	 */
case|case
name|PMC_OP_GETCPUINFO
case|:
comment|/* CPU information */
block|{
name|struct
name|pmc_op_getcpuinfo
name|gci
decl_stmt|;
name|gci
operator|.
name|pm_cputype
operator|=
name|md
operator|->
name|pmd_cputype
expr_stmt|;
name|gci
operator|.
name|pm_ncpu
operator|=
name|mp_ncpus
expr_stmt|;
name|gci
operator|.
name|pm_npmc
operator|=
name|md
operator|->
name|pmd_npmc
expr_stmt|;
name|gci
operator|.
name|pm_nclass
operator|=
name|md
operator|->
name|pmd_nclass
expr_stmt|;
name|bcopy
argument_list|(
name|md
operator|->
name|pmd_classes
argument_list|,
operator|&
name|gci
operator|.
name|pm_classes
argument_list|,
sizeof|sizeof
argument_list|(
name|gci
operator|.
name|pm_classes
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|gci
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|gci
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Get module statistics 	 */
case|case
name|PMC_OP_GETDRIVERSTATS
case|:
block|{
name|struct
name|pmc_op_getdriverstats
name|gms
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|pmc_stats
argument_list|,
operator|&
name|gms
argument_list|,
sizeof|sizeof
argument_list|(
name|gms
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|gms
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|gms
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Retrieve module version number 	 */
case|case
name|PMC_OP_GETMODULEVERSION
case|:
block|{
name|uint32_t
name|cv
decl_stmt|,
name|modv
decl_stmt|;
comment|/* retrieve the client's idea of the ABI version */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|cv
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* don't service clients newer than our driver */
name|modv
operator|=
name|PMC_VERSION
expr_stmt|;
if|if
condition|(
operator|(
name|cv
operator|&
literal|0xFFFF0000
operator|)
operator|>
operator|(
name|modv
operator|&
literal|0xFFFF0000
operator|)
condition|)
block|{
name|error
operator|=
name|EPROGMISMATCH
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|modv
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Retrieve the state of all the PMCs on a given 	 * CPU. 	 */
case|case
name|PMC_OP_GETPMCINFO
case|:
block|{
name|uint32_t
name|cpu
decl_stmt|,
name|n
decl_stmt|,
name|npmc
decl_stmt|;
name|size_t
name|pmcinfo_size
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_info
modifier|*
name|p
decl_stmt|,
modifier|*
name|pmcinfo
decl_stmt|;
name|struct
name|pmc_op_getpmcinfo
modifier|*
name|gpi
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
name|PMC_DOWNGRADE_SX
argument_list|()
expr_stmt|;
name|gpi
operator|=
operator|(
expr|struct
name|pmc_op_getpmcinfo
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|&
name|gpi
operator|->
name|pm_cpu
argument_list|,
operator|&
name|cpu
argument_list|,
sizeof|sizeof
argument_list|(
name|cpu
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|cpu
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|mp_ncpus
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
comment|/* switch to CPU 'cpu' */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|npmc
operator|=
name|md
operator|->
name|pmd_npmc
expr_stmt|;
name|pmcinfo_size
operator|=
name|npmc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_info
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|pmcinfo
argument_list|,
expr|struct
name|pmc_info
operator|*
argument_list|,
name|pmcinfo_size
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|p
operator|=
name|pmcinfo
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|n
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|md
operator|->
name|pmd_describe
argument_list|(
name|cpu
argument_list|,
name|n
argument_list|,
name|p
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|PMC_ROW_DISP_IS_STANDALONE
argument_list|(
name|n
argument_list|)
condition|)
name|p
operator|->
name|pm_rowdisp
operator|=
name|PMC_DISP_STANDALONE
expr_stmt|;
elseif|else
if|if
condition|(
name|PMC_ROW_DISP_IS_THREAD
argument_list|(
name|n
argument_list|)
condition|)
name|p
operator|->
name|pm_rowdisp
operator|=
name|PMC_DISP_THREAD
expr_stmt|;
else|else
name|p
operator|->
name|pm_rowdisp
operator|=
name|PMC_DISP_FREE
expr_stmt|;
name|p
operator|->
name|pm_ownerpid
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|NULL
condition|)
comment|/* no PMC associated */
continue|continue;
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_owner
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] pmc_owner had a null proc pointer"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|pm_ownerpid
operator|=
name|po
operator|->
name|po_owner
operator|->
name|p_pid
expr_stmt|;
name|p
operator|->
name|pm_mode
operator|=
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|p
operator|->
name|pm_event
operator|=
name|pm
operator|->
name|pm_event
expr_stmt|;
name|p
operator|->
name|pm_flags
operator|=
name|pm
operator|->
name|pm_flags
expr_stmt|;
if|if
condition|(
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
name|p
operator|->
name|pm_reloadcount
operator|=
name|pm
operator|->
name|pm_sc
operator|.
name|pm_reloadcount
expr_stmt|;
block|}
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
comment|/* now copy out the PMC info collected */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|pmcinfo
argument_list|,
operator|&
name|gpi
operator|->
name|pm_pmcs
argument_list|,
name|pmcinfo_size
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pmcinfo
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Set the administrative state of a PMC.  I.e. whether 	 * the PMC is to be used or not. 	 */
case|case
name|PMC_OP_PMCADMIN
case|:
block|{
name|int
name|cpu
decl_stmt|,
name|ri
decl_stmt|;
name|enum
name|pmc_state
name|request
decl_stmt|;
name|struct
name|pmc_cpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|struct
name|pmc_op_pmcadmin
name|pma
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|==
name|curthread
argument_list|,
operator|(
literal|"[pmc,%d] td != curthread"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_PMC_MANAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|pma
argument_list|,
sizeof|sizeof
argument_list|(
name|pma
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|cpu
operator|=
name|pma
operator|.
name|pm_cpu
expr_stmt|;
if|if
condition|(
name|cpu
operator|<
literal|0
operator|||
name|cpu
operator|>=
name|mp_ncpus
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|request
operator|=
name|pma
operator|.
name|pm_state
expr_stmt|;
if|if
condition|(
name|request
operator|!=
name|PMC_STATE_DISABLED
operator|&&
name|request
operator|!=
name|PMC_STATE_FREE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ri
operator|=
name|pma
operator|.
name|pm_pmc
expr_stmt|;
comment|/* pmc id == row index */
if|if
condition|(
name|ri
operator|<
literal|0
operator|||
name|ri
operator|>=
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * We can't disable a PMC with a row-index allocated 		 * for process virtual PMCs. 		 */
if|if
condition|(
name|PMC_ROW_DISP_IS_THREAD
argument_list|(
name|ri
argument_list|)
operator|&&
name|request
operator|==
name|PMC_STATE_DISABLED
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* 		 * otherwise, this PMC on this CPU is either free or 		 * in system-wide mode. 		 */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|pc
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
expr_stmt|;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
comment|/* 		 * XXX do we need some kind of 'forced' disable? 		 */
if|if
condition|(
name|phw
operator|->
name|phw_pmc
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|request
operator|==
name|PMC_STATE_DISABLED
operator|&&
operator|(
name|phw
operator|->
name|phw_state
operator|&
name|PMC_PHW_FLAG_IS_ENABLED
operator|)
condition|)
block|{
name|phw
operator|->
name|phw_state
operator|&=
operator|~
name|PMC_PHW_FLAG_IS_ENABLED
expr_stmt|;
name|PMC_MARK_ROW_STANDALONE
argument_list|(
name|ri
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|request
operator|==
name|PMC_STATE_FREE
operator|&&
operator|(
name|phw
operator|->
name|phw_state
operator|&
name|PMC_PHW_FLAG_IS_ENABLED
operator|)
operator|==
literal|0
condition|)
block|{
name|phw
operator|->
name|phw_state
operator||=
name|PMC_PHW_FLAG_IS_ENABLED
expr_stmt|;
name|PMC_UNMARK_ROW_STANDALONE
argument_list|(
name|ri
argument_list|)
expr_stmt|;
block|}
comment|/* other cases are a no-op */
block|}
else|else
name|error
operator|=
name|EBUSY
expr_stmt|;
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Allocate a PMC. 	 */
case|case
name|PMC_OP_PMCALLOCATE
case|:
block|{
name|uint32_t
name|caps
decl_stmt|;
name|u_int
name|cpu
decl_stmt|;
name|int
name|n
decl_stmt|;
name|enum
name|pmc_mode
name|mode
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pmc
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|struct
name|pmc_op_pmcallocate
name|pa
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|pa
argument_list|,
sizeof|sizeof
argument_list|(
name|pa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|caps
operator|=
name|pa
operator|.
name|pm_caps
expr_stmt|;
name|mode
operator|=
name|pa
operator|.
name|pm_mode
expr_stmt|;
name|cpu
operator|=
name|pa
operator|.
name|pm_cpu
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|!=
name|PMC_MODE_SS
operator|&&
name|mode
operator|!=
name|PMC_MODE_SC
operator|&&
name|mode
operator|!=
name|PMC_MODE_TS
operator|&&
name|mode
operator|!=
name|PMC_MODE_TC
operator|)
operator|||
operator|(
name|cpu
operator|!=
operator|(
name|u_int
operator|)
name|PMC_CPU_ANY
operator|&&
name|cpu
operator|>=
operator|(
name|u_int
operator|)
name|mp_ncpus
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Virtual PMCs should only ask for a default CPU. 		 * System mode PMCs need to specify a non-default CPU. 		 */
if|if
condition|(
operator|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|cpu
operator|!=
operator|(
name|u_int
operator|)
name|PMC_CPU_ANY
operator|)
operator|||
operator|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|cpu
operator|==
operator|(
name|u_int
operator|)
name|PMC_CPU_ANY
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Check that a disabled CPU is not being asked for. 		 */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
comment|/* 		 * Refuse an allocation for a system-wide PMC if this 		 * process has been jailed, or if this process lacks 		 * super-user credentials and the sysctl tunable 		 * 'security.bsd.unprivileged_syspmcs' is zero. 		 */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|jailed
argument_list|(
name|curthread
operator|->
name|td_ucred
argument_list|)
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|pmc_unprivileged_syspmcs
condition|)
block|{
name|error
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_PMC_SYSTEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|error
condition|)
break|break;
comment|/* 		 * Look for valid values for 'pm_flags' 		 */
if|if
condition|(
operator|(
name|pa
operator|.
name|pm_flags
operator|&
operator|~
operator|(
name|PMC_F_DESCENDANTS
operator||
name|PMC_F_LOG_PROCCSW
operator||
name|PMC_F_LOG_PROCEXIT
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* process logging options are not allowed for system PMCs */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|pa
operator|.
name|pm_flags
operator|&
operator|(
name|PMC_F_LOG_PROCCSW
operator||
name|PMC_F_LOG_PROCEXIT
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * All sampling mode PMCs need to be able to interrupt the 		 * CPU. 		 */
if|if
condition|(
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|mode
argument_list|)
condition|)
name|caps
operator||=
name|PMC_CAP_INTERRUPT
expr_stmt|;
comment|/* A valid class specifier should have been passed in. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|md
operator|->
name|pmd_nclass
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|md
operator|->
name|pmd_classes
index|[
name|n
index|]
operator|.
name|pm_class
operator|==
name|pa
operator|.
name|pm_class
condition|)
break|break;
if|if
condition|(
name|n
operator|==
name|md
operator|->
name|pmd_nclass
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* The requested PMC capabilities should be feasible. */
if|if
condition|(
operator|(
name|md
operator|->
name|pmd_classes
index|[
name|n
index|]
operator|.
name|pm_caps
operator|&
name|caps
operator|)
operator|!=
name|caps
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|ALL
argument_list|,
literal|2
argument_list|,
literal|"event=%d caps=0x%x mode=%d cpu=%d"
argument_list|,
name|pa
operator|.
name|pm_ev
argument_list|,
name|caps
argument_list|,
name|mode
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|pmc
operator|=
name|pmc_allocate_pmc_descriptor
argument_list|()
expr_stmt|;
name|pmc
operator|->
name|pm_id
operator|=
name|PMC_ID_MAKE_ID
argument_list|(
name|cpu
argument_list|,
name|pa
operator|.
name|pm_mode
argument_list|,
name|pa
operator|.
name|pm_class
argument_list|,
name|PMC_ID_INVALID
argument_list|)
expr_stmt|;
name|pmc
operator|->
name|pm_event
operator|=
name|pa
operator|.
name|pm_ev
expr_stmt|;
name|pmc
operator|->
name|pm_state
operator|=
name|PMC_STATE_FREE
expr_stmt|;
name|pmc
operator|->
name|pm_caps
operator|=
name|caps
expr_stmt|;
name|pmc
operator|->
name|pm_flags
operator|=
name|pa
operator|.
name|pm_flags
expr_stmt|;
comment|/* switch thread to CPU 'cpu' */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
define|#
directive|define
name|PMC_IS_SHAREABLE_PMC
parameter_list|(
name|cpu
parameter_list|,
name|n
parameter_list|)
define|\
value|(pmc_pcpu[(cpu)]->pc_hwpmcs[(n)]->phw_state&		\ 	 PMC_PHW_FLAG_IS_SHAREABLE)
define|#
directive|define
name|PMC_IS_UNALLOCATED
parameter_list|(
name|cpu
parameter_list|,
name|n
parameter_list|)
define|\
value|(pmc_pcpu[(cpu)]->pc_hwpmcs[(n)]->phw_pmc == NULL)
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|pmc_can_allocate_row
argument_list|(
name|n
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
operator|&&
name|pmc_can_allocate_rowindex
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|,
name|n
argument_list|,
name|cpu
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|PMC_IS_UNALLOCATED
argument_list|(
name|cpu
argument_list|,
name|n
argument_list|)
operator|||
name|PMC_IS_SHAREABLE_PMC
argument_list|(
name|cpu
argument_list|,
name|n
argument_list|)
operator|)
operator|&&
name|md
operator|->
name|pmd_allocate_pmc
argument_list|(
name|cpu
argument_list|,
name|n
argument_list|,
name|pmc
argument_list|,
operator|&
name|pa
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
else|else
block|{
comment|/* Process virtual mode */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|pmc_can_allocate_row
argument_list|(
name|n
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
operator|&&
name|pmc_can_allocate_rowindex
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|,
name|n
argument_list|,
name|PMC_CPU_ANY
argument_list|)
operator|==
literal|0
operator|&&
name|md
operator|->
name|pmd_allocate_pmc
argument_list|(
name|curthread
operator|->
name|td_oncpu
argument_list|,
name|n
argument_list|,
name|pmc
argument_list|,
operator|&
name|pa
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
undef|#
directive|undef
name|PMC_IS_UNALLOCATED
undef|#
directive|undef
name|PMC_IS_SHAREABLE_PMC
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
condition|)
block|{
name|pmc_destroy_pmc_descriptor
argument_list|(
name|pmc
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pmc
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|pmc
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Fill in the correct value in the ID field */
name|pmc
operator|->
name|pm_id
operator|=
name|PMC_ID_MAKE_ID
argument_list|(
name|cpu
argument_list|,
name|mode
argument_list|,
name|pa
operator|.
name|pm_class
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|ALL
argument_list|,
literal|2
argument_list|,
literal|"ev=%d class=%d mode=%d n=%d -> pmcid=%x"
argument_list|,
name|pmc
operator|->
name|pm_event
argument_list|,
name|pa
operator|.
name|pm_class
argument_list|,
name|mode
argument_list|,
name|n
argument_list|,
name|pmc
operator|->
name|pm_id
argument_list|)
expr_stmt|;
comment|/* Process mode PMCs with logging enabled need log files */
if|if
condition|(
name|pmc
operator|->
name|pm_flags
operator|&
operator|(
name|PMC_F_LOG_PROCEXIT
operator||
name|PMC_F_LOG_PROCCSW
operator|)
condition|)
name|pmc
operator|->
name|pm_flags
operator||=
name|PMC_F_NEEDS_LOGFILE
expr_stmt|;
comment|/* All system mode sampling PMCs require a log file */
if|if
condition|(
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
condition|)
name|pmc
operator|->
name|pm_flags
operator||=
name|PMC_F_NEEDS_LOGFILE
expr_stmt|;
comment|/* 		 * Configure global pmc's immediately 		 */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pmc
argument_list|)
argument_list|)
condition|)
block|{
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|phw
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_hwpmcs
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|phw
operator|->
name|phw_state
operator|&
name|PMC_PHW_FLAG_IS_ENABLED
operator|)
operator|==
literal|0
operator|||
operator|(
name|error
operator|=
name|md
operator|->
name|pmd_config_pmc
argument_list|(
name|cpu
argument_list|,
name|n
argument_list|,
name|pmc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|md
operator|->
name|pmd_release_pmc
argument_list|(
name|cpu
argument_list|,
name|n
argument_list|,
name|pmc
argument_list|)
expr_stmt|;
name|pmc_destroy_pmc_descriptor
argument_list|(
name|pmc
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pmc
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|pmc
operator|=
name|NULL
expr_stmt|;
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
block|}
name|pmc
operator|->
name|pm_state
operator|=
name|PMC_STATE_ALLOCATED
expr_stmt|;
comment|/* 		 * mark row disposition 		 */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
condition|)
name|PMC_MARK_ROW_STANDALONE
argument_list|(
name|n
argument_list|)
expr_stmt|;
else|else
name|PMC_MARK_ROW_THREAD
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* 		 * Register this PMC with the current thread as its owner. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_register_owner
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|,
name|pmc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|pmc_release_pmc_descriptor
argument_list|(
name|pmc
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pmc
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|pmc
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Return the allocated index. 		 */
name|pa
operator|.
name|pm_pmcid
operator|=
name|pmc
operator|->
name|pm_id
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|pa
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|pa
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Attach a PMC to a process. 	 */
case|case
name|PMC_OP_PMCATTACH
case|:
block|{
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pmc_op_pmcattach
name|a
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|a
operator|.
name|pm_pid
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|pm_pid
operator|==
literal|0
condition|)
name|a
operator|.
name|pm_pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|a
operator|.
name|pm_pmc
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* PMCs may be (re)attached only when allocated or stopped */
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_ALLOCATED
operator|&&
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_STOPPED
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* lookup pid */
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|a
operator|.
name|pm_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
break|break;
block|}
comment|/* 		 * Ignore processes that are working on exiting. 		 */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_WEXIT
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* pfind() returns a locked process */
break|break;
block|}
comment|/* 		 * we are allowed to attach a PMC to a process if 		 * we can debug it. 		 */
name|error
operator|=
name|p_candebug
argument_list|(
name|curthread
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|pmc_attach_process
argument_list|(
name|p
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Detach an attached PMC from a process. 	 */
case|case
name|PMC_OP_PMCDETACH
case|:
block|{
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pmc_op_pmcattach
name|a
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|a
operator|.
name|pm_pid
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|pm_pid
operator|==
literal|0
condition|)
name|a
operator|.
name|pm_pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|a
operator|.
name|pm_pmc
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|a
operator|.
name|pm_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
break|break;
block|}
comment|/* 		 * Treat processes that are in the process of exiting 		 * as if they were not present. 		 */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_WEXIT
condition|)
name|error
operator|=
name|ESRCH
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* pfind() returns a locked process */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|pmc_detach_process
argument_list|(
name|p
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Retrieve the MSR number associated with the counter 	 * 'pmc_id'.  This allows processes to directly use RDPMC 	 * instructions to read their PMCs, without the overhead of a 	 * system call. 	 */
case|case
name|PMC_OP_PMCGETMSR
case|:
block|{
name|int
name|ri
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_target
modifier|*
name|pt
decl_stmt|;
name|struct
name|pmc_op_getmsr
name|gm
decl_stmt|;
name|PMC_DOWNGRADE_SX
argument_list|()
expr_stmt|;
comment|/* CPU has no 'GETMSR' support */
if|if
condition|(
name|md
operator|->
name|pmd_get_msr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOSYS
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|gm
argument_list|,
sizeof|sizeof
argument_list|(
name|gm
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|gm
operator|.
name|pm_pmcid
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * The allocated PMC has to be a process virtual PMC, 		 * i.e., of type MODE_T[CS].  Global PMCs can only be 		 * read using the PMCREAD operation since they may be 		 * allocated on a different CPU than the one we could 		 * be running on at the time of the RDPMC instruction. 		 * 		 * The GETMSR operation is not allowed for PMCs that 		 * are inherited across processes. 		 */
if|if
condition|(
operator|!
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
operator|||
operator|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_DESCENDANTS
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * It only makes sense to use a RDPMC (or its 		 * equivalent instruction on non-x86 architectures) on 		 * a process that has allocated and attached a PMC to 		 * itself.  Conversely the PMC is only allowed to have 		 * one process attached to it -- its owner. 		 */
if|if
condition|(
operator|(
name|pt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pm
operator|->
name|pm_targets
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|LIST_NEXT
argument_list|(
name|pt
argument_list|,
name|pt_next
argument_list|)
operator|!=
name|NULL
operator|||
name|pt
operator|->
name|pt_process
operator|->
name|pp_proc
operator|!=
name|pm
operator|->
name|pm_owner
operator|->
name|po_owner
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ri
operator|=
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|md
operator|->
name|pmd_get_msr
call|)
argument_list|(
name|ri
argument_list|,
operator|&
name|gm
operator|.
name|pm_msr
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|gm
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|gm
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
comment|/* 		 * Mark our process as using MSRs.  Update machine 		 * state using a forced context switch. 		 */
name|pt
operator|->
name|pt_process
operator|->
name|pp_flags
operator||=
name|PMC_PP_ENABLE_MSR_ACCESS
expr_stmt|;
name|pmc_force_context_switch
argument_list|()
expr_stmt|;
block|}
break|break;
comment|/* 	 * Release an allocated PMC 	 */
case|case
name|PMC_OP_PMCRELEASE
case|:
block|{
name|pmc_id_t
name|pmcid
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_op_simple
name|sp
decl_stmt|;
comment|/* 		 * Find PMC pointer for the named PMC. 		 * 		 * Use pmc_release_pmc_descriptor() to switch off the 		 * PMC, remove all its target threads, and remove the 		 * PMC from its owner's list. 		 * 		 * Remove the owner record if this is the last PMC 		 * owned. 		 * 		 * Free up space. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|pmcid
operator|=
name|sp
operator|.
name|pm_pmcid
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|pmcid
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
name|pmc_release_pmc_descriptor
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|pmc_maybe_remove_owner
argument_list|(
name|po
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pm
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Read and/or write a PMC. 	 */
case|case
name|PMC_OP_PMCRW
case|:
block|{
name|uint32_t
name|cpu
decl_stmt|,
name|ri
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_op_pmcrw
modifier|*
name|pprw
decl_stmt|;
name|struct
name|pmc_op_pmcrw
name|prw
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
name|pmc_value_t
name|oldvalue
decl_stmt|;
name|PMC_DOWNGRADE_SX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|prw
argument_list|,
sizeof|sizeof
argument_list|(
name|prw
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|ri
operator|=
literal|0
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|OPS
argument_list|,
literal|1
argument_list|,
literal|"rw id=%d flags=0x%x"
argument_list|,
name|prw
operator|.
name|pm_pmcid
argument_list|,
name|prw
operator|.
name|pm_flags
argument_list|)
expr_stmt|;
comment|/* must have at least one flag set */
if|if
condition|(
operator|(
name|prw
operator|.
name|pm_flags
operator|&
operator|(
name|PMC_F_OLDVALUE
operator||
name|PMC_F_NEWVALUE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* locate pmc descriptor */
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|prw
operator|.
name|pm_pmcid
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Can't read a PMC that hasn't been started. */
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_ALLOCATED
operator|&&
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_STOPPED
operator|&&
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_RUNNING
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* writing a new value is allowed only for 'STOPPED' pmcs */
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
operator|&&
operator|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_NEWVALUE
operator|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 			 * If this PMC is attached to its owner (i.e., 			 * the process requesting this operation) and 			 * is running, then attempt to get an 			 * upto-date reading from hardware for a READ. 			 * Writes are only allowed when the PMC is 			 * stopped, so only update the saved value 			 * field. 			 * 			 * If the PMC is not running, or is not 			 * attached to its owner, read/write to the 			 * savedvalue field. 			 */
name|ri
operator|=
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|mtx_pool_lock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|curthread
operator|->
name|td_oncpu
expr_stmt|;
if|if
condition|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_OLDVALUE
condition|)
block|{
if|if
condition|(
operator|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_ATTACHED_TO_OWNER
operator|)
operator|&&
operator|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
operator|)
condition|)
name|error
operator|=
call|(
modifier|*
name|md
operator|->
name|pmd_read_pmc
call|)
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
operator|&
name|oldvalue
argument_list|)
expr_stmt|;
else|else
name|oldvalue
operator|=
name|pm
operator|->
name|pm_gv
operator|.
name|pm_savedvalue
expr_stmt|;
block|}
if|if
condition|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_NEWVALUE
condition|)
name|pm
operator|->
name|pm_gv
operator|.
name|pm_savedvalue
operator|=
name|prw
operator|.
name|pm_value
expr_stmt|;
name|mtx_pool_unlock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* System mode PMCs */
name|cpu
operator|=
name|PMC_TO_CPU
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|ri
operator|=
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
comment|/* move this thread to CPU 'cpu' */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
comment|/* save old value */
if|if
condition|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_OLDVALUE
condition|)
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|md
operator|->
name|pmd_read_pmc
call|)
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
operator|&
name|oldvalue
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
comment|/* write out new value */
if|if
condition|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_NEWVALUE
condition|)
name|error
operator|=
call|(
modifier|*
name|md
operator|->
name|pmd_write_pmc
call|)
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|prw
operator|.
name|pm_value
argument_list|)
expr_stmt|;
name|error
label|:
name|critical_exit
argument_list|()
expr_stmt|;
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|pprw
operator|=
operator|(
expr|struct
name|pmc_op_pmcrw
operator|*
operator|)
name|arg
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_NEWVALUE
condition|)
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|OPS
argument_list|,
literal|2
argument_list|,
literal|"rw id=%d new %jx -> old %jx"
argument_list|,
name|ri
argument_list|,
name|prw
operator|.
name|pm_value
argument_list|,
name|oldvalue
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_OLDVALUE
condition|)
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|OPS
argument_list|,
literal|2
argument_list|,
literal|"rw id=%d -> old %jx"
argument_list|,
name|ri
argument_list|,
name|oldvalue
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* return old value if requested */
if|if
condition|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_OLDVALUE
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|oldvalue
argument_list|,
operator|&
name|pprw
operator|->
name|pm_value
argument_list|,
sizeof|sizeof
argument_list|(
name|prw
operator|.
name|pm_value
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
block|}
break|break;
comment|/* 	 * Set the sampling rate for a sampling mode PMC and the 	 * initial count for a counting mode PMC. 	 */
case|case
name|PMC_OP_PMCSETCOUNT
case|:
block|{
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_op_pmcsetcount
name|sc
decl_stmt|;
name|PMC_DOWNGRADE_SX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|sc
operator|.
name|pm_pmcid
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
name|pm
operator|->
name|pm_sc
operator|.
name|pm_reloadcount
operator|=
name|sc
operator|.
name|pm_count
expr_stmt|;
else|else
name|pm
operator|->
name|pm_sc
operator|.
name|pm_initial
operator|=
name|sc
operator|.
name|pm_count
expr_stmt|;
block|}
break|break;
comment|/* 	 * Start a PMC. 	 */
case|case
name|PMC_OP_PMCSTART
case|:
block|{
name|pmc_id_t
name|pmcid
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_op_simple
name|sp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|pmcid
operator|=
name|sp
operator|.
name|pm_pmcid
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|pmcid
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|KASSERT
argument_list|(
name|pmcid
operator|==
name|pm
operator|->
name|pm_id
argument_list|,
operator|(
literal|"[pmc,%d] pmcid %x != id %x"
operator|,
name|__LINE__
operator|,
name|pm
operator|->
name|pm_id
operator|,
name|pmcid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
condition|)
comment|/* already running */
break|break;
elseif|else
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_STOPPED
operator|&&
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_ALLOCATED
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pmc_start
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Stop a PMC. 	 */
case|case
name|PMC_OP_PMCSTOP
case|:
block|{
name|pmc_id_t
name|pmcid
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_op_simple
name|sp
decl_stmt|;
name|PMC_DOWNGRADE_SX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|pmcid
operator|=
name|sp
operator|.
name|pm_pmcid
expr_stmt|;
comment|/* 		 * Mark the PMC as inactive and invoke the MD stop 		 * routines if needed. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|pmcid
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|KASSERT
argument_list|(
name|pmcid
operator|==
name|pm
operator|->
name|pm_id
argument_list|,
operator|(
literal|"[pmc,%d] pmc id %x != pmcid %x"
operator|,
name|__LINE__
operator|,
name|pm
operator|->
name|pm_id
operator|,
name|pmcid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_STOPPED
condition|)
comment|/* already stopped */
break|break;
elseif|else
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_RUNNING
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pmc_stop
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Write a user supplied value to the log file. 	 */
case|case
name|PMC_OP_WRITELOG
case|:
block|{
name|struct
name|pmc_op_writelog
name|wl
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|PMC_DOWNGRADE_SX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|wl
argument_list|,
sizeof|sizeof
argument_list|(
name|wl
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_find_owner_descriptor
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pmclog_process_userlog
argument_list|(
name|po
argument_list|,
operator|&
name|wl
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_sx_downgraded
condition|)
name|sx_sunlock
argument_list|(
operator|&
name|pmc_sx
argument_list|)
expr_stmt|;
else|else
name|sx_xunlock
argument_list|(
operator|&
name|pmc_sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|atomic_add_int
argument_list|(
operator|&
name|pmc_stats
operator|.
name|pm_syscall_errors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Helper functions  */
end_comment

begin_comment
comment|/*  * Interrupt processing.  *  * Find a free slot in the per-cpu array of PC samples and write the  * current (PMC,PID,PC) triple to it.  If an event was successfully  * added, a bit is set in mask 'pmc_cpumask' denoting that the  * DO_SAMPLES hook needs to be invoked from the clock handler.  *  * This function is meant to be called from an NMI handler.  It cannot  * use any of the locking primitives supplied by the OS.  */
end_comment

begin_function
name|int
name|pmc_process_interrupt
parameter_list|(
name|int
name|cpu
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|uintfptr_t
name|pc
parameter_list|,
name|int
name|usermode
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|ri
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|pmc_sample
modifier|*
name|ps
decl_stmt|;
name|struct
name|pmc_samplebuffer
modifier|*
name|psb
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ri
operator|=
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|psb
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_sb
expr_stmt|;
name|ps
operator|=
name|psb
operator|->
name|ps_write
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|ps_pc
condition|)
block|{
comment|/* in use, reader hasn't caught up */
name|pm
operator|->
name|pm_stalled
operator|=
literal|1
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|pmc_stats
operator|.
name|pm_intr_bufferfull
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|SAM
argument_list|,
name|INT
argument_list|,
literal|1
argument_list|,
literal|"(spc) cpu=%d pm=%p pc=%jx um=%d wr=%d rd=%d"
argument_list|,
name|cpu
argument_list|,
name|pm
argument_list|,
operator|(
name|uint64_t
operator|)
name|pc
argument_list|,
name|usermode
argument_list|,
call|(
name|int
call|)
argument_list|(
name|psb
operator|->
name|ps_write
operator|-
name|psb
operator|->
name|ps_samples
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|psb
operator|->
name|ps_read
operator|-
name|psb
operator|->
name|ps_samples
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* fill in entry */
name|PMCDBG
argument_list|(
name|SAM
argument_list|,
name|INT
argument_list|,
literal|1
argument_list|,
literal|"cpu=%d pm=%p pc=%jx um=%d wr=%d rd=%d"
argument_list|,
name|cpu
argument_list|,
name|pm
argument_list|,
operator|(
name|uint64_t
operator|)
name|pc
argument_list|,
name|usermode
argument_list|,
call|(
name|int
call|)
argument_list|(
name|psb
operator|->
name|ps_write
operator|-
name|psb
operator|->
name|ps_samples
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|psb
operator|->
name|ps_read
operator|-
name|psb
operator|->
name|ps_samples
argument_list|)
argument_list|)
expr_stmt|;
name|atomic_add_rel_32
argument_list|(
operator|&
name|pm
operator|->
name|pm_runcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* hold onto PMC */
name|ps
operator|->
name|ps_pmc
operator|=
name|pm
expr_stmt|;
if|if
condition|(
operator|(
name|td
operator|=
name|curthread
operator|)
operator|&&
name|td
operator|->
name|td_proc
condition|)
name|ps
operator|->
name|ps_pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
else|else
name|ps
operator|->
name|ps_pid
operator|=
operator|-
literal|1
expr_stmt|;
name|ps
operator|->
name|ps_usermode
operator|=
name|usermode
expr_stmt|;
name|ps
operator|->
name|ps_pc
operator|=
name|pc
expr_stmt|;
comment|/* mark entry as in use */
comment|/* increment write pointer, modulo ring buffer size */
name|ps
operator|++
expr_stmt|;
if|if
condition|(
name|ps
operator|==
name|psb
operator|->
name|ps_fence
condition|)
name|psb
operator|->
name|ps_write
operator|=
name|psb
operator|->
name|ps_samples
expr_stmt|;
else|else
name|psb
operator|->
name|ps_write
operator|=
name|ps
expr_stmt|;
name|done
label|:
comment|/* mark CPU as needing processing */
name|atomic_set_rel_int
argument_list|(
operator|&
name|pmc_cpumask
argument_list|,
operator|(
literal|1
operator|<<
name|cpu
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Process saved PC samples.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_process_samples
parameter_list|(
name|int
name|cpu
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|ri
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_sample
modifier|*
name|ps
decl_stmt|;
name|struct
name|pmc_samplebuffer
modifier|*
name|psb
decl_stmt|;
name|KASSERT
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|==
name|cpu
argument_list|,
operator|(
literal|"[pmc,%d] not on the correct CPU pcpu=%d cpu=%d"
operator|,
name|__LINE__
operator|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|psb
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_sb
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|pmc_nsamples
condition|;
name|n
operator|++
control|)
block|{
comment|/* bound on #iterations */
name|ps
operator|=
name|psb
operator|->
name|ps_read
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|ps_pc
operator|==
operator|(
name|uintfptr_t
operator|)
literal|0
condition|)
comment|/* no data */
break|break;
name|pm
operator|=
name|ps
operator|->
name|ps_pmc
expr_stmt|;
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
name|KASSERT
argument_list|(
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
argument_list|,
operator|(
literal|"[pmc,%d] pmc=%p non-sampling mode=%d"
operator|,
name|__LINE__
operator|,
name|pm
operator|,
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Ignore PMCs that have been switched off */
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_RUNNING
condition|)
goto|goto
name|entrydone
goto|;
name|PMCDBG
argument_list|(
name|SAM
argument_list|,
name|OPS
argument_list|,
literal|1
argument_list|,
literal|"cpu=%d pm=%p pc=%jx um=%d wr=%d rd=%d"
argument_list|,
name|cpu
argument_list|,
name|pm
argument_list|,
operator|(
name|uint64_t
operator|)
name|ps
operator|->
name|ps_pc
argument_list|,
name|ps
operator|->
name|ps_usermode
argument_list|,
call|(
name|int
call|)
argument_list|(
name|psb
operator|->
name|ps_write
operator|-
name|psb
operator|->
name|ps_samples
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|psb
operator|->
name|ps_read
operator|-
name|psb
operator|->
name|ps_samples
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If this is a process-mode PMC that is attached to 		 * its owner, and if the PC is in user mode, update 		 * profiling statistics like timer-based profiling 		 * would have done. 		 */
if|if
condition|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_ATTACHED_TO_OWNER
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|ps_usermode
condition|)
block|{
name|td
operator|=
name|FIRST_THREAD_IN_PROC
argument_list|(
name|po
operator|->
name|po_owner
argument_list|)
expr_stmt|;
name|addupc_intr
argument_list|(
name|td
argument_list|,
name|ps
operator|->
name|ps_pc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|entrydone
goto|;
block|}
comment|/* 		 * Otherwise, this is either a sampling mode PMC that 		 * is attached to a different process than its owner, 		 * or a system-wide sampling PMC.  Dispatch a log 		 * entry to the PMC's owner process. 		 */
name|pmclog_process_pcsample
argument_list|(
name|pm
argument_list|,
name|ps
argument_list|)
expr_stmt|;
name|entrydone
label|:
name|ps
operator|->
name|ps_pc
operator|=
operator|(
name|uintfptr_t
operator|)
literal|0
expr_stmt|;
comment|/* mark entry as free */
name|atomic_subtract_rel_32
argument_list|(
operator|&
name|pm
operator|->
name|pm_runcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* increment read pointer, modulo sample size */
if|if
condition|(
operator|++
name|ps
operator|==
name|psb
operator|->
name|ps_fence
condition|)
name|psb
operator|->
name|ps_read
operator|=
name|psb
operator|->
name|ps_samples
expr_stmt|;
else|else
name|psb
operator|->
name|ps_read
operator|=
name|ps
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|pmc_stats
operator|.
name|pm_log_sweeps
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Do not re-enable stalled PMCs if we failed to process any samples */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Restart any stalled sampling PMCs on this CPU. 	 * 	 * If the NMI handler sets the pm_stalled field of a PMC after 	 * the check below, we'll end up processing the stalled PMC at 	 * the next hardclock tick. 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|n
operator|++
control|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|md
operator|->
name|pmd_get_config
argument_list|)
argument_list|(
name|cpu
argument_list|,
name|n
argument_list|,
operator|&
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|NULL
operator|||
comment|/* !cfg'ed */
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_RUNNING
operator|||
comment|/* !active */
operator|!
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
operator|||
comment|/* !sampling */
name|pm
operator|->
name|pm_stalled
operator|==
literal|0
condition|)
comment|/* !stalled */
continue|continue;
name|pm
operator|->
name|pm_stalled
operator|=
literal|0
expr_stmt|;
name|ri
operator|=
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
expr_stmt|;
call|(
modifier|*
name|md
operator|->
name|pmd_start_pmc
call|)
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Event handlers.  */
end_comment

begin_comment
comment|/*  * Handle a process exit.  *  * Remove this process from all hash tables.  If this process  * owned any PMCs, turn off those PMCs and deallocate them,  * removing any associations with target processes.  *  * This function will be called by the last 'thread' of a  * process.  *  * XXX This eventhandler gets called early in the exit process.  * Consider using a 'hook' invocation from thread_exit() or equivalent  * spot.  Another negative is that kse_exit doesn't seem to call  * exit1() [??].  *  */
end_comment

begin_function
specifier|static
name|void
name|pmc_process_exit
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|is_using_hwpmcs
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|unsigned
name|int
name|ri
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|pmc_value_t
name|newvalue
decl_stmt|,
name|tmp
decl_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|is_using_hwpmcs
operator|=
name|p
operator|->
name|p_flag
operator|&
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Log a sysexit event to all SS PMC owners. 	 */
name|LIST_FOREACH
argument_list|(
argument|po
argument_list|,
argument|&pmc_ss_owners
argument_list|,
argument|po_ssnext
argument_list|)
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
name|pmclog_process_sysexit
argument_list|(
name|po
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_using_hwpmcs
condition|)
return|return;
name|PMC_GET_SX_XLOCK
argument_list|()
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|EXT
argument_list|,
literal|1
argument_list|,
literal|"process-exit proc=%p (%d, %s)"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
comment|/* 	 * Since this code is invoked by the last thread in an exiting 	 * process, we would have context switched IN at some prior 	 * point.  However, with PREEMPTION, kernel mode context 	 * switches may happen any time, so we want to disable a 	 * context switch OUT till we get any PMCs targetting this 	 * process off the hardware. 	 * 	 * We also need to atomically remove this process' 	 * entry from our target process hash table, using 	 * PMC_FLAG_REMOVE. 	 */
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|EXT
argument_list|,
literal|1
argument_list|,
literal|"process-exit proc=%p (%d, %s)"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
comment|/* no preemption */
name|cpu
operator|=
name|curthread
operator|->
name|td_oncpu
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|p
argument_list|,
name|PMC_FLAG_REMOVE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|EXT
argument_list|,
literal|2
argument_list|,
literal|"process-exit proc=%p pmc-process=%p"
argument_list|,
name|p
argument_list|,
name|pp
argument_list|)
expr_stmt|;
comment|/* 		 * The exiting process could the target of 		 * some PMCs which will be running on 		 * currently executing CPU. 		 * 		 * We need to turn these PMCs off like we 		 * would do at context switch OUT time. 		 */
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
block|{
comment|/* 			 * Pick up the pmc pointer from hardware 			 * state similar to the CSW_OUT code. 			 */
name|pm
operator|=
name|NULL
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|md
operator|->
name|pmd_get_config
argument_list|)
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
operator|&
name|pm
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|EXT
argument_list|,
literal|2
argument_list|,
literal|"ri=%d pm=%p"
argument_list|,
name|ri
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|NULL
operator|||
operator|!
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
continue|continue;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|EXT
argument_list|,
literal|2
argument_list|,
literal|"ppmcs[%d]=%p pm=%p "
literal|"state=%d"
argument_list|,
name|ri
argument_list|,
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
argument_list|,
name|pm
argument_list|,
name|pm
operator|->
name|pm_state
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
operator|==
name|ri
argument_list|,
operator|(
literal|"[pmc,%d] ri mismatch pmc(%d) ri(%d)"
operator|,
name|__LINE__
operator|,
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|==
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
argument_list|,
operator|(
literal|"[pmc,%d] pm %p != pp_pmcs[%d] %p"
operator|,
name|__LINE__
operator|,
name|pm
operator|,
name|ri
operator|,
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|md
operator|->
name|pmd_stop_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_runcount
operator|>
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] bad runcount ri %d rc %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|,
name|pm
operator|->
name|pm_runcount
operator|)
argument_list|)
expr_stmt|;
comment|/* Stop hardware only if it is actually running */
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
operator|&&
name|pm
operator|->
name|pm_stalled
operator|==
literal|0
condition|)
block|{
name|md
operator|->
name|pmd_read_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
operator|&
name|newvalue
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|newvalue
operator|-
name|PMC_PCPU_SAVED
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|mtx_pool_lock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_gv
operator|.
name|pm_savedvalue
operator|+=
name|tmp
expr_stmt|;
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmcval
operator|+=
name|tmp
expr_stmt|;
name|mtx_pool_unlock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
name|atomic_subtract_rel_32
argument_list|(
operator|&
name|pm
operator|->
name|pm_runcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|int
operator|)
name|pm
operator|->
name|pm_runcount
operator|>=
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] runcount is %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|md
operator|->
name|pmd_config_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Inform the MD layer of this pseudo "context switch 		 * out" 		 */
operator|(
name|void
operator|)
name|md
operator|->
name|pmd_switch_out
argument_list|(
name|pmc_pcpu
index|[
name|cpu
index|]
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
comment|/* ok to be pre-empted now */
comment|/* 		 * Unlink this process from the PMCs that are 		 * targetting it.  This will send a signal to 		 * all PMC owner's whose PMCs are orphaned. 		 * 		 * Log PMC value at exit time if requested. 		 */
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
if|if
condition|(
operator|(
name|pm
operator|=
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_NEEDS_LOGFILE
operator|&&
name|PMC_IS_COUNTING_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
name|pmclog_process_procexit
argument_list|(
name|pm
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|pmc_unlink_target_process
argument_list|(
name|pm
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|pp
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
else|else
name|critical_exit
argument_list|()
expr_stmt|;
comment|/* pp == NULL */
comment|/* 	 * If the process owned PMCs, free them up and free up 	 * memory. 	 */
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_find_owner_descriptor
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pmc_remove_owner
argument_list|(
name|po
argument_list|)
expr_stmt|;
name|pmc_destroy_owner_descriptor
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|pmc_sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a process fork.  *  * If the parent process 'p1' is under HWPMC monitoring, then copy  * over any attached PMCs that have 'do_descendants' semantics.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_process_fork
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
name|struct
name|proc
modifier|*
name|newproc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|is_using_hwpmcs
decl_stmt|;
name|unsigned
name|int
name|ri
decl_stmt|;
name|uint32_t
name|do_descendants
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|ppnew
decl_stmt|,
modifier|*
name|ppold
decl_stmt|;
operator|(
name|void
operator|)
name|flags
expr_stmt|;
comment|/* unused parameter */
name|PROC_LOCK
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|is_using_hwpmcs
operator|=
name|p1
operator|->
name|p_flag
operator|&
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p1
argument_list|)
expr_stmt|;
comment|/* 	 * If there are system-wide sampling PMCs active, we need to 	 * log all fork events to their owner's logs. 	 */
name|LIST_FOREACH
argument_list|(
argument|po
argument_list|,
argument|&pmc_ss_owners
argument_list|,
argument|po_ssnext
argument_list|)
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
name|pmclog_process_procfork
argument_list|(
name|po
argument_list|,
name|p1
operator|->
name|p_pid
argument_list|,
name|newproc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_using_hwpmcs
condition|)
return|return;
name|PMC_GET_SX_XLOCK
argument_list|()
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|FRK
argument_list|,
literal|1
argument_list|,
literal|"process-fork proc=%p (%d, %s) -> %p"
argument_list|,
name|p1
argument_list|,
name|p1
operator|->
name|p_pid
argument_list|,
name|p1
operator|->
name|p_comm
argument_list|,
name|newproc
argument_list|)
expr_stmt|;
comment|/* 	 * If the parent process (curthread->td_proc) is a 	 * target of any PMCs, look for PMCs that are to be 	 * inherited, and link these into the new process 	 * descriptor. 	 */
if|if
condition|(
operator|(
name|ppold
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|,
name|PMC_FLAG_NONE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* nothing to do */
name|do_descendants
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
if|if
condition|(
operator|(
name|pm
operator|=
name|ppold
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
operator|!=
name|NULL
condition|)
name|do_descendants
operator||=
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_DESCENDANTS
expr_stmt|;
if|if
condition|(
name|do_descendants
operator|==
literal|0
condition|)
comment|/* nothing to do */
goto|goto
name|done
goto|;
comment|/* allocate a descriptor for the new process  */
if|if
condition|(
operator|(
name|ppnew
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|newproc
argument_list|,
name|PMC_FLAG_ALLOCATE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Run through all PMCs that were targeting the old process 	 * and which specified F_DESCENDANTS and attach them to the 	 * new process. 	 * 	 * Log the fork event to all owners of PMCs attached to this 	 * process, if not already logged. 	 */
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
if|if
condition|(
operator|(
name|pm
operator|=
name|ppold
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_DESCENDANTS
operator|)
condition|)
block|{
name|pmc_link_target_process
argument_list|(
name|pm
argument_list|,
name|ppnew
argument_list|)
expr_stmt|;
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
if|if
condition|(
name|po
operator|->
name|po_sscount
operator|==
literal|0
operator|&&
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
name|pmclog_process_procfork
argument_list|(
name|po
argument_list|,
name|p1
operator|->
name|p_pid
argument_list|,
name|newproc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now mark the new process as being tracked by this driver. 	 */
name|PROC_LOCK
argument_list|(
name|newproc
argument_list|)
expr_stmt|;
name|newproc
operator|->
name|p_flag
operator||=
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|newproc
argument_list|)
expr_stmt|;
name|done
label|:
name|sx_xunlock
argument_list|(
operator|&
name|pmc_sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * initialization  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|pmc_name_of_pmcclass
index|[]
init|=
block|{
undef|#
directive|undef
name|__PMC_CLASS
define|#
directive|define
name|__PMC_CLASS
parameter_list|(
name|N
parameter_list|)
value|#N ,
name|__PMC_CLASSES
argument_list|()
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|pmc_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|,
name|error
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
name|struct
name|pmc_samplebuffer
modifier|*
name|sb
decl_stmt|;
name|md
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* parse debug flags first */
if|if
condition|(
name|TUNABLE_STR_FETCH
argument_list|(
name|PMC_SYSCTL_NAME_PREFIX
literal|"debugflags"
argument_list|,
name|pmc_debugstr
argument_list|,
sizeof|sizeof
argument_list|(
name|pmc_debugstr
argument_list|)
argument_list|)
condition|)
name|pmc_debugflags_parse
argument_list|(
name|pmc_debugstr
argument_list|,
name|pmc_debugstr
operator|+
name|strlen
argument_list|(
name|pmc_debugstr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|0
argument_list|,
literal|"PMC Initialize (version %x)"
argument_list|,
name|PMC_VERSION
argument_list|)
expr_stmt|;
comment|/* check kernel version */
if|if
condition|(
name|pmc_kernel_version
operator|!=
name|PMC_VERSION
condition|)
block|{
if|if
condition|(
name|pmc_kernel_version
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"hwpmc: this kernel has not been compiled with "
literal|"'options HWPMC_HOOKS'.\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"hwpmc: kernel version (0x%x) does not match "
literal|"module version (0x%x).\n"
argument_list|,
name|pmc_kernel_version
argument_list|,
name|PMC_VERSION
argument_list|)
expr_stmt|;
return|return
name|EPROGMISMATCH
return|;
block|}
comment|/* 	 * check sysctl parameters 	 */
if|if
condition|(
name|pmc_hashsize
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"hwpmc: tunable hashsize=%d must be greater "
literal|"than zero.\n"
argument_list|,
name|pmc_hashsize
argument_list|)
expr_stmt|;
name|pmc_hashsize
operator|=
name|PMC_HASH_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|pmc_nsamples
operator|<=
literal|0
operator|||
name|pmc_nsamples
operator|>
literal|65535
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"hwpmc: tunable nsamples=%d out of range.\n"
argument_list|,
name|pmc_nsamples
argument_list|)
expr_stmt|;
name|pmc_nsamples
operator|=
name|PMC_NSAMPLES
expr_stmt|;
block|}
name|md
operator|=
name|pmc_md_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
operator|||
name|md
operator|->
name|pmd_init
operator|==
name|NULL
condition|)
return|return
name|ENOSYS
return|;
comment|/* allocate space for the per-cpu array */
name|MALLOC
argument_list|(
name|pmc_pcpu
argument_list|,
expr|struct
name|pmc_cpu
operator|*
operator|*
argument_list|,
name|mp_ncpus
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_cpu
operator|*
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* per-cpu 'saved values' for managing process-mode PMCs */
name|MALLOC
argument_list|(
name|pmc_pcpu_saved
argument_list|,
name|pmc_value_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|pmc_value_t
argument_list|)
operator|*
name|mp_ncpus
operator|*
name|md
operator|->
name|pmd_npmc
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* perform cpu dependent initialization */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|mp_ncpus
condition|;
name|cpu
operator|++
control|)
block|{
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
continue|continue;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|md
operator|->
name|pmd_init
argument_list|(
name|cpu
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* allocate space for the sample array */
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|mp_ncpus
condition|;
name|cpu
operator|++
control|)
block|{
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
continue|continue;
name|MALLOC
argument_list|(
name|sb
argument_list|,
expr|struct
name|pmc_samplebuffer
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_samplebuffer
argument_list|)
operator|+
name|pmc_nsamples
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_sample
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sb
operator|->
name|ps_read
operator|=
name|sb
operator|->
name|ps_write
operator|=
name|sb
operator|->
name|ps_samples
expr_stmt|;
name|sb
operator|->
name|ps_fence
operator|=
name|sb
operator|->
name|ps_samples
operator|+
name|pmc_nsamples
expr_stmt|;
name|KASSERT
argument_list|(
name|pmc_pcpu
index|[
name|cpu
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] cpu=%d Null per-cpu data"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_sb
operator|=
name|sb
expr_stmt|;
block|}
comment|/* allocate space for the row disposition array */
name|pmc_pmcdisp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|enum
name|pmc_mode
argument_list|)
operator|*
name|md
operator|->
name|pmd_npmc
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pmc_pmcdisp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] pmcdisp allocation returned NULL"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
comment|/* mark all PMCs as available */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
condition|;
name|n
operator|++
control|)
name|PMC_MARK_ROW_FREE
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* allocate thread hash tables */
name|pmc_ownerhash
operator|=
name|hashinit
argument_list|(
name|pmc_hashsize
argument_list|,
name|M_PMC
argument_list|,
operator|&
name|pmc_ownerhashmask
argument_list|)
expr_stmt|;
name|pmc_processhash
operator|=
name|hashinit
argument_list|(
name|pmc_hashsize
argument_list|,
name|M_PMC
argument_list|,
operator|&
name|pmc_processhashmask
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmc_processhash_mtx
argument_list|,
literal|"pmc-process-hash"
argument_list|,
literal|"pmc-leaf"
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|pmc_ss_owners
argument_list|)
expr_stmt|;
name|pmc_ss_count
operator|=
literal|0
expr_stmt|;
comment|/* allocate a pool of spin mutexes */
name|pmc_mtxpool
operator|=
name|mtx_pool_create
argument_list|(
literal|"pmc-leaf"
argument_list|,
name|pmc_mtxpool_size
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|1
argument_list|,
literal|"pmc_ownerhash=%p, mask=0x%lx "
literal|"targethash=%p mask=0x%lx"
argument_list|,
name|pmc_ownerhash
argument_list|,
name|pmc_ownerhashmask
argument_list|,
name|pmc_processhash
argument_list|,
name|pmc_processhashmask
argument_list|)
expr_stmt|;
comment|/* register process {exit,fork,exec} handlers */
name|pmc_exit_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|process_exit
argument_list|,
name|pmc_process_exit
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|pmc_fork_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|process_fork
argument_list|,
name|pmc_process_fork
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
comment|/* initialize logging */
name|pmclog_initialize
argument_list|()
expr_stmt|;
comment|/* set hook functions */
name|pmc_intr
operator|=
name|md
operator|->
name|pmd_intr
expr_stmt|;
name|pmc_hook
operator|=
name|pmc_hook_handler
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|PMC_MODULE_NAME
literal|":"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_nclass
condition|;
name|n
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %s/%d/0x%b"
argument_list|,
name|pmc_name_of_pmcclass
index|[
name|md
operator|->
name|pmd_classes
index|[
name|n
index|]
operator|.
name|pm_class
index|]
argument_list|,
name|md
operator|->
name|pmd_nclasspmcs
index|[
name|n
index|]
argument_list|,
name|md
operator|->
name|pmd_classes
index|[
name|n
index|]
operator|.
name|pm_caps
argument_list|,
literal|"\20"
literal|"\1INT\2USR\3SYS\4EDG\5THR"
literal|"\6REA\7WRI\10INV\11QUA\12PRC"
literal|"\13TAG\14CSC"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* prepare to be unloaded */
end_comment

begin_function
specifier|static
name|void
name|pmc_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
name|struct
name|pmc_ownerhash
modifier|*
name|ph
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|struct
name|pmc_processhash
modifier|*
name|prh
decl_stmt|;
endif|#
directive|endif
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
literal|"cleanup"
argument_list|)
expr_stmt|;
comment|/* switch off sampling */
name|atomic_store_rel_int
argument_list|(
operator|&
name|pmc_cpumask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pmc_intr
operator|=
name|NULL
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|pmc_sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc_hook
operator|==
name|NULL
condition|)
block|{
comment|/* being unloaded already */
name|sx_xunlock
argument_list|(
operator|&
name|pmc_sx
argument_list|)
expr_stmt|;
return|return;
block|}
name|pmc_hook
operator|=
name|NULL
expr_stmt|;
comment|/* prevent new threads from entering module */
comment|/* deregister event handlers */
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|process_fork
argument_list|,
name|pmc_fork_tag
argument_list|)
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|process_exit
argument_list|,
name|pmc_exit_tag
argument_list|)
expr_stmt|;
comment|/* send SIGBUS to all owner threads, free up allocations */
if|if
condition|(
name|pmc_ownerhash
condition|)
for|for
control|(
name|ph
operator|=
name|pmc_ownerhash
init|;
name|ph
operator|<=
operator|&
name|pmc_ownerhash
index|[
name|pmc_ownerhashmask
index|]
condition|;
name|ph
operator|++
control|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|po
argument_list|,
argument|ph
argument_list|,
argument|po_next
argument_list|,
argument|tmp
argument_list|)
block|{
name|pmc_remove_owner
argument_list|(
name|po
argument_list|)
expr_stmt|;
comment|/* send SIGBUS to owner processes */
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|2
argument_list|,
literal|"cleanup signal proc=%p "
literal|"(%d, %s)"
argument_list|,
name|po
operator|->
name|po_owner
argument_list|,
name|po
operator|->
name|po_owner
operator|->
name|p_pid
argument_list|,
name|po
operator|->
name|po_owner
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|po
operator|->
name|po_owner
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|po
operator|->
name|po_owner
argument_list|,
name|SIGBUS
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|po
operator|->
name|po_owner
argument_list|)
expr_stmt|;
name|pmc_destroy_owner_descriptor
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* reclaim allocated data structures */
if|if
condition|(
name|pmc_mtxpool
condition|)
name|mtx_pool_destroy
argument_list|(
operator|&
name|pmc_mtxpool
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pmc_processhash_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc_processhash
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|3
argument_list|,
literal|"%s"
argument_list|,
literal|"destroy process hash"
argument_list|)
expr_stmt|;
for|for
control|(
name|prh
operator|=
name|pmc_processhash
init|;
name|prh
operator|<=
operator|&
name|pmc_processhash
index|[
name|pmc_processhashmask
index|]
condition|;
name|prh
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|prh
argument_list|,
argument|pp_next
argument_list|)
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|3
argument_list|,
literal|"pid=%d"
argument_list|,
name|pp
operator|->
name|pp_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hashdestroy
argument_list|(
name|pmc_processhash
argument_list|,
name|M_PMC
argument_list|,
name|pmc_processhashmask
argument_list|)
expr_stmt|;
name|pmc_processhash
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pmc_ownerhash
condition|)
block|{
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|3
argument_list|,
literal|"%s"
argument_list|,
literal|"destroy owner hash"
argument_list|)
expr_stmt|;
name|hashdestroy
argument_list|(
name|pmc_ownerhash
argument_list|,
name|M_PMC
argument_list|,
name|pmc_ownerhashmask
argument_list|)
expr_stmt|;
name|pmc_ownerhash
operator|=
name|NULL
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|pmc_ss_owners
argument_list|)
argument_list|,
operator|(
literal|"[pmc,%d] Global SS owner list not empty"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pmc_ss_count
operator|==
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] Global SS count not empty"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
comment|/* free the per-cpu sample buffers */
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|mp_ncpus
condition|;
name|cpu
operator|++
control|)
block|{
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
continue|continue;
name|KASSERT
argument_list|(
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_sb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] Null cpu sample buffer cpu=%d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_sb
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_sb
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* do processor dependent cleanup */
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|3
argument_list|,
literal|"%s"
argument_list|,
literal|"md cleanup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
condition|)
block|{
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|mp_ncpus
condition|;
name|cpu
operator|++
control|)
block|{
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|1
argument_list|,
literal|"pmc-cleanup cpu=%d pcs=%p"
argument_list|,
name|cpu
argument_list|,
name|pmc_pcpu
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
continue|continue;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc_pcpu
index|[
name|cpu
index|]
condition|)
operator|(
name|void
operator|)
name|md
operator|->
name|pmd_cleanup
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|md
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|md
operator|=
name|NULL
expr_stmt|;
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
block|}
comment|/* deallocate per-cpu structures */
name|FREE
argument_list|(
name|pmc_pcpu
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|pmc_pcpu
operator|=
name|NULL
expr_stmt|;
name|FREE
argument_list|(
name|pmc_pcpu_saved
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|pmc_pcpu_saved
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pmc_pmcdisp
condition|)
block|{
name|FREE
argument_list|(
name|pmc_pmcdisp
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|pmc_pmcdisp
operator|=
name|NULL
expr_stmt|;
block|}
name|pmclog_shutdown
argument_list|()
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|pmc_sx
argument_list|)
expr_stmt|;
comment|/* we are done */
block|}
end_function

begin_comment
comment|/*  * The function called at load/unload.  */
end_comment

begin_function
specifier|static
name|int
name|load
parameter_list|(
name|struct
name|module
modifier|*
name|module
name|__unused
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* initialize the subsystem */
name|error
operator|=
name|pmc_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|1
argument_list|,
literal|"syscall=%d ncpus=%d"
argument_list|,
name|pmc_syscall_num
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
case|case
name|MOD_SHUTDOWN
case|:
name|pmc_cleanup
argument_list|()
expr_stmt|;
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|1
argument_list|,
literal|"%s"
argument_list|,
literal|"unloaded"
argument_list|)
expr_stmt|;
break|break;
default|default :
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* XXX should panic(9) */
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* memory pool */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PMC
argument_list|,
literal|"pmc"
argument_list|,
literal|"Memory space for the PMC module"
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

