begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2007 Joseph Koshy  * Copyright (c) 2007 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by A. Joseph Koshy under  * sponsorship from the FreeBSD Foundation and Google, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*  * Logging code for hwpmc(4)  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmckern.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmclog.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_comment
comment|/*  * Sysctl tunables  */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_hwpmc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * kern.hwpmc.logbuffersize -- size of the per-cpu owner buffers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmclog_buffer_size
init|=
name|PMC_LOG_BUFFER_SIZE
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|1100000
operator|)
end_if

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
name|PMC_SYSCTL_NAME_PREFIX
literal|"logbuffersize"
argument_list|,
operator|&
name|pmclog_buffer_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_hwpmc
argument_list|,
name|OID_AUTO
argument_list|,
name|logbuffersize
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pmclog_buffer_size
argument_list|,
literal|0
argument_list|,
literal|"size of log buffers in kilobytes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * kern.hwpmc.nbuffer -- number of global log buffers  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmc_nlogbuffers
init|=
name|PMC_NLOGBUFFERS
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|1100000
operator|)
end_if

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
name|PMC_SYSCTL_NAME_PREFIX
literal|"nbuffers"
argument_list|,
operator|&
name|pmc_nlogbuffers
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_hwpmc
argument_list|,
name|OID_AUTO
argument_list|,
name|nbuffers
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pmc_nlogbuffers
argument_list|,
literal|0
argument_list|,
literal|"number of global log buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Global log buffer list and associated spin lock.  */
end_comment

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pmclog_buffer
argument_list|)
end_macro

begin_expr_stmt
name|pmc_bufferlist
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|pmc_bufferlist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|pmc_bufferlist_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* spin lock */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|pmc_kthread_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sleep lock */
end_comment

begin_define
define|#
directive|define
name|PMCLOG_INIT_BUFFER_DESCRIPTOR
parameter_list|(
name|D
parameter_list|)
value|do {				\ 		const int __roundup = roundup(sizeof(*D),		\ 			sizeof(uint32_t));				\ 		(D)->plb_fence = ((char *) (D)) +			\ 			 1024*pmclog_buffer_size;			\ 		(D)->plb_base  = (D)->plb_ptr = ((char *) (D)) +	\ 			__roundup;					\ 	} while (0)
end_define

begin_comment
comment|/*  * Log file record constructors.  */
end_comment

begin_define
define|#
directive|define
name|_PMCLOG_TO_HEADER
parameter_list|(
name|T
parameter_list|,
name|L
parameter_list|)
define|\
value|((PMCLOG_HEADER_MAGIC<< 24) |					\ 	 (PMCLOG_TYPE_ ## T<< 16)   |					\ 	 ((L)& 0xFFFF))
end_define

begin_comment
comment|/* reserve LEN bytes of space and initialize the entry header */
end_comment

begin_define
define|#
directive|define
name|_PMCLOG_RESERVE
parameter_list|(
name|PO
parameter_list|,
name|TYPE
parameter_list|,
name|LEN
parameter_list|,
name|ACTION
parameter_list|)
value|do {			\ 		uint32_t *_le;						\ 		int _len = roundup((LEN), sizeof(uint32_t));		\ 		if ((_le = pmclog_reserve((PO), _len)) == NULL) {	\ 			ACTION;						\ 		}							\ 		*_le = _PMCLOG_TO_HEADER(TYPE,_len);			\ 		_le += 3
end_define

begin_comment
comment|/* skip over timestamp */
end_comment

begin_define
define|#
directive|define
name|PMCLOG_RESERVE
parameter_list|(
name|P
parameter_list|,
name|T
parameter_list|,
name|L
parameter_list|)
value|_PMCLOG_RESERVE(P,T,L,return)
end_define

begin_define
define|#
directive|define
name|PMCLOG_RESERVE_WITH_ERROR
parameter_list|(
name|P
parameter_list|,
name|T
parameter_list|,
name|L
parameter_list|)
value|_PMCLOG_RESERVE(P,T,L,		\ 	error=ENOMEM;goto error)
end_define

begin_define
define|#
directive|define
name|PMCLOG_EMIT32
parameter_list|(
name|V
parameter_list|)
value|do { *_le++ = (V); } while (0)
end_define

begin_define
define|#
directive|define
name|PMCLOG_EMIT64
parameter_list|(
name|V
parameter_list|)
value|do { 					\ 		*_le++ = (uint32_t) ((V)& 0xFFFFFFFF);			\ 		*_le++ = (uint32_t) (((V)>> 32)& 0xFFFFFFFF);		\ 	} while (0)
end_define

begin_comment
comment|/* Emit a string.  Caution: does NOT update _le, so needs to be last */
end_comment

begin_define
define|#
directive|define
name|PMCLOG_EMITSTRING
parameter_list|(
name|S
parameter_list|,
name|L
parameter_list|)
value|do { bcopy((S), _le, (L)); } while (0)
end_define

begin_define
define|#
directive|define
name|PMCLOG_EMITNULLSTRING
parameter_list|(
name|L
parameter_list|)
value|do { bzero(_le, (L)); } while (0)
end_define

begin_define
define|#
directive|define
name|PMCLOG_DESPATCH
parameter_list|(
name|PO
parameter_list|)
define|\
value|pmclog_release((PO));					\ 	} while (0)
end_define

begin_comment
comment|/*  * Assertions about the log file format.  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_callchain
argument_list|)
operator|==
literal|6
operator|*
literal|4
operator|+
name|PMC_CALLCHAIN_DEPTH_MAX
operator|*
sizeof|sizeof
argument_list|(
name|uintfptr_t
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_closelog
argument_list|)
operator|==
literal|3
operator|*
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_dropnotify
argument_list|)
operator|==
literal|3
operator|*
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_map_in
argument_list|)
operator|==
name|PATH_MAX
operator|+
literal|4
operator|*
literal|4
operator|+
sizeof|sizeof
argument_list|(
name|uintfptr_t
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|pmclog_map_in
argument_list|,
name|pl_pathname
argument_list|)
operator|==
literal|4
operator|*
literal|4
operator|+
sizeof|sizeof
argument_list|(
name|uintfptr_t
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_map_out
argument_list|)
operator|==
literal|4
operator|*
literal|4
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uintfptr_t
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_pcsample
argument_list|)
operator|==
literal|6
operator|*
literal|4
operator|+
sizeof|sizeof
argument_list|(
name|uintfptr_t
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_pmcallocate
argument_list|)
operator|==
literal|6
operator|*
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_pmcattach
argument_list|)
operator|==
literal|5
operator|*
literal|4
operator|+
name|PATH_MAX
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|pmclog_pmcattach
argument_list|,
name|pl_pathname
argument_list|)
operator|==
literal|5
operator|*
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_pmcdetach
argument_list|)
operator|==
literal|5
operator|*
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_proccsw
argument_list|)
operator|==
literal|5
operator|*
literal|4
operator|+
literal|8
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_procexec
argument_list|)
operator|==
literal|5
operator|*
literal|4
operator|+
name|PATH_MAX
operator|+
sizeof|sizeof
argument_list|(
name|uintfptr_t
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|pmclog_procexec
argument_list|,
name|pl_pathname
argument_list|)
operator|==
literal|5
operator|*
literal|4
operator|+
sizeof|sizeof
argument_list|(
name|uintfptr_t
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_procexit
argument_list|)
operator|==
literal|5
operator|*
literal|4
operator|+
literal|8
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_procfork
argument_list|)
operator|==
literal|5
operator|*
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_sysexit
argument_list|)
operator|==
literal|4
operator|*
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_userdata
argument_list|)
operator|==
literal|4
operator|*
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Log buffer structure  */
end_comment

begin_struct
struct|struct
name|pmclog_buffer
block|{
name|TAILQ_ENTRY
argument_list|(
argument|pmclog_buffer
argument_list|)
name|plb_next
expr_stmt|;
name|char
modifier|*
name|plb_base
decl_stmt|;
name|char
modifier|*
name|plb_ptr
decl_stmt|;
name|char
modifier|*
name|plb_fence
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|pmclog_get_buffer
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmclog_loop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmclog_release
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
modifier|*
name|pmclog_reserve
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmclog_schedule_io
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmclog_stop_kthread
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Helper functions  */
end_comment

begin_comment
comment|/*  * Get a log buffer  */
end_comment

begin_function
specifier|static
name|int
name|pmclog_get_buffer
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
block|{
name|struct
name|pmclog_buffer
modifier|*
name|plb
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_curbuf
operator|==
name|NULL
argument_list|,
operator|(
literal|"[pmclog,%d] po=%p current buffer still valid"
operator|,
name|__LINE__
operator|,
name|po
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|pmc_bufferlist_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|plb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmc_bufferlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmc_bufferlist
argument_list|,
name|plb
argument_list|,
name|plb_next
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|pmc_bufferlist_mtx
argument_list|)
expr_stmt|;
name|PMCDBG2
argument_list|(
name|LOG
argument_list|,
name|GTB
argument_list|,
literal|1
argument_list|,
literal|"po=%p plb=%p"
argument_list|,
name|po
argument_list|,
name|plb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HWPMC_DEBUG
if|if
condition|(
name|plb
condition|)
name|KASSERT
argument_list|(
name|plb
operator|->
name|plb_ptr
operator|==
name|plb
operator|->
name|plb_base
operator|&&
name|plb
operator|->
name|plb_base
operator|<
name|plb
operator|->
name|plb_fence
argument_list|,
operator|(
literal|"[pmclog,%d] po=%p buffer invariants: ptr=%p "
literal|"base=%p fence=%p"
operator|,
name|__LINE__
operator|,
name|po
operator|,
name|plb
operator|->
name|plb_ptr
operator|,
name|plb
operator|->
name|plb_base
operator|,
name|plb
operator|->
name|plb_fence
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|po
operator|->
name|po_curbuf
operator|=
name|plb
expr_stmt|;
comment|/* update stats */
name|atomic_add_int
argument_list|(
operator|&
name|pmc_stats
operator|.
name|pm_buffer_requests
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|plb
operator|==
name|NULL
condition|)
name|atomic_add_int
argument_list|(
operator|&
name|pmc_stats
operator|.
name|pm_buffer_requests_failed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|plb
condition|?
literal|0
else|:
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Log handler loop.  *  * This function is executed by each pmc owner's helper thread.  */
end_comment

begin_function
specifier|static
name|void
name|pmclog_loop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmclog_buffer
modifier|*
name|lb
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|ucred
modifier|*
name|ownercred
decl_stmt|;
name|struct
name|ucred
modifier|*
name|mycred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|sigset_t
name|unb
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
name|po
operator|=
operator|(
expr|struct
name|pmc_owner
operator|*
operator|)
name|arg
expr_stmt|;
name|p
operator|=
name|po
operator|->
name|po_owner
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|SIGEMPTYSET
argument_list|(
name|unb
argument_list|)
expr_stmt|;
name|SIGADDSET
argument_list|(
name|unb
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kern_sigprocmask
argument_list|(
name|td
argument_list|,
name|SIG_UNBLOCK
argument_list|,
operator|&
name|unb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mycred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ownercred
operator|=
name|crhold
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PMCDBG2
argument_list|(
name|LOG
argument_list|,
name|INI
argument_list|,
literal|1
argument_list|,
literal|"po=%p kt=%p"
argument_list|,
name|po
argument_list|,
name|po
operator|->
name|po_kthread
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_kthread
operator|==
name|curthread
operator|->
name|td_proc
argument_list|,
operator|(
literal|"[pmclog,%d] proc mismatch po=%p po/kt=%p curproc=%p"
operator|,
name|__LINE__
operator|,
name|po
operator|,
name|po
operator|->
name|po_kthread
operator|,
name|curthread
operator|->
name|td_proc
operator|)
argument_list|)
expr_stmt|;
name|lb
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Loop waiting for I/O requests to be added to the owner 	 * struct's queue.  The loop is exited when the log file 	 * is deconfigured. 	 */
name|mtx_lock
argument_list|(
operator|&
name|pmc_kthread_mtx
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* check if we've been asked to exit */
if|if
condition|(
operator|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|lb
operator|==
name|NULL
condition|)
block|{
comment|/* look for a fresh buffer to write */
name|mtx_lock_spin
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|po
operator|->
name|po_logbuffers
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|)
expr_stmt|;
comment|/* No more buffers and shutdown required. */
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_SHUTDOWN
condition|)
break|break;
operator|(
name|void
operator|)
name|msleep
argument_list|(
name|po
argument_list|,
operator|&
name|pmc_kthread_mtx
argument_list|,
name|PWAIT
argument_list|,
literal|"pmcloop"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|po
operator|->
name|po_logbuffers
argument_list|,
name|lb
argument_list|,
name|plb_next
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pmc_kthread_mtx
argument_list|)
expr_stmt|;
comment|/* process the request */
name|PMCDBG3
argument_list|(
name|LOG
argument_list|,
name|WRI
argument_list|,
literal|2
argument_list|,
literal|"po=%p base=%p ptr=%p"
argument_list|,
name|po
argument_list|,
name|lb
operator|->
name|plb_base
argument_list|,
name|lb
operator|->
name|plb_ptr
argument_list|)
expr_stmt|;
comment|/* change our thread's credentials before issuing the I/O */
name|aiov
operator|.
name|iov_base
operator|=
name|lb
operator|->
name|plb_base
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|nbytes
operator|=
name|lb
operator|->
name|plb_ptr
operator|-
name|lb
operator|->
name|plb_base
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|nbytes
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
comment|/* switch thread credentials -- see kern_ktrace.c */
name|td
operator|->
name|td_ucred
operator|=
name|ownercred
expr_stmt|;
name|error
operator|=
name|fo_write
argument_list|(
name|po
operator|->
name|po_file
argument_list|,
operator|&
name|auio
argument_list|,
name|ownercred
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|mycred
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* XXX some errors are recoverable */
comment|/* send a SIGIO to the owner and exit */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|p
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pmc_kthread_mtx
argument_list|)
expr_stmt|;
name|po
operator|->
name|po_error
operator|=
name|error
expr_stmt|;
comment|/* save for flush log */
name|PMCDBG2
argument_list|(
name|LOG
argument_list|,
name|WRI
argument_list|,
literal|2
argument_list|,
literal|"po=%p error=%d"
argument_list|,
name|po
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|pmc_kthread_mtx
argument_list|)
expr_stmt|;
comment|/* put the used buffer back into the global pool */
name|PMCLOG_INIT_BUFFER_DESCRIPTOR
argument_list|(
name|lb
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|pmc_bufferlist_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmc_bufferlist
argument_list|,
name|lb
argument_list|,
name|plb_next
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|pmc_bufferlist_mtx
argument_list|)
expr_stmt|;
name|lb
operator|=
name|NULL
expr_stmt|;
block|}
name|wakeup_one
argument_list|(
name|po
operator|->
name|po_kthread
argument_list|)
expr_stmt|;
name|po
operator|->
name|po_kthread
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pmc_kthread_mtx
argument_list|)
expr_stmt|;
comment|/* return the current I/O buffer to the global pool */
if|if
condition|(
name|lb
condition|)
block|{
name|PMCLOG_INIT_BUFFER_DESCRIPTOR
argument_list|(
name|lb
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|pmc_bufferlist_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmc_bufferlist
argument_list|,
name|lb
argument_list|,
name|plb_next
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|pmc_bufferlist_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Exit this thread, signalling the waiter 	 */
name|crfree
argument_list|(
name|ownercred
argument_list|)
expr_stmt|;
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release and log entry and schedule an I/O if needed.  */
end_comment

begin_function
specifier|static
name|void
name|pmclog_release
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|>=
name|po
operator|->
name|po_curbuf
operator|->
name|plb_base
argument_list|,
operator|(
literal|"[pmclog,%d] buffer invariants po=%p ptr=%p base=%p"
operator|,
name|__LINE__
operator|,
name|po
operator|,
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|,
name|po
operator|->
name|po_curbuf
operator|->
name|plb_base
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|<=
name|po
operator|->
name|po_curbuf
operator|->
name|plb_fence
argument_list|,
operator|(
literal|"[pmclog,%d] buffer invariants po=%p ptr=%p fenc=%p"
operator|,
name|__LINE__
operator|,
name|po
operator|,
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|,
name|po
operator|->
name|po_curbuf
operator|->
name|plb_fence
operator|)
argument_list|)
expr_stmt|;
comment|/* schedule an I/O if we've filled a buffer */
if|if
condition|(
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|>=
name|po
operator|->
name|po_curbuf
operator|->
name|plb_fence
condition|)
name|pmclog_schedule_io
argument_list|(
name|po
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|)
expr_stmt|;
name|PMCDBG1
argument_list|(
name|LOG
argument_list|,
name|REL
argument_list|,
literal|1
argument_list|,
literal|"po=%p"
argument_list|,
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt to reserve 'length' bytes of space in an owner's log  * buffer.  The function returns a pointer to 'length' bytes of space  * if there was enough space or returns NULL if no space was  * available.  Non-null returns do so with the po mutex locked.  The  * caller must invoke pmclog_release() on the pmc owner structure  * when done.  */
end_comment

begin_function
specifier|static
name|uint32_t
modifier|*
name|pmclog_reserve
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|uintptr_t
name|newptr
decl_stmt|,
name|oldptr
decl_stmt|;
name|uint32_t
modifier|*
name|lh
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|PMCDBG2
argument_list|(
name|LOG
argument_list|,
name|ALL
argument_list|,
literal|1
argument_list|,
literal|"po=%p len=%d"
argument_list|,
name|po
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|length
operator|%
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"[pmclog,%d] length not a multiple of word size"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|)
expr_stmt|;
comment|/* No more data when shutdown in progress. */
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_SHUTDOWN
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|po
operator|->
name|po_curbuf
operator|==
name|NULL
condition|)
if|if
condition|(
name|pmclog_get_buffer
argument_list|(
name|po
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|po
operator|->
name|po_curbuf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmclog,%d] po=%p no current buffer"
operator|,
name|__LINE__
operator|,
name|po
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|>=
name|po
operator|->
name|po_curbuf
operator|->
name|plb_base
operator|&&
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|<=
name|po
operator|->
name|po_curbuf
operator|->
name|plb_fence
argument_list|,
operator|(
literal|"[pmclog,%d] po=%p buffer invariants: ptr=%p base=%p fence=%p"
operator|,
name|__LINE__
operator|,
name|po
operator|,
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|,
name|po
operator|->
name|po_curbuf
operator|->
name|plb_base
operator|,
name|po
operator|->
name|po_curbuf
operator|->
name|plb_fence
operator|)
argument_list|)
expr_stmt|;
name|oldptr
operator|=
operator|(
name|uintptr_t
operator|)
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
expr_stmt|;
name|newptr
operator|=
name|oldptr
operator|+
name|length
expr_stmt|;
name|KASSERT
argument_list|(
name|oldptr
operator|!=
operator|(
name|uintptr_t
operator|)
name|NULL
argument_list|,
operator|(
literal|"[pmclog,%d] po=%p Null log buffer pointer"
operator|,
name|__LINE__
operator|,
name|po
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we have space in the current buffer, return a pointer to 	 * available space with the PO structure locked. 	 */
if|if
condition|(
name|newptr
operator|<=
operator|(
name|uintptr_t
operator|)
name|po
operator|->
name|po_curbuf
operator|->
name|plb_fence
condition|)
block|{
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|newptr
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Otherwise, schedule the current buffer for output and get a 	 * fresh buffer. 	 */
name|pmclog_schedule_io
argument_list|(
name|po
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmclog_get_buffer
argument_list|(
name|po
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|po
operator|->
name|po_curbuf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmclog,%d] po=%p no current buffer"
operator|,
name|__LINE__
operator|,
name|po
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmclog,%d] null return from pmc_get_log_buffer"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|==
name|po
operator|->
name|po_curbuf
operator|->
name|plb_base
operator|&&
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|<=
name|po
operator|->
name|po_curbuf
operator|->
name|plb_fence
argument_list|,
operator|(
literal|"[pmclog,%d] po=%p buffer invariants: ptr=%p base=%p fence=%p"
operator|,
name|__LINE__
operator|,
name|po
operator|,
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|,
name|po
operator|->
name|po_curbuf
operator|->
name|plb_base
operator|,
name|po
operator|->
name|po_curbuf
operator|->
name|plb_fence
operator|)
argument_list|)
expr_stmt|;
name|oldptr
operator|=
operator|(
name|uintptr_t
operator|)
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
expr_stmt|;
name|done
label|:
name|lh
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|oldptr
expr_stmt|;
name|lh
operator|++
expr_stmt|;
comment|/* skip header */
name|getnanotime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
comment|/* fill in the timestamp */
operator|*
name|lh
operator|++
operator|=
name|ts
operator|.
name|tv_sec
operator|&
literal|0xFFFFFFFF
expr_stmt|;
operator|*
name|lh
operator|++
operator|=
name|ts
operator|.
name|tv_nsec
operator|&
literal|0xFFFFFFF
expr_stmt|;
return|return
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|oldptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Schedule an I/O.  *  * Transfer the current buffer to the helper kthread.  */
end_comment

begin_function
specifier|static
name|void
name|pmclog_schedule_io
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|po
operator|->
name|po_curbuf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmclog,%d] schedule_io with null buffer po=%p"
operator|,
name|__LINE__
operator|,
name|po
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|>=
name|po
operator|->
name|po_curbuf
operator|->
name|plb_base
argument_list|,
operator|(
literal|"[pmclog,%d] buffer invariants po=%p ptr=%p base=%p"
operator|,
name|__LINE__
operator|,
name|po
operator|,
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|,
name|po
operator|->
name|po_curbuf
operator|->
name|plb_base
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|<=
name|po
operator|->
name|po_curbuf
operator|->
name|plb_fence
argument_list|,
operator|(
literal|"[pmclog,%d] buffer invariants po=%p ptr=%p fenc=%p"
operator|,
name|__LINE__
operator|,
name|po
operator|,
name|po
operator|->
name|po_curbuf
operator|->
name|plb_ptr
operator|,
name|po
operator|->
name|po_curbuf
operator|->
name|plb_fence
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG1
argument_list|(
name|LOG
argument_list|,
name|SIO
argument_list|,
literal|1
argument_list|,
literal|"po=%p"
argument_list|,
name|po
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Add the current buffer to the tail of the buffer list and 	 * wakeup the helper. 	 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|po
operator|->
name|po_logbuffers
argument_list|,
name|po
operator|->
name|po_curbuf
argument_list|,
name|plb_next
argument_list|)
expr_stmt|;
name|po
operator|->
name|po_curbuf
operator|=
name|NULL
expr_stmt|;
name|wakeup_one
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop the helper kthread.  */
end_comment

begin_function
specifier|static
name|void
name|pmclog_stop_kthread
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pmc_kthread_mtx
argument_list|)
expr_stmt|;
name|po
operator|->
name|po_flags
operator|&=
operator|~
name|PMC_PO_OWNS_LOGFILE
expr_stmt|;
if|if
condition|(
name|po
operator|->
name|po_kthread
operator|!=
name|NULL
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|po
operator|->
name|po_kthread
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|po
operator|->
name|po_kthread
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|po
operator|->
name|po_kthread
argument_list|)
expr_stmt|;
block|}
name|wakeup_one
argument_list|(
name|po
argument_list|)
expr_stmt|;
while|while
condition|(
name|po
operator|->
name|po_kthread
condition|)
name|msleep
argument_list|(
name|po
operator|->
name|po_kthread
argument_list|,
operator|&
name|pmc_kthread_mtx
argument_list|,
name|PPAUSE
argument_list|,
literal|"pmckstp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pmc_kthread_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Public functions  */
end_comment

begin_comment
comment|/*  * Configure a log file for pmc owner 'po'.  *  * Parameter 'logfd' is a file handle referencing an open file in the  * owner process.  This file needs to have been opened for writing.  */
end_comment

begin_function
name|int
name|pmclog_configure_log
parameter_list|(
name|struct
name|pmc_mdep
modifier|*
name|md
parameter_list|,
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|int
name|logfd
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|cap_rights_t
name|rights
decl_stmt|;
comment|/* 	 * As long as it is possible to get a LOR between pmc_sx lock and 	 * proctree/allproc sx locks used for adding a new process, assure 	 * the former is not held here. 	 */
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SA_UNLOCKED
argument_list|)
expr_stmt|;
name|PMCDBG2
argument_list|(
name|LOG
argument_list|,
name|CFG
argument_list|,
literal|1
argument_list|,
literal|"config po=%p logfd=%d"
argument_list|,
name|po
argument_list|,
name|logfd
argument_list|)
expr_stmt|;
name|p
operator|=
name|po
operator|->
name|po_owner
expr_stmt|;
comment|/* return EBUSY if a log file was already present */
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_kthread
operator|==
name|NULL
argument_list|,
operator|(
literal|"[pmclog,%d] po=%p kthread (%p) already present"
operator|,
name|__LINE__
operator|,
name|po
operator|,
name|po
operator|->
name|po_kthread
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_file
operator|==
name|NULL
argument_list|,
operator|(
literal|"[pmclog,%d] po=%p file (%p) already present"
operator|,
name|__LINE__
operator|,
name|po
operator|,
name|po
operator|->
name|po_file
operator|)
argument_list|)
expr_stmt|;
comment|/* get a reference to the file state */
name|error
operator|=
name|fget_write
argument_list|(
name|curthread
argument_list|,
name|logfd
argument_list|,
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_WRITE
argument_list|)
argument_list|,
operator|&
name|po
operator|->
name|po_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
comment|/* mark process as owning a log file */
name|po
operator|->
name|po_flags
operator||=
name|PMC_PO_OWNS_LOGFILE
expr_stmt|;
name|error
operator|=
name|kproc_create
argument_list|(
name|pmclog_loop
argument_list|,
name|po
argument_list|,
operator|&
name|po
operator|->
name|po_kthread
argument_list|,
name|RFHIGHPID
argument_list|,
literal|0
argument_list|,
literal|"hwpmc: proc(%d)"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
comment|/* mark process as using HWPMCs */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* create a log initialization entry */
name|PMCLOG_RESERVE_WITH_ERROR
argument_list|(
name|po
argument_list|,
name|INITIALIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_initialize
argument_list|)
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|PMC_VERSION
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|md
operator|->
name|pmd_cputype
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
comment|/* shutdown the thread */
if|if
condition|(
name|po
operator|->
name|po_kthread
condition|)
name|pmclog_stop_kthread
argument_list|(
name|po
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_kthread
operator|==
name|NULL
argument_list|,
operator|(
literal|"[pmclog,%d] po=%p kthread not "
literal|"stopped"
operator|,
name|__LINE__
operator|,
name|po
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|po
operator|->
name|po_file
condition|)
operator|(
name|void
operator|)
name|fdrop
argument_list|(
name|po
operator|->
name|po_file
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|po
operator|->
name|po_file
operator|=
name|NULL
expr_stmt|;
comment|/* clear file and error state */
name|po
operator|->
name|po_error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * De-configure a log file.  This will throw away any buffers queued  * for this owner process.  */
end_comment

begin_function
name|int
name|pmclog_deconfigure_log
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|pmclog_buffer
modifier|*
name|lb
decl_stmt|;
name|PMCDBG1
argument_list|(
name|LOG
argument_list|,
name|CFG
argument_list|,
literal|1
argument_list|,
literal|"de-config po=%p"
argument_list|,
name|po
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_sscount
operator|==
literal|0
argument_list|,
operator|(
literal|"[pmclog,%d] po=%p still owning SS PMCs"
operator|,
name|__LINE__
operator|,
name|po
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_file
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmclog,%d] po=%p no log file"
operator|,
name|__LINE__
operator|,
name|po
operator|)
argument_list|)
expr_stmt|;
comment|/* stop the kthread, this will reset the 'OWNS_LOGFILE' flag */
name|pmclog_stop_kthread
argument_list|(
name|po
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_kthread
operator|==
name|NULL
argument_list|,
operator|(
literal|"[pmclog,%d] po=%p kthread not stopped"
operator|,
name|__LINE__
operator|,
name|po
operator|)
argument_list|)
expr_stmt|;
comment|/* return all queued log buffers to the global pool */
while|while
condition|(
operator|(
name|lb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|po
operator|->
name|po_logbuffers
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|po
operator|->
name|po_logbuffers
argument_list|,
name|lb
argument_list|,
name|plb_next
argument_list|)
expr_stmt|;
name|PMCLOG_INIT_BUFFER_DESCRIPTOR
argument_list|(
name|lb
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|pmc_bufferlist_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmc_bufferlist
argument_list|,
name|lb
argument_list|,
name|plb_next
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|pmc_bufferlist_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* return the 'current' buffer to the global pool */
if|if
condition|(
operator|(
name|lb
operator|=
name|po
operator|->
name|po_curbuf
operator|)
operator|!=
name|NULL
condition|)
block|{
name|PMCLOG_INIT_BUFFER_DESCRIPTOR
argument_list|(
name|lb
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|pmc_bufferlist_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmc_bufferlist
argument_list|,
name|lb
argument_list|,
name|plb_next
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|pmc_bufferlist_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* drop a reference to the fd */
if|if
condition|(
name|po
operator|->
name|po_file
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|fdrop
argument_list|(
name|po
operator|->
name|po_file
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|po
operator|->
name|po_file
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|error
operator|=
literal|0
expr_stmt|;
name|po
operator|->
name|po_error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush a process' log buffer.  */
end_comment

begin_function
name|int
name|pmclog_flush
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|pmclog_buffer
modifier|*
name|lb
decl_stmt|;
name|PMCDBG1
argument_list|(
name|LOG
argument_list|,
name|FLS
argument_list|,
literal|1
argument_list|,
literal|"po=%p"
argument_list|,
name|po
argument_list|)
expr_stmt|;
comment|/* 	 * If there is a pending error recorded by the logger thread, 	 * return that. 	 */
if|if
condition|(
name|po
operator|->
name|po_error
condition|)
return|return
operator|(
name|po
operator|->
name|po_error
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check that we do have an active log file. 	 */
name|mtx_lock
argument_list|(
operator|&
name|pmc_kthread_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_PO_OWNS_LOGFILE
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Schedule the current buffer if any and not empty. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|)
expr_stmt|;
name|lb
operator|=
name|po
operator|->
name|po_curbuf
expr_stmt|;
if|if
condition|(
name|lb
operator|&&
name|lb
operator|->
name|plb_ptr
operator|!=
name|lb
operator|->
name|plb_base
condition|)
block|{
name|pmclog_schedule_io
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOBUFS
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|)
expr_stmt|;
name|error
label|:
name|mtx_unlock
argument_list|(
operator|&
name|pmc_kthread_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pmclog_close
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
block|{
name|PMCDBG1
argument_list|(
name|LOG
argument_list|,
name|CLO
argument_list|,
literal|1
argument_list|,
literal|"po=%p"
argument_list|,
name|po
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pmc_kthread_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule the current buffer. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|po
operator|->
name|po_curbuf
condition|)
name|pmclog_schedule_io
argument_list|(
name|po
argument_list|)
expr_stmt|;
else|else
name|wakeup_one
argument_list|(
name|po
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|po
operator|->
name|po_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Initiate shutdown: no new data queued, 	 * thread will close file on last block. 	 */
name|po
operator|->
name|po_flags
operator||=
name|PMC_PO_SHUTDOWN
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pmc_kthread_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmclog_process_callchain
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|pmc_sample
modifier|*
name|ps
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|recordlen
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|PMCDBG3
argument_list|(
name|LOG
argument_list|,
name|SAM
argument_list|,
literal|1
argument_list|,
literal|"pm=%p pid=%d n=%d"
argument_list|,
name|pm
argument_list|,
name|ps
operator|->
name|ps_pid
argument_list|,
name|ps
operator|->
name|ps_nsamples
argument_list|)
expr_stmt|;
name|recordlen
operator|=
name|offsetof
argument_list|(
expr|struct
name|pmclog_callchain
argument_list|,
name|pl_pc
argument_list|)
operator|+
name|ps
operator|->
name|ps_nsamples
operator|*
sizeof|sizeof
argument_list|(
name|uintfptr_t
argument_list|)
expr_stmt|;
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
name|flags
operator|=
name|PMC_CALLCHAIN_TO_CPUFLAGS
argument_list|(
name|ps
operator|->
name|ps_cpu
argument_list|,
name|ps
operator|->
name|ps_flags
argument_list|)
expr_stmt|;
name|PMCLOG_RESERVE
argument_list|(
name|po
argument_list|,
name|CALLCHAIN
argument_list|,
name|recordlen
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|ps
operator|->
name|ps_pid
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pm
operator|->
name|pm_id
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ps
operator|->
name|ps_nsamples
condition|;
name|n
operator|++
control|)
name|PMCLOG_EMITADDR
argument_list|(
name|ps
operator|->
name|ps_pc
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmclog_process_closelog
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
block|{
name|PMCLOG_RESERVE
argument_list|(
name|po
argument_list|,
name|CLOSELOG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_closelog
argument_list|)
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmclog_process_dropnotify
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
block|{
name|PMCLOG_RESERVE
argument_list|(
name|po
argument_list|,
name|DROPNOTIFY
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_dropnotify
argument_list|)
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmclog_process_map_in
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|uintfptr_t
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|pathlen
decl_stmt|,
name|recordlen
decl_stmt|;
name|KASSERT
argument_list|(
name|path
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmclog,%d] map-in, null path"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|pathlen
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* #bytes for path name */
name|recordlen
operator|=
name|offsetof
argument_list|(
expr|struct
name|pmclog_map_in
argument_list|,
name|pl_pathname
argument_list|)
operator|+
name|pathlen
expr_stmt|;
name|PMCLOG_RESERVE
argument_list|(
name|po
argument_list|,
name|MAP_IN
argument_list|,
name|recordlen
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|PMCLOG_EMITADDR
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|PMCLOG_EMITSTRING
argument_list|(
name|path
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmclog_process_map_out
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|uintfptr_t
name|start
parameter_list|,
name|uintfptr_t
name|end
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|start
operator|<=
name|end
argument_list|,
operator|(
literal|"[pmclog,%d] start> end"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|PMCLOG_RESERVE
argument_list|(
name|po
argument_list|,
name|MAP_OUT
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_map_out
argument_list|)
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|PMCLOG_EMITADDR
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|PMCLOG_EMITADDR
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmclog_process_pmcallocate
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_soft
modifier|*
name|ps
decl_stmt|;
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
name|PMCDBG1
argument_list|(
name|LOG
argument_list|,
name|ALL
argument_list|,
literal|1
argument_list|,
literal|"pm=%p"
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|PMC_TO_CLASS
argument_list|(
name|pm
argument_list|)
operator|==
name|PMC_CLASS_SOFT
condition|)
block|{
name|PMCLOG_RESERVE
argument_list|(
name|po
argument_list|,
name|PMCALLOCATEDYN
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_pmcallocatedyn
argument_list|)
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pm
operator|->
name|pm_id
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pm
operator|->
name|pm_event
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pm
operator|->
name|pm_flags
argument_list|)
expr_stmt|;
name|ps
operator|=
name|pmc_soft_ev_acquire
argument_list|(
name|pm
operator|->
name|pm_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
name|PMCLOG_EMITSTRING
argument_list|(
name|ps
operator|->
name|ps_ev
operator|.
name|pm_ev_name
argument_list|,
name|PMC_NAME_MAX
argument_list|)
expr_stmt|;
else|else
name|PMCLOG_EMITNULLSTRING
argument_list|(
name|PMC_NAME_MAX
argument_list|)
expr_stmt|;
name|pmc_soft_ev_release
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PMCLOG_RESERVE
argument_list|(
name|po
argument_list|,
name|PMCALLOCATE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_pmcallocate
argument_list|)
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pm
operator|->
name|pm_id
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pm
operator|->
name|pm_event
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pm
operator|->
name|pm_flags
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pmclog_process_pmcattach
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|pathlen
decl_stmt|,
name|recordlen
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|PMCDBG2
argument_list|(
name|LOG
argument_list|,
name|ATT
argument_list|,
literal|1
argument_list|,
literal|"pm=%p pid=%d"
argument_list|,
name|pm
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
name|pathlen
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* #bytes for the string */
name|recordlen
operator|=
name|offsetof
argument_list|(
expr|struct
name|pmclog_pmcattach
argument_list|,
name|pl_pathname
argument_list|)
operator|+
name|pathlen
expr_stmt|;
name|PMCLOG_RESERVE
argument_list|(
name|po
argument_list|,
name|PMCATTACH
argument_list|,
name|recordlen
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pm
operator|->
name|pm_id
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|PMCLOG_EMITSTRING
argument_list|(
name|path
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmclog_process_pmcdetach
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|PMCDBG2
argument_list|(
name|LOG
argument_list|,
name|ATT
argument_list|,
literal|1
argument_list|,
literal|"!pm=%p pid=%d"
argument_list|,
name|pm
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
name|PMCLOG_RESERVE
argument_list|(
name|po
argument_list|,
name|PMCDETACH
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_pmcdetach
argument_list|)
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pm
operator|->
name|pm_id
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log a context switch event to the log file.  */
end_comment

begin_function
name|void
name|pmclog_process_proccsw
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|,
name|pmc_value_t
name|v
parameter_list|)
block|{
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_LOG_PROCCSW
argument_list|,
operator|(
literal|"[pmclog,%d] log-process-csw called gratuitously"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG3
argument_list|(
name|LOG
argument_list|,
name|SWO
argument_list|,
literal|1
argument_list|,
literal|"pm=%p pid=%d v=%jx"
argument_list|,
name|pm
argument_list|,
name|pp
operator|->
name|pp_proc
operator|->
name|p_pid
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
name|PMCLOG_RESERVE
argument_list|(
name|po
argument_list|,
name|PROCCSW
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_proccsw
argument_list|)
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pm
operator|->
name|pm_id
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT64
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pp
operator|->
name|pp_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmclog_process_procexec
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|pmc_id_t
name|pmid
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|uintfptr_t
name|startaddr
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|pathlen
decl_stmt|,
name|recordlen
decl_stmt|;
name|PMCDBG3
argument_list|(
name|LOG
argument_list|,
name|EXC
argument_list|,
literal|1
argument_list|,
literal|"po=%p pid=%d path=\"%s\""
argument_list|,
name|po
argument_list|,
name|pid
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|pathlen
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* #bytes for the path */
name|recordlen
operator|=
name|offsetof
argument_list|(
expr|struct
name|pmclog_procexec
argument_list|,
name|pl_pathname
argument_list|)
operator|+
name|pathlen
expr_stmt|;
name|PMCLOG_RESERVE
argument_list|(
name|po
argument_list|,
name|PROCEXEC
argument_list|,
name|recordlen
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|PMCLOG_EMITADDR
argument_list|(
name|startaddr
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pmid
argument_list|)
expr_stmt|;
name|PMCLOG_EMITSTRING
argument_list|(
name|path
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log a process exit event (and accumulated pmc value) to the log file.  */
end_comment

begin_function
name|void
name|pmclog_process_procexit
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|ri
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|ri
operator|=
name|PMC_TO_ROWINDEX
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|PMCDBG3
argument_list|(
name|LOG
argument_list|,
name|EXT
argument_list|,
literal|1
argument_list|,
literal|"pm=%p pid=%d v=%jx"
argument_list|,
name|pm
argument_list|,
name|pp
operator|->
name|pp_proc
operator|->
name|p_pid
argument_list|,
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmcval
argument_list|)
expr_stmt|;
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
name|PMCLOG_RESERVE
argument_list|(
name|po
argument_list|,
name|PROCEXIT
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_procexit
argument_list|)
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pm
operator|->
name|pm_id
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT64
argument_list|(
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmcval
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pp
operator|->
name|pp_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log a fork event.  */
end_comment

begin_function
name|void
name|pmclog_process_procfork
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|pid_t
name|oldpid
parameter_list|,
name|pid_t
name|newpid
parameter_list|)
block|{
name|PMCLOG_RESERVE
argument_list|(
name|po
argument_list|,
name|PROCFORK
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_procfork
argument_list|)
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|oldpid
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|newpid
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log a process exit event of the form suitable for system-wide PMCs.  */
end_comment

begin_function
name|void
name|pmclog_process_sysexit
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|PMCLOG_RESERVE
argument_list|(
name|po
argument_list|,
name|SYSEXIT
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_sysexit
argument_list|)
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a user log entry.  */
end_comment

begin_function
name|int
name|pmclog_process_userlog
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|struct
name|pmc_op_writelog
modifier|*
name|wl
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|PMCDBG2
argument_list|(
name|LOG
argument_list|,
name|WRI
argument_list|,
literal|1
argument_list|,
literal|"writelog po=%p ud=0x%x"
argument_list|,
name|po
argument_list|,
name|wl
operator|->
name|pm_userdata
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|PMCLOG_RESERVE_WITH_ERROR
argument_list|(
name|po
argument_list|,
name|USERDATA
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmclog_userdata
argument_list|)
argument_list|)
expr_stmt|;
name|PMCLOG_EMIT32
argument_list|(
name|wl
operator|->
name|pm_userdata
argument_list|)
expr_stmt|;
name|PMCLOG_DESPATCH
argument_list|(
name|po
argument_list|)
expr_stmt|;
name|error
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialization.  *  * Create a pool of log buffers and initialize mutexes.  */
end_comment

begin_function
name|void
name|pmclog_initialize
parameter_list|()
block|{
name|int
name|n
decl_stmt|;
name|struct
name|pmclog_buffer
modifier|*
name|plb
decl_stmt|;
if|if
condition|(
name|pmclog_buffer_size
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"hwpmc: tunable logbuffersize=%d must be "
literal|"greater than zero.\n"
argument_list|,
name|pmclog_buffer_size
argument_list|)
expr_stmt|;
name|pmclog_buffer_size
operator|=
name|PMC_LOG_BUFFER_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|pmc_nlogbuffers
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"hwpmc: tunable nlogbuffers=%d must be greater "
literal|"than zero.\n"
argument_list|,
name|pmc_nlogbuffers
argument_list|)
expr_stmt|;
name|pmc_nlogbuffers
operator|=
name|PMC_NLOGBUFFERS
expr_stmt|;
block|}
comment|/* create global pool of log buffers */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|pmc_nlogbuffers
condition|;
name|n
operator|++
control|)
block|{
name|plb
operator|=
name|malloc
argument_list|(
literal|1024
operator|*
name|pmclog_buffer_size
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|PMCLOG_INIT_BUFFER_DESCRIPTOR
argument_list|(
name|plb
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmc_bufferlist
argument_list|,
name|plb
argument_list|,
name|plb_next
argument_list|)
expr_stmt|;
block|}
name|mtx_init
argument_list|(
operator|&
name|pmc_bufferlist_mtx
argument_list|,
literal|"pmc-buffer-list"
argument_list|,
literal|"pmc-leaf"
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmc_kthread_mtx
argument_list|,
literal|"pmc-kthread"
argument_list|,
literal|"pmc-sleep"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shutdown logging.  *  * Destroy mutexes and release memory back the to free pool.  */
end_comment

begin_function
name|void
name|pmclog_shutdown
parameter_list|()
block|{
name|struct
name|pmclog_buffer
modifier|*
name|plb
decl_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pmc_kthread_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pmc_bufferlist_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|plb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmc_bufferlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmc_bufferlist
argument_list|,
name|plb
argument_list|,
name|plb_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|plb
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

