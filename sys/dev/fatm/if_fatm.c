begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  * 	All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Author: Hartmut Brandt<harti@freebsd.org>  *  * Fore PCA200E driver for NATM  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_natm.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_BPF
end_ifdef

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_atm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/utopia/utopia.h>
end_include

begin_include
include|#
directive|include
file|<dev/fatm/if_fatmreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fatm/if_fatmvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/fatm/firmware.h>
end_include

begin_decl_stmt
name|devclass_t
name|fatm_devclass
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint16_t
name|vid
decl_stmt|;
name|uint16_t
name|did
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|fatm_devs
index|[]
init|=
block|{
block|{
literal|0x1127
block|,
literal|0x300
block|,
literal|"FORE PCA200E"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_struct
specifier|static
specifier|const
struct|struct
name|rate
block|{
name|uint32_t
name|ratio
decl_stmt|;
name|uint32_t
name|cell_rate
decl_stmt|;
block|}
name|rate_table
index|[]
init|=
block|{
include|#
directive|include
file|<dev/fatm/if_fatm_rate.h>
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|RATE_TABLE_SIZE
value|(sizeof(rate_table) / sizeof(rate_table[0]))
end_define

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_atm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fatm
argument_list|,
name|utopia
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|fatm_utopia_readregs
parameter_list|(
name|struct
name|ifatm
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fatm_utopia_writereg
parameter_list|(
name|struct
name|ifatm
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|utopia_methods
name|fatm_utopia_methods
init|=
block|{
name|fatm_utopia_readregs
block|,
name|fatm_utopia_writereg
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VC_OK
parameter_list|(
name|SC
parameter_list|,
name|VPI
parameter_list|,
name|VCI
parameter_list|)
define|\
value|(((VPI)& ~((1<< IFP2IFATM((SC)->ifp)->mib.vpi_bits) - 1)) == 0&&	\ 	 (VCI) != 0&& ((VCI)& ~((1<< IFP2IFATM((SC)->ifp)->mib.vci_bits) - 1)) == 0)
end_define

begin_function_decl
specifier|static
name|int
name|fatm_load_vc
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|card_vcc
modifier|*
name|vc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Probing is easy: step trough the list of known vendor and device  * ids and compare. If one is found - it's our.  */
end_comment

begin_function
specifier|static
name|int
name|fatm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fatm_devs
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|fatm_devs
index|[
name|i
index|]
operator|.
name|vid
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|fatm_devs
index|[
name|i
index|]
operator|.
name|did
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|fatm_devs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function called at completion of a SUNI writeregs/readregs command.  * This is called from the interrupt handler while holding the softc lock.  * We use the queue entry as the randevouze point.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_utopia_writeregs_complete
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cmdqueue
modifier|*
name|q
parameter_list|)
block|{
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|&
name|FATM_STAT_ERROR
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|suni_reg_errors
operator|++
expr_stmt|;
name|q
operator|->
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|wakeup
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a SUNI register. The bits that are 1 in mask are written from val  * into register reg. We wait for the command to complete by sleeping on  * the register memory.  *  * We assume, that we already hold the softc mutex.  */
end_comment

begin_function
specifier|static
name|int
name|fatm_utopia_writereg
parameter_list|(
name|struct
name|ifatm
modifier|*
name|ifatm
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|u_int
name|mask
parameter_list|,
name|u_int
name|val
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|cmdqueue
modifier|*
name|q
decl_stmt|;
name|struct
name|fatm_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifatm
operator|->
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|FATM_CHECKLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifatm
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* get queue element and fill it */
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|cmdqueue
argument_list|,
expr|struct
name|cmdqueue
argument_list|,
name|sc
operator|->
name|cmdqueue
operator|.
name|head
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|&
name|FATM_STAT_FREE
operator|)
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|cmd_queue_full
operator|++
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|NEXT_QUEUE_ENTRY
argument_list|(
name|sc
operator|->
name|cmdqueue
operator|.
name|head
argument_list|,
name|FATM_CMD_QLEN
argument_list|)
expr_stmt|;
name|q
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|cb
operator|=
name|fatm_utopia_writeregs_complete
expr_stmt|;
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|FATM_STAT_PENDING
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
name|FATMOC_GETOC3_BUF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
name|FATMOC_OP
argument_list|,
name|FATM_MAKE_SETOC3
argument_list|(
name|reg
argument_list|,
name|val
argument_list|,
name|mask
argument_list|)
operator||
name|FATM_OP_INTERRUPT_SEL
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the command to complete 	 */
name|error
operator|=
name|msleep
argument_list|(
name|q
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"fatm_setreg"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EWOULDBLOCK
case|:
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
name|error
operator|=
name|EINTR
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|error
operator|=
name|q
operator|->
name|error
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function called at completion of a SUNI readregs command.  * This is called from the interrupt handler while holding the softc lock.  * We use reg_mem as the randevouze point.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_utopia_readregs_complete
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cmdqueue
modifier|*
name|q
parameter_list|)
block|{
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|&
name|FATM_STAT_ERROR
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|suni_reg_errors
operator|++
expr_stmt|;
name|q
operator|->
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|reg_mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read SUNI registers  *  * We use a preallocated buffer to read the registers. Therefor we need  * to protect against multiple threads trying to read registers. We do this  * with a condition variable and a flag. We wait for the command to complete by sleeping on  * the register memory.  *  * We assume, that we already hold the softc mutex.  */
end_comment

begin_function
specifier|static
name|int
name|fatm_utopia_readregs_internal
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|ptr
decl_stmt|;
name|struct
name|cmdqueue
modifier|*
name|q
decl_stmt|;
comment|/* get the buffer */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FATM_REGS_INUSE
operator|)
condition|)
break|break;
name|cv_wait
argument_list|(
operator|&
name|sc
operator|->
name|cv_regs
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|flags
operator||=
name|FATM_REGS_INUSE
expr_stmt|;
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|cmdqueue
argument_list|,
expr|struct
name|cmdqueue
argument_list|,
name|sc
operator|->
name|cmdqueue
operator|.
name|head
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|&
name|FATM_STAT_FREE
operator|)
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|cmd_queue_full
operator|++
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|NEXT_QUEUE_ENTRY
argument_list|(
name|sc
operator|->
name|cmdqueue
operator|.
name|head
argument_list|,
name|FATM_CMD_QLEN
argument_list|)
expr_stmt|;
name|q
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|cb
operator|=
name|fatm_utopia_readregs_complete
expr_stmt|;
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|FATM_STAT_PENDING
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|reg_mem
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|reg_mem
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
name|FATMOC_GETOC3_BUF
argument_list|,
name|sc
operator|->
name|reg_mem
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
name|FATMOC_OP
argument_list|,
name|FATM_OP_OC3_GET_REG
operator||
name|FATM_OP_INTERRUPT_SEL
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the command to complete 	 */
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|reg_mem
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"fatm_getreg"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EWOULDBLOCK
case|:
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
name|error
operator|=
name|EINTR
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|reg_mem
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|reg_mem
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|error
operator|=
name|q
operator|->
name|error
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* declare buffer to be free */
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FATM_REGS_INUSE
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|cv_regs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* swap if needed */
name|ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|sc
operator|->
name|reg_mem
operator|.
name|mem
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FATM_NREGS
condition|;
name|i
operator|++
control|)
name|ptr
index|[
name|i
index|]
operator|=
name|le32toh
argument_list|(
name|ptr
index|[
name|i
index|]
argument_list|)
operator|&
literal|0xff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read SUNI registers for the SUNI module.  *  * We assume, that we already hold the mutex.  */
end_comment

begin_function
specifier|static
name|int
name|fatm_utopia_readregs
parameter_list|(
name|struct
name|ifatm
modifier|*
name|ifatm
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|uint8_t
modifier|*
name|valp
parameter_list|,
name|u_int
modifier|*
name|np
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|fatm_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|reg
operator|>=
name|FATM_NREGS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|reg
operator|+
operator|*
name|np
operator|>
name|FATM_NREGS
condition|)
operator|*
name|np
operator|=
name|FATM_NREGS
operator|-
name|reg
expr_stmt|;
name|sc
operator|=
name|ifatm
operator|->
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|FATM_CHECKLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|fatm_utopia_readregs_internal
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|np
condition|;
name|i
operator|++
control|)
name|valp
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|sc
operator|->
name|reg_mem
operator|.
name|mem
operator|)
index|[
name|reg
operator|+
name|i
index|]
expr_stmt|;
comment|/* declare buffer to be free */
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FATM_REGS_INUSE
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|cv_regs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check whether the hard is beating. We remember the last heart beat and  * compare it to the current one. If it appears stuck for 10 times, we have  * a problem.  *  * Assume we hold the lock.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_check_heartbeat
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|h
decl_stmt|;
name|FATM_CHECKLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|h
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|FATMO_HEARTBEAT
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|BEAT
argument_list|,
operator|(
literal|"heartbeat %08x"
operator|,
name|h
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|stop_cnt
operator|==
literal|10
condition|)
return|return;
if|if
condition|(
name|h
operator|==
name|sc
operator|->
name|heartbeat
condition|)
block|{
if|if
condition|(
operator|++
name|sc
operator|->
name|stop_cnt
operator|==
literal|10
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"i960 stopped???\n"
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_HIMR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|sc
operator|->
name|stop_cnt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|heartbeat
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ensure that the heart is still beating.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fatm_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|FATM_CHECKLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fatm_check_heartbeat
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_timer
argument_list|,
name|hz
operator|*
literal|5
argument_list|,
name|fatm_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hard reset the i960 on the board. This is done by initializing registers,  * clearing interrupts and waiting for the selftest to finish. Not sure,  * whether all these barriers are actually needed.  *  * Assumes that we hold the lock.  */
end_comment

begin_function
specifier|static
name|int
name|fatm_reset
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|w
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|FATM_CHECKLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_APP_BASE
argument_list|,
name|FATMO_COMMON_ORIGIN
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_UART_TO_960
argument_list|,
name|XMIT_READY
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_UART_TO_HOST
argument_list|,
name|XMIT_READY
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_BOOT_STATUS
argument_list|,
name|COLD_START
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE1
argument_list|(
name|sc
argument_list|,
name|FATMO_HCR
argument_list|,
name|FATM_HCR_RESET
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|WRITE1
argument_list|(
name|sc
argument_list|,
name|FATMO_HCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BARRIER_RW
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|w
operator|=
literal|100
init|;
name|w
condition|;
name|w
operator|--
control|)
block|{
name|BARRIER_R
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|FATMO_BOOT_STATUS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|SELF_TEST_OK
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SELF_TEST_FAIL
case|:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop the card. Must be called WITH the lock held  * Reset, free transmit and receive buffers. Wakeup everybody who may sleep.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_stop
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|cmdqueue
modifier|*
name|q
decl_stmt|;
name|struct
name|rbuf
modifier|*
name|rb
decl_stmt|;
name|struct
name|txqueue
modifier|*
name|tx
decl_stmt|;
name|uint32_t
name|stat
decl_stmt|;
name|FATM_CHECKLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Stop the board */
name|utopia_stop
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fatm_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop watchdog */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|ATMEV_SEND_IFSTATE_CHANGED
argument_list|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|utopia
operator|.
name|carrier
operator|==
name|UTP_CARR_OK
argument_list|)
expr_stmt|;
comment|/* 		 * Collect transmit mbufs, partial receive mbufs and 		 * supplied mbufs 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FATM_TX_QLEN
condition|;
name|i
operator|++
control|)
block|{
name|tx
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|txqueue
argument_list|,
expr|struct
name|txqueue
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|m
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|tx
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tx
operator|->
name|m
argument_list|)
expr_stmt|;
name|tx
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Collect supplied mbufs */
while|while
condition|(
operator|(
name|rb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_used
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rbuf_tag
argument_list|,
name|rb
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|rb
operator|->
name|m
argument_list|)
expr_stmt|;
name|rb
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_free
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* Unwait any waiters */
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sadi_mem
argument_list|)
expr_stmt|;
comment|/* wakeup all threads waiting for STAT or REG buffers */
name|cv_broadcast
argument_list|(
operator|&
name|sc
operator|->
name|cv_stat
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|sc
operator|->
name|cv_regs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|FATM_STAT_INUSE
operator||
name|FATM_REGS_INUSE
operator|)
expr_stmt|;
comment|/* wakeup all threads waiting on commands */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FATM_CMD_QLEN
condition|;
name|i
operator|++
control|)
block|{
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|cmdqueue
argument_list|,
expr|struct
name|cmdqueue
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|=
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|)
operator|!=
name|FATM_STAT_FREE
condition|)
block|{
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|stat
operator||
name|FATM_STAT_ERROR
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
name|utopia_reset_media
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|small_cnt
operator|=
name|sc
operator|->
name|large_cnt
operator|=
literal|0
expr_stmt|;
comment|/* Reset vcc info */
if|if
condition|(
name|sc
operator|->
name|vccs
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|open_vccs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FORE_MAX_VCC
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|->
name|vflags
operator|&
operator|(
name|FATM_VCC_OPEN
operator||
name|FATM_VCC_TRY_OPEN
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|uma_zfree
argument_list|(
name|sc
operator|->
name|vcc_zone
argument_list|,
name|sc
operator|->
name|vccs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|->
name|vflags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|open_vccs
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Load the firmware into the board and save the entry point.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|firmware_load
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|firmware
modifier|*
name|fw
init|=
operator|(
expr|struct
name|firmware
operator|*
operator|)
name|firmware
decl_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
operator|(
literal|"loading - entry=%x"
operator|,
name|fw
operator|->
name|entry
operator|)
argument_list|)
expr_stmt|;
name|bus_space_write_region_4
argument_list|(
name|sc
operator|->
name|memt
argument_list|,
name|sc
operator|->
name|memh
argument_list|,
name|fw
operator|->
name|offset
argument_list|,
name|firmware
argument_list|,
sizeof|sizeof
argument_list|(
name|firmware
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|firmware
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|BARRIER_RW
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|fw
operator|->
name|entry
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a character from the virtual UART. The availability of a character  * is signaled by a non-null value of the 32 bit register. The eating of  * the character by us is signalled to the card by setting that register  * to zero.  */
end_comment

begin_function
specifier|static
name|int
name|rx_getc
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|w
init|=
literal|50
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|c
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|FATMO_UART_TO_HOST
argument_list|)
expr_stmt|;
name|BARRIER_RW
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_UART_TO_HOST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DBGC
argument_list|(
name|sc
argument_list|,
name|UART
argument_list|,
operator|(
literal|"%c"
operator|,
name|c
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|&
literal|0xff
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Eat up characters from the board and stuff them in the bit-bucket.  */
end_comment

begin_function
specifier|static
name|void
name|rx_flush
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|w
init|=
literal|10000
decl_stmt|;
while|while
condition|(
name|w
operator|--
operator|&&
name|rx_getc
argument_list|(
name|sc
argument_list|)
operator|>=
literal|0
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*   * Write a character to the card. The UART is available if the register  * is zero.  */
end_comment

begin_function
specifier|static
name|int
name|tx_putc
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|c
parameter_list|)
block|{
name|int
name|w
init|=
literal|10
decl_stmt|;
name|int
name|c1
decl_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|c1
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|FATMO_UART_TO_960
argument_list|)
expr_stmt|;
name|BARRIER_RW
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|0
condition|)
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_UART_TO_960
argument_list|,
name|c
operator||
name|CHAR_AVAIL
argument_list|)
expr_stmt|;
name|DBGC
argument_list|(
name|sc
argument_list|,
name|UART
argument_list|,
operator|(
literal|"%c"
operator|,
name|c
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start the firmware. This is doing by issuing a 'go' command with  * the hex entry address of the firmware. Then we wait for the self-test to  * succeed.  */
end_comment

begin_function
specifier|static
name|int
name|fatm_start_firmware
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|start
parameter_list|)
block|{
specifier|static
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|u_int
name|w
decl_stmt|,
name|val
decl_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
operator|(
literal|"starting"
operator|)
argument_list|)
expr_stmt|;
name|rx_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tx_putc
argument_list|(
name|sc
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|rx_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tx_putc
argument_list|(
name|sc
argument_list|,
literal|'g'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rx_getc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tx_putc
argument_list|(
name|sc
argument_list|,
literal|'o'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rx_getc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tx_putc
argument_list|(
name|sc
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rx_getc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tx_putc
argument_list|(
name|sc
argument_list|,
name|hex
index|[
operator|(
name|start
operator|>>
literal|12
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rx_getc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tx_putc
argument_list|(
name|sc
argument_list|,
name|hex
index|[
operator|(
name|start
operator|>>
literal|8
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rx_getc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tx_putc
argument_list|(
name|sc
argument_list|,
name|hex
index|[
operator|(
name|start
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rx_getc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tx_putc
argument_list|(
name|sc
argument_list|,
name|hex
index|[
operator|(
name|start
operator|>>
literal|0
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rx_getc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tx_putc
argument_list|(
name|sc
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|rx_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|w
operator|=
literal|100
init|;
name|w
condition|;
name|w
operator|--
control|)
block|{
name|BARRIER_R
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|FATMO_BOOT_STATUS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|CP_RUNNING
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SELF_TEST_FAIL
case|:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize one card and host queue.  */
end_comment

begin_function
specifier|static
name|void
name|init_card_queue
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|fqueue
modifier|*
name|queue
parameter_list|,
name|int
name|qlen
parameter_list|,
name|size_t
name|qel_size
parameter_list|,
name|size_t
name|desc_size
parameter_list|,
name|cardoff_t
name|off
parameter_list|,
name|u_char
modifier|*
modifier|*
name|statpp
parameter_list|,
name|uint32_t
modifier|*
name|cardstat
parameter_list|,
name|u_char
modifier|*
name|descp
parameter_list|,
name|uint32_t
name|carddesc
parameter_list|)
block|{
name|struct
name|fqelem
modifier|*
name|el
init|=
name|queue
operator|->
name|chunk
decl_stmt|;
while|while
condition|(
name|qlen
operator|--
condition|)
block|{
name|el
operator|->
name|card
operator|=
name|off
expr_stmt|;
name|off
operator|+=
literal|8
expr_stmt|;
comment|/* size of card entry */
name|el
operator|->
name|statp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|*
name|statpp
operator|)
expr_stmt|;
operator|(
operator|*
name|statpp
operator|)
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|H_SETSTAT
argument_list|(
name|el
operator|->
name|statp
argument_list|,
name|FATM_STAT_FREE
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|el
operator|->
name|statp
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|el
operator|->
name|card
operator|+
name|FATMOS_STATP
argument_list|,
operator|(
operator|*
name|cardstat
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cardstat
operator|)
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|el
operator|->
name|ioblk
operator|=
name|descp
expr_stmt|;
name|descp
operator|+=
name|desc_size
expr_stmt|;
name|el
operator|->
name|card_ioblk
operator|=
name|carddesc
expr_stmt|;
name|carddesc
operator|+=
name|desc_size
expr_stmt|;
name|el
operator|=
operator|(
expr|struct
name|fqelem
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|el
operator|+
name|qel_size
operator|)
expr_stmt|;
block|}
name|queue
operator|->
name|tail
operator|=
name|queue
operator|->
name|head
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Issue the initialize operation to the card, wait for completion and  * initialize the on-board and host queue structures with offsets and  * addresses.  */
end_comment

begin_function
specifier|static
name|int
name|fatm_init_cmd
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|w
decl_stmt|,
name|c
decl_stmt|;
name|u_char
modifier|*
name|statp
decl_stmt|;
name|uint32_t
name|card_stat
decl_stmt|;
name|u_int
name|cnt
decl_stmt|;
name|struct
name|fqelem
modifier|*
name|el
decl_stmt|;
name|cardoff_t
name|off
decl_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
operator|(
literal|"command"
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_ISTAT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_IMASK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_HLOGGER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_RECEIVE_TRESHOLD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_NUM_CONNECT
argument_list|,
name|FORE_MAX_VCC
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_CQUEUE_LEN
argument_list|,
name|FATM_CMD_QLEN
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_TQUEUE_LEN
argument_list|,
name|FATM_TX_QLEN
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_RQUEUE_LEN
argument_list|,
name|FATM_RX_QLEN
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_RPD_EXTENSION
argument_list|,
name|RPD_EXTENSIONS
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_TPD_EXTENSION
argument_list|,
name|TPD_EXTENSIONS
argument_list|)
expr_stmt|;
comment|/* 	 * initialize buffer descriptors 	 */
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_SMALL_B1
operator|+
name|FATMOB_QUEUE_LENGTH
argument_list|,
name|SMALL_SUPPLY_QLEN
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_SMALL_B1
operator|+
name|FATMOB_BUFFER_SIZE
argument_list|,
name|SMALL_BUFFER_LEN
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_SMALL_B1
operator|+
name|FATMOB_POOL_SIZE
argument_list|,
name|SMALL_POOL_SIZE
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_SMALL_B1
operator|+
name|FATMOB_SUPPLY_BLKSIZE
argument_list|,
name|SMALL_SUPPLY_BLKSIZE
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_LARGE_B1
operator|+
name|FATMOB_QUEUE_LENGTH
argument_list|,
name|LARGE_SUPPLY_QLEN
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_LARGE_B1
operator|+
name|FATMOB_BUFFER_SIZE
argument_list|,
name|LARGE_BUFFER_LEN
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_LARGE_B1
operator|+
name|FATMOB_POOL_SIZE
argument_list|,
name|LARGE_POOL_SIZE
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_LARGE_B1
operator|+
name|FATMOB_SUPPLY_BLKSIZE
argument_list|,
name|LARGE_SUPPLY_BLKSIZE
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_SMALL_B2
operator|+
name|FATMOB_QUEUE_LENGTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_SMALL_B2
operator|+
name|FATMOB_BUFFER_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_SMALL_B2
operator|+
name|FATMOB_POOL_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_SMALL_B2
operator|+
name|FATMOB_SUPPLY_BLKSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_LARGE_B2
operator|+
name|FATMOB_QUEUE_LENGTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_LARGE_B2
operator|+
name|FATMOB_BUFFER_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_LARGE_B2
operator|+
name|FATMOB_POOL_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_LARGE_B2
operator|+
name|FATMOB_SUPPLY_BLKSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Start the command 	 */
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_STATUS
argument_list|,
name|FATM_STAT_PENDING
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_OP
argument_list|,
name|FATM_OP_INITIALIZE
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Busy wait for completion 	 */
name|w
operator|=
literal|100
expr_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|c
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|FATMO_INIT
operator|+
name|FATMOI_STATUS
argument_list|)
expr_stmt|;
name|BARRIER_R
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|FATM_STAT_COMPLETE
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|&
name|FATM_STAT_ERROR
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* 	 * Initialize the queues 	 */
name|statp
operator|=
name|sc
operator|->
name|stat_mem
operator|.
name|mem
expr_stmt|;
name|card_stat
operator|=
name|sc
operator|->
name|stat_mem
operator|.
name|paddr
expr_stmt|;
comment|/* 	 * Command queue. This is special in that it's on the card. 	 */
name|el
operator|=
name|sc
operator|->
name|cmdqueue
operator|.
name|chunk
expr_stmt|;
name|off
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|FATMO_COMMAND_QUEUE
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
operator|(
literal|"cmd queue=%x"
operator|,
name|off
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|FATM_CMD_QLEN
condition|;
name|cnt
operator|++
control|)
block|{
name|el
operator|=
operator|&
operator|(
operator|(
expr|struct
name|cmdqueue
operator|*
operator|)
name|sc
operator|->
name|cmdqueue
operator|.
name|chunk
operator|+
name|cnt
operator|)
operator|->
name|q
expr_stmt|;
name|el
operator|->
name|card
operator|=
name|off
expr_stmt|;
name|off
operator|+=
literal|32
expr_stmt|;
comment|/* size of card structure */
name|el
operator|->
name|statp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|statp
expr_stmt|;
name|statp
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|H_SETSTAT
argument_list|(
name|el
operator|->
name|statp
argument_list|,
name|FATM_STAT_FREE
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|el
operator|->
name|statp
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|el
operator|->
name|card
operator|+
name|FATMOC_STATP
argument_list|,
name|card_stat
argument_list|)
expr_stmt|;
name|card_stat
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|cmdqueue
operator|.
name|tail
operator|=
name|sc
operator|->
name|cmdqueue
operator|.
name|head
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Now the other queues. These are in memory 	 */
name|init_card_queue
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txqueue
argument_list|,
name|FATM_TX_QLEN
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|txqueue
argument_list|)
argument_list|,
name|TPD_SIZE
argument_list|,
name|READ4
argument_list|(
name|sc
argument_list|,
name|FATMO_TRANSMIT_QUEUE
argument_list|)
argument_list|,
operator|&
name|statp
argument_list|,
operator|&
name|card_stat
argument_list|,
name|sc
operator|->
name|txq_mem
operator|.
name|mem
argument_list|,
name|sc
operator|->
name|txq_mem
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|init_card_queue
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxqueue
argument_list|,
name|FATM_RX_QLEN
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rxqueue
argument_list|)
argument_list|,
name|RPD_SIZE
argument_list|,
name|READ4
argument_list|(
name|sc
argument_list|,
name|FATMO_RECEIVE_QUEUE
argument_list|)
argument_list|,
operator|&
name|statp
argument_list|,
operator|&
name|card_stat
argument_list|,
name|sc
operator|->
name|rxq_mem
operator|.
name|mem
argument_list|,
name|sc
operator|->
name|rxq_mem
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|init_card_queue
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|s1queue
argument_list|,
name|SMALL_SUPPLY_QLEN
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|supqueue
argument_list|)
argument_list|,
name|BSUP_BLK2SIZE
argument_list|(
name|SMALL_SUPPLY_BLKSIZE
argument_list|)
argument_list|,
name|READ4
argument_list|(
name|sc
argument_list|,
name|FATMO_SMALL_B1_QUEUE
argument_list|)
argument_list|,
operator|&
name|statp
argument_list|,
operator|&
name|card_stat
argument_list|,
name|sc
operator|->
name|s1q_mem
operator|.
name|mem
argument_list|,
name|sc
operator|->
name|s1q_mem
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|init_card_queue
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|l1queue
argument_list|,
name|LARGE_SUPPLY_QLEN
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|supqueue
argument_list|)
argument_list|,
name|BSUP_BLK2SIZE
argument_list|(
name|LARGE_SUPPLY_BLKSIZE
argument_list|)
argument_list|,
name|READ4
argument_list|(
name|sc
argument_list|,
name|FATMO_LARGE_B1_QUEUE
argument_list|)
argument_list|,
operator|&
name|statp
argument_list|,
operator|&
name|card_stat
argument_list|,
name|sc
operator|->
name|l1q_mem
operator|.
name|mem
argument_list|,
name|sc
operator|->
name|l1q_mem
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txcnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read PROM. Called only from attach code. Here we spin because the interrupt  * handler is not yet set up.  */
end_comment

begin_function
specifier|static
name|int
name|fatm_getprom
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|prom
modifier|*
name|prom
decl_stmt|;
name|struct
name|cmdqueue
modifier|*
name|q
decl_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
operator|(
literal|"reading prom"
operator|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|cmdqueue
argument_list|,
expr|struct
name|cmdqueue
argument_list|,
name|sc
operator|->
name|cmdqueue
operator|.
name|head
argument_list|)
expr_stmt|;
name|NEXT_QUEUE_ENTRY
argument_list|(
name|sc
operator|->
name|cmdqueue
operator|.
name|head
argument_list|,
name|FATM_CMD_QLEN
argument_list|)
expr_stmt|;
name|q
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|cb
operator|=
name|NULL
expr_stmt|;
empty_stmt|;
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|FATM_STAT_PENDING
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|prom_mem
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|prom_mem
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
name|FATMOC_GPROM_BUF
argument_list|,
name|sc
operator|->
name|prom_mem
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
name|FATMOC_OP
argument_list|,
name|FATM_OP_GET_PROM_DATA
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|&
operator|(
name|FATM_STAT_COMPLETE
operator||
name|FATM_STAT_ERROR
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1000
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"getprom timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|&
name|FATM_STAT_ERROR
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"getprom error\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|FATM_STAT_FREE
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|NEXT_QUEUE_ENTRY
argument_list|(
name|sc
operator|->
name|cmdqueue
operator|.
name|tail
argument_list|,
name|FATM_CMD_QLEN
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|prom_mem
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|prom_mem
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
block|{
name|u_int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"PROM: "
argument_list|)
expr_stmt|;
name|u_char
modifier|*
name|ptr
init|=
operator|(
name|u_char
operator|*
operator|)
name|sc
operator|->
name|prom_mem
operator|.
name|mem
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|prom
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x "
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|prom
operator|=
operator|(
expr|struct
name|prom
operator|*
operator|)
name|sc
operator|->
name|prom_mem
operator|.
name|mem
expr_stmt|;
name|bcopy
argument_list|(
name|prom
operator|->
name|mac
operator|+
literal|2
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|serial
operator|=
name|le32toh
argument_list|(
name|prom
operator|->
name|serial
argument_list|)
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|hw_version
operator|=
name|le32toh
argument_list|(
name|prom
operator|->
name|version
argument_list|)
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|sw_version
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|FATMO_FIRMWARE_RELEASE
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"ESI=%02x:%02x:%02x:%02x:%02x:%02x "
literal|"serial=%u hw=0x%x sw=0x%x\n"
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|0
index|]
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|1
index|]
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|2
index|]
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|3
index|]
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|4
index|]
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|5
index|]
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|serial
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|hw_version
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|sw_version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the callback function for bus_dmamap_load. We assume, that we  * have a 32-bit bus and so have always one segment.  */
end_comment

begin_function
specifier|static
name|void
name|dmaload_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|ptr
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: error=%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"too many DMA segments"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|<=
literal|0xffffffff
argument_list|,
operator|(
literal|"DMA address too large %lx"
operator|,
operator|(
name|u_long
operator|)
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|)
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a chunk of DMA-able memory and map it.  */
end_comment

begin_function
specifier|static
name|int
name|alloc_dma_memory
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|struct
name|fatm_mem
modifier|*
name|mem
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mem
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
name|mem
operator|->
name|align
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|mem
operator|->
name|size
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|mem
operator|->
name|dmat
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"could not allocate %s DMA tag\n"
argument_list|,
name|nm
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
operator|&
name|mem
operator|->
name|mem
argument_list|,
literal|0
argument_list|,
operator|&
name|mem
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"could not allocate %s DMA memory: "
literal|"%d\n"
argument_list|,
name|nm
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|mem
operator|->
name|dmat
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
name|mem
operator|->
name|map
argument_list|,
name|mem
operator|->
name|mem
argument_list|,
name|mem
operator|->
name|size
argument_list|,
name|dmaload_helper
argument_list|,
operator|&
name|mem
operator|->
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"could not load %s DMA memory: "
literal|"%d\n"
argument_list|,
name|nm
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
name|mem
operator|->
name|mem
argument_list|,
name|mem
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|mem
operator|->
name|dmat
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|DBG
argument_list|(
name|sc
argument_list|,
name|DMA
argument_list|,
operator|(
literal|"DMA %s V/P/S/Z %p/%lx/%x/%x"
operator|,
name|nm
operator|,
name|mem
operator|->
name|mem
operator|,
operator|(
name|u_long
operator|)
name|mem
operator|->
name|paddr
operator|,
name|mem
operator|->
name|size
operator|,
name|mem
operator|->
name|align
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_DMA_SYNC
end_ifdef

begin_function
specifier|static
name|int
name|alloc_dma_memoryX
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|struct
name|fatm_mem
modifier|*
name|mem
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mem
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
name|mem
operator|->
name|align
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_24BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|mem
operator|->
name|size
argument_list|,
literal|1
argument_list|,
name|mem
operator|->
name|size
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|mem
operator|->
name|dmat
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"could not allocate %s DMA tag\n"
argument_list|,
name|nm
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mem
operator|->
name|mem
operator|=
name|contigmalloc
argument_list|(
name|mem
operator|->
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
name|BUS_SPACE_MAXADDR_24BIT
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|mem
operator|->
name|align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|mem
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"could not allocate %s DMA map: "
literal|"%d\n"
argument_list|,
name|nm
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|mem
operator|->
name|mem
argument_list|,
name|mem
operator|->
name|size
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|mem
operator|->
name|dmat
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
name|mem
operator|->
name|map
argument_list|,
name|mem
operator|->
name|mem
argument_list|,
name|mem
operator|->
name|size
argument_list|,
name|dmaload_helper
argument_list|,
operator|&
name|mem
operator|->
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"could not load %s DMA memory: "
literal|"%d\n"
argument_list|,
name|nm
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
name|mem
operator|->
name|map
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|mem
operator|->
name|mem
argument_list|,
name|mem
operator|->
name|size
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|mem
operator|->
name|dmat
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|DBG
argument_list|(
name|sc
argument_list|,
name|DMA
argument_list|,
operator|(
literal|"DMAX %s V/P/S/Z %p/%lx/%x/%x"
operator|,
name|nm
operator|,
name|mem
operator|->
name|mem
operator|,
operator|(
name|u_long
operator|)
name|mem
operator|->
name|paddr
operator|,
name|mem
operator|->
name|size
operator|,
name|mem
operator|->
name|align
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DMAX: %s V/P/S/Z %p/%lx/%x/%x"
argument_list|,
name|nm
argument_list|,
name|mem
operator|->
name|mem
argument_list|,
operator|(
name|u_long
operator|)
name|mem
operator|->
name|paddr
argument_list|,
name|mem
operator|->
name|size
argument_list|,
name|mem
operator|->
name|align
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_DMA_SYNC */
end_comment

begin_comment
comment|/*  * Destroy all resources of an dma-able memory chunk  */
end_comment

begin_function
specifier|static
name|void
name|destroy_dma_memory
parameter_list|(
name|struct
name|fatm_mem
modifier|*
name|mem
parameter_list|)
block|{
if|if
condition|(
name|mem
operator|->
name|mem
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
name|mem
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
name|mem
operator|->
name|mem
argument_list|,
name|mem
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|mem
operator|->
name|dmat
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_DMA_SYNC
end_ifdef

begin_function
specifier|static
name|void
name|destroy_dma_memoryX
parameter_list|(
name|struct
name|fatm_mem
modifier|*
name|mem
parameter_list|)
block|{
if|if
condition|(
name|mem
operator|->
name|mem
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
name|mem
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
name|mem
operator|->
name|map
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|mem
operator|->
name|mem
argument_list|,
name|mem
operator|->
name|size
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|mem
operator|->
name|dmat
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_DMA_SYNC */
end_comment

begin_comment
comment|/*  * Try to supply buffers to the card if there are free entries in the queues  */
end_comment

begin_function
specifier|static
name|void
name|fatm_supply_small_buffers
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|nblocks
decl_stmt|,
name|nbufs
decl_stmt|;
name|struct
name|supqueue
modifier|*
name|q
decl_stmt|;
name|struct
name|rbd
modifier|*
name|bd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|,
name|cnt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|rbuf
modifier|*
name|rb
decl_stmt|;
name|bus_addr_t
name|phys
decl_stmt|;
name|nbufs
operator|=
name|max
argument_list|(
literal|4
operator|*
name|sc
operator|->
name|open_vccs
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|nbufs
operator|=
name|min
argument_list|(
name|nbufs
argument_list|,
name|SMALL_POOL_SIZE
argument_list|)
expr_stmt|;
name|nbufs
operator|-=
name|sc
operator|->
name|small_cnt
expr_stmt|;
name|nblocks
operator|=
operator|(
name|nbufs
operator|+
name|SMALL_SUPPLY_BLKSIZE
operator|-
literal|1
operator|)
operator|/
name|SMALL_SUPPLY_BLKSIZE
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|nblocks
condition|;
name|cnt
operator|++
control|)
block|{
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|s1queue
argument_list|,
expr|struct
name|supqueue
argument_list|,
name|sc
operator|->
name|s1queue
operator|.
name|head
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|!=
name|FATM_STAT_FREE
condition|)
break|break;
name|bd
operator|=
operator|(
expr|struct
name|rbd
operator|*
operator|)
name|q
operator|->
name|q
operator|.
name|ioblk
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SMALL_SUPPLY_BLKSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_free
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"out of rbufs\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_free
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
break|break;
block|}
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
name|SMALL_BUFFER_LEN
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|rbuf_tag
argument_list|,
name|rb
operator|->
name|map
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|SMALL_BUFFER_LEN
argument_list|,
name|dmaload_helper
argument_list|,
operator|&
name|phys
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"dmamap_load mbuf failed %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_free
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
break|break;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rbuf_tag
argument_list|,
name|rb
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_used
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rb
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|bd
index|[
name|i
index|]
operator|.
name|handle
operator|=
name|rb
operator|-
name|sc
operator|->
name|rbufs
expr_stmt|;
name|H_SETDESC
argument_list|(
name|bd
index|[
name|i
index|]
operator|.
name|buffer
argument_list|,
name|phys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|SMALL_SUPPLY_BLKSIZE
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|rb
operator|=
name|sc
operator|->
name|rbufs
operator|+
name|bd
index|[
name|j
index|]
operator|.
name|handle
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rbuf_tag
argument_list|,
name|rb
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|rb
operator|->
name|m
argument_list|)
expr_stmt|;
name|rb
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_free
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|H_SYNCQ_PREWRITE
argument_list|(
operator|&
name|sc
operator|->
name|s1q_mem
argument_list|,
name|bd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rbd
argument_list|)
operator|*
name|SMALL_SUPPLY_BLKSIZE
argument_list|)
expr_stmt|;
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|FATM_STAT_PENDING
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
argument_list|,
name|q
operator|->
name|q
operator|.
name|card_ioblk
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|small_cnt
operator|+=
name|SMALL_SUPPLY_BLKSIZE
expr_stmt|;
name|NEXT_QUEUE_ENTRY
argument_list|(
name|sc
operator|->
name|s1queue
operator|.
name|head
argument_list|,
name|SMALL_SUPPLY_QLEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Try to supply buffers to the card if there are free entries in the queues  * We assume that all buffers are within the address space accessible by the  * card (32-bit), so we don't need bounce buffers.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_supply_large_buffers
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|nbufs
decl_stmt|,
name|nblocks
decl_stmt|,
name|cnt
decl_stmt|;
name|struct
name|supqueue
modifier|*
name|q
decl_stmt|;
name|struct
name|rbd
modifier|*
name|bd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|rbuf
modifier|*
name|rb
decl_stmt|;
name|bus_addr_t
name|phys
decl_stmt|;
name|nbufs
operator|=
name|max
argument_list|(
literal|4
operator|*
name|sc
operator|->
name|open_vccs
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|nbufs
operator|=
name|min
argument_list|(
name|nbufs
argument_list|,
name|LARGE_POOL_SIZE
argument_list|)
expr_stmt|;
name|nbufs
operator|-=
name|sc
operator|->
name|large_cnt
expr_stmt|;
name|nblocks
operator|=
operator|(
name|nbufs
operator|+
name|LARGE_SUPPLY_BLKSIZE
operator|-
literal|1
operator|)
operator|/
name|LARGE_SUPPLY_BLKSIZE
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|nblocks
condition|;
name|cnt
operator|++
control|)
block|{
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|l1queue
argument_list|,
expr|struct
name|supqueue
argument_list|,
name|sc
operator|->
name|l1queue
operator|.
name|head
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|!=
name|FATM_STAT_FREE
condition|)
break|break;
name|bd
operator|=
operator|(
expr|struct
name|rbd
operator|*
operator|)
name|q
operator|->
name|q
operator|.
name|ioblk
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LARGE_SUPPLY_BLKSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_free
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"out of rbufs\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_free
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* No MEXT_ALIGN */
name|m
operator|->
name|m_data
operator|+=
name|MCLBYTES
operator|-
name|LARGE_BUFFER_LEN
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|rbuf_tag
argument_list|,
name|rb
operator|->
name|map
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|LARGE_BUFFER_LEN
argument_list|,
name|dmaload_helper
argument_list|,
operator|&
name|phys
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"dmamap_load mbuf failed %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_free
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
break|break;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rbuf_tag
argument_list|,
name|rb
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_used
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rb
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|bd
index|[
name|i
index|]
operator|.
name|handle
operator|=
name|rb
operator|-
name|sc
operator|->
name|rbufs
expr_stmt|;
name|H_SETDESC
argument_list|(
name|bd
index|[
name|i
index|]
operator|.
name|buffer
argument_list|,
name|phys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|LARGE_SUPPLY_BLKSIZE
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|rb
operator|=
name|sc
operator|->
name|rbufs
operator|+
name|bd
index|[
name|j
index|]
operator|.
name|handle
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rbuf_tag
argument_list|,
name|rb
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|rb
operator|->
name|m
argument_list|)
expr_stmt|;
name|rb
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_free
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|H_SYNCQ_PREWRITE
argument_list|(
operator|&
name|sc
operator|->
name|l1q_mem
argument_list|,
name|bd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rbd
argument_list|)
operator|*
name|LARGE_SUPPLY_BLKSIZE
argument_list|)
expr_stmt|;
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|FATM_STAT_PENDING
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
argument_list|,
name|q
operator|->
name|q
operator|.
name|card_ioblk
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|large_cnt
operator|+=
name|LARGE_SUPPLY_BLKSIZE
expr_stmt|;
name|NEXT_QUEUE_ENTRY
argument_list|(
name|sc
operator|->
name|l1queue
operator|.
name|head
argument_list|,
name|LARGE_SUPPLY_QLEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Actually start the card. The lock must be held here.  * Reset, load the firmware, start it, initializes queues, read the PROM  * and supply receive buffers to the card.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_init_locked
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|rxqueue
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|error
decl_stmt|;
name|uint32_t
name|start
decl_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
operator|(
literal|"initialize"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|fatm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Hard reset the board 	 */
if|if
condition|(
name|fatm_reset
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
name|start
operator|=
name|firmware_load
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fatm_start_firmware
argument_list|(
name|sc
argument_list|,
name|start
argument_list|)
operator|||
name|fatm_init_cmd
argument_list|(
name|sc
argument_list|)
operator|||
name|fatm_getprom
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|fatm_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Handle media 	 */
name|c
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|FATMO_MEDIA_TYPE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|FORE_MT_TAXI_100
case|:
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_TAXI_100
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
literal|227273
expr_stmt|;
break|break;
case|case
name|FORE_MT_TAXI_140
case|:
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_TAXI_140
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
literal|318181
expr_stmt|;
break|break;
case|case
name|FORE_MT_UTP_SONET
case|:
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_UTP_155
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
literal|353207
expr_stmt|;
break|break;
case|case
name|FORE_MT_MM_OC3_ST
case|:
case|case
name|FORE_MT_MM_OC3_SC
case|:
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_MM_155
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
literal|353207
expr_stmt|;
break|break;
case|case
name|FORE_MT_SM_OC3_ST
case|:
case|case
name|FORE_MT_SM_OC3_SC
case|:
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_SM_155
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
literal|353207
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fatm: unknown media type %d\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_UNKNOWN
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
literal|353207
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|ifp
operator|->
name|if_baudrate
operator|=
literal|53
operator|*
literal|8
operator|*
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
expr_stmt|;
name|utopia_init_media
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the RBDs 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FATM_RX_QLEN
condition|;
name|i
operator|++
control|)
block|{
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|rxqueue
argument_list|,
expr|struct
name|rxqueue
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
literal|0
argument_list|,
name|q
operator|->
name|q
operator|.
name|card_ioblk
argument_list|)
expr_stmt|;
block|}
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Supply buffers to the card 	 */
name|fatm_supply_small_buffers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fatm_supply_large_buffers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Now set flags, that we are ready 	 */
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* 	 * Start the watchdog timer 	 */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_timer
argument_list|,
name|hz
operator|*
literal|5
argument_list|,
name|fatm_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* start SUNI */
name|utopia_start
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|ATMEV_SEND_IFSTATE_CHANGED
argument_list|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|utopia
operator|.
name|carrier
operator|==
name|UTP_CARR_OK
argument_list|)
expr_stmt|;
comment|/* start all channels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FORE_MAX_VCC
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|->
name|vflags
operator||=
name|FATM_VCC_REOPEN
expr_stmt|;
name|error
operator|=
name|fatm_load_vc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|vccs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"reopening %u "
literal|"failed: %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|->
name|vflags
operator|&=
operator|~
name|FATM_VCC_REOPEN
expr_stmt|;
block|}
block|}
name|DBG
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
operator|(
literal|"done"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the exported as initialisation function.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_init
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|fatm_softc
modifier|*
name|sc
init|=
name|p
decl_stmt|;
name|FATM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fatm_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  * The INTERRUPT handling  */
end_comment

begin_comment
comment|/*  * Check the command queue. If a command was completed, call the completion  * function for that command.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_intr_drain_cmd
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cmdqueue
modifier|*
name|q
decl_stmt|;
name|int
name|stat
decl_stmt|;
comment|/* 	 * Drain command queue 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|cmdqueue
argument_list|,
expr|struct
name|cmdqueue
argument_list|,
name|sc
operator|->
name|cmdqueue
operator|.
name|tail
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|stat
operator|=
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|FATM_STAT_COMPLETE
operator|&&
name|stat
operator|!=
operator|(
name|FATM_STAT_COMPLETE
operator||
name|FATM_STAT_ERROR
operator|)
operator|&&
name|stat
operator|!=
name|FATM_STAT_ERROR
condition|)
break|break;
call|(
modifier|*
name|q
operator|->
name|cb
call|)
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|FATM_STAT_FREE
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|NEXT_QUEUE_ENTRY
argument_list|(
name|sc
operator|->
name|cmdqueue
operator|.
name|tail
argument_list|,
name|FATM_CMD_QLEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Drain the small buffer supply queue.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_intr_drain_small_buffers
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|supqueue
modifier|*
name|q
decl_stmt|;
name|int
name|stat
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|s1queue
argument_list|,
expr|struct
name|supqueue
argument_list|,
name|sc
operator|->
name|s1queue
operator|.
name|tail
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|stat
operator|=
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|FATM_STAT_COMPLETE
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|stat
operator|&
name|FATM_STAT_ERROR
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: status %x\n"
argument_list|,
name|__func__
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|FATM_STAT_FREE
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|NEXT_QUEUE_ENTRY
argument_list|(
name|sc
operator|->
name|s1queue
operator|.
name|tail
argument_list|,
name|SMALL_SUPPLY_QLEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Drain the large buffer supply queue.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_intr_drain_large_buffers
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|supqueue
modifier|*
name|q
decl_stmt|;
name|int
name|stat
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|l1queue
argument_list|,
expr|struct
name|supqueue
argument_list|,
name|sc
operator|->
name|l1queue
operator|.
name|tail
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|stat
operator|=
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|FATM_STAT_COMPLETE
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|stat
operator|&
name|FATM_STAT_ERROR
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s status %x\n"
argument_list|,
name|__func__
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|FATM_STAT_FREE
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|NEXT_QUEUE_ENTRY
argument_list|(
name|sc
operator|->
name|l1queue
operator|.
name|tail
argument_list|,
name|LARGE_SUPPLY_QLEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check the receive queue. Send any received PDU up the protocol stack  * (except when there was an error or the VCI appears to be closed. In this  * case discard the PDU).  */
end_comment

begin_function
specifier|static
name|void
name|fatm_intr_drain_rx
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|rxqueue
modifier|*
name|q
decl_stmt|;
name|int
name|stat
decl_stmt|,
name|mlen
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|uint32_t
name|h
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|last
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
name|struct
name|rpd
modifier|*
name|rpd
decl_stmt|;
name|struct
name|rbuf
modifier|*
name|rb
decl_stmt|;
name|u_int
name|vci
decl_stmt|,
name|vpi
decl_stmt|,
name|pt
decl_stmt|;
name|struct
name|atm_pseudohdr
name|aph
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|card_vcc
modifier|*
name|vc
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|rxqueue
argument_list|,
expr|struct
name|rxqueue
argument_list|,
name|sc
operator|->
name|rxqueue
operator|.
name|tail
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|stat
operator|=
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|FATM_STAT_COMPLETE
operator|)
operator|==
literal|0
condition|)
break|break;
name|rpd
operator|=
operator|(
expr|struct
name|rpd
operator|*
operator|)
name|q
operator|->
name|q
operator|.
name|ioblk
expr_stmt|;
name|H_SYNCQ_POSTREAD
argument_list|(
operator|&
name|sc
operator|->
name|rxq_mem
argument_list|,
name|rpd
argument_list|,
name|RPD_SIZE
argument_list|)
expr_stmt|;
name|rpd
operator|->
name|nseg
operator|=
name|le32toh
argument_list|(
name|rpd
operator|->
name|nseg
argument_list|)
expr_stmt|;
name|mlen
operator|=
literal|0
expr_stmt|;
name|m0
operator|=
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rpd
operator|->
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|rb
operator|=
name|sc
operator|->
name|rbufs
operator|+
name|rpd
operator|->
name|segment
index|[
name|i
index|]
operator|.
name|handle
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|m0
operator|=
name|last
operator|=
name|rb
operator|->
name|m
expr_stmt|;
block|}
else|else
block|{
name|last
operator|->
name|m_next
operator|=
name|rb
operator|->
name|m
expr_stmt|;
name|last
operator|=
name|rb
operator|->
name|m
expr_stmt|;
block|}
name|last
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|sc
operator|->
name|large_cnt
operator|--
expr_stmt|;
else|else
name|sc
operator|->
name|small_cnt
operator|--
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rbuf_tag
argument_list|,
name|rb
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rbuf_tag
argument_list|,
name|rb
operator|->
name|map
argument_list|)
expr_stmt|;
name|rb
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_free
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|last
operator|->
name|m_len
operator|=
name|le32toh
argument_list|(
name|rpd
operator|->
name|segment
index|[
name|i
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|mlen
operator|+=
name|last
operator|->
name|m_len
expr_stmt|;
block|}
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mlen
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|h
operator|=
name|le32toh
argument_list|(
name|rpd
operator|->
name|atm_header
argument_list|)
expr_stmt|;
name|vpi
operator|=
operator|(
name|h
operator|>>
literal|20
operator|)
operator|&
literal|0xff
expr_stmt|;
name|vci
operator|=
operator|(
name|h
operator|>>
literal|4
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|pt
operator|=
operator|(
name|h
operator|>>
literal|1
operator|)
operator|&
literal|0x7
expr_stmt|;
comment|/* 		 * Locate the VCC this packet belongs to 		 */
if|if
condition|(
operator|!
name|VC_OK
argument_list|(
name|sc
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
condition|)
name|vc
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|vc
operator|=
name|sc
operator|->
name|vccs
index|[
name|vci
index|]
operator|)
operator|==
name|NULL
operator|||
operator|!
operator|(
name|sc
operator|->
name|vccs
index|[
name|vci
index|]
operator|->
name|vflags
operator|&
name|FATM_VCC_OPEN
operator|)
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|rx_closed
operator|++
expr_stmt|;
name|vc
operator|=
name|NULL
expr_stmt|;
block|}
name|DBG
argument_list|(
name|sc
argument_list|,
name|RCV
argument_list|,
operator|(
literal|"RCV: vc=%u.%u pt=%u mlen=%d %s"
operator|,
name|vpi
operator|,
name|vci
operator|,
name|pt
operator|,
name|mlen
operator|,
name|vc
operator|==
name|NULL
condition|?
literal|"dropped"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vc
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ENABLE_BPF
if|if
condition|(
operator|!
operator|(
name|vc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATMIO_FLAG_NG
operator|)
operator|&&
name|vc
operator|->
name|param
operator|.
name|aal
operator|==
name|ATMIO_AAL_5
operator|&&
operator|(
name|vc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATM_PH_LLCSNAP
operator|)
condition|)
name|BPF_MTAP
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ATM_PH_FLAGS
argument_list|(
operator|&
name|aph
argument_list|)
operator|=
name|vc
operator|->
name|param
operator|.
name|flags
expr_stmt|;
name|ATM_PH_VPI
argument_list|(
operator|&
name|aph
argument_list|)
operator|=
name|vpi
expr_stmt|;
name|ATM_PH_SETVCI
argument_list|(
operator|&
name|aph
argument_list|,
name|vci
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|vc
operator|->
name|ipackets
operator|++
expr_stmt|;
name|vc
operator|->
name|ibytes
operator|+=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|atm_input
argument_list|(
name|ifp
argument_list|,
operator|&
name|aph
argument_list|,
name|m0
argument_list|,
name|vc
operator|->
name|rxhand
argument_list|)
expr_stmt|;
block|}
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|FATM_STAT_FREE
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
argument_list|,
name|q
operator|->
name|q
operator|.
name|card_ioblk
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NEXT_QUEUE_ENTRY
argument_list|(
name|sc
operator|->
name|rxqueue
operator|.
name|tail
argument_list|,
name|FATM_RX_QLEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check the transmit queue. Free the mbuf chains that we were transmitting.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_intr_drain_tx
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|txqueue
modifier|*
name|q
decl_stmt|;
name|int
name|stat
decl_stmt|;
comment|/* 	 * Drain tx queue 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|txqueue
argument_list|,
expr|struct
name|txqueue
argument_list|,
name|sc
operator|->
name|txqueue
operator|.
name|tail
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|stat
operator|=
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|FATM_STAT_COMPLETE
operator|&&
name|stat
operator|!=
operator|(
name|FATM_STAT_COMPLETE
operator||
name|FATM_STAT_ERROR
operator|)
operator|&&
name|stat
operator|!=
name|FATM_STAT_ERROR
condition|)
break|break;
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|FATM_STAT_FREE
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|q
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|q
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|q
operator|->
name|m
argument_list|)
expr_stmt|;
name|q
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|txcnt
operator|--
expr_stmt|;
name|NEXT_QUEUE_ENTRY
argument_list|(
name|sc
operator|->
name|txqueue
operator|.
name|tail
argument_list|,
name|FATM_TX_QLEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Interrupt handler  */
end_comment

begin_function
specifier|static
name|void
name|fatm_intr
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|fatm_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fatm_softc
operator|*
operator|)
name|p
decl_stmt|;
name|FATM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|READ4
argument_list|(
name|sc
argument_list|,
name|FATMO_PSR
argument_list|)
condition|)
block|{
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|FATMO_HCR
argument_list|,
name|FATM_HCR_CLRIRQ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|fatm_intr_drain_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fatm_intr_drain_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fatm_intr_drain_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fatm_intr_drain_small_buffers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fatm_intr_drain_large_buffers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fatm_supply_small_buffers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fatm_supply_large_buffers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|retry_tx
operator|&&
name|_IF_QLEN
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
call|(
modifier|*
name|sc
operator|->
name|ifp
operator|->
name|if_start
call|)
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get device statistics. This must be called with the softc locked.  * We use a preallocated buffer, so we need to protect this buffer.  * We do this by using a condition variable and a flag. If the flag is set  * the buffer is in use by one thread (one thread is executing a GETSTAT  * card command). In this case all other threads that are trying to get  * statistics block on that condition variable. When the thread finishes  * using the buffer it resets the flag and signals the condition variable. This  * will wakeup the next thread that is waiting for the buffer. If the interface  * is stopped the stopping function will broadcast the cv. All threads will  * find that the interface has been stopped and return.  *  * Aquiring of the buffer is done by the fatm_getstat() function. The freeing  * must be done by the caller when he has finished using the buffer.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_getstat_complete
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cmdqueue
modifier|*
name|q
parameter_list|)
block|{
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|&
name|FATM_STAT_ERROR
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|get_stat_errors
operator|++
expr_stmt|;
name|q
operator|->
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sadi_mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fatm_getstat
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|cmdqueue
modifier|*
name|q
decl_stmt|;
comment|/* 	 * Wait until either the interface is stopped or we can get the 	 * statistics buffer 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FATM_STAT_INUSE
operator|)
condition|)
break|break;
name|cv_wait
argument_list|(
operator|&
name|sc
operator|->
name|cv_stat
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|flags
operator||=
name|FATM_STAT_INUSE
expr_stmt|;
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|cmdqueue
argument_list|,
expr|struct
name|cmdqueue
argument_list|,
name|sc
operator|->
name|cmdqueue
operator|.
name|head
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|&
name|FATM_STAT_FREE
operator|)
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|cmd_queue_full
operator|++
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|NEXT_QUEUE_ENTRY
argument_list|(
name|sc
operator|->
name|cmdqueue
operator|.
name|head
argument_list|,
name|FATM_CMD_QLEN
argument_list|)
expr_stmt|;
name|q
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|cb
operator|=
name|fatm_getstat_complete
expr_stmt|;
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|FATM_STAT_PENDING
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sadi_mem
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|sadi_mem
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
name|FATMOC_GSTAT_BUF
argument_list|,
name|sc
operator|->
name|sadi_mem
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
name|FATMOC_OP
argument_list|,
name|FATM_OP_REQUEST_STATS
operator||
name|FATM_OP_INTERRUPT_SEL
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the command to complete 	 */
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|sadi_mem
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"fatm_stat"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EWOULDBLOCK
case|:
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
name|error
operator|=
name|EINTR
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sadi_mem
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|sadi_mem
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|error
operator|=
name|q
operator|->
name|error
expr_stmt|;
break|break;
block|}
comment|/* 	 * Swap statistics 	 */
if|if
condition|(
name|q
operator|->
name|error
operator|==
literal|0
condition|)
block|{
name|u_int
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|p
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|sc
operator|->
name|sadi_mem
operator|.
name|mem
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|fatm_stats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|be32toh
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a copy of a single mbuf. It can have either internal or  * external data, it may have a packet header. External data is really  * copied, so the new buffer is writeable.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|copy_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|new
decl_stmt|;
name|MGET
argument_list|(
name|new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|M_MOVE_PKTHDR
argument_list|(
name|new
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
name|MHLEN
condition|)
name|MCLGET
argument_list|(
name|new
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
name|MLEN
condition|)
name|MCLGET
argument_list|(
name|new
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|new
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|new
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|new
operator|->
name|m_flags
operator|&=
operator|~
name|M_RDONLY
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * All segments must have a four byte aligned buffer address and a four  * byte aligned length. Step through an mbuf chain and check these conditions.  * If the buffer address is not aligned and this is a normal mbuf, move  * the data down. Else make a copy of the mbuf with aligned data.  * If the buffer length is not aligned steel data from the next mbuf.  * We don't need to check whether this has more than one external reference,  * because steeling data doesn't change the external cluster.  * If the last mbuf is not aligned, fill with zeroes.  *  * Return packet length (well we should have this in the packet header),  * but be careful not to count the zero fill at the end.  *  * If fixing fails free the chain and zero the pointer.  *  * We assume, that aligning the virtual address also aligns the mapped bus  * address.  */
end_comment

begin_function
specifier|static
name|u_int
name|fatm_fix_chain
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|u_int
name|mlen
init|=
literal|0
decl_stmt|,
name|fill
init|=
literal|0
decl_stmt|;
name|int
name|first
decl_stmt|,
name|off
decl_stmt|;
name|u_char
modifier|*
name|d
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
do|do
block|{
name|next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
operator|%
literal|4
operator|!=
literal|0
operator|||
operator|(
name|m
operator|->
name|m_len
operator|%
literal|4
operator|!=
literal|0
operator|&&
name|next
operator|)
condition|)
block|{
comment|/* 			 * Needs fixing 			 */
name|first
operator|=
operator|(
name|m
operator|==
operator|*
name|mp
operator|)
expr_stmt|;
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|=
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|d
operator|%
literal|4
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|M_WRITABLE
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|fix_addr_copy
operator|++
expr_stmt|;
name|bcopy
argument_list|(
name|d
argument_list|,
name|d
operator|-
name|off
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|d
operator|-
name|off
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|new
operator|=
name|copy_mbuf
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|fix_addr_noext
operator|++
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|istats
operator|.
name|fix_addr_ext
operator|++
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|m_next
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|m_next
operator|=
name|next
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|new
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|off
operator|=
name|m
operator|->
name|m_len
operator|%
literal|4
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|M_WRITABLE
argument_list|(
name|m
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|new
operator|=
name|copy_mbuf
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|fix_len_noext
operator|++
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|istats
operator|.
name|fix_len_copy
operator|++
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|m_next
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|m_next
operator|=
name|next
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|new
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|istats
operator|.
name|fix_len
operator|++
expr_stmt|;
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
name|off
operator|=
literal|4
operator|-
name|off
expr_stmt|;
while|while
condition|(
name|off
condition|)
block|{
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|0
expr_stmt|;
name|fill
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|fix_empty
operator|++
expr_stmt|;
name|next
operator|=
name|m_free
argument_list|(
name|next
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|cp
operator|=
name|mtod
argument_list|(
name|next
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|next
operator|->
name|m_len
operator|--
expr_stmt|;
name|next
operator|->
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
name|cp
expr_stmt|;
block|}
name|off
operator|--
expr_stmt|;
name|m
operator|->
name|m_len
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
condition|)
operator|*
name|mp
operator|=
name|m
expr_stmt|;
block|}
name|mlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|prev
operator|=
name|m
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|m
operator|=
name|next
operator|)
operator|!=
name|NULL
condition|)
do|;
return|return
operator|(
name|mlen
operator|-
name|fill
operator|)
return|;
name|fail
label|:
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The helper function is used to load the computed physical addresses  * into the transmit descriptor.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_tpd_load
parameter_list|(
name|void
modifier|*
name|varg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|tpd
modifier|*
name|tpd
init|=
name|varg
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|KASSERT
argument_list|(
name|nsegs
operator|<=
name|TPD_EXTENSIONS
operator|+
name|TXD_FIXED
argument_list|,
operator|(
literal|"too many segments"
operator|)
argument_list|)
expr_stmt|;
name|tpd
operator|->
name|spec
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nsegs
operator|--
condition|)
block|{
name|H_SETDESC
argument_list|(
name|tpd
operator|->
name|segment
index|[
name|tpd
operator|->
name|spec
index|]
operator|.
name|buffer
argument_list|,
name|segs
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|H_SETDESC
argument_list|(
name|tpd
operator|->
name|segment
index|[
name|tpd
operator|->
name|spec
index|]
operator|.
name|length
argument_list|,
name|segs
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|tpd
operator|->
name|spec
operator|++
expr_stmt|;
name|segs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start output.  *  * Note, that we update the internal statistics without the lock here.  */
end_comment

begin_function
specifier|static
name|int
name|fatm_tx
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|card_vcc
modifier|*
name|vc
parameter_list|,
name|u_int
name|mlen
parameter_list|)
block|{
name|struct
name|txqueue
modifier|*
name|q
decl_stmt|;
name|u_int
name|nblks
decl_stmt|;
name|int
name|error
decl_stmt|,
name|aal
decl_stmt|,
name|nsegs
decl_stmt|;
name|struct
name|tpd
modifier|*
name|tpd
decl_stmt|;
comment|/* 	 * Get a queue element. 	 * If there isn't one - try to drain the transmit queue 	 * We used to sleep here if that doesn't help, but we 	 * should not sleep here, because we are called with locks. 	 */
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|txqueue
argument_list|,
expr|struct
name|txqueue
argument_list|,
name|sc
operator|->
name|txqueue
operator|.
name|head
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|!=
name|FATM_STAT_FREE
condition|)
block|{
name|fatm_intr_drain_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|!=
name|FATM_STAT_FREE
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|retry_tx
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|tx_retry
operator|++
expr_stmt|;
name|IF_PREPEND
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|istats
operator|.
name|tx_queue_full
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|istats
operator|.
name|tx_queue_almost_full
operator|++
expr_stmt|;
block|}
name|tpd
operator|=
name|q
operator|->
name|q
operator|.
name|ioblk
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_BPF
if|if
condition|(
operator|!
operator|(
name|vc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATMIO_FLAG_NG
operator|)
operator|&&
name|vc
operator|->
name|param
operator|.
name|aal
operator|==
name|ATMIO_AAL_5
operator|&&
operator|(
name|vc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATM_PH_LLCSNAP
operator|)
condition|)
name|BPF_MTAP
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* map the mbuf */
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|q
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|fatm_tpd_load
argument_list|,
name|tpd
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"mbuf loaded error=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nsegs
operator|=
name|tpd
operator|->
name|spec
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|q
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * OK. Now go and do it. 	 */
name|aal
operator|=
operator|(
name|vc
operator|->
name|param
operator|.
name|aal
operator|==
name|ATMIO_AAL_5
operator|)
condition|?
literal|5
else|:
literal|0
expr_stmt|;
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|FATM_STAT_PENDING
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|q
operator|->
name|m
operator|=
name|m
expr_stmt|;
comment|/* 	 * If the transmit queue is almost full, schedule a 	 * transmit interrupt so that transmit descriptors can 	 * be recycled. 	 */
name|H_SETDESC
argument_list|(
name|tpd
operator|->
name|spec
argument_list|,
name|TDX_MKSPEC
argument_list|(
operator|(
name|sc
operator|->
name|txcnt
operator|>=
operator|(
literal|4
operator|*
name|FATM_TX_QLEN
operator|)
operator|/
literal|5
operator|)
argument_list|,
name|aal
argument_list|,
name|nsegs
argument_list|,
name|mlen
argument_list|)
argument_list|)
expr_stmt|;
name|H_SETDESC
argument_list|(
name|tpd
operator|->
name|atm_header
argument_list|,
name|TDX_MKHDR
argument_list|(
name|vc
operator|->
name|param
operator|.
name|vpi
argument_list|,
name|vc
operator|->
name|param
operator|.
name|vci
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vc
operator|->
name|param
operator|.
name|traffic
operator|==
name|ATMIO_TRAFFIC_UBR
condition|)
name|H_SETDESC
argument_list|(
name|tpd
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RATE_TABLE_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rate_table
index|[
name|i
index|]
operator|.
name|cell_rate
operator|<
name|vc
operator|->
name|param
operator|.
name|tparam
operator|.
name|pcr
condition|)
break|break;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|i
operator|--
expr_stmt|;
name|H_SETDESC
argument_list|(
name|tpd
operator|->
name|stream
argument_list|,
name|rate_table
index|[
name|i
index|]
operator|.
name|ratio
argument_list|)
expr_stmt|;
block|}
name|H_SYNCQ_PREWRITE
argument_list|(
operator|&
name|sc
operator|->
name|txq_mem
argument_list|,
name|tpd
argument_list|,
name|TPD_SIZE
argument_list|)
expr_stmt|;
name|nblks
operator|=
name|TDX_SEGS2BLKS
argument_list|(
name|nsegs
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|XMIT
argument_list|,
operator|(
literal|"XMIT: mlen=%d spec=0x%x nsegs=%d blocks=%d"
operator|,
name|mlen
operator|,
name|le32toh
argument_list|(
name|tpd
operator|->
name|spec
argument_list|)
operator|,
name|nsegs
operator|,
name|nblks
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
literal|0
argument_list|,
name|q
operator|->
name|q
operator|.
name|card_ioblk
operator||
name|nblks
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txcnt
operator|++
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|vc
operator|->
name|obytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|vc
operator|->
name|opackets
operator|++
expr_stmt|;
name|NEXT_QUEUE_ENTRY
argument_list|(
name|sc
operator|->
name|txqueue
operator|.
name|head
argument_list|,
name|FATM_TX_QLEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fatm_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|atm_pseudohdr
name|aph
decl_stmt|;
name|struct
name|fatm_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|mlen
decl_stmt|,
name|vpi
decl_stmt|,
name|vci
decl_stmt|;
name|struct
name|card_vcc
modifier|*
name|vc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Loop through the mbuf chain and compute the total length 		 * of the packet. Check that all data pointer are 		 * 4 byte aligned. If they are not, call fatm_mfix to 		 * fix that problem. This comes more or less from the 		 * en driver. 		 */
name|mlen
operator|=
name|fatm_fix_chain
argument_list|(
name|sc
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|aph
operator|=
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|atm_pseudohdr
operator|*
argument_list|)
expr_stmt|;
name|mlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlen
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mlen
operator|>
name|FATM_MAXPDU
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|tx_pdu2big
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|vci
operator|=
name|ATM_PH_VCI
argument_list|(
operator|&
name|aph
argument_list|)
expr_stmt|;
name|vpi
operator|=
name|ATM_PH_VPI
argument_list|(
operator|&
name|aph
argument_list|)
expr_stmt|;
comment|/* 		 * From here on we need the softc 		 */
name|FATM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|VC_OK
argument_list|(
name|sc
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
operator|||
operator|(
name|vc
operator|=
name|sc
operator|->
name|vccs
index|[
name|vci
index|]
operator|)
operator|==
name|NULL
operator|||
operator|!
operator|(
name|vc
operator|->
name|vflags
operator|&
name|FATM_VCC_OPEN
operator|)
condition|)
block|{
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fatm_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|vc
argument_list|,
name|mlen
argument_list|)
condition|)
block|{
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * VCC managment  *  * This may seem complicated. The reason for this is, that we need an  * asynchronuous open/close for the NATM VCCs because our ioctl handler  * is called with the radix node head of the routing table locked. Therefor  * we cannot sleep there and wait for the open/close to succeed. For this  * reason we just initiate the operation from the ioctl.  */
end_comment

begin_comment
comment|/*  * Command the card to open/close a VC.  * Return the queue entry for waiting if we are succesful.  */
end_comment

begin_function
specifier|static
name|struct
name|cmdqueue
modifier|*
name|fatm_start_vcc
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|vpi
parameter_list|,
name|u_int
name|vci
parameter_list|,
name|uint32_t
name|cmd
parameter_list|,
name|u_int
name|mtu
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|fatm_softc
modifier|*
parameter_list|,
name|struct
name|cmdqueue
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|cmdqueue
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|cmdqueue
argument_list|,
expr|struct
name|cmdqueue
argument_list|,
name|sc
operator|->
name|cmdqueue
operator|.
name|head
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|&
name|FATM_STAT_FREE
operator|)
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|cmd_queue_full
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|NEXT_QUEUE_ENTRY
argument_list|(
name|sc
operator|->
name|cmdqueue
operator|.
name|head
argument_list|,
name|FATM_CMD_QLEN
argument_list|)
expr_stmt|;
name|q
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|cb
operator|=
name|func
expr_stmt|;
name|H_SETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|,
name|FATM_STAT_PENDING
argument_list|)
expr_stmt|;
name|H_SYNCSTAT_PREWRITE
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
name|FATMOC_ACTIN_VPVC
argument_list|,
name|MKVPVC
argument_list|(
name|vpi
argument_list|,
name|vci
argument_list|)
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
name|FATMOC_ACTIN_MTU
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
name|FATMOC_OP
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The VC has been opened/closed and somebody has been waiting for this.  * Wake him up.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_cmd_complete
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cmdqueue
modifier|*
name|q
parameter_list|)
block|{
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|&
name|FATM_STAT_ERROR
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|get_stat_errors
operator|++
expr_stmt|;
name|q
operator|->
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|wakeup
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open complete  */
end_comment

begin_function
specifier|static
name|void
name|fatm_open_finish
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|card_vcc
modifier|*
name|vc
parameter_list|)
block|{
name|vc
operator|->
name|vflags
operator|&=
operator|~
name|FATM_VCC_TRY_OPEN
expr_stmt|;
name|vc
operator|->
name|vflags
operator||=
name|FATM_VCC_OPEN
expr_stmt|;
if|if
condition|(
name|vc
operator|->
name|vflags
operator|&
name|FATM_VCC_REOPEN
condition|)
block|{
name|vc
operator|->
name|vflags
operator|&=
operator|~
name|FATM_VCC_REOPEN
expr_stmt|;
return|return;
block|}
comment|/* inform management if this is not an NG 	 * VCC or it's an NG PVC. */
if|if
condition|(
operator|!
operator|(
name|vc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATMIO_FLAG_NG
operator|)
operator|||
operator|(
name|vc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATMIO_FLAG_PVC
operator|)
condition|)
name|ATMEV_SEND_VCC_CHANGED
argument_list|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|vc
operator|->
name|param
operator|.
name|vci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The VC that we have tried to open asynchronuosly has been opened.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_open_complete
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cmdqueue
modifier|*
name|q
parameter_list|)
block|{
name|u_int
name|vci
decl_stmt|;
name|struct
name|card_vcc
modifier|*
name|vc
decl_stmt|;
name|vci
operator|=
name|GETVCI
argument_list|(
name|READ4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
name|FATMOC_ACTIN_VPVC
argument_list|)
argument_list|)
expr_stmt|;
name|vc
operator|=
name|sc
operator|->
name|vccs
index|[
name|vci
index|]
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|&
name|FATM_STAT_ERROR
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|get_stat_errors
operator|++
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|vci
index|]
operator|=
name|NULL
expr_stmt|;
name|uma_zfree
argument_list|(
name|sc
operator|->
name|vcc_zone
argument_list|,
name|vc
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"opening VCI %u failed\n"
argument_list|,
name|vci
argument_list|)
expr_stmt|;
return|return;
block|}
name|fatm_open_finish
argument_list|(
name|sc
argument_list|,
name|vc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait on the queue entry until the VCC is opened/closed.  */
end_comment

begin_function
specifier|static
name|int
name|fatm_waitvcc
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cmdqueue
modifier|*
name|q
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * Wait for the command to complete 	 */
name|error
operator|=
name|msleep
argument_list|(
name|q
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"fatm_vci"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|q
operator|->
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start to open a VCC. This just initiates the operation.  */
end_comment

begin_function
specifier|static
name|int
name|fatm_open_vcc
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|atmio_openvcc
modifier|*
name|op
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|card_vcc
modifier|*
name|vc
decl_stmt|;
comment|/* 	 * Check parameters 	 */
if|if
condition|(
operator|(
name|op
operator|->
name|param
operator|.
name|flags
operator|&
name|ATMIO_FLAG_NOTX
operator|)
operator|&&
operator|(
name|op
operator|->
name|param
operator|.
name|flags
operator|&
name|ATMIO_FLAG_NORX
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|VC_OK
argument_list|(
name|sc
argument_list|,
name|op
operator|->
name|param
operator|.
name|vpi
argument_list|,
name|op
operator|->
name|param
operator|.
name|vci
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|op
operator|->
name|param
operator|.
name|aal
operator|!=
name|ATMIO_AAL_0
operator|&&
name|op
operator|->
name|param
operator|.
name|aal
operator|!=
name|ATMIO_AAL_5
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|vc
operator|=
name|uma_zalloc
argument_list|(
name|sc
operator|->
name|vcc_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|vc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|FATM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|op
operator|->
name|param
operator|.
name|vci
index|]
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|vc
operator|->
name|param
operator|=
name|op
operator|->
name|param
expr_stmt|;
name|vc
operator|->
name|rxhand
operator|=
name|op
operator|->
name|rxhand
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|param
operator|.
name|traffic
condition|)
block|{
case|case
name|ATMIO_TRAFFIC_UBR
case|:
break|break;
case|case
name|ATMIO_TRAFFIC_CBR
case|:
if|if
condition|(
name|op
operator|->
name|param
operator|.
name|tparam
operator|.
name|pcr
operator|==
literal|0
operator|||
name|op
operator|->
name|param
operator|.
name|tparam
operator|.
name|pcr
operator|>
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|vc
operator|->
name|ibytes
operator|=
name|vc
operator|->
name|obytes
operator|=
literal|0
expr_stmt|;
name|vc
operator|->
name|ipackets
operator|=
name|vc
operator|->
name|opackets
operator|=
literal|0
expr_stmt|;
name|vc
operator|->
name|vflags
operator|=
name|FATM_VCC_TRY_OPEN
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|op
operator|->
name|param
operator|.
name|vci
index|]
operator|=
name|vc
expr_stmt|;
name|sc
operator|->
name|open_vccs
operator|++
expr_stmt|;
name|error
operator|=
name|fatm_load_vc
argument_list|(
name|sc
argument_list|,
name|vc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|vccs
index|[
name|op
operator|->
name|param
operator|.
name|vci
index|]
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|open_vccs
operator|--
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* don't free below */
name|vc
operator|=
name|NULL
expr_stmt|;
name|done
label|:
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vc
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|sc
operator|->
name|vcc_zone
argument_list|,
name|vc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to initialize the given VC  */
end_comment

begin_function
specifier|static
name|int
name|fatm_load_vc
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|card_vcc
modifier|*
name|vc
parameter_list|)
block|{
name|uint32_t
name|cmd
decl_stmt|;
name|struct
name|cmdqueue
modifier|*
name|q
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Command and buffer strategy */
name|cmd
operator|=
name|FATM_OP_ACTIVATE_VCIN
operator||
name|FATM_OP_INTERRUPT_SEL
operator||
operator|(
literal|0
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|vc
operator|->
name|param
operator|.
name|aal
operator|==
name|ATMIO_AAL_0
condition|)
name|cmd
operator||=
operator|(
literal|0
operator|<<
literal|8
operator|)
expr_stmt|;
else|else
name|cmd
operator||=
operator|(
literal|5
operator|<<
literal|8
operator|)
expr_stmt|;
name|q
operator|=
name|fatm_start_vcc
argument_list|(
name|sc
argument_list|,
name|vc
operator|->
name|param
operator|.
name|vpi
argument_list|,
name|vc
operator|->
name|param
operator|.
name|vci
argument_list|,
name|cmd
argument_list|,
literal|1
argument_list|,
operator|(
name|vc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATMIO_FLAG_ASYNC
operator|)
condition|?
name|fatm_open_complete
else|:
name|fatm_cmd_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|vc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATMIO_FLAG_ASYNC
operator|)
condition|)
block|{
name|error
operator|=
name|fatm_waitvcc
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|fatm_open_finish
argument_list|(
name|sc
argument_list|,
name|vc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finish close  */
end_comment

begin_function
specifier|static
name|void
name|fatm_close_finish
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|card_vcc
modifier|*
name|vc
parameter_list|)
block|{
comment|/* inform management of this is not an NG 	 * VCC or it's an NG PVC. */
if|if
condition|(
operator|!
operator|(
name|vc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATMIO_FLAG_NG
operator|)
operator|||
operator|(
name|vc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATMIO_FLAG_PVC
operator|)
condition|)
name|ATMEV_SEND_VCC_CHANGED
argument_list|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|vc
operator|->
name|param
operator|.
name|vci
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|vc
operator|->
name|param
operator|.
name|vci
index|]
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|open_vccs
operator|--
expr_stmt|;
name|uma_zfree
argument_list|(
name|sc
operator|->
name|vcc_zone
argument_list|,
name|vc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The VC has been closed.  */
end_comment

begin_function
specifier|static
name|void
name|fatm_close_complete
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cmdqueue
modifier|*
name|q
parameter_list|)
block|{
name|u_int
name|vci
decl_stmt|;
name|struct
name|card_vcc
modifier|*
name|vc
decl_stmt|;
name|vci
operator|=
name|GETVCI
argument_list|(
name|READ4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
name|FATMOC_ACTIN_VPVC
argument_list|)
argument_list|)
expr_stmt|;
name|vc
operator|=
name|sc
operator|->
name|vccs
index|[
name|vci
index|]
expr_stmt|;
name|H_SYNCSTAT_POSTREAD
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|H_GETSTAT
argument_list|(
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
operator|&
name|FATM_STAT_ERROR
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|get_stat_errors
operator|++
expr_stmt|;
comment|/* keep the VCC in that state */
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"closing VCI %u failed\n"
argument_list|,
name|vci
argument_list|)
expr_stmt|;
return|return;
block|}
name|fatm_close_finish
argument_list|(
name|sc
argument_list|,
name|vc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initiate closing a VCC  */
end_comment

begin_function
specifier|static
name|int
name|fatm_close_vcc
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|atmio_closevcc
modifier|*
name|cl
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|cmdqueue
modifier|*
name|q
decl_stmt|;
name|struct
name|card_vcc
modifier|*
name|vc
decl_stmt|;
if|if
condition|(
operator|!
name|VC_OK
argument_list|(
name|sc
argument_list|,
name|cl
operator|->
name|vpi
argument_list|,
name|cl
operator|->
name|vci
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|FATM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|vc
operator|=
name|sc
operator|->
name|vccs
index|[
name|cl
operator|->
name|vci
index|]
expr_stmt|;
if|if
condition|(
name|vc
operator|==
name|NULL
operator|||
operator|!
operator|(
name|vc
operator|->
name|vflags
operator|&
operator|(
name|FATM_VCC_OPEN
operator||
name|FATM_VCC_TRY_OPEN
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|q
operator|=
name|fatm_start_vcc
argument_list|(
name|sc
argument_list|,
name|cl
operator|->
name|vpi
argument_list|,
name|cl
operator|->
name|vci
argument_list|,
name|FATM_OP_DEACTIVATE_VCIN
operator||
name|FATM_OP_INTERRUPT_SEL
argument_list|,
literal|1
argument_list|,
operator|(
name|vc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATMIO_FLAG_ASYNC
operator|)
condition|?
name|fatm_close_complete
else|:
name|fatm_cmd_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|vc
operator|->
name|vflags
operator|&=
operator|~
operator|(
name|FATM_VCC_OPEN
operator||
name|FATM_VCC_TRY_OPEN
operator|)
expr_stmt|;
name|vc
operator|->
name|vflags
operator||=
name|FATM_VCC_TRY_CLOSE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATMIO_FLAG_ASYNC
operator|)
condition|)
block|{
name|error
operator|=
name|fatm_waitvcc
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|fatm_close_finish
argument_list|(
name|sc
argument_list|,
name|vc
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IOCTL handler  */
end_comment

begin_function
specifier|static
name|int
name|fatm_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|fatm_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|atmio_closevcc
modifier|*
name|cl
init|=
operator|(
expr|struct
name|atmio_closevcc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|atmio_openvcc
modifier|*
name|op
init|=
operator|(
expr|struct
name|atmio_openvcc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|atmio_vcctable
modifier|*
name|vtab
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCATMOPENVCC
case|:
comment|/* kernel internal use */
name|error
operator|=
name|fatm_open_vcc
argument_list|(
name|sc
argument_list|,
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCATMCLOSEVCC
case|:
comment|/* kernel internal use */
name|error
operator|=
name|fatm_close_vcc
argument_list|(
name|sc
argument_list|,
name|cl
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
name|FATM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|fatm_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
case|case
name|AF_INET6
case|:
name|ifa
operator|->
name|ifa_rtrequest
operator|=
name|atm_rtrequest
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|FATM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|fatm_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|fatm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCATMGVCCS
case|:
comment|/* return vcc table */
name|vtab
operator|=
name|atm_getvccs
argument_list|(
operator|(
expr|struct
name|atmio_vcc
operator|*
operator|*
operator|)
name|sc
operator|->
name|vccs
argument_list|,
name|FORE_MAX_VCC
operator|+
literal|1
argument_list|,
name|sc
operator|->
name|open_vccs
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|vtab
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vtab
argument_list|)
operator|+
name|vtab
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|vtab
operator|->
name|vccs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vtab
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCATMGETVCCS
case|:
comment|/* internal netgraph use */
name|vtab
operator|=
name|atm_getvccs
argument_list|(
operator|(
expr|struct
name|atmio_vcc
operator|*
operator|*
operator|)
name|sc
operator|->
name|vccs
argument_list|,
name|FORE_MAX_VCC
operator|+
literal|1
argument_list|,
name|sc
operator|->
name|open_vccs
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtab
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|arg
operator|=
name|vtab
expr_stmt|;
break|break;
default|default:
name|DBG
argument_list|(
name|sc
argument_list|,
name|IOCTL
argument_list|,
operator|(
literal|"+++ cmd=%08lx arg=%p"
operator|,
name|cmd
operator|,
name|arg
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach from the interface and free all resources allocated during  * initialisation and later.  */
end_comment

begin_function
specifier|static
name|int
name|fatm_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|rbuf
modifier|*
name|rb
decl_stmt|;
name|struct
name|fatm_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|txqueue
modifier|*
name|tx
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_is_alive
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|FATM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fatm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|utopia_detach
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|atm_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX race */
block|}
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ih
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irqres
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_used
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"rbuf %p still in use!\n"
argument_list|,
name|rb
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rbuf_tag
argument_list|,
name|rb
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rb
operator|->
name|m
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_free
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|txqueue
operator|.
name|chunk
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FATM_TX_QLEN
condition|;
name|i
operator|++
control|)
block|{
name|tx
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|txqueue
argument_list|,
expr|struct
name|txqueue
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|tx
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|rb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_free
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|rbuf_tag
argument_list|,
name|rb
operator|->
name|map
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rbufs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|rbufs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vccs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FORE_MAX_VCC
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|uma_zfree
argument_list|(
name|sc
operator|->
name|vcc_zone
argument_list|,
name|sc
operator|->
name|vccs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|vccs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vcc_zone
operator|!=
name|NULL
condition|)
name|uma_zdestroy
argument_list|(
name|sc
operator|->
name|vcc_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|l1queue
operator|.
name|chunk
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|l1queue
operator|.
name|chunk
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|s1queue
operator|.
name|chunk
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|s1queue
operator|.
name|chunk
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rxqueue
operator|.
name|chunk
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|rxqueue
operator|.
name|chunk
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txqueue
operator|.
name|chunk
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|txqueue
operator|.
name|chunk
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cmdqueue
operator|.
name|chunk
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|cmdqueue
operator|.
name|chunk
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|destroy_dma_memory
argument_list|(
operator|&
name|sc
operator|->
name|reg_mem
argument_list|)
expr_stmt|;
name|destroy_dma_memory
argument_list|(
operator|&
name|sc
operator|->
name|sadi_mem
argument_list|)
expr_stmt|;
name|destroy_dma_memory
argument_list|(
operator|&
name|sc
operator|->
name|prom_mem
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TEST_DMA_SYNC
name|destroy_dma_memoryX
argument_list|(
operator|&
name|sc
operator|->
name|s1q_mem
argument_list|)
expr_stmt|;
name|destroy_dma_memoryX
argument_list|(
operator|&
name|sc
operator|->
name|l1q_mem
argument_list|)
expr_stmt|;
name|destroy_dma_memoryX
argument_list|(
operator|&
name|sc
operator|->
name|rxq_mem
argument_list|)
expr_stmt|;
name|destroy_dma_memoryX
argument_list|(
operator|&
name|sc
operator|->
name|txq_mem
argument_list|)
expr_stmt|;
name|destroy_dma_memoryX
argument_list|(
operator|&
name|sc
operator|->
name|stat_mem
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|tx_tag
operator|!=
name|NULL
condition|)
if|if
condition|(
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|)
condition|)
name|printf
argument_list|(
literal|"tx DMA tag busy!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rbuf_tag
operator|!=
name|NULL
condition|)
if|if
condition|(
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rbuf_tag
argument_list|)
condition|)
name|printf
argument_list|(
literal|"rbuf DMA tag busy!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|parent_dmat
operator|!=
name|NULL
condition|)
if|if
condition|(
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
condition|)
name|printf
argument_list|(
literal|"parent DMA tag busy!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irqres
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqid
argument_list|,
name|sc
operator|->
name|irqres
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|memres
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|memid
argument_list|,
name|sc
operator|->
name|memres
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sysctl_ctx_free
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sc
operator|->
name|cv_stat
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sc
operator|->
name|cv_regs
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sysctl handler  */
end_comment

begin_function
specifier|static
name|int
name|fatm_sysctl_istats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|fatm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_long
modifier|*
name|ret
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ret
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|istats
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|FATM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|istats
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|istats
argument_list|)
argument_list|)
expr_stmt|;
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|istats
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sysctl handler for card statistics  * This is disable because it destroys the PHY statistics.  */
end_comment

begin_function
specifier|static
name|int
name|fatm_sysctl_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|fatm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
specifier|const
name|struct
name|fatm_stats
modifier|*
name|s
decl_stmt|;
name|u_long
modifier|*
name|ret
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|ret
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|FATM_NSTATS
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|FATM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fatm_getstat
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|sc
operator|->
name|sadi_mem
operator|.
name|mem
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|phy_4b5b
operator|.
name|crc_header_errors
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|phy_4b5b
operator|.
name|framing_errors
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|phy_oc3
operator|.
name|section_bip8_errors
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|phy_oc3
operator|.
name|path_bip8_errors
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|phy_oc3
operator|.
name|line_bip24_errors
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|phy_oc3
operator|.
name|line_febe_errors
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|phy_oc3
operator|.
name|path_febe_errors
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|phy_oc3
operator|.
name|corr_hcs_errors
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|phy_oc3
operator|.
name|ucorr_hcs_errors
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|atm
operator|.
name|cells_transmitted
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|atm
operator|.
name|cells_received
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|atm
operator|.
name|vpi_bad_range
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|atm
operator|.
name|vpi_no_conn
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|atm
operator|.
name|vci_bad_range
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|atm
operator|.
name|vci_no_conn
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal0
operator|.
name|cells_transmitted
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal0
operator|.
name|cells_received
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal0
operator|.
name|cells_dropped
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal4
operator|.
name|cells_transmitted
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal4
operator|.
name|cells_received
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal4
operator|.
name|cells_crc_errors
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal4
operator|.
name|cels_protocol_errors
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal4
operator|.
name|cells_dropped
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal4
operator|.
name|cspdus_transmitted
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal4
operator|.
name|cspdus_received
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal4
operator|.
name|cspdus_protocol_errors
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal4
operator|.
name|cspdus_dropped
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal5
operator|.
name|cells_transmitted
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal5
operator|.
name|cells_received
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal5
operator|.
name|congestion_experienced
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal5
operator|.
name|cells_dropped
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal5
operator|.
name|cspdus_transmitted
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal5
operator|.
name|cspdus_received
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal5
operator|.
name|cspdus_crc_errors
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal5
operator|.
name|cspdus_protocol_errors
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aal5
operator|.
name|cspdus_dropped
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aux
operator|.
name|small_b1_failed
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aux
operator|.
name|large_b1_failed
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aux
operator|.
name|small_b2_failed
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aux
operator|.
name|large_b2_failed
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aux
operator|.
name|rpd_alloc_failed
expr_stmt|;
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|->
name|aux
operator|.
name|receive_carrier
expr_stmt|;
block|}
comment|/* declare the buffer free */
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FATM_STAT_INUSE
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|cv_stat
argument_list|)
expr_stmt|;
name|FATM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|FATM_NSTATS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXDMASEGS
value|32
end_define

begin_comment
comment|/* maximum number of receive descriptors */
end_comment

begin_comment
comment|/*  * Attach to the device.  *  * We assume, that there is a global lock (Giant in this case) that protects  * multiple threads from entering this function. This makes sense, doesn't it?  */
end_comment

begin_function
specifier|static
name|int
name|fatm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|fatm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|uint16_t
name|cfg
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|rbuf
modifier|*
name|rb
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|txqueue
modifier|*
name|tx
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ATM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|device
operator|=
name|ATM_DEVICE_PCA200E
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|serial
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|hw_version
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|sw_version
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vpi_bits
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vci_bits
operator|=
name|FORE_VCIBITS
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vpcs
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vccs
operator|=
name|FORE_MAX_VCC
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_UNKNOWN
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|phy
operator|=
operator|&
name|sc
operator|->
name|utopia
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_free
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_used
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize mutex and condition variables. 	 */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|sc
operator|->
name|cv_stat
argument_list|,
literal|"fatm_stat"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|sc
operator|->
name|cv_regs
argument_list|,
literal|"fatm_regs"
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_timer
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Make the sysctl tree 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw_atm
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"istats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|fatm_sysctl_istats
argument_list|,
literal|"LU"
argument_list|,
literal|"internal statistics"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|fatm_sysctl_stats
argument_list|,
literal|"LU"
argument_list|,
literal|"card statistics"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"retry_tx"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|retry_tx
argument_list|,
literal|0
argument_list|,
literal|"retry flag"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
ifdef|#
directive|ifdef
name|FATM_DEBUG
if|if
condition|(
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|debug
argument_list|,
literal|0
argument_list|,
literal|"debug flags"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|sc
operator|->
name|debug
operator|=
name|FATM_DEBUG
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Network subsystem stuff 	 */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|fatm_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|fatm_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|fatm_init
expr_stmt|;
name|ifp
operator|->
name|if_linkmib
operator|=
operator|&
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
expr_stmt|;
name|ifp
operator|->
name|if_linkmiblen
operator|=
sizeof|sizeof
argument_list|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
argument_list|)
expr_stmt|;
comment|/* 	 * Enable memory and bustmaster 	 */
name|cfg
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator||=
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cfg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Map memory 	 */
name|cfg
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cfg
operator|&
name|PCIM_CMD_MEMEN
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to enable memory mapping\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|memid
operator|=
literal|0x10
expr_stmt|;
name|sc
operator|->
name|memres
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|memid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|memres
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"could not map memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|memh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|memres
argument_list|)
expr_stmt|;
name|sc
operator|->
name|memt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|memres
argument_list|)
expr_stmt|;
comment|/* 	 * Convert endianess of slave access 	 */
name|cfg
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|FATM_PCIR_MCTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator||=
name|FATM_PCIM_SWAB
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|FATM_PCIR_MCTL
argument_list|,
name|cfg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate interrupt (activate at the end) 	 */
name|sc
operator|->
name|irqid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irqres
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irqid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irqres
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"could not allocate irq\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate the parent DMA tag. This is used simply to hold overall 	 * restrictions for the controller (and PCI bus) and is never used 	 * to do anything. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
name|MAXDMASEGS
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|parent_dmat
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"could not allocate parent DMA tag\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate the receive buffer DMA tag. This tag must map a maximum of 	 * a mbuf cluster. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
literal|1
argument_list|,
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|rbuf_tag
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"could not allocate rbuf DMA tag\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate the transmission DMA tag. Must add 1, because 	 * rounded up PDU will be 65536 bytes long. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FATM_MAXPDU
operator|+
literal|1
argument_list|,
name|TPD_EXTENSIONS
operator|+
name|TXD_FIXED
argument_list|,
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|tx_tag
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"could not allocate tx DMA tag\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate DMAable memory. 	 */
name|sc
operator|->
name|stat_mem
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
operator|(
name|FATM_CMD_QLEN
operator|+
name|FATM_TX_QLEN
operator|+
name|FATM_RX_QLEN
operator|+
name|SMALL_SUPPLY_QLEN
operator|+
name|LARGE_SUPPLY_QLEN
operator|)
expr_stmt|;
name|sc
operator|->
name|stat_mem
operator|.
name|align
operator|=
literal|4
expr_stmt|;
name|sc
operator|->
name|txq_mem
operator|.
name|size
operator|=
name|FATM_TX_QLEN
operator|*
name|TPD_SIZE
expr_stmt|;
name|sc
operator|->
name|txq_mem
operator|.
name|align
operator|=
literal|32
expr_stmt|;
name|sc
operator|->
name|rxq_mem
operator|.
name|size
operator|=
name|FATM_RX_QLEN
operator|*
name|RPD_SIZE
expr_stmt|;
name|sc
operator|->
name|rxq_mem
operator|.
name|align
operator|=
literal|32
expr_stmt|;
name|sc
operator|->
name|s1q_mem
operator|.
name|size
operator|=
name|SMALL_SUPPLY_QLEN
operator|*
name|BSUP_BLK2SIZE
argument_list|(
name|SMALL_SUPPLY_BLKSIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|s1q_mem
operator|.
name|align
operator|=
literal|32
expr_stmt|;
name|sc
operator|->
name|l1q_mem
operator|.
name|size
operator|=
name|LARGE_SUPPLY_QLEN
operator|*
name|BSUP_BLK2SIZE
argument_list|(
name|LARGE_SUPPLY_BLKSIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|l1q_mem
operator|.
name|align
operator|=
literal|32
expr_stmt|;
ifdef|#
directive|ifdef
name|TEST_DMA_SYNC
if|if
condition|(
operator|(
name|error
operator|=
name|alloc_dma_memoryX
argument_list|(
name|sc
argument_list|,
literal|"STATUS"
argument_list|,
operator|&
name|sc
operator|->
name|stat_mem
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|alloc_dma_memoryX
argument_list|(
name|sc
argument_list|,
literal|"TXQ"
argument_list|,
operator|&
name|sc
operator|->
name|txq_mem
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|alloc_dma_memoryX
argument_list|(
name|sc
argument_list|,
literal|"RXQ"
argument_list|,
operator|&
name|sc
operator|->
name|rxq_mem
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|alloc_dma_memoryX
argument_list|(
name|sc
argument_list|,
literal|"S1Q"
argument_list|,
operator|&
name|sc
operator|->
name|s1q_mem
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|alloc_dma_memoryX
argument_list|(
name|sc
argument_list|,
literal|"L1Q"
argument_list|,
operator|&
name|sc
operator|->
name|l1q_mem
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
else|#
directive|else
if|if
condition|(
operator|(
name|error
operator|=
name|alloc_dma_memory
argument_list|(
name|sc
argument_list|,
literal|"STATUS"
argument_list|,
operator|&
name|sc
operator|->
name|stat_mem
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|alloc_dma_memory
argument_list|(
name|sc
argument_list|,
literal|"TXQ"
argument_list|,
operator|&
name|sc
operator|->
name|txq_mem
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|alloc_dma_memory
argument_list|(
name|sc
argument_list|,
literal|"RXQ"
argument_list|,
operator|&
name|sc
operator|->
name|rxq_mem
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|alloc_dma_memory
argument_list|(
name|sc
argument_list|,
literal|"S1Q"
argument_list|,
operator|&
name|sc
operator|->
name|s1q_mem
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|alloc_dma_memory
argument_list|(
name|sc
argument_list|,
literal|"L1Q"
argument_list|,
operator|&
name|sc
operator|->
name|l1q_mem
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
name|sc
operator|->
name|prom_mem
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|prom
argument_list|)
expr_stmt|;
name|sc
operator|->
name|prom_mem
operator|.
name|align
operator|=
literal|32
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|alloc_dma_memory
argument_list|(
name|sc
argument_list|,
literal|"PROM"
argument_list|,
operator|&
name|sc
operator|->
name|prom_mem
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|sc
operator|->
name|sadi_mem
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|fatm_stats
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sadi_mem
operator|.
name|align
operator|=
literal|32
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|alloc_dma_memory
argument_list|(
name|sc
argument_list|,
literal|"STATISTICS"
argument_list|,
operator|&
name|sc
operator|->
name|sadi_mem
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|sc
operator|->
name|reg_mem
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|FATM_NREGS
expr_stmt|;
name|sc
operator|->
name|reg_mem
operator|.
name|align
operator|=
literal|32
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|alloc_dma_memory
argument_list|(
name|sc
argument_list|,
literal|"REGISTERS"
argument_list|,
operator|&
name|sc
operator|->
name|reg_mem
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Allocate queues 	 */
name|sc
operator|->
name|cmdqueue
operator|.
name|chunk
operator|=
name|malloc
argument_list|(
name|FATM_CMD_QLEN
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cmdqueue
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txqueue
operator|.
name|chunk
operator|=
name|malloc
argument_list|(
name|FATM_TX_QLEN
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|txqueue
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxqueue
operator|.
name|chunk
operator|=
name|malloc
argument_list|(
name|FATM_RX_QLEN
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rxqueue
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|s1queue
operator|.
name|chunk
operator|=
name|malloc
argument_list|(
name|SMALL_SUPPLY_QLEN
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|supqueue
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|l1queue
operator|.
name|chunk
operator|=
name|malloc
argument_list|(
name|LARGE_SUPPLY_QLEN
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|supqueue
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vccs
operator|=
name|malloc
argument_list|(
operator|(
name|FORE_MAX_VCC
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|vccs
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vcc_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"FATM vccs"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|card_vcc
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vcc_zone
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate memory for the receive buffer headers. The total number 	 * of headers should probably also include the maximum number of 	 * buffers on the receive queue. 	 */
name|sc
operator|->
name|rbuf_total
operator|=
name|SMALL_POOL_SIZE
operator|+
name|LARGE_POOL_SIZE
expr_stmt|;
name|sc
operator|->
name|rbufs
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|rbuf_total
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rbuf
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Put all rbuf headers on the free list and create DMA maps. 	 */
for|for
control|(
name|rb
operator|=
name|sc
operator|->
name|rbufs
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|rbuf_total
condition|;
name|i
operator|++
operator|,
name|rb
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|rbuf_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|rb
operator|->
name|map
argument_list|)
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"creating rx map: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|rbuf_free
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create dma maps for transmission. In case of an error, free the 	 * allocated DMA maps, because on some architectures maps are NULL 	 * and we cannot distinguish between a failure and a NULL map in 	 * the detach routine. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FATM_TX_QLEN
condition|;
name|i
operator|++
control|)
block|{
name|tx
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|txqueue
argument_list|,
expr|struct
name|txqueue
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|tx
operator|->
name|map
argument_list|)
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"creating tx map: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|tx
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|txqueue
argument_list|,
expr|struct
name|txqueue
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|tx
operator|->
name|map
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
goto|goto
name|fail
goto|;
block|}
block|}
name|utopia_attach
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|media
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
operator|&
name|fatm_utopia_methods
argument_list|)
expr_stmt|;
name|sc
operator|->
name|utopia
operator|.
name|flags
operator||=
name|UTP_FL_NORESET
operator||
name|UTP_FL_POLL_CARRIER
expr_stmt|;
comment|/* 	 * Attach the interface 	 */
name|atm_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
literal|512
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_BPF
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_ATM_RFC1483
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atmllc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irqres
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|fatm_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"couldn't setup irq\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fail
label|:
if|if
condition|(
name|error
condition|)
name|fatm_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FATM_DEBUG
argument_list|)
operator|&&
literal|0
end_if

begin_function
specifier|static
name|void
name|dump_s1_queue
parameter_list|(
name|struct
name|fatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|supqueue
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SMALL_SUPPLY_QLEN
condition|;
name|i
operator|++
control|)
block|{
name|q
operator|=
name|GET_QUEUE
argument_list|(
name|sc
operator|->
name|s1queue
argument_list|,
expr|struct
name|supqueue
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2d: card=%x(%x,%x) stat=%x\n"
argument_list|,
name|i
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
argument_list|,
name|READ4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
argument_list|)
argument_list|,
name|READ4
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q
operator|.
name|card
operator|+
literal|4
argument_list|)
argument_list|,
operator|*
name|q
operator|->
name|q
operator|.
name|statp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Driver infrastructure.  */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|fatm_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fatm_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fatm_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fatm_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fatm_driver
init|=
block|{
literal|"fatm"
block|,
name|fatm_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fatm_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|fatm
argument_list|,
name|pci
argument_list|,
name|fatm_driver
argument_list|,
name|fatm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

