begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997 Nicolas Souchu  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: ppc.c,v 1.2 1997/09/01 02:08:41 bde Exp $  *  */
end_comment

begin_include
include|#
directive|include
file|"ppc.h"
end_include

begin_if
if|#
directive|if
name|NPPC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppbconf.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ppcreg.h>
end_include

begin_function_decl
specifier|static
name|int
name|ppcprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ppcattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|ppcdriver
init|=
block|{
name|ppcprobe
block|,
name|ppcattach
block|,
literal|"ppc"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ppc_data
modifier|*
name|ppcdata
index|[
name|NPPC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nppc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_types
index|[]
init|=
block|{
literal|"SMC"
block|,
literal|"SMC FDC37C665GT"
block|,
literal|"SMC FDC37C666GT"
block|,
literal|"NatSemi"
block|,
literal|"PC87332"
block|,
literal|"PC87306"
block|,
literal|"Intel 82091AA"
block|,
literal|"Generic"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_modes
index|[]
init|=
block|{
literal|"AUTODETECT"
block|,
literal|"NIBBLE"
block|,
literal|"PS/2"
block|,
literal|"EPP"
block|,
literal|"ECP+EPP"
block|,
literal|"ECP+PS/2"
block|,
literal|"ECP"
block|,
literal|"UNKNOWN"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_epp_protocol
index|[]
init|=
block|{
literal|" (EPP 1.9)"
block|,
literal|" (EPP 1.7)"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * BIOS printer list - used by BIOS probe.  */
end_comment

begin_define
define|#
directive|define
name|BIOS_PPC_PORTS
value|0x408
end_define

begin_define
define|#
directive|define
name|BIOS_PORTS
value|(short *)(KERNBASE+BIOS_PPC_PORTS)
end_define

begin_define
define|#
directive|define
name|BIOS_MAX_PPC
value|4
end_define

begin_comment
comment|/*  * All these functions are default actions for IN/OUT operations.  * They may be redefined if needed.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_outsb_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|outsb
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_outsw_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|outsw
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_outsl_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|outsl
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_insb_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|insb
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_insw_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|insw
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_insl_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|insl
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
name|ppc_rdtr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_dtr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|ppc_rstr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_str
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|ppc_rctr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_ctr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|ppc_repp
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_epp
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|ppc_recr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_ecr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|ppc_rfifo
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_fifo
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wdtr
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_dtr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wstr
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_str
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wctr
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_ctr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wepp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_epp
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wecr
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_ecr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wfifo
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_fifo
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|ppc_reset_epp_timeout
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ppc_ecp_sync
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ppb_adapter
name|ppc_adapter
init|=
block|{
literal|0
block|,
comment|/* no intr handler, filled by chipset dependent code */
name|ppc_reset_epp_timeout
block|,
name|ppc_ecp_sync
block|,
name|ppc_outsb_epp
block|,
name|ppc_outsw_epp
block|,
name|ppc_outsl_epp
block|,
name|ppc_insb_epp
block|,
name|ppc_insw_epp
block|,
name|ppc_insl_epp
block|,
name|ppc_rdtr
block|,
name|ppc_rstr
block|,
name|ppc_rctr
block|,
name|ppc_repp
block|,
name|ppc_recr
block|,
name|ppc_rfifo
block|,
name|ppc_wdtr
block|,
name|ppc_wstr
block|,
name|ppc_wctr
block|,
name|ppc_wepp
block|,
name|ppc_wecr
block|,
name|ppc_wfifo
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ppc_ecp_sync()		XXX  */
end_comment

begin_function
specifier|static
name|void
name|ppc_ecp_sync
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|r
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
literal|0xe0
operator|)
operator|!=
literal|0x80
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&
literal|0x1
condition|)
return|return;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ppc: ECP sync failed as data still "
expr|\
literal|"present in FIFO.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ppcintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
comment|/* call directly upper code */
name|ppb_intr
argument_list|(
operator|&
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_link
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * ppc_pc873xx_detect  *  * Probe for a Natsemi PC873xx-family part.  *  * References in this function are to the National Semiconductor  * PC87332 datasheet TL/C/11930, May 1995 revision.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pc873xx_basetab
index|[]
init|=
block|{
literal|0x0398
block|,
literal|0x026e
block|,
literal|0x015c
block|,
literal|0x002e
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pc873xx_porttab
index|[]
init|=
block|{
literal|0x0378
block|,
literal|0x03bc
block|,
literal|0x0278
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ppc_pc873xx_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|)
block|{
specifier|static
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|base
decl_stmt|,
name|idport
decl_stmt|;
name|int
name|val
decl_stmt|,
name|mode
decl_stmt|;
while|while
condition|(
operator|(
name|idport
operator|=
name|pc873xx_basetab
index|[
name|index
operator|++
index|]
operator|)
condition|)
block|{
comment|/* XXX should check first to see if this location is already claimed */
comment|/* 	 * Pull the 873xx through the power-on ID cycle (2.2,1.).  We can't use this 	 * to locate the chip as it may already have been used by the BIOS. 	 */
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
comment|/* 	 * Read the SID byte.  Possible values are : 	 * 	 * 0001xxxx	PC87332 	 * 01110xxx	PC87306 	 */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_SID
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0xf0
operator|)
operator|==
literal|0x10
condition|)
block|{
name|ppc
operator|->
name|ppc_type
operator|=
name|NS_PC87332
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|0xf8
operator|)
operator|==
literal|0x70
condition|)
block|{
name|ppc
operator|->
name|ppc_type
operator|=
name|NS_PC87306
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
operator|&&
operator|(
name|val
operator|!=
literal|0xff
operator|)
condition|)
name|printf
argument_list|(
literal|"PC873xx probe at 0x%x got unknown ID 0x%x\n"
argument_list|,
name|idport
argument_list|,
name|val
argument_list|)
expr_stmt|;
continue|continue ;
comment|/* not recognised */
block|}
comment|/* 	 * We think we have one.  Is it enabled and where we want it to be?	  	 */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_FER
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PC873_PPENABLE
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx parallel port disabled\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_FAR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
operator|&
literal|0x3
expr_stmt|;
comment|/* XXX we should create a driver instance for every port found */
if|if
condition|(
name|pc873xx_porttab
index|[
name|val
index|]
operator|!=
name|ppc
operator|->
name|ppc_base
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx at 0x%x not for driver at port 0x%x\n"
argument_list|,
name|pc873xx_porttab
index|[
name|val
index|]
argument_list|,
name|ppc
operator|->
name|ppc_base
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*  	 * This is the port we want.  Can we dink with it to improve 	 * our chances? 	 */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PC873_CFGLOCK
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx locked\n"
argument_list|)
expr_stmt|;
comment|/* work out what mode we're in */
name|mode
operator|=
name|PPB_NIBBLE
expr_stmt|;
comment|/* worst case */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PCR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PC873_EPPEN
operator|)
operator|&&
operator|(
name|val
operator|&
name|PC873_EPP19
operator|)
condition|)
block|{
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PC873_EPPRDIR
operator|)
condition|)
block|{
name|mode
operator|=
name|PPB_EPP
expr_stmt|;
comment|/* As we would have done it anwyay */
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
name|PC873_ECPEN
operator|)
operator|&&
operator|(
name|val
operator|&
name|PC873_ECPCLK
operator|)
condition|)
block|{
name|mode
operator|=
name|PPB_PS2
expr_stmt|;
comment|/* tolerable alternative */
block|}
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx unlocked, "
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* broken */
comment|/* 	     * Frob the zero-wait-state option if possible; it causes 	     * unreliable operation. 	     */
block|outb(idport, PC873_FCR); 	    val = inb(idport + 1); 	    if ((ppc->ppc_type == NS_PC87306) ||
comment|/* we are a '306 */
block|!(val& PC873_ZWSPWDN)) {
comment|/* or pin _is_ ZWS */
block|val&= ~PC873_ZWS; 		outb(idport + 1, val);
comment|/* must disable ZWS */
block|outb(idport + 1, val); 		 		if (bootverbose) 		    printf("ZWS %s, ", (val& PC873_ZWS) ? "enabled" : "disabled"); 	    }
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"reconfiguring for "
argument_list|)
expr_stmt|;
comment|/*  	     * if the chip is at 0x3bc, we can't use EPP as there's no room 	     * for the extra registers. 	     * 	     * XXX should we use ECP mode always and use the EPP submode? 	     */
if|if
condition|(
name|ppc
operator|->
name|ppc_base
operator|!=
literal|0x3bc
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"EPP 1.9\n"
argument_list|)
expr_stmt|;
comment|/* configure for EPP 1.9 operation XXX should be configurable */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PCR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|PC873_ECPEN
operator||
name|PC873_ECPCLK
operator|)
expr_stmt|;
comment|/* disable ECP */
name|val
operator||=
operator|(
name|PC873_EPPEN
operator||
name|PC873_EPP19
operator|)
expr_stmt|;
comment|/* enable EPP */
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* enable automatic direction turnover */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|PC873_EPPRDIR
expr_stmt|;
comment|/* disable "regular" direction change */
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* we are an EPP-32 port */
name|mode
operator|=
name|PPB_EPP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ECP\n"
argument_list|)
expr_stmt|;
comment|/* configure as an ECP port to get bidirectional operation for now */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PCR
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
operator||
name|PC873_ECPEN
operator||
name|PC873_ECPCLK
argument_list|)
expr_stmt|;
comment|/* we look like a PS/2 port */
name|mode
operator|=
name|PPB_PS2
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mode
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ppc_detect_ps2
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|)
block|{
name|char
name|save_control
decl_stmt|,
name|r
decl_stmt|;
name|save_control
operator|=
name|r_ctr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
comment|/* Try PS/2 mode */
name|w_ctr
argument_list|(
name|ppc
argument_list|,
literal|0xec
argument_list|)
expr_stmt|;
name|w_dtr
argument_list|(
name|ppc
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
comment|/* needed if in ECP mode */
if|if
condition|(
name|ppc
operator|->
name|ppc_mode
operator|==
name|PPB_ECP
condition|)
name|w_ctr
argument_list|(
name|ppc
argument_list|,
name|PCD
operator||
literal|0xec
argument_list|)
expr_stmt|;
name|r
operator|=
name|r_dtr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
operator|(
name|char
operator|)
literal|0xff
condition|)
block|{
if|if
condition|(
name|r
operator|!=
operator|(
name|char
operator|)
literal|0x55
condition|)
return|return
literal|0
return|;
name|w_dtr
argument_list|(
name|ppc
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|r
operator|=
name|r_dtr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
operator|(
name|char
operator|)
literal|0xaa
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|PPB_NIBBLE
operator|)
return|;
block|}
else|else
name|w_ctr
argument_list|(
name|ppc
argument_list|,
name|save_control
argument_list|)
expr_stmt|;
return|return
operator|(
name|PPB_PS2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppc_smc37c66xgt_detect  *  * SMC FDC37C66xGT configuration.  */
end_comment

begin_function
specifier|static
name|int
name|ppc_smc37c66xgt_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|char
name|r
decl_stmt|;
name|int
name|retry
init|=
literal|0
decl_stmt|;
comment|/* boolean */
name|int
name|type
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|csr
init|=
name|SMC66x_CSR
decl_stmt|;
comment|/* initial value is 0x3F0 */
name|int
name|port_address
index|[]
init|=
block|{
operator|-
literal|1
comment|/* disabled */
block|,
literal|0x3bc
block|,
literal|0x378
block|,
literal|0x278
block|}
decl_stmt|;
define|#
directive|define
name|cio
value|csr+1
comment|/* config IO port is either 0x3F1 or 0x371 */
comment|/* 	 * Detection: enter configuration mode and read CRD register. 	 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC665_iCODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC665_iCODE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|==
literal|0x65
condition|)
block|{
name|type
operator|=
name|SMC_37C665GT
expr_stmt|;
goto|goto
name|config
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC666_iCODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC666_iCODE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|==
literal|0x66
condition|)
block|{
name|type
operator|=
name|SMC_37C666GT
expr_stmt|;
break|break;
block|}
comment|/* Another chance, CSR may be hard-configured to be at 0x370 */
name|csr
operator|=
name|SMC666_CSR
expr_stmt|;
block|}
name|config
label|:
comment|/* 	 * If chipset not found, do not continue. 	 */
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* select CR1 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* read the port's address: bits 0 and 1 of CR1 */
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
name|SMC_CR1_ADDR
expr_stmt|;
if|if
condition|(
name|port_address
index|[
name|r
index|]
operator|!=
name|ppc
operator|->
name|ppc_base
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ppc
operator|->
name|ppc_type
operator|=
name|type
expr_stmt|;
comment|/* 	 * CR1 and CR4 registers bits 3 and 0/1 for mode configuration 	 * If SPP mode is detected, try to set ECP+EPP mode end retry 	 * detection to verify. 	 */
name|retry
label|:
comment|/* select CR1 register */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
block|{
comment|/* autodetect mode */
comment|/* 666GT chipset is hardwired to an extended mode */
if|if
condition|(
name|type
operator|==
name|SMC_37C666GT
condition|)
name|mode
operator|=
name|PPB_ECP_EPP
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
name|SMC_CR1_MODE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* already in extended parallel port mode, read CR4 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
name|SMC_CR4_EMODE
operator|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|SMC_SPP
case|:
comment|/* let's detect NIBBLE or PS/2 later */
break|break;
case|case
name|SMC_EPPSPP
case|:
name|mode
operator|=
name|PPB_EPP
expr_stmt|;
break|break;
case|case
name|SMC_ECP
case|:
comment|/* 				 * Yet, don't know what to do with it! 	XXX 				 * So, consider ECP mode as PS/2. 				 * (see configuration later). 				 */
name|mode
operator|=
name|PPB_ECP
expr_stmt|;
break|break;
case|case
name|SMC_ECPEPP
case|:
name|mode
operator|=
name|PPB_ECP_EPP
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* mode forced */
comment|/* 666GT chipset is hardwired to an extended mode */
if|if
condition|(
name|type
operator|==
name|SMC_37C666GT
condition|)
goto|goto
name|end_detect
goto|;
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|PPB_NIBBLE
operator|||
name|mode
operator|==
name|PPB_PS2
condition|)
block|{
comment|/* do not use ECP when the mode is forced to SPP */
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_CR1_MODE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* an extended mode is selected */
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator|&
operator|~
name|SMC_CR1_MODE
argument_list|)
expr_stmt|;
comment|/* read CR4 register and reset mode field */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
operator|~
name|SMC_CR4_EMODE
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|PPB_EPP
case|:
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_EPPSPP
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_ECP
case|:
case|case
name|PPB_ECP_PS2
case|:
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_ECP
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_ECP_EPP
case|:
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_ECPEPP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ppc: unknown mode (%d)\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|end_detect
label|:
if|if
condition|(
name|PPB_IS_EPP
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* select CR4 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
expr_stmt|;
comment|/* 		 * Set the EPP protocol... 		 * Low=EPP 1.9 (1284 standard) and High=EPP 1.7 		 * ...then check the result. 		 */
if|if
condition|(
name|ppc
operator|->
name|ppc_epp
operator|==
name|EPP_1_9
condition|)
name|outb
argument_list|(
name|cio
argument_list|,
operator|(
name|r
operator|&
operator|~
name|SMC_CR4_EPPTYPE
operator|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|cio
argument_list|,
operator|(
name|r
operator||
name|SMC_CR4_EPPTYPE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* end config mode */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
comment|/* 	 * Write 100 to the mode bits and disable DMA, enable intr. 	 */
if|if
condition|(
name|mode
operator|==
name|PPB_ECP_EPP
condition|)
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* 	 * Write 001 to the mode bits and disable DMA, enable intr. 	 */
if|if
condition|(
name|mode
operator|==
name|PPB_ECP
condition|)
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
if|if
condition|(
name|PPB_IS_EPP
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* 		 * Try to reset EPP timeout bit. 		 * If it fails, try PS/2 and NIBBLE modes. 		 */
name|ppc_reset_epp_timeout
argument_list|(
name|ppc
operator|->
name|ppc_unit
argument_list|)
expr_stmt|;
name|r
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|&
name|TIMEOUT
operator|)
condition|)
return|return
operator|(
name|mode
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|mode
condition|)
return|return
operator|(
name|mode
operator|)
return|;
block|}
comment|/* detect PS/2 or NIBBLE mode */
return|return
operator|(
name|ppc_detect_ps2
argument_list|(
name|ppc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ppc_check_ecpepp_timeout
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|)
block|{
name|char
name|r
decl_stmt|;
name|ppc_reset_epp_timeout
argument_list|(
name|ppc
operator|->
name|ppc_unit
argument_list|)
expr_stmt|;
name|r
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|&
name|TIMEOUT
operator|)
condition|)
block|{
return|return
operator|(
name|PPB_ECP_EPP
operator|)
return|;
block|}
comment|/* If EPP timeout bit is not reset, DON'T use EPP */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
return|return
operator|(
name|PPB_ECP_PS2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppc_generic_detect  */
end_comment

begin_function
specifier|static
name|int
name|ppc_generic_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|char
name|save_control
decl_stmt|,
name|r
decl_stmt|;
comment|/* don't know what to do here */
if|if
condition|(
name|mode
condition|)
return|return
operator|(
name|mode
operator|)
return|;
comment|/* try to reset EPP timeout bit */
name|ppc_reset_epp_timeout
argument_list|(
name|ppc
operator|->
name|ppc_unit
argument_list|)
expr_stmt|;
name|r
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|&
name|TIMEOUT
operator|)
condition|)
block|{
return|return
operator|(
name|PPB_EPP
operator|)
return|;
block|}
comment|/* Now check for ECP */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|r
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
literal|0xe0
operator|)
operator|==
literal|0x20
condition|)
block|{
comment|/* Search for SMC style EPP+ECP mode */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
return|return
operator|(
name|ppc_check_ecpepp_timeout
argument_list|(
name|ppc
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ppc_detect_ps2
argument_list|(
name|ppc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppc_detect()  *  * mode is the mode suggested at boot  */
end_comment

begin_function
specifier|static
name|int
name|ppc_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ppc
operator|->
name|ppc_mode
operator|&&
operator|(
name|ppc
operator|->
name|ppc_mode
operator|=
name|ppc_pc873xx_detect
argument_list|(
name|ppc
argument_list|)
operator|)
condition|)
goto|goto
name|end_detect
goto|;
if|if
condition|(
operator|!
name|ppc
operator|->
name|ppc_mode
operator|&&
operator|(
name|ppc
operator|->
name|ppc_mode
operator|=
name|ppc_smc37c66xgt_detect
argument_list|(
name|ppc
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
goto|goto
name|end_detect
goto|;
if|if
condition|(
operator|!
name|ppc
operator|->
name|ppc_mode
operator|&&
operator|(
name|ppc
operator|->
name|ppc_mode
operator|=
name|ppc_generic_detect
argument_list|(
name|ppc
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
goto|goto
name|end_detect
goto|;
name|printf
argument_list|(
literal|"ppc: port not present at 0x%x.\n"
argument_list|,
name|ppc
operator|->
name|ppc_base
argument_list|)
expr_stmt|;
return|return
operator|(
name|PPC_ENOPORT
operator|)
return|;
name|end_detect
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * EPP timeout, according to the PC87332 manual  * Semantics of clearing EPP timeout bit.  * PC87332	- reading SPP_STR does it...  * SMC		- write 1 to EPP timeout bit			XXX  * Others	- (???) write 0 to EPP timeout bit  */
end_comment

begin_function
specifier|static
name|void
name|ppc_reset_epp_timeout
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|char
name|r
decl_stmt|;
name|r
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
name|w_str
argument_list|(
name|ppc
argument_list|,
name|r
operator||
literal|0x1
argument_list|)
expr_stmt|;
name|w_str
argument_list|(
name|ppc
argument_list|,
name|r
operator|&
literal|0xfe
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ppcprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
specifier|static
name|short
name|next_bios_ppc
init|=
literal|0
decl_stmt|;
name|struct
name|ppc_data
modifier|*
name|ppc
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * If port not specified, use bios list. 	 */
if|if
condition|(
name|dvp
operator|->
name|id_iobase
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|next_bios_ppc
operator|<
name|BIOS_MAX_PPC
operator|)
operator|&&
operator|(
operator|*
operator|(
name|BIOS_PORTS
operator|+
name|next_bios_ppc
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|dvp
operator|->
name|id_iobase
operator|=
operator|*
operator|(
name|BIOS_PORTS
operator|+
name|next_bios_ppc
operator|++
operator|)
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Port was explicitly specified. 	 * This allows probing of ports unknown to the BIOS. 	 */
comment|/* 	 * Allocate the ppc_data structure. 	 */
name|ppc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ppc
condition|)
block|{
name|printf
argument_list|(
literal|"ppc: cannot malloc!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|bzero
argument_list|(
name|ppc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_data
argument_list|)
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_base
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|ppc
operator|->
name|ppc_unit
operator|=
name|dvp
operator|->
name|id_unit
expr_stmt|;
name|ppc
operator|->
name|ppc_type
operator|=
name|GENERIC
expr_stmt|;
comment|/* PPB_AUTODETECT is default to allow chipset detection even if 	 * mode is forced by dvp->id_flags (see later, ppc_detect() call) */
name|ppc
operator|->
name|ppc_mode
operator|=
name|PPB_AUTODETECT
expr_stmt|;
name|ppc
operator|->
name|ppc_epp
operator|=
operator|(
name|dvp
operator|->
name|id_flags
operator|&
literal|0x8
operator|)
operator|>>
literal|3
expr_stmt|;
comment|/* 	 * XXX 	 * Try and detect if interrupts are working. 	 */
if|if
condition|(
operator|!
operator|(
name|dvp
operator|->
name|id_flags
operator|&
literal|0x10
operator|)
condition|)
name|ppc
operator|->
name|ppc_irq
operator|=
operator|(
name|dvp
operator|->
name|id_irq
operator|)
expr_stmt|;
name|ppcdata
index|[
name|ppc
operator|->
name|ppc_unit
index|]
operator|=
name|ppc
expr_stmt|;
name|nppc
operator|++
expr_stmt|;
comment|/* 	 * Try to detect the chipset and its mode. 	 */
if|if
condition|(
name|ppc_detect
argument_list|(
name|ppc
argument_list|,
name|dvp
operator|->
name|id_flags
operator|&
literal|0x7
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|end_probe
label|:
return|return
operator|(
literal|1
operator|)
return|;
name|error
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ppcattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|isdp
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|isdp
operator|->
name|id_unit
index|]
decl_stmt|;
name|struct
name|ppb_data
modifier|*
name|ppbus
decl_stmt|;
comment|/* 	 * Link the Parallel Port Chipset (adapter) to 	 * the future ppbus. 	 */
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter_unit
operator|=
name|ppc
operator|->
name|ppc_unit
expr_stmt|;
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter
operator|=
operator|&
name|ppc_adapter
expr_stmt|;
name|printf
argument_list|(
literal|"ppc%d: %s chipset in %s mode%s\n"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|,
name|ppc_types
index|[
name|ppc
operator|->
name|ppc_type
index|]
argument_list|,
name|ppc_modes
index|[
name|ppc
operator|->
name|ppc_mode
index|]
argument_list|,
operator|(
name|PPB_IS_EPP
argument_list|(
name|ppc
operator|->
name|ppc_mode
argument_list|)
operator|)
condition|?
name|ppc_epp_protocol
index|[
name|ppc
operator|->
name|ppc_epp
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Prepare ppbus data area for upper level code. 	 */
name|ppbus
operator|=
name|ppb_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ppbus
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ppc
operator|->
name|ppc_link
operator|.
name|ppbus
operator|=
name|ppbus
expr_stmt|;
name|ppbus
operator|->
name|ppb_link
operator|=
operator|&
name|ppc
operator|->
name|ppc_link
expr_stmt|;
comment|/* 	 * Probe the ppbus and attach devices found. 	 */
name|ppb_attachdevs
argument_list|(
name|ppbus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

