begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997-2000 Nicolas Souchu  * Copyright (c) 2001 Alcove - Nicolas Souchu  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ppc.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ppbus/ppbconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppb_msq.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppc/ppcvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppc/ppcreg.h>
end_include

begin_include
include|#
directive|include
file|"ppbus_if.h"
end_include

begin_function_decl
specifier|static
name|void
name|ppcintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|IO_LPTSIZE_EXTENDED
value|8
end_define

begin_comment
comment|/* "Extended" LPT controllers */
end_comment

begin_define
define|#
directive|define
name|IO_LPTSIZE_NORMAL
value|4
end_define

begin_comment
comment|/* "Normal" LPT controllers */
end_comment

begin_define
define|#
directive|define
name|LOG_PPC
parameter_list|(
name|function
parameter_list|,
name|ppc
parameter_list|,
name|string
parameter_list|)
define|\
value|if (bootverbose) printf("%s: %s\n", function, string)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
name|defined
argument_list|(
name|PC98
argument_list|)
end_if

begin_define
define|#
directive|define
name|PC98_IEEE_1284_DISABLE
value|0x100
end_define

begin_define
define|#
directive|define
name|PC98_IEEE_1284_PORT
value|0x140
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEVTOSOFTC
parameter_list|(
name|dev
parameter_list|)
value|((struct ppc_data *)device_get_softc(dev))
end_define

begin_decl_stmt
name|devclass_t
name|ppc_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|ppc_driver_name
index|[]
init|=
literal|"ppc"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_models
index|[]
init|=
block|{
literal|"SMC-like"
block|,
literal|"SMC FDC37C665GT"
block|,
literal|"SMC FDC37C666GT"
block|,
literal|"PC87332"
block|,
literal|"PC87306"
block|,
literal|"82091AA"
block|,
literal|"Generic"
block|,
literal|"W83877F"
block|,
literal|"W83877AF"
block|,
literal|"Winbond"
block|,
literal|"PC87334"
block|,
literal|"SMC FDC37C935"
block|,
literal|"PC87303"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of available modes */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_avms
index|[]
init|=
block|{
literal|"COMPATIBLE"
block|,
literal|"NIBBLE-only"
block|,
literal|"PS2-only"
block|,
literal|"PS2/NIBBLE"
block|,
literal|"EPP-only"
block|,
literal|"EPP/NIBBLE"
block|,
literal|"EPP/PS2"
block|,
literal|"EPP/PS2/NIBBLE"
block|,
literal|"ECP-only"
block|,
literal|"ECP/NIBBLE"
block|,
literal|"ECP/PS2"
block|,
literal|"ECP/PS2/NIBBLE"
block|,
literal|"ECP/EPP"
block|,
literal|"ECP/EPP/NIBBLE"
block|,
literal|"ECP/EPP/PS2"
block|,
literal|"ECP/EPP/PS2/NIBBLE"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of current executing modes  * Note that few modes do not actually exist.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_modes
index|[]
init|=
block|{
literal|"COMPATIBLE"
block|,
literal|"NIBBLE"
block|,
literal|"PS/2"
block|,
literal|"PS/2"
block|,
literal|"EPP"
block|,
literal|"EPP"
block|,
literal|"EPP"
block|,
literal|"EPP"
block|,
literal|"ECP"
block|,
literal|"ECP"
block|,
literal|"ECP+PS2"
block|,
literal|"ECP+PS2"
block|,
literal|"ECP+EPP"
block|,
literal|"ECP+EPP"
block|,
literal|"ECP+EPP"
block|,
literal|"ECP+EPP"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_epp_protocol
index|[]
init|=
block|{
literal|" (EPP 1.9)"
block|,
literal|" (EPP 1.7)"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_comment
comment|/*  * BIOS printer list - used by BIOS probe.  */
end_comment

begin_define
define|#
directive|define
name|BIOS_PPC_PORTS
value|0x408
end_define

begin_define
define|#
directive|define
name|BIOS_PORTS
value|(short *)(KERNBASE+BIOS_PPC_PORTS)
end_define

begin_define
define|#
directive|define
name|BIOS_MAX_PPC
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ppc_ecp_sync()		XXX  */
end_comment

begin_function
name|void
name|ppc_ecp_sync
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|DEVTOSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
operator|)
operator|&&
operator|!
operator|(
name|ppc
operator|->
name|ppc_dtm
operator|&
name|PPB_ECP
operator|)
condition|)
return|return;
name|r
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
literal|0xe0
operator|)
operator|!=
name|PPC_ECR_EPP
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&
literal|0x1
condition|)
return|return;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ppc%d: ECP sync failed as data still "
expr|\
literal|"present in FIFO.\n"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * ppc_detect_fifo()  *  * Detect parallel port FIFO  */
end_comment

begin_function
specifier|static
name|int
name|ppc_detect_fifo
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|)
block|{
name|char
name|ecr_sav
decl_stmt|;
name|char
name|ctr_sav
decl_stmt|,
name|ctr
decl_stmt|,
name|cc
decl_stmt|;
name|short
name|i
decl_stmt|;
comment|/* save registers */
name|ecr_sav
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
name|ctr_sav
operator|=
name|r_ctr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
comment|/* enter ECP configuration mode, no interrupt, no DMA */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0xf4
argument_list|)
expr_stmt|;
comment|/* read PWord size - transfers in FIFO mode must be PWord aligned */
name|ppc
operator|->
name|ppc_pword
operator|=
operator|(
name|r_cnfgA
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_PWORD_MASK
operator|)
expr_stmt|;
comment|/* XXX 16 and 32 bits implementations not supported */
if|if
condition|(
name|ppc
operator|->
name|ppc_pword
operator|!=
name|PPC_PWORD_8
condition|)
block|{
name|LOG_PPC
argument_list|(
name|__func__
argument_list|,
name|ppc
argument_list|,
literal|"PWord not supported"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0x34
argument_list|)
expr_stmt|;
comment|/* byte mode, no interrupt, no DMA */
name|ctr
operator|=
name|r_ctr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
name|w_ctr
argument_list|(
name|ppc
argument_list|,
name|ctr
operator||
name|PCD
argument_list|)
expr_stmt|;
comment|/* set direction to 1 */
comment|/* enter ECP test mode, no interrupt, no DMA */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0xd4
argument_list|)
expr_stmt|;
comment|/* flush the FIFO */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_FIFO_EMPTY
condition|)
break|break;
name|cc
operator|=
name|r_fifo
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
literal|1024
condition|)
block|{
name|LOG_PPC
argument_list|(
name|__func__
argument_list|,
name|ppc
argument_list|,
literal|"can't flush FIFO"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* enable interrupts, no DMA */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0xd0
argument_list|)
expr_stmt|;
comment|/* determine readIntrThreshold 	 * fill the FIFO until serviceIntr is set 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
block|{
name|w_fifo
argument_list|(
name|ppc
argument_list|,
operator|(
name|char
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ppc
operator|->
name|ppc_rthr
operator|&&
operator|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_SERVICE_INTR
operator|)
condition|)
block|{
comment|/* readThreshold reached */
name|ppc
operator|->
name|ppc_rthr
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_FIFO_FULL
condition|)
block|{
name|ppc
operator|->
name|ppc_fifo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
literal|1024
condition|)
block|{
name|LOG_PPC
argument_list|(
name|__func__
argument_list|,
name|ppc
argument_list|,
literal|"can't fill FIFO"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0xd4
argument_list|)
expr_stmt|;
comment|/* test mode, no interrupt, no DMA */
name|w_ctr
argument_list|(
name|ppc
argument_list|,
name|ctr
operator|&
operator|~
name|PCD
argument_list|)
expr_stmt|;
comment|/* set direction to 0 */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0xd0
argument_list|)
expr_stmt|;
comment|/* enable interrupts */
comment|/* determine writeIntrThreshold 	 * empty the FIFO until serviceIntr is set 	 */
for|for
control|(
name|i
operator|=
name|ppc
operator|->
name|ppc_fifo
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|r_fifo
argument_list|(
name|ppc
argument_list|)
operator|!=
call|(
name|char
call|)
argument_list|(
name|ppc
operator|->
name|ppc_fifo
operator|-
name|i
argument_list|)
condition|)
block|{
name|LOG_PPC
argument_list|(
name|__func__
argument_list|,
name|ppc
argument_list|,
literal|"invalid data in FIFO"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_SERVICE_INTR
condition|)
block|{
comment|/* writeIntrThreshold reached */
name|ppc
operator|->
name|ppc_wthr
operator|=
name|ppc
operator|->
name|ppc_fifo
operator|-
name|i
operator|+
literal|1
expr_stmt|;
block|}
comment|/* if FIFO empty before the last byte, error */
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
operator|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_FIFO_EMPTY
operator|)
condition|)
block|{
name|LOG_PPC
argument_list|(
name|__func__
argument_list|,
name|ppc
argument_list|,
literal|"data lost in FIFO"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|/* FIFO must be empty after the last byte */
if|if
condition|(
operator|!
operator|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_FIFO_EMPTY
operator|)
condition|)
block|{
name|LOG_PPC
argument_list|(
name|__func__
argument_list|,
name|ppc
argument_list|,
literal|"can't empty the FIFO"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|w_ctr
argument_list|(
name|ppc
argument_list|,
name|ctr_sav
argument_list|)
expr_stmt|;
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr_sav
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|w_ctr
argument_list|(
name|ppc
argument_list|,
name|ctr_sav
argument_list|)
expr_stmt|;
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr_sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ppc_detect_port
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|)
block|{
name|w_ctr
argument_list|(
name|ppc
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
comment|/* To avoid missing PS2 ports */
name|w_dtr
argument_list|(
name|ppc
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_dtr
argument_list|(
name|ppc
argument_list|)
operator|!=
literal|0xaa
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * EPP timeout, according to the PC87332 manual  * Semantics of clearing EPP timeout bit.  * PC87332	- reading SPP_STR does it...  * SMC		- write 1 to EPP timeout bit			XXX  * Others	- (?) write 0 to EPP timeout bit  */
end_comment

begin_function
specifier|static
name|void
name|ppc_reset_epp_timeout
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|)
block|{
specifier|register
name|char
name|r
decl_stmt|;
name|r
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
name|w_str
argument_list|(
name|ppc
argument_list|,
name|r
operator||
literal|0x1
argument_list|)
expr_stmt|;
name|w_str
argument_list|(
name|ppc
argument_list|,
name|r
operator|&
literal|0xfe
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ppc_check_epp_timeout
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|)
block|{
name|ppc_reset_epp_timeout
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|r_str
argument_list|(
name|ppc
argument_list|)
operator|&
name|TIMEOUT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Configure current operating mode  */
end_comment

begin_function
specifier|static
name|int
name|ppc_generic_setmode
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|u_char
name|ecr
init|=
literal|0
decl_stmt|;
comment|/* check if mode is available */
if|if
condition|(
name|mode
operator|&&
operator|!
operator|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|mode
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* if ECP mode, configure ecr register */
if|if
condition|(
operator|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
operator|)
operator|||
operator|(
name|ppc
operator|->
name|ppc_dtm
operator|&
name|PPB_ECP
operator|)
condition|)
block|{
comment|/* return to byte mode (keeping direction bit), 		 * no interrupt, no DMA to be able to change to 		 * ECP 		 */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|PPC_ECR_RESET
argument_list|)
expr_stmt|;
name|ecr
operator|=
name|PPC_DISABLE_INTR
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|PPB_EPP
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
elseif|else
if|if
condition|(
name|mode
operator|&
name|PPB_ECP
condition|)
comment|/* select ECP mode */
name|ecr
operator||=
name|PPC_ECR_ECP
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|&
name|PPB_PS2
condition|)
comment|/* select PS2 mode with ECP */
name|ecr
operator||=
name|PPC_ECR_PS2
expr_stmt|;
else|else
comment|/* select COMPATIBLE/NIBBLE mode */
name|ecr
operator||=
name|PPC_ECR_STD
expr_stmt|;
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr
argument_list|)
expr_stmt|;
block|}
name|ppc
operator|->
name|ppc_mode
operator|=
name|mode
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The ppc driver is free to choose options like FIFO or DMA  * if ECP mode is available.  *  * The 'RAW' option allows the upper drivers to force the ppc mode  * even with FIFO, DMA available.  */
end_comment

begin_function
specifier|static
name|int
name|ppc_smclike_setmode
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|u_char
name|ecr
init|=
literal|0
decl_stmt|;
comment|/* check if mode is available */
if|if
condition|(
name|mode
operator|&&
operator|!
operator|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|mode
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* if ECP mode, configure ecr register */
if|if
condition|(
operator|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
operator|)
operator|||
operator|(
name|ppc
operator|->
name|ppc_dtm
operator|&
name|PPB_ECP
operator|)
condition|)
block|{
comment|/* return to byte mode (keeping direction bit), 		 * no interrupt, no DMA to be able to change to 		 * ECP or EPP mode 		 */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|PPC_ECR_RESET
argument_list|)
expr_stmt|;
name|ecr
operator|=
name|PPC_DISABLE_INTR
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|PPB_EPP
condition|)
comment|/* select EPP mode */
name|ecr
operator||=
name|PPC_ECR_EPP
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|&
name|PPB_ECP
condition|)
comment|/* select ECP mode */
name|ecr
operator||=
name|PPC_ECR_ECP
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|&
name|PPB_PS2
condition|)
comment|/* select PS2 mode with ECP */
name|ecr
operator||=
name|PPC_ECR_PS2
expr_stmt|;
else|else
comment|/* select COMPATIBLE/NIBBLE mode */
name|ecr
operator||=
name|PPC_ECR_STD
expr_stmt|;
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr
argument_list|)
expr_stmt|;
block|}
name|ppc
operator|->
name|ppc_mode
operator|=
name|mode
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PPC_PROBE_CHIPSET
end_ifdef

begin_comment
comment|/*  * ppc_pc873xx_detect  *  * Probe for a Natsemi PC873xx-family part.  *  * References in this function are to the National Semiconductor  * PC87332 datasheet TL/C/11930, May 1995 revision.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pc873xx_basetab
index|[]
init|=
block|{
literal|0x0398
block|,
literal|0x026e
block|,
literal|0x015c
block|,
literal|0x002e
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pc873xx_porttab
index|[]
init|=
block|{
literal|0x0378
block|,
literal|0x03bc
block|,
literal|0x0278
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pc873xx_irqtab
index|[]
init|=
block|{
literal|5
block|,
literal|7
block|,
literal|5
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pc873xx_regstab
index|[]
init|=
block|{
name|PC873_FER
block|,
name|PC873_FAR
block|,
name|PC873_PTR
block|,
name|PC873_FCR
block|,
name|PC873_PCR
block|,
name|PC873_PMC
block|,
name|PC873_TUP
block|,
name|PC873_SID
block|,
name|PC873_PNP0
block|,
name|PC873_PNP1
block|,
name|PC873_LPTBA
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pc873xx_rnametab
index|[]
init|=
block|{
literal|"FER"
block|,
literal|"FAR"
block|,
literal|"PTR"
block|,
literal|"FCR"
block|,
literal|"PCR"
block|,
literal|"PMC"
block|,
literal|"TUP"
block|,
literal|"SID"
block|,
literal|"PNP0"
block|,
literal|"PNP1"
block|,
literal|"LPTBA"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ppc_pc873xx_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
comment|/* XXX mode never forced */
block|{
specifier|static
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|idport
decl_stmt|,
name|irq
decl_stmt|;
name|int
name|ptr
decl_stmt|,
name|pcr
decl_stmt|,
name|val
decl_stmt|,
name|i
decl_stmt|;
while|while
condition|(
operator|(
name|idport
operator|=
name|pc873xx_basetab
index|[
name|index
operator|++
index|]
operator|)
condition|)
block|{
comment|/* XXX should check first to see if this location is already claimed */
comment|/* 	 * Pull the 873xx through the power-on ID cycle (2.2,1.). 	 * We can't use this to locate the chip as it may already have 	 * been used by the BIOS. 	 */
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
comment|/* 	 * Read the SID byte.  Possible values are : 	 * 	 * 01010xxx	PC87334 	 * 0001xxxx	PC87332 	 * 01110xxx	PC87306 	 * 00110xxx	PC87303 	 */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_SID
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0xf0
operator|)
operator|==
literal|0x10
condition|)
block|{
name|ppc
operator|->
name|ppc_model
operator|=
name|NS_PC87332
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|0xf8
operator|)
operator|==
literal|0x70
condition|)
block|{
name|ppc
operator|->
name|ppc_model
operator|=
name|NS_PC87306
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|0xf8
operator|)
operator|==
literal|0x50
condition|)
block|{
name|ppc
operator|->
name|ppc_model
operator|=
name|NS_PC87334
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|0xf8
operator|)
operator|==
literal|0x40
condition|)
block|{
comment|/* Should be 0x30 by the 					      documentation, but probing 					      yielded 0x40... */
name|ppc
operator|->
name|ppc_model
operator|=
name|NS_PC87303
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
operator|&&
operator|(
name|val
operator|!=
literal|0xff
operator|)
condition|)
name|printf
argument_list|(
literal|"PC873xx probe at 0x%x got unknown ID 0x%x\n"
argument_list|,
name|idport
argument_list|,
name|val
argument_list|)
expr_stmt|;
continue|continue ;
comment|/* not recognised */
block|}
comment|/* print registers */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"PC873xx"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pc873xx_regstab
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|idport
argument_list|,
name|pc873xx_regstab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s=0x%x"
argument_list|,
name|pc873xx_rnametab
index|[
name|i
index|]
argument_list|,
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We think we have one.  Is it enabled and where we want it to be? 	 */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_FER
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PC873_PPENABLE
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx parallel port disabled\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_FAR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX we should create a driver instance for every port found */
if|if
condition|(
name|pc873xx_porttab
index|[
name|val
operator|&
literal|0x3
index|]
operator|!=
name|ppc
operator|->
name|ppc_base
condition|)
block|{
comment|/* First try to change the port address to that requested... */
switch|switch
condition|(
name|ppc
operator|->
name|ppc_base
condition|)
block|{
case|case
literal|0x378
case|:
name|val
operator|&=
literal|0xfc
expr_stmt|;
break|break;
case|case
literal|0x3bc
case|:
name|val
operator|&=
literal|0xfd
expr_stmt|;
break|break;
case|case
literal|0x278
case|:
name|val
operator|&=
literal|0xfe
expr_stmt|;
break|break;
default|default:
name|val
operator|&=
literal|0xfd
expr_stmt|;
break|break;
block|}
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_FAR
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Check for success by reading back the value we supposedly 	       wrote and comparing...*/
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_FAR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
operator|&
literal|0x3
expr_stmt|;
comment|/* If we fail, report the failure... */
if|if
condition|(
name|pc873xx_porttab
index|[
name|val
index|]
operator|!=
name|ppc
operator|->
name|ppc_base
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx at 0x%x not for driver at port 0x%x\n"
argument_list|,
name|pc873xx_porttab
index|[
name|val
index|]
argument_list|,
name|ppc
operator|->
name|ppc_base
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* get irq settings */
if|if
condition|(
name|ppc
operator|->
name|ppc_base
operator|==
literal|0x378
condition|)
name|irq
operator|=
operator|(
name|ptr
operator|&
name|PC873_LPTBIRQ7
operator|)
condition|?
literal|7
else|:
literal|5
expr_stmt|;
else|else
name|irq
operator|=
name|pc873xx_irqtab
index|[
name|val
index|]
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx irq %d at 0x%x\n"
argument_list|,
name|irq
argument_list|,
name|ppc
operator|->
name|ppc_base
argument_list|)
expr_stmt|;
comment|/* 	 * Check if irq settings are correct 	 */
if|if
condition|(
name|irq
operator|!=
name|ppc
operator|->
name|ppc_irq
condition|)
block|{
comment|/* 		 * If the chipset is not locked and base address is 0x378, 		 * we have another chance 		 */
if|if
condition|(
name|ppc
operator|->
name|ppc_base
operator|==
literal|0x378
operator|&&
operator|!
operator|(
name|ptr
operator|&
name|PC873_CFGLOCK
operator|)
condition|)
block|{
if|if
condition|(
name|ppc
operator|->
name|ppc_irq
operator|==
literal|7
condition|)
block|{
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
operator|(
name|ptr
operator||
name|PC873_LPTBIRQ7
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
operator|(
name|ptr
operator||
name|PC873_LPTBIRQ7
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
operator|(
name|ptr
operator|&
operator|~
name|PC873_LPTBIRQ7
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
operator|(
name|ptr
operator|&
operator|~
name|PC873_LPTBIRQ7
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx irq set to %d\n"
argument_list|,
name|ppc
operator|->
name|ppc_irq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx sorry, can't change irq setting\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx irq settings are correct\n"
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PCR
argument_list|)
expr_stmt|;
name|pcr
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|&
name|PC873_CFGLOCK
operator|)
operator|||
operator|!
name|chipset_mode
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx %s"
argument_list|,
operator|(
name|ptr
operator|&
name|PC873_CFGLOCK
operator|)
condition|?
literal|"locked"
else|:
literal|"unlocked"
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_NIBBLE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", NIBBLE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr
operator|&
name|PC873_EPPEN
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_EPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", EPP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr
operator|&
name|PC873_EPP19
condition|)
name|ppc
operator|->
name|ppc_epp
operator|=
name|EPP_1_9
expr_stmt|;
else|else
name|ppc
operator|->
name|ppc_epp
operator|=
name|EPP_1_7
expr_stmt|;
if|if
condition|(
operator|(
name|ppc
operator|->
name|ppc_model
operator|==
name|NS_PC87332
operator|)
operator|&&
name|bootverbose
condition|)
block|{
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|&
name|PC873_EPPRDIR
condition|)
name|printf
argument_list|(
literal|", Regular mode"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", Automatic mode"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pcr
operator|&
name|PC873_ECPEN
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", ECP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr
operator|&
name|PC873_ECPCLK
condition|)
block|{
comment|/* XXX */
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_PS2
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", PS/2"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|&
name|PC873_EXTENDED
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", SPP"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx unlocked"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_ECP
condition|)
block|{
if|if
condition|(
operator|(
name|chipset_mode
operator|&
name|PPB_EPP
operator|)
operator|&&
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", ECP+EPP not supported"
argument_list|)
expr_stmt|;
name|pcr
operator|&=
operator|~
name|PC873_EPPEN
expr_stmt|;
name|pcr
operator||=
operator|(
name|PC873_ECPEN
operator||
name|PC873_ECPCLK
operator|)
expr_stmt|;
comment|/* XXX */
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", ECP"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_EPP
condition|)
block|{
name|pcr
operator|&=
operator|~
operator|(
name|PC873_ECPEN
operator||
name|PC873_ECPCLK
operator|)
expr_stmt|;
name|pcr
operator||=
operator|(
name|PC873_EPPEN
operator||
name|PC873_EPP19
operator|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_epp
operator|=
name|EPP_1_9
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", EPP1.9"
argument_list|)
expr_stmt|;
comment|/* enable automatic direction turnover */
if|if
condition|(
name|ppc
operator|->
name|ppc_model
operator|==
name|NS_PC87332
condition|)
block|{
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|&=
operator|~
name|PC873_EPPRDIR
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", Automatic mode"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pcr
operator|&=
operator|~
operator|(
name|PC873_ECPEN
operator||
name|PC873_ECPCLK
operator||
name|PC873_EPPEN
operator|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
comment|/* configure extended bit in PTR */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_PS2
condition|)
block|{
name|ptr
operator||=
name|PC873_EXTENDED
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", PS/2"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* default to NIBBLE mode */
name|ptr
operator|&=
operator|~
name|PC873_EXTENDED
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", NIBBLE"
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|ppc
operator|->
name|ppc_avm
operator|=
name|chipset_mode
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_type
operator|=
name|PPC_TYPE_GENERIC
expr_stmt|;
name|ppc_generic_setmode
argument_list|(
name|ppc
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|chipset_mode
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppc_smc37c66xgt_detect  *  * SMC FDC37C66xGT configuration.  */
end_comment

begin_function
specifier|static
name|int
name|ppc_smc37c66xgt_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|u_char
name|r
decl_stmt|;
name|int
name|type
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|csr
init|=
name|SMC66x_CSR
decl_stmt|;
comment|/* initial value is 0x3F0 */
name|int
name|port_address
index|[]
init|=
block|{
operator|-
literal|1
comment|/* disabled */
block|,
literal|0x3bc
block|,
literal|0x378
block|,
literal|0x278
block|}
decl_stmt|;
define|#
directive|define
name|cio
value|csr+1
comment|/* config IO port is either 0x3F1 or 0x371 */
comment|/* 	 * Detection: enter configuration mode and read CRD register. 	 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC665_iCODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC665_iCODE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|==
literal|0x65
condition|)
block|{
name|type
operator|=
name|SMC_37C665GT
expr_stmt|;
goto|goto
name|config
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC666_iCODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC666_iCODE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|==
literal|0x66
condition|)
block|{
name|type
operator|=
name|SMC_37C666GT
expr_stmt|;
break|break;
block|}
comment|/* Another chance, CSR may be hard-configured to be at 0x370 */
name|csr
operator|=
name|SMC666_CSR
expr_stmt|;
block|}
name|config
label|:
comment|/* 	 * If chipset not found, do not continue. 	 */
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* select CR1 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* read the port's address: bits 0 and 1 of CR1 */
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
name|SMC_CR1_ADDR
expr_stmt|;
if|if
condition|(
name|port_address
index|[
operator|(
name|int
operator|)
name|r
index|]
operator|!=
name|ppc
operator|->
name|ppc_base
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ppc
operator|->
name|ppc_model
operator|=
name|type
expr_stmt|;
comment|/* 	 * CR1 and CR4 registers bits 3 and 0/1 for mode configuration 	 * If SPP mode is detected, try to set ECP+EPP mode 	 */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ppc%d: SMC registers CR1=0x%x"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|,
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" CR4=0x%x"
argument_list|,
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
comment|/* select CR1 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chipset_mode
condition|)
block|{
comment|/* autodetect mode */
comment|/* 666GT is ~certainly~ hardwired to an extended ECP+EPP mode */
if|if
condition|(
name|type
operator|==
name|SMC_37C666GT
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" configuration hardwired, supposing "
expr|\
literal|"ECP+EPP SPP"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
name|SMC_CR1_MODE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* already in extended parallel port mode, read CR4 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
name|SMC_CR4_EMODE
operator|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|SMC_SPP
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" SPP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMC_EPPSPP
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" EPP SPP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMC_ECP
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP SPP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMC_ECPEPP
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP+EPP SPP"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* not an extended port mode */
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" SPP"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* mode forced */
name|ppc
operator|->
name|ppc_avm
operator|=
name|chipset_mode
expr_stmt|;
comment|/* 666GT is ~certainly~ hardwired to an extended ECP+EPP mode */
if|if
condition|(
name|type
operator|==
name|SMC_37C666GT
condition|)
goto|goto
name|end_detect
goto|;
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chipset_mode
operator|&
operator|(
name|PPB_ECP
operator||
name|PPB_EPP
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* do not use ECP when the mode is not forced to */
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_CR1_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" SPP"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* an extended mode is selected */
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator|&
operator|~
name|SMC_CR1_MODE
argument_list|)
expr_stmt|;
comment|/* read CR4 register and reset mode field */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
operator|~
name|SMC_CR4_EMODE
expr_stmt|;
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_ECP
condition|)
block|{
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_EPP
condition|)
block|{
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_ECPEPP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP+EPP"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_ECP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* PPB_EPP is set */
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_EPPSPP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" EPP SPP"
argument_list|)
expr_stmt|;
block|}
block|}
name|ppc
operator|->
name|ppc_avm
operator|=
name|chipset_mode
expr_stmt|;
block|}
comment|/* set FIFO threshold to 16 */
if|if
condition|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
condition|)
block|{
comment|/* select CRA */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0xa
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|cio
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
name|end_detect
label|:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_EPP
condition|)
block|{
comment|/* select CR4 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
expr_stmt|;
comment|/* 		 * Set the EPP protocol... 		 * Low=EPP 1.9 (1284 standard) and High=EPP 1.7 		 */
if|if
condition|(
name|ppc
operator|->
name|ppc_epp
operator|==
name|EPP_1_9
condition|)
name|outb
argument_list|(
name|cio
argument_list|,
operator|(
name|r
operator|&
operator|~
name|SMC_CR4_EPPTYPE
operator|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|cio
argument_list|,
operator|(
name|r
operator||
name|SMC_CR4_EPPTYPE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* end config mode */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_type
operator|=
name|PPC_TYPE_SMCLIKE
expr_stmt|;
name|ppc_smclike_setmode
argument_list|(
name|ppc
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|chipset_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SMC FDC37C935 configuration  * Found on many Alpha machines  */
end_comment

begin_function
specifier|static
name|int
name|ppc_smc37c935_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|type
init|=
operator|-
literal|1
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|SMC935_CFG
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
comment|/* enter config mode */
name|outb
argument_list|(
name|SMC935_CFG
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SMC935_IND
argument_list|,
name|SMC935_ID
argument_list|)
expr_stmt|;
comment|/* check device id */
if|if
condition|(
name|inb
argument_list|(
name|SMC935_DAT
argument_list|)
operator|==
literal|0x2
condition|)
name|type
operator|=
name|SMC_37C935
expr_stmt|;
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
block|{
name|outb
argument_list|(
name|SMC935_CFG
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
comment|/* exit config mode */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ppc
operator|->
name|ppc_model
operator|=
name|type
expr_stmt|;
name|outb
argument_list|(
name|SMC935_IND
argument_list|,
name|SMC935_LOGDEV
argument_list|)
expr_stmt|;
comment|/* select parallel port, */
name|outb
argument_list|(
name|SMC935_DAT
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* which is logical device 3 */
comment|/* set io port base */
name|outb
argument_list|(
name|SMC935_IND
argument_list|,
name|SMC935_PORTHI
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SMC935_DAT
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
name|ppc
operator|->
name|ppc_base
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SMC935_IND
argument_list|,
name|SMC935_PORTLO
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SMC935_DAT
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|ppc
operator|->
name|ppc_base
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chipset_mode
condition|)
name|ppc
operator|->
name|ppc_avm
operator|=
name|PPB_COMPATIBLE
expr_stmt|;
comment|/* default mode */
else|else
block|{
name|ppc
operator|->
name|ppc_avm
operator|=
name|chipset_mode
expr_stmt|;
name|outb
argument_list|(
name|SMC935_IND
argument_list|,
name|SMC935_PPMODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SMC935_DAT
argument_list|,
name|SMC935_CENT
argument_list|)
expr_stmt|;
comment|/* start in compatible mode */
comment|/* SPP + EPP or just plain SPP */
if|if
condition|(
name|chipset_mode
operator|&
operator|(
name|PPB_SPP
operator|)
condition|)
block|{
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_EPP
condition|)
block|{
if|if
condition|(
name|ppc
operator|->
name|ppc_epp
operator|==
name|EPP_1_9
condition|)
block|{
name|outb
argument_list|(
name|SMC935_IND
argument_list|,
name|SMC935_PPMODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SMC935_DAT
argument_list|,
name|SMC935_EPP19SPP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ppc
operator|->
name|ppc_epp
operator|==
name|EPP_1_7
condition|)
block|{
name|outb
argument_list|(
name|SMC935_IND
argument_list|,
name|SMC935_PPMODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SMC935_DAT
argument_list|,
name|SMC935_EPP17SPP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|outb
argument_list|(
name|SMC935_IND
argument_list|,
name|SMC935_PPMODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SMC935_DAT
argument_list|,
name|SMC935_SPP
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ECP + EPP or just plain ECP */
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_ECP
condition|)
block|{
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_EPP
condition|)
block|{
if|if
condition|(
name|ppc
operator|->
name|ppc_epp
operator|==
name|EPP_1_9
condition|)
block|{
name|outb
argument_list|(
name|SMC935_IND
argument_list|,
name|SMC935_PPMODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SMC935_DAT
argument_list|,
name|SMC935_ECPEPP19
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ppc
operator|->
name|ppc_epp
operator|==
name|EPP_1_7
condition|)
block|{
name|outb
argument_list|(
name|SMC935_IND
argument_list|,
name|SMC935_PPMODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SMC935_DAT
argument_list|,
name|SMC935_ECPEPP17
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|outb
argument_list|(
name|SMC935_IND
argument_list|,
name|SMC935_PPMODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SMC935_DAT
argument_list|,
name|SMC935_ECP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|outb
argument_list|(
name|SMC935_CFG
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
comment|/* exit config mode */
name|ppc
operator|->
name|ppc_type
operator|=
name|PPC_TYPE_SMCLIKE
expr_stmt|;
name|ppc_smclike_setmode
argument_list|(
name|ppc
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|chipset_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Winbond W83877F stuff  *  * EFER: extended function enable register  * EFIR: extended function index register  * EFDR: extended function data register  */
end_comment

begin_define
define|#
directive|define
name|efir
value|((efer == 0x250) ? 0x251 : 0x3f0)
end_define

begin_define
define|#
directive|define
name|efdr
value|((efer == 0x250) ? 0x252 : 0x3f1)
end_define

begin_decl_stmt
specifier|static
name|int
name|w83877f_efers
index|[]
init|=
block|{
literal|0x250
block|,
literal|0x3f0
block|,
literal|0x3f0
block|,
literal|0x250
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|w83877f_keys
index|[]
init|=
block|{
literal|0x89
block|,
literal|0x86
block|,
literal|0x87
block|,
literal|0x88
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|w83877f_keyiter
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|w83877f_hefs
index|[]
init|=
block|{
name|WINB_HEFERE
block|,
name|WINB_HEFRAS
block|,
name|WINB_HEFERE
operator||
name|WINB_HEFRAS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ppc_w83877f_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|efer
decl_stmt|;
name|unsigned
name|char
name|r
decl_stmt|,
name|hefere
decl_stmt|,
name|hefras
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
comment|/* first try to enable configuration registers */
name|efer
operator|=
name|w83877f_efers
index|[
name|i
index|]
expr_stmt|;
comment|/* write the key to the EFER */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w83877f_keyiter
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
name|outb
argument_list|(
name|efer
argument_list|,
name|w83877f_keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* then check HEFERE and HEFRAS bits */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
name|hefere
operator|=
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
name|WINB_HEFERE
expr_stmt|;
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x16
argument_list|)
expr_stmt|;
name|hefras
operator|=
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
name|WINB_HEFRAS
expr_stmt|;
comment|/* 		 * HEFRAS	HEFERE 		 *   0		   1	write 89h to 250h (power-on default) 		 *   1		   0	write 86h twice to 3f0h 		 *   1		   1	write 87h twice to 3f0h 		 *   0		   0	write 88h to 250h 		 */
if|if
condition|(
operator|(
name|hefere
operator||
name|hefras
operator|)
operator|==
name|w83877f_hefs
index|[
name|i
index|]
condition|)
goto|goto
name|found
goto|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* failed */
name|found
label|:
comment|/* check base port address - read from CR23 */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x23
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_base
operator|!=
name|inb
argument_list|(
name|efdr
argument_list|)
operator|*
literal|4
condition|)
comment|/* 4 bytes boundaries */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* read CHIP ID from CR9/bits0-3 */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x9
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
name|WINB_CHIPID
condition|)
block|{
case|case
name|WINB_W83877F_ID
case|:
name|ppc
operator|->
name|ppc_model
operator|=
name|WINB_W83877F
expr_stmt|;
break|break;
case|case
name|WINB_W83877AF_ID
case|:
name|ppc
operator|->
name|ppc_model
operator|=
name|WINB_W83877AF
expr_stmt|;
break|break;
default|default:
name|ppc
operator|->
name|ppc_model
operator|=
name|WINB_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
comment|/* dump of registers */
name|printf
argument_list|(
literal|"ppc%d: 0x%x - "
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|,
name|w83877f_keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|0xd
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|efir
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0x10
init|;
name|i
operator|<=
literal|0x17
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|efir
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x1e
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x20
init|;
name|i
operator|<=
literal|0x29
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|efir
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ppc%d:"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|)
expr_stmt|;
block|}
name|ppc
operator|->
name|ppc_type
operator|=
name|PPC_TYPE_GENERIC
expr_stmt|;
if|if
condition|(
operator|!
name|chipset_mode
condition|)
block|{
comment|/* autodetect mode */
comment|/* select CR0 */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|r
operator|=
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
operator|(
name|WINB_PRTMODS0
operator||
name|WINB_PRTMODS1
operator|)
expr_stmt|;
comment|/* select CR9 */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x9
argument_list|)
expr_stmt|;
name|r
operator||=
operator|(
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
name|WINB_PRTMODS2
operator|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|WINB_W83757
case|:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ppc%d: W83757 compatible mode\n"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* generic or SMC-like */
case|case
name|WINB_EXTFDC
case|:
case|case
name|WINB_EXTADP
case|:
case|case
name|WINB_EXT2FDD
case|:
case|case
name|WINB_JOYSTICK
case|:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" not in parallel port mode\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
operator|(
name|WINB_PARALLEL
operator||
name|WINB_EPP_SPP
operator|)
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" EPP SPP"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|WINB_PARALLEL
operator||
name|WINB_ECP
operator|)
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP SPP"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|WINB_PARALLEL
operator||
name|WINB_ECP_EPP
operator|)
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
name|ppc
operator|->
name|ppc_type
operator|=
name|PPC_TYPE_SMCLIKE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP+EPP SPP"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: unknown case (0x%x)!\n"
argument_list|,
name|__func__
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* mode forced */
comment|/* select CR9 and set PRTMODS2 bit */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x9
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
operator|~
name|WINB_PRTMODS2
argument_list|)
expr_stmt|;
comment|/* select CR0 and reset PRTMODSx bits */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
operator|~
operator|(
name|WINB_PRTMODS0
operator||
name|WINB_PRTMODS1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_ECP
condition|)
block|{
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_EPP
condition|)
block|{
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator||
name|WINB_ECP_EPP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP+EPP"
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_type
operator|=
name|PPC_TYPE_SMCLIKE
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator||
name|WINB_ECP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* select EPP_SPP otherwise */
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator||
name|WINB_EPP_SPP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" EPP SPP"
argument_list|)
expr_stmt|;
block|}
name|ppc
operator|->
name|ppc_avm
operator|=
name|chipset_mode
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* exit configuration mode */
name|outb
argument_list|(
name|efer
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ppc
operator|->
name|ppc_type
condition|)
block|{
case|case
name|PPC_TYPE_SMCLIKE
case|:
name|ppc_smclike_setmode
argument_list|(
name|ppc
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ppc_generic_setmode
argument_list|(
name|ppc
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|chipset_mode
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ppc_generic_detect  */
end_comment

begin_function
specifier|static
name|int
name|ppc_generic_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
block|{
comment|/* default to generic */
name|ppc
operator|->
name|ppc_type
operator|=
name|PPC_TYPE_GENERIC
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ppc%d:"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|)
expr_stmt|;
comment|/* first, check for ECP */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|PPC_ECR_PS2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
literal|0xe0
operator|)
operator|==
name|PPC_ECR_PS2
condition|)
block|{
name|ppc
operator|->
name|ppc_dtm
operator||=
name|PPB_ECP
operator||
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP SPP"
argument_list|)
expr_stmt|;
comment|/* search for SMC style ECP+EPP mode */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|PPC_ECR_EPP
argument_list|)
expr_stmt|;
block|}
comment|/* try to reset EPP timeout bit */
if|if
condition|(
name|ppc_check_epp_timeout
argument_list|(
name|ppc
argument_list|)
condition|)
block|{
name|ppc
operator|->
name|ppc_dtm
operator||=
name|PPB_EPP
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_dtm
operator|&
name|PPB_ECP
condition|)
block|{
comment|/* SMC like chipset found */
name|ppc
operator|->
name|ppc_model
operator|=
name|SMC_LIKE
expr_stmt|;
name|ppc
operator|->
name|ppc_type
operator|=
name|PPC_TYPE_SMCLIKE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP+EPP"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" EPP"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* restore to standard mode */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|PPC_ECR_STD
argument_list|)
expr_stmt|;
block|}
comment|/* XXX try to detect NIBBLE and PS2 modes */
name|ppc
operator|->
name|ppc_dtm
operator||=
name|PPB_NIBBLE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" SPP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chipset_mode
condition|)
name|ppc
operator|->
name|ppc_avm
operator|=
name|chipset_mode
expr_stmt|;
else|else
name|ppc
operator|->
name|ppc_avm
operator|=
name|ppc
operator|->
name|ppc_dtm
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ppc
operator|->
name|ppc_type
condition|)
block|{
case|case
name|PPC_TYPE_SMCLIKE
case|:
name|ppc_smclike_setmode
argument_list|(
name|ppc
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ppc_generic_setmode
argument_list|(
name|ppc
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|chipset_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppc_detect()  *  * mode is the mode suggested at boot  */
end_comment

begin_function
specifier|static
name|int
name|ppc_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PPC_PROBE_CHIPSET
name|int
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* list of supported chipsets */
name|int
function_decl|(
modifier|*
name|chipset_detect
index|[]
function_decl|)
parameter_list|(
name|struct
name|ppc_data
modifier|*
parameter_list|,
name|int
parameter_list|)
init|=
block|{
name|ppc_pc873xx_detect
operator|,
function_decl|ppc_smc37c66xgt_detect
operator|,
function_decl|ppc_w83877f_detect
operator|,
function_decl|ppc_smc37c935_detect
operator|,
function_decl|ppc_generic_detect
operator|,
function_decl|NULL
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* if can't find the port and mode not forced return error */
end_comment

begin_if
if|if
condition|(
operator|!
name|ppc_detect_port
argument_list|(
name|ppc
argument_list|)
operator|&&
name|chipset_mode
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
end_if

begin_comment
comment|/* failed, port not present */
end_comment

begin_comment
comment|/* assume centronics compatible mode is supported */
end_comment

begin_expr_stmt
name|ppc
operator|->
name|ppc_avm
operator|=
name|PPB_COMPATIBLE
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PPC_PROBE_CHIPSET
end_ifdef

begin_comment
comment|/* we have to differenciate available chipset modes, 	 * chipset running modes and IEEE-1284 operating modes 	 * 	 * after detection, the port must support running in compatible mode 	 */
end_comment

begin_if
if|if
condition|(
name|ppc
operator|->
name|ppc_flags
operator|&
literal|0x40
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ppc: chipset forced to generic\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ppc
operator|->
name|ppc_mode
operator|=
name|ppc_generic_detect
argument_list|(
name|ppc
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PPC_PROBE_CHIPSET
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|chipset_detect
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mode
operator|=
name|chipset_detect
index|[
name|i
index|]
operator|(
name|ppc
operator|,
name|chipset_mode
operator|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ppc
operator|->
name|ppc_mode
operator|=
name|mode
expr_stmt|;
break|break;
block|}
block|}
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* configure/detect ECP FIFO */
end_comment

begin_if
if|if
condition|(
operator|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
operator|)
operator|&&
operator|!
operator|(
name|ppc
operator|->
name|ppc_flags
operator|&
literal|0x80
operator|)
condition|)
name|ppc_detect_fifo
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * ppc_exec_microseq()  *  * Execute a microsequence.  * Microsequence mechanism is supposed to handle fast I/O operations.  */
end_comment

begin_macro
unit|int
name|ppc_exec_microseq
argument_list|(
argument|device_t dev
argument_list|,
argument|struct ppb_microseq **p_msq
argument_list|)
end_macro

begin_block
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|DEVTOSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ppb_microseq
modifier|*
name|mi
decl_stmt|;
name|char
name|cc
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|iter
decl_stmt|,
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
specifier|register
name|int
name|reg
decl_stmt|;
specifier|register
name|char
name|mask
decl_stmt|;
specifier|register
name|int
name|accum
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
init|=
literal|0
decl_stmt|;
name|struct
name|ppb_microseq
modifier|*
name|stack
init|=
literal|0
decl_stmt|;
comment|/* microsequence registers are equivalent to PC-like port registers */
define|#
directive|define
name|r_reg
parameter_list|(
name|reg
parameter_list|,
name|ppc
parameter_list|)
value|(bus_read_1((ppc)->res_ioport, reg))
define|#
directive|define
name|w_reg
parameter_list|(
name|reg
parameter_list|,
name|ppc
parameter_list|,
name|byte
parameter_list|)
value|(bus_write_1((ppc)->res_ioport, reg, byte))
define|#
directive|define
name|INCR_PC
value|(mi ++)
comment|/* increment program counter */
name|mi
operator|=
operator|*
name|p_msq
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|mi
operator|->
name|opcode
condition|)
block|{
case|case
name|MS_OP_RSET
case|:
name|cc
operator|=
name|r_reg
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|,
name|ppc
argument_list|)
expr_stmt|;
name|cc
operator|&=
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|i
expr_stmt|;
comment|/* clear mask */
name|cc
operator||=
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
comment|/* assert mask */
name|w_reg
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|,
name|ppc
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_RASSERT_P
case|:
name|reg
operator|=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
name|ptr
operator|=
name|ppc
operator|->
name|ppc_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
operator|)
operator|==
name|MS_ACCUM
condition|)
block|{
name|accum
operator|=
name|ppc
operator|->
name|ppc_accum
expr_stmt|;
for|for
control|(
init|;
name|accum
condition|;
name|accum
operator|--
control|)
name|w_reg
argument_list|(
name|reg
argument_list|,
name|ppc
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_accum
operator|=
name|accum
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|w_reg
argument_list|(
name|reg
argument_list|,
name|ppc
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_ptr
operator|=
name|ptr
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_RFETCH_P
case|:
name|reg
operator|=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
name|mask
operator|=
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|i
expr_stmt|;
name|ptr
operator|=
name|ppc
operator|->
name|ppc_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
operator|)
operator|==
name|MS_ACCUM
condition|)
block|{
name|accum
operator|=
name|ppc
operator|->
name|ppc_accum
expr_stmt|;
for|for
control|(
init|;
name|accum
condition|;
name|accum
operator|--
control|)
operator|*
name|ptr
operator|++
operator|=
name|r_reg
argument_list|(
name|reg
argument_list|,
name|ppc
argument_list|)
operator|&
name|mask
expr_stmt|;
name|ppc
operator|->
name|ppc_accum
operator|=
name|accum
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|*
name|ptr
operator|++
operator|=
name|r_reg
argument_list|(
name|reg
argument_list|,
name|ppc
argument_list|)
operator|&
name|mask
expr_stmt|;
name|ppc
operator|->
name|ppc_ptr
operator|=
name|ptr
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_RFETCH
case|:
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|mi
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|p
operator|)
operator|=
name|r_reg
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|,
name|ppc
argument_list|)
operator|&
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_RASSERT
case|:
case|case
name|MS_OP_DELAY
case|:
comment|/* let's suppose the next instr. is the same */
name|prefetch
label|:
for|for
control|(
init|;
name|mi
operator|->
name|opcode
operator|==
name|MS_OP_RASSERT
condition|;
name|INCR_PC
control|)
name|w_reg
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|,
name|ppc
argument_list|,
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|opcode
operator|==
name|MS_OP_DELAY
condition|)
block|{
name|DELAY
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
name|INCR_PC
expr_stmt|;
goto|goto
name|prefetch
goto|;
block|}
break|break;
case|case
name|MS_OP_ADELAY
case|:
if|if
condition|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
condition|)
name|pause
argument_list|(
literal|"ppbdelay"
argument_list|,
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
operator|*
operator|(
name|hz
operator|/
literal|1000
operator|)
argument_list|)
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_TRIG
case|:
name|reg
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
expr_stmt|;
name|iter
operator|=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|mi
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|p
expr_stmt|;
comment|/* XXX delay limited to 255 us */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iter
condition|;
name|i
operator|++
control|)
block|{
name|w_reg
argument_list|(
name|reg
argument_list|,
name|ppc
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_SET
case|:
name|ppc
operator|->
name|ppc_accum
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_DBRA
case|:
if|if
condition|(
operator|--
name|ppc
operator|->
name|ppc_accum
operator|>
literal|0
condition|)
name|mi
operator|+=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_BRSET
case|:
name|cc
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|&
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
operator|)
operator|==
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
condition|)
name|mi
operator|+=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_BRCLEAR
case|:
name|cc
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|&
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
operator|)
operator|==
literal|0
condition|)
name|mi
operator|+=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_BRSTAT
case|:
name|cc
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|&
operator|(
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
operator||
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
operator|)
operator|)
operator|==
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
condition|)
name|mi
operator|+=
name|mi
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|i
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_C_CALL
case|:
comment|/* 			 * If the C call returns !0 then end the microseq. 			 * The current state of ptr is passed to the C function 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|f
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|ppc
operator|->
name|ppc_ptr
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_PTR
case|:
name|ppc
operator|->
name|ppc_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|p
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_CALL
case|:
if|if
condition|(
name|stack
condition|)
name|panic
argument_list|(
literal|"%s: too much calls"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|p
condition|)
block|{
comment|/* store the state of the actual 				 * microsequence 				 */
name|stack
operator|=
name|mi
expr_stmt|;
comment|/* jump to the new microsequence */
name|mi
operator|=
operator|(
expr|struct
name|ppb_microseq
operator|*
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|p
expr_stmt|;
block|}
else|else
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_SUBRET
case|:
comment|/* retrieve microseq and pc state before the call */
name|mi
operator|=
name|stack
expr_stmt|;
comment|/* reset the stack */
name|stack
operator|=
literal|0
expr_stmt|;
comment|/* XXX return code */
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_PUT
case|:
case|case
name|MS_OP_GET
case|:
case|case
name|MS_OP_RET
case|:
comment|/* can't return to ppb level during the execution 			 * of a submicrosequence */
if|if
condition|(
name|stack
condition|)
name|panic
argument_list|(
literal|"%s: can't return to ppb level"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* update pc for ppb level of execution */
operator|*
name|p_msq
operator|=
name|mi
expr_stmt|;
comment|/* return to ppb level of execution */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"%s: unknown microsequence opcode 0x%x"
argument_list|,
name|__func__
argument_list|,
name|mi
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* unreached */
block|}
end_block

begin_function
specifier|static
name|void
name|ppcintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|arg
decl_stmt|;
name|u_char
name|ctr
decl_stmt|,
name|ecr
decl_stmt|,
name|str
decl_stmt|;
comment|/* 	 * If we have any child interrupt handlers registered, let 	 * them handle this interrupt. 	 * 	 * XXX: If DMA is in progress should we just complete that w/o 	 * doing this? 	 */
if|if
condition|(
name|ppc
operator|->
name|ppc_child_handlers
operator|>
literal|0
condition|)
block|{
name|intr_event_execute_handlers
argument_list|(
name|curproc
argument_list|,
name|ppc
operator|->
name|ppc_intr_event
argument_list|)
expr_stmt|;
return|return;
block|}
name|str
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
name|ctr
operator|=
name|r_ctr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
name|ecr
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PPC_DEBUG
argument_list|)
operator|&&
name|PPC_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"![%x/%x/%x]"
argument_list|,
name|ctr
argument_list|,
name|ecr
argument_list|,
name|str
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* don't use ecp mode with IRQENABLE set */
if|if
condition|(
name|ctr
operator|&
name|IRQENABLE
condition|)
block|{
return|return;
block|}
comment|/* interrupts are generated by nFault signal 	 * only in ECP mode */
if|if
condition|(
operator|(
name|str
operator|&
name|nFAULT
operator|)
operator|&&
operator|(
name|ppc
operator|->
name|ppc_mode
operator|&
name|PPB_ECP
operator|)
condition|)
block|{
comment|/* check if ppc driver has programmed the 		 * nFault interrupt */
if|if
condition|(
name|ppc
operator|->
name|ppc_irqstat
operator|&
name|PPC_IRQ_nFAULT
condition|)
block|{
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr
operator||
name|PPC_nFAULT_INTR
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_irqstat
operator|&=
operator|~
name|PPC_IRQ_nFAULT
expr_stmt|;
block|}
else|else
block|{
comment|/* shall be handled by underlying layers XXX */
return|return;
block|}
block|}
if|if
condition|(
name|ppc
operator|->
name|ppc_irqstat
operator|&
name|PPC_IRQ_DMA
condition|)
block|{
comment|/* disable interrupts (should be done by hardware though) */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr
operator||
name|PPC_SERVICE_INTR
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_irqstat
operator|&=
operator|~
name|PPC_IRQ_DMA
expr_stmt|;
name|ecr
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
comment|/* check if DMA completed */
if|if
condition|(
operator|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
operator|)
operator|&&
operator|(
name|ecr
operator|&
name|PPC_ENABLE_DMA
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PPC_DEBUG
name|printf
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* stop DMA */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr
operator|&
operator|~
name|PPC_ENABLE_DMA
argument_list|)
expr_stmt|;
name|ecr
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_dmastat
operator|==
name|PPC_DMA_STARTED
condition|)
block|{
ifdef|#
directive|ifdef
name|PPC_DEBUG
name|printf
argument_list|(
literal|"d"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ppc
operator|->
name|ppc_dmadone
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_dmastat
operator|=
name|PPC_DMA_COMPLETE
expr_stmt|;
comment|/* wakeup the waiting process */
name|wakeup
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ppc
operator|->
name|ppc_irqstat
operator|&
name|PPC_IRQ_FIFO
condition|)
block|{
comment|/* classic interrupt I/O */
name|ppc
operator|->
name|ppc_irqstat
operator|&=
operator|~
name|PPC_IRQ_FIFO
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|int
name|ppc_read
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ppc_write
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|how
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ppc_reset_epp
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|DEVTOSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ppc_reset_epp_timeout
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ppc_setmode
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|DEVTOSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ppc
operator|->
name|ppc_type
condition|)
block|{
case|case
name|PPC_TYPE_SMCLIKE
case|:
return|return
operator|(
name|ppc_smclike_setmode
argument_list|(
name|ppc
argument_list|,
name|mode
argument_list|)
operator|)
return|;
break|break;
case|case
name|PPC_TYPE_GENERIC
case|:
default|default:
return|return
operator|(
name|ppc_generic_setmode
argument_list|(
name|ppc
argument_list|,
name|mode
argument_list|)
operator|)
return|;
break|break;
block|}
comment|/* not reached */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ppc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|rid
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__i386__
specifier|static
name|short
name|next_bios_ppc
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|unsigned
name|int
name|pc98_ieee_mode
init|=
literal|0x00
decl_stmt|;
name|unsigned
name|int
name|tmp
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|struct
name|ppc_data
modifier|*
name|ppc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_long
name|port
decl_stmt|;
comment|/* 	 * Allocate the ppc_data structure. 	 */
name|ppc
operator|=
name|DEVTOSOFTC
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ppc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_data
argument_list|)
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|rid_ioport
operator|=
name|rid
expr_stmt|;
comment|/* retrieve ISA parameters */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|rid
argument_list|,
operator|&
name|port
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
comment|/* 	 * If port not specified, use bios list. 	 */
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|next_bios_ppc
operator|==
literal|0
condition|)
block|{
comment|/* Use default IEEE-1284 port of NEC PC-98x1 */
name|port
operator|=
name|PC98_IEEE_1284_PORT
expr_stmt|;
name|next_bios_ppc
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"parallel port found at 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|port
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|next_bios_ppc
operator|<
name|BIOS_MAX_PPC
operator|)
operator|&&
operator|(
operator|*
operator|(
name|BIOS_PORTS
operator|+
name|next_bios_ppc
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|port
operator|=
operator|*
operator|(
name|BIOS_PORTS
operator|+
name|next_bios_ppc
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"parallel port found at 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"parallel port not found.\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
endif|#
directive|endif
comment|/* PC98 */
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|rid
argument_list|,
name|port
argument_list|,
name|IO_LPTSIZE_EXTENDED
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IO port is mandatory */
comment|/* Try "extended" IO port range...*/
name|ppc
operator|->
name|res_ioport
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|ppc
operator|->
name|rid_ioport
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|IO_LPTSIZE_EXTENDED
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|res_ioport
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using extended I/O port range\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Failed? If so, then try the "normal" IO port range... */
name|ppc
operator|->
name|res_ioport
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|ppc
operator|->
name|rid_ioport
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|IO_LPTSIZE_NORMAL
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|res_ioport
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using normal I/O port range\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot reserve I/O port range\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|ppc
operator|->
name|ppc_base
operator|=
name|rman_get_start
argument_list|(
name|ppc
operator|->
name|res_ioport
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_flags
operator|=
name|device_get_flags
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ppc
operator|->
name|ppc_flags
operator|&
literal|0x20
operator|)
condition|)
block|{
name|ppc
operator|->
name|res_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|ppc
operator|->
name|rid_irq
argument_list|,
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|res_drq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
operator|&
name|ppc
operator|->
name|rid_drq
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ppc
operator|->
name|res_irq
condition|)
name|ppc
operator|->
name|ppc_irq
operator|=
name|rman_get_start
argument_list|(
name|ppc
operator|->
name|res_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|res_drq
condition|)
name|ppc
operator|->
name|ppc_dmachan
operator|=
name|rman_get_start
argument_list|(
name|ppc
operator|->
name|res_drq
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_model
operator|=
name|GENERIC
expr_stmt|;
name|ppc
operator|->
name|ppc_mode
operator|=
name|PPB_COMPATIBLE
expr_stmt|;
name|ppc
operator|->
name|ppc_epp
operator|=
operator|(
name|ppc
operator|->
name|ppc_flags
operator|&
literal|0x10
operator|)
operator|>>
literal|4
expr_stmt|;
name|ppc
operator|->
name|ppc_type
operator|=
name|PPC_TYPE_GENERIC
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
name|defined
argument_list|(
name|PC98
argument_list|)
comment|/* 	 * IEEE STD 1284 Function Check and Enable 	 * for default IEEE-1284 port of NEC PC-98x1 	 */
if|if
condition|(
name|ppc
operator|->
name|ppc_base
operator|==
name|PC98_IEEE_1284_PORT
operator|&&
operator|!
operator|(
name|ppc
operator|->
name|ppc_flags
operator|&
name|PC98_IEEE_1284_DISABLE
operator|)
condition|)
block|{
name|tmp
operator|=
name|inb
argument_list|(
name|ppc
operator|->
name|ppc_base
operator|+
name|PPC_1284_ENABLE
argument_list|)
expr_stmt|;
name|pc98_ieee_mode
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
literal|0x10
operator|)
operator|==
literal|0x10
condition|)
block|{
name|outb
argument_list|(
name|ppc
operator|->
name|ppc_base
operator|+
name|PPC_1284_ENABLE
argument_list|,
name|tmp
operator|&
operator|~
literal|0x10
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|inb
argument_list|(
name|ppc
operator|->
name|ppc_base
operator|+
name|PPC_1284_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
literal|0x10
operator|)
operator|==
literal|0x10
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
name|outb
argument_list|(
name|ppc
operator|->
name|ppc_base
operator|+
name|PPC_1284_ENABLE
argument_list|,
name|tmp
operator||
literal|0x10
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|inb
argument_list|(
name|ppc
operator|->
name|ppc_base
operator|+
name|PPC_1284_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
literal|0x10
operator|)
operator|!=
literal|0x10
condition|)
goto|goto
name|error
goto|;
block|}
name|outb
argument_list|(
name|ppc
operator|->
name|ppc_base
operator|+
name|PPC_1284_ENABLE
argument_list|,
name|pc98_ieee_mode
operator||
literal|0x10
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Try to detect the chipset and its mode. 	 */
if|if
condition|(
name|ppc_detect
argument_list|(
name|ppc
argument_list|,
name|ppc
operator|->
name|ppc_flags
operator|&
literal|0xf
argument_list|)
condition|)
goto|goto
name|error
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
name|defined
argument_list|(
name|PC98
argument_list|)
if|if
condition|(
name|ppc
operator|->
name|ppc_base
operator|==
name|PC98_IEEE_1284_PORT
operator|&&
operator|!
operator|(
name|ppc
operator|->
name|ppc_flags
operator|&
name|PC98_IEEE_1284_DISABLE
operator|)
condition|)
block|{
name|outb
argument_list|(
name|ppc
operator|->
name|ppc_base
operator|+
name|PPC_1284_ENABLE
argument_list|,
name|pc98_ieee_mode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ppc
operator|->
name|res_irq
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ppc
operator|->
name|rid_irq
argument_list|,
name|ppc
operator|->
name|res_irq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ppc
operator|->
name|res_ioport
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ppc
operator|->
name|rid_ioport
argument_list|,
name|ppc
operator|->
name|res_ioport
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ppc
operator|->
name|res_drq
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|ppc
operator|->
name|rid_drq
argument_list|,
name|ppc
operator|->
name|res_drq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ppc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|DEVTOSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
name|ppbus
decl_stmt|;
name|int
name|error
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s chipset (%s) in %s mode%s\n"
argument_list|,
name|ppc_models
index|[
name|ppc
operator|->
name|ppc_model
index|]
argument_list|,
name|ppc_avms
index|[
name|ppc
operator|->
name|ppc_avm
index|]
argument_list|,
name|ppc_modes
index|[
name|ppc
operator|->
name|ppc_mode
index|]
argument_list|,
operator|(
name|PPB_IS_EPP
argument_list|(
name|ppc
operator|->
name|ppc_mode
argument_list|)
operator|)
condition|?
name|ppc_epp_protocol
index|[
name|ppc
operator|->
name|ppc_epp
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_fifo
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"FIFO with %d/%d/%d bytes threshold\n"
argument_list|,
name|ppc
operator|->
name|ppc_fifo
argument_list|,
name|ppc
operator|->
name|ppc_wthr
argument_list|,
name|ppc
operator|->
name|ppc_rthr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|res_irq
condition|)
block|{
comment|/* 		 * Create an interrupt event to manage the handlers of 		 * child devices. 		 */
name|error
operator|=
name|intr_event_create
argument_list|(
operator|&
name|ppc
operator|->
name|ppc_intr_event
argument_list|,
name|ppc
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"%s:"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create interrupt event: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* default to the tty mask for registration */
comment|/* XXX */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|ppc
operator|->
name|res_irq
argument_list|,
name|INTR_TYPE_TTY
argument_list|,
name|NULL
argument_list|,
name|ppcintr
argument_list|,
name|ppc
argument_list|,
operator|&
name|ppc
operator|->
name|intr_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to register interrupt handler: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* add ppbus as a child of this isa to parallel bridge */
name|ppbus
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"ppbus"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Probe the ppbus and attach devices found. 	 */
name|device_probe_and_attach
argument_list|(
name|ppbus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ppc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|DEVTOSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
modifier|*
name|children
decl_stmt|;
name|int
name|nchildren
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|ppc
operator|->
name|res_irq
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* detach& delete all children */
if|if
condition|(
operator|!
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|children
argument_list|,
operator|&
name|nchildren
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchildren
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|children
index|[
name|i
index|]
condition|)
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|children
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|children
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ppc
operator|->
name|res_irq
operator|!=
literal|0
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|ppc
operator|->
name|res_irq
argument_list|,
name|ppc
operator|->
name|intr_cookie
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ppc
operator|->
name|rid_irq
argument_list|,
name|ppc
operator|->
name|res_irq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ppc
operator|->
name|res_ioport
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ppc
operator|->
name|rid_ioport
argument_list|,
name|ppc
operator|->
name|res_ioport
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ppc
operator|->
name|res_drq
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|ppc
operator|->
name|rid_drq
argument_list|,
name|ppc
operator|->
name|res_drq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|u_char
name|ppc_io
parameter_list|(
name|device_t
name|ppcdev
parameter_list|,
name|int
name|iop
parameter_list|,
name|u_char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|,
name|u_char
name|byte
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|DEVTOSOFTC
argument_list|(
name|ppcdev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|iop
condition|)
block|{
case|case
name|PPB_OUTSB_EPP
case|:
name|bus_write_multi_1
argument_list|(
name|ppc
operator|->
name|res_ioport
argument_list|,
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_OUTSW_EPP
case|:
name|bus_write_multi_2
argument_list|(
name|ppc
operator|->
name|res_ioport
argument_list|,
name|PPC_EPP_DATA
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_OUTSL_EPP
case|:
name|bus_write_multi_4
argument_list|(
name|ppc
operator|->
name|res_ioport
argument_list|,
name|PPC_EPP_DATA
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_INSB_EPP
case|:
name|bus_read_multi_1
argument_list|(
name|ppc
operator|->
name|res_ioport
argument_list|,
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_INSW_EPP
case|:
name|bus_read_multi_2
argument_list|(
name|ppc
operator|->
name|res_ioport
argument_list|,
name|PPC_EPP_DATA
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_INSL_EPP
case|:
name|bus_read_multi_4
argument_list|(
name|ppc
operator|->
name|res_ioport
argument_list|,
name|PPC_EPP_DATA
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_RDTR
case|:
return|return
operator|(
name|r_dtr
argument_list|(
name|ppc
argument_list|)
operator|)
return|;
case|case
name|PPB_RSTR
case|:
return|return
operator|(
name|r_str
argument_list|(
name|ppc
argument_list|)
operator|)
return|;
case|case
name|PPB_RCTR
case|:
return|return
operator|(
name|r_ctr
argument_list|(
name|ppc
argument_list|)
operator|)
return|;
case|case
name|PPB_REPP_A
case|:
return|return
operator|(
name|r_epp_A
argument_list|(
name|ppc
argument_list|)
operator|)
return|;
case|case
name|PPB_REPP_D
case|:
return|return
operator|(
name|r_epp_D
argument_list|(
name|ppc
argument_list|)
operator|)
return|;
case|case
name|PPB_RECR
case|:
return|return
operator|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|)
return|;
case|case
name|PPB_RFIFO
case|:
return|return
operator|(
name|r_fifo
argument_list|(
name|ppc
argument_list|)
operator|)
return|;
case|case
name|PPB_WDTR
case|:
name|w_dtr
argument_list|(
name|ppc
argument_list|,
name|byte
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_WSTR
case|:
name|w_str
argument_list|(
name|ppc
argument_list|,
name|byte
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_WCTR
case|:
name|w_ctr
argument_list|(
name|ppc
argument_list|,
name|byte
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_WEPP_A
case|:
name|w_epp_A
argument_list|(
name|ppc
argument_list|,
name|byte
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_WEPP_D
case|:
name|w_epp_D
argument_list|(
name|ppc
argument_list|,
name|byte
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_WECR
case|:
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|byte
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_WFIFO
case|:
name|w_fifo
argument_list|(
name|ppc
argument_list|,
name|byte
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unknown I/O operation"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not significative */
block|}
end_function

begin_function
name|int
name|ppc_read_ivar
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
operator|(
expr|struct
name|ppc_data
operator|*
operator|)
name|device_get_softc
argument_list|(
name|bus
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|PPC_IVAR_EPP_PROTO
case|:
operator|*
name|val
operator|=
operator|(
name|u_long
operator|)
name|ppc
operator|->
name|ppc_epp
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We allow child devices to allocate an IRQ resource at rid 0 for their  * interrupt handlers.  */
end_comment

begin_function
name|struct
name|resource
modifier|*
name|ppc_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|DEVTOSOFTC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IRQ
case|:
if|if
condition|(
operator|*
name|rid
operator|==
literal|0
condition|)
return|return
operator|(
name|ppc
operator|->
name|res_irq
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ppc_release_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|DEVTOSOFTC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IRQ
case|:
if|if
condition|(
name|rid
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|r
operator|==
name|ppc
operator|->
name|res_irq
argument_list|,
operator|(
literal|"ppc child IRQ resource mismatch"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If a child wants to add a handler for our IRQ, add it to our interrupt  * event.  Otherwise, fail the request.  */
end_comment

begin_function
name|int
name|ppc_setup_intr
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_filter_t
modifier|*
name|filt
parameter_list|,
name|void
function_decl|(
modifier|*
name|ihand
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|DEVTOSOFTC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|r
operator|!=
name|ppc
operator|->
name|res_irq
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* We don't allow filters. */
if|if
condition|(
name|filt
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|intr_event_add_handler
argument_list|(
name|ppc
operator|->
name|ppc_intr_event
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|ihand
argument_list|,
name|arg
argument_list|,
name|intr_priority
argument_list|(
name|flags
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ppc
operator|->
name|ppc_child_handlers
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ppc_teardown_intr
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|DEVTOSOFTC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|r
operator|!=
name|ppc
operator|->
name|res_irq
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|KASSERT
argument_list|(
name|intr_handler_source
argument_list|(
name|cookie
argument_list|)
operator|==
name|ppc
argument_list|,
operator|(
literal|"ppc_teardown_intr: source mismatch"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|intr_event_remove_handler
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ppc
operator|->
name|ppc_child_handlers
operator|--
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ppc
argument_list|,
name|ppbus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

