begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * BSD LICENSE  *  * Copyright (c) 2015-2017 Amazon.com, Inc. or its affiliates.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/rss_config.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_rss.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|"ena.h"
end_include

begin_include
include|#
directive|include
file|"ena_sysctl.h"
end_include

begin_comment
comment|/*********************************************************  *  Function prototypes  *********************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|ena_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_intr_msix_mgmnt
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_allocate_pci_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_pci_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_change_mtu
parameter_list|(
name|if_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ena_alloc_counters
parameter_list|(
name|counter_u64_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ena_free_counters
parameter_list|(
name|counter_u64_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ena_reset_counters
parameter_list|(
name|counter_u64_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_init_io_rings_common
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|struct
name|ena_ring
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_init_io_rings
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_io_ring_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_all_io_rings_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_setup_tx_dma_tag
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_free_tx_dma_tag
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_setup_rx_dma_tag
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_free_rx_dma_tag
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_setup_tx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_tx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_setup_all_tx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_all_tx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|validate_rx_req_id
parameter_list|(
name|struct
name|ena_ring
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_setup_rx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_rx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_setup_all_rx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_all_rx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|ena_alloc_rx_mbuf
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|struct
name|ena_ring
modifier|*
parameter_list|,
name|struct
name|ena_rx_buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_rx_mbuf
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|struct
name|ena_ring
modifier|*
parameter_list|,
name|struct
name|ena_rx_buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_refill_rx_bufs
parameter_list|(
name|struct
name|ena_ring
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_rx_bufs
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_refill_all_rx_bufs
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_all_rx_bufs
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_tx_bufs
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_all_tx_bufs
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_destroy_all_tx_queues
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_destroy_all_rx_queues
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_destroy_all_io_queues
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_create_io_queues
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_tx_cleanup
parameter_list|(
name|struct
name|ena_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_deferred_rx_cleanup
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_rx_cleanup
parameter_list|(
name|struct
name|ena_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|validate_tx_req_id
parameter_list|(
name|struct
name|ena_ring
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_rx_hash_mbuf
parameter_list|(
name|struct
name|ena_ring
modifier|*
parameter_list|,
name|struct
name|ena_com_rx_ctx
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|ena_rx_mbuf
parameter_list|(
name|struct
name|ena_ring
modifier|*
parameter_list|,
name|struct
name|ena_com_rx_buf_info
modifier|*
parameter_list|,
name|struct
name|ena_com_rx_ctx
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ena_rx_checksum
parameter_list|(
name|struct
name|ena_ring
modifier|*
parameter_list|,
name|struct
name|ena_com_rx_ctx
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_handle_msix
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_enable_msix
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_setup_mgmnt_intr
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_setup_io_intr
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_request_mgmnt_irq
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_request_io_irq
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_mgmnt_irq
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_io_irq
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_free_irqs
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_disable_msix
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_unmask_all_io_irqs
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_rss_configure
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_up_complete
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_up
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_down
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|ena_get_counter
parameter_list|(
name|if_t
parameter_list|,
name|ift_counter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_media_change
parameter_list|(
name|if_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_media_status
parameter_list|(
name|if_t
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_ioctl
parameter_list|(
name|if_t
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_get_dev_offloads
parameter_list|(
name|struct
name|ena_com_dev_get_features_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_update_host_info
parameter_list|(
name|struct
name|ena_admin_host_info
modifier|*
parameter_list|,
name|if_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_update_hwassist
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_setup_ifnet
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|struct
name|ena_com_dev_get_features_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_tx_csum
parameter_list|(
name|struct
name|ena_com_tx_ctx
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_check_and_collapse_mbuf
parameter_list|(
name|struct
name|ena_ring
modifier|*
name|tx_ring
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mbuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_xmit_mbuf
parameter_list|(
name|struct
name|ena_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_start_xmit
parameter_list|(
name|struct
name|ena_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_mq_start
parameter_list|(
name|if_t
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_deferred_mq_start
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_qflush
parameter_list|(
name|if_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_calc_io_queue_num
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|struct
name|ena_com_dev_get_features_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_calc_queue_size
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|,
name|struct
name|ena_com_dev_get_features_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_rss_init_default
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_rss_init_default_deferred
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_config_host_info
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_device_init
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|device_t
parameter_list|,
name|struct
name|ena_com_dev_get_features_ctx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ena_enable_msix_and_set_admin_interrupts
parameter_list|(
name|struct
name|ena_adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_update_on_link_change
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ena_admin_aenq_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unimplemented_aenq_handler
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ena_admin_aenq_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ena_timer_service
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|ena_version
index|[]
init|=
name|DEVICE_NAME
name|DRV_MODULE_NAME
literal|" v"
name|DRV_MODULE_VERSION
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ena
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"ENA driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Tuneable number of buffers in the buf-ring (drbr)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ena_buf_ring_size
init|=
literal|4096
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ena
argument_list|,
name|OID_AUTO
argument_list|,
name|buf_ring_size
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ena_buf_ring_size
argument_list|,
literal|0
argument_list|,
literal|"Size of the bufring"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|ena_vendor_info_t
name|ena_vendor_info_array
index|[]
init|=
block|{
block|{
name|PCI_VENDOR_ID_AMAZON
block|,
name|PCI_DEV_ID_ENA_PF
block|,
literal|0
block|}
block|,
block|{
name|PCI_VENDOR_ID_AMAZON
block|,
name|PCI_DEV_ID_ENA_LLQ_PF
block|,
literal|0
block|}
block|,
block|{
name|PCI_VENDOR_ID_AMAZON
block|,
name|PCI_DEV_ID_ENA_VF
block|,
literal|0
block|}
block|,
block|{
name|PCI_VENDOR_ID_AMAZON
block|,
name|PCI_DEV_ID_ENA_LLQ_VF
block|,
literal|0
block|}
block|,
comment|/* Last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Contains pointers to event handlers, e.g. link state chage.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ena_aenq_handlers
name|aenq_handlers
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ena_dmamap_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ena_dma_alloc
parameter_list|(
name|device_t
name|dmadev
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|ena_mem_handle_t
modifier|*
name|dma
parameter_list|,
name|int
name|mapflags
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dmadev
argument_list|)
decl_stmt|;
name|uint32_t
name|maxsize
decl_stmt|;
name|uint64_t
name|dma_space_addr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|maxsize
operator|=
operator|(
operator|(
name|size
operator|-
literal|1
operator|)
operator|/
name|PAGE_SIZE
operator|+
literal|1
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
name|dma_space_addr
operator|=
name|ENA_DMA_BIT_MASK
argument_list|(
name|adapter
operator|->
name|dma_width
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma_space_addr
operator|==
literal|0
condition|)
name|dma_space_addr
operator|=
name|BUS_SPACE_MAXADDR
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dmadev
argument_list|)
argument_list|,
comment|/* parent */
literal|8
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds 		*/
name|dma_space_addr
argument_list|,
comment|/* lowaddr of exclusion window	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr of exclusion window	*/
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg 		*/
name|maxsize
argument_list|,
comment|/* maxsize 			*/
literal|1
argument_list|,
comment|/* nsegments 			*/
name|maxsize
argument_list|,
comment|/* maxsegsize 			*/
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags 				*/
name|NULL
argument_list|,
comment|/* lockfunc 			*/
name|NULL
argument_list|,
comment|/* lockarg 			*/
operator|&
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dmadev
argument_list|,
literal|"%s: bus_dma_tag_create failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_tag
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|vaddr
argument_list|,
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dmadev
argument_list|,
literal|"%s: bus_dmamem_alloc(%ju) failed: %d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|size
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_map_create
goto|;
block|}
name|dma
operator|->
name|paddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|size
argument_list|,
name|ena_dmamap_callback
argument_list|,
operator|&
name|dma
operator|->
name|paddr
argument_list|,
name|mapflags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
literal|0
operator|)
operator|||
operator|(
name|dma
operator|->
name|paddr
operator|==
literal|0
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dmadev
argument_list|,
literal|"%s: bus_dmamap_load failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_map_load
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail_map_load
label|:
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|fail_map_create
label|:
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
name|fail_tag
label|:
name|dma
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_allocate_pci_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|pdev
init|=
name|adapter
operator|->
name|pdev
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
name|ENA_REG_BAR
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|memory
operator|=
name|NULL
expr_stmt|;
name|adapter
operator|->
name|registers
operator|=
name|bus_alloc_resource_any
argument_list|(
name|pdev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|registers
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"Unable to allocate bus resource: "
literal|"registers\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_free_pci_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|pdev
init|=
name|adapter
operator|->
name|pdev
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|memory
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|pdev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
name|ENA_MEM_BAR
argument_list|)
argument_list|,
name|adapter
operator|->
name|memory
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|registers
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|pdev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
name|ENA_REG_BAR
argument_list|)
argument_list|,
name|adapter
operator|->
name|registers
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ena_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ena_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|char
name|adapter_name
index|[
literal|60
index|]
decl_stmt|;
name|uint16_t
name|pci_vendor_id
init|=
literal|0
decl_stmt|;
name|uint16_t
name|pci_device_id
init|=
literal|0
decl_stmt|;
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|ena_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_DBG
argument_list|,
literal|"vendor=%x device=%x "
argument_list|,
name|pci_vendor_id
argument_list|,
name|pci_device_id
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|adapter_name
argument_list|,
name|DEVICE_DESC
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|adapter_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_change_mtu
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|int
name|new_mtu
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ena_com_dev_get_features_ctx
name|get_feat_ctx
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|old_mtu
decl_stmt|,
name|max_frame
decl_stmt|;
name|rc
operator|=
name|ena_com_get_dev_attr_feat
argument_list|(
name|adapter
operator|->
name|ena_dev
argument_list|,
operator|&
name|get_feat_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Cannot get attribute for ena device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Save old MTU in case of fail */
name|old_mtu
operator|=
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Change MTU and calculate max frame */
name|if_setmtu
argument_list|(
name|ifp
argument_list|,
name|new_mtu
argument_list|)
expr_stmt|;
name|max_frame
operator|=
name|ETHER_MAX_FRAME
argument_list|(
name|ifp
argument_list|,
name|ETHERTYPE_VLAN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_mtu
operator|<
name|ENA_MIN_FRAME_LEN
operator|)
operator|||
operator|(
name|new_mtu
operator|>
name|get_feat_ctx
operator|.
name|dev_attr
operator|.
name|max_mtu
operator|)
operator|||
operator|(
name|max_frame
operator|>
name|ENA_MAX_FRAME_LEN
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Invalid MTU setting. "
literal|"new_mtu: %d\n"
argument_list|,
name|new_mtu
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|rc
operator|=
name|ena_com_set_dev_mtu
argument_list|(
name|adapter
operator|->
name|ena_dev
argument_list|,
name|new_mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|if_setmtu
argument_list|(
name|ifp
argument_list|,
name|old_mtu
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ena_alloc_counters
parameter_list|(
name|counter_u64_t
modifier|*
name|begin
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|counter_u64_t
modifier|*
name|end
init|=
operator|(
name|counter_u64_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|begin
operator|+
name|size
operator|)
decl_stmt|;
for|for
control|(
init|;
name|begin
operator|<
name|end
condition|;
operator|++
name|begin
control|)
operator|*
name|begin
operator|=
name|counter_u64_alloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ena_free_counters
parameter_list|(
name|counter_u64_t
modifier|*
name|begin
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|counter_u64_t
modifier|*
name|end
init|=
operator|(
name|counter_u64_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|begin
operator|+
name|size
operator|)
decl_stmt|;
for|for
control|(
init|;
name|begin
operator|<
name|end
condition|;
operator|++
name|begin
control|)
name|counter_u64_free
argument_list|(
operator|*
name|begin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ena_reset_counters
parameter_list|(
name|counter_u64_t
modifier|*
name|begin
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|counter_u64_t
modifier|*
name|end
init|=
operator|(
name|counter_u64_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|begin
operator|+
name|size
operator|)
decl_stmt|;
for|for
control|(
init|;
name|begin
operator|<
name|end
condition|;
operator|++
name|begin
control|)
name|counter_u64_zero
argument_list|(
operator|*
name|begin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_init_io_rings_common
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|ena_ring
modifier|*
name|ring
parameter_list|,
name|uint16_t
name|qid
parameter_list|)
block|{
name|ring
operator|->
name|qid
operator|=
name|qid
expr_stmt|;
name|ring
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|ring
operator|->
name|ena_dev
operator|=
name|adapter
operator|->
name|ena_dev
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_init_io_rings
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
decl_stmt|;
name|struct
name|ena_ring
modifier|*
name|txr
decl_stmt|,
modifier|*
name|rxr
decl_stmt|;
name|struct
name|ena_que
modifier|*
name|que
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ena_dev
operator|=
name|adapter
operator|->
name|ena_dev
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_ring
index|[
name|i
index|]
expr_stmt|;
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_ring
index|[
name|i
index|]
expr_stmt|;
comment|/* TX/RX common ring state */
name|ena_init_io_rings_common
argument_list|(
name|adapter
argument_list|,
name|txr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ena_init_io_rings_common
argument_list|(
name|adapter
argument_list|,
name|rxr
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* TX specific ring state */
name|txr
operator|->
name|ring_size
operator|=
name|adapter
operator|->
name|tx_ring_size
expr_stmt|;
name|txr
operator|->
name|tx_max_header_size
operator|=
name|ena_dev
operator|->
name|tx_max_header_size
expr_stmt|;
name|txr
operator|->
name|tx_mem_queue_type
operator|=
name|ena_dev
operator|->
name|tx_mem_queue_type
expr_stmt|;
name|txr
operator|->
name|smoothed_interval
operator|=
name|ena_com_get_nonadaptive_moderation_interval_tx
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
comment|/* Allocate a buf ring */
name|txr
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
name|ena_buf_ring_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|txr
operator|->
name|ring_mtx
argument_list|)
expr_stmt|;
comment|/* Alloc TX statistics. */
name|ena_alloc_counters
argument_list|(
operator|(
name|counter_u64_t
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
operator|->
name|tx_stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* RX specific ring state */
name|rxr
operator|->
name|ring_size
operator|=
name|adapter
operator|->
name|rx_ring_size
expr_stmt|;
name|rxr
operator|->
name|rx_small_copy_len
operator|=
name|adapter
operator|->
name|small_copy_len
expr_stmt|;
name|rxr
operator|->
name|smoothed_interval
operator|=
name|ena_com_get_nonadaptive_moderation_interval_rx
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
comment|/* Alloc RX statistics. */
name|ena_alloc_counters
argument_list|(
operator|(
name|counter_u64_t
operator|*
operator|)
operator|&
name|rxr
operator|->
name|rx_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
operator|->
name|rx_stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize locks */
name|snprintf
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|,
name|nitems
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:tx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|,
name|nitems
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:rx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|txr
operator|->
name|ring_mtx
argument_list|,
name|txr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rxr
operator|->
name|ring_mtx
argument_list|,
name|rxr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|que
operator|=
operator|&
name|adapter
operator|->
name|que
index|[
name|i
index|]
expr_stmt|;
name|que
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|que
operator|->
name|id
operator|=
name|i
expr_stmt|;
name|que
operator|->
name|tx_ring
operator|=
name|txr
expr_stmt|;
name|que
operator|->
name|rx_ring
operator|=
name|rxr
expr_stmt|;
name|txr
operator|->
name|que
operator|=
name|que
expr_stmt|;
name|rxr
operator|->
name|que
operator|=
name|que
expr_stmt|;
name|rxr
operator|->
name|empty_rx_queue
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ena_free_io_ring_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|)
block|{
name|struct
name|ena_ring
modifier|*
name|txr
init|=
operator|&
name|adapter
operator|->
name|tx_ring
index|[
name|qid
index|]
decl_stmt|;
name|struct
name|ena_ring
modifier|*
name|rxr
init|=
operator|&
name|adapter
operator|->
name|rx_ring
index|[
name|qid
index|]
decl_stmt|;
name|ena_free_counters
argument_list|(
operator|(
name|counter_u64_t
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
operator|->
name|tx_stats
argument_list|)
argument_list|)
expr_stmt|;
name|ena_free_counters
argument_list|(
operator|(
name|counter_u64_t
operator|*
operator|)
operator|&
name|rxr
operator|->
name|rx_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
operator|->
name|rx_stats
argument_list|)
argument_list|)
expr_stmt|;
name|ENA_RING_MTX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|drbr_free
argument_list|(
name|txr
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ENA_RING_MTX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|txr
operator|->
name|ring_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|rxr
operator|->
name|ring_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_free_all_io_rings_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|ena_free_io_ring_resources
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_setup_tx_dma_tag
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* Create DMA tag for Tx buffers */
name|ret
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds 	     */
name|ENA_DMA_BIT_MASK
argument_list|(
name|adapter
operator|->
name|dma_width
argument_list|)
argument_list|,
comment|/* lowaddr of excl window  */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr of excl window */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg 	     */
name|ENA_TSO_MAXSIZE
argument_list|,
comment|/* maxsize 		     */
name|adapter
operator|->
name|max_tx_sgl_size
operator|-
literal|1
argument_list|,
comment|/* nsegments 		     */
name|ENA_TSO_MAXSIZE
argument_list|,
comment|/* maxsegsize 	     */
literal|0
argument_list|,
comment|/* flags 		     */
name|NULL
argument_list|,
comment|/* lockfunc 		     */
name|NULL
argument_list|,
comment|/* lockfuncarg 	     */
operator|&
name|adapter
operator|->
name|tx_buf_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Unable to create Tx DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_free_tx_dma_tag
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|bus_dma_tag_destroy
argument_list|(
name|adapter
operator|->
name|tx_buf_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|adapter
operator|->
name|tx_buf_tag
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_setup_rx_dma_tag
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* Create DMA tag for Rx buffers*/
name|ret
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|)
argument_list|,
comment|/* parent   */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds 	     */
name|ENA_DMA_BIT_MASK
argument_list|(
name|adapter
operator|->
name|dma_width
argument_list|)
argument_list|,
comment|/* lowaddr of excl window  */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr of excl window */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg 	     */
name|MJUM16BYTES
argument_list|,
comment|/* maxsize 		     */
literal|1
argument_list|,
comment|/* nsegments 		     */
name|MJUM16BYTES
argument_list|,
comment|/* maxsegsize 	     */
literal|0
argument_list|,
comment|/* flags 		     */
name|NULL
argument_list|,
comment|/* lockfunc 		     */
name|NULL
argument_list|,
comment|/* lockarg 		     */
operator|&
name|adapter
operator|->
name|rx_buf_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Unable to create Rx DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_free_rx_dma_tag
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|bus_dma_tag_destroy
argument_list|(
name|adapter
operator|->
name|rx_buf_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|adapter
operator|->
name|rx_buf_tag
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ena_setup_tx_resources - allocate Tx resources (Descriptors)  * @adapter: network interface device structure  * @qid: queue index  *  * Returns 0 on success, otherwise on failure.  **/
end_comment

begin_function
specifier|static
name|int
name|ena_setup_tx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|struct
name|ena_que
modifier|*
name|que
init|=
operator|&
name|adapter
operator|->
name|que
index|[
name|qid
index|]
decl_stmt|;
name|struct
name|ena_ring
modifier|*
name|tx_ring
init|=
name|que
operator|->
name|tx_ring
decl_stmt|;
name|int
name|size
decl_stmt|,
name|i
decl_stmt|,
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|cpuset_t
name|cpu_mask
decl_stmt|;
endif|#
directive|endif
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ena_tx_buffer
argument_list|)
operator|*
name|tx_ring
operator|->
name|ring_size
expr_stmt|;
name|tx_ring
operator|->
name|tx_buffer_info
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_ring
operator|->
name|tx_buffer_info
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|tx_ring
operator|->
name|ring_size
expr_stmt|;
name|tx_ring
operator|->
name|free_tx_ids
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_ring
operator|->
name|free_tx_ids
operator|==
name|NULL
condition|)
goto|goto
name|err_buf_info_free
goto|;
comment|/* Req id stack for TX OOO completions */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tx_ring
operator|->
name|ring_size
condition|;
name|i
operator|++
control|)
name|tx_ring
operator|->
name|free_tx_ids
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* Reset TX statistics. */
name|ena_reset_counters
argument_list|(
operator|(
name|counter_u64_t
operator|*
operator|)
operator|&
name|tx_ring
operator|->
name|tx_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_ring
operator|->
name|tx_stats
argument_list|)
argument_list|)
expr_stmt|;
name|tx_ring
operator|->
name|next_to_use
operator|=
literal|0
expr_stmt|;
name|tx_ring
operator|->
name|next_to_clean
operator|=
literal|0
expr_stmt|;
comment|/* Make sure that drbr is empty */
name|ENA_RING_MTX_LOCK
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
name|drbr_flush
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|)
expr_stmt|;
name|ENA_RING_MTX_UNLOCK
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
comment|/* ... and create the buffer DMA maps */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tx_ring
operator|->
name|ring_size
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|adapter
operator|->
name|tx_buf_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Unable to create Tx DMA map for buffer %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|err_buf_info_unmap
goto|;
block|}
block|}
comment|/* Allocate taskqueues */
name|TASK_INIT
argument_list|(
operator|&
name|tx_ring
operator|->
name|enqueue_task
argument_list|,
literal|0
argument_list|,
name|ena_deferred_mq_start
argument_list|,
name|tx_ring
argument_list|)
expr_stmt|;
name|tx_ring
operator|->
name|enqueue_tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ena_tx_enque"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|tx_ring
operator|->
name|enqueue_tq
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_ring
operator|->
name|enqueue_tq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Unable to create taskqueue for enqueue task\n"
argument_list|)
expr_stmt|;
name|i
operator|=
name|tx_ring
operator|->
name|ring_size
expr_stmt|;
goto|goto
name|err_buf_info_unmap
goto|;
block|}
comment|/* RSS set cpu for thread */
ifdef|#
directive|ifdef
name|RSS
name|CPU_SETOF
argument_list|(
name|que
operator|->
name|cpu
argument_list|,
operator|&
name|cpu_mask
argument_list|)
expr_stmt|;
name|taskqueue_start_threads_cpuset
argument_list|(
operator|&
name|tx_ring
operator|->
name|enqueue_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
operator|&
name|cpu_mask
argument_list|,
literal|"%s tx_ring enq (bucket %d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|)
argument_list|,
name|que
operator|->
name|cpu
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* RSS */
name|taskqueue_start_threads
argument_list|(
operator|&
name|tx_ring
operator|->
name|enqueue_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s txeq %d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|)
argument_list|,
name|que
operator|->
name|cpu
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSS */
return|return
operator|(
literal|0
operator|)
return|;
name|err_buf_info_unmap
label|:
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|adapter
operator|->
name|tx_buf_tag
argument_list|,
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tx_ring
operator|->
name|free_tx_ids
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|tx_ring
operator|->
name|free_tx_ids
operator|=
name|NULL
expr_stmt|;
name|err_buf_info_free
label|:
name|free
argument_list|(
name|tx_ring
operator|->
name|tx_buffer_info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|tx_ring
operator|->
name|tx_buffer_info
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ena_free_tx_resources - Free Tx Resources per Queue  * @adapter: network interface device structure  * @qid: queue index  *  * Free all transmit software resources  **/
end_comment

begin_function
specifier|static
name|void
name|ena_free_tx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|struct
name|ena_ring
modifier|*
name|tx_ring
init|=
operator|&
name|adapter
operator|->
name|tx_ring
index|[
name|qid
index|]
decl_stmt|;
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|tx_ring
operator|->
name|enqueue_tq
argument_list|,
operator|&
name|tx_ring
operator|->
name|enqueue_task
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain
argument_list|(
name|tx_ring
operator|->
name|enqueue_tq
argument_list|,
operator|&
name|tx_ring
operator|->
name|enqueue_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|tx_ring
operator|->
name|enqueue_tq
argument_list|)
expr_stmt|;
name|ENA_RING_MTX_LOCK
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
comment|/* Flush buffer ring, */
name|drbr_flush
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|)
expr_stmt|;
comment|/* Free buffer DMA maps, */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tx_ring
operator|->
name|ring_size
condition|;
name|i
operator|++
control|)
block|{
name|m_freem
argument_list|(
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|i
index|]
operator|.
name|mbuf
argument_list|)
expr_stmt|;
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|i
index|]
operator|.
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|adapter
operator|->
name|tx_buf_tag
argument_list|,
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|adapter
operator|->
name|tx_buf_tag
argument_list|,
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
block|}
name|ENA_RING_MTX_UNLOCK
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
comment|/* And free allocated memory. */
name|free
argument_list|(
name|tx_ring
operator|->
name|tx_buffer_info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|tx_ring
operator|->
name|tx_buffer_info
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|tx_ring
operator|->
name|free_tx_ids
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|tx_ring
operator|->
name|free_tx_ids
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ena_setup_all_tx_resources - allocate all queues Tx resources  * @adapter: network interface device structure  *  * Returns 0 on success, otherwise on failure.  **/
end_comment

begin_function
specifier|static
name|int
name|ena_setup_all_tx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|ena_setup_tx_resources
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Allocation for Tx Queue %u failed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|err_setup_tx
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err_setup_tx
label|:
comment|/* Rewind the index freeing the rings as we go */
while|while
condition|(
name|i
operator|--
condition|)
name|ena_free_tx_resources
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ena_free_all_tx_resources - Free Tx Resources for All Queues  * @adapter: network interface device structure  *  * Free all transmit software resources  **/
end_comment

begin_function
specifier|static
name|void
name|ena_free_all_tx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|ena_free_tx_resources
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|validate_rx_req_id
parameter_list|(
name|struct
name|ena_ring
modifier|*
name|rx_ring
parameter_list|,
name|uint16_t
name|req_id
parameter_list|)
block|{
if|if
condition|(
name|likely
argument_list|(
name|req_id
operator|<
name|rx_ring
operator|->
name|ring_size
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|device_printf
argument_list|(
name|rx_ring
operator|->
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Invalid rx req_id: %hu\n"
argument_list|,
name|req_id
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|rx_ring
operator|->
name|rx_stats
operator|.
name|bad_req_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Trigger device reset */
name|rx_ring
operator|->
name|adapter
operator|->
name|reset_reason
operator|=
name|ENA_REGS_RESET_INV_RX_REQ_ID
expr_stmt|;
name|rx_ring
operator|->
name|adapter
operator|->
name|trigger_reset
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ena_setup_rx_resources - allocate Rx resources (Descriptors)  * @adapter: network interface device structure  * @qid: queue index  *  * Returns 0 on success, otherwise on failure.  **/
end_comment

begin_function
specifier|static
name|int
name|ena_setup_rx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|)
block|{
name|struct
name|ena_que
modifier|*
name|que
init|=
operator|&
name|adapter
operator|->
name|que
index|[
name|qid
index|]
decl_stmt|;
name|struct
name|ena_ring
modifier|*
name|rx_ring
init|=
name|que
operator|->
name|rx_ring
decl_stmt|;
name|int
name|size
decl_stmt|,
name|err
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|cpuset_t
name|cpu_mask
decl_stmt|;
endif|#
directive|endif
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ena_rx_buffer
argument_list|)
operator|*
name|rx_ring
operator|->
name|ring_size
expr_stmt|;
comment|/* 	 * Alloc extra element so in rx path 	 * we can always prefetch rx_info + 1 	 */
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ena_rx_buffer
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|rx_buffer_info
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|rx_ring
operator|->
name|ring_size
expr_stmt|;
name|rx_ring
operator|->
name|free_rx_ids
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rx_ring
operator|->
name|ring_size
condition|;
name|i
operator|++
control|)
name|rx_ring
operator|->
name|free_rx_ids
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* Reset RX statistics. */
name|ena_reset_counters
argument_list|(
operator|(
name|counter_u64_t
operator|*
operator|)
operator|&
name|rx_ring
operator|->
name|rx_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_ring
operator|->
name|rx_stats
argument_list|)
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|next_to_clean
operator|=
literal|0
expr_stmt|;
name|rx_ring
operator|->
name|next_to_use
operator|=
literal|0
expr_stmt|;
comment|/* ... and create the buffer DMA maps */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rx_ring
operator|->
name|ring_size
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|adapter
operator|->
name|rx_buf_tag
argument_list|,
literal|0
argument_list|,
operator|&
operator|(
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|i
index|]
operator|.
name|map
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Unable to create Rx DMA map for buffer %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|err_buf_info_unmap
goto|;
block|}
block|}
comment|/* Create LRO for the ring */
if|if
condition|(
operator|(
name|adapter
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|err
init|=
name|tcp_lro_init
argument_list|(
operator|&
name|rx_ring
operator|->
name|lro
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"LRO[%d] Initialization failed!\n"
argument_list|,
name|qid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ena_trace
argument_list|(
name|ENA_INFO
argument_list|,
literal|"RX Soft LRO[%d] Initialized\n"
argument_list|,
name|qid
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|lro
operator|.
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
block|}
block|}
comment|/* Allocate taskqueues */
name|TASK_INIT
argument_list|(
operator|&
name|rx_ring
operator|->
name|cmpl_task
argument_list|,
literal|0
argument_list|,
name|ena_deferred_rx_cleanup
argument_list|,
name|rx_ring
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|cmpl_tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ena RX completion"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|rx_ring
operator|->
name|cmpl_tq
argument_list|)
expr_stmt|;
comment|/* RSS set cpu for thread */
ifdef|#
directive|ifdef
name|RSS
name|CPU_SETOF
argument_list|(
name|que
operator|->
name|cpu
argument_list|,
operator|&
name|cpu_mask
argument_list|)
expr_stmt|;
name|taskqueue_start_threads_cpuset
argument_list|(
operator|&
name|rx_ring
operator|->
name|cmpl_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
operator|&
name|cpu_mask
argument_list|,
literal|"%s rx_ring cmpl (bucket %d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|)
argument_list|,
name|que
operator|->
name|cpu
argument_list|)
expr_stmt|;
else|#
directive|else
name|taskqueue_start_threads
argument_list|(
operator|&
name|rx_ring
operator|->
name|cmpl_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s rx_ring cmpl %d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|)
argument_list|,
name|que
operator|->
name|cpu
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
name|err_buf_info_unmap
label|:
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|adapter
operator|->
name|rx_buf_tag
argument_list|,
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rx_ring
operator|->
name|free_rx_ids
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|free_rx_ids
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|rx_ring
operator|->
name|rx_buffer_info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|rx_buffer_info
operator|=
name|NULL
expr_stmt|;
name|ena_trace
argument_list|(
name|ENA_ALERT
argument_list|,
literal|"RX resource allocation fail"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ena_free_rx_resources - Free Rx Resources  * @adapter: network interface device structure  * @qid: queue index  *  * Free all receive software resources  **/
end_comment

begin_function
specifier|static
name|void
name|ena_free_rx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|)
block|{
name|struct
name|ena_ring
modifier|*
name|rx_ring
init|=
operator|&
name|adapter
operator|->
name|rx_ring
index|[
name|qid
index|]
decl_stmt|;
name|ena_trace
argument_list|(
name|ENA_INFO
argument_list|,
literal|"%s qid %d\n"
argument_list|,
name|__func__
argument_list|,
name|qid
argument_list|)
expr_stmt|;
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|rx_ring
operator|->
name|cmpl_tq
argument_list|,
operator|&
name|rx_ring
operator|->
name|cmpl_task
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|taskqueue_drain
argument_list|(
name|rx_ring
operator|->
name|cmpl_tq
argument_list|,
operator|&
name|rx_ring
operator|->
name|cmpl_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|rx_ring
operator|->
name|cmpl_tq
argument_list|)
expr_stmt|;
comment|/* Free buffer DMA maps, */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rx_ring
operator|->
name|ring_size
condition|;
name|i
operator|++
control|)
block|{
name|m_freem
argument_list|(
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|i
index|]
operator|.
name|mbuf
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|i
index|]
operator|.
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|adapter
operator|->
name|rx_buf_tag
argument_list|,
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|adapter
operator|->
name|rx_buf_tag
argument_list|,
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
block|}
comment|/* free LRO resources, */
name|tcp_lro_free
argument_list|(
operator|&
name|rx_ring
operator|->
name|lro
argument_list|)
expr_stmt|;
comment|/* free allocated memory */
name|free
argument_list|(
name|rx_ring
operator|->
name|rx_buffer_info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|rx_buffer_info
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|rx_ring
operator|->
name|free_rx_ids
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|free_rx_ids
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ena_setup_all_rx_resources - allocate all queues Rx resources  * @adapter: network interface device structure  *  * Returns 0 on success, otherwise on failure.  **/
end_comment

begin_function
specifier|static
name|int
name|ena_setup_all_rx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|ena_setup_rx_resources
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Allocation for Rx Queue %u failed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|err_setup_rx
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err_setup_rx
label|:
comment|/* rewind the index freeing the rings as we go */
while|while
condition|(
name|i
operator|--
condition|)
name|ena_free_rx_resources
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ena_free_all_rx_resources - Free Rx resources for all queues  * @adapter: network interface device structure  *  * Free all receive software resources  **/
end_comment

begin_function
specifier|static
name|void
name|ena_free_all_rx_resources
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|ena_free_rx_resources
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ena_alloc_rx_mbuf
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|ena_ring
modifier|*
name|rx_ring
parameter_list|,
name|struct
name|ena_rx_buffer
modifier|*
name|rx_info
parameter_list|)
block|{
name|struct
name|ena_com_buf
modifier|*
name|ena_buf
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|error
decl_stmt|;
comment|/* if previous allocated frag is not used */
if|if
condition|(
name|rx_info
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Get mbuf using UMA allocator */
name|rx_info
operator|->
name|mbuf
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUM16BYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_info
operator|->
name|mbuf
operator|==
name|NULL
condition|)
block|{
name|counter_u64_add
argument_list|(
name|rx_ring
operator|->
name|rx_stats
operator|.
name|mbuf_alloc_fail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Set mbuf length*/
name|rx_info
operator|->
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|rx_info
operator|->
name|mbuf
operator|->
name|m_len
operator|=
name|MJUM16BYTES
expr_stmt|;
comment|/* Map packets for DMA */
name|ena_trace
argument_list|(
name|ENA_DBG
operator||
name|ENA_RSC
operator||
name|ENA_RXPTH
argument_list|,
literal|"Using tag %p for buffers' DMA mapping, mbuf %p len: %d"
argument_list|,
name|adapter
operator|->
name|rx_buf_tag
argument_list|,
name|rx_info
operator|->
name|mbuf
argument_list|,
name|rx_info
operator|->
name|mbuf
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|adapter
operator|->
name|rx_buf_tag
argument_list|,
name|rx_info
operator|->
name|map
argument_list|,
name|rx_info
operator|->
name|mbuf
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
literal|0
operator|)
operator|||
operator|(
name|nsegs
operator|!=
literal|1
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"failed to map mbuf, error: %d, "
literal|"nsegs: %d\n"
argument_list|,
name|error
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|rx_ring
operator|->
name|rx_stats
operator|.
name|dma_mapping_err
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|adapter
operator|->
name|rx_buf_tag
argument_list|,
name|rx_info
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|ena_buf
operator|=
operator|&
name|rx_info
operator|->
name|ena_buf
expr_stmt|;
name|ena_buf
operator|->
name|paddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|ena_buf
operator|->
name|len
operator|=
name|MJUM16BYTES
expr_stmt|;
name|ena_trace
argument_list|(
name|ENA_DBG
operator||
name|ENA_RSC
operator||
name|ENA_RXPTH
argument_list|,
literal|"ALLOC RX BUF: mbuf %p, rx_info %p, len %d, paddr %#jx\n"
argument_list|,
name|rx_info
operator|->
name|mbuf
argument_list|,
name|rx_info
argument_list|,
name|ena_buf
operator|->
name|len
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ena_buf
operator|->
name|paddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|exit
label|:
name|m_freem
argument_list|(
name|rx_info
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|rx_info
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_free_rx_mbuf
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|ena_ring
modifier|*
name|rx_ring
parameter_list|,
name|struct
name|ena_rx_buffer
modifier|*
name|rx_info
parameter_list|)
block|{
if|if
condition|(
name|rx_info
operator|->
name|mbuf
operator|==
name|NULL
condition|)
return|return;
name|bus_dmamap_unload
argument_list|(
name|adapter
operator|->
name|rx_buf_tag
argument_list|,
name|rx_info
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rx_info
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|rx_info
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ena_refill_rx_bufs - Refills ring with descriptors  * @rx_ring: the ring which we want to feed with free descriptors  * @num: number of descriptors to refill  * Refills the ring with newly allocated DMA-mapped mbufs for receiving  **/
end_comment

begin_function
specifier|static
name|int
name|ena_refill_rx_bufs
parameter_list|(
name|struct
name|ena_ring
modifier|*
name|rx_ring
parameter_list|,
name|uint32_t
name|num
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
name|rx_ring
operator|->
name|adapter
decl_stmt|;
name|uint16_t
name|next_to_use
decl_stmt|,
name|req_id
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ena_trace
argument_list|(
name|ENA_DBG
operator||
name|ENA_RXPTH
operator||
name|ENA_RSC
argument_list|,
literal|"refill qid: %d"
argument_list|,
name|rx_ring
operator|->
name|qid
argument_list|)
expr_stmt|;
name|next_to_use
operator|=
name|rx_ring
operator|->
name|next_to_use
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ena_rx_buffer
modifier|*
name|rx_info
decl_stmt|;
name|ena_trace
argument_list|(
name|ENA_DBG
operator||
name|ENA_RXPTH
operator||
name|ENA_RSC
argument_list|,
literal|"RX buffer - next to use: %d"
argument_list|,
name|next_to_use
argument_list|)
expr_stmt|;
name|req_id
operator|=
name|rx_ring
operator|->
name|free_rx_ids
index|[
name|next_to_use
index|]
expr_stmt|;
name|rc
operator|=
name|validate_rx_req_id
argument_list|(
name|rx_ring
argument_list|,
name|req_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
break|break;
name|rx_info
operator|=
operator|&
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|req_id
index|]
expr_stmt|;
name|rc
operator|=
name|ena_alloc_rx_mbuf
argument_list|(
name|adapter
argument_list|,
name|rx_ring
argument_list|,
name|rx_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"failed to alloc buffer for rx queue\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|rc
operator|=
name|ena_com_add_single_rx_desc
argument_list|(
name|rx_ring
operator|->
name|ena_com_io_sq
argument_list|,
operator|&
name|rx_info
operator|->
name|ena_buf
argument_list|,
name|req_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"failed to add buffer for rx queue %d\n"
argument_list|,
name|rx_ring
operator|->
name|qid
argument_list|)
expr_stmt|;
break|break;
block|}
name|next_to_use
operator|=
name|ENA_RX_RING_IDX_NEXT
argument_list|(
name|next_to_use
argument_list|,
name|rx_ring
operator|->
name|ring_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|num
condition|)
block|{
name|counter_u64_add
argument_list|(
name|rx_ring
operator|->
name|rx_stats
operator|.
name|refil_partial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"refilled rx queue %d with %d pages only\n"
argument_list|,
name|rx_ring
operator|->
name|qid
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|wmb
argument_list|()
expr_stmt|;
name|ena_com_write_sq_doorbell
argument_list|(
name|rx_ring
operator|->
name|ena_com_io_sq
argument_list|)
expr_stmt|;
block|}
name|rx_ring
operator|->
name|next_to_use
operator|=
name|next_to_use
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_free_rx_bufs
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|)
block|{
name|struct
name|ena_ring
modifier|*
name|rx_ring
init|=
operator|&
name|adapter
operator|->
name|rx_ring
index|[
name|qid
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rx_ring
operator|->
name|ring_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ena_rx_buffer
modifier|*
name|rx_info
init|=
operator|&
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|rx_info
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
name|ena_free_rx_mbuf
argument_list|(
name|adapter
argument_list|,
name|rx_ring
argument_list|,
name|rx_info
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * ena_refill_all_rx_bufs - allocate all queues Rx buffers  * @adapter: network interface device structure  *  */
end_comment

begin_function
specifier|static
name|void
name|ena_refill_all_rx_bufs
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ena_ring
modifier|*
name|rx_ring
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|,
name|bufs_num
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rx_ring
operator|=
operator|&
name|adapter
operator|->
name|rx_ring
index|[
name|i
index|]
expr_stmt|;
name|bufs_num
operator|=
name|rx_ring
operator|->
name|ring_size
operator|-
literal|1
expr_stmt|;
name|rc
operator|=
name|ena_refill_rx_bufs
argument_list|(
name|rx_ring
argument_list|,
name|bufs_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
operator|!=
name|bufs_num
argument_list|)
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"refilling Queue %d failed. allocated %d buffers"
literal|" from: %d\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|,
name|bufs_num
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ena_free_all_rx_bufs
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|ena_free_rx_bufs
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ena_free_tx_bufs - Free Tx Buffers per Queue  * @adapter: network interface device structure  * @qid: queue index  **/
end_comment

begin_function
specifier|static
name|void
name|ena_free_tx_bufs
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|)
block|{
name|struct
name|ena_ring
modifier|*
name|tx_ring
init|=
operator|&
name|adapter
operator|->
name|tx_ring
index|[
name|qid
index|]
decl_stmt|;
name|ENA_RING_MTX_LOCK
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tx_ring
operator|->
name|ring_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ena_tx_buffer
modifier|*
name|tx_info
init|=
operator|&
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|tx_info
operator|->
name|mbuf
operator|==
name|NULL
condition|)
continue|continue;
name|ena_trace
argument_list|(
name|ENA_DBG
operator||
name|ENA_TXPTH
operator||
name|ENA_RSC
argument_list|,
literal|"free uncompleted Tx mbufs qid[%d] idx: 0x%x"
argument_list|,
name|qid
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|adapter
operator|->
name|tx_buf_tag
argument_list|,
name|tx_info
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|tx_info
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|tx_info
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|ENA_RING_MTX_UNLOCK
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_free_all_tx_bufs
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|ena_free_tx_bufs
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_destroy_all_tx_queues
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|uint16_t
name|ena_qid
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|ena_qid
operator|=
name|ENA_IO_TXQ_IDX
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ena_com_destroy_io_queue
argument_list|(
name|adapter
operator|->
name|ena_dev
argument_list|,
name|ena_qid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ena_destroy_all_rx_queues
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|uint16_t
name|ena_qid
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|ena_qid
operator|=
name|ENA_IO_RXQ_IDX
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ena_com_destroy_io_queue
argument_list|(
name|adapter
operator|->
name|ena_dev
argument_list|,
name|ena_qid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ena_destroy_all_io_queues
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|ena_destroy_all_tx_queues
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_destroy_all_rx_queues
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|validate_tx_req_id
parameter_list|(
name|struct
name|ena_ring
modifier|*
name|tx_ring
parameter_list|,
name|uint16_t
name|req_id
parameter_list|)
block|{
name|struct
name|ena_tx_buffer
modifier|*
name|tx_info
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|req_id
operator|<
name|tx_ring
operator|->
name|ring_size
argument_list|)
condition|)
block|{
name|tx_info
operator|=
operator|&
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|req_id
index|]
expr_stmt|;
if|if
condition|(
name|tx_info
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|counter_u64_add
argument_list|(
name|tx_ring
operator|->
name|tx_stats
operator|.
name|bad_req_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_create_io_queues
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
init|=
name|adapter
operator|->
name|ena_dev
decl_stmt|;
name|struct
name|ena_com_create_io_ctx
name|ctx
decl_stmt|;
name|struct
name|ena_ring
modifier|*
name|ring
decl_stmt|;
name|uint16_t
name|ena_qid
decl_stmt|;
name|uint32_t
name|msix_vector
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
comment|/* Create TX queues */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|msix_vector
operator|=
name|ENA_IO_IRQ_IDX
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ena_qid
operator|=
name|ENA_IO_TXQ_IDX
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|mem_queue_type
operator|=
name|ena_dev
operator|->
name|tx_mem_queue_type
expr_stmt|;
name|ctx
operator|.
name|direction
operator|=
name|ENA_COM_IO_QUEUE_DIRECTION_TX
expr_stmt|;
name|ctx
operator|.
name|queue_size
operator|=
name|adapter
operator|->
name|tx_ring_size
expr_stmt|;
name|ctx
operator|.
name|msix_vector
operator|=
name|msix_vector
expr_stmt|;
name|ctx
operator|.
name|qid
operator|=
name|ena_qid
expr_stmt|;
name|rc
operator|=
name|ena_com_create_io_queue
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Failed to create io TX queue #%d rc: %d\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|err_tx
goto|;
block|}
name|ring
operator|=
operator|&
name|adapter
operator|->
name|tx_ring
index|[
name|i
index|]
expr_stmt|;
name|rc
operator|=
name|ena_com_get_io_handlers
argument_list|(
name|ena_dev
argument_list|,
name|ena_qid
argument_list|,
operator|&
name|ring
operator|->
name|ena_com_io_sq
argument_list|,
operator|&
name|ring
operator|->
name|ena_com_io_cq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Failed to get TX queue handlers. TX queue num"
literal|" %d rc: %d\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|ena_com_destroy_io_queue
argument_list|(
name|ena_dev
argument_list|,
name|ena_qid
argument_list|)
expr_stmt|;
goto|goto
name|err_tx
goto|;
block|}
block|}
comment|/* Create RX queues */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|msix_vector
operator|=
name|ENA_IO_IRQ_IDX
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ena_qid
operator|=
name|ENA_IO_RXQ_IDX
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|mem_queue_type
operator|=
name|ENA_ADMIN_PLACEMENT_POLICY_HOST
expr_stmt|;
name|ctx
operator|.
name|direction
operator|=
name|ENA_COM_IO_QUEUE_DIRECTION_RX
expr_stmt|;
name|ctx
operator|.
name|queue_size
operator|=
name|adapter
operator|->
name|rx_ring_size
expr_stmt|;
name|ctx
operator|.
name|msix_vector
operator|=
name|msix_vector
expr_stmt|;
name|ctx
operator|.
name|qid
operator|=
name|ena_qid
expr_stmt|;
name|rc
operator|=
name|ena_com_create_io_queue
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Failed to create io RX queue[%d] rc: %d\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|err_rx
goto|;
block|}
name|ring
operator|=
operator|&
name|adapter
operator|->
name|rx_ring
index|[
name|i
index|]
expr_stmt|;
name|rc
operator|=
name|ena_com_get_io_handlers
argument_list|(
name|ena_dev
argument_list|,
name|ena_qid
argument_list|,
operator|&
name|ring
operator|->
name|ena_com_io_sq
argument_list|,
operator|&
name|ring
operator|->
name|ena_com_io_cq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Failed to get RX queue handlers. RX queue num"
literal|" %d rc: %d\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|ena_com_destroy_io_queue
argument_list|(
name|ena_dev
argument_list|,
name|ena_qid
argument_list|)
expr_stmt|;
goto|goto
name|err_rx
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err_rx
label|:
while|while
condition|(
name|i
operator|--
condition|)
name|ena_com_destroy_io_queue
argument_list|(
name|ena_dev
argument_list|,
name|ENA_IO_RXQ_IDX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|adapter
operator|->
name|num_queues
expr_stmt|;
name|err_tx
label|:
while|while
condition|(
name|i
operator|--
condition|)
name|ena_com_destroy_io_queue
argument_list|(
name|ena_dev
argument_list|,
name|ENA_IO_TXQ_IDX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ena_tx_cleanup - clear sent packets and corresponding descriptors  * @tx_ring: ring for which we want to clean packets  *  * Once packets are sent, we ask the device in a loop for no longer used  * descriptors. We find the related mbuf chain in a map (index in an array)  * and free it, then update ring state.  * This is performed in "endless" loop, updating ring pointers every  * TX_COMMIT. The first check of free descriptor is performed before the actual  * loop, then repeated at the loop end.  **/
end_comment

begin_function
specifier|static
name|int
name|ena_tx_cleanup
parameter_list|(
name|struct
name|ena_ring
modifier|*
name|tx_ring
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|ena_com_io_cq
modifier|*
name|io_cq
decl_stmt|;
name|uint16_t
name|next_to_clean
decl_stmt|;
name|uint16_t
name|req_id
decl_stmt|;
name|uint16_t
name|ena_qid
decl_stmt|;
name|unsigned
name|int
name|total_done
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|commit
init|=
name|TX_COMMIT
decl_stmt|;
name|int
name|budget
init|=
name|TX_BUDGET
decl_stmt|;
name|int
name|work_done
decl_stmt|;
name|adapter
operator|=
name|tx_ring
operator|->
name|que
operator|->
name|adapter
expr_stmt|;
name|ena_qid
operator|=
name|ENA_IO_TXQ_IDX
argument_list|(
name|tx_ring
operator|->
name|que
operator|->
name|id
argument_list|)
expr_stmt|;
name|io_cq
operator|=
operator|&
name|adapter
operator|->
name|ena_dev
operator|->
name|io_cq_queues
index|[
name|ena_qid
index|]
expr_stmt|;
name|next_to_clean
operator|=
name|tx_ring
operator|->
name|next_to_clean
expr_stmt|;
do|do
block|{
name|struct
name|ena_tx_buffer
modifier|*
name|tx_info
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|rc
operator|=
name|ena_com_tx_comp_req_id_get
argument_list|(
name|io_cq
argument_list|,
operator|&
name|req_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
break|break;
name|rc
operator|=
name|validate_tx_req_id
argument_list|(
name|tx_ring
argument_list|,
name|req_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
break|break;
name|tx_info
operator|=
operator|&
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|req_id
index|]
expr_stmt|;
name|mbuf
operator|=
name|tx_info
operator|->
name|mbuf
expr_stmt|;
name|tx_info
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|bintime_clear
argument_list|(
operator|&
name|tx_info
operator|->
name|timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_info
operator|->
name|num_of_bufs
operator|!=
literal|0
condition|)
block|{
comment|/* Map is no longer required */
name|bus_dmamap_unload
argument_list|(
name|adapter
operator|->
name|tx_buf_tag
argument_list|,
name|tx_info
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|total_done
operator|+=
name|tx_info
operator|->
name|tx_descs
expr_stmt|;
name|tx_ring
operator|->
name|free_tx_ids
index|[
name|next_to_clean
index|]
operator|=
name|req_id
expr_stmt|;
name|next_to_clean
operator|=
name|ENA_TX_RING_IDX_NEXT
argument_list|(
name|next_to_clean
argument_list|,
name|tx_ring
operator|->
name|ring_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|commit
operator|==
literal|0
condition|)
block|{
name|commit
operator|=
name|TX_COMMIT
expr_stmt|;
comment|/* update ring state every TX_COMMIT descriptor */
name|tx_ring
operator|->
name|next_to_clean
operator|=
name|next_to_clean
expr_stmt|;
name|ena_com_comp_ack
argument_list|(
operator|&
name|adapter
operator|->
name|ena_dev
operator|->
name|io_sq_queues
index|[
name|ena_qid
index|]
argument_list|,
name|total_done
argument_list|)
expr_stmt|;
name|ena_com_update_dev_comp_head
argument_list|(
name|io_cq
argument_list|)
expr_stmt|;
name|total_done
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|budget
condition|)
do|;
name|work_done
operator|=
name|TX_BUDGET
operator|-
name|budget
expr_stmt|;
comment|/* If there is still something to commit update ring state */
if|if
condition|(
name|commit
operator|!=
name|TX_COMMIT
condition|)
block|{
name|tx_ring
operator|->
name|next_to_clean
operator|=
name|next_to_clean
expr_stmt|;
name|ena_com_comp_ack
argument_list|(
operator|&
name|adapter
operator|->
name|ena_dev
operator|->
name|io_sq_queues
index|[
name|ena_qid
index|]
argument_list|,
name|total_done
argument_list|)
expr_stmt|;
name|ena_com_update_dev_comp_head
argument_list|(
name|io_cq
argument_list|)
expr_stmt|;
block|}
name|taskqueue_enqueue
argument_list|(
name|tx_ring
operator|->
name|enqueue_tq
argument_list|,
operator|&
name|tx_ring
operator|->
name|enqueue_task
argument_list|)
expr_stmt|;
return|return
operator|(
name|work_done
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_rx_hash_mbuf
parameter_list|(
name|struct
name|ena_ring
modifier|*
name|rx_ring
parameter_list|,
name|struct
name|ena_com_rx_ctx
modifier|*
name|ena_rx_ctx
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
name|rx_ring
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|rss_support
condition|)
block|{
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|ena_rx_ctx
operator|->
name|hash
expr_stmt|;
if|if
condition|(
name|ena_rx_ctx
operator|->
name|frag
operator|&&
operator|(
name|ena_rx_ctx
operator|->
name|l3_proto
operator|!=
name|ENA_ETH_IO_L4_PROTO_UNKNOWN
operator|)
condition|)
block|{
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_OPAQUE_HASH
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ena_rx_ctx
operator|->
name|l3_proto
condition|)
block|{
case|case
name|ENA_ETH_IO_L3_PROTO_IPV4
case|:
switch|switch
condition|(
name|ena_rx_ctx
operator|->
name|l4_proto
condition|)
block|{
case|case
name|ENA_ETH_IO_L4_PROTO_TCP
case|:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_RSS_TCP_IPV4
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENA_ETH_IO_L4_PROTO_UDP
case|:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_RSS_UDP_IPV4
argument_list|)
expr_stmt|;
break|break;
default|default:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_RSS_IPV4
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENA_ETH_IO_L3_PROTO_IPV6
case|:
switch|switch
condition|(
name|ena_rx_ctx
operator|->
name|l4_proto
condition|)
block|{
case|case
name|ENA_ETH_IO_L4_PROTO_TCP
case|:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_RSS_TCP_IPV6
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENA_ETH_IO_L4_PROTO_UDP
case|:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_RSS_UDP_IPV6
argument_list|)
expr_stmt|;
break|break;
default|default:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_RSS_IPV6
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENA_ETH_IO_L3_PROTO_UNKNOWN
case|:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_NONE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_OPAQUE_HASH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|rx_ring
operator|->
name|qid
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_NONE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * ena_rx_mbuf - assemble mbuf from descriptors  * @rx_ring: ring for which we want to clean packets  * @ena_bufs: buffer info  * @ena_rx_ctx: metadata for this packet(s)  * @next_to_clean: ring pointer, will be updated only upon success  *  **/
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ena_rx_mbuf
parameter_list|(
name|struct
name|ena_ring
modifier|*
name|rx_ring
parameter_list|,
name|struct
name|ena_com_rx_buf_info
modifier|*
name|ena_bufs
parameter_list|,
name|struct
name|ena_com_rx_ctx
modifier|*
name|ena_rx_ctx
parameter_list|,
name|uint16_t
modifier|*
name|next_to_clean
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|ena_rx_buffer
modifier|*
name|rx_info
decl_stmt|;
name|struct
name|ena_adapter
modifier|*
name|adapter
decl_stmt|;
name|unsigned
name|int
name|descs
init|=
name|ena_rx_ctx
operator|->
name|descs
decl_stmt|;
name|uint16_t
name|ntc
decl_stmt|,
name|len
decl_stmt|,
name|req_id
decl_stmt|,
name|buf
init|=
literal|0
decl_stmt|;
name|ntc
operator|=
operator|*
name|next_to_clean
expr_stmt|;
name|adapter
operator|=
name|rx_ring
operator|->
name|adapter
expr_stmt|;
name|rx_info
operator|=
operator|&
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|ntc
index|]
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rx_info
operator|->
name|mbuf
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"NULL mbuf in rx_info"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|len
operator|=
name|ena_bufs
index|[
name|buf
index|]
operator|.
name|len
expr_stmt|;
name|req_id
operator|=
name|ena_bufs
index|[
name|buf
index|]
operator|.
name|req_id
expr_stmt|;
name|rx_info
operator|=
operator|&
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|req_id
index|]
expr_stmt|;
name|ena_trace
argument_list|(
name|ENA_DBG
operator||
name|ENA_RXPTH
argument_list|,
literal|"rx_info %p, mbuf %p, paddr %jx"
argument_list|,
name|rx_info
argument_list|,
name|rx_info
operator|->
name|mbuf
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rx_info
operator|->
name|ena_buf
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|rx_info
operator|->
name|mbuf
expr_stmt|;
name|mbuf
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|mbuf
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|rx_ring
operator|->
name|que
operator|->
name|adapter
operator|->
name|ifp
expr_stmt|;
comment|/* Fill mbuf with hash key and it's interpretation for optimization */
name|ena_rx_hash_mbuf
argument_list|(
name|rx_ring
argument_list|,
name|ena_rx_ctx
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
name|ena_trace
argument_list|(
name|ENA_DBG
operator||
name|ENA_RXPTH
argument_list|,
literal|"rx mbuf 0x%p, flags=0x%x, len: %d"
argument_list|,
name|mbuf
argument_list|,
name|mbuf
operator|->
name|m_flags
argument_list|,
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* DMA address is not needed anymore, unmap it */
name|bus_dmamap_unload
argument_list|(
name|rx_ring
operator|->
name|adapter
operator|->
name|rx_buf_tag
argument_list|,
name|rx_info
operator|->
name|map
argument_list|)
expr_stmt|;
name|rx_info
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|rx_ring
operator|->
name|free_rx_ids
index|[
name|ntc
index|]
operator|=
name|req_id
expr_stmt|;
name|ntc
operator|=
name|ENA_RX_RING_IDX_NEXT
argument_list|(
name|ntc
argument_list|,
name|rx_ring
operator|->
name|ring_size
argument_list|)
expr_stmt|;
comment|/* 	 * While we have more than 1 descriptors for one rcvd packet, append 	 * other mbufs to the main one 	 */
while|while
condition|(
operator|--
name|descs
condition|)
block|{
operator|++
name|buf
expr_stmt|;
name|len
operator|=
name|ena_bufs
index|[
name|buf
index|]
operator|.
name|len
expr_stmt|;
name|req_id
operator|=
name|ena_bufs
index|[
name|buf
index|]
operator|.
name|req_id
expr_stmt|;
name|rx_info
operator|=
operator|&
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|req_id
index|]
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rx_info
operator|->
name|mbuf
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"NULL mbuf in rx_info"
argument_list|)
expr_stmt|;
comment|/* 			 * If one of the required mbufs was not allocated yet, 			 * we can break there. 			 * All earlier used descriptors will be reallocated 			 * later and not used mbufs can be reused. 			 * The next_to_clean pointer will not be updated in case 			 * of an error, so caller should advance it manually 			 * in error handling routine to keep it up to date 			 * with hw ring. 			 */
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|m_append
argument_list|(
name|mbuf
argument_list|,
name|len
argument_list|,
name|rx_info
operator|->
name|mbuf
operator|->
name|m_data
argument_list|)
operator|==
literal|0
condition|)
block|{
name|counter_u64_add
argument_list|(
name|rx_ring
operator|->
name|rx_stats
operator|.
name|mbuf_alloc_fail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ena_trace
argument_list|(
name|ENA_WARNING
argument_list|,
literal|"Failed to append Rx mbuf %p"
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
comment|/* Free already appended mbuf, it won't be useful anymore */
name|bus_dmamap_unload
argument_list|(
name|rx_ring
operator|->
name|adapter
operator|->
name|rx_buf_tag
argument_list|,
name|rx_info
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rx_info
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|rx_info
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|rx_ring
operator|->
name|free_rx_ids
index|[
name|ntc
index|]
operator|=
name|req_id
expr_stmt|;
name|ntc
operator|=
name|ENA_RX_RING_IDX_NEXT
argument_list|(
name|ntc
argument_list|,
name|rx_ring
operator|->
name|ring_size
argument_list|)
expr_stmt|;
block|}
operator|*
name|next_to_clean
operator|=
name|ntc
expr_stmt|;
return|return
operator|(
name|mbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ena_rx_checksum - indicate in mbuf if hw indicated a good cksum  **/
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ena_rx_checksum
parameter_list|(
name|struct
name|ena_ring
modifier|*
name|rx_ring
parameter_list|,
name|struct
name|ena_com_rx_ctx
modifier|*
name|ena_rx_ctx
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|)
block|{
comment|/* if IP and error */
if|if
condition|(
operator|(
name|ena_rx_ctx
operator|->
name|l3_proto
operator|==
name|ENA_ETH_IO_L3_PROTO_IPV4
operator|)
operator|&&
name|ena_rx_ctx
operator|->
name|l3_csum_err
condition|)
block|{
comment|/* ipv4 checksum error */
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
name|counter_u64_add
argument_list|(
name|rx_ring
operator|->
name|rx_stats
operator|.
name|bad_csum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if TCP/UDP */
if|if
condition|(
operator|(
name|ena_rx_ctx
operator|->
name|l4_proto
operator|==
name|ENA_ETH_IO_L4_PROTO_TCP
operator|)
operator|||
operator|(
name|ena_rx_ctx
operator|->
name|l4_proto
operator|==
name|ENA_ETH_IO_L4_PROTO_UDP
operator|)
condition|)
block|{
if|if
condition|(
name|ena_rx_ctx
operator|->
name|l4_csum_err
condition|)
block|{
comment|/* TCP/UDP checksum error */
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
name|counter_u64_add
argument_list|(
name|rx_ring
operator|->
name|rx_stats
operator|.
name|bad_csum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
expr_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ena_deferred_rx_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ena_ring
modifier|*
name|rx_ring
init|=
name|arg
decl_stmt|;
name|int
name|budget
init|=
name|CLEAN_BUDGET
decl_stmt|;
name|ENA_RING_MTX_LOCK
argument_list|(
name|rx_ring
argument_list|)
expr_stmt|;
comment|/* 	 * If deferred task was executed, perform cleanup of all awaiting 	 * descs (or until given budget is depleted to avoid infinite loop). 	 */
while|while
condition|(
name|budget
operator|--
condition|)
block|{
if|if
condition|(
name|ena_rx_cleanup
argument_list|(
name|rx_ring
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|ENA_RING_MTX_UNLOCK
argument_list|(
name|rx_ring
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ena_rx_cleanup - handle rx irq  * @arg: ring for which irq is being handled  **/
end_comment

begin_function
specifier|static
name|int
name|ena_rx_cleanup
parameter_list|(
name|struct
name|ena_ring
modifier|*
name|rx_ring
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|ena_com_rx_ctx
name|ena_rx_ctx
decl_stmt|;
name|struct
name|ena_com_io_cq
modifier|*
name|io_cq
decl_stmt|;
name|struct
name|ena_com_io_sq
modifier|*
name|io_sq
decl_stmt|;
name|if_t
name|ifp
decl_stmt|;
name|uint16_t
name|ena_qid
decl_stmt|;
name|uint16_t
name|next_to_clean
decl_stmt|;
name|uint32_t
name|refill_required
decl_stmt|;
name|uint32_t
name|refill_threshold
decl_stmt|;
name|uint32_t
name|do_if_input
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|qid
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|int
name|budget
init|=
name|RX_BUDGET
decl_stmt|;
name|adapter
operator|=
name|rx_ring
operator|->
name|que
operator|->
name|adapter
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|qid
operator|=
name|rx_ring
operator|->
name|que
operator|->
name|id
expr_stmt|;
name|ena_qid
operator|=
name|ENA_IO_RXQ_IDX
argument_list|(
name|qid
argument_list|)
expr_stmt|;
name|io_cq
operator|=
operator|&
name|adapter
operator|->
name|ena_dev
operator|->
name|io_cq_queues
index|[
name|ena_qid
index|]
expr_stmt|;
name|io_sq
operator|=
operator|&
name|adapter
operator|->
name|ena_dev
operator|->
name|io_sq_queues
index|[
name|ena_qid
index|]
expr_stmt|;
name|next_to_clean
operator|=
name|rx_ring
operator|->
name|next_to_clean
expr_stmt|;
do|do
block|{
name|ena_rx_ctx
operator|.
name|ena_bufs
operator|=
name|rx_ring
operator|->
name|ena_bufs
expr_stmt|;
name|ena_rx_ctx
operator|.
name|max_bufs
operator|=
name|adapter
operator|->
name|max_rx_sgl_size
expr_stmt|;
name|ena_rx_ctx
operator|.
name|descs
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|ena_com_rx_pkt
argument_list|(
name|io_cq
argument_list|,
name|io_sq
argument_list|,
operator|&
name|ena_rx_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|unlikely
argument_list|(
name|ena_rx_ctx
operator|.
name|descs
operator|==
literal|0
argument_list|)
condition|)
break|break;
comment|/* Receive mbuf from the ring */
name|mbuf
operator|=
name|ena_rx_mbuf
argument_list|(
name|rx_ring
argument_list|,
name|rx_ring
operator|->
name|ena_bufs
argument_list|,
operator|&
name|ena_rx_ctx
argument_list|,
operator|&
name|next_to_clean
argument_list|)
expr_stmt|;
comment|/* Exit if we failed to retrieve a buffer */
if|if
condition|(
name|unlikely
argument_list|(
name|mbuf
operator|==
name|NULL
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ena_rx_ctx
operator|.
name|descs
condition|;
operator|++
name|i
control|)
block|{
name|rx_ring
operator|->
name|free_rx_ids
index|[
name|next_to_clean
index|]
operator|=
name|rx_ring
operator|->
name|ena_bufs
index|[
name|i
index|]
operator|.
name|req_id
expr_stmt|;
name|next_to_clean
operator|=
name|ENA_RX_RING_IDX_NEXT
argument_list|(
name|next_to_clean
argument_list|,
name|rx_ring
operator|->
name|ring_size
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|ena_trace
argument_list|(
name|ENA_DBG
operator||
name|ENA_RXPTH
argument_list|,
literal|"Rx: %d bytes"
argument_list|,
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM_IPV6
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|ena_rx_checksum
argument_list|(
name|rx_ring
argument_list|,
operator|&
name|ena_rx_ctx
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
name|counter_enter
argument_list|()
expr_stmt|;
name|counter_u64_add_protected
argument_list|(
name|rx_ring
operator|->
name|rx_stats
operator|.
name|bytes
argument_list|,
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|counter_u64_add_protected
argument_list|(
name|adapter
operator|->
name|hw_stats
operator|.
name|rx_bytes
argument_list|,
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|counter_exit
argument_list|()
expr_stmt|;
comment|/* 		 * LRO is only for IP/TCP packets and TCP checksum of the packet 		 * should be computed by hardware. 		 */
name|do_if_input
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_VALID
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ena_rx_ctx
operator|.
name|l4_proto
operator|==
name|ENA_ETH_IO_L4_PROTO_TCP
operator|)
condition|)
block|{
comment|/* 			 * Send to the stack if: 			 *  - LRO not enabled, or 			 *  - no LRO resources, or 			 *  - lro enqueue fails 			 */
if|if
condition|(
operator|(
name|rx_ring
operator|->
name|lro
operator|.
name|lro_cnt
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|tcp_lro_rx
argument_list|(
operator|&
name|rx_ring
operator|->
name|lro
argument_list|,
name|mbuf
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|do_if_input
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|do_if_input
operator|!=
literal|0
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_DBG
operator||
name|ENA_RXPTH
argument_list|,
literal|"calling if_input() with mbuf %p"
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
name|counter_enter
argument_list|()
expr_stmt|;
name|counter_u64_add_protected
argument_list|(
name|rx_ring
operator|->
name|rx_stats
operator|.
name|cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counter_u64_add_protected
argument_list|(
name|adapter
operator|->
name|hw_stats
operator|.
name|rx_packets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counter_exit
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|budget
condition|)
do|;
name|rx_ring
operator|->
name|next_to_clean
operator|=
name|next_to_clean
expr_stmt|;
name|refill_required
operator|=
name|ena_com_free_desc
argument_list|(
name|io_sq
argument_list|)
expr_stmt|;
name|refill_threshold
operator|=
name|rx_ring
operator|->
name|ring_size
operator|/
name|ENA_RX_REFILL_THRESH_DEVIDER
expr_stmt|;
if|if
condition|(
name|refill_required
operator|>
name|refill_threshold
condition|)
block|{
name|ena_com_update_dev_comp_head
argument_list|(
name|rx_ring
operator|->
name|ena_com_io_cq
argument_list|)
expr_stmt|;
name|ena_refill_rx_bufs
argument_list|(
name|rx_ring
argument_list|,
name|refill_required
argument_list|)
expr_stmt|;
block|}
name|tcp_lro_flush_all
argument_list|(
operator|&
name|rx_ring
operator|->
name|lro
argument_list|)
expr_stmt|;
return|return
operator|(
name|RX_BUDGET
operator|-
name|budget
operator|)
return|;
name|error
label|:
name|counter_u64_add
argument_list|(
name|rx_ring
operator|->
name|rx_stats
operator|.
name|bad_desc_num
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|RX_BUDGET
operator|-
name|budget
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX& Interrupt Service routine  *  **********************************************************************/
end_comment

begin_comment
comment|/**  * ena_handle_msix - MSIX Interrupt Handler for admin/async queue  * @arg: interrupt number  **/
end_comment

begin_function
specifier|static
name|void
name|ena_intr_msix_mgmnt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|ena_adapter
operator|*
operator|)
name|arg
decl_stmt|;
name|ena_com_admin_q_comp_intr_handler
argument_list|(
name|adapter
operator|->
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|adapter
operator|->
name|running
argument_list|)
condition|)
name|ena_com_aenq_intr_handler
argument_list|(
name|adapter
operator|->
name|ena_dev
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ena_handle_msix - MSIX Interrupt Handler for Tx/Rx  * @arg: interrupt number  **/
end_comment

begin_function
specifier|static
name|void
name|ena_handle_msix
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ena_que
modifier|*
name|que
init|=
name|arg
decl_stmt|;
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
name|que
operator|->
name|adapter
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|ena_ring
modifier|*
name|tx_ring
decl_stmt|;
name|struct
name|ena_ring
modifier|*
name|rx_ring
decl_stmt|;
name|struct
name|ena_com_io_cq
modifier|*
name|io_cq
decl_stmt|;
name|struct
name|ena_eth_io_intr_reg
name|intr_reg
decl_stmt|;
name|int
name|qid
decl_stmt|,
name|ena_qid
decl_stmt|;
name|int
name|txc
decl_stmt|,
name|rxc
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|ena_trace
argument_list|(
name|ENA_DBG
argument_list|,
literal|"MSI-X TX/RX routine"
argument_list|)
expr_stmt|;
name|tx_ring
operator|=
name|que
operator|->
name|tx_ring
expr_stmt|;
name|rx_ring
operator|=
name|que
operator|->
name|rx_ring
expr_stmt|;
name|qid
operator|=
name|que
operator|->
name|id
expr_stmt|;
name|ena_qid
operator|=
name|ENA_IO_TXQ_IDX
argument_list|(
name|qid
argument_list|)
expr_stmt|;
name|io_cq
operator|=
operator|&
name|adapter
operator|->
name|ena_dev
operator|->
name|io_cq_queues
index|[
name|ena_qid
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLEAN_BUDGET
condition|;
operator|++
name|i
control|)
block|{
comment|/* 		 * If lock cannot be acquired, then deferred cleanup task was 		 * being executed and rx ring is being cleaned up in 		 * another thread. 		 */
if|if
condition|(
name|ENA_RING_MTX_TRYLOCK
argument_list|(
name|rx_ring
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rxc
operator|=
name|ena_rx_cleanup
argument_list|(
name|rx_ring
argument_list|)
expr_stmt|;
name|ENA_RING_MTX_UNLOCK
argument_list|(
name|rx_ring
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rxc
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Protection from calling ena_tx_cleanup from ena_start_xmit */
name|ENA_RING_MTX_LOCK
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
name|txc
operator|=
name|ena_tx_cleanup
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
name|ENA_RING_MTX_UNLOCK
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|txc
operator|!=
name|TX_BUDGET
operator|)
operator|&&
operator|(
name|rxc
operator|!=
name|RX_BUDGET
operator|)
condition|)
break|break;
block|}
comment|/* Signal that work is done and unmask interrupt */
name|ena_com_update_intr_reg
argument_list|(
operator|&
name|intr_reg
argument_list|,
name|RX_IRQ_INTERVAL
argument_list|,
name|TX_IRQ_INTERVAL
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ena_com_unmask_intr
argument_list|(
name|io_cq
argument_list|,
operator|&
name|intr_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_enable_msix
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|pdev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|msix_vecs
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
comment|/* Reserved the max msix vectors we might need */
name|msix_vecs
operator|=
name|ENA_MAX_MSIX_VEC
argument_list|(
name|adapter
operator|->
name|num_queues
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_entries
operator|=
name|malloc
argument_list|(
name|msix_vecs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|msix_entry
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Allocated msix_entries, vectors (cnt: %d)\n"
argument_list|,
name|msix_vecs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix_vecs
condition|;
name|i
operator|++
control|)
block|{
name|adapter
operator|->
name|msix_entries
index|[
name|i
index|]
operator|.
name|entry
operator|=
name|i
expr_stmt|;
comment|/* Vectors must start from 1 */
name|adapter
operator|->
name|msix_entries
index|[
name|i
index|]
operator|.
name|vector
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
name|rc
operator|=
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|msix_vecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to enable MSIX, vectors %d rc %d\n"
argument_list|,
name|msix_vecs
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|err_msix_free
goto|;
block|}
name|adapter
operator|->
name|msix_vecs
operator|=
name|msix_vecs
expr_stmt|;
name|adapter
operator|->
name|msix_enabled
operator|=
name|true
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_msix_free
label|:
name|free
argument_list|(
name|adapter
operator|->
name|msix_entries
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_entries
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_setup_mgmnt_intr
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|snprintf
argument_list|(
name|adapter
operator|->
name|irq_tbl
index|[
name|ENA_MGMNT_IRQ_IDX
index|]
operator|.
name|name
argument_list|,
name|ENA_IRQNAME_SIZE
argument_list|,
literal|"ena-mgmnt@pci:%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Handler is NULL on purpose, it will be set 	 * when mgmnt interrupt is acquired 	 */
name|adapter
operator|->
name|irq_tbl
index|[
name|ENA_MGMNT_IRQ_IDX
index|]
operator|.
name|handler
operator|=
name|NULL
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|ENA_MGMNT_IRQ_IDX
index|]
operator|.
name|data
operator|=
name|adapter
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|ENA_MGMNT_IRQ_IDX
index|]
operator|.
name|vector
operator|=
name|adapter
operator|->
name|msix_entries
index|[
name|ENA_MGMNT_IRQ_IDX
index|]
operator|.
name|vector
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_setup_io_intr
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|int
name|last_bind_cpu
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|irq_idx
decl_stmt|;
name|ena_trace
argument_list|(
name|ENA_DBG
argument_list|,
literal|"enter"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|irq_idx
operator|=
name|ENA_IO_IRQ_IDX
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|adapter
operator|->
name|irq_tbl
index|[
name|irq_idx
index|]
operator|.
name|name
argument_list|,
name|ENA_IRQNAME_SIZE
argument_list|,
literal|"%s-TxRx-%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|irq_idx
index|]
operator|.
name|handler
operator|=
name|ena_handle_msix
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|irq_idx
index|]
operator|.
name|data
operator|=
operator|&
name|adapter
operator|->
name|que
index|[
name|i
index|]
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|irq_idx
index|]
operator|.
name|vector
operator|=
name|adapter
operator|->
name|msix_entries
index|[
name|irq_idx
index|]
operator|.
name|vector
expr_stmt|;
name|ena_trace
argument_list|(
name|ENA_INFO
operator||
name|ENA_IOQ
argument_list|,
literal|"ena_setup_io_intr vector: %d\n"
argument_list|,
name|adapter
operator|->
name|msix_entries
index|[
name|irq_idx
index|]
operator|.
name|vector
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|adapter
operator|->
name|que
index|[
name|i
index|]
operator|.
name|cpu
operator|=
name|adapter
operator|->
name|irq_tbl
index|[
name|irq_idx
index|]
operator|.
name|cpu
operator|=
name|rss_getcpu
argument_list|(
name|i
operator|%
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 		 * We still want to bind rings to the corresponding cpu 		 * using something similar to the RSS round-robin technique. 		 */
if|if
condition|(
name|last_bind_cpu
operator|<
literal|0
condition|)
name|last_bind_cpu
operator|=
name|CPU_FIRST
argument_list|()
expr_stmt|;
name|adapter
operator|->
name|que
index|[
name|i
index|]
operator|.
name|cpu
operator|=
name|adapter
operator|->
name|irq_tbl
index|[
name|irq_idx
index|]
operator|.
name|cpu
operator|=
name|last_bind_cpu
expr_stmt|;
name|last_bind_cpu
operator|=
name|CPU_NEXT
argument_list|(
name|last_bind_cpu
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ena_request_mgmnt_irq
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ena_irq
modifier|*
name|irq
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|rcc
decl_stmt|;
name|flags
operator|=
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
expr_stmt|;
name|irq
operator|=
operator|&
name|adapter
operator|->
name|irq_tbl
index|[
name|ENA_MGMNT_IRQ_IDX
index|]
expr_stmt|;
name|irq
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|irq
operator|->
name|vector
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"could not allocate "
literal|"irq vector: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rc
operator|=
name|bus_activate_resource
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|vector
argument_list|,
name|irq
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"could not activate "
literal|"irq vector: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
goto|goto
name|err_res_free
goto|;
block|}
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ena_intr_msix_mgmnt
argument_list|,
name|irq
operator|->
name|data
argument_list|,
operator|&
name|irq
operator|->
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"failed to register "
literal|"interrupt handler for irq %ju: %d\n"
argument_list|,
name|rman_get_start
argument_list|(
name|irq
operator|->
name|res
argument_list|)
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|err_res_free
goto|;
block|}
name|irq
operator|->
name|requested
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
name|err_res_free
label|:
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"releasing resource for irq %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
name|rcc
operator|=
name|bus_release_resource
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|vector
argument_list|,
name|irq
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"dev has no parent while "
literal|"releasing res for irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
name|irq
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_request_io_irq
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ena_irq
modifier|*
name|irq
decl_stmt|;
name|unsigned
name|long
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|rcc
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix_enabled
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"failed to request irq\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
block|{
name|flags
operator|=
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|ENA_IO_IRQ_FIRST_IDX
init|;
name|i
operator|<
name|adapter
operator|->
name|msix_vecs
condition|;
name|i
operator|++
control|)
block|{
name|irq
operator|=
operator|&
name|adapter
operator|->
name|irq_tbl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|requested
condition|)
continue|continue;
name|irq
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|irq
operator|->
name|vector
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"could not allocate "
literal|"irq vector: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|irq
operator|->
name|handler
argument_list|,
name|irq
operator|->
name|data
argument_list|,
operator|&
name|irq
operator|->
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"failed to register "
literal|"interrupt handler for irq %ju: %d\n"
argument_list|,
name|rman_get_start
argument_list|(
name|irq
operator|->
name|res
argument_list|)
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|irq
operator|->
name|requested
operator|=
name|true
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"queue %d - RSS bucket %d\n"
argument_list|,
name|i
operator|-
name|ENA_IO_IRQ_FIRST_IDX
argument_list|,
name|irq
operator|->
name|cpu
argument_list|)
expr_stmt|;
else|#
directive|else
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"queue %d - cpu %d\n"
argument_list|,
name|i
operator|-
name|ENA_IO_IRQ_FIRST_IDX
argument_list|,
name|irq
operator|->
name|cpu
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|rc
operator|)
return|;
name|err
label|:
for|for
control|(
init|;
name|i
operator|>=
name|ENA_IO_IRQ_FIRST_IDX
condition|;
name|i
operator|--
control|)
block|{
name|irq
operator|=
operator|&
name|adapter
operator|->
name|irq_tbl
index|[
name|i
index|]
expr_stmt|;
name|rcc
operator|=
literal|0
expr_stmt|;
comment|/* Once we entered err: section and irq->requested is true we 		   free both intr and resources */
if|if
condition|(
name|irq
operator|->
name|requested
condition|)
name|rcc
operator|=
name|bus_teardown_intr
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|irq
operator|->
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"could not release"
literal|" irq: %d, error: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|,
name|rcc
argument_list|)
expr_stmt|;
comment|/* If we entred err: section without irq->requested set we know 		   it was bus_alloc_resource_any() that needs cleanup, provided 		   res is not NULL. In case res is NULL no work in needed in 		   this iteration */
name|rcc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|rcc
operator|=
name|bus_release_resource
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|vector
argument_list|,
name|irq
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rcc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"dev has no parent while "
literal|"releasing res for irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
name|irq
operator|->
name|requested
operator|=
name|false
expr_stmt|;
name|irq
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_free_mgmnt_irq
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ena_irq
modifier|*
name|irq
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|irq
operator|=
operator|&
name|adapter
operator|->
name|irq_tbl
index|[
name|ENA_MGMNT_IRQ_IDX
index|]
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|requested
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_INFO
operator||
name|ENA_ADMQ
argument_list|,
literal|"tear down irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bus_teardown_intr
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|irq
operator|->
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"failed to tear "
literal|"down irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
name|irq
operator|->
name|requested
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|irq
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_INFO
operator||
name|ENA_ADMQ
argument_list|,
literal|"release resource irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bus_release_resource
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|vector
argument_list|,
name|irq
operator|->
name|res
argument_list|)
expr_stmt|;
name|irq
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"dev has no parent while "
literal|"releasing res for irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ena_free_io_irq
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ena_irq
modifier|*
name|irq
decl_stmt|;
name|int
name|rc
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|ENA_IO_IRQ_FIRST_IDX
init|;
name|i
operator|<
name|adapter
operator|->
name|msix_vecs
condition|;
name|i
operator|++
control|)
block|{
name|irq
operator|=
operator|&
name|adapter
operator|->
name|irq_tbl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|requested
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_INFO
operator||
name|ENA_IOQ
argument_list|,
literal|"tear down irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bus_teardown_intr
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|irq
operator|->
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"failed to tear "
literal|"down irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
block|}
name|irq
operator|->
name|requested
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|irq
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_INFO
operator||
name|ENA_IOQ
argument_list|,
literal|"release resource irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bus_release_resource
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|vector
argument_list|,
name|irq
operator|->
name|res
argument_list|)
expr_stmt|;
name|irq
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"dev has no parent"
literal|" while releasing res for irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ena_free_irqs
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|ena_free_io_irq
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_free_mgmnt_irq
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_disable_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_disable_msix
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|pci_release_msi
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_vecs
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|msix_entries
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_entries
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_unmask_all_io_irqs
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ena_com_io_cq
modifier|*
name|io_cq
decl_stmt|;
name|struct
name|ena_eth_io_intr_reg
name|intr_reg
decl_stmt|;
name|uint16_t
name|ena_qid
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Unmask interrupts for all queues */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|ena_qid
operator|=
name|ENA_IO_TXQ_IDX
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|io_cq
operator|=
operator|&
name|adapter
operator|->
name|ena_dev
operator|->
name|io_cq_queues
index|[
name|ena_qid
index|]
expr_stmt|;
name|ena_com_update_intr_reg
argument_list|(
operator|&
name|intr_reg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ena_com_unmask_intr
argument_list|(
name|io_cq
argument_list|,
operator|&
name|intr_reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Configure the Rx forwarding */
end_comment

begin_function
specifier|static
name|int
name|ena_rss_configure
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
init|=
name|adapter
operator|->
name|ena_dev
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Set indirect table */
name|rc
operator|=
name|ena_com_indirect_table_set
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|rc
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rc
operator|!=
name|EOPNOTSUPP
operator|)
argument_list|)
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* Configure hash function (if supported) */
name|rc
operator|=
name|ena_com_set_hash_function
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|rc
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rc
operator|!=
name|EOPNOTSUPP
operator|)
argument_list|)
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* Configure hash inputs (if supported) */
name|rc
operator|=
name|ena_com_set_hash_ctrl
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|rc
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rc
operator|!=
name|EOPNOTSUPP
operator|)
argument_list|)
condition|)
return|return
operator|(
name|rc
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_up_complete
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|rss_support
condition|)
block|{
name|rc
operator|=
name|ena_rss_configure
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|rc
operator|=
name|ena_change_mtu
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|adapter
operator|->
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ena_refill_all_rx_bufs
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_reset_counters
argument_list|(
operator|(
name|counter_u64_t
operator|*
operator|)
operator|&
name|adapter
operator|->
name|hw_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|adapter
operator|->
name|hw_stats
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_up
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"device is not attached!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|adapter
operator|->
name|running
operator|==
name|false
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"device is not running!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|adapter
operator|->
name|up
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"device is going UP\n"
argument_list|)
expr_stmt|;
comment|/* setup interrupts for IO queues */
name|ena_setup_io_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ena_request_io_irq
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_ALERT
argument_list|,
literal|"err_req_irq"
argument_list|)
expr_stmt|;
goto|goto
name|err_req_irq
goto|;
block|}
comment|/* allocate transmit descriptors */
name|rc
operator|=
name|ena_setup_all_tx_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_ALERT
argument_list|,
literal|"err_setup_tx"
argument_list|)
expr_stmt|;
goto|goto
name|err_setup_tx
goto|;
block|}
comment|/* allocate receive descriptors */
name|rc
operator|=
name|ena_setup_all_rx_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_ALERT
argument_list|,
literal|"err_setup_rx"
argument_list|)
expr_stmt|;
goto|goto
name|err_setup_rx
goto|;
block|}
comment|/* create IO queues for Rx& Tx */
name|rc
operator|=
name|ena_create_io_queues
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_ALERT
argument_list|,
literal|"create IO queues failed"
argument_list|)
expr_stmt|;
goto|goto
name|err_io_que
goto|;
block|}
if|if
condition|(
name|adapter
operator|->
name|link_status
condition|)
name|if_link_state_change
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ena_up_complete
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|err_up_complete
goto|;
name|counter_u64_add
argument_list|(
name|adapter
operator|->
name|dev_stats
operator|.
name|interface_up
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ena_update_hwassist
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|if_setdrvflagbits
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|IFF_DRV_RUNNING
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|adapter
operator|->
name|timer_service
argument_list|,
name|SBT_1S
argument_list|,
name|SBT_1S
argument_list|,
name|ena_timer_service
argument_list|,
operator|(
name|void
operator|*
operator|)
name|adapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|up
operator|=
name|true
expr_stmt|;
name|ena_unmask_all_io_irqs
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err_up_complete
label|:
name|ena_destroy_all_io_queues
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_io_que
label|:
name|ena_free_all_rx_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_setup_rx
label|:
name|ena_free_all_tx_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_setup_tx
label|:
name|ena_free_io_irq
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_req_irq
label|:
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ena_get_counter
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|ena_hw_stats
modifier|*
name|stats
decl_stmt|;
name|adapter
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|&
name|adapter
operator|->
name|hw_stats
expr_stmt|;
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
name|IFCOUNTER_IPACKETS
case|:
return|return
operator|(
name|counter_u64_fetch
argument_list|(
name|stats
operator|->
name|rx_packets
argument_list|)
operator|)
return|;
case|case
name|IFCOUNTER_OPACKETS
case|:
return|return
operator|(
name|counter_u64_fetch
argument_list|(
name|stats
operator|->
name|tx_packets
argument_list|)
operator|)
return|;
case|case
name|IFCOUNTER_IBYTES
case|:
return|return
operator|(
name|counter_u64_fetch
argument_list|(
name|stats
operator|->
name|rx_bytes
argument_list|)
operator|)
return|;
case|case
name|IFCOUNTER_OBYTES
case|:
return|return
operator|(
name|counter_u64_fetch
argument_list|(
name|stats
operator|->
name|tx_bytes
argument_list|)
operator|)
return|;
case|case
name|IFCOUNTER_IQDROPS
case|:
return|return
operator|(
name|counter_u64_fetch
argument_list|(
name|stats
operator|->
name|rx_drops
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ena_media_change
parameter_list|(
name|if_t
name|ifp
parameter_list|)
block|{
comment|/* Media Change is not supported by firmware */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_media_status
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|ena_trace
argument_list|(
name|ENA_DBG
argument_list|,
literal|"enter"
argument_list|)
expr_stmt|;
name|ENA_DEV_LOCK
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_status
condition|)
block|{
name|ENA_DEV_UNLOCK
expr_stmt|;
name|ena_trace
argument_list|(
name|ENA_WARNING
argument_list|,
literal|"link_status = false"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_T
operator||
name|IFM_FDX
expr_stmt|;
name|ENA_DEV_UNLOCK
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|ena_adapter
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|up
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
name|ena_up
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ena_ioctl
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|adapter
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
comment|/* 	 * Acquiring lock to prevent from running up and down routines parallel. 	 */
name|rc
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
name|sx_xlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
name|ena_down
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_change_mtu
argument_list|(
name|ifp
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ena_up
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"ioctl promisc/allmulti\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sx_xlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ena_up
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
name|ena_down
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|rc
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|reinit
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_reqcap
operator|!=
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|=
name|ifr
operator|->
name|ifr_reqcap
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reinit
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
name|ena_down
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ena_up
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|rc
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_get_dev_offloads
parameter_list|(
name|struct
name|ena_com_dev_get_features_ctx
modifier|*
name|feat
parameter_list|)
block|{
name|int
name|caps
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|feat
operator|->
name|offload
operator|.
name|tx
operator|&
operator|(
name|ENA_ADMIN_FEATURE_OFFLOAD_DESC_TX_L4_IPV4_CSUM_FULL_MASK
operator||
name|ENA_ADMIN_FEATURE_OFFLOAD_DESC_TX_L4_IPV4_CSUM_PART_MASK
operator||
name|ENA_ADMIN_FEATURE_OFFLOAD_DESC_TX_L3_CSUM_IPV4_MASK
operator|)
operator|)
operator|!=
literal|0
condition|)
name|caps
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
if|if
condition|(
operator|(
name|feat
operator|->
name|offload
operator|.
name|tx
operator|&
operator|(
name|ENA_ADMIN_FEATURE_OFFLOAD_DESC_TX_L4_IPV6_CSUM_FULL_MASK
operator||
name|ENA_ADMIN_FEATURE_OFFLOAD_DESC_TX_L4_IPV6_CSUM_PART_MASK
operator|)
operator|)
operator|!=
literal|0
condition|)
name|caps
operator||=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
if|if
condition|(
operator|(
name|feat
operator|->
name|offload
operator|.
name|tx
operator|&
name|ENA_ADMIN_FEATURE_OFFLOAD_DESC_TSO_IPV4_MASK
operator|)
operator|!=
literal|0
condition|)
name|caps
operator||=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
operator|(
name|feat
operator|->
name|offload
operator|.
name|tx
operator|&
name|ENA_ADMIN_FEATURE_OFFLOAD_DESC_TSO_IPV6_MASK
operator|)
operator|!=
literal|0
condition|)
name|caps
operator||=
name|IFCAP_TSO6
expr_stmt|;
if|if
condition|(
operator|(
name|feat
operator|->
name|offload
operator|.
name|rx_supported
operator|&
operator|(
name|ENA_ADMIN_FEATURE_OFFLOAD_DESC_RX_L4_IPV4_CSUM_MASK
operator||
name|ENA_ADMIN_FEATURE_OFFLOAD_DESC_RX_L3_CSUM_IPV4_MASK
operator|)
operator|)
operator|!=
literal|0
condition|)
name|caps
operator||=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
operator|(
name|feat
operator|->
name|offload
operator|.
name|rx_supported
operator|&
name|ENA_ADMIN_FEATURE_OFFLOAD_DESC_RX_L4_IPV6_CSUM_MASK
operator|)
operator|!=
literal|0
condition|)
name|caps
operator||=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
name|caps
operator||=
name|IFCAP_LRO
operator||
name|IFCAP_JUMBO_MTU
expr_stmt|;
return|return
operator|(
name|caps
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_update_host_info
parameter_list|(
name|struct
name|ena_admin_host_info
modifier|*
name|host_info
parameter_list|,
name|if_t
name|ifp
parameter_list|)
block|{
name|host_info
operator|->
name|supported_network_features
index|[
literal|0
index|]
operator|=
operator|(
name|uint32_t
operator|)
name|if_getcapabilities
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_update_hwassist
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|uint32_t
name|feat
init|=
name|adapter
operator|->
name|tx_offload_cap
decl_stmt|;
name|int
name|cap
init|=
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|if_clearhwassist
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cap
operator|&
name|IFCAP_TXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|feat
operator|&
name|ENA_ADMIN_FEATURE_OFFLOAD_DESC_TX_L3_CSUM_IPV4_MASK
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|CSUM_IP
expr_stmt|;
if|if
condition|(
operator|(
name|feat
operator|&
operator|(
name|ENA_ADMIN_FEATURE_OFFLOAD_DESC_TX_L4_IPV4_CSUM_FULL_MASK
operator||
name|ENA_ADMIN_FEATURE_OFFLOAD_DESC_TX_L4_IPV4_CSUM_PART_MASK
operator|)
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|CSUM_IP_UDP
operator||
name|CSUM_IP_TCP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cap
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|CSUM_IP6_UDP
operator||
name|CSUM_IP6_TCP
expr_stmt|;
if|if
condition|(
operator|(
name|cap
operator|&
name|IFCAP_TSO4
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|CSUM_IP_TSO
expr_stmt|;
if|if
condition|(
operator|(
name|cap
operator|&
name|IFCAP_TSO6
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|CSUM_IP6_TSO
expr_stmt|;
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_setup_ifnet
parameter_list|(
name|device_t
name|pdev
parameter_list|,
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|ena_com_dev_get_features_ctx
modifier|*
name|feat
parameter_list|)
block|{
name|if_t
name|ifp
decl_stmt|;
name|int
name|caps
init|=
literal|0
decl_stmt|;
name|ena_trace
argument_list|(
name|ENA_DBG
argument_list|,
literal|"enter"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
operator|=
name|if_gethandle
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"can not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|pdev
argument_list|)
argument_list|)
expr_stmt|;
name|if_setdev
argument_list|(
name|ifp
argument_list|,
name|pdev
argument_list|)
expr_stmt|;
name|if_setsoftc
argument_list|(
name|ifp
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|if_setflags
argument_list|(
name|ifp
argument_list|,
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
argument_list|)
expr_stmt|;
name|if_setinitfn
argument_list|(
name|ifp
argument_list|,
name|ena_init
argument_list|)
expr_stmt|;
name|if_settransmitfn
argument_list|(
name|ifp
argument_list|,
name|ena_mq_start
argument_list|)
expr_stmt|;
name|if_setqflushfn
argument_list|(
name|ifp
argument_list|,
name|ena_qflush
argument_list|)
expr_stmt|;
name|if_setioctlfn
argument_list|(
name|ifp
argument_list|,
name|ena_ioctl
argument_list|)
expr_stmt|;
name|if_setgetcounterfn
argument_list|(
name|ifp
argument_list|,
name|ena_get_counter
argument_list|)
expr_stmt|;
name|if_setsendqlen
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|tx_ring_size
argument_list|)
expr_stmt|;
name|if_setsendqready
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_setmtu
argument_list|(
name|ifp
argument_list|,
name|ETHERMTU
argument_list|)
expr_stmt|;
name|if_setbaudrate
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Zeroize capabilities... */
name|if_setcapabilities
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_setcapenable
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* check hardware support */
name|caps
operator|=
name|ena_get_dev_offloads
argument_list|(
name|feat
argument_list|)
expr_stmt|;
comment|/* ... and set them */
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
name|caps
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* TSO parameters */
name|ifp
operator|->
name|if_hw_tsomax
operator|=
name|ENA_TSO_MAXSIZE
operator|-
operator|(
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegcount
operator|=
name|adapter
operator|->
name|max_tx_sgl_size
operator|-
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegsize
operator|=
name|ENA_TSO_MAXSIZE
expr_stmt|;
name|if_setifheaderlen
argument_list|(
name|ifp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
argument_list|)
expr_stmt|;
name|if_setcapenable
argument_list|(
name|ifp
argument_list|,
name|if_getcapabilities
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
name|ifmedia_init
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|ena_media_change
argument_list|,
name|ena_media_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|mac_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_down
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|up
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"device is going DOWN\n"
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|adapter
operator|->
name|timer_service
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|up
operator|=
name|false
expr_stmt|;
name|if_setdrvflagbits
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
name|ena_free_io_irq
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|trigger_reset
condition|)
block|{
name|rc
operator|=
name|ena_com_dev_reset
argument_list|(
name|adapter
operator|->
name|ena_dev
argument_list|,
name|adapter
operator|->
name|reset_reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Device reset failed\n"
argument_list|)
expr_stmt|;
block|}
name|ena_destroy_all_io_queues
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_free_all_tx_bufs
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_free_all_rx_bufs
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_free_all_tx_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_free_all_rx_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|adapter
operator|->
name|dev_stats
operator|.
name|interface_down
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ena_tx_csum
parameter_list|(
name|struct
name|ena_com_tx_ctx
modifier|*
name|ena_tx_ctx
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|)
block|{
name|struct
name|ena_com_tx_meta
modifier|*
name|ena_meta
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|u32
name|mss
decl_stmt|;
name|bool
name|offload
decl_stmt|;
name|uint16_t
name|etype
decl_stmt|;
name|int
name|ehdrlen
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|iphlen
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|offload
operator|=
name|false
expr_stmt|;
name|ena_meta
operator|=
operator|&
name|ena_tx_ctx
operator|->
name|ena_meta
expr_stmt|;
name|mss
operator|=
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
if|if
condition|(
name|mss
operator|!=
literal|0
condition|)
name|offload
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
condition|)
name|offload
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_OFFLOAD
operator|)
operator|!=
literal|0
condition|)
name|offload
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|offload
condition|)
block|{
name|ena_tx_ctx
operator|->
name|meta_valid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Determine where frame payload starts. */
name|eh
operator|=
name|mtod
argument_list|(
name|mbuf
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
else|else
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mbuf
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|iphlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
operator|)
operator|!=
literal|0
condition|)
block|{
name|ena_tx_ctx
operator|->
name|l3_csum_enable
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
condition|)
block|{
name|ena_tx_ctx
operator|->
name|tso_enable
operator|=
literal|1
expr_stmt|;
name|ena_meta
operator|->
name|l4_hdr_len
operator|=
operator|(
name|th
operator|->
name|th_off
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|ena_tx_ctx
operator|->
name|l3_proto
operator|=
name|ENA_ETH_IO_L3_PROTO_IPV4
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|==
literal|0
condition|)
name|ena_tx_ctx
operator|->
name|df
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
name|ena_tx_ctx
operator|->
name|l3_proto
operator|=
name|ENA_ETH_IO_L3_PROTO_IPV6
expr_stmt|;
default|default:
break|break;
block|}
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|ena_tx_ctx
operator|->
name|l4_proto
operator|=
name|ENA_ETH_IO_L4_PROTO_TCP
expr_stmt|;
if|if
condition|(
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP_TCP
operator||
name|CSUM_IP6_TCP
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ena_tx_ctx
operator|->
name|l4_csum_enable
operator|=
literal|1
expr_stmt|;
else|else
name|ena_tx_ctx
operator|->
name|l4_csum_enable
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_UDP
condition|)
block|{
name|ena_tx_ctx
operator|->
name|l4_proto
operator|=
name|ENA_ETH_IO_L4_PROTO_UDP
expr_stmt|;
if|if
condition|(
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP_UDP
operator||
name|CSUM_IP6_UDP
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ena_tx_ctx
operator|->
name|l4_csum_enable
operator|=
literal|1
expr_stmt|;
else|else
name|ena_tx_ctx
operator|->
name|l4_csum_enable
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ena_tx_ctx
operator|->
name|l4_proto
operator|=
name|ENA_ETH_IO_L4_PROTO_UNKNOWN
expr_stmt|;
name|ena_tx_ctx
operator|->
name|l4_csum_enable
operator|=
literal|0
expr_stmt|;
block|}
name|ena_meta
operator|->
name|mss
operator|=
name|mss
expr_stmt|;
name|ena_meta
operator|->
name|l3_hdr_len
operator|=
name|iphlen
expr_stmt|;
name|ena_meta
operator|->
name|l3_hdr_offset
operator|=
name|ehdrlen
expr_stmt|;
name|ena_tx_ctx
operator|->
name|meta_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_check_and_collapse_mbuf
parameter_list|(
name|struct
name|ena_ring
modifier|*
name|tx_ring
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mbuf
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|collapsed_mbuf
decl_stmt|;
name|int
name|num_frags
decl_stmt|;
name|adapter
operator|=
name|tx_ring
operator|->
name|adapter
expr_stmt|;
name|num_frags
operator|=
name|ena_mbuf_count
argument_list|(
operator|*
name|mbuf
argument_list|)
expr_stmt|;
comment|/* One segment must be reserved for configuration descriptor. */
if|if
condition|(
name|num_frags
operator|<
name|adapter
operator|->
name|max_tx_sgl_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|counter_u64_add
argument_list|(
name|tx_ring
operator|->
name|tx_stats
operator|.
name|collapse
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|collapsed_mbuf
operator|=
name|m_collapse
argument_list|(
operator|*
name|mbuf
argument_list|,
name|M_NOWAIT
argument_list|,
name|adapter
operator|->
name|max_tx_sgl_size
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|collapsed_mbuf
operator|==
name|NULL
condition|)
block|{
name|counter_u64_add
argument_list|(
name|tx_ring
operator|->
name|tx_stats
operator|.
name|collapse_err
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* If mbuf was collapsed succesfully, original mbuf is released. */
operator|*
name|mbuf
operator|=
name|collapsed_mbuf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_xmit_mbuf
parameter_list|(
name|struct
name|ena_ring
modifier|*
name|tx_ring
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mbuf
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|ena_tx_buffer
modifier|*
name|tx_info
decl_stmt|;
name|struct
name|ena_com_tx_ctx
name|ena_tx_ctx
decl_stmt|;
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
decl_stmt|;
name|struct
name|ena_com_buf
modifier|*
name|ena_buf
decl_stmt|;
name|struct
name|ena_com_io_sq
modifier|*
name|io_sq
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|ENA_BUS_DMA_SEGS
index|]
decl_stmt|;
name|void
modifier|*
name|push_hdr
decl_stmt|;
name|uint16_t
name|next_to_use
decl_stmt|;
name|uint16_t
name|req_id
decl_stmt|;
name|uint16_t
name|push_len
decl_stmt|;
name|uint16_t
name|ena_qid
decl_stmt|;
name|uint32_t
name|len
decl_stmt|,
name|nsegs
decl_stmt|,
name|header_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|int
name|nb_hw_desc
decl_stmt|;
name|ena_qid
operator|=
name|ENA_IO_TXQ_IDX
argument_list|(
name|tx_ring
operator|->
name|que
operator|->
name|id
argument_list|)
expr_stmt|;
name|adapter
operator|=
name|tx_ring
operator|->
name|que
operator|->
name|adapter
expr_stmt|;
name|ena_dev
operator|=
name|adapter
operator|->
name|ena_dev
expr_stmt|;
name|io_sq
operator|=
operator|&
name|adapter
operator|->
name|ena_dev
operator|->
name|io_sq_queues
index|[
name|ena_qid
index|]
expr_stmt|;
name|rc
operator|=
name|ena_check_and_collapse_mbuf
argument_list|(
name|tx_ring
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_WARNING
argument_list|,
literal|"Failed to collapse mbuf! err: %d"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|next_to_use
operator|=
name|tx_ring
operator|->
name|next_to_use
expr_stmt|;
name|req_id
operator|=
name|tx_ring
operator|->
name|free_tx_ids
index|[
name|next_to_use
index|]
expr_stmt|;
name|tx_info
operator|=
operator|&
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|req_id
index|]
expr_stmt|;
name|tx_info
operator|->
name|mbuf
operator|=
operator|*
name|mbuf
expr_stmt|;
name|tx_info
operator|->
name|num_of_bufs
operator|=
literal|0
expr_stmt|;
name|ena_buf
operator|=
name|tx_info
operator|->
name|bufs
expr_stmt|;
name|len
operator|=
operator|(
operator|*
name|mbuf
operator|)
operator|->
name|m_len
expr_stmt|;
name|ena_trace
argument_list|(
name|ENA_DBG
operator||
name|ENA_TXPTH
argument_list|,
literal|"Tx: %d bytes"
argument_list|,
operator|(
operator|*
name|mbuf
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|push_len
operator|=
literal|0
expr_stmt|;
name|header_len
operator|=
name|min_t
argument_list|(
name|uint32_t
argument_list|,
name|len
argument_list|,
name|tx_ring
operator|->
name|tx_max_header_size
argument_list|)
expr_stmt|;
name|push_hdr
operator|=
name|NULL
expr_stmt|;
name|rc
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|adapter
operator|->
name|tx_buf_tag
argument_list|,
name|tx_info
operator|->
name|map
argument_list|,
operator|*
name|mbuf
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|!=
literal|0
operator|)
operator|||
operator|(
name|nsegs
operator|==
literal|0
operator|)
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_WARNING
argument_list|,
literal|"dmamap load failed! err: %d nsegs: %d"
argument_list|,
name|rc
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|tx_ring
operator|->
name|tx_stats
operator|.
name|dma_mapping_err
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tx_info
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ENOMEM
condition|)
return|return
operator|(
name|ENA_COM_NO_MEM
operator|)
return|;
else|else
return|return
operator|(
name|ENA_COM_INVAL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|ena_buf
operator|->
name|len
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
name|ena_buf
operator|->
name|paddr
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|ena_buf
operator|++
expr_stmt|;
block|}
name|tx_info
operator|->
name|num_of_bufs
operator|=
name|nsegs
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ena_tx_ctx
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ena_com_tx_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ena_tx_ctx
operator|.
name|ena_bufs
operator|=
name|tx_info
operator|->
name|bufs
expr_stmt|;
name|ena_tx_ctx
operator|.
name|push_header
operator|=
name|push_hdr
expr_stmt|;
name|ena_tx_ctx
operator|.
name|num_bufs
operator|=
name|tx_info
operator|->
name|num_of_bufs
expr_stmt|;
name|ena_tx_ctx
operator|.
name|req_id
operator|=
name|req_id
expr_stmt|;
name|ena_tx_ctx
operator|.
name|header_len
operator|=
name|header_len
expr_stmt|;
comment|/* Set flags and meta data */
name|ena_tx_csum
argument_list|(
operator|&
name|ena_tx_ctx
argument_list|,
operator|*
name|mbuf
argument_list|)
expr_stmt|;
comment|/* Prepare the packet's descriptors and send them to device */
name|rc
operator|=
name|ena_com_prepare_tx
argument_list|(
name|io_sq
argument_list|,
operator|&
name|ena_tx_ctx
argument_list|,
operator|&
name|nb_hw_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_WARNING
argument_list|,
literal|"failed to prepare tx bufs\n"
argument_list|)
expr_stmt|;
name|counter_enter
argument_list|()
expr_stmt|;
name|counter_u64_add_protected
argument_list|(
name|tx_ring
operator|->
name|tx_stats
operator|.
name|queue_stop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counter_u64_add_protected
argument_list|(
name|tx_ring
operator|->
name|tx_stats
operator|.
name|prepare_ctx_err
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counter_exit
argument_list|()
expr_stmt|;
goto|goto
name|dma_error
goto|;
block|}
name|counter_enter
argument_list|()
expr_stmt|;
name|counter_u64_add_protected
argument_list|(
name|tx_ring
operator|->
name|tx_stats
operator|.
name|cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counter_u64_add_protected
argument_list|(
name|tx_ring
operator|->
name|tx_stats
operator|.
name|bytes
argument_list|,
operator|(
operator|*
name|mbuf
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|counter_u64_add_protected
argument_list|(
name|adapter
operator|->
name|hw_stats
operator|.
name|tx_packets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counter_u64_add_protected
argument_list|(
name|adapter
operator|->
name|hw_stats
operator|.
name|tx_bytes
argument_list|,
operator|(
operator|*
name|mbuf
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|counter_exit
argument_list|()
expr_stmt|;
name|tx_info
operator|->
name|tx_descs
operator|=
name|nb_hw_desc
expr_stmt|;
name|getbinuptime
argument_list|(
operator|&
name|tx_info
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|tx_info
operator|->
name|print_once
operator|=
name|true
expr_stmt|;
name|tx_ring
operator|->
name|next_to_use
operator|=
name|ENA_TX_RING_IDX_NEXT
argument_list|(
name|next_to_use
argument_list|,
name|tx_ring
operator|->
name|ring_size
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|adapter
operator|->
name|tx_buf_tag
argument_list|,
name|tx_info
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|dma_error
label|:
name|tx_info
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|adapter
operator|->
name|tx_buf_tag
argument_list|,
name|tx_info
operator|->
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_start_xmit
parameter_list|(
name|struct
name|ena_ring
modifier|*
name|tx_ring
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
name|tx_ring
operator|->
name|adapter
decl_stmt|;
name|struct
name|ena_com_io_sq
modifier|*
name|io_sq
decl_stmt|;
name|int
name|ena_qid
decl_stmt|;
name|int
name|acum_pkts
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_status
condition|)
return|return;
name|ena_qid
operator|=
name|ENA_IO_TXQ_IDX
argument_list|(
name|tx_ring
operator|->
name|que
operator|->
name|id
argument_list|)
expr_stmt|;
name|io_sq
operator|=
operator|&
name|adapter
operator|->
name|ena_dev
operator|->
name|io_sq_queues
index|[
name|ena_qid
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|mbuf
operator|=
name|drbr_peek
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_DBG
operator||
name|ENA_TXPTH
argument_list|,
literal|"\ndequeued mbuf %p with flags %#x and"
literal|" header csum flags %#jx"
argument_list|,
name|mbuf
argument_list|,
name|mbuf
operator|->
name|m_flags
argument_list|,
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ena_com_sq_have_enough_space
argument_list|(
name|io_sq
argument_list|,
name|ENA_TX_CLEANUP_THRESHOLD
argument_list|)
condition|)
name|ena_tx_cleanup
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|ena_xmit_mbuf
argument_list|(
name|tx_ring
argument_list|,
operator|&
name|mbuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|ENA_COM_NO_MEM
condition|)
block|{
name|drbr_putback
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|ENA_COM_NO_SPACE
condition|)
block|{
name|drbr_putback
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|drbr_advance
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|drbr_advance
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|acum_pkts
operator|++
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|acum_pkts
operator|==
name|DB_THRESHOLD
condition|)
block|{
name|acum_pkts
operator|=
literal|0
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
comment|/* Trigger the dma engine */
name|ena_com_write_sq_doorbell
argument_list|(
name|io_sq
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|tx_ring
operator|->
name|tx_stats
operator|.
name|doorbells
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|acum_pkts
operator|!=
literal|0
condition|)
block|{
name|wmb
argument_list|()
expr_stmt|;
comment|/* Trigger the dma engine */
name|ena_com_write_sq_doorbell
argument_list|(
name|io_sq
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|tx_ring
operator|->
name|tx_stats
operator|.
name|doorbells
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ena_com_sq_have_enough_space
argument_list|(
name|io_sq
argument_list|,
name|ENA_TX_CLEANUP_THRESHOLD
argument_list|)
condition|)
name|ena_tx_cleanup
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_deferred_mq_start
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ena_ring
modifier|*
name|tx_ring
init|=
operator|(
expr|struct
name|ena_ring
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|tx_ring
operator|->
name|adapter
operator|->
name|ifp
decl_stmt|;
while|while
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|)
operator|&&
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|ENA_RING_MTX_LOCK
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
name|ena_start_xmit
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
name|ENA_RING_MTX_UNLOCK
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ena_mq_start
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ena_ring
modifier|*
name|tx_ring
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|is_drbr_empty
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Which queue to use */
comment|/* 	 * If everything is setup correctly, it should be the 	 * same bucket that the current CPU we're on is. 	 * It should improve performance. 	 */
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
block|{
ifdef|#
directive|ifdef
name|RSS
if|if
condition|(
name|rss_hash2bucket
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
argument_list|,
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|i
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|i
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
block|}
block|}
else|else
block|{
name|i
operator|=
name|curcpu
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
block|}
name|tx_ring
operator|=
operator|&
name|adapter
operator|->
name|tx_ring
index|[
name|i
index|]
expr_stmt|;
comment|/* Check if drbr is empty before putting packet */
name|is_drbr_empty
operator|=
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|tx_ring
operator|->
name|enqueue_tq
argument_list|,
operator|&
name|tx_ring
operator|->
name|enqueue_task
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|is_drbr_empty
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ENA_RING_MTX_TRYLOCK
argument_list|(
name|tx_ring
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|ena_start_xmit
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
name|ENA_RING_MTX_UNLOCK
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|taskqueue_enqueue
argument_list|(
name|tx_ring
operator|->
name|enqueue_tq
argument_list|,
operator|&
name|tx_ring
operator|->
name|enqueue_task
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_qflush
parameter_list|(
name|if_t
name|ifp
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ena_ring
modifier|*
name|tx_ring
init|=
name|adapter
operator|->
name|tx_ring
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
operator|++
name|i
operator|,
operator|++
name|tx_ring
control|)
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|)
condition|)
block|{
name|ENA_RING_MTX_LOCK
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
name|drbr_flush
argument_list|(
name|ifp
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|)
expr_stmt|;
name|ENA_RING_MTX_UNLOCK
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_calc_io_queue_num
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|ena_com_dev_get_features_ctx
modifier|*
name|get_feat_ctx
parameter_list|)
block|{
name|int
name|io_sq_num
decl_stmt|,
name|io_cq_num
decl_stmt|,
name|io_queue_num
decl_stmt|;
name|io_sq_num
operator|=
name|get_feat_ctx
operator|->
name|max_queues
operator|.
name|max_sq_num
expr_stmt|;
name|io_cq_num
operator|=
name|get_feat_ctx
operator|->
name|max_queues
operator|.
name|max_sq_num
expr_stmt|;
name|io_queue_num
operator|=
name|min_t
argument_list|(
name|int
argument_list|,
name|mp_ncpus
argument_list|,
name|ENA_MAX_NUM_IO_QUEUES
argument_list|)
expr_stmt|;
name|io_queue_num
operator|=
name|min_t
argument_list|(
name|int
argument_list|,
name|io_queue_num
argument_list|,
name|io_sq_num
argument_list|)
expr_stmt|;
name|io_queue_num
operator|=
name|min_t
argument_list|(
name|int
argument_list|,
name|io_queue_num
argument_list|,
name|io_cq_num
argument_list|)
expr_stmt|;
comment|/* 1 IRQ for for mgmnt and 1 IRQ for each TX/RX pair */
name|io_queue_num
operator|=
name|min_t
argument_list|(
name|int
argument_list|,
name|io_queue_num
argument_list|,
name|pci_msix_count
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|io_queue_num
operator|=
name|min_t
argument_list|(
name|int
argument_list|,
name|io_queue_num
argument_list|,
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|io_queue_num
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_calc_queue_size
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|uint16_t
modifier|*
name|max_tx_sgl_size
parameter_list|,
name|uint16_t
modifier|*
name|max_rx_sgl_size
parameter_list|,
name|struct
name|ena_com_dev_get_features_ctx
modifier|*
name|feat
parameter_list|)
block|{
name|uint32_t
name|queue_size
init|=
name|ENA_DEFAULT_RING_SIZE
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|uint32_t
name|q
decl_stmt|;
name|queue_size
operator|=
name|min_t
argument_list|(
name|uint32_t
argument_list|,
name|queue_size
argument_list|,
name|feat
operator|->
name|max_queues
operator|.
name|max_cq_depth
argument_list|)
expr_stmt|;
name|queue_size
operator|=
name|min_t
argument_list|(
name|uint32_t
argument_list|,
name|queue_size
argument_list|,
name|feat
operator|->
name|max_queues
operator|.
name|max_sq_depth
argument_list|)
expr_stmt|;
comment|/* round down to the nearest power of 2 */
name|v
operator|=
name|queue_size
expr_stmt|;
while|while
condition|(
name|v
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|powerof2
argument_list|(
name|queue_size
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|v
operator|/=
literal|2
expr_stmt|;
name|q
operator|=
name|rounddown2
argument_list|(
name|queue_size
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
literal|0
condition|)
block|{
name|queue_size
operator|=
name|q
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|queue_size
operator|==
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Invalid queue size\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENA_COM_FAULT
operator|)
return|;
block|}
operator|*
name|max_tx_sgl_size
operator|=
name|min_t
argument_list|(
name|uint16_t
argument_list|,
name|ENA_PKT_MAX_BUFS
argument_list|,
name|feat
operator|->
name|max_queues
operator|.
name|max_packet_tx_descs
argument_list|)
expr_stmt|;
operator|*
name|max_rx_sgl_size
operator|=
name|min_t
argument_list|(
name|uint16_t
argument_list|,
name|ENA_PKT_MAX_BUFS
argument_list|,
name|feat
operator|->
name|max_queues
operator|.
name|max_packet_rx_descs
argument_list|)
expr_stmt|;
return|return
operator|(
name|queue_size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_rss_init_default
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
init|=
name|adapter
operator|->
name|ena_dev
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|pdev
decl_stmt|;
name|int
name|qid
decl_stmt|,
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|rc
operator|=
name|ena_com_rss_init
argument_list|(
name|ena_dev
argument_list|,
name|ENA_RX_RSS_TABLE_LOG_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot init RSS\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ENA_RX_RSS_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|RSS
name|qid
operator|=
name|rss_get_indirection_to_bucket
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|qid
operator|=
name|qid
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
else|#
directive|else
name|qid
operator|=
name|i
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
endif|#
directive|endif
name|rc
operator|=
name|ena_com_indirect_table_fill_entry
argument_list|(
name|ena_dev
argument_list|,
name|i
argument_list|,
name|ENA_IO_RXQ_IDX
argument_list|(
name|qid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|rc
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rc
operator|!=
name|EOPNOTSUPP
operator|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot fill indirect table\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_rss_destroy
goto|;
block|}
block|}
name|rc
operator|=
name|ena_com_fill_hash_function
argument_list|(
name|ena_dev
argument_list|,
name|ENA_ADMIN_CRC32
argument_list|,
name|NULL
argument_list|,
name|ENA_HASH_KEY_SIZE
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|rc
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rc
operator|!=
name|EOPNOTSUPP
operator|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot fill hash function\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_rss_destroy
goto|;
block|}
name|rc
operator|=
name|ena_com_set_default_hash_ctrl
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|rc
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rc
operator|!=
name|EOPNOTSUPP
operator|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot fill hash control\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_rss_destroy
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err_rss_destroy
label|:
name|ena_com_rss_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_rss_init_default_deferred
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
decl_stmt|;
name|devclass_t
name|dc
decl_stmt|;
name|int
name|max
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|dc
operator|=
name|devclass_find
argument_list|(
literal|"ena"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_DBG
argument_list|,
literal|"No devclass ena\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|max
operator|=
name|devclass_get_maxunit
argument_list|(
name|dc
argument_list|)
expr_stmt|;
while|while
condition|(
name|max
operator|--
operator|>=
literal|0
condition|)
block|{
name|adapter
operator|=
name|devclass_get_softc
argument_list|(
name|dc
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|!=
name|NULL
condition|)
block|{
name|rc
operator|=
name|ena_rss_init_default
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|rss_support
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"WARNING: RSS was not properly initialized,"
literal|" it will affect bandwidth\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|rss_support
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|ena_rss_init
argument_list|,
name|SI_SUB_KICK_SCHEDULER
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|ena_rss_init_default_deferred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|ena_config_host_info
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_admin_host_info
modifier|*
name|host_info
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Allocate only the host info */
name|rc
operator|=
name|ena_com_allocate_host_info
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|ena_trace
argument_list|(
name|ENA_ALERT
argument_list|,
literal|"Cannot allocate host info\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|host_info
operator|=
name|ena_dev
operator|->
name|host_attr
operator|.
name|host_info
expr_stmt|;
name|host_info
operator|->
name|os_type
operator|=
name|ENA_ADMIN_OS_FREEBSD
expr_stmt|;
name|host_info
operator|->
name|kernel_ver
operator|=
name|osreldate
expr_stmt|;
name|sprintf
argument_list|(
name|host_info
operator|->
name|kernel_ver_str
argument_list|,
literal|"%d"
argument_list|,
name|osreldate
argument_list|)
expr_stmt|;
name|host_info
operator|->
name|os_dist
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|host_info
operator|->
name|os_dist_str
argument_list|,
name|osrelease
argument_list|,
sizeof|sizeof
argument_list|(
name|host_info
operator|->
name|os_dist_str
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|host_info
operator|->
name|driver_version
operator|=
operator|(
name|DRV_MODULE_VER_MAJOR
operator|)
operator||
operator|(
name|DRV_MODULE_VER_MINOR
operator|<<
name|ENA_ADMIN_HOST_INFO_MINOR_SHIFT
operator|)
operator||
operator|(
name|DRV_MODULE_VER_SUBMINOR
operator|<<
name|ENA_ADMIN_HOST_INFO_SUB_MINOR_SHIFT
operator|)
expr_stmt|;
name|rc
operator|=
name|ena_com_set_host_attributes
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|EOPNOTSUPP
condition|)
name|ena_trace
argument_list|(
name|ENA_WARNING
argument_list|,
literal|"Cannot set host attributes\n"
argument_list|)
expr_stmt|;
else|else
name|ena_trace
argument_list|(
name|ENA_ALERT
argument_list|,
literal|"Cannot set host attributes\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return;
name|err
label|:
name|ena_com_delete_host_info
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_device_init
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|device_t
name|pdev
parameter_list|,
name|struct
name|ena_com_dev_get_features_ctx
modifier|*
name|get_feat_ctx
parameter_list|,
name|int
modifier|*
name|wd_active
parameter_list|)
block|{
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
init|=
name|adapter
operator|->
name|ena_dev
decl_stmt|;
name|bool
name|readless_supported
decl_stmt|;
name|uint32_t
name|aenq_groups
decl_stmt|;
name|int
name|dma_width
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|ena_com_mmio_reg_read_request_init
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"failed to init mmio read less\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* 	 * The PCIe configuration space revision id indicate if mmio reg 	 * read is disabled 	 */
name|readless_supported
operator|=
operator|!
operator|(
name|pci_get_revid
argument_list|(
name|pdev
argument_list|)
operator|&
name|ENA_MMIO_DISABLE_REG_READ
operator|)
expr_stmt|;
name|ena_com_set_mmio_read_mode
argument_list|(
name|ena_dev
argument_list|,
name|readless_supported
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ena_com_dev_reset
argument_list|(
name|ena_dev
argument_list|,
name|ENA_REGS_RESET_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"Can not reset device\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_mmio_read_less
goto|;
block|}
name|rc
operator|=
name|ena_com_validate_version
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"device version is too low\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_mmio_read_less
goto|;
block|}
name|dma_width
operator|=
name|ena_com_get_dma_width
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma_width
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"Invalid dma width value %d"
argument_list|,
name|dma_width
argument_list|)
expr_stmt|;
name|rc
operator|=
name|dma_width
expr_stmt|;
goto|goto
name|err_mmio_read_less
goto|;
block|}
name|adapter
operator|->
name|dma_width
operator|=
name|dma_width
expr_stmt|;
comment|/* ENA admin level init */
name|rc
operator|=
name|ena_com_admin_init
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|aenq_handlers
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"Can not initialize ena admin queue with device\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_mmio_read_less
goto|;
block|}
comment|/* 	 * To enable the msix interrupts the driver needs to know the number 	 * of queues. So the driver uses polling mode to retrieve this 	 * information 	 */
name|ena_com_set_admin_polling_mode
argument_list|(
name|ena_dev
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ena_config_host_info
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
comment|/* Get Device Attributes */
name|rc
operator|=
name|ena_com_get_dev_attr_feat
argument_list|(
name|ena_dev
argument_list|,
name|get_feat_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"Cannot get attribute for ena device rc: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|err_admin_init
goto|;
block|}
name|aenq_groups
operator|=
name|BIT
argument_list|(
name|ENA_ADMIN_LINK_CHANGE
argument_list|)
operator||
name|BIT
argument_list|(
name|ENA_ADMIN_FATAL_ERROR
argument_list|)
operator||
name|BIT
argument_list|(
name|ENA_ADMIN_WARNING
argument_list|)
operator||
name|BIT
argument_list|(
name|ENA_ADMIN_NOTIFICATION
argument_list|)
operator||
name|BIT
argument_list|(
name|ENA_ADMIN_KEEP_ALIVE
argument_list|)
expr_stmt|;
name|aenq_groups
operator|&=
name|get_feat_ctx
operator|->
name|aenq
operator|.
name|supported_groups
expr_stmt|;
name|rc
operator|=
name|ena_com_set_aenq_config
argument_list|(
name|ena_dev
argument_list|,
name|aenq_groups
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"Cannot configure aenq groups rc: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|err_admin_init
goto|;
block|}
operator|*
name|wd_active
operator|=
operator|!
operator|!
operator|(
name|aenq_groups
operator|&
name|BIT
argument_list|(
name|ENA_ADMIN_KEEP_ALIVE
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_admin_init
label|:
name|ena_com_delete_host_info
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|ena_com_admin_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|err_mmio_read_less
label|:
name|ena_com_mmio_reg_read_request_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_enable_msix_and_set_admin_interrupts
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|io_vectors
parameter_list|)
block|{
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
init|=
name|adapter
operator|->
name|ena_dev
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|ena_enable_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Error with MSI-X enablement\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|ena_setup_mgmnt_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ena_request_mgmnt_irq
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Cannot setup mgmnt queue intr\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_disable_msix
goto|;
block|}
name|ena_com_set_admin_polling_mode
argument_list|(
name|ena_dev
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|ena_com_admin_aenq_enable
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_disable_msix
label|:
name|ena_disable_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Function called on ENA_ADMIN_KEEP_ALIVE event */
end_comment

begin_function
specifier|static
name|void
name|ena_keep_alive_wd
parameter_list|(
name|void
modifier|*
name|adapter_data
parameter_list|,
name|struct
name|ena_admin_aenq_entry
modifier|*
name|aenq_e
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|ena_adapter
operator|*
operator|)
name|adapter_data
decl_stmt|;
name|struct
name|ena_admin_aenq_keep_alive_desc
modifier|*
name|desc
decl_stmt|;
name|sbintime_t
name|stime
decl_stmt|;
name|uint64_t
name|rx_drops
decl_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|ena_admin_aenq_keep_alive_desc
operator|*
operator|)
name|aenq_e
expr_stmt|;
name|rx_drops
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|desc
operator|->
name|rx_drops_high
operator|<<
literal|32
operator|)
operator||
name|desc
operator|->
name|rx_drops_low
expr_stmt|;
name|counter_u64_zero
argument_list|(
name|adapter
operator|->
name|hw_stats
operator|.
name|rx_drops
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|adapter
operator|->
name|hw_stats
operator|.
name|rx_drops
argument_list|,
name|rx_drops
argument_list|)
expr_stmt|;
name|stime
operator|=
name|getsbinuptime
argument_list|()
expr_stmt|;
name|atomic_store_rel_64
argument_list|(
operator|&
name|adapter
operator|->
name|keep_alive_timestamp
argument_list|,
name|stime
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check for keep alive expiration */
end_comment

begin_function
specifier|static
name|void
name|check_for_missing_keep_alive
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|sbintime_t
name|timestamp
decl_stmt|,
name|time
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|wd_active
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|adapter
operator|->
name|keep_alive_timeout
operator|==
literal|0
condition|)
return|return;
name|timestamp
operator|=
name|atomic_load_acq_64
argument_list|(
operator|&
name|adapter
operator|->
name|keep_alive_timestamp
argument_list|)
expr_stmt|;
name|time
operator|=
name|getsbinuptime
argument_list|()
operator|-
name|timestamp
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|time
operator|>
name|adapter
operator|->
name|keep_alive_timeout
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Keep alive watchdog timeout.\n"
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|adapter
operator|->
name|dev_stats
operator|.
name|wd_expired
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|reset_reason
operator|=
name|ENA_REGS_RESET_KEEP_ALIVE_TO
expr_stmt|;
name|adapter
operator|->
name|trigger_reset
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check if admin queue is enabled */
end_comment

begin_function
specifier|static
name|void
name|check_for_admin_com_state
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|ena_com_get_admin_running_state
argument_list|(
name|adapter
operator|->
name|ena_dev
argument_list|)
operator|==
name|false
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"ENA admin queue is not in running state!\n"
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|adapter
operator|->
name|dev_stats
operator|.
name|admin_q_pause
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|reset_reason
operator|=
name|ENA_REGS_RESET_ADMIN_TO
expr_stmt|;
name|adapter
operator|->
name|trigger_reset
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|check_missing_comp_in_queue
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|ena_ring
modifier|*
name|tx_ring
parameter_list|)
block|{
name|struct
name|bintime
name|curtime
decl_stmt|,
name|time
decl_stmt|;
name|struct
name|ena_tx_buffer
modifier|*
name|tx_buf
decl_stmt|;
name|uint32_t
name|missed_tx
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|getbinuptime
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tx_ring
operator|->
name|ring_size
condition|;
name|i
operator|++
control|)
block|{
name|tx_buf
operator|=
operator|&
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bintime_isset
argument_list|(
operator|&
name|tx_buf
operator|->
name|timestamp
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|time
operator|=
name|curtime
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|tx_buf
operator|->
name|timestamp
argument_list|)
expr_stmt|;
comment|/* Check again if packet is still waiting */
if|if
condition|(
name|unlikely
argument_list|(
name|bttosbt
argument_list|(
name|time
argument_list|)
operator|>
name|adapter
operator|->
name|missing_tx_timeout
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|tx_buf
operator|->
name|print_once
condition|)
name|ena_trace
argument_list|(
name|ENA_WARNING
argument_list|,
literal|"Found a Tx that wasn't "
literal|"completed on time, qid %d, index %d.\n"
argument_list|,
name|tx_ring
operator|->
name|qid
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tx_buf
operator|->
name|print_once
operator|=
name|true
expr_stmt|;
name|missed_tx
operator|++
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|missed_tx
operator|>
name|adapter
operator|->
name|missing_tx_threshold
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"The number of lost tx completion "
literal|"is above the threshold (%d> %d). "
literal|"Reset the device\n"
argument_list|,
name|missed_tx
argument_list|,
name|adapter
operator|->
name|missing_tx_threshold
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|reset_reason
operator|=
name|ENA_REGS_RESET_MISS_TX_CMPL
expr_stmt|;
name|adapter
operator|->
name|trigger_reset
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for TX which were not completed on time.  * Timeout is defined by "missing_tx_timeout".  * Reset will be performed if number of incompleted  * transactions exceeds "missing_tx_threshold".  */
end_comment

begin_function
specifier|static
name|void
name|check_for_missing_tx_completions
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ena_ring
modifier|*
name|tx_ring
decl_stmt|;
name|int
name|i
decl_stmt|,
name|budget
decl_stmt|,
name|rc
decl_stmt|;
comment|/* Make sure the driver doesn't turn the device in other process */
name|rmb
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|up
condition|)
return|return;
if|if
condition|(
name|adapter
operator|->
name|trigger_reset
condition|)
return|return;
if|if
condition|(
name|adapter
operator|->
name|missing_tx_timeout
operator|==
literal|0
condition|)
return|return;
name|budget
operator|=
name|adapter
operator|->
name|missing_tx_max_queues
expr_stmt|;
for|for
control|(
name|i
operator|=
name|adapter
operator|->
name|next_monitored_tx_qid
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|tx_ring
operator|=
operator|&
name|adapter
operator|->
name|tx_ring
index|[
name|i
index|]
expr_stmt|;
name|rc
operator|=
name|check_missing_comp_in_queue
argument_list|(
name|adapter
argument_list|,
name|tx_ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
return|return;
name|budget
operator|--
expr_stmt|;
if|if
condition|(
name|budget
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|adapter
operator|->
name|next_monitored_tx_qid
operator|=
name|i
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
block|}
end_function

begin_comment
comment|/* trigger deferred rx cleanup after 2 consecutive detections */
end_comment

begin_define
define|#
directive|define
name|EMPTY_RX_REFILL
value|2
end_define

begin_comment
comment|/* For the rare case where the device runs out of Rx descriptors and the  * msix handler failed to refill new Rx descriptors (due to a lack of memory  * for example).  * This case will lead to a deadlock:  * The device won't send interrupts since all the new Rx packets will be dropped  * The msix handler won't allocate new Rx descriptors so the device won't be  * able to send new packets.  *  * When such a situation is detected - execute rx cleanup task in another thread  */
end_comment

begin_function
specifier|static
name|void
name|check_for_empty_rx_ring
parameter_list|(
name|struct
name|ena_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ena_ring
modifier|*
name|rx_ring
decl_stmt|;
name|int
name|i
decl_stmt|,
name|refill_required
decl_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|up
condition|)
return|return;
if|if
condition|(
name|adapter
operator|->
name|trigger_reset
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rx_ring
operator|=
operator|&
name|adapter
operator|->
name|rx_ring
index|[
name|i
index|]
expr_stmt|;
name|refill_required
operator|=
name|ena_com_free_desc
argument_list|(
name|rx_ring
operator|->
name|ena_com_io_sq
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|refill_required
operator|==
operator|(
name|rx_ring
operator|->
name|ring_size
operator|-
literal|1
operator|)
argument_list|)
condition|)
block|{
name|rx_ring
operator|->
name|empty_rx_queue
operator|++
expr_stmt|;
if|if
condition|(
name|rx_ring
operator|->
name|empty_rx_queue
operator|>=
name|EMPTY_RX_REFILL
condition|)
block|{
name|counter_u64_add
argument_list|(
name|rx_ring
operator|->
name|rx_stats
operator|.
name|empty_rx_ring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"trigger refill for ring %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|rx_ring
operator|->
name|cmpl_tq
argument_list|,
operator|&
name|rx_ring
operator|->
name|cmpl_task
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|empty_rx_queue
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|rx_ring
operator|->
name|empty_rx_queue
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ena_timer_service
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|ena_adapter
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ena_admin_host_info
modifier|*
name|host_info
init|=
name|adapter
operator|->
name|ena_dev
operator|->
name|host_attr
operator|.
name|host_info
decl_stmt|;
name|check_for_missing_keep_alive
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|check_for_admin_com_state
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|check_for_missing_tx_completions
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|check_for_empty_rx_ring
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_info
operator|!=
name|NULL
condition|)
name|ena_update_host_info
argument_list|(
name|host_info
argument_list|,
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|adapter
operator|->
name|trigger_reset
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Trigger reset is on\n"
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|reset_tq
argument_list|,
operator|&
name|adapter
operator|->
name|reset_task
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Schedule another timeout one second from now. 	 */
name|callout_schedule_sbt
argument_list|(
operator|&
name|adapter
operator|->
name|timer_service
argument_list|,
name|SBT_1S
argument_list|,
name|SBT_1S
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_reset_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ena_com_dev_get_features_ctx
name|get_feat_ctx
decl_stmt|;
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|ena_adapter
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
init|=
name|adapter
operator|->
name|ena_dev
decl_stmt|;
name|bool
name|dev_up
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|adapter
operator|->
name|trigger_reset
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"device reset scheduled but trigger_reset is off\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sx_xlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|adapter
operator|->
name|timer_service
argument_list|)
expr_stmt|;
name|dev_up
operator|=
name|adapter
operator|->
name|up
expr_stmt|;
name|ena_com_set_admin_running_state
argument_list|(
name|ena_dev
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|ena_down
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_free_mgmnt_irq
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_disable_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_com_abort_admin_commands
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|ena_com_wait_for_abort_completion
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|ena_com_admin_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|ena_com_mmio_reg_read_request_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|reset_reason
operator|=
name|ENA_REGS_RESET_NORMAL
expr_stmt|;
name|adapter
operator|->
name|trigger_reset
operator|=
name|false
expr_stmt|;
comment|/* Finished destroy part. Restart the device */
name|rc
operator|=
name|ena_device_init
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|pdev
argument_list|,
operator|&
name|get_feat_ctx
argument_list|,
operator|&
name|adapter
operator|->
name|wd_active
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"ENA device init failed! (err: %d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|err_dev_free
goto|;
block|}
name|rc
operator|=
name|ena_enable_msix_and_set_admin_interrupts
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|num_queues
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Enable MSI-X failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_com_free
goto|;
block|}
comment|/* If the interface was up before the reset bring it up */
if|if
condition|(
name|dev_up
condition|)
block|{
name|rc
operator|=
name|ena_up
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Failed to create I/O queues\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_msix_free
goto|;
block|}
block|}
name|callout_reset_sbt
argument_list|(
operator|&
name|adapter
operator|->
name|timer_service
argument_list|,
name|SBT_1S
argument_list|,
name|SBT_1S
argument_list|,
name|ena_timer_service
argument_list|,
operator|(
name|void
operator|*
operator|)
name|adapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
return|return;
name|err_msix_free
label|:
name|ena_free_mgmnt_irq
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_disable_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_com_free
label|:
name|ena_com_admin_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|err_dev_free
label|:
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"ENA reset failed!\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|running
operator|=
name|false
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ena_attach - Device Initialization Routine  * @pdev: device information struct  *  * Returns 0 on success, otherwise on failure.  *  * ena_attach initializes an adapter identified by a device structure.  * The OS initialization, configuring of the adapter private structure,  * and a hardware reset occur.  **/
end_comment

begin_function
specifier|static
name|int
name|ena_attach
parameter_list|(
name|device_t
name|pdev
parameter_list|)
block|{
name|struct
name|ena_com_dev_get_features_ctx
name|get_feat_ctx
decl_stmt|;
specifier|static
name|int
name|version_printed
decl_stmt|;
name|struct
name|ena_adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|tx_sgl_size
init|=
literal|0
decl_stmt|;
name|uint16_t
name|rx_sgl_size
init|=
literal|0
decl_stmt|;
name|int
name|io_queue_num
decl_stmt|;
name|int
name|queue_size
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|adapter
operator|=
name|device_get_softc
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|pdev
operator|=
name|pdev
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|adapter
operator|->
name|global_mtx
argument_list|,
literal|"ENA global mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|,
literal|"ENA ioctl sx"
argument_list|)
expr_stmt|;
comment|/* Set up the timer service */
name|callout_init_mtx
argument_list|(
operator|&
name|adapter
operator|->
name|timer_service
argument_list|,
operator|&
name|adapter
operator|->
name|global_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|keep_alive_timeout
operator|=
name|DEFAULT_KEEP_ALIVE_TO
expr_stmt|;
name|adapter
operator|->
name|missing_tx_timeout
operator|=
name|DEFAULT_TX_CMP_TO
expr_stmt|;
name|adapter
operator|->
name|missing_tx_max_queues
operator|=
name|DEFAULT_TX_MONITORED_QUEUES
expr_stmt|;
name|adapter
operator|->
name|missing_tx_threshold
operator|=
name|DEFAULT_TX_CMP_THRESHOLD
expr_stmt|;
if|if
condition|(
name|version_printed
operator|++
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"%s\n"
argument_list|,
name|ena_version
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ena_allocate_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"PCI resource allocation failed!\n"
argument_list|)
expr_stmt|;
name|ena_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* Allocate memory for ena_dev structure */
name|ena_dev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ena_com_dev
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|ena_dev
operator|=
name|ena_dev
expr_stmt|;
name|ena_dev
operator|->
name|dmadev
operator|=
name|pdev
expr_stmt|;
name|ena_dev
operator|->
name|bus
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ena_bus
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Store register resources */
operator|(
operator|(
expr|struct
name|ena_bus
operator|*
operator|)
operator|(
name|ena_dev
operator|->
name|bus
operator|)
operator|)
operator|->
name|reg_bar_t
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|registers
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|ena_bus
operator|*
operator|)
operator|(
name|ena_dev
operator|->
name|bus
operator|)
operator|)
operator|->
name|reg_bar_h
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|registers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|ena_bus
operator|*
operator|)
operator|(
name|ena_dev
operator|->
name|bus
operator|)
operator|)
operator|->
name|reg_bar_h
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"failed to pmap registers bar\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_bus_free
goto|;
block|}
name|ena_dev
operator|->
name|tx_mem_queue_type
operator|=
name|ENA_ADMIN_PLACEMENT_POLICY_HOST
expr_stmt|;
comment|/* Device initialization */
name|rc
operator|=
name|ena_device_init
argument_list|(
name|adapter
argument_list|,
name|pdev
argument_list|,
operator|&
name|get_feat_ctx
argument_list|,
operator|&
name|adapter
operator|->
name|wd_active
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"ENA device init failed! (err: %d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_bus_free
goto|;
block|}
name|adapter
operator|->
name|keep_alive_timestamp
operator|=
name|getsbinuptime
argument_list|()
expr_stmt|;
name|adapter
operator|->
name|tx_offload_cap
operator|=
name|get_feat_ctx
operator|.
name|offload
operator|.
name|tx
expr_stmt|;
comment|/* Set for sure that interface is not up */
name|adapter
operator|->
name|up
operator|=
name|false
expr_stmt|;
name|memcpy
argument_list|(
name|adapter
operator|->
name|mac_addr
argument_list|,
name|get_feat_ctx
operator|.
name|dev_attr
operator|.
name|mac_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|small_copy_len
operator|=
name|ENA_DEFAULT_SMALL_PACKET_LEN
expr_stmt|;
comment|/* calculate IO queue number to create */
name|io_queue_num
operator|=
name|ena_calc_io_queue_num
argument_list|(
name|adapter
argument_list|,
operator|&
name|get_feat_ctx
argument_list|)
expr_stmt|;
name|ENA_ASSERT
argument_list|(
name|io_queue_num
operator|>
literal|0
argument_list|,
literal|"Invalid queue number: %d\n"
argument_list|,
name|io_queue_num
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_queues
operator|=
name|io_queue_num
expr_stmt|;
comment|/* calculatre ring sizes */
name|queue_size
operator|=
name|ena_calc_queue_size
argument_list|(
name|adapter
argument_list|,
operator|&
name|tx_sgl_size
argument_list|,
operator|&
name|rx_sgl_size
argument_list|,
operator|&
name|get_feat_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|queue_size
operator|<=
literal|0
operator|)
operator|||
operator|(
name|io_queue_num
operator|<=
literal|0
operator|)
condition|)
block|{
name|rc
operator|=
name|ENA_COM_FAULT
expr_stmt|;
goto|goto
name|err_com_free
goto|;
block|}
name|adapter
operator|->
name|reset_reason
operator|=
name|ENA_REGS_RESET_NORMAL
expr_stmt|;
name|adapter
operator|->
name|tx_ring_size
operator|=
name|queue_size
expr_stmt|;
name|adapter
operator|->
name|rx_ring_size
operator|=
name|queue_size
expr_stmt|;
name|adapter
operator|->
name|max_tx_sgl_size
operator|=
name|tx_sgl_size
expr_stmt|;
name|adapter
operator|->
name|max_rx_sgl_size
operator|=
name|rx_sgl_size
expr_stmt|;
comment|/* set up dma tags for rx and tx buffers */
name|rc
operator|=
name|ena_setup_tx_dma_tag
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|err_com_free
goto|;
name|rc
operator|=
name|ena_setup_rx_dma_tag
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|err_tx_tag_free
goto|;
comment|/* initialize rings basic information */
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"initalize %d io queues\n"
argument_list|,
name|io_queue_num
argument_list|)
expr_stmt|;
name|ena_init_io_rings
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* setup network interface */
name|rc
operator|=
name|ena_setup_ifnet
argument_list|(
name|pdev
argument_list|,
name|adapter
argument_list|,
operator|&
name|get_feat_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"Error with network interface setup\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_io_free
goto|;
block|}
name|rc
operator|=
name|ena_enable_msix_and_set_admin_interrupts
argument_list|(
name|adapter
argument_list|,
name|io_queue_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"Failed to enable and set the admin interrupts\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_ifp_free
goto|;
block|}
comment|/* Initialize reset task queue */
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|reset_task
argument_list|,
literal|0
argument_list|,
name|ena_reset_task
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|reset_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"ena_reset_enqueue"
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|adapter
operator|->
name|reset_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|adapter
operator|->
name|reset_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s rstq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize statistics */
name|ena_alloc_counters
argument_list|(
operator|(
name|counter_u64_t
operator|*
operator|)
operator|&
name|adapter
operator|->
name|dev_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ena_stats_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ena_alloc_counters
argument_list|(
operator|(
name|counter_u64_t
operator|*
operator|)
operator|&
name|adapter
operator|->
name|hw_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ena_hw_stats
argument_list|)
argument_list|)
expr_stmt|;
name|ena_sysctl_add_nodes
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is not active */
name|if_setdrvflagbits
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|running
operator|=
name|true
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_ifp_free
label|:
name|if_detach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|err_io_free
label|:
name|ena_free_all_io_rings_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_free_rx_dma_tag
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_tx_tag_free
label|:
name|ena_free_tx_dma_tag
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_com_free
label|:
name|ena_com_admin_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|ena_com_delete_host_info
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|ena_com_mmio_reg_read_request_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|err_bus_free
label|:
name|free
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ena_dev
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ena_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ena_detach - Device Removal Routine  * @pdev: device information struct  *  * ena_detach is called by the device subsystem to alert the driver  * that it should release a PCI device.  **/
end_comment

begin_function
specifier|static
name|int
name|ena_detach
parameter_list|(
name|device_t
name|pdev
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
init|=
name|adapter
operator|->
name|ena_dev
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Make sure VLANS are not using driver */
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"VLAN is in use, detach first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Free reset task and callout */
name|callout_drain
argument_list|(
operator|&
name|adapter
operator|->
name|timer_service
argument_list|)
expr_stmt|;
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|adapter
operator|->
name|reset_tq
argument_list|,
operator|&
name|adapter
operator|->
name|reset_task
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain
argument_list|(
name|adapter
operator|->
name|reset_tq
argument_list|,
operator|&
name|adapter
operator|->
name|reset_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|adapter
operator|->
name|reset_tq
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
name|ena_down
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
name|ena_free_all_io_rings_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_free_counters
argument_list|(
operator|(
name|counter_u64_t
operator|*
operator|)
operator|&
name|adapter
operator|->
name|hw_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ena_hw_stats
argument_list|)
argument_list|)
expr_stmt|;
name|ena_free_counters
argument_list|(
operator|(
name|counter_u64_t
operator|*
operator|)
operator|&
name|adapter
operator|->
name|dev_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ena_stats_dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|rss_support
condition|)
name|ena_com_rss_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ena_free_rx_dma_tag
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Unmapped RX DMA tag associations\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ena_free_tx_dma_tag
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"Unmapped TX DMA tag associations\n"
argument_list|)
expr_stmt|;
comment|/* Reset the device only if the device is running. */
if|if
condition|(
name|adapter
operator|->
name|running
condition|)
name|ena_com_dev_reset
argument_list|(
name|ena_dev
argument_list|,
name|adapter
operator|->
name|reset_reason
argument_list|)
expr_stmt|;
name|ena_com_delete_host_info
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|ena_free_irqs
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ena_com_abort_admin_commands
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|ena_com_wait_for_abort_completion
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|ena_com_admin_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|ena_com_mmio_reg_read_request_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|ena_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|adapter
operator|->
name|global_mtx
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|adapter
operator|->
name|ioctl_sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ena_dev
operator|->
name|bus
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ena_dev
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ena_dev
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_detach
argument_list|(
name|pdev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  ******************************** AENQ Handlers *******************************  *****************************************************************************/
end_comment

begin_comment
comment|/**  * ena_update_on_link_change:  * Notify the network interface about the change in link status  **/
end_comment

begin_function
specifier|static
name|void
name|ena_update_on_link_change
parameter_list|(
name|void
modifier|*
name|adapter_data
parameter_list|,
name|struct
name|ena_admin_aenq_entry
modifier|*
name|aenq_e
parameter_list|)
block|{
name|struct
name|ena_adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|ena_adapter
operator|*
operator|)
name|adapter_data
decl_stmt|;
name|struct
name|ena_admin_aenq_link_change_desc
modifier|*
name|aenq_desc
decl_stmt|;
name|int
name|status
decl_stmt|;
name|if_t
name|ifp
decl_stmt|;
name|aenq_desc
operator|=
operator|(
expr|struct
name|ena_admin_aenq_link_change_desc
operator|*
operator|)
name|aenq_e
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|status
operator|=
name|aenq_desc
operator|->
name|flags
operator|&
name|ENA_ADMIN_AENQ_LINK_CHANGE_DESC_LINK_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"link is UP\n"
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"link is DOWN\n"
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|pdev
argument_list|,
literal|"invalid value recvd\n"
argument_list|)
expr_stmt|;
name|BUG
argument_list|()
expr_stmt|;
block|}
name|adapter
operator|->
name|link_status
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This handler will called for unknown event group or unimplemented handlers  **/
end_comment

begin_function
specifier|static
name|void
name|unimplemented_aenq_handler
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|ena_admin_aenq_entry
modifier|*
name|aenq_e
parameter_list|)
block|{
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ena_aenq_handlers
name|aenq_handlers
init|=
block|{
operator|.
name|handlers
operator|=
block|{
index|[
name|ENA_ADMIN_LINK_CHANGE
index|]
operator|=
name|ena_update_on_link_change
block|,
index|[
name|ENA_ADMIN_KEEP_ALIVE
index|]
operator|=
name|ena_keep_alive_wd
block|,     }
block|,
operator|.
name|unimplemented_handler
operator|=
name|unimplemented_aenq_handler
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|ena_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ena_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ena_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ena_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ena_driver
init|=
block|{
literal|"ena"
block|,
name|ena_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ena_adapter
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|ena_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ena
argument_list|,
name|pci
argument_list|,
name|ena_driver
argument_list|,
name|ena_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ena
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ena
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*********************************************************************/
end_comment

end_unit

