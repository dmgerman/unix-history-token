begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Cronyx-Tau32-PCI adapter driver for FreeBSD.  *  * Copyright (C) 2003-2005 Cronyx Engineering.  * Copyright (C) 2003-2005 Kurakin Roman,<rik@FreeBSD.org>  *  * This software is distributed with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Authors grant any other persons or organisations a permission to use,  * modify and redistribute this software in source and binary forms,  * as long as this message is kept with the software, all derivative  * works or modified versions.  *  * $Cronyx: if_ce.c,v 1.9.2.8 2005/11/21 14:17:44 rik Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
end_if

begin_define
define|#
directive|define
name|NPCI
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|504000
end_if

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|501000
end_if

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|"opt_ng_cronyx.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH_CRONYX
end_ifdef

begin_include
include|#
directive|include
file|"opt_netgraph.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NETGRAPH
end_ifndef

begin_error
error|#
directive|error
error|#option	NETGRAPH missed from configuration
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<dev/ce/ng_ce.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_sppp.h>
end_include

begin_define
define|#
directive|define
name|PP_CISCO
value|IFF_LINK2
end_define

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/cx/machdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/ce/ceddk.h>
end_include

begin_include
include|#
directive|include
file|<machine/cserial.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_comment
comment|/* If we don't have Cronyx's sppp version, we don't have fr support via sppp */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PP_FR
end_ifndef

begin_define
define|#
directive|define
name|PP_FR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IFP2SP
end_ifndef

begin_define
define|#
directive|define
name|IFP2SP
parameter_list|(
name|ifp
parameter_list|)
value|((struct sppp*)ifp)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SP2IFP
end_ifndef

begin_define
define|#
directive|define
name|SP2IFP
parameter_list|(
name|sp
parameter_list|)
value|((struct ifnet*)sp)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCIR_BAR
end_ifndef

begin_define
define|#
directive|define
name|PCIR_BAR
parameter_list|(
name|x
parameter_list|)
value|(PCIR_MAPS + (x) * 4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* define as our previous return value */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BUS_PROBE_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|BUS_PROBE_DEFAULT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CE_DEBUG
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|({if (d->chan->debug) {\ 				printf ("%s: ", d->name); printf s;}})
end_define

begin_define
define|#
directive|define
name|CE_DEBUG2
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|({if (d->chan->debug>1) {\ 				printf ("%s: ", d->name); printf s;}})
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CALLOUT_MPSAFE
end_ifndef

begin_define
define|#
directive|define
name|CALLOUT_MPSAFE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IF_DRAIN
end_ifndef

begin_define
define|#
directive|define
name|IF_DRAIN
parameter_list|(
name|ifq
parameter_list|)
value|do {		\ 	struct mbuf *m;			\ 	for (;;) {			\ 		IF_DEQUEUE(ifq, m);	\ 		if (m == NULL)		\ 			break;		\ 		m_freem(m);		\ 	}				\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_IF_QLEN
end_ifndef

begin_define
define|#
directive|define
name|_IF_QLEN
parameter_list|(
name|ifq
parameter_list|)
value|((ifq)->ifq_len)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|callout_drain
end_ifndef

begin_define
define|#
directive|define
name|callout_drain
value|callout_stop
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|504000
end_if

begin_define
define|#
directive|define
name|CE_LOCK_NAME
value|"ceX"
end_define

begin_decl_stmt
specifier|static
name|int
name|ce_mpsafenet
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.ce.mpsafenet"
argument_list|,
operator|&
name|ce_mpsafenet
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|ce
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Cronyx Tau32-PCI Adapters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_ce
argument_list|,
name|OID_AUTO
argument_list|,
name|mpsafenet
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ce_mpsafenet
argument_list|,
literal|0
argument_list|,
literal|"Enable/disable MPSAFE network support for Cronyx Tau32-PCI Adapters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CE_LOCK
parameter_list|(
name|_bd
parameter_list|)
value|do { \ 				    if (ce_mpsafenet) \ 					mtx_lock (&(_bd)->ce_mtx); \ 				} while (0)
end_define

begin_define
define|#
directive|define
name|CE_UNLOCK
parameter_list|(
name|_bd
parameter_list|)
value|do { \ 				    if (ce_mpsafenet) \ 					mtx_unlock (&(_bd)->ce_mtx); \ 				} while (0)
end_define

begin_define
define|#
directive|define
name|CE_LOCK_ASSERT
parameter_list|(
name|_bd
parameter_list|)
value|do { \ 				    if (ce_mpsafenet) \ 					mtx_assert (&(_bd)->ce_mtx, MA_OWNED); \ 				} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|ce_mpsafenet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CE_LOCK
parameter_list|(
name|_bd
parameter_list|)
value|do {} while (0&& (_bd)&& ce_mpsafenet)
end_define

begin_define
define|#
directive|define
name|CE_UNLOCK
parameter_list|(
name|_bd
parameter_list|)
value|do {} while (0&& (_bd)&& ce_mpsafenet)
end_define

begin_define
define|#
directive|define
name|CE_LOCK_ASSERT
parameter_list|(
name|_bd
parameter_list|)
value|do {} while (0&& (_bd)&& ce_mpsafenet)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|185
end_define

begin_decl_stmt
specifier|static
name|int
name|ce_probe
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ce_attach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ce_detach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ce_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ce_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ce_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ce_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|_ce_dma_mem_t
block|{
name|unsigned
name|long
name|phys
decl_stmt|;
name|void
modifier|*
name|virt
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|bus_dma_tag_t
name|dmat
decl_stmt|;
name|bus_dmamap_t
name|mapp
decl_stmt|;
endif|#
directive|endif
block|}
name|ce_dma_mem_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_drv_t
block|{
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|int
name|running
decl_stmt|;
name|ce_board_t
modifier|*
name|board
decl_stmt|;
name|ce_chan_t
modifier|*
name|chan
decl_stmt|;
name|struct
name|ifqueue
name|rqueue
decl_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|char
name|nodename
index|[
name|NG_NODELEN
operator|+
literal|1
index|]
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|hook_p
name|debug_hook
decl_stmt|;
name|node_p
name|node
decl_stmt|;
name|struct
name|ifqueue
name|queue
decl_stmt|;
name|struct
name|ifqueue
name|hi_queue
decl_stmt|;
name|short
name|timeout
decl_stmt|;
name|struct
name|callout
name|timeout_handle
decl_stmt|;
else|#
directive|else
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|struct
name|cdev
modifier|*
name|devt
decl_stmt|;
else|#
directive|else
comment|/* __FreeBSD_version< 500000 */
name|dev_t
name|devt
decl_stmt|;
endif|#
directive|endif
name|ce_dma_mem_t
name|dmamem
decl_stmt|;
block|}
name|drv_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_bdrv_t
block|{
name|ce_board_t
modifier|*
name|board
decl_stmt|;
name|struct
name|resource
modifier|*
name|ce_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|ce_irq
decl_stmt|;
name|void
modifier|*
name|ce_intrhand
decl_stmt|;
name|ce_dma_mem_t
name|dmamem
decl_stmt|;
name|drv_t
name|channel
index|[
name|NCHAN
index|]
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|504000
name|struct
name|mtx
name|ce_mtx
decl_stmt|;
endif|#
directive|endif
block|}
name|bdrv_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|driver_t
name|ce_driver
init|=
block|{
literal|"ce"
block|,
name|ce_methods
block|,
sizeof|sizeof
argument_list|(
name|bdrv_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ce_devclass
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ce_receive
parameter_list|(
name|ce_chan_t
modifier|*
name|c
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ce_transmit
parameter_list|(
name|ce_chan_t
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|attachment
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ce_error
parameter_list|(
name|ce_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ce_up
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ce_start
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ce_down
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ce_watchdog
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|ng_type
name|typestruct
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|ce_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ce_tlf
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ce_tls
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ce_ifwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ce_sioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ce_initialize
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|ce_board_t
modifier|*
name|adapter
index|[
name|NBRD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|drv_t
modifier|*
name|channel
index|[
name|NBRD
operator|*
name|NCHAN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout
name|led_timo
index|[
name|NBRD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout
name|timeout_handle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ce_destroy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_function_decl
specifier|static
name|int
name|ce_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ce_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ce_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|ce_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ce_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ce_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ce_cdevsw
init|=
block|{
name|ce_open
block|,
name|ce_close
block|,
name|noread
block|,
name|nowrite
block|,
name|ce_ioctl
block|,
name|nopoll
block|,
name|nommap
block|,
name|nostrategy
block|,
literal|"ce"
block|,
name|CDEV_MAJOR
block|,
name|nodump
block|,
name|nopsize
block|,
name|D_NAGGED
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|__FreeBSD_version
operator|==
literal|500000
end_elif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ce_cdevsw
init|=
block|{
name|ce_open
block|,
name|ce_close
block|,
name|noread
block|,
name|nowrite
block|,
name|ce_ioctl
block|,
name|nopoll
block|,
name|nommap
block|,
name|nostrategy
block|,
literal|"ce"
block|,
name|CDEV_MAJOR
block|,
name|nodump
block|,
name|nopsize
block|,
name|D_NAGGED
block|, 	}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|__FreeBSD_version
operator|<=
literal|501000
end_elif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ce_cdevsw
init|=
block|{
operator|.
name|d_open
operator|=
name|ce_open
block|,
operator|.
name|d_close
operator|=
name|ce_close
block|,
operator|.
name|d_read
operator|=
name|noread
block|,
operator|.
name|d_write
operator|=
name|nowrite
block|,
operator|.
name|d_ioctl
operator|=
name|ce_ioctl
block|,
operator|.
name|d_poll
operator|=
name|nopoll
block|,
operator|.
name|d_mmap
operator|=
name|nommap
block|,
operator|.
name|d_strategy
operator|=
name|nostrategy
block|,
operator|.
name|d_name
operator|=
literal|"ce"
block|,
operator|.
name|d_maj
operator|=
name|CDEV_MAJOR
block|,
operator|.
name|d_dump
operator|=
name|nodump
block|,
operator|.
name|d_flags
operator|=
name|D_NAGGED
block|, }
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|502103
end_elif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ce_cdevsw
init|=
block|{
operator|.
name|d_open
operator|=
name|ce_open
block|,
operator|.
name|d_close
operator|=
name|ce_close
block|,
operator|.
name|d_ioctl
operator|=
name|ce_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"ce"
block|,
operator|.
name|d_maj
operator|=
name|CDEV_MAJOR
block|,
operator|.
name|d_flags
operator|=
name|D_NAGGED
block|, }
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|600000
end_elif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ce_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|ce_open
block|,
operator|.
name|d_close
operator|=
name|ce_close
block|,
operator|.
name|d_ioctl
operator|=
name|ce_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"ce"
block|,
operator|.
name|d_maj
operator|=
name|CDEV_MAJOR
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|, }
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __FreeBSD_version>= 600000 */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ce_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|ce_open
block|,
operator|.
name|d_close
operator|=
name|ce_close
block|,
operator|.
name|d_ioctl
operator|=
name|ce_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"ce"
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Print the mbuf chain, for debug purposes only.  */
end_comment

begin_function
specifier|static
name|void
name|printmbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|printf
argument_list|(
literal|"mbuf:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|printf
argument_list|(
literal|" HDR %d:"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|printf
argument_list|(
literal|" EXT:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make an mbuf from data.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|makembuf
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
literal|0
return|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ce_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|TAU32_PCI_VENDOR_ID
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|TAU32_PCI_DEVICE_ID
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Cronyx-Tau32-PCI serial adapter"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ce_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBRD
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|adapter
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NCHAN
condition|;
operator|++
name|k
control|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|ce_destroy
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|=
name|channel
index|[
name|i
operator|*
name|NCHAN
operator|+
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|CE_LOCK
argument_list|(
operator|(
name|bdrv_t
operator|*
operator|)
name|d
operator|->
name|board
operator|->
name|sys
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|chan
operator|->
name|type
condition|)
block|{
case|case
name|T_E1
case|:
name|ce_e1_timer
argument_list|(
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|CE_UNLOCK
argument_list|(
operator|(
name|bdrv_t
operator|*
operator|)
name|d
operator|->
name|board
operator|->
name|sys
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ce_destroy
condition|)
name|callout_reset
argument_list|(
operator|&
name|timeout_handle
argument_list|,
name|hz
argument_list|,
name|ce_timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ce_led_off
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ce_board_t
modifier|*
name|b
init|=
name|arg
decl_stmt|;
name|bdrv_t
modifier|*
name|bd
init|=
operator|(
name|bdrv_t
operator|*
operator|)
name|b
operator|->
name|sys
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|ce_destroy
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|TAU32_LedSet
argument_list|(
name|b
operator|->
name|ddk
operator|.
name|pControllerObject
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ce_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|arg
decl_stmt|;
name|ce_board_t
modifier|*
name|b
init|=
name|bd
operator|->
name|board
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
operator|&&
name|defined
name|NETGRAPH
name|int
name|error
decl_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|ce_destroy
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
comment|/* Turn LED on. */
name|TAU32_LedSet
argument_list|(
name|b
operator|->
name|ddk
operator|.
name|pControllerObject
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAU32_HandleInterrupt
argument_list|(
name|b
operator|->
name|ddk
operator|.
name|pControllerObject
argument_list|)
expr_stmt|;
comment|/* Turn LED off 50 msec later. */
name|callout_reset
argument_list|(
operator|&
name|led_timo
index|[
name|b
operator|->
name|num
index|]
argument_list|,
name|hz
operator|/
literal|20
argument_list|,
name|ce_led_off
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Pass packets in a lock-free state */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAN
operator|&&
name|b
operator|->
name|chan
index|[
name|i
index|]
operator|.
name|type
condition|;
name|i
operator|++
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|b
operator|->
name|chan
index|[
name|i
index|]
operator|.
name|sys
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|running
condition|)
continue|continue;
while|while
condition|(
name|_IF_QLEN
argument_list|(
operator|&
name|d
operator|->
name|rqueue
argument_list|)
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|d
operator|->
name|rqueue
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NETGRAPH
if|if
condition|(
name|d
operator|->
name|hook
condition|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|d
operator|->
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|ng_queue_data
argument_list|(
name|d
operator|->
name|hook
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|IF_DRAIN
argument_list|(
operator|&
name|d
operator|->
name|rqueue
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|sppp_input
argument_list|(
name|d
operator|->
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
end_if

begin_function
specifier|static
name|void
name|ce_bus_dmamap_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|unsigned
name|long
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"too many DMA segments, %d should be 1"
operator|,
name|nseg
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BUS_DMA_ZERO
end_ifndef

begin_define
define|#
directive|define
name|BUS_DMA_ZERO
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ce_bus_dma_mem_alloc
parameter_list|(
name|int
name|bnum
parameter_list|,
name|int
name|cnum
parameter_list|,
name|ce_dma_mem_t
modifier|*
name|dmem
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dmem
operator|->
name|size
argument_list|,
literal|1
argument_list|,
name|dmem
operator|->
name|size
argument_list|,
literal|0
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502000
name|NULL
argument_list|,
name|NULL
argument_list|,
endif|#
directive|endif
operator|&
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|cnum
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"ce%d-%d: "
argument_list|,
name|bnum
argument_list|,
name|cnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ce%d: "
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"couldn't allocate tag for dma memory\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dmem
operator|->
name|virt
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|dmem
operator|->
name|mapp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|cnum
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"ce%d-%d: "
argument_list|,
name|bnum
argument_list|,
name|cnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ce%d: "
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"couldn't allocate mem for dma memory\n"
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|mapp
argument_list|,
name|dmem
operator|->
name|virt
argument_list|,
name|dmem
operator|->
name|size
argument_list|,
name|ce_bus_dmamap_addr
argument_list|,
operator|&
name|dmem
operator|->
name|phys
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|cnum
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"ce%d-%d: "
argument_list|,
name|bnum
argument_list|,
name|cnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ce%d: "
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"couldn't load mem map for dma memory\n"
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|virt
argument_list|,
name|dmem
operator|->
name|mapp
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502000
name|bzero
argument_list|(
name|dmem
operator|->
name|virt
argument_list|,
name|dmem
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ce_bus_dma_mem_free
parameter_list|(
name|ce_dma_mem_t
modifier|*
name|dmem
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|mapp
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|virt
argument_list|,
name|dmem
operator|->
name|mapp
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|ce_bus_dma_mem_alloc
parameter_list|(
name|int
name|bnum
parameter_list|,
name|int
name|cnum
parameter_list|,
name|ce_dma_mem_t
modifier|*
name|dmem
parameter_list|)
block|{
name|dmem
operator|->
name|virt
operator|=
name|contigmalloc
argument_list|(
name|dmem
operator|->
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmem
operator|->
name|virt
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|cnum
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"ce%d-%d: "
argument_list|,
name|bnum
argument_list|,
name|cnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ce%d: "
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"couldn't allocate dma memory\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dmem
operator|->
name|phys
operator|=
name|vtophys
argument_list|(
name|dmem
operator|->
name|virt
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dmem
operator|->
name|virt
argument_list|,
name|dmem
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ce_bus_dma_mem_free
parameter_list|(
name|ce_dma_mem_t
modifier|*
name|dmem
parameter_list|)
block|{
name|contigfree
argument_list|(
name|dmem
operator|->
name|virt
argument_list|,
name|dmem
operator|->
name|size
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Called if the probe succeeded.  */
end_comment

begin_function
specifier|static
name|int
name|ce_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|504000
name|char
modifier|*
name|ce_ln
init|=
name|CE_LOCK_NAME
decl_stmt|;
endif|#
directive|endif
name|vm_offset_t
name|vbase
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|error
decl_stmt|;
name|ce_board_t
modifier|*
name|b
decl_stmt|;
name|ce_chan_t
modifier|*
name|c
decl_stmt|;
name|drv_t
modifier|*
name|d
decl_stmt|;
name|int
name|s
decl_stmt|;
name|b
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ce_board_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|printf
argument_list|(
literal|"ce%d: couldn't allocate memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|bzero
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|ce_board_t
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|ddk
operator|.
name|sys
operator|=
operator|&
name|b
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|440000
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bd
operator|->
name|dmamem
operator|.
name|size
operator|=
name|TAU32_ControllerObjectSize
expr_stmt|;
if|if
condition|(
operator|!
name|ce_bus_dma_mem_alloc
argument_list|(
name|unit
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bd
operator|->
name|dmamem
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|b
operator|->
name|ddk
operator|.
name|pControllerObject
operator|=
name|bd
operator|->
name|dmamem
operator|.
name|virt
expr_stmt|;
name|bd
operator|->
name|board
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|sys
operator|=
name|bd
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bd
operator|->
name|ce_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bd
operator|->
name|ce_res
condition|)
block|{
name|printf
argument_list|(
literal|"ce%d: cannot map memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ce_bus_dma_mem_free
argument_list|(
operator|&
name|bd
operator|->
name|dmamem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|vbase
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|bd
operator|->
name|ce_res
argument_list|)
expr_stmt|;
name|b
operator|->
name|ddk
operator|.
name|PciBar1VirtualAddress
operator|=
operator|(
name|void
operator|*
operator|)
name|vbase
expr_stmt|;
name|b
operator|->
name|ddk
operator|.
name|ControllerObjectPhysicalAddress
operator|=
name|bd
operator|->
name|dmamem
operator|.
name|phys
expr_stmt|;
name|b
operator|->
name|ddk
operator|.
name|pErrorNotifyCallback
operator|=
name|ce_error_callback
expr_stmt|;
name|b
operator|->
name|ddk
operator|.
name|pStatusNotifyCallback
operator|=
name|ce_status_callback
expr_stmt|;
name|b
operator|->
name|num
operator|=
name|unit
expr_stmt|;
name|TAU32_BeforeReset
argument_list|(
operator|&
name|b
operator|->
name|ddk
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|TAU32_PCI_RESET_ADDRESS
argument_list|,
name|TAU32_PCI_RESET_ON
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|TAU32_PCI_RESET_ADDRESS
argument_list|,
name|TAU32_PCI_RESET_OFF
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAU32_Initialize
argument_list|(
operator|&
name|b
operator|->
name|ddk
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ce%d: init adapter error 0x%08x, bus dead bits 0x%08lx\n"
argument_list|,
name|unit
argument_list|,
name|b
operator|->
name|ddk
operator|.
name|InitErrors
argument_list|,
name|b
operator|->
name|ddk
operator|.
name|DeadBits
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|bd
operator|->
name|ce_res
argument_list|)
expr_stmt|;
name|ce_bus_dma_mem_free
argument_list|(
operator|&
name|bd
operator|->
name|dmamem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ce_init_board
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|ce_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bd
operator|->
name|ce_irq
condition|)
block|{
name|printf
argument_list|(
literal|"ce%d: cannot map interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|bd
operator|->
name|ce_res
argument_list|)
expr_stmt|;
name|ce_bus_dma_mem_free
argument_list|(
operator|&
name|bd
operator|->
name|dmamem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|callout_init
argument_list|(
operator|&
name|led_timo
index|[
name|unit
index|]
argument_list|,
name|ce_mpsafenet
condition|?
name|CALLOUT_MPSAFE
else|:
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|callout_init
argument_list|(
operator|&
name|led_timo
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|bd
operator|->
name|ce_irq
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500013
name|INTR_TYPE_NET
operator||
operator|(
name|ce_mpsafenet
condition|?
name|INTR_MPSAFE
else|:
literal|0
operator|)
argument_list|,
else|#
directive|else
name|INTR_TYPE_NET
argument_list|,
endif|#
directive|endif
name|NULL
argument_list|,
name|ce_intr
argument_list|,
name|bd
argument_list|,
operator|&
name|bd
operator|->
name|ce_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ce%d: cannot set up irq\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|bd
operator|->
name|ce_irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|bd
operator|->
name|ce_res
argument_list|)
expr_stmt|;
name|ce_bus_dma_mem_free
argument_list|(
operator|&
name|bd
operator|->
name|dmamem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
switch|switch
condition|(
name|b
operator|->
name|ddk
operator|.
name|Model
condition|)
block|{
case|case
literal|1
case|:
name|strcpy
argument_list|(
name|b
operator|->
name|name
argument_list|,
name|TAU32_BASE_NAME
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|strcpy
argument_list|(
name|b
operator|->
name|name
argument_list|,
name|TAU32_LITE_NAME
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strcpy
argument_list|(
name|b
operator|->
name|name
argument_list|,
name|TAU32_ADPCM_NAME
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcpy
argument_list|(
name|b
operator|->
name|name
argument_list|,
name|TAU32_UNKNOWN_NAME
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"ce%d: %s\n"
argument_list|,
name|unit
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|c
operator|->
name|num
operator|=
operator|(
name|c
operator|-
name|b
operator|->
name|chan
operator|)
expr_stmt|;
name|c
operator|->
name|board
operator|=
name|b
expr_stmt|;
name|d
operator|=
operator|&
name|bd
operator|->
name|channel
index|[
name|c
operator|->
name|num
index|]
expr_stmt|;
name|d
operator|->
name|dmamem
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|ce_buf_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce_bus_dma_mem_alloc
argument_list|(
name|unit
argument_list|,
name|c
operator|->
name|num
argument_list|,
operator|&
name|d
operator|->
name|dmamem
argument_list|)
condition|)
continue|continue;
name|channel
index|[
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
index|]
operator|=
name|d
expr_stmt|;
name|sprintf
argument_list|(
name|d
operator|->
name|name
argument_list|,
literal|"ce%d.%d"
argument_list|,
name|b
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
name|d
operator|->
name|board
operator|=
name|b
expr_stmt|;
name|d
operator|->
name|chan
operator|=
name|c
expr_stmt|;
name|c
operator|->
name|sys
operator|=
name|d
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
if|if
condition|(
name|c
operator|->
name|sys
operator|==
name|NULL
condition|)
continue|continue;
name|d
operator|=
name|c
operator|->
name|sys
expr_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
if|if
condition|(
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
operator|&
name|d
operator|->
name|node
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot make common node\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|d
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_NODE_SET_PRIVATE
argument_list|(
name|d
operator|->
name|node
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|d
operator|->
name|timeout_handle
argument_list|,
name|ce_mpsafenet
condition|?
name|CALLOUT_MPSAFE
else|:
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|node
operator|->
name|private
operator|=
name|d
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|d
operator|->
name|nodename
argument_list|,
literal|"%s%d"
argument_list|,
name|NG_CE_NODE_TYPE
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_name_node
argument_list|(
name|d
operator|->
name|node
argument_list|,
name|d
operator|->
name|nodename
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot name node\n"
argument_list|,
name|d
operator|->
name|nodename
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_NODE_UNREF
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
else|#
directive|else
name|ng_rmnode
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|ng_unref
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
name|d
operator|->
name|queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|d
operator|->
name|hi_queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|d
operator|->
name|rqueue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|mtx_init
argument_list|(
operator|&
name|d
operator|->
name|queue
operator|.
name|ifq_mtx
argument_list|,
literal|"ce_queue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|d
operator|->
name|hi_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"ce_queue_hi"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|d
operator|->
name|rqueue
operator|.
name|ifq_mtx
argument_list|,
literal|"ce_rqueue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/*NETGRAPH*/
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|600031
name|d
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_PPP
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|ifp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sppp
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|d
operator|->
name|ifp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sppp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|ifp
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot if_alloc() interface\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|d
operator|->
name|ifp
operator|->
name|if_softc
operator|=
name|d
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|501000
name|if_initname
argument_list|(
name|d
operator|->
name|ifp
argument_list|,
literal|"ce"
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|ifp
operator|->
name|if_unit
operator|=
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_name
operator|=
literal|"ce"
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|ifp
operator|->
name|if_mtu
operator|=
name|PP_MTU
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502125
if|if
condition|(
operator|!
name|ce_mpsafenet
condition|)
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_NEEDSGIANT
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|ifp
operator|->
name|if_ioctl
operator|=
name|ce_sioctl
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_start
operator|=
name|ce_ifstart
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_watchdog
operator|=
name|ce_ifwatchdog
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_init
operator|=
name|ce_initialize
expr_stmt|;
name|d
operator|->
name|rqueue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|mtx_init
argument_list|(
operator|&
name|d
operator|->
name|rqueue
operator|.
name|ifq_mtx
argument_list|,
literal|"ce_rqueue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sppp_attach
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_tlf
operator|=
name|ce_tlf
expr_stmt|;
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_tls
operator|=
name|ce_tls
expr_stmt|;
comment|/* If BPF is in the kernel, call the attach for it. 		 * The header size of PPP or Cisco/HDLC is 4 bytes. */
name|bpfattach
argument_list|(
name|d
operator|->
name|ifp
argument_list|,
name|DLT_PPP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*NETGRAPH*/
name|ce_start_chan
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|d
operator|->
name|dmamem
operator|.
name|virt
argument_list|,
name|d
operator|->
name|dmamem
operator|.
name|phys
argument_list|)
expr_stmt|;
comment|/* Register callback functions. */
name|ce_register_transmit
argument_list|(
name|c
argument_list|,
operator|&
name|ce_transmit
argument_list|)
expr_stmt|;
name|ce_register_receive
argument_list|(
name|c
argument_list|,
operator|&
name|ce_receive
argument_list|)
expr_stmt|;
name|ce_register_error
argument_list|(
name|c
argument_list|,
operator|&
name|ce_error
argument_list|)
expr_stmt|;
name|d
operator|->
name|devt
operator|=
name|make_dev
argument_list|(
operator|&
name|ce_cdevsw
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ce%d"
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|504000
name|ce_ln
index|[
literal|2
index|]
operator|=
literal|'0'
operator|+
name|unit
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|bd
operator|->
name|ce_mtx
argument_list|,
name|ce_ln
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|TAU32_EnableInterrupts
argument_list|(
name|b
operator|->
name|ddk
operator|.
name|pControllerObject
argument_list|)
expr_stmt|;
name|adapter
index|[
name|unit
index|]
operator|=
name|b
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ce_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ce_board_t
modifier|*
name|b
init|=
name|bd
operator|->
name|board
decl_stmt|;
name|ce_chan_t
modifier|*
name|c
decl_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|504000
name|KASSERT
argument_list|(
name|mtx_initialized
argument_list|(
operator|&
name|bd
operator|->
name|ce_mtx
argument_list|)
argument_list|,
operator|(
literal|"ce mutex not initialized"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
comment|/* Check if the device is busy (open). */
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
name|drv_t
operator|*
operator|)
name|c
operator|->
name|sys
decl_stmt|;
comment|/* XXX Non existen chan! */
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|chan
condition|)
continue|continue;
if|if
condition|(
name|d
operator|->
name|running
condition|)
block|{
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
block|}
comment|/* Ok, we can unload driver */
comment|/* At first we should disable interrupts */
name|ce_destroy
operator|=
literal|1
expr_stmt|;
name|TAU32_DisableInterrupts
argument_list|(
name|b
operator|->
name|ddk
operator|.
name|pControllerObject
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|led_timo
index|[
name|b
operator|->
name|num
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
name|drv_t
operator|*
operator|)
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|chan
condition|)
continue|continue;
ifndef|#
directive|ifndef
name|NETGRAPH
comment|/* Detach from the packet filter list of interfaces. */
name|bpfdetach
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* Detach from the sync PPP list. */
name|sppp_detach
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* Detach from the system list of interfaces. */
name|if_detach
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|600031
name|if_free
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|d
operator|->
name|ifp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IF_DRAIN
argument_list|(
operator|&
name|d
operator|->
name|rqueue
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|mtx_destroy
argument_list|(
operator|&
name|d
operator|->
name|rqueue
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
if|if
condition|(
name|d
operator|->
name|node
condition|)
block|{
name|ng_rmnode_self
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|d
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
block|}
name|IF_DRAIN
argument_list|(
operator|&
name|d
operator|->
name|rqueue
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|d
operator|->
name|queue
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|d
operator|->
name|hi_queue
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|d
operator|->
name|rqueue
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
else|#
directive|else
name|ng_rmnode
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|d
operator|->
name|node
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|destroy_dev
argument_list|(
name|d
operator|->
name|devt
argument_list|)
expr_stmt|;
block|}
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|led_timo
index|[
name|b
operator|->
name|num
index|]
argument_list|)
expr_stmt|;
comment|/* Disable the interrupt request. */
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|bd
operator|->
name|ce_irq
argument_list|,
name|bd
operator|->
name|ce_intrhand
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|bd
operator|->
name|ce_irq
argument_list|)
expr_stmt|;
name|TAU32_DestructiveHalt
argument_list|(
name|b
operator|->
name|ddk
operator|.
name|pControllerObject
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|bd
operator|->
name|ce_res
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
name|drv_t
operator|*
operator|)
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|chan
condition|)
continue|continue;
name|channel
index|[
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Deallocate buffers. */
name|ce_bus_dma_mem_free
argument_list|(
operator|&
name|d
operator|->
name|dmamem
argument_list|)
expr_stmt|;
block|}
name|adapter
index|[
name|b
operator|->
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|ce_bus_dma_mem_free
argument_list|(
operator|&
name|bd
operator|->
name|dmamem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|504000
name|mtx_destroy
argument_list|(
operator|&
name|bd
operator|->
name|ce_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NETGRAPH
end_ifndef

begin_function
specifier|static
name|void
name|ce_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|board
operator|->
name|sys
decl_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ce_ifwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|ce_watchdog
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ce_tlf
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|SP2IFP
argument_list|(
name|sp
argument_list|)
operator|->
name|if_softc
decl_stmt|;
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ce_tlf\n"
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|pp_down
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ce_tls
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|SP2IFP
argument_list|(
name|sp
argument_list|)
operator|->
name|if_softc
decl_stmt|;
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ce_tls\n"
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|pp_up
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|ce_sioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|board
operator|->
name|sys
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|,
name|was_up
decl_stmt|,
name|should_be_up
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|600034
name|was_up
operator|=
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
expr_stmt|;
else|#
directive|else
name|was_up
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|sppp_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
operator|)
condition|)
name|d
operator|->
name|chan
operator|->
name|debug
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|chan
operator|->
name|debug
condition|)
name|d
operator|->
name|chan
operator|->
name|debug
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl 0x%lx\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SIOCADDMULTI
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl SIOCADDMULTI\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SIOCDELMULTI
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl SIOCDELMULTI\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SIOCSIFFLAGS
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl SIOCSIFFLAGS\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl SIOCSIFADDR\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* We get here only in case of SIFFLAGS or SIFADDR. */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|600034
name|should_be_up
operator|=
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
expr_stmt|;
else|#
directive|else
name|should_be_up
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|was_up
operator|&&
name|should_be_up
condition|)
block|{
comment|/* Interface goes up -- start it. */
name|ce_up
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ce_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|was_up
operator|&&
operator|!
name|should_be_up
condition|)
block|{
comment|/* Interface is going down -- stop it. */
comment|/*		if ((IFP2SP(ifp)->pp_flags& PP_FR) || (ifp->if_flags& PP_CISCO))*/
name|ce_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl 0x%lx p4\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Initialization of interface.  * It seems to be never called by upper level?  */
end_comment

begin_function
specifier|static
name|void
name|ce_initialize
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|softc
decl_stmt|;
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"ce_initialize\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*NETGRAPH*/
end_comment

begin_comment
comment|/*  * Stop the interface.  Called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|ce_down
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"ce_down\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Interface is going down -- stop it. */
name|ce_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ce_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|running
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start the interface.  Called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|ce_up
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"ce_up\n"
operator|)
argument_list|)
expr_stmt|;
name|ce_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ce_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|running
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on the interface.  Get another datagram to send  * off of the interface queue, and copy it to the interface  * before starting the output.  */
end_comment

begin_function
specifier|static
name|void
name|ce_send
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_short
name|len
decl_stmt|;
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ce_send\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* No output if the interface is down. */
if|if
condition|(
operator|!
name|d
operator|->
name|running
condition|)
return|return;
while|while
condition|(
name|ce_transmit_space
argument_list|(
name|d
operator|->
name|chan
argument_list|)
condition|)
block|{
comment|/* Get the packet to send. */
ifdef|#
directive|ifdef
name|NETGRAPH
name|IF_DEQUEUE
argument_list|(
operator|&
name|d
operator|->
name|hi_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
name|IF_DEQUEUE
argument_list|(
operator|&
name|d
operator|->
name|queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|=
name|sppp_dequeue
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m
condition|)
return|return;
ifndef|#
directive|ifndef
name|NETGRAPH
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|BPF_MTAP
argument_list|(
name|d
operator|->
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|d
operator|->
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|d
operator|->
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|490000
name|len
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|>=
name|BUFSZ
condition|)
name|printf
argument_list|(
literal|"%s: too long packet: %d bytes: "
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|m
operator|->
name|m_next
condition|)
name|ce_send_packet
argument_list|(
name|d
operator|->
name|chan
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|ce_buf_item_t
modifier|*
name|item
init|=
operator|(
name|ce_buf_item_t
operator|*
operator|)
name|d
operator|->
name|chan
operator|->
name|tx_queue
decl_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|item
operator|->
name|buf
argument_list|)
expr_stmt|;
name|ce_send_packet
argument_list|(
name|d
operator|->
name|chan
argument_list|,
name|item
operator|->
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Set up transmit timeout, if the transmit ring is not empty.*/
ifdef|#
directive|ifdef
name|NETGRAPH
name|d
operator|->
name|timeout
operator|=
literal|10
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|10
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|NETGRAPH
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|600034
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Start output on the interface.  * Always called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|ce_start
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|running
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|chan
operator|->
name|dtr
condition|)
name|ce_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|chan
operator|->
name|rts
condition|)
name|ce_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ce_send
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle transmit timeouts.  * Recover after lost transmit interrupts.  * Always called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|ce_watchdog
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|board
operator|->
name|sys
decl_stmt|;
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"device timeout\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|running
condition|)
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ce_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*		ce_stop_chan (d->chan);*/
comment|/*		ce_start_chan (d->chan, 1, 1, 0, 0);*/
name|ce_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ce_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ce_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ce_transmit
parameter_list|(
name|ce_chan_t
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|attachment
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|d
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
else|#
directive|else
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_opackets
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|600034
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ce_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ce_receive
parameter_list|(
name|ce_chan_t
modifier|*
name|c
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|running
condition|)
return|return;
name|m
operator|=
name|makembuf
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"no memory for packet\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_iqdrops
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|c
operator|->
name|debug
operator|>
literal|1
condition|)
name|printmbuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
literal|0
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|d
operator|->
name|rqueue
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_ipackets
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|d
operator|->
name|ifp
expr_stmt|;
comment|/* Check if there's a BPF listener on this interface. 	 * If so, hand off the raw packet to bpf. */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|BPF_TAP
argument_list|(
name|d
operator|->
name|ifp
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|d
operator|->
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_tap
argument_list|(
name|d
operator|->
name|ifp
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IF_ENQUEUE
argument_list|(
operator|&
name|d
operator|->
name|rqueue
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|ce_error
parameter_list|(
name|ce_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
switch|switch
condition|(
name|data
condition|)
block|{
case|case
name|CE_FRAME
case|:
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"frame error\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CE_CRC
case|:
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"crc error\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CE_OVERRUN
case|:
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"overrun error\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_collisions
expr_stmt|;
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CE_OVERFLOW
case|:
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"overflow error\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CE_UNDERRUN
case|:
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"underrun error\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|d
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
else|#
directive|else
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|600034
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ce_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"error #%d\n"
operator|,
name|data
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * You also need read, write, open, close routines.  * This should get you started  */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_decl_stmt
specifier|static
name|int
name|ce_open
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|oflags
argument_list|,
name|int
name|devtype
argument_list|,
expr|struct
name|proc
operator|*
name|p
argument_list|)
else|#
directive|else
decl|static
name|int
name|ce_open
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|int
name|oflags
argument_list|,
name|int
name|devtype
argument_list|,
expr|struct
name|thread
operator|*
name|td
argument_list|)
endif|#
directive|endif
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|drv_t
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBRD
operator|*
name|NCHAN
operator|||
operator|!
operator|(
name|d
operator|=
name|channel
index|[
name|unit
index|]
operator|)
condition|)
return|return
name|ENXIO
return|;
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ce_open\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Only called on the LAST close.  */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_decl_stmt
specifier|static
name|int
name|ce_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|fflag
argument_list|,
name|int
name|devtype
argument_list|,
expr|struct
name|proc
operator|*
name|p
argument_list|)
else|#
directive|else
decl|static
name|int
name|ce_close
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|int
name|fflag
argument_list|,
name|int
name|devtype
argument_list|,
expr|struct
name|thread
operator|*
name|td
argument_list|)
endif|#
directive|endif
block|{
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ce_close\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|ce_modem_status
parameter_list|(
name|ce_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|board
operator|->
name|sys
decl_stmt|;
name|int
name|status
decl_stmt|,
name|s
decl_stmt|;
name|status
operator|=
name|d
operator|->
name|running
condition|?
name|TIOCM_LE
else|:
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce_get_cd
argument_list|(
name|c
argument_list|)
condition|)
name|status
operator||=
name|TIOCM_CD
expr_stmt|;
if|if
condition|(
name|ce_get_cts
argument_list|(
name|c
argument_list|)
condition|)
name|status
operator||=
name|TIOCM_CTS
expr_stmt|;
if|if
condition|(
name|ce_get_dsr
argument_list|(
name|c
argument_list|)
condition|)
name|status
operator||=
name|TIOCM_DSR
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|dtr
condition|)
name|status
operator||=
name|TIOCM_DTR
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|rts
condition|)
name|status
operator||=
name|TIOCM_RTS
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_decl_stmt
specifier|static
name|int
name|ce_ioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|cmd
argument_list|,
name|caddr_t
name|data
argument_list|,
name|int
name|flag
argument_list|,
expr|struct
name|proc
operator|*
name|p
argument_list|)
else|#
directive|else
decl|static
name|int
name|ce_ioctl
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|u_long
name|cmd
argument_list|,
name|caddr_t
name|data
argument_list|,
name|int
name|flag
argument_list|,
expr|struct
name|thread
operator|*
name|td
argument_list|)
endif|#
directive|endif
block|{
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|board
operator|->
name|sys
decl_stmt|;
name|ce_chan_t
modifier|*
name|c
init|=
name|d
operator|->
name|chan
decl_stmt|;
name|struct
name|serial_statistics
modifier|*
name|st
decl_stmt|;
name|struct
name|e1_statistics
modifier|*
name|opte1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|char
name|mask
index|[
literal|16
index|]
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SERIAL_GETREGISTERED
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getregistered\n"
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mask
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|NBRD
operator|*
name|NCHAN
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|channel
index|[
name|s
index|]
condition|)
name|mask
index|[
name|s
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|s
operator|&
literal|7
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|mask
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|NETGRAPH
case|case
name|SERIAL_GETPROTO
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getproto\n"
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
operator|(
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&
name|PP_FR
operator|)
condition|?
literal|"fr"
else|:
operator|(
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|?
literal|"cisco"
else|:
literal|"ppp"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETPROTO
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setproto\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|600034
if|if
condition|(
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
else|#
directive|else
if|if
condition|(
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
endif|#
directive|endif
return|return
name|EBUSY
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"cisco"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
condition|)
block|{
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&=
operator|~
operator|(
name|PP_FR
operator|)
expr_stmt|;
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator||=
name|PP_KEEPALIVE
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|PP_CISCO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"fr"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|&&
name|PP_FR
condition|)
block|{
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|PP_CISCO
operator|)
expr_stmt|;
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator||=
name|PP_FR
operator||
name|PP_KEEPALIVE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"ppp"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
condition|)
block|{
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&=
operator|~
name|PP_FR
expr_stmt|;
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&=
operator|~
name|PP_KEEPALIVE
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|PP_CISCO
operator|)
expr_stmt|;
block|}
else|else
return|return
name|EINVAL
return|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETKEEPALIVE
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getkeepalive\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&
name|PP_FR
operator|)
operator|||
operator|(
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&
name|PP_KEEPALIVE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETKEEPALIVE
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setkeepalive\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&
name|PP_FR
operator|)
operator|||
operator|(
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator||=
name|PP_KEEPALIVE
expr_stmt|;
else|else
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&=
operator|~
name|PP_KEEPALIVE
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/*NETGRAPH*/
case|case
name|SERIAL_GETMODE
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getmode\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|SERIAL_HDLC
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETMODE
case|:
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|!=
name|SERIAL_HDLC
condition|)
return|return
name|EINVAL
return|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETCFG
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getcfg\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|)
name|data
operator|=
literal|'c'
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETCFG
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setcfg\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|)
operator|!=
literal|'c'
condition|)
return|return
name|EINVAL
return|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETSTAT
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getstat\n"
operator|)
argument_list|)
expr_stmt|;
name|st
operator|=
operator|(
expr|struct
name|serial_statistics
operator|*
operator|)
name|data
expr_stmt|;
name|st
operator|->
name|rintr
operator|=
name|c
operator|->
name|rintr
expr_stmt|;
name|st
operator|->
name|tintr
operator|=
name|c
operator|->
name|tintr
expr_stmt|;
name|st
operator|->
name|mintr
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|ibytes
operator|=
name|c
operator|->
name|ibytes
expr_stmt|;
name|st
operator|->
name|ipkts
operator|=
name|c
operator|->
name|ipkts
expr_stmt|;
name|st
operator|->
name|obytes
operator|=
name|c
operator|->
name|obytes
expr_stmt|;
name|st
operator|->
name|opkts
operator|=
name|c
operator|->
name|opkts
expr_stmt|;
name|st
operator|->
name|ierrs
operator|=
name|c
operator|->
name|overrun
operator|+
name|c
operator|->
name|frame
operator|+
name|c
operator|->
name|crc
expr_stmt|;
name|st
operator|->
name|oerrs
operator|=
name|c
operator|->
name|underrun
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETESTAT
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getestat\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
name|opte1
operator|=
operator|(
expr|struct
name|e1_statistics
operator|*
operator|)
name|data
expr_stmt|;
name|opte1
operator|->
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|status
operator|&
name|ESTS_NOALARM
condition|)
name|opte1
operator|->
name|status
operator||=
name|E1_NOALARM
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|status
operator|&
name|ESTS_LOS
condition|)
name|opte1
operator|->
name|status
operator||=
name|E1_LOS
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|status
operator|&
name|ESTS_LOF
condition|)
name|opte1
operator|->
name|status
operator||=
name|E1_LOF
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|status
operator|&
name|ESTS_AIS
condition|)
name|opte1
operator|->
name|status
operator||=
name|E1_AIS
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|status
operator|&
name|ESTS_LOMF
condition|)
name|opte1
operator|->
name|status
operator||=
name|E1_LOMF
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|status
operator|&
name|ESTS_AIS16
condition|)
name|opte1
operator|->
name|status
operator||=
name|E1_AIS16
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|status
operator|&
name|ESTS_FARLOF
condition|)
name|opte1
operator|->
name|status
operator||=
name|E1_FARLOF
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|status
operator|&
name|ESTS_FARLOMF
condition|)
name|opte1
operator|->
name|status
operator||=
name|E1_FARLOMF
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|status
operator|&
name|ESTS_TSTREQ
condition|)
name|opte1
operator|->
name|status
operator||=
name|E1_TSTREQ
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|status
operator|&
name|ESTS_TSTERR
condition|)
name|opte1
operator|->
name|status
operator||=
name|E1_TSTERR
expr_stmt|;
name|opte1
operator|->
name|cursec
operator|=
name|c
operator|->
name|cursec
expr_stmt|;
name|opte1
operator|->
name|totsec
operator|=
name|c
operator|->
name|totsec
operator|+
name|c
operator|->
name|cursec
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|bpv
operator|=
name|c
operator|->
name|currnt
operator|.
name|bpv
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|fse
operator|=
name|c
operator|->
name|currnt
operator|.
name|fse
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|crce
operator|=
name|c
operator|->
name|currnt
operator|.
name|crce
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|rcrce
operator|=
name|c
operator|->
name|currnt
operator|.
name|rcrce
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|uas
operator|=
name|c
operator|->
name|currnt
operator|.
name|uas
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|les
operator|=
name|c
operator|->
name|currnt
operator|.
name|les
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|es
operator|=
name|c
operator|->
name|currnt
operator|.
name|es
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|bes
operator|=
name|c
operator|->
name|currnt
operator|.
name|bes
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|ses
operator|=
name|c
operator|->
name|currnt
operator|.
name|ses
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|oofs
operator|=
name|c
operator|->
name|currnt
operator|.
name|oofs
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|css
operator|=
name|c
operator|->
name|currnt
operator|.
name|css
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|dm
operator|=
name|c
operator|->
name|currnt
operator|.
name|dm
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|bpv
operator|=
name|c
operator|->
name|total
operator|.
name|bpv
operator|+
name|c
operator|->
name|currnt
operator|.
name|bpv
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|fse
operator|=
name|c
operator|->
name|total
operator|.
name|fse
operator|+
name|c
operator|->
name|currnt
operator|.
name|fse
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|crce
operator|=
name|c
operator|->
name|total
operator|.
name|crce
operator|+
name|c
operator|->
name|currnt
operator|.
name|crce
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|rcrce
operator|=
name|c
operator|->
name|total
operator|.
name|rcrce
operator|+
name|c
operator|->
name|currnt
operator|.
name|rcrce
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|uas
operator|=
name|c
operator|->
name|total
operator|.
name|uas
operator|+
name|c
operator|->
name|currnt
operator|.
name|uas
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|les
operator|=
name|c
operator|->
name|total
operator|.
name|les
operator|+
name|c
operator|->
name|currnt
operator|.
name|les
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|es
operator|=
name|c
operator|->
name|total
operator|.
name|es
operator|+
name|c
operator|->
name|currnt
operator|.
name|es
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|bes
operator|=
name|c
operator|->
name|total
operator|.
name|bes
operator|+
name|c
operator|->
name|currnt
operator|.
name|bes
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|ses
operator|=
name|c
operator|->
name|total
operator|.
name|ses
operator|+
name|c
operator|->
name|currnt
operator|.
name|ses
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|oofs
operator|=
name|c
operator|->
name|total
operator|.
name|oofs
operator|+
name|c
operator|->
name|currnt
operator|.
name|oofs
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|css
operator|=
name|c
operator|->
name|total
operator|.
name|css
operator|+
name|c
operator|->
name|currnt
operator|.
name|css
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|dm
operator|=
name|c
operator|->
name|total
operator|.
name|dm
operator|+
name|c
operator|->
name|currnt
operator|.
name|dm
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
literal|48
condition|;
operator|++
name|s
control|)
block|{
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|bpv
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|bpv
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|fse
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|fse
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|crce
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|crce
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|rcrce
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|rcrce
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|uas
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|uas
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|les
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|les
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|es
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|es
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|bes
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|bes
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|ses
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|ses
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|oofs
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|oofs
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|css
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|css
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|dm
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|dm
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|SERIAL_CLRSTAT
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: clrstat\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|c
operator|->
name|rintr
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tintr
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|ibytes
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|obytes
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|ipkts
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|opkts
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|overrun
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|frame
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|crc
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|underrun
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|c
operator|->
name|currnt
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|currnt
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|c
operator|->
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|total
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|c
operator|->
name|interval
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|interval
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETLOOP
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getloop\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|lloop
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETLOOP
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setloop\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_lloop
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETRLOOP
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getrloop\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|rloop
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETRLOOP
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setloop\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_rloop
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETDEBUG
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getdebug\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|d
operator|->
name|chan
operator|->
name|debug
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETDEBUG
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setdebug\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|d
operator|->
name|chan
operator|->
name|debug
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
if|if
condition|(
name|d
operator|->
name|chan
operator|->
name|debug
condition|)
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_DEBUG
expr_stmt|;
else|else
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_DEBUG
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
case|case
name|SERIAL_GETBAUD
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getbaud\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|baud
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETBAUD
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setbaud\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|||
operator|!
name|c
operator|->
name|unfram
condition|)
return|return
name|EINVAL
return|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_baud
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETTIMESLOTS
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: gettimeslots\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|||
name|c
operator|->
name|unfram
operator|)
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_DATA
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|u_long
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|ts
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETTIMESLOTS
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: settimeslots\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|||
name|c
operator|->
name|unfram
operator|)
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_DATA
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_ts
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|u_long
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETHIGAIN
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: gethigain\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|higain
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETHIGAIN
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: sethigain\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_higain
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETPHONY
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getphony\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|phony
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETPHONY
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setphony\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_phony
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETUNFRAM
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getunfram\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|||
name|c
operator|->
name|num
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|unfram
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETUNFRAM
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setunfram\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|||
name|c
operator|->
name|num
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_unfram
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETSCRAMBLER
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getscrambler\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|unfram
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|scrambler
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETSCRAMBLER
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setscrambler\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|c
operator|->
name|unfram
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_scrambler
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETMONITOR
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getmonitor\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|monitor
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETMONITOR
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setmonitor\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_monitor
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETUSE16
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getuse16\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|||
name|c
operator|->
name|unfram
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|use16
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETUSE16
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setuse16\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_use16
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETCRC4
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getcrc4\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|||
name|c
operator|->
name|unfram
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|crc4
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETCRC4
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setcrc4\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|||
name|c
operator|->
name|unfram
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_crc4
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETCLK
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getclk\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
switch|switch
condition|(
name|c
operator|->
name|gsyn
condition|)
block|{
default|default:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|E1CLK_INTERNAL
expr_stmt|;
break|break;
case|case
name|GSYN_RCV
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|E1CLK_RECEIVE
expr_stmt|;
break|break;
case|case
name|GSYN_RCV0
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|E1CLK_RECEIVE_CHAN0
expr_stmt|;
break|break;
case|case
name|GSYN_RCV1
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|E1CLK_RECEIVE_CHAN1
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
case|case
name|SERIAL_SETCLK
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setclk\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
default|default:
name|ce_set_gsyn
argument_list|(
name|c
argument_list|,
name|GSYN_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1CLK_RECEIVE
case|:
name|ce_set_gsyn
argument_list|(
name|c
argument_list|,
name|GSYN_RCV
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1CLK_RECEIVE_CHAN0
case|:
name|ce_set_gsyn
argument_list|(
name|c
argument_list|,
name|GSYN_RCV0
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1CLK_RECEIVE_CHAN1
case|:
name|ce_set_gsyn
argument_list|(
name|c
argument_list|,
name|GSYN_RCV1
argument_list|)
expr_stmt|;
break|break;
block|}
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
if|#
directive|if
literal|0
block|case SERIAL_RESET: 		CE_DEBUG2 (d, ("ioctl: reset\n"));
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
block|error = suser (p);
empty|#elsif __FreeBSD_version< 700000
block|error = suser (td);
else|#
directive|else
block|error = priv_check (td, PRIV_DRIVER);
endif|#
directive|endif
block|if (error) 			return error; 		s = splimp (); 		CE_LOCK (bd);
comment|/*		ce_reset (c->board, 0, 0);*/
block|CE_UNLOCK (bd); 		splx (s); 		return 0;  	case SERIAL_HARDRESET: 		CE_DEBUG2 (d, ("ioctl: hardreset\n"));
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
block|error = suser (p);
empty|#elsif __FreeBSD_version< 700000
block|error = suser (td);
else|#
directive|else
block|error = priv_check (td, PRIV_DRIVER);
endif|#
directive|endif
block|if (error) 			return error; 		s = splimp (); 		CE_LOCK (bd);
comment|/* hard_reset (c->board); */
block|CE_UNLOCK (bd); 		splx (s); 		return 0;
endif|#
directive|endif
case|case
name|SERIAL_GETCABLE
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getcable\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|CABLE_TP
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETDIR
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getdir\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_DATA
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|dir
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETDIR
case|:
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setdir\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
empty|#elsif __FreeBSD_version< 700000
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_dir
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCSDTR
case|:
comment|/* Set DTR */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_dtr
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCCDTR
case|:
comment|/* Clear DTR */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_dtr
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMSET
case|:
comment|/* Set DTR/RTS */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_set_dtr
argument_list|(
name|c
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|ce_set_rts
argument_list|(
name|c
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMBIS
case|:
comment|/* Add DTR/RTS */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|ce_set_dtr
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|ce_set_rts
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMBIC
case|:
comment|/* Clear DTR/RTS */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|ce_set_dtr
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|ce_set_rts
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMGET
case|:
comment|/* Get modem status */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ce_modem_status
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENOTTY
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH
end_ifdef

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
end_if

begin_function
specifier|static
name|int
name|ng_ce_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|static
name|int
name|ng_ce_constructor
parameter_list|(
name|node_p
modifier|*
name|node
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
operator|*
name|node
operator|)
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Constructor\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
specifier|static
name|int
name|ng_ce_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
else|#
directive|else
name|drv_t
modifier|*
name|d
init|=
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|board
operator|->
name|sys
decl_stmt|;
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Newhook\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Attach debug hook */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_CE_HOOK_DEBUG
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|hook
operator|->
name|private
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|debug_hook
operator|=
name|hook
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for raw hook */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_CE_HOOK_RAW
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
name|hook
operator|->
name|private
operator|=
name|d
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_up
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|char
modifier|*
name|format_timeslots
parameter_list|(
name|u_long
name|s
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|s
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|int
name|prev
init|=
operator|(
name|i
operator|>
literal|1
operator|)
operator|&
operator|(
name|s
operator|>>
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|int
name|next
init|=
operator|(
name|i
operator|<
literal|31
operator|)
operator|&
operator|(
name|s
operator|>>
operator|(
name|i
operator|+
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
if|if
condition|(
name|next
condition|)
continue|continue;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|>
name|buf
condition|)
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|10
condition|)
operator|*
name|p
operator|++
operator|=
literal|'0'
operator|+
name|i
operator|/
literal|10
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'0'
operator|+
name|i
operator|%
literal|10
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
specifier|static
name|int
name|print_modems
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|ce_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|need_header
parameter_list|)
block|{
name|int
name|status
init|=
name|ce_modem_status
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|need_header
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"  LE   DTR  DSR  RTS  CTS  CD\n"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%4s %4s %4s %4s %4s %4s\n"
argument_list|,
name|status
operator|&
name|TIOCM_LE
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_DTR
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_DSR
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_RTS
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_CTS
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_CD
condition|?
literal|"On"
else|:
literal|"-"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
specifier|static
name|int
name|print_stats
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|ce_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|need_header
parameter_list|)
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|need_header
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"  Rintr   Tintr   Mintr   Ibytes   Ipkts   Ierrs   Obytes   Opkts   Oerrs\n"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%7ld %7ld %7ld %8lu %7ld %7ld %8lu %7ld %7ld\n"
argument_list|,
name|c
operator|->
name|rintr
argument_list|,
name|c
operator|->
name|tintr
argument_list|,
literal|0l
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|c
operator|->
name|ibytes
argument_list|,
name|c
operator|->
name|ipkts
argument_list|,
name|c
operator|->
name|overrun
operator|+
name|c
operator|->
name|frame
operator|+
name|c
operator|->
name|crc
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|c
operator|->
name|obytes
argument_list|,
name|c
operator|->
name|opkts
argument_list|,
name|c
operator|->
name|underrun
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
specifier|static
name|char
modifier|*
name|format_e1_status
parameter_list|(
name|u_char
name|status
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_NOALARM
condition|)
return|return
literal|"Ok"
return|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_LOS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",LOS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_AIS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",AIS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_LOF
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",LOF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_LOMF
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",LOMF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_FARLOF
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",FARLOF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_AIS16
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",AIS16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_FARLOMF
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",FARLOMF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_TSTREQ
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",TSTREQ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_TSTERR
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",TSTERR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|','
condition|)
return|return
name|buf
operator|+
literal|1
return|;
return|return
literal|"Unknown"
return|;
block|}
specifier|static
name|int
name|print_frac
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|leftalign
parameter_list|,
name|u_long
name|numerator
parameter_list|,
name|u_long
name|divider
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|numerator
operator|<
literal|1
operator|||
name|divider
operator|<
literal|1
condition|)
block|{
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
name|leftalign
condition|?
literal|"/-   "
else|:
literal|"    -"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
name|n
operator|=
call|(
name|int
call|)
argument_list|(
literal|0.5
operator|+
literal|1000.0
operator|*
name|numerator
operator|/
name|divider
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1000
condition|)
block|{
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
name|leftalign
condition|?
literal|"/.%-3d"
else|:
literal|" .%03d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
operator|*
operator|(
name|s
operator|+
name|length
operator|)
operator|=
name|leftalign
condition|?
literal|'/'
else|:
literal|' '
expr_stmt|;
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|1000000
condition|)
name|n
operator|=
operator|(
name|n
operator|+
literal|500
operator|)
operator|/
literal|1000
operator|*
literal|1000
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>=
literal|100000
condition|)
name|n
operator|=
operator|(
name|n
operator|+
literal|50
operator|)
operator|/
literal|100
operator|*
literal|100
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>=
literal|10000
condition|)
name|n
operator|=
operator|(
name|n
operator|+
literal|5
operator|)
operator|/
literal|10
operator|*
literal|10
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1000
case|:
name|length
operator|+=
name|printf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|".999"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
case|case
literal|10000
case|:
name|n
operator|=
literal|9990
expr_stmt|;
break|break;
case|case
literal|100000
case|:
name|n
operator|=
literal|99900
expr_stmt|;
break|break;
case|case
literal|1000000
case|:
name|n
operator|=
literal|999000
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|<
literal|10000
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%d.%d"
argument_list|,
name|n
operator|/
literal|1000
argument_list|,
name|n
operator|/
literal|10
operator|%
literal|100
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
literal|100000
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%d.%d"
argument_list|,
name|n
operator|/
literal|1000
argument_list|,
name|n
operator|/
literal|100
operator|%
literal|10
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
literal|1000000
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%d."
argument_list|,
name|n
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%d"
argument_list|,
name|n
operator|/
literal|1000
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
specifier|static
name|int
name|print_e1_stats
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|ce_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|e1_counters
name|total
decl_stmt|;
name|u_long
name|totsec
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|totsec
operator|=
name|c
operator|->
name|totsec
operator|+
name|c
operator|->
name|cursec
expr_stmt|;
name|total
operator|.
name|bpv
operator|=
name|c
operator|->
name|total
operator|.
name|bpv
operator|+
name|c
operator|->
name|currnt
operator|.
name|bpv
expr_stmt|;
name|total
operator|.
name|fse
operator|=
name|c
operator|->
name|total
operator|.
name|fse
operator|+
name|c
operator|->
name|currnt
operator|.
name|fse
expr_stmt|;
name|total
operator|.
name|crce
operator|=
name|c
operator|->
name|total
operator|.
name|crce
operator|+
name|c
operator|->
name|currnt
operator|.
name|crce
expr_stmt|;
name|total
operator|.
name|rcrce
operator|=
name|c
operator|->
name|total
operator|.
name|rcrce
operator|+
name|c
operator|->
name|currnt
operator|.
name|rcrce
expr_stmt|;
name|total
operator|.
name|uas
operator|=
name|c
operator|->
name|total
operator|.
name|uas
operator|+
name|c
operator|->
name|currnt
operator|.
name|uas
expr_stmt|;
name|total
operator|.
name|les
operator|=
name|c
operator|->
name|total
operator|.
name|les
operator|+
name|c
operator|->
name|currnt
operator|.
name|les
expr_stmt|;
name|total
operator|.
name|es
operator|=
name|c
operator|->
name|total
operator|.
name|es
operator|+
name|c
operator|->
name|currnt
operator|.
name|es
expr_stmt|;
name|total
operator|.
name|bes
operator|=
name|c
operator|->
name|total
operator|.
name|bes
operator|+
name|c
operator|->
name|currnt
operator|.
name|bes
expr_stmt|;
name|total
operator|.
name|ses
operator|=
name|c
operator|->
name|total
operator|.
name|ses
operator|+
name|c
operator|->
name|currnt
operator|.
name|ses
expr_stmt|;
name|total
operator|.
name|oofs
operator|=
name|c
operator|->
name|total
operator|.
name|oofs
operator|+
name|c
operator|->
name|currnt
operator|.
name|oofs
expr_stmt|;
name|total
operator|.
name|css
operator|=
name|c
operator|->
name|total
operator|.
name|css
operator|+
name|c
operator|->
name|currnt
operator|.
name|css
expr_stmt|;
name|total
operator|.
name|dm
operator|=
name|c
operator|->
name|total
operator|.
name|dm
operator|+
name|c
operator|->
name|currnt
operator|.
name|dm
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" Unav/Degr  Bpv/Fsyn  CRC/RCRC  Err/Lerr  Sev/Bur   Oof/Slp  Status\n"
argument_list|)
expr_stmt|;
comment|/* Unavailable seconds, degraded minutes */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|uas
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
literal|60
operator|*
name|c
operator|->
name|currnt
operator|.
name|dm
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* Bipolar violations, frame sync errors */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|bpv
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|fse
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* CRC errors, remote CRC errors (E-bit) */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|crce
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|rcrce
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* Errored seconds, line errored seconds */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|es
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|les
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* Severely errored seconds, burst errored seconds */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|ses
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|bes
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* Out of frame seconds, controlled slip seconds */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|oofs
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|css
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" %s\n"
argument_list|,
name|format_e1_status
argument_list|(
name|c
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print total statistics. */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|uas
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
literal|60
operator|*
name|total
operator|.
name|dm
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|bpv
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|fse
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|crce
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|rcrce
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|es
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|les
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|ses
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|bes
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|oofs
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|css
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" -- Total\n"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
specifier|static
name|int
name|print_chan
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|ce_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"ce%d"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|chan
operator|->
name|debug
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" debug=%d"
argument_list|,
name|d
operator|->
name|chan
operator|->
name|debug
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|board
operator|->
name|mux
condition|)
block|{
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" cfg=C"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" cfg=A"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|baud
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" %ld"
argument_list|,
name|c
operator|->
name|baud
argument_list|)
expr_stmt|;
else|else
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" extclock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_E1
condition|)
switch|switch
condition|(
name|c
operator|->
name|gsyn
condition|)
block|{
case|case
name|GSYN_INT
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" syn=int"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GSYN_RCV
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" syn=rcv"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GSYN_RCV0
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" syn=rcv0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GSYN_RCV1
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" syn=rcv1"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_E1
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" higain=%s"
argument_list|,
name|c
operator|->
name|higain
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" loop=%s"
argument_list|,
name|c
operator|->
name|lloop
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_E1
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" ts=%s"
argument_list|,
name|format_timeslots
argument_list|(
name|c
operator|->
name|ts
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
specifier|static
name|int
name|ng_ce_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
else|#
directive|else
specifier|static
name|int
name|ng_ce_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|retaddr
parameter_list|,
name|struct
name|ng_mesg
modifier|*
modifier|*
name|rptr
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Rcvmsg\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NGM_CE_COOKIE
case|:
name|printf
argument_list|(
literal|"Not implemented yet\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NGM_GENERIC_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NGM_TEXT_STATUS
case|:
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
name|int
name|dl
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|+
literal|730
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
name|dl
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|MALLOC
argument_list|(
name|resp
argument_list|,
expr|struct
name|ng_mesg
operator|*
argument_list|,
name|dl
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|resp
argument_list|,
name|dl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
operator|(
name|resp
operator|)
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|l
operator|+=
name|print_chan
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
name|l
operator|+=
name|print_stats
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|l
operator|+=
name|print_modems
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|l
operator|+=
name|print_e1_stats
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
block|}
else|else
name|l
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|l
argument_list|,
literal|"Error: node not connect to channel"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|version
operator|=
name|NG_VERSION
expr_stmt|;
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|arglen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|token
operator|=
name|msg
operator|->
name|header
operator|.
name|token
expr_stmt|;
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|typecookie
operator|=
name|NGM_CE_COOKIE
expr_stmt|;
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|cmd
operator|=
name|msg
operator|->
name|header
operator|.
name|cmd
expr_stmt|;
endif|#
directive|endif
name|strncpy
argument_list|(
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
literal|"status"
argument_list|,
name|NG_CMDSTRLEN
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|rptr
operator|=
name|resp
expr_stmt|;
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
specifier|static
name|int
name|ng_ce_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502120
name|meta_p
name|meta
decl_stmt|;
else|#
directive|else
name|struct
name|ng_tag_prio
modifier|*
name|ptag
decl_stmt|;
endif|#
directive|endif
else|#
directive|else
specifier|static
name|int
name|ng_ce_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|board
operator|->
name|sys
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|q
decl_stmt|;
name|int
name|s
decl_stmt|;
name|CE_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"Rcvdata\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502120
name|NGI_GET_META
argument_list|(
name|item
argument_list|,
name|meta
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|||
operator|!
name|d
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502120
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
operator|!
name|hook
operator|->
name|private
operator|||
operator|!
name|d
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ENETDOWN
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502120
comment|/* Check for high priority data */
if|if
condition|(
operator|(
name|ptag
operator|=
operator|(
expr|struct
name|ng_tag_prio
operator|*
operator|)
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|NGM_GENERIC_COOKIE
argument_list|,
name|NG_TAG_PRIO
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|ptag
operator|->
name|priority
operator|>
name|NG_PRIO_CUTOFF
operator|)
condition|)
name|q
operator|=
operator|&
name|d
operator|->
name|hi_queue
expr_stmt|;
else|else
name|q
operator|=
operator|&
name|d
operator|->
name|queue
expr_stmt|;
else|#
directive|else
name|q
operator|=
operator|(
name|meta
operator|&&
name|meta
operator|->
name|priority
operator|>
literal|0
operator|)
condition|?
operator|&
name|d
operator|->
name|hi_queue
else|:
operator|&
name|d
operator|->
name|queue
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|IF_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IF_QFULL
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|_IF_DROP
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502120
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ENOBUFS
return|;
block|}
name|_IF_ENQUEUE
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|IF_QFULL
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|IF_ENQUEUE
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ce_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|ng_ce_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Rmnode\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|running
condition|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|board
operator|->
name|sys
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KLD_MODULE
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502120
if|if
condition|(
name|node
operator|->
name|nd_flags
operator|&
name|NGF_REALLY_DIE
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|node
operator|->
name|nd_flags
operator|&
name|NG_REALLY_DIE
condition|)
block|{
endif|#
directive|endif
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502120
name|NG_NODE_REVIVE
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Persistant node */
else|#
directive|else
name|node
operator|->
name|nd_flags
operator|&=
operator|~
name|NG_INVALID
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
else|#
directive|else
comment|/* __FreeBSD_version< 500000 */
name|drv_t
modifier|*
name|d
init|=
name|node
operator|->
name|private
decl_stmt|;
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|running
condition|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|board
operator|->
name|sys
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|flags
operator||=
name|NG_INVALID
expr_stmt|;
name|ng_cutlinks
argument_list|(
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KLD_MODULE
name|ng_unname
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
literal|0
return|;
block|}
specifier|static
name|void
name|ng_ce_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|d
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|timeout
operator|==
literal|1
condition|)
name|ce_watchdog
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|timeout
condition|)
name|d
operator|->
name|timeout
operator|--
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|d
operator|->
name|timeout_handle
argument_list|,
name|hz
argument_list|,
name|ng_ce_watchdog
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|int
name|ng_ce_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|drv_t
modifier|*
name|d
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
condition|)
block|{
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Connect\n"
operator|)
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|d
operator|->
name|timeout_handle
argument_list|,
name|hz
argument_list|,
name|ng_ce_watchdog
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|ng_ce_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|drv_t
modifier|*
name|d
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
condition|)
block|{
name|CE_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Disconnect\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
if|if
condition|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|hook
operator|->
name|private
condition|)
endif|#
directive|endif
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|board
operator|->
name|sys
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|CE_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ce_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CE_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* If we were wait it than it reasserted now, just stop it. */
if|if
condition|(
operator|!
name|callout_drain
argument_list|(
operator|&
name|d
operator|->
name|timeout_handle
argument_list|)
condition|)
name|callout_stop
argument_list|(
operator|&
name|d
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
specifier|static
name|int
name|ce_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|dev_t
name|dev
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|cdsw
decl_stmt|;
endif|#
directive|endif
specifier|static
name|int
name|load_count
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|501114
if|if
condition|(
operator|!
name|debug_mpsafenet
operator|&&
name|ce_mpsafenet
condition|)
block|{
name|printf
argument_list|(
literal|"WORNING! Network stack is not MPSAFE. "
literal|"Turning off debug.ce.mpsafenet.\n"
argument_list|)
expr_stmt|;
name|ce_mpsafenet
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502103
if|if
condition|(
name|ce_mpsafenet
condition|)
name|ce_cdevsw
operator|.
name|d_flags
operator|&=
operator|~
name|D_NEEDGIANT
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
if|if
condition|(
name|dev
operator|!=
name|NODEV
operator|&&
operator|(
name|cdsw
operator|=
name|devsw
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
name|cdsw
operator|->
name|d_maj
operator|==
name|CDEV_MAJOR
condition|)
block|{
name|printf
argument_list|(
literal|"Tau32-PCI driver is already in system\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
operator|&&
name|defined
name|NETGRAPH
if|if
condition|(
name|ng_newtype
argument_list|(
operator|&
name|typestruct
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Failed to register ng_ce\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|load_count
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<=
literal|500000
name|cdevsw_add
argument_list|(
operator|&
name|ce_cdevsw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|callout_init
argument_list|(
operator|&
name|timeout_handle
argument_list|,
name|ce_mpsafenet
condition|?
name|CALLOUT_MPSAFE
else|:
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|callout_init
argument_list|(
operator|&
name|timeout_handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_reset
argument_list|(
operator|&
name|timeout_handle
argument_list|,
name|hz
operator|*
literal|5
argument_list|,
name|ce_timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
name|load_count
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Removing device entry for Tau32-PCI\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<=
literal|500000
name|cdevsw_remove
argument_list|(
operator|&
name|ce_cdevsw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
operator|&&
name|defined
name|NETGRAPH
name|ng_rmtype
argument_list|(
operator|&
name|typestruct
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If we were wait it than it reasserted now, just stop it. 		 * Actually we shouldn't get this condition. But code could be 		 * changed in the future, so just be a litle paranoid. 		 */
if|if
condition|(
operator|!
name|callout_drain
argument_list|(
operator|&
name|timeout_handle
argument_list|)
condition|)
name|callout_stop
argument_list|(
operator|&
name|timeout_handle
argument_list|)
expr_stmt|;
operator|--
name|load_count
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
block|}
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|NETGRAPH
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502100
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_CE_NODE_TYPE
block|,
operator|.
name|constructor
operator|=
name|ng_ce_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ng_ce_rcvmsg
block|,
operator|.
name|shutdown
operator|=
name|ng_ce_rmnode
block|,
operator|.
name|newhook
operator|=
name|ng_ce_newhook
block|,
operator|.
name|connect
operator|=
name|ng_ce_connect
block|,
operator|.
name|rcvdata
operator|=
name|ng_ce_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ng_ce_disconnect
block|, }
decl_stmt|;
else|#
directive|else
comment|/* __FreeBSD_version< 502100 */
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_ABI_VERSION
block|,
else|#
directive|else
name|NG_VERSION
block|,
endif|#
directive|endif
name|NG_CE_NODE_TYPE
block|,
name|ce_modevent
block|,
name|ng_ce_constructor
block|,
name|ng_ce_rcvmsg
block|,
name|ng_ce_rmnode
block|,
name|ng_ce_newhook
block|,
name|NULL
block|,
name|ng_ce_connect
block|,
name|ng_ce_rcvdata
block|,
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|NULL
block|,
endif|#
directive|endif
name|ng_ce_disconnect
block|,
name|NULL
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD_version< 502100 */
endif|#
directive|endif
comment|/*NETGRAPH*/
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
ifdef|#
directive|ifdef
name|NETGRAPH
name|MODULE_DEPEND
argument_list|(
name|ng_ce
argument_list|,
name|netgraph
argument_list|,
name|NG_ABI_VERSION
argument_list|,
name|NG_ABI_VERSION
argument_list|,
name|NG_ABI_VERSION
argument_list|)
expr_stmt|;
else|#
directive|else
name|MODULE_DEPEND
argument_list|(
name|ce
argument_list|,
name|sppp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KLD_MODULE
name|DRIVER_MODULE
argument_list|(
name|cemod
argument_list|,
name|pci
argument_list|,
name|ce_driver
argument_list|,
name|ce_devclass
argument_list|,
name|ce_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|DRIVER_MODULE
argument_list|(
name|ce
argument_list|,
name|pci
argument_list|,
name|ce_driver
argument_list|,
name|ce_devclass
argument_list|,
name|ce_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* if __FreeBSD_version< 500000*/
ifdef|#
directive|ifdef
name|NETGRAPH
name|DRIVER_MODULE
argument_list|(
name|ce
argument_list|,
name|pci
argument_list|,
name|ce_driver
argument_list|,
name|ce_devclass
argument_list|,
name|ng_mod_event
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
else|#
directive|else
name|DRIVER_MODULE
argument_list|(
name|ce
argument_list|,
name|pci
argument_list|,
name|ce_driver
argument_list|,
name|ce_devclass
argument_list|,
name|ce_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD_version< 500000 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCI */
end_comment

end_unit

