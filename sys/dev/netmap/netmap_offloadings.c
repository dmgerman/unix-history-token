begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2014 Vincenzo Maffione. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* defines used in kernel.h */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* types used in module initialization */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_comment
comment|/* struct socket */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* */
end_comment

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|linux
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"bsd_glue.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_elif

begin_warning
warning|#
directive|warning
warning|OSX support is only partial
end_warning

begin_include
include|#
directive|include
file|"osx_glue.h"
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|Unsupported platform
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unsupported */
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_comment
comment|/* This routine is called by bdg_mismatch_datapath() when it finishes  * accumulating bytes for a segment, in order to fix some fields in the  * segment headers (which still contain the same content as the header  * of the original GSO packet). 'buf' points to the beginning (e.g.  * the ethernet header) of the segment, and 'len' is its length.  */
end_comment

begin_function
specifier|static
name|void
name|gso_fix_segment
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|u_int
name|idx
parameter_list|,
name|u_int
name|segmented_bytes
parameter_list|,
name|u_int
name|last_segment
parameter_list|,
name|u_int
name|tcp
parameter_list|,
name|u_int
name|iphlen
parameter_list|)
block|{
name|struct
name|nm_iphdr
modifier|*
name|iph
init|=
operator|(
expr|struct
name|nm_iphdr
operator|*
operator|)
operator|(
name|buf
operator|+
literal|14
operator|)
decl_stmt|;
name|struct
name|nm_ipv6hdr
modifier|*
name|ip6h
init|=
operator|(
expr|struct
name|nm_ipv6hdr
operator|*
operator|)
operator|(
name|buf
operator|+
literal|14
operator|)
decl_stmt|;
name|uint16_t
modifier|*
name|check
init|=
name|NULL
decl_stmt|;
name|uint8_t
modifier|*
name|check_data
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|iphlen
operator|==
literal|20
condition|)
block|{
comment|/* Set the IPv4 "Total Length" field. */
name|iph
operator|->
name|tot_len
operator|=
name|htobe16
argument_list|(
name|len
operator|-
literal|14
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"ip total length %u"
argument_list|,
name|be16toh
argument_list|(
name|ip
operator|->
name|tot_len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the IPv4 "Identification" field. */
name|iph
operator|->
name|id
operator|=
name|htobe16
argument_list|(
name|be16toh
argument_list|(
name|iph
operator|->
name|id
argument_list|)
operator|+
name|idx
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"ip identification %u"
argument_list|,
name|be16toh
argument_list|(
name|iph
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute and insert the IPv4 header checksum. */
name|iph
operator|->
name|check
operator|=
literal|0
expr_stmt|;
name|iph
operator|->
name|check
operator|=
name|nm_csum_ipv4
argument_list|(
name|iph
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"IP csum %x"
argument_list|,
name|be16toh
argument_list|(
name|iph
operator|->
name|check
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if (iphlen == 40) */
comment|/* Set the IPv6 "Payload Len" field. */
name|ip6h
operator|->
name|payload_len
operator|=
name|htobe16
argument_list|(
name|len
operator|-
literal|14
operator|-
name|iphlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tcp
condition|)
block|{
name|struct
name|nm_tcphdr
modifier|*
name|tcph
init|=
operator|(
expr|struct
name|nm_tcphdr
operator|*
operator|)
operator|(
name|buf
operator|+
literal|14
operator|+
name|iphlen
operator|)
decl_stmt|;
comment|/* Set the TCP sequence number. */
name|tcph
operator|->
name|seq
operator|=
name|htobe32
argument_list|(
name|be32toh
argument_list|(
name|tcph
operator|->
name|seq
argument_list|)
operator|+
name|segmented_bytes
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"tcp seq %u"
argument_list|,
name|be32toh
argument_list|(
name|tcph
operator|->
name|seq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Zero the PSH and FIN TCP flags if this is not the last 		   segment. */
if|if
condition|(
operator|!
name|last_segment
condition|)
name|tcph
operator|->
name|flags
operator|&=
operator|~
operator|(
literal|0x8
operator||
literal|0x1
operator|)
expr_stmt|;
name|ND
argument_list|(
literal|"last_segment %u"
argument_list|,
name|last_segment
argument_list|)
expr_stmt|;
name|check
operator|=
operator|&
name|tcph
operator|->
name|check
expr_stmt|;
name|check_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|tcph
expr_stmt|;
block|}
else|else
block|{
comment|/* UDP */
name|struct
name|nm_udphdr
modifier|*
name|udph
init|=
operator|(
expr|struct
name|nm_udphdr
operator|*
operator|)
operator|(
name|buf
operator|+
literal|14
operator|+
name|iphlen
operator|)
decl_stmt|;
comment|/* Set the UDP 'Length' field. */
name|udph
operator|->
name|len
operator|=
name|htobe16
argument_list|(
name|len
operator|-
literal|14
operator|-
name|iphlen
argument_list|)
expr_stmt|;
name|check
operator|=
operator|&
name|udph
operator|->
name|check
expr_stmt|;
name|check_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|udph
expr_stmt|;
block|}
comment|/* Compute and insert TCP/UDP checksum. */
operator|*
name|check
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iphlen
operator|==
literal|20
condition|)
name|nm_csum_tcpudp_ipv4
argument_list|(
name|iph
argument_list|,
name|check_data
argument_list|,
name|len
operator|-
literal|14
operator|-
name|iphlen
argument_list|,
name|check
argument_list|)
expr_stmt|;
else|else
name|nm_csum_tcpudp_ipv6
argument_list|(
name|ip6h
argument_list|,
name|check_data
argument_list|,
name|len
operator|-
literal|14
operator|-
name|iphlen
argument_list|,
name|check
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"TCP/UDP csum %x"
argument_list|,
name|be16toh
argument_list|(
operator|*
name|check
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The VALE mismatch datapath implementation. */
end_comment

begin_function
name|void
name|bdg_mismatch_datapath
parameter_list|(
name|struct
name|netmap_vp_adapter
modifier|*
name|na
parameter_list|,
name|struct
name|netmap_vp_adapter
modifier|*
name|dst_na
parameter_list|,
name|struct
name|nm_bdg_fwd
modifier|*
name|ft_p
parameter_list|,
name|struct
name|netmap_ring
modifier|*
name|ring
parameter_list|,
name|u_int
modifier|*
name|j
parameter_list|,
name|u_int
name|lim
parameter_list|,
name|u_int
modifier|*
name|howmany
parameter_list|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
name|NULL
decl_stmt|;
name|struct
name|nm_vnet_hdr
modifier|*
name|vh
init|=
name|NULL
decl_stmt|;
comment|/* Number of source slots to process. */
name|u_int
name|frags
init|=
name|ft_p
operator|->
name|ft_frags
decl_stmt|;
name|struct
name|nm_bdg_fwd
modifier|*
name|ft_end
init|=
name|ft_p
operator|+
name|frags
decl_stmt|;
comment|/* Source and destination pointers. */
name|uint8_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|size_t
name|src_len
decl_stmt|,
name|dst_len
decl_stmt|;
name|u_int
name|j_start
init|=
operator|*
name|j
decl_stmt|;
name|u_int
name|dst_slots
init|=
literal|0
decl_stmt|;
comment|/* If the source port uses the offloadings, while destination doesn't, 	 * we grab the source virtio-net header and do the offloadings here. 	 */
if|if
condition|(
name|na
operator|->
name|virt_hdr_len
operator|&&
operator|!
name|dst_na
operator|->
name|virt_hdr_len
condition|)
block|{
name|vh
operator|=
operator|(
expr|struct
name|nm_vnet_hdr
operator|*
operator|)
name|ft_p
operator|->
name|ft_buf
expr_stmt|;
block|}
comment|/* Init source and dest pointers. */
name|src
operator|=
name|ft_p
operator|->
name|ft_buf
expr_stmt|;
name|src_len
operator|=
name|ft_p
operator|->
name|ft_len
expr_stmt|;
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
operator|*
name|j
index|]
expr_stmt|;
name|dst
operator|=
name|NMB
argument_list|(
operator|&
name|dst_na
operator|->
name|up
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|dst_len
operator|=
name|src_len
expr_stmt|;
comment|/* We are processing the first input slot and there is a mismatch 	 * between source and destination virt_hdr_len (SHL and DHL). 	 * When the a client is using virtio-net headers, the header length 	 * can be: 	 *    - 10: the header corresponds to the struct nm_vnet_hdr 	 *    - 12: the first 10 bytes correspond to the struct 	 *          virtio_net_hdr, and the last 2 bytes store the 	 *          "mergeable buffers" info, which is an optional 	 *	    hint that can be zeroed for compability 	 * 	 * The destination header is therefore built according to the 	 * following table: 	 * 	 * SHL | DHL | destination header 	 * ----------------------------- 	 *   0 |  10 | zero 	 *   0 |  12 | zero 	 *  10 |   0 | doesn't exist 	 *  10 |  12 | first 10 bytes are copied from source header, last 2 are zero 	 *  12 |   0 | doesn't exist 	 *  12 |  10 | copied from the first 10 bytes of source header 	 */
name|bzero
argument_list|(
name|dst
argument_list|,
name|dst_na
operator|->
name|virt_hdr_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|virt_hdr_len
operator|&&
name|dst_na
operator|->
name|virt_hdr_len
condition|)
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nm_vnet_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip the virtio-net headers. */
name|src
operator|+=
name|na
operator|->
name|virt_hdr_len
expr_stmt|;
name|src_len
operator|-=
name|na
operator|->
name|virt_hdr_len
expr_stmt|;
name|dst
operator|+=
name|dst_na
operator|->
name|virt_hdr_len
expr_stmt|;
name|dst_len
operator|=
name|dst_na
operator|->
name|virt_hdr_len
operator|+
name|src_len
expr_stmt|;
comment|/* Here it could be dst_len == 0 (which implies src_len == 0), 	 * so we avoid passing a zero length fragment. 	 */
if|if
condition|(
name|dst_len
operator|==
literal|0
condition|)
block|{
name|ft_p
operator|++
expr_stmt|;
name|src
operator|=
name|ft_p
operator|->
name|ft_buf
expr_stmt|;
name|src_len
operator|=
name|ft_p
operator|->
name|ft_len
expr_stmt|;
name|dst_len
operator|=
name|src_len
expr_stmt|;
block|}
if|if
condition|(
name|vh
operator|&&
name|vh
operator|->
name|gso_type
operator|!=
name|VIRTIO_NET_HDR_GSO_NONE
condition|)
block|{
name|u_int
name|gso_bytes
init|=
literal|0
decl_stmt|;
comment|/* Length of the GSO packet header. */
name|u_int
name|gso_hdr_len
init|=
literal|0
decl_stmt|;
comment|/* Pointer to the GSO packet header. Assume it is in a single fragment. */
name|uint8_t
modifier|*
name|gso_hdr
init|=
name|NULL
decl_stmt|;
comment|/* Index of the current segment. */
name|u_int
name|gso_idx
init|=
literal|0
decl_stmt|;
comment|/* Payload data bytes segmented so far (e.g. TCP data bytes). */
name|u_int
name|segmented_bytes
init|=
literal|0
decl_stmt|;
comment|/* Length of the IP header (20 if IPv4, 40 if IPv6). */
name|u_int
name|iphlen
init|=
literal|0
decl_stmt|;
comment|/* Is this a TCP or an UDP GSO packet? */
name|u_int
name|tcp
init|=
operator|(
operator|(
name|vh
operator|->
name|gso_type
operator|&
operator|~
name|VIRTIO_NET_HDR_GSO_ECN
operator|)
operator|==
name|VIRTIO_NET_HDR_GSO_UDP
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|/* Segment the GSO packet contained into the input slots (frags). */
while|while
condition|(
name|ft_p
operator|!=
name|ft_end
condition|)
block|{
name|size_t
name|copy
decl_stmt|;
comment|/* Grab the GSO header if we don't have it. */
if|if
condition|(
operator|!
name|gso_hdr
condition|)
block|{
name|uint16_t
name|ethertype
decl_stmt|;
name|gso_hdr
operator|=
name|src
expr_stmt|;
comment|/* Look at the 'Ethertype' field to see if this packet 				 * is IPv4 or IPv6. 				 */
name|ethertype
operator|=
name|be16toh
argument_list|(
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|gso_hdr
operator|+
literal|12
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ethertype
operator|==
literal|0x0800
condition|)
name|iphlen
operator|=
literal|20
expr_stmt|;
else|else
comment|/* if (ethertype == 0x86DD) */
name|iphlen
operator|=
literal|40
expr_stmt|;
name|ND
argument_list|(
literal|3
argument_list|,
literal|"type=%04x"
argument_list|,
name|ethertype
argument_list|)
expr_stmt|;
comment|/* Compute gso_hdr_len. For TCP we need to read the 				 * content of the 'Data Offset' field. 				 */
if|if
condition|(
name|tcp
condition|)
block|{
name|struct
name|nm_tcphdr
modifier|*
name|tcph
init|=
operator|(
expr|struct
name|nm_tcphdr
operator|*
operator|)
operator|&
name|gso_hdr
index|[
literal|14
operator|+
name|iphlen
index|]
decl_stmt|;
name|gso_hdr_len
operator|=
literal|14
operator|+
name|iphlen
operator|+
literal|4
operator|*
operator|(
name|tcph
operator|->
name|doff
operator|>>
literal|4
operator|)
expr_stmt|;
block|}
else|else
name|gso_hdr_len
operator|=
literal|14
operator|+
name|iphlen
operator|+
literal|8
expr_stmt|;
comment|/* UDP */
name|ND
argument_list|(
literal|3
argument_list|,
literal|"gso_hdr_len %u gso_mtu %d"
argument_list|,
name|gso_hdr_len
argument_list|,
name|dst_na
operator|->
name|mfs
argument_list|)
expr_stmt|;
comment|/* Advance source pointers. */
name|src
operator|+=
name|gso_hdr_len
expr_stmt|;
name|src_len
operator|-=
name|gso_hdr_len
expr_stmt|;
if|if
condition|(
name|src_len
operator|==
literal|0
condition|)
block|{
name|ft_p
operator|++
expr_stmt|;
if|if
condition|(
name|ft_p
operator|==
name|ft_end
condition|)
break|break;
name|src
operator|=
name|ft_p
operator|->
name|ft_buf
expr_stmt|;
name|src_len
operator|=
name|ft_p
operator|->
name|ft_len
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Fill in the header of the current segment. */
if|if
condition|(
name|gso_bytes
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|gso_hdr
argument_list|,
name|gso_hdr_len
argument_list|)
expr_stmt|;
name|gso_bytes
operator|=
name|gso_hdr_len
expr_stmt|;
block|}
comment|/* Fill in data and update source and dest pointers. */
name|copy
operator|=
name|src_len
expr_stmt|;
if|if
condition|(
name|gso_bytes
operator|+
name|copy
operator|>
name|dst_na
operator|->
name|mfs
condition|)
name|copy
operator|=
name|dst_na
operator|->
name|mfs
operator|-
name|gso_bytes
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|+
name|gso_bytes
argument_list|,
name|src
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|gso_bytes
operator|+=
name|copy
expr_stmt|;
name|src
operator|+=
name|copy
expr_stmt|;
name|src_len
operator|-=
name|copy
expr_stmt|;
comment|/* A segment is complete or we have processed all the 			   the GSO payload bytes. */
if|if
condition|(
name|gso_bytes
operator|>=
name|dst_na
operator|->
name|mfs
operator|||
operator|(
name|src_len
operator|==
literal|0
operator|&&
name|ft_p
operator|+
literal|1
operator|==
name|ft_end
operator|)
condition|)
block|{
comment|/* After raw segmentation, we must fix some header 				 * fields and compute checksums, in a protocol dependent 				 * way. */
name|gso_fix_segment
argument_list|(
name|dst
argument_list|,
name|gso_bytes
argument_list|,
name|gso_idx
argument_list|,
name|segmented_bytes
argument_list|,
name|src_len
operator|==
literal|0
operator|&&
name|ft_p
operator|+
literal|1
operator|==
name|ft_end
argument_list|,
name|tcp
argument_list|,
name|iphlen
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"frame %u completed with %d bytes"
argument_list|,
name|gso_idx
argument_list|,
operator|(
name|int
operator|)
name|gso_bytes
argument_list|)
expr_stmt|;
name|slot
operator|->
name|len
operator|=
name|gso_bytes
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|segmented_bytes
operator|+=
name|gso_bytes
operator|-
name|gso_hdr_len
expr_stmt|;
name|dst_slots
operator|++
expr_stmt|;
comment|/* Next destination slot. */
operator|*
name|j
operator|=
name|nm_next
argument_list|(
operator|*
name|j
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
operator|*
name|j
index|]
expr_stmt|;
name|dst
operator|=
name|NMB
argument_list|(
operator|&
name|dst_na
operator|->
name|up
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|gso_bytes
operator|=
literal|0
expr_stmt|;
name|gso_idx
operator|++
expr_stmt|;
block|}
comment|/* Next input slot. */
if|if
condition|(
name|src_len
operator|==
literal|0
condition|)
block|{
name|ft_p
operator|++
expr_stmt|;
if|if
condition|(
name|ft_p
operator|==
name|ft_end
condition|)
break|break;
name|src
operator|=
name|ft_p
operator|->
name|ft_buf
expr_stmt|;
name|src_len
operator|=
name|ft_p
operator|->
name|ft_len
expr_stmt|;
block|}
block|}
name|ND
argument_list|(
literal|3
argument_list|,
literal|"%d bytes segmented"
argument_list|,
name|segmented_bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Address of a checksum field into a destination slot. */
name|uint16_t
modifier|*
name|check
init|=
name|NULL
decl_stmt|;
comment|/* Accumulator for an unfolded checksum. */
name|rawsum_t
name|csum
init|=
literal|0
decl_stmt|;
comment|/* Process a non-GSO packet. */
comment|/* Init 'check' if necessary. */
if|if
condition|(
name|vh
operator|&&
operator|(
name|vh
operator|->
name|flags
operator|&
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
operator|)
condition|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|vh
operator|->
name|csum_offset
operator|+
name|vh
operator|->
name|csum_start
operator|>
name|src_len
argument_list|)
condition|)
name|D
argument_list|(
literal|"invalid checksum request"
argument_list|)
expr_stmt|;
else|else
name|check
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|dst
operator|+
name|vh
operator|->
name|csum_start
operator|+
name|vh
operator|->
name|csum_offset
operator|)
expr_stmt|;
block|}
while|while
condition|(
name|ft_p
operator|!=
name|ft_end
condition|)
block|{
comment|/* Init/update the packet checksum if needed. */
if|if
condition|(
name|vh
operator|&&
operator|(
name|vh
operator|->
name|flags
operator|&
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|dst_slots
condition|)
name|csum
operator|=
name|nm_csum_raw
argument_list|(
name|src
operator|+
name|vh
operator|->
name|csum_start
argument_list|,
name|src_len
operator|-
name|vh
operator|->
name|csum_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|csum
operator|=
name|nm_csum_raw
argument_list|(
name|src
argument_list|,
name|src_len
argument_list|,
name|csum
argument_list|)
expr_stmt|;
block|}
comment|/* Round to a multiple of 64 */
name|src_len
operator|=
operator|(
name|src_len
operator|+
literal|63
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
if|if
condition|(
name|ft_p
operator|->
name|ft_flags
operator|&
name|NS_INDIRECT
condition|)
block|{
if|if
condition|(
name|copyin
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|src_len
argument_list|)
condition|)
block|{
comment|/* Invalid user pointer, pretend len is 0. */
name|dst_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
operator|(
name|int
operator|)
name|src_len
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|len
operator|=
name|dst_len
expr_stmt|;
name|dst_slots
operator|++
expr_stmt|;
comment|/* Next destination slot. */
operator|*
name|j
operator|=
name|nm_next
argument_list|(
operator|*
name|j
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
operator|*
name|j
index|]
expr_stmt|;
name|dst
operator|=
name|NMB
argument_list|(
operator|&
name|dst_na
operator|->
name|up
argument_list|,
name|slot
argument_list|)
expr_stmt|;
comment|/* Next source slot. */
name|ft_p
operator|++
expr_stmt|;
name|src
operator|=
name|ft_p
operator|->
name|ft_buf
expr_stmt|;
name|dst_len
operator|=
name|src_len
operator|=
name|ft_p
operator|->
name|ft_len
expr_stmt|;
block|}
comment|/* Finalize (fold) the checksum if needed. */
if|if
condition|(
name|check
operator|&&
name|vh
operator|&&
operator|(
name|vh
operator|->
name|flags
operator|&
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
operator|)
condition|)
block|{
operator|*
name|check
operator|=
name|nm_csum_fold
argument_list|(
name|csum
argument_list|)
expr_stmt|;
block|}
name|ND
argument_list|(
literal|3
argument_list|,
literal|"using %u dst_slots"
argument_list|,
name|dst_slots
argument_list|)
expr_stmt|;
comment|/* A second pass on the desitations slots to set the slot flags, 		 * using the right number of destination slots. 		 */
while|while
condition|(
name|j_start
operator|!=
operator|*
name|j
condition|)
block|{
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
name|j_start
index|]
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
operator|(
name|dst_slots
operator|<<
literal|8
operator|)
operator||
name|NS_MOREFRAG
expr_stmt|;
name|j_start
operator|=
name|nm_next
argument_list|(
name|j_start
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
comment|/* Clear NS_MOREFRAG flag on last entry. */
name|slot
operator|->
name|flags
operator|=
operator|(
name|dst_slots
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
comment|/* Update howmany. */
if|if
condition|(
name|unlikely
argument_list|(
name|dst_slots
operator|>
operator|*
name|howmany
argument_list|)
condition|)
block|{
name|dst_slots
operator|=
operator|*
name|howmany
expr_stmt|;
name|D
argument_list|(
literal|"Slot allocation error: Should never happen"
argument_list|)
expr_stmt|;
block|}
operator|*
name|howmany
operator|-=
name|dst_slots
expr_stmt|;
block|}
end_function

end_unit

