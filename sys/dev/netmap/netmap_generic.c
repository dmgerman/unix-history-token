begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2013-2014 Universita` di Pisa. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This module implements netmap support on top of standard,  * unmodified device drivers.  *  * A NIOCREGIF request is handled here if the device does not  * have native support. TX and RX rings are emulated as follows:  *  * NIOCREGIF  *	We preallocate a block of TX mbufs (roughly as many as  *	tx descriptors; the number is not critical) to speed up  *	operation during transmissions. The refcount on most of  *	these buffers is artificially bumped up so we can recycle  *	them more easily. Also, the destructor is intercepted  *	so we use it as an interrupt notification to wake up  *	processes blocked on a poll().  *  *	For each receive ring we allocate one "struct mbq"  *	(an mbuf tailq plus a spinlock). We intercept packets  *	(through if_input)  *	on the receive path and put them in the mbq from which  *	netmap receive routines can grab them.  *  * TX:  *	in the generic_txsync() routine, netmap buffers are copied  *	(or linked, in a future) to the preallocated mbufs  *	and pushed to the transmit queue. Some of these mbufs  *	(those with NS_REPORT, or otherwise every half ring)  *	have the refcount=1, others have refcount=2.  *	When the destructor is invoked, we take that as  *	a notification that all mbufs up to that one in  *	the specific ring have been completed, and generate  *	the equivalent of a transmit interrupt.  *  * RX:  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_comment
comment|/* PROT_EXEC */
end_comment

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* in netmap_kern.h */
end_comment

begin_comment
comment|// XXX temporary - D() defined here
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_mem2.h>
end_include

begin_define
define|#
directive|define
name|rtnl_lock
parameter_list|()
value|ND("rtnl_lock called")
end_define

begin_define
define|#
directive|define
name|rtnl_unlock
parameter_list|()
value|ND("rtnl_unlock called")
end_define

begin_define
define|#
directive|define
name|MBUF_TXQ
parameter_list|(
name|m
parameter_list|)
value|((m)->m_pkthdr.flowid)
end_define

begin_define
define|#
directive|define
name|MBUF_RXQ
parameter_list|(
name|m
parameter_list|)
value|((m)->m_pkthdr.flowid)
end_define

begin_define
define|#
directive|define
name|smp_mb
parameter_list|()
end_define

begin_comment
comment|/*  * FreeBSD mbuf allocator/deallocator in emulation mode:  *  * We allocate EXT_PACKET mbuf+clusters, but need to set M_NOFREE  * so that the destructor, if invoked, will not free the packet.  *    In principle we should set the destructor only on demand,  * but since there might be a race we better do it on allocation.  * As a consequence, we also need to set the destructor or we  * would leak buffers.  */
end_comment

begin_comment
comment|/*  * mbuf wrappers  */
end_comment

begin_comment
comment|/* mbuf destructor, also need to change the type to EXT_EXTREF,  * add an M_NOFREE flag, and then clear the flag and  * chain into uma_zfree(zone_pack, mf)  * (or reinstall the buffer ?)  */
end_comment

begin_define
define|#
directive|define
name|SET_MBUF_DESTRUCTOR
parameter_list|(
name|m
parameter_list|,
name|fn
parameter_list|)
value|do {		\ 	(m)->m_ext.ext_free = (void *)fn;	\ 	(m)->m_ext.ext_type = EXT_EXTREF;	\ } while (0)
end_define

begin_function
specifier|static
name|void
name|netmap_default_mbuf_destructor
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
comment|/* restore original mbuf */
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_arg1
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_arg1
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|=
name|EXT_PACKET
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_free
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|GET_MBUF_REFCNT
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
name|SET_MBUF_REFCNT
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|zone_pack
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|mbuf
modifier|*
name|netmap_get_mbuf
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
operator||
name|M_NOFREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|m
operator|->
name|m_ext
operator|.
name|ext_arg1
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
comment|// XXX save
name|m
operator|->
name|m_ext
operator|.
name|ext_free
operator|=
operator|(
name|void
operator|*
operator|)
name|netmap_default_mbuf_destructor
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|=
name|EXT_EXTREF
expr_stmt|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"create m %p refcnt %d"
argument_list|,
name|m
argument_list|,
name|GET_MBUF_REFCNT
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* linux */
end_comment

begin_include
include|#
directive|include
file|"bsd_glue.h"
end_include

begin_include
include|#
directive|include
file|<linux/rtnetlink.h>
end_include

begin_comment
comment|/* rtnl_[un]lock() */
end_comment

begin_include
include|#
directive|include
file|<linux/ethtool.h>
end_include

begin_comment
comment|/* struct ethtool_ops, get_ringparam */
end_comment

begin_include
include|#
directive|include
file|<linux/hrtimer.h>
end_include

begin_comment
comment|//#define REG_RESET
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* linux */
end_comment

begin_comment
comment|/* Common headers. */
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_mem2.h>
end_include

begin_comment
comment|/* ======================== usage stats =========================== */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RATE_GENERIC
end_ifdef

begin_define
define|#
directive|define
name|IFRATE
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_struct
struct|struct
name|rate_stats
block|{
name|unsigned
name|long
name|txpkt
decl_stmt|;
name|unsigned
name|long
name|txsync
decl_stmt|;
name|unsigned
name|long
name|txirq
decl_stmt|;
name|unsigned
name|long
name|rxpkt
decl_stmt|;
name|unsigned
name|long
name|rxirq
decl_stmt|;
name|unsigned
name|long
name|rxsync
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rate_context
block|{
name|unsigned
name|refcount
decl_stmt|;
name|struct
name|timer_list
name|timer
decl_stmt|;
name|struct
name|rate_stats
name|new
decl_stmt|;
name|struct
name|rate_stats
name|old
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|RATE_PRINTK
parameter_list|(
name|_NAME_
parameter_list|)
define|\
value|printk( #_NAME_ " = %lu Hz\n", (cur._NAME_ - ctx->old._NAME_)/RATE_PERIOD);
end_define

begin_define
define|#
directive|define
name|RATE_PERIOD
value|2
end_define

begin_function
specifier|static
name|void
name|rate_callback
parameter_list|(
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|struct
name|rate_context
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|rate_context
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|rate_stats
name|cur
init|=
name|ctx
operator|->
name|new
decl_stmt|;
name|int
name|r
decl_stmt|;
name|RATE_PRINTK
argument_list|(
name|txpkt
argument_list|)
expr_stmt|;
name|RATE_PRINTK
argument_list|(
name|txsync
argument_list|)
expr_stmt|;
name|RATE_PRINTK
argument_list|(
name|txirq
argument_list|)
expr_stmt|;
name|RATE_PRINTK
argument_list|(
name|rxpkt
argument_list|)
expr_stmt|;
name|RATE_PRINTK
argument_list|(
name|rxsync
argument_list|)
expr_stmt|;
name|RATE_PRINTK
argument_list|(
name|rxirq
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|old
operator|=
name|cur
expr_stmt|;
name|r
operator|=
name|mod_timer
argument_list|(
operator|&
name|ctx
operator|->
name|timer
argument_list|,
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
name|RATE_PERIOD
operator|*
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
argument_list|)
condition|)
name|D
argument_list|(
literal|"[v1000] Error: mod_timer()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|rate_context
name|rate_ctx
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|generic_rate
parameter_list|(
name|int
name|txp
parameter_list|,
name|int
name|txs
parameter_list|,
name|int
name|txi
parameter_list|,
name|int
name|rxp
parameter_list|,
name|int
name|rxs
parameter_list|,
name|int
name|rxi
parameter_list|)
block|{
if|if
condition|(
name|txp
condition|)
name|rate_ctx
operator|.
name|new
operator|.
name|txpkt
operator|++
expr_stmt|;
if|if
condition|(
name|txs
condition|)
name|rate_ctx
operator|.
name|new
operator|.
name|txsync
operator|++
expr_stmt|;
if|if
condition|(
name|txi
condition|)
name|rate_ctx
operator|.
name|new
operator|.
name|txirq
operator|++
expr_stmt|;
if|if
condition|(
name|rxp
condition|)
name|rate_ctx
operator|.
name|new
operator|.
name|rxpkt
operator|++
expr_stmt|;
if|if
condition|(
name|rxs
condition|)
name|rate_ctx
operator|.
name|new
operator|.
name|rxsync
operator|++
expr_stmt|;
if|if
condition|(
name|rxi
condition|)
name|rate_ctx
operator|.
name|new
operator|.
name|rxirq
operator|++
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !RATE */
end_comment

begin_define
define|#
directive|define
name|IFRATE
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !RATE */
end_comment

begin_comment
comment|/* =============== GENERIC NETMAP ADAPTER SUPPORT ================= */
end_comment

begin_comment
comment|/*  * Wrapper used by the generic adapter layer to notify  * the poller threads. Differently from netmap_rx_irq(), we check  * only NAF_NETMAP_ON instead of NAF_NATIVE_ON to enable the irq.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_generic_irq
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|q
parameter_list|,
name|u_int
modifier|*
name|work_done
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|nm_netmap_on
argument_list|(
name|na
argument_list|)
argument_list|)
condition|)
return|return;
name|netmap_common_irq
argument_list|(
name|ifp
argument_list|,
name|q
argument_list|,
name|work_done
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enable/disable netmap mode for a generic network interface. */
end_comment

begin_function
specifier|static
name|int
name|generic_netmap_register
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|struct
name|netmap_generic_adapter
modifier|*
name|gna
init|=
operator|(
expr|struct
name|netmap_generic_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|na
condition|)
return|return
name|EINVAL
return|;
ifdef|#
directive|ifdef
name|REG_RESET
name|error
operator|=
name|ifp
operator|->
name|netdev_ops
operator|->
name|ndo_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
endif|#
directive|endif
comment|/* REG_RESET */
if|if
condition|(
name|enable
condition|)
block|{
comment|/* Enable netmap mode. */
comment|/* Init the mitigation support on all the rx queues. */
name|gna
operator|->
name|mit
operator|=
name|malloc
argument_list|(
name|na
operator|->
name|num_rx_rings
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nm_generic_mit
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gna
operator|->
name|mit
condition|)
block|{
name|D
argument_list|(
literal|"mitigation allocation failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|na
operator|->
name|num_rx_rings
condition|;
name|r
operator|++
control|)
name|netmap_mitigation_init
argument_list|(
operator|&
name|gna
operator|->
name|mit
index|[
name|r
index|]
argument_list|,
name|r
argument_list|,
name|na
argument_list|)
expr_stmt|;
comment|/* Initialize the rx queue, as generic_rx_handler() can 		 * be called as soon as netmap_catch_rx() returns. 		 */
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|na
operator|->
name|num_rx_rings
condition|;
name|r
operator|++
control|)
block|{
name|mbq_safe_init
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|r
index|]
operator|.
name|rx_queue
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Preallocate packet buffers for the tx rings. 		 */
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|na
operator|->
name|num_tx_rings
condition|;
name|r
operator|++
control|)
name|na
operator|->
name|tx_rings
index|[
name|r
index|]
operator|.
name|tx_pool
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|na
operator|->
name|num_tx_rings
condition|;
name|r
operator|++
control|)
block|{
name|na
operator|->
name|tx_rings
index|[
name|r
index|]
operator|.
name|tx_pool
operator|=
name|malloc
argument_list|(
name|na
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mbuf
operator|*
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|na
operator|->
name|tx_rings
index|[
name|r
index|]
operator|.
name|tx_pool
condition|)
block|{
name|D
argument_list|(
literal|"tx_pool allocation failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|free_tx_pools
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
control|)
name|na
operator|->
name|tx_rings
index|[
name|r
index|]
operator|.
name|tx_pool
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|netmap_get_mbuf
argument_list|(
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|D
argument_list|(
literal|"tx_pool[%d] allocation failed"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|free_tx_pools
goto|;
block|}
name|na
operator|->
name|tx_rings
index|[
name|r
index|]
operator|.
name|tx_pool
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
block|}
block|}
name|rtnl_lock
argument_list|()
expr_stmt|;
comment|/* Prepare to intercept incoming traffic. */
name|error
operator|=
name|netmap_catch_rx
argument_list|(
name|na
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"netdev_rx_handler_register() failed (%d)"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|register_handler
goto|;
block|}
name|na
operator|->
name|na_flags
operator||=
name|NAF_NETMAP_ON
expr_stmt|;
comment|/* Make netmap control the packet steering. */
name|netmap_catch_tx
argument_list|(
name|gna
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rtnl_unlock
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|RATE_GENERIC
if|if
condition|(
name|rate_ctx
operator|.
name|refcount
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"setup_timer()"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rate_ctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rate_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|setup_timer
argument_list|(
operator|&
name|rate_ctx
operator|.
name|timer
argument_list|,
operator|&
name|rate_callback
argument_list|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|rate_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod_timer
argument_list|(
operator|&
name|rate_ctx
operator|.
name|timer
argument_list|,
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
literal|1500
argument_list|)
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"Error: mod_timer()"
argument_list|)
expr_stmt|;
block|}
block|}
name|rate_ctx
operator|.
name|refcount
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* RATE */
block|}
elseif|else
if|if
condition|(
name|na
operator|->
name|tx_rings
index|[
literal|0
index|]
operator|.
name|tx_pool
condition|)
block|{
comment|/* Disable netmap mode. We enter here only if the previous 		   generic_netmap_register(na, 1) was successfull. 		   If it was not, na->tx_rings[0].tx_pool was set to NULL by the 		   error handling code below. */
name|rtnl_lock
argument_list|()
expr_stmt|;
name|na
operator|->
name|na_flags
operator|&=
operator|~
name|NAF_NETMAP_ON
expr_stmt|;
comment|/* Release packet steering control. */
name|netmap_catch_tx
argument_list|(
name|gna
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do not intercept packets on the rx path. */
name|netmap_catch_rx
argument_list|(
name|na
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rtnl_unlock
argument_list|()
expr_stmt|;
comment|/* Free the mbufs going to the netmap rings */
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|na
operator|->
name|num_rx_rings
condition|;
name|r
operator|++
control|)
block|{
name|mbq_safe_purge
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|r
index|]
operator|.
name|rx_queue
argument_list|)
expr_stmt|;
name|mbq_safe_destroy
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|r
index|]
operator|.
name|rx_queue
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|na
operator|->
name|num_rx_rings
condition|;
name|r
operator|++
control|)
name|netmap_mitigation_cleanup
argument_list|(
operator|&
name|gna
operator|->
name|mit
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gna
operator|->
name|mit
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|na
operator|->
name|num_tx_rings
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
control|)
block|{
name|m_freem
argument_list|(
name|na
operator|->
name|tx_rings
index|[
name|r
index|]
operator|.
name|tx_pool
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|na
operator|->
name|tx_rings
index|[
name|r
index|]
operator|.
name|tx_pool
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RATE_GENERIC
if|if
condition|(
operator|--
name|rate_ctx
operator|.
name|refcount
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"del_timer()"
argument_list|)
expr_stmt|;
name|del_timer
argument_list|(
operator|&
name|rate_ctx
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|REG_RESET
name|error
operator|=
name|ifp
operator|->
name|netdev_ops
operator|->
name|ndo_open
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|free_tx_pools
goto|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
name|register_handler
label|:
name|rtnl_unlock
argument_list|()
expr_stmt|;
name|free_tx_pools
label|:
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|na
operator|->
name|num_tx_rings
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
name|na
operator|->
name|tx_rings
index|[
name|r
index|]
operator|.
name|tx_pool
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|na
operator|->
name|tx_rings
index|[
name|r
index|]
operator|.
name|tx_pool
index|[
name|i
index|]
condition|)
name|m_freem
argument_list|(
name|na
operator|->
name|tx_rings
index|[
name|r
index|]
operator|.
name|tx_pool
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|na
operator|->
name|tx_rings
index|[
name|r
index|]
operator|.
name|tx_pool
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|na
operator|->
name|tx_rings
index|[
name|r
index|]
operator|.
name|tx_pool
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|na
operator|->
name|num_rx_rings
condition|;
name|r
operator|++
control|)
block|{
name|netmap_mitigation_cleanup
argument_list|(
operator|&
name|gna
operator|->
name|mit
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|mbq_safe_destroy
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|r
index|]
operator|.
name|rx_queue
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|gna
operator|->
name|mit
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Callback invoked when the device driver frees an mbuf used  * by netmap to transmit a packet. This usually happens when  * the NIC notifies the driver that transmission is completed.  */
end_comment

begin_function
specifier|static
name|void
name|generic_mbuf_destructor
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|netmap_generic_irq
argument_list|(
name|MBUF_IFP
argument_list|(
name|m
argument_list|)
argument_list|,
name|MBUF_TXQ
argument_list|(
name|m
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|netmap_verbose
condition|)
name|RD
argument_list|(
literal|5
argument_list|,
literal|"Tx irq (%p) queue %d index %d"
argument_list|,
name|m
argument_list|,
name|MBUF_TXQ
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
name|int
operator|)
operator|(
name|uintptr_t
operator|)
name|m
operator|->
name|m_ext
operator|.
name|ext_arg1
argument_list|)
expr_stmt|;
name|netmap_default_mbuf_destructor
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD__ */
name|IFRATE
argument_list|(
name|rate_ctx
operator|.
name|new
operator|.
name|txirq
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|netmap_adaptive_io
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record completed transmissions and update hwtail.  *  * The oldest tx buffer not yet completed is at nr_hwtail + 1,  * nr_hwcur is the first unsent buffer.  */
end_comment

begin_function
specifier|static
name|u_int
name|generic_netmap_tx_clean
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
name|nm_i
init|=
name|nm_next
argument_list|(
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|lim
argument_list|)
decl_stmt|;
name|u_int
name|hwcur
init|=
name|kring
operator|->
name|nr_hwcur
decl_stmt|;
name|u_int
name|n
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|tx_pool
init|=
name|kring
operator|->
name|tx_pool
decl_stmt|;
while|while
condition|(
name|nm_i
operator|!=
name|hwcur
condition|)
block|{
comment|/* buffers not completed */
name|struct
name|mbuf
modifier|*
name|m
init|=
name|tx_pool
index|[
name|nm_i
index|]
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
comment|/* this is done, try to replenish the entry */
name|tx_pool
index|[
name|nm_i
index|]
operator|=
name|m
operator|=
name|netmap_get_mbuf
argument_list|(
name|NETMAP_BUF_SIZE
argument_list|(
name|kring
operator|->
name|na
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"mbuf allocation failed, XXX error"
argument_list|)
expr_stmt|;
comment|// XXX how do we proceed ? break ?
return|return
operator|-
name|ENOMEM
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_MBUF_REFCNT
argument_list|(
name|m
argument_list|)
operator|!=
literal|1
condition|)
block|{
break|break;
comment|/* This mbuf is still busy: its refcnt is 2. */
block|}
name|n
operator|++
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* rate adaptation */
block|if (netmap_adaptive_io> 1) { 			if (n>= netmap_adaptive_io) 				break; 		} else if (netmap_adaptive_io) {
comment|/* if hwcur - nm_i< lim/8 do an early break 			 * so we prevent the sender from stalling. See CVT. 			 */
block|if (hwcur>= nm_i) { 				if (hwcur - nm_i< lim/2) 					break; 			} else { 				if (hwcur + lim + 1 - nm_i< lim/2) 					break; 			} 		}
endif|#
directive|endif
block|}
name|kring
operator|->
name|nr_hwtail
operator|=
name|nm_prev
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"tx completed [%d] -> hwtail %d"
argument_list|,
name|n
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * We have pending packets in the driver between nr_hwtail +1 and hwcur.  * Compute a position in the middle, to be used to generate  * a notification.  */
end_comment

begin_function
specifier|static
specifier|inline
name|u_int
name|generic_tx_event_middle
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|u_int
name|hwcur
parameter_list|)
block|{
name|u_int
name|n
init|=
name|kring
operator|->
name|nkr_num_slots
decl_stmt|;
name|u_int
name|ntc
init|=
name|nm_next
argument_list|(
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|n
operator|-
literal|1
argument_list|)
decl_stmt|;
name|u_int
name|e
decl_stmt|;
if|if
condition|(
name|hwcur
operator|>=
name|ntc
condition|)
block|{
name|e
operator|=
operator|(
name|hwcur
operator|+
name|ntc
operator|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* wrap around */
name|e
operator|=
operator|(
name|hwcur
operator|+
name|n
operator|+
name|ntc
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|e
operator|>=
name|n
condition|)
block|{
name|e
operator|-=
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|e
operator|>=
name|n
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"This cannot happen"
argument_list|)
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/*  * We have pending packets in the driver between nr_hwtail+1 and hwcur.  * Schedule a notification approximately in the middle of the two.  * There is a race but this is only called within txsync which does  * a double check.  */
end_comment

begin_function
specifier|static
name|void
name|generic_set_tx_event
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|u_int
name|hwcur
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|e
decl_stmt|;
if|if
condition|(
name|nm_next
argument_list|(
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
argument_list|)
operator|==
name|hwcur
condition|)
block|{
return|return;
comment|/* all buffers are free */
block|}
name|e
operator|=
name|generic_tx_event_middle
argument_list|(
name|kring
argument_list|,
name|hwcur
argument_list|)
expr_stmt|;
name|m
operator|=
name|kring
operator|->
name|tx_pool
index|[
name|e
index|]
expr_stmt|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"Request Event at %d mbuf %p refcnt %d"
argument_list|,
name|e
argument_list|,
name|m
argument_list|,
name|m
condition|?
name|GET_MBUF_REFCNT
argument_list|(
name|m
argument_list|)
else|:
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* This can happen if there is already an event on the netmap 		   slot 'e': There is nothing to do. */
return|return;
block|}
name|kring
operator|->
name|tx_pool
index|[
name|e
index|]
operator|=
name|NULL
expr_stmt|;
name|SET_MBUF_DESTRUCTOR
argument_list|(
name|m
argument_list|,
name|generic_mbuf_destructor
argument_list|)
expr_stmt|;
comment|// XXX wmb() ?
comment|/* Decrement the refcount an free it if we have the last one. */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|smp_mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * generic_netmap_txsync() transforms netmap buffers into mbufs  * and passes them to the standard device driver  * (ndo_start_xmit() or ifp->if_transmit() ).  * On linux this is not done directly, but using dev_queue_xmit(),  * since it implements the TX flow control (and takes some locks).  */
end_comment

begin_function
specifier|static
name|int
name|generic_netmap_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|nm_i
decl_stmt|;
comment|/* index into the netmap ring */
comment|// j
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|u_int
name|ring_nr
init|=
name|kring
operator|->
name|ring_id
decl_stmt|;
name|IFRATE
argument_list|(
name|rate_ctx
operator|.
name|new
operator|.
name|txsync
operator|++
argument_list|)
expr_stmt|;
comment|// TODO: handle the case of mbuf allocation failure
name|rmb
argument_list|()
expr_stmt|;
comment|/* 	 * First part: process new packets to send. 	 */
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|nm_i
operator|!=
name|head
condition|)
block|{
comment|/* we have new packets to send */
while|while
condition|(
name|nm_i
operator|!=
name|head
condition|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
decl_stmt|;
name|u_int
name|len
init|=
name|slot
operator|->
name|len
decl_stmt|;
name|void
modifier|*
name|addr
init|=
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
decl_stmt|;
comment|/* device-specific */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|tx_ret
decl_stmt|;
name|NM_CHECK_ADDR_LEN
argument_list|(
name|na
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Tale a mbuf from the tx pool and copy in the user packet. */
name|m
operator|=
name|kring
operator|->
name|tx_pool
index|[
name|nm_i
index|]
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|m
argument_list|)
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"This should never happen"
argument_list|)
expr_stmt|;
name|kring
operator|->
name|tx_pool
index|[
name|nm_i
index|]
operator|=
name|m
operator|=
name|netmap_get_mbuf
argument_list|(
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"mbuf allocation failed"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* XXX we should ask notifications when NS_REPORT is set, 			 * or roughly every half frame. We can optimize this 			 * by lazily requesting notifications only when a 			 * transmission fails. Probably the best way is to 			 * break on failures and set notifications when 			 * ring->cur == ring->tail || nm_i != cur 			 */
name|tx_ret
operator|=
name|generic_xmit_frame
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|tx_ret
argument_list|)
condition|)
block|{
name|ND
argument_list|(
literal|5
argument_list|,
literal|"start_xmit failed: err %d [nm_i %u, head %u, hwtail %u]"
argument_list|,
name|tx_ret
argument_list|,
name|nm_i
argument_list|,
name|head
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
comment|/* 				 * No room for this mbuf in the device driver. 				 * Request a notification FOR A PREVIOUS MBUF, 				 * then call generic_netmap_tx_clean(kring) to do the 				 * double check and see if we can free more buffers. 				 * If there is space continue, else break; 				 * NOTE: the double check is necessary if the problem 				 * occurs in the txsync call after selrecord(). 				 * Also, we need some way to tell the caller that not 				 * all buffers were queued onto the device (this was 				 * not a problem with native netmap driver where space 				 * is preallocated). The bridge has a similar problem 				 * and we solve it there by dropping the excess packets. 				 */
name|generic_set_tx_event
argument_list|(
name|kring
argument_list|,
name|nm_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|generic_netmap_tx_clean
argument_list|(
name|kring
argument_list|)
condition|)
block|{
comment|/* space now available */
continue|continue;
block|}
else|else
block|{
break|break;
block|}
block|}
name|slot
operator|->
name|flags
operator|&=
operator|~
operator|(
name|NS_REPORT
operator||
name|NS_BUF_CHANGED
operator|)
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|IFRATE
argument_list|(
name|rate_ctx
operator|.
name|new
operator|.
name|txpkt
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* Update hwcur to the next slot to transmit. */
name|kring
operator|->
name|nr_hwcur
operator|=
name|nm_i
expr_stmt|;
comment|/* not head, we could break early */
block|}
comment|/* 	 * Second, reclaim completed buffers 	 */
if|if
condition|(
name|flags
operator|&
name|NAF_FORCE_RECLAIM
operator|||
name|nm_kr_txempty
argument_list|(
name|kring
argument_list|)
condition|)
block|{
comment|/* No more available slots? Set a notification event 		 * on a netmap slot that will be cleaned in the future. 		 * No doublecheck is performed, since txsync() will be 		 * called twice by netmap_poll(). 		 */
name|generic_set_tx_event
argument_list|(
name|kring
argument_list|,
name|nm_i
argument_list|)
expr_stmt|;
block|}
name|ND
argument_list|(
literal|"tx #%d, hwtail = %d"
argument_list|,
name|n
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
name|generic_netmap_tx_clean
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|nm_txsync_finalize
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This handler is registered (through netmap_catch_rx())  * within the attached network interface  * in the RX subsystem, so that every mbuf passed up by  * the driver can be stolen to the network stack.  * Stolen packets are put in a queue where the  * generic_netmap_rxsync() callback can extract them.  */
end_comment

begin_function
name|void
name|generic_rx_handler
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_generic_adapter
modifier|*
name|gna
init|=
operator|(
expr|struct
name|netmap_generic_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|u_int
name|work_done
decl_stmt|;
name|u_int
name|rr
init|=
name|MBUF_RXQ
argument_list|(
name|m
argument_list|)
decl_stmt|;
comment|// receive ring number
if|if
condition|(
name|rr
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
block|{
name|rr
operator|=
name|rr
operator|%
name|na
operator|->
name|num_rx_rings
expr_stmt|;
comment|// XXX expensive...
block|}
comment|/* limit the size of the queue */
if|if
condition|(
name|unlikely
argument_list|(
name|mbq_len
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|rr
index|]
operator|.
name|rx_queue
argument_list|)
operator|>
literal|1024
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mbq_safe_enqueue
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|rr
index|]
operator|.
name|rx_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|netmap_generic_mit
operator|<
literal|32768
condition|)
block|{
comment|/* no rx mitigation, pass notification up */
name|netmap_generic_irq
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|rr
argument_list|,
operator|&
name|work_done
argument_list|)
expr_stmt|;
name|IFRATE
argument_list|(
name|rate_ctx
operator|.
name|new
operator|.
name|rxirq
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* same as send combining, filter notification if there is a 		 * pending timer, otherwise pass it up and start a timer. 		 */
if|if
condition|(
name|likely
argument_list|(
name|netmap_mitigation_active
argument_list|(
operator|&
name|gna
operator|->
name|mit
index|[
name|rr
index|]
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Record that there is some pending work. */
name|gna
operator|->
name|mit
index|[
name|rr
index|]
operator|.
name|mit_pending
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|netmap_generic_irq
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|rr
argument_list|,
operator|&
name|work_done
argument_list|)
expr_stmt|;
name|IFRATE
argument_list|(
name|rate_ctx
operator|.
name|new
operator|.
name|rxirq
operator|++
argument_list|)
expr_stmt|;
name|netmap_mitigation_start
argument_list|(
operator|&
name|gna
operator|->
name|mit
index|[
name|rr
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * generic_netmap_rxsync() extracts mbufs from the queue filled by  * generic_netmap_rx_handler() and puts their content in the netmap  * receive ring.  * Access must be protected because the rx handler is asynchronous,  */
end_comment

begin_function
specifier|static
name|int
name|generic_netmap_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|u_int
name|nm_i
decl_stmt|;
comment|/* index into the netmap ring */
comment|//j,
name|u_int
name|n
decl_stmt|;
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|nm_rxsync_prologue
argument_list|(
name|kring
argument_list|)
decl_stmt|;
name|int
name|force_update
init|=
operator|(
name|flags
operator|&
name|NAF_FORCE_READ
operator|)
operator|||
name|kring
operator|->
name|nr_kflags
operator|&
name|NKR_PENDINTR
decl_stmt|;
if|if
condition|(
name|head
operator|>
name|lim
condition|)
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
comment|/* 	 * First part: import newly received packets. 	 */
if|if
condition|(
name|netmap_no_pendintr
operator|||
name|force_update
condition|)
block|{
comment|/* extract buffers from the rx queue, stop at most one 		 * slot before nr_hwcur (stop_i) 		 */
name|uint16_t
name|slot_flags
init|=
name|kring
operator|->
name|nkr_slot_flags
decl_stmt|;
name|u_int
name|stop_i
init|=
name|nm_prev
argument_list|(
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|lim
argument_list|)
decl_stmt|;
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
comment|/* first empty slot in the receive ring */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|nm_i
operator|!=
name|stop_i
condition|;
name|n
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
name|void
modifier|*
name|addr
init|=
name|NMB
argument_list|(
name|na
argument_list|,
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* we only check the address here on generic rx rings */
if|if
condition|(
name|addr
operator|==
name|NETMAP_BUF_BASE
argument_list|(
name|na
argument_list|)
condition|)
block|{
comment|/* Bad buffer */
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
block|}
comment|/* 			 * Call the locked version of the function. 			 * XXX Ideally we could grab a batch of mbufs at once 			 * and save some locking overhead. 			 */
name|m
operator|=
name|mbq_safe_dequeue
argument_list|(
operator|&
name|kring
operator|->
name|rx_queue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
comment|/* no more data */
break|break;
name|len
operator|=
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
operator|.
name|flags
operator|=
name|slot_flags
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
block|{
name|kring
operator|->
name|nr_hwtail
operator|=
name|nm_i
expr_stmt|;
name|IFRATE
argument_list|(
name|rate_ctx
operator|.
name|new
operator|.
name|rxpkt
operator|+=
name|n
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|nr_kflags
operator|&=
operator|~
name|NKR_PENDINTR
expr_stmt|;
block|}
comment|// XXX should we invert the order ?
comment|/* 	 * Second part: skip past packets that userspace has released. 	 */
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|nm_i
operator|!=
name|head
condition|)
block|{
comment|/* Userspace has released some packets. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|nm_i
operator|!=
name|head
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
decl_stmt|;
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_BUF_CHANGED
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwcur
operator|=
name|head
expr_stmt|;
block|}
comment|/* tell userspace that there might be new packets. */
name|nm_rxsync_finalize
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|IFRATE
argument_list|(
name|rate_ctx
operator|.
name|new
operator|.
name|rxsync
operator|++
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generic_netmap_dtor
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|netmap_generic_adapter
modifier|*
name|gna
init|=
operator|(
expr|struct
name|netmap_generic_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|prev_na
init|=
name|gna
operator|->
name|prev
decl_stmt|;
if|if
condition|(
name|prev_na
operator|!=
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"Released generic NA %p"
argument_list|,
name|gna
argument_list|)
expr_stmt|;
name|if_rele
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|netmap_adapter_put
argument_list|(
name|prev_na
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|WNA
argument_list|(
name|ifp
argument_list|)
operator|=
name|prev_na
expr_stmt|;
name|D
argument_list|(
literal|"Restored native NA %p"
argument_list|,
name|prev_na
argument_list|)
expr_stmt|;
name|na
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * generic_netmap_attach() makes it possible to use netmap on  * a device without native netmap support.  * This is less performant than native support but potentially  * faster than raw sockets or similar schemes.  *  * In this "emulated" mode, netmap rings do not necessarily  * have the same size as those in the NIC. We use a default  * value and possibly override it if the OS has ways to fetch the  * actual configuration.  */
end_comment

begin_function
name|int
name|generic_netmap_attach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|netmap_generic_adapter
modifier|*
name|gna
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|u_int
name|num_tx_desc
decl_stmt|,
name|num_rx_desc
decl_stmt|;
name|num_tx_desc
operator|=
name|num_rx_desc
operator|=
name|netmap_generic_ringsize
expr_stmt|;
comment|/* starting point */
name|generic_find_num_desc
argument_list|(
name|ifp
argument_list|,
operator|&
name|num_tx_desc
argument_list|,
operator|&
name|num_rx_desc
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"Netmap ring size: TX = %d, RX = %d"
argument_list|,
name|num_tx_desc
argument_list|,
name|num_rx_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_tx_desc
operator|==
literal|0
operator|||
name|num_rx_desc
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"Device has no hw slots (tx %u, rx %u)"
argument_list|,
name|num_tx_desc
argument_list|,
name|num_rx_desc
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|gna
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|gna
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|gna
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"no memory on attach, give up"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|na
operator|=
operator|(
expr|struct
name|netmap_adapter
operator|*
operator|)
name|gna
expr_stmt|;
name|na
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|na
operator|->
name|num_tx_desc
operator|=
name|num_tx_desc
expr_stmt|;
name|na
operator|->
name|num_rx_desc
operator|=
name|num_rx_desc
expr_stmt|;
name|na
operator|->
name|nm_register
operator|=
operator|&
name|generic_netmap_register
expr_stmt|;
name|na
operator|->
name|nm_txsync
operator|=
operator|&
name|generic_netmap_txsync
expr_stmt|;
name|na
operator|->
name|nm_rxsync
operator|=
operator|&
name|generic_netmap_rxsync
expr_stmt|;
name|na
operator|->
name|nm_dtor
operator|=
operator|&
name|generic_netmap_dtor
expr_stmt|;
comment|/* when using generic, NAF_NETMAP_ON is set so we force 	 * NAF_SKIP_INTR to use the regular interrupt handler 	 */
name|na
operator|->
name|na_flags
operator|=
name|NAF_SKIP_INTR
operator||
name|NAF_HOST_RINGS
expr_stmt|;
name|ND
argument_list|(
literal|"[GNA] num_tx_queues(%d), real_num_tx_queues(%d), len(%lu)"
argument_list|,
name|ifp
operator|->
name|num_tx_queues
argument_list|,
name|ifp
operator|->
name|real_num_tx_queues
argument_list|,
name|ifp
operator|->
name|tx_queue_len
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"[GNA] num_rx_queues(%d), real_num_rx_queues(%d)"
argument_list|,
name|ifp
operator|->
name|num_rx_queues
argument_list|,
name|ifp
operator|->
name|real_num_rx_queues
argument_list|)
expr_stmt|;
name|generic_find_num_queues
argument_list|(
name|ifp
argument_list|,
operator|&
name|na
operator|->
name|num_tx_rings
argument_list|,
operator|&
name|na
operator|->
name|num_rx_rings
argument_list|)
expr_stmt|;
name|retval
operator|=
name|netmap_attach_common
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
name|free
argument_list|(
name|gna
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

end_unit

