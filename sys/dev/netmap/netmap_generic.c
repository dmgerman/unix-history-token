begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2013-2016 Vincenzo Maffione  * Copyright (C) 2013-2016 Luigi Rizzo  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This module implements netmap support on top of standard,  * unmodified device drivers.  *  * A NIOCREGIF request is handled here if the device does not  * have native support. TX and RX rings are emulated as follows:  *  * NIOCREGIF  *	We preallocate a block of TX mbufs (roughly as many as  *	tx descriptors; the number is not critical) to speed up  *	operation during transmissions. The refcount on most of  *	these buffers is artificially bumped up so we can recycle  *	them more easily. Also, the destructor is intercepted  *	so we use it as an interrupt notification to wake up  *	processes blocked on a poll().  *  *	For each receive ring we allocate one "struct mbq"  *	(an mbuf tailq plus a spinlock). We intercept packets  *	(through if_input)  *	on the receive path and put them in the mbq from which  *	netmap receive routines can grab them.  *  * TX:  *	in the generic_txsync() routine, netmap buffers are copied  *	(or linked, in a future) to the preallocated mbufs  *	and pushed to the transmit queue. Some of these mbufs  *	(those with NS_REPORT, or otherwise every half ring)  *	have the refcount=1, others have refcount=2.  *	When the destructor is invoked, we take that as  *	a notification that all mbufs up to that one in  *	the specific ring have been completed, and generate  *	the equivalent of a transmit interrupt.  *  * RX:  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_comment
comment|/* PROT_EXEC */
end_comment

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* in netmap_kern.h */
end_comment

begin_comment
comment|// XXX temporary - D() defined here
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_mem2.h>
end_include

begin_define
define|#
directive|define
name|rtnl_lock
parameter_list|()
value|ND("rtnl_lock called")
end_define

begin_define
define|#
directive|define
name|rtnl_unlock
parameter_list|()
value|ND("rtnl_unlock called")
end_define

begin_define
define|#
directive|define
name|MBUF_RXQ
parameter_list|(
name|m
parameter_list|)
value|((m)->m_pkthdr.flowid)
end_define

begin_define
define|#
directive|define
name|smp_mb
parameter_list|()
end_define

begin_comment
comment|/*  * FreeBSD mbuf allocator/deallocator in emulation mode:  */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|1100000
end_if

begin_comment
comment|/*  * For older versions of FreeBSD:  *  * We allocate EXT_PACKET mbuf+clusters, but need to set M_NOFREE  * so that the destructor, if invoked, will not free the packet.  * In principle we should set the destructor only on demand,  * but since there might be a race we better do it on allocation.  * As a consequence, we also need to set the destructor or we  * would leak buffers.  */
end_comment

begin_comment
comment|/* mbuf destructor, also need to change the type to EXT_EXTREF,  * add an M_NOFREE flag, and then clear the flag and  * chain into uma_zfree(zone_pack, mf)  * (or reinstall the buffer ?)  */
end_comment

begin_define
define|#
directive|define
name|SET_MBUF_DESTRUCTOR
parameter_list|(
name|m
parameter_list|,
name|fn
parameter_list|)
value|do {		\ 	(m)->m_ext.ext_free = (void *)fn;	\ 	(m)->m_ext.ext_type = EXT_EXTREF;	\ } while (0)
end_define

begin_function
specifier|static
name|int
name|void_mbuf_dtor
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
comment|/* restore original mbuf */
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_arg1
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_arg1
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|=
name|EXT_PACKET
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_free
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|MBUF_REFCNT
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
name|SET_MBUF_REFCNT
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|zone_pack
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|mbuf
modifier|*
name|nm_os_get_mbuf
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
operator|(
name|void
operator|)
name|ifp
expr_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
comment|/* m_getcl() (mb_ctor_mbuf) has an assert that checks that 		 * M_NOFREE flag is not specified as third argument, 		 * so we have to set M_NOFREE after m_getcl(). */
name|m
operator|->
name|m_flags
operator||=
name|M_NOFREE
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_arg1
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
comment|// XXX save
name|m
operator|->
name|m_ext
operator|.
name|ext_free
operator|=
operator|(
name|void
operator|*
operator|)
name|void_mbuf_dtor
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|=
name|EXT_EXTREF
expr_stmt|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"create m %p refcnt %d"
argument_list|,
name|m
argument_list|,
name|MBUF_REFCNT
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __FreeBSD_version>= 1100000 */
end_comment

begin_comment
comment|/*  * Newer versions of FreeBSD, using a straightforward scheme.  *  * We allocate mbufs with m_gethdr(), since the mbuf header is needed  * by the driver. We also attach a customly-provided external storage,  * which in this case is a netmap buffer. When calling m_extadd(), however  * we pass a NULL address, since the real address (and length) will be  * filled in by nm_os_generic_xmit_frame() right before calling  * if_transmit().  *  * The dtor function does nothing, however we need it since mb_free_ext()  * has a KASSERT(), checking that the mbuf dtor function is not NULL.  */
end_comment

begin_function
specifier|static
name|void
name|void_mbuf_dtor
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{ }
end_function

begin_define
define|#
directive|define
name|SET_MBUF_DESTRUCTOR
parameter_list|(
name|m
parameter_list|,
name|fn
parameter_list|)
value|do {		\ 	(m)->m_ext.ext_free = (fn != NULL) ?		\ 	    (void *)fn : (void *)void_mbuf_dtor;	\ } while (0)
end_define

begin_function
specifier|static
specifier|inline
name|struct
name|mbuf
modifier|*
name|nm_os_get_mbuf
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
operator|(
name|void
operator|)
name|ifp
expr_stmt|;
operator|(
name|void
operator|)
name|len
expr_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return
name|m
return|;
block|}
name|m_extadd
argument_list|(
name|m
argument_list|,
name|NULL
comment|/* buf */
argument_list|,
literal|0
comment|/* size */
argument_list|,
name|void_mbuf_dtor
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|EXT_NET_DRV
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD_version>= 1100000 */
end_comment

begin_elif
elif|#
directive|elif
name|defined
name|_WIN32
end_elif

begin_include
include|#
directive|include
file|"win_glue.h"
end_include

begin_define
define|#
directive|define
name|rtnl_lock
parameter_list|()
value|ND("rtnl_lock called")
end_define

begin_define
define|#
directive|define
name|rtnl_unlock
parameter_list|()
value|ND("rtnl_unlock called")
end_define

begin_define
define|#
directive|define
name|MBUF_TXQ
parameter_list|(
name|m
parameter_list|)
value|0
end_define

begin_comment
comment|//((m)->m_pkthdr.flowid)
end_comment

begin_define
define|#
directive|define
name|MBUF_RXQ
parameter_list|(
name|m
parameter_list|)
value|0
end_define

begin_comment
comment|//((m)->m_pkthdr.flowid)
end_comment

begin_define
define|#
directive|define
name|smp_mb
parameter_list|()
end_define

begin_comment
comment|//XXX: to be correctly defined
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* linux */
end_comment

begin_include
include|#
directive|include
file|"bsd_glue.h"
end_include

begin_include
include|#
directive|include
file|<linux/rtnetlink.h>
end_include

begin_comment
comment|/* rtnl_[un]lock() */
end_comment

begin_include
include|#
directive|include
file|<linux/ethtool.h>
end_include

begin_comment
comment|/* struct ethtool_ops, get_ringparam */
end_comment

begin_include
include|#
directive|include
file|<linux/hrtimer.h>
end_include

begin_function
specifier|static
specifier|inline
name|struct
name|mbuf
modifier|*
name|nm_os_get_mbuf
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
name|alloc_skb
argument_list|(
name|ifp
operator|->
name|needed_headroom
operator|+
name|len
operator|+
name|ifp
operator|->
name|needed_tailroom
argument_list|,
name|GFP_ATOMIC
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* linux */
end_comment

begin_comment
comment|/* Common headers. */
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_mem2.h>
end_include

begin_define
define|#
directive|define
name|for_each_kring_n
parameter_list|(
name|_i
parameter_list|,
name|_k
parameter_list|,
name|_karr
parameter_list|,
name|_n
parameter_list|)
define|\
value|for (_k=_karr, _i = 0; _i< _n; (_k)++, (_i)++)
end_define

begin_define
define|#
directive|define
name|for_each_tx_kring
parameter_list|(
name|_i
parameter_list|,
name|_k
parameter_list|,
name|_na
parameter_list|)
define|\
value|for_each_kring_n(_i, _k, (_na)->tx_rings, (_na)->num_tx_rings)
end_define

begin_define
define|#
directive|define
name|for_each_tx_kring_h
parameter_list|(
name|_i
parameter_list|,
name|_k
parameter_list|,
name|_na
parameter_list|)
define|\
value|for_each_kring_n(_i, _k, (_na)->tx_rings, (_na)->num_tx_rings + 1)
end_define

begin_define
define|#
directive|define
name|for_each_rx_kring
parameter_list|(
name|_i
parameter_list|,
name|_k
parameter_list|,
name|_na
parameter_list|)
define|\
value|for_each_kring_n(_i, _k, (_na)->rx_rings, (_na)->num_rx_rings)
end_define

begin_define
define|#
directive|define
name|for_each_rx_kring_h
parameter_list|(
name|_i
parameter_list|,
name|_k
parameter_list|,
name|_na
parameter_list|)
define|\
value|for_each_kring_n(_i, _k, (_na)->rx_rings, (_na)->num_rx_rings + 1)
end_define

begin_comment
comment|/* ======================== PERFORMANCE STATISTICS =========================== */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RATE_GENERIC
end_ifdef

begin_define
define|#
directive|define
name|IFRATE
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_struct
struct|struct
name|rate_stats
block|{
name|unsigned
name|long
name|txpkt
decl_stmt|;
name|unsigned
name|long
name|txsync
decl_stmt|;
name|unsigned
name|long
name|txirq
decl_stmt|;
name|unsigned
name|long
name|txrepl
decl_stmt|;
name|unsigned
name|long
name|txdrop
decl_stmt|;
name|unsigned
name|long
name|rxpkt
decl_stmt|;
name|unsigned
name|long
name|rxirq
decl_stmt|;
name|unsigned
name|long
name|rxsync
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rate_context
block|{
name|unsigned
name|refcount
decl_stmt|;
name|struct
name|timer_list
name|timer
decl_stmt|;
name|struct
name|rate_stats
name|new
decl_stmt|;
name|struct
name|rate_stats
name|old
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|RATE_PRINTK
parameter_list|(
name|_NAME_
parameter_list|)
define|\
value|printk( #_NAME_ " = %lu Hz\n", (cur._NAME_ - ctx->old._NAME_)/RATE_PERIOD);
end_define

begin_define
define|#
directive|define
name|RATE_PERIOD
value|2
end_define

begin_function
specifier|static
name|void
name|rate_callback
parameter_list|(
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|struct
name|rate_context
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|rate_context
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|rate_stats
name|cur
init|=
name|ctx
operator|->
name|new
decl_stmt|;
name|int
name|r
decl_stmt|;
name|RATE_PRINTK
argument_list|(
name|txpkt
argument_list|)
expr_stmt|;
name|RATE_PRINTK
argument_list|(
name|txsync
argument_list|)
expr_stmt|;
name|RATE_PRINTK
argument_list|(
name|txirq
argument_list|)
expr_stmt|;
name|RATE_PRINTK
argument_list|(
name|txrepl
argument_list|)
expr_stmt|;
name|RATE_PRINTK
argument_list|(
name|txdrop
argument_list|)
expr_stmt|;
name|RATE_PRINTK
argument_list|(
name|rxpkt
argument_list|)
expr_stmt|;
name|RATE_PRINTK
argument_list|(
name|rxsync
argument_list|)
expr_stmt|;
name|RATE_PRINTK
argument_list|(
name|rxirq
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|old
operator|=
name|cur
expr_stmt|;
name|r
operator|=
name|mod_timer
argument_list|(
operator|&
name|ctx
operator|->
name|timer
argument_list|,
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
name|RATE_PERIOD
operator|*
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
argument_list|)
condition|)
name|D
argument_list|(
literal|"[v1000] Error: mod_timer()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|rate_context
name|rate_ctx
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|generic_rate
parameter_list|(
name|int
name|txp
parameter_list|,
name|int
name|txs
parameter_list|,
name|int
name|txi
parameter_list|,
name|int
name|rxp
parameter_list|,
name|int
name|rxs
parameter_list|,
name|int
name|rxi
parameter_list|)
block|{
if|if
condition|(
name|txp
condition|)
name|rate_ctx
operator|.
name|new
operator|.
name|txpkt
operator|++
expr_stmt|;
if|if
condition|(
name|txs
condition|)
name|rate_ctx
operator|.
name|new
operator|.
name|txsync
operator|++
expr_stmt|;
if|if
condition|(
name|txi
condition|)
name|rate_ctx
operator|.
name|new
operator|.
name|txirq
operator|++
expr_stmt|;
if|if
condition|(
name|rxp
condition|)
name|rate_ctx
operator|.
name|new
operator|.
name|rxpkt
operator|++
expr_stmt|;
if|if
condition|(
name|rxs
condition|)
name|rate_ctx
operator|.
name|new
operator|.
name|rxsync
operator|++
expr_stmt|;
if|if
condition|(
name|rxi
condition|)
name|rate_ctx
operator|.
name|new
operator|.
name|rxirq
operator|++
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !RATE */
end_comment

begin_define
define|#
directive|define
name|IFRATE
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !RATE */
end_comment

begin_comment
comment|/* ========== GENERIC (EMULATED) NETMAP ADAPTER SUPPORT ============= */
end_comment

begin_comment
comment|/*  * Wrapper used by the generic adapter layer to notify  * the poller threads. Differently from netmap_rx_irq(), we check  * only NAF_NETMAP_ON instead of NAF_NATIVE_ON to enable the irq.  */
end_comment

begin_function
name|void
name|netmap_generic_irq
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|q
parameter_list|,
name|u_int
modifier|*
name|work_done
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|nm_netmap_on
argument_list|(
name|na
argument_list|)
argument_list|)
condition|)
return|return;
name|netmap_common_irq
argument_list|(
name|na
argument_list|,
name|q
argument_list|,
name|work_done
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RATE_GENERIC
if|if
condition|(
name|work_done
condition|)
name|rate_ctx
operator|.
name|new
operator|.
name|rxirq
operator|++
expr_stmt|;
else|else
name|rate_ctx
operator|.
name|new
operator|.
name|txirq
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* RATE_GENERIC */
block|}
end_function

begin_function
specifier|static
name|int
name|generic_netmap_unregister
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_generic_adapter
modifier|*
name|gna
init|=
operator|(
expr|struct
name|netmap_generic_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
block|{
name|rtnl_lock
argument_list|()
expr_stmt|;
name|na
operator|->
name|na_flags
operator|&=
operator|~
name|NAF_NETMAP_ON
expr_stmt|;
comment|/* Release packet steering control. */
name|nm_os_catch_tx
argument_list|(
name|gna
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop intercepting packets on the RX path. */
name|nm_os_catch_rx
argument_list|(
name|gna
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rtnl_unlock
argument_list|()
expr_stmt|;
block|}
name|for_each_rx_kring_h
argument_list|(
argument|r
argument_list|,
argument|kring
argument_list|,
argument|na
argument_list|)
block|{
if|if
condition|(
name|nm_kring_pending_off
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"Emulated adapter: ring '%s' deactivated"
argument_list|,
name|kring
operator|->
name|name
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_mode
operator|=
name|NKR_NETMAP_OFF
expr_stmt|;
block|}
block|}
name|for_each_tx_kring_h
argument_list|(
argument|r
argument_list|,
argument|kring
argument_list|,
argument|na
argument_list|)
block|{
if|if
condition|(
name|nm_kring_pending_off
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|kring
operator|->
name|nr_mode
operator|=
name|NKR_NETMAP_OFF
expr_stmt|;
name|D
argument_list|(
literal|"Emulated adapter: ring '%s' deactivated"
argument_list|,
name|kring
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|for_each_rx_kring
argument_list|(
argument|r
argument_list|,
argument|kring
argument_list|,
argument|na
argument_list|)
block|{
comment|/* Free the mbufs still pending in the RX queues, 		 * that did not end up into the corresponding netmap 		 * RX rings. */
name|mbq_safe_purge
argument_list|(
operator|&
name|kring
operator|->
name|rx_queue
argument_list|)
expr_stmt|;
name|nm_os_mitigation_cleanup
argument_list|(
operator|&
name|gna
operator|->
name|mit
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Decrement reference counter for the mbufs in the 	 * TX pools. These mbufs can be still pending in drivers, 	 * (e.g. this happens with virtio-net driver, which 	 * does lazy reclaiming of transmitted mbufs). */
name|for_each_tx_kring
argument_list|(
argument|r
argument_list|,
argument|kring
argument_list|,
argument|na
argument_list|)
block|{
comment|/* We must remove the destructor on the TX event, 		 * because the destructor invokes netmap code, and 		 * the netmap module may disappear before the 		 * TX event is consumed. */
name|mtx_lock_spin
argument_list|(
operator|&
name|kring
operator|->
name|tx_event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|tx_event
condition|)
block|{
name|SET_MBUF_DESTRUCTOR
argument_list|(
name|kring
operator|->
name|tx_event
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|tx_event
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|kring
operator|->
name|tx_event_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
block|{
name|nm_os_free
argument_list|(
name|gna
operator|->
name|mit
argument_list|)
expr_stmt|;
name|for_each_rx_kring
argument_list|(
argument|r
argument_list|,
argument|kring
argument_list|,
argument|na
argument_list|)
block|{
name|mbq_safe_fini
argument_list|(
operator|&
name|kring
operator|->
name|rx_queue
argument_list|)
expr_stmt|;
block|}
name|for_each_tx_kring
argument_list|(
argument|r
argument_list|,
argument|kring
argument_list|,
argument|na
argument_list|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|kring
operator|->
name|tx_event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|tx_pool
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|kring
operator|->
name|tx_pool
index|[
name|i
index|]
condition|)
block|{
name|m_freem
argument_list|(
name|kring
operator|->
name|tx_pool
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|nm_os_free
argument_list|(
name|kring
operator|->
name|tx_pool
argument_list|)
expr_stmt|;
name|kring
operator|->
name|tx_pool
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RATE_GENERIC
if|if
condition|(
operator|--
name|rate_ctx
operator|.
name|refcount
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"del_timer()"
argument_list|)
expr_stmt|;
name|del_timer
argument_list|(
operator|&
name|rate_ctx
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|D
argument_list|(
literal|"Emulated adapter for %s deactivated"
argument_list|,
name|na
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Enable/disable netmap mode for a generic network interface. */
end_comment

begin_function
specifier|static
name|int
name|generic_netmap_register
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|struct
name|netmap_generic_adapter
modifier|*
name|gna
init|=
operator|(
expr|struct
name|netmap_generic_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|na
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
name|enable
condition|)
block|{
comment|/* This is actually an unregif. */
return|return
name|generic_netmap_unregister
argument_list|(
name|na
argument_list|)
return|;
block|}
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"Emulated adapter for %s activated"
argument_list|,
name|na
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Do all memory allocations when (na->active_fds == 0), to 		 * simplify error management. */
comment|/* Allocate memory for mitigation support on all the rx queues. */
name|gna
operator|->
name|mit
operator|=
name|nm_os_malloc
argument_list|(
name|na
operator|->
name|num_rx_rings
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nm_generic_mit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gna
operator|->
name|mit
condition|)
block|{
name|D
argument_list|(
literal|"mitigation allocation failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|for_each_rx_kring
argument_list|(
argument|r
argument_list|,
argument|kring
argument_list|,
argument|na
argument_list|)
block|{
comment|/* Init mitigation support. */
name|nm_os_mitigation_init
argument_list|(
operator|&
name|gna
operator|->
name|mit
index|[
name|r
index|]
argument_list|,
name|r
argument_list|,
name|na
argument_list|)
expr_stmt|;
comment|/* Initialize the rx queue, as generic_rx_handler() can 			 * be called as soon as nm_os_catch_rx() returns. 			 */
name|mbq_safe_init
argument_list|(
operator|&
name|kring
operator|->
name|rx_queue
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Prepare mbuf pools (parallel to the tx rings), for packet 		 * transmission. Don't preallocate the mbufs here, it's simpler 		 * to leave this task to txsync. 		 */
name|for_each_tx_kring
argument_list|(
argument|r
argument_list|,
argument|kring
argument_list|,
argument|na
argument_list|)
block|{
name|kring
operator|->
name|tx_pool
operator|=
name|NULL
expr_stmt|;
block|}
name|for_each_tx_kring
argument_list|(
argument|r
argument_list|,
argument|kring
argument_list|,
argument|na
argument_list|)
block|{
name|kring
operator|->
name|tx_pool
operator|=
name|nm_os_malloc
argument_list|(
name|na
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mbuf
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kring
operator|->
name|tx_pool
condition|)
block|{
name|D
argument_list|(
literal|"tx_pool allocation failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|free_tx_pools
goto|;
block|}
name|mtx_init
argument_list|(
operator|&
name|kring
operator|->
name|tx_event_lock
argument_list|,
literal|"tx_event_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
block|}
block|}
name|for_each_rx_kring_h
argument_list|(
argument|r
argument_list|,
argument|kring
argument_list|,
argument|na
argument_list|)
block|{
if|if
condition|(
name|nm_kring_pending_on
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"Emulated adapter: ring '%s' activated"
argument_list|,
name|kring
operator|->
name|name
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_mode
operator|=
name|NKR_NETMAP_ON
expr_stmt|;
block|}
block|}
name|for_each_tx_kring_h
argument_list|(
argument|r
argument_list|,
argument|kring
argument_list|,
argument|na
argument_list|)
block|{
if|if
condition|(
name|nm_kring_pending_on
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"Emulated adapter: ring '%s' activated"
argument_list|,
name|kring
operator|->
name|name
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_mode
operator|=
name|NKR_NETMAP_ON
expr_stmt|;
block|}
block|}
name|for_each_tx_kring
argument_list|(
argument|r
argument_list|,
argument|kring
argument_list|,
argument|na
argument_list|)
block|{
comment|/* Initialize tx_pool and tx_event. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|->
name|tx_pool
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|kring
operator|->
name|tx_event
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
block|{
name|rtnl_lock
argument_list|()
expr_stmt|;
comment|/* Prepare to intercept incoming traffic. */
name|error
operator|=
name|nm_os_catch_rx
argument_list|(
name|gna
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"nm_os_catch_rx(1) failed (%d)"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|register_handler
goto|;
block|}
comment|/* Make netmap control the packet steering. */
name|error
operator|=
name|nm_os_catch_tx
argument_list|(
name|gna
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"nm_os_catch_tx(1) failed (%d)"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|catch_rx
goto|;
block|}
name|rtnl_unlock
argument_list|()
expr_stmt|;
name|na
operator|->
name|na_flags
operator||=
name|NAF_NETMAP_ON
expr_stmt|;
ifdef|#
directive|ifdef
name|RATE_GENERIC
if|if
condition|(
name|rate_ctx
operator|.
name|refcount
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"setup_timer()"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rate_ctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rate_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|setup_timer
argument_list|(
operator|&
name|rate_ctx
operator|.
name|timer
argument_list|,
operator|&
name|rate_callback
argument_list|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|rate_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod_timer
argument_list|(
operator|&
name|rate_ctx
operator|.
name|timer
argument_list|,
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
literal|1500
argument_list|)
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"Error: mod_timer()"
argument_list|)
expr_stmt|;
block|}
block|}
name|rate_ctx
operator|.
name|refcount
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* RATE */
block|}
return|return
literal|0
return|;
comment|/* Here (na->active_fds == 0) holds. */
name|catch_rx
label|:
name|nm_os_catch_rx
argument_list|(
name|gna
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|register_handler
label|:
name|rtnl_unlock
argument_list|()
expr_stmt|;
name|free_tx_pools
label|:
name|for_each_tx_kring
argument_list|(
argument|r
argument_list|,
argument|kring
argument_list|,
argument|na
argument_list|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|kring
operator|->
name|tx_event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|tx_pool
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
name|nm_os_free
argument_list|(
name|kring
operator|->
name|tx_pool
argument_list|)
expr_stmt|;
name|kring
operator|->
name|tx_pool
operator|=
name|NULL
expr_stmt|;
block|}
name|for_each_rx_kring
argument_list|(
argument|r
argument_list|,
argument|kring
argument_list|,
argument|na
argument_list|)
block|{
name|mbq_safe_fini
argument_list|(
operator|&
name|kring
operator|->
name|rx_queue
argument_list|)
expr_stmt|;
block|}
name|nm_os_free
argument_list|(
name|gna
operator|->
name|mit
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Callback invoked when the device driver frees an mbuf used  * by netmap to transmit a packet. This usually happens when  * the NIC notifies the driver that transmission is completed.  */
end_comment

begin_function
specifier|static
name|void
name|generic_mbuf_destructor
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|GEN_TX_MBUF_IFP
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|unsigned
name|int
name|r
init|=
name|MBUF_TXQ
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|r_orig
init|=
name|r
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|nm_netmap_on
argument_list|(
name|na
argument_list|)
operator|||
name|r
operator|>=
name|na
operator|->
name|num_tx_rings
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"Error: no netmap adapter on device %p"
argument_list|,
name|GEN_TX_MBUF_IFP
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * First, clear the event mbuf. 	 * In principle, the event 'm' should match the one stored 	 * on ring 'r'. However we check it explicitely to stay 	 * safe against lower layers (qdisc, driver, etc.) changing 	 * MBUF_TXQ(m) under our feet. If the match is not found 	 * on 'r', we try to see if it belongs to some other ring. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|bool
name|match
init|=
name|false
decl_stmt|;
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|r
index|]
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|kring
operator|->
name|tx_event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|tx_event
operator|==
name|m
condition|)
block|{
name|kring
operator|->
name|tx_event
operator|=
name|NULL
expr_stmt|;
name|match
operator|=
name|true
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|kring
operator|->
name|tx_event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
condition|)
block|{
if|if
condition|(
name|r
operator|!=
name|r_orig
condition|)
block|{
name|RD
argument_list|(
literal|1
argument_list|,
literal|"event %p migrated: ring %u --> %u"
argument_list|,
name|m
argument_list|,
name|r_orig
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|++
name|r
operator|==
name|na
operator|->
name|num_tx_rings
condition|)
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|r_orig
condition|)
block|{
name|RD
argument_list|(
literal|1
argument_list|,
literal|"Cannot match event %p"
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Second, wake up clients. They will reclaim the event through 	 * txsync. */
name|netmap_generic_irq
argument_list|(
name|na
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|void_mbuf_dtor
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Record completed transmissions and update hwtail.  *  * The oldest tx buffer not yet completed is at nr_hwtail + 1,  * nr_hwcur is the first unsent buffer.  */
end_comment

begin_function
specifier|static
name|u_int
name|generic_netmap_tx_clean
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|txqdisc
parameter_list|)
block|{
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
name|nm_i
init|=
name|nm_next
argument_list|(
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|lim
argument_list|)
decl_stmt|;
name|u_int
name|hwcur
init|=
name|kring
operator|->
name|nr_hwcur
decl_stmt|;
name|u_int
name|n
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|tx_pool
init|=
name|kring
operator|->
name|tx_pool
decl_stmt|;
name|ND
argument_list|(
literal|"hwcur = %d, hwtail = %d"
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
while|while
condition|(
name|nm_i
operator|!=
name|hwcur
condition|)
block|{
comment|/* buffers not completed */
name|struct
name|mbuf
modifier|*
name|m
init|=
name|tx_pool
index|[
name|nm_i
index|]
decl_stmt|;
if|if
condition|(
name|txqdisc
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* Nothing to do, this is going 				 * to be replenished. */
name|RD
argument_list|(
literal|3
argument_list|,
literal|"Is this happening?"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MBUF_QUEUED
argument_list|(
name|m
argument_list|)
condition|)
block|{
break|break;
comment|/* Not dequeued yet. */
block|}
elseif|else
if|if
condition|(
name|MBUF_REFCNT
argument_list|(
name|m
argument_list|)
operator|!=
literal|1
condition|)
block|{
comment|/* This mbuf has been dequeued but is still busy 				 * (refcount is 2). 				 * Leave it to the driver and replenish. */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|tx_pool
index|[
name|nm_i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|int
name|event_consumed
decl_stmt|;
comment|/* This slot was used to place an event. */
name|mtx_lock_spin
argument_list|(
operator|&
name|kring
operator|->
name|tx_event_lock
argument_list|)
expr_stmt|;
name|event_consumed
operator|=
operator|(
name|kring
operator|->
name|tx_event
operator|==
name|NULL
operator|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|kring
operator|->
name|tx_event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event_consumed
condition|)
block|{
comment|/* The event has not been consumed yet, 					 * still busy in the driver. */
break|break;
block|}
comment|/* The event has been consumed, we can go 				 * ahead. */
block|}
elseif|else
if|if
condition|(
name|MBUF_REFCNT
argument_list|(
name|m
argument_list|)
operator|!=
literal|1
condition|)
block|{
comment|/* This mbuf is still busy: its refcnt is 2. */
break|break;
block|}
block|}
name|n
operator|++
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwtail
operator|=
name|nm_prev
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"tx completed [%d] -> hwtail %d"
argument_list|,
name|n
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Compute a slot index in the middle between inf and sup. */
end_comment

begin_function
specifier|static
specifier|inline
name|u_int
name|ring_middle
parameter_list|(
name|u_int
name|inf
parameter_list|,
name|u_int
name|sup
parameter_list|,
name|u_int
name|lim
parameter_list|)
block|{
name|u_int
name|n
init|=
name|lim
operator|+
literal|1
decl_stmt|;
name|u_int
name|e
decl_stmt|;
if|if
condition|(
name|sup
operator|>=
name|inf
condition|)
block|{
name|e
operator|=
operator|(
name|sup
operator|+
name|inf
operator|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* wrap around */
name|e
operator|=
operator|(
name|sup
operator|+
name|n
operator|+
name|inf
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|e
operator|>=
name|n
condition|)
block|{
name|e
operator|-=
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|e
operator|>=
name|n
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"This cannot happen"
argument_list|)
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generic_set_tx_event
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|u_int
name|hwcur
parameter_list|)
block|{
name|u_int
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|e
decl_stmt|;
name|u_int
name|ntc
init|=
name|nm_next
argument_list|(
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|lim
argument_list|)
decl_stmt|;
comment|/* next to clean */
if|if
condition|(
name|ntc
operator|==
name|hwcur
condition|)
block|{
return|return;
comment|/* all buffers are free */
block|}
comment|/* 	 * We have pending packets in the driver between hwtail+1 	 * and hwcur, and we have to chose one of these slot to 	 * generate a notification. 	 * There is a race but this is only called within txsync which 	 * does a double check. 	 */
if|#
directive|if
literal|0
comment|/* Choose a slot in the middle, so that we don't risk ending 	 * up in a situation where the client continuously wake up, 	 * fills one or a few TX slots and go to sleep again. */
block|e = ring_middle(ntc, hwcur, lim);
else|#
directive|else
comment|/* Choose the first pending slot, to be safe against driver 	 * reordering mbuf transmissions. */
name|e
operator|=
name|ntc
expr_stmt|;
endif|#
directive|endif
name|m
operator|=
name|kring
operator|->
name|tx_pool
index|[
name|e
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* An event is already in place. */
return|return;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|kring
operator|->
name|tx_event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|tx_event
condition|)
block|{
comment|/* An event is already in place. */
name|mtx_unlock_spin
argument_list|(
operator|&
name|kring
operator|->
name|tx_event_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|SET_MBUF_DESTRUCTOR
argument_list|(
name|m
argument_list|,
name|generic_mbuf_destructor
argument_list|)
expr_stmt|;
name|kring
operator|->
name|tx_event
operator|=
name|m
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|kring
operator|->
name|tx_event_lock
argument_list|)
expr_stmt|;
name|kring
operator|->
name|tx_pool
index|[
name|e
index|]
operator|=
name|NULL
expr_stmt|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"Request Event at %d mbuf %p refcnt %d"
argument_list|,
name|e
argument_list|,
name|m
argument_list|,
name|m
condition|?
name|MBUF_REFCNT
argument_list|(
name|m
argument_list|)
else|:
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Decrement the refcount. This will free it if we lose the race 	 * with the driver. */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|smp_mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * generic_netmap_txsync() transforms netmap buffers into mbufs  * and passes them to the standard device driver  * (ndo_start_xmit() or ifp->if_transmit() ).  * On linux this is not done directly, but using dev_queue_xmit(),  * since it implements the TX flow control (and takes some locks).  */
end_comment

begin_function
specifier|static
name|int
name|generic_netmap_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|struct
name|netmap_generic_adapter
modifier|*
name|gna
init|=
operator|(
expr|struct
name|netmap_generic_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|nm_i
decl_stmt|;
comment|/* index into the netmap ring */
comment|// j
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|u_int
name|ring_nr
init|=
name|kring
operator|->
name|ring_id
decl_stmt|;
name|IFRATE
argument_list|(
name|rate_ctx
operator|.
name|new
operator|.
name|txsync
operator|++
argument_list|)
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
comment|/* 	 * First part: process new packets to send. 	 */
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|nm_i
operator|!=
name|head
condition|)
block|{
comment|/* we have new packets to send */
name|struct
name|nm_os_gen_arg
name|a
decl_stmt|;
name|u_int
name|event
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|gna
operator|->
name|txqdisc
operator|&&
name|nm_kr_txempty
argument_list|(
name|kring
argument_list|)
condition|)
block|{
comment|/* In txqdisc mode, we ask for a delayed notification, 			 * but only when cur == hwtail, which means that the 			 * client is going to block. */
name|event
operator|=
name|ring_middle
argument_list|(
name|nm_i
argument_list|,
name|head
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|3
argument_list|,
literal|"Place txqdisc event (hwcur=%u,event=%u,"
literal|"head=%u,hwtail=%u)"
argument_list|,
name|nm_i
argument_list|,
name|event
argument_list|,
name|head
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
block|}
name|a
operator|.
name|ifp
operator|=
name|ifp
expr_stmt|;
name|a
operator|.
name|ring_nr
operator|=
name|ring_nr
expr_stmt|;
name|a
operator|.
name|head
operator|=
name|a
operator|.
name|tail
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|nm_i
operator|!=
name|head
condition|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
decl_stmt|;
name|u_int
name|len
init|=
name|slot
operator|->
name|len
decl_stmt|;
name|void
modifier|*
name|addr
init|=
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
decl_stmt|;
comment|/* device-specific */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|tx_ret
decl_stmt|;
name|NM_CHECK_ADDR_LEN
argument_list|(
name|na
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Tale a mbuf from the tx pool (replenishing the pool 			 * entry if necessary) and copy in the user packet. */
name|m
operator|=
name|kring
operator|->
name|tx_pool
index|[
name|nm_i
index|]
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|kring
operator|->
name|tx_pool
index|[
name|nm_i
index|]
operator|=
name|m
operator|=
name|nm_os_get_mbuf
argument_list|(
name|ifp
argument_list|,
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|RD
argument_list|(
literal|2
argument_list|,
literal|"Failed to replenish mbuf"
argument_list|)
expr_stmt|;
comment|/* Here we could schedule a timer which 					 * retries to replenish after a while, 					 * and notifies the client when it 					 * manages to replenish some slots. In 					 * any case we break early to avoid 					 * crashes. */
break|break;
block|}
name|IFRATE
argument_list|(
name|rate_ctx
operator|.
name|new
operator|.
name|txrepl
operator|++
argument_list|)
expr_stmt|;
block|}
name|a
operator|.
name|m
operator|=
name|m
expr_stmt|;
name|a
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|a
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|a
operator|.
name|qevent
operator|=
operator|(
name|nm_i
operator|==
name|event
operator|)
expr_stmt|;
comment|/* When not in txqdisc mode, we should ask 			 * notifications when NS_REPORT is set, or roughly 			 * every half ring. To optimize this, we set a 			 * notification event when the client runs out of 			 * TX ring space, or when transmission fails. In 			 * the latter case we also break early. 			 */
name|tx_ret
operator|=
name|nm_os_generic_xmit_frame
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|tx_ret
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|gna
operator|->
name|txqdisc
condition|)
block|{
comment|/* 					 * No room for this mbuf in the device driver. 					 * Request a notification FOR A PREVIOUS MBUF, 					 * then call generic_netmap_tx_clean(kring) to do the 					 * double check and see if we can free more buffers. 					 * If there is space continue, else break; 					 * NOTE: the double check is necessary if the problem 					 * occurs in the txsync call after selrecord(). 					 * Also, we need some way to tell the caller that not 					 * all buffers were queued onto the device (this was 					 * not a problem with native netmap driver where space 					 * is preallocated). The bridge has a similar problem 					 * and we solve it there by dropping the excess packets. 					 */
name|generic_set_tx_event
argument_list|(
name|kring
argument_list|,
name|nm_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|generic_netmap_tx_clean
argument_list|(
name|kring
argument_list|,
name|gna
operator|->
name|txqdisc
argument_list|)
condition|)
block|{
comment|/* space now available */
continue|continue;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|/* In txqdisc mode, the netmap-aware qdisc 				 * queue has the same length as the number of 				 * netmap slots (N). Since tail is advanced 				 * only when packets are dequeued, qdisc 				 * queue overrun cannot happen, so 				 * nm_os_generic_xmit_frame() did not fail 				 * because of that. 				 * However, packets can be dropped because 				 * carrier is off, or because our qdisc is 				 * being deactivated, or possibly for other 				 * reasons. In these cases, we just let the 				 * packet to be dropped. */
name|IFRATE
argument_list|(
name|rate_ctx
operator|.
name|new
operator|.
name|txdrop
operator|++
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|flags
operator|&=
operator|~
operator|(
name|NS_REPORT
operator||
name|NS_BUF_CHANGED
operator|)
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|IFRATE
argument_list|(
name|rate_ctx
operator|.
name|new
operator|.
name|txpkt
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|.
name|head
operator|!=
name|NULL
condition|)
block|{
name|a
operator|.
name|addr
operator|=
name|NULL
expr_stmt|;
name|nm_os_generic_xmit_frame
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
block|}
comment|/* Update hwcur to the next slot to transmit. Here nm_i 		 * is not necessarily head, we could break early. */
name|kring
operator|->
name|nr_hwcur
operator|=
name|nm_i
expr_stmt|;
block|}
comment|/* 	 * Second, reclaim completed buffers 	 */
if|if
condition|(
operator|!
name|gna
operator|->
name|txqdisc
operator|&&
operator|(
name|flags
operator|&
name|NAF_FORCE_RECLAIM
operator|||
name|nm_kr_txempty
argument_list|(
name|kring
argument_list|)
operator|)
condition|)
block|{
comment|/* No more available slots? Set a notification event 		 * on a netmap slot that will be cleaned in the future. 		 * No doublecheck is performed, since txsync() will be 		 * called twice by netmap_poll(). 		 */
name|generic_set_tx_event
argument_list|(
name|kring
argument_list|,
name|nm_i
argument_list|)
expr_stmt|;
block|}
name|generic_netmap_tx_clean
argument_list|(
name|kring
argument_list|,
name|gna
operator|->
name|txqdisc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This handler is registered (through nm_os_catch_rx())  * within the attached network interface  * in the RX subsystem, so that every mbuf passed up by  * the driver can be stolen to the network stack.  * Stolen packets are put in a queue where the  * generic_netmap_rxsync() callback can extract them.  * Returns 1 if the packet was stolen, 0 otherwise.  */
end_comment

begin_function
name|int
name|generic_rx_handler
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_generic_adapter
modifier|*
name|gna
init|=
operator|(
expr|struct
name|netmap_generic_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|u_int
name|work_done
decl_stmt|;
name|u_int
name|r
init|=
name|MBUF_RXQ
argument_list|(
name|m
argument_list|)
decl_stmt|;
comment|/* receive ring number */
if|if
condition|(
name|r
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
block|{
name|r
operator|=
name|r
operator|%
name|na
operator|->
name|num_rx_rings
expr_stmt|;
block|}
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|r
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_mode
operator|==
name|NKR_NETMAP_OFF
condition|)
block|{
comment|/* We must not intercept this mbuf. */
return|return
literal|0
return|;
block|}
comment|/* limit the size of the queue */
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|gna
operator|->
name|rxsg
operator|&&
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
operator|>
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This may happen when GRO/LRO features are enabled for 		 * the NIC driver when the generic adapter does not 		 * support RX scatter-gather. */
name|RD
argument_list|(
literal|2
argument_list|,
literal|"Warning: driver pushed up big packet "
literal|"(size=%d)"
argument_list|,
operator|(
name|int
operator|)
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|mbq_len
argument_list|(
operator|&
name|kring
operator|->
name|rx_queue
argument_list|)
operator|>
literal|1024
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mbq_safe_enqueue
argument_list|(
operator|&
name|kring
operator|->
name|rx_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|netmap_generic_mit
operator|<
literal|32768
condition|)
block|{
comment|/* no rx mitigation, pass notification up */
name|netmap_generic_irq
argument_list|(
name|na
argument_list|,
name|r
argument_list|,
operator|&
name|work_done
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* same as send combining, filter notification if there is a 		 * pending timer, otherwise pass it up and start a timer. 		 */
if|if
condition|(
name|likely
argument_list|(
name|nm_os_mitigation_active
argument_list|(
operator|&
name|gna
operator|->
name|mit
index|[
name|r
index|]
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Record that there is some pending work. */
name|gna
operator|->
name|mit
index|[
name|r
index|]
operator|.
name|mit_pending
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|netmap_generic_irq
argument_list|(
name|na
argument_list|,
name|r
argument_list|,
operator|&
name|work_done
argument_list|)
expr_stmt|;
name|nm_os_mitigation_start
argument_list|(
operator|&
name|gna
operator|->
name|mit
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We have intercepted the mbuf. */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * generic_netmap_rxsync() extracts mbufs from the queue filled by  * generic_netmap_rx_handler() and puts their content in the netmap  * receive ring.  * Access must be protected because the rx handler is asynchronous,  */
end_comment

begin_function
specifier|static
name|int
name|generic_netmap_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|u_int
name|nm_i
decl_stmt|;
comment|/* index into the netmap ring */
comment|//j,
name|u_int
name|n
decl_stmt|;
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|int
name|force_update
init|=
operator|(
name|flags
operator|&
name|NAF_FORCE_READ
operator|)
operator|||
name|kring
operator|->
name|nr_kflags
operator|&
name|NKR_PENDINTR
decl_stmt|;
comment|/* Adapter-specific variables. */
name|uint16_t
name|slot_flags
init|=
name|kring
operator|->
name|nkr_slot_flags
decl_stmt|;
name|u_int
name|nm_buf_len
init|=
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
decl_stmt|;
name|struct
name|mbq
name|tmpq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|avail
decl_stmt|;
comment|/* in bytes */
name|int
name|mlen
decl_stmt|;
name|int
name|copy
decl_stmt|;
if|if
condition|(
name|head
operator|>
name|lim
condition|)
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
name|IFRATE
argument_list|(
name|rate_ctx
operator|.
name|new
operator|.
name|rxsync
operator|++
argument_list|)
expr_stmt|;
comment|/* 	 * First part: skip past packets that userspace has released. 	 * This can possibly make room for the second part. 	 */
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|nm_i
operator|!=
name|head
condition|)
block|{
comment|/* Userspace has released some packets. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|nm_i
operator|!=
name|head
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
decl_stmt|;
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_BUF_CHANGED
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwcur
operator|=
name|head
expr_stmt|;
block|}
comment|/* 	 * Second part: import newly received packets. 	 */
if|if
condition|(
operator|!
name|netmap_no_pendintr
operator|&&
operator|!
name|force_update
condition|)
block|{
return|return
literal|0
return|;
block|}
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
comment|/* First empty slot in the receive ring. */
comment|/* Compute the available space (in bytes) in this netmap ring. 	 * The first slot that is not considered in is the one before 	 * nr_hwcur. */
name|avail
operator|=
name|nm_prev
argument_list|(
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|lim
argument_list|)
operator|-
name|nm_i
expr_stmt|;
if|if
condition|(
name|avail
operator|<
literal|0
condition|)
name|avail
operator|+=
name|lim
operator|+
literal|1
expr_stmt|;
name|avail
operator|*=
name|nm_buf_len
expr_stmt|;
comment|/* First pass: While holding the lock on the RX mbuf queue, 	 * extract as many mbufs as they fit the available space, 	 * and put them in a temporary queue. 	 * To avoid performing a per-mbuf division (mlen / nm_buf_len) to 	 * to update avail, we do the update in a while loop that we 	 * also use to set the RX slots, but without performing the copy. */
name|mbq_init
argument_list|(
operator|&
name|tmpq
argument_list|)
expr_stmt|;
name|mbq_lock
argument_list|(
operator|&
name|kring
operator|->
name|rx_queue
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
condition|;
name|n
operator|++
control|)
block|{
name|m
operator|=
name|mbq_peek
argument_list|(
operator|&
name|kring
operator|->
name|rx_queue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
comment|/* No more packets from the driver. */
break|break;
block|}
name|mlen
operator|=
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlen
operator|>
name|avail
condition|)
block|{
comment|/* No more space in the ring. */
break|break;
block|}
name|mbq_dequeue
argument_list|(
operator|&
name|kring
operator|->
name|rx_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|mlen
condition|)
block|{
name|copy
operator|=
name|nm_buf_len
expr_stmt|;
if|if
condition|(
name|mlen
operator|<
name|copy
condition|)
block|{
name|copy
operator|=
name|mlen
expr_stmt|;
block|}
name|mlen
operator|-=
name|copy
expr_stmt|;
name|avail
operator|-=
name|nm_buf_len
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
operator|.
name|len
operator|=
name|copy
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
operator|.
name|flags
operator|=
name|slot_flags
operator||
operator|(
name|mlen
condition|?
name|NS_MOREFRAG
else|:
literal|0
operator|)
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
name|mbq_enqueue
argument_list|(
operator|&
name|tmpq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|mbq_unlock
argument_list|(
operator|&
name|kring
operator|->
name|rx_queue
argument_list|)
expr_stmt|;
comment|/* Second pass: Drain the temporary queue, going over the used RX slots, 	 * and perform the copy out of the RX queue lock. */
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|void
modifier|*
name|nmaddr
decl_stmt|;
name|int
name|ofs
init|=
literal|0
decl_stmt|;
name|int
name|morefrag
decl_stmt|;
name|m
operator|=
name|mbq_dequeue
argument_list|(
operator|&
name|tmpq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
break|break;
block|}
do|do
block|{
name|nmaddr
operator|=
name|NMB
argument_list|(
name|na
argument_list|,
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
argument_list|)
expr_stmt|;
comment|/* We only check the address here on generic rx rings. */
if|if
condition|(
name|nmaddr
operator|==
name|NETMAP_BUF_BASE
argument_list|(
name|na
argument_list|)
condition|)
block|{
comment|/* Bad buffer */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mbq_purge
argument_list|(
operator|&
name|tmpq
argument_list|)
expr_stmt|;
name|mbq_fini
argument_list|(
operator|&
name|tmpq
argument_list|)
expr_stmt|;
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
block|}
name|copy
operator|=
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
operator|.
name|len
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|ofs
argument_list|,
name|copy
argument_list|,
name|nmaddr
argument_list|)
expr_stmt|;
name|ofs
operator|+=
name|copy
expr_stmt|;
name|morefrag
operator|=
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
operator|.
name|flags
operator|&
name|NS_MOREFRAG
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|morefrag
condition|)
do|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|mbq_fini
argument_list|(
operator|&
name|tmpq
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|kring
operator|->
name|nr_hwtail
operator|=
name|nm_i
expr_stmt|;
name|IFRATE
argument_list|(
name|rate_ctx
operator|.
name|new
operator|.
name|rxpkt
operator|+=
name|n
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|nr_kflags
operator|&=
operator|~
name|NKR_PENDINTR
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generic_netmap_dtor
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_generic_adapter
modifier|*
name|gna
init|=
operator|(
expr|struct
name|netmap_generic_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|netmap_generic_getifp
argument_list|(
name|gna
argument_list|)
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|prev_na
init|=
name|gna
operator|->
name|prev
decl_stmt|;
if|if
condition|(
name|prev_na
operator|!=
name|NULL
condition|)
block|{
name|netmap_adapter_put
argument_list|(
name|prev_na
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_iszombie
argument_list|(
name|na
argument_list|)
condition|)
block|{
comment|/* 		         * The driver has been removed without releasing 		         * the reference so we need to do it here. 		         */
name|netmap_adapter_put
argument_list|(
name|prev_na
argument_list|)
expr_stmt|;
block|}
name|D
argument_list|(
literal|"Native netmap adapter %p restored"
argument_list|,
name|prev_na
argument_list|)
expr_stmt|;
block|}
name|NM_ATTACH_NA
argument_list|(
name|ifp
argument_list|,
name|prev_na
argument_list|)
expr_stmt|;
comment|/* 	 * netmap_detach_common(), that it's called after this function, 	 * overrides WNA(ifp) if na->ifp is not NULL. 	 */
name|na
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
name|D
argument_list|(
literal|"Emulated netmap adapter for %s destroyed"
argument_list|,
name|na
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|na_is_generic
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
return|return
name|na
operator|->
name|nm_register
operator|==
name|generic_netmap_register
return|;
block|}
end_function

begin_comment
comment|/*  * generic_netmap_attach() makes it possible to use netmap on  * a device without native netmap support.  * This is less performant than native support but potentially  * faster than raw sockets or similar schemes.  *  * In this "emulated" mode, netmap rings do not necessarily  * have the same size as those in the NIC. We use a default  * value and possibly override it if the OS has ways to fetch the  * actual configuration.  */
end_comment

begin_function
name|int
name|generic_netmap_attach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|netmap_generic_adapter
modifier|*
name|gna
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|u_int
name|num_tx_desc
decl_stmt|,
name|num_rx_desc
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|ifp
operator|->
name|if_type
operator|==
name|IFT_LOOP
condition|)
block|{
name|D
argument_list|(
literal|"if_loop is not supported by %s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
endif|#
directive|endif
name|num_tx_desc
operator|=
name|num_rx_desc
operator|=
name|netmap_generic_ringsize
expr_stmt|;
comment|/* starting point */
name|nm_os_generic_find_num_desc
argument_list|(
name|ifp
argument_list|,
operator|&
name|num_tx_desc
argument_list|,
operator|&
name|num_rx_desc
argument_list|)
expr_stmt|;
comment|/* ignore errors */
name|ND
argument_list|(
literal|"Netmap ring size: TX = %d, RX = %d"
argument_list|,
name|num_tx_desc
argument_list|,
name|num_rx_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_tx_desc
operator|==
literal|0
operator|||
name|num_rx_desc
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"Device has no hw slots (tx %u, rx %u)"
argument_list|,
name|num_tx_desc
argument_list|,
name|num_rx_desc
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|gna
operator|=
name|nm_os_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|gna
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gna
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"no memory on attach, give up"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|na
operator|=
operator|(
expr|struct
name|netmap_adapter
operator|*
operator|)
name|gna
expr_stmt|;
name|strncpy
argument_list|(
name|na
operator|->
name|name
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|na
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|na
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|na
operator|->
name|num_tx_desc
operator|=
name|num_tx_desc
expr_stmt|;
name|na
operator|->
name|num_rx_desc
operator|=
name|num_rx_desc
expr_stmt|;
name|na
operator|->
name|nm_register
operator|=
operator|&
name|generic_netmap_register
expr_stmt|;
name|na
operator|->
name|nm_txsync
operator|=
operator|&
name|generic_netmap_txsync
expr_stmt|;
name|na
operator|->
name|nm_rxsync
operator|=
operator|&
name|generic_netmap_rxsync
expr_stmt|;
name|na
operator|->
name|nm_dtor
operator|=
operator|&
name|generic_netmap_dtor
expr_stmt|;
comment|/* when using generic, NAF_NETMAP_ON is set so we force 	 * NAF_SKIP_INTR to use the regular interrupt handler 	 */
name|na
operator|->
name|na_flags
operator|=
name|NAF_SKIP_INTR
operator||
name|NAF_HOST_RINGS
expr_stmt|;
name|ND
argument_list|(
literal|"[GNA] num_tx_queues(%d), real_num_tx_queues(%d), len(%lu)"
argument_list|,
name|ifp
operator|->
name|num_tx_queues
argument_list|,
name|ifp
operator|->
name|real_num_tx_queues
argument_list|,
name|ifp
operator|->
name|tx_queue_len
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"[GNA] num_rx_queues(%d), real_num_rx_queues(%d)"
argument_list|,
name|ifp
operator|->
name|num_rx_queues
argument_list|,
name|ifp
operator|->
name|real_num_rx_queues
argument_list|)
expr_stmt|;
name|nm_os_generic_find_num_queues
argument_list|(
name|ifp
argument_list|,
operator|&
name|na
operator|->
name|num_tx_rings
argument_list|,
operator|&
name|na
operator|->
name|num_rx_rings
argument_list|)
expr_stmt|;
name|retval
operator|=
name|netmap_attach_common
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
name|nm_os_free
argument_list|(
name|gna
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
name|gna
operator|->
name|prev
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* save old na */
if|if
condition|(
name|gna
operator|->
name|prev
operator|!=
name|NULL
condition|)
block|{
name|netmap_adapter_get
argument_list|(
name|gna
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
name|NM_ATTACH_NA
argument_list|(
name|ifp
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|nm_os_generic_set_features
argument_list|(
name|gna
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"Emulated adapter for %s created (prev was %p)"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|gna
operator|->
name|prev
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

end_unit

