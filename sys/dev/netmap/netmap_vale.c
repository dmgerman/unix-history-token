begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2013-2016 Universita` di Pisa  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This module implements the VALE switch for netmap  --- VALE SWITCH ---  NMG_LOCK() serializes all modifications to switches and ports. A switch cannot be deleted until all ports are gone.  For each switch, an SX lock (RWlock on linux) protects deletion of ports. When configuring or deleting a new port, the lock is acquired in exclusive mode (after holding NMG_LOCK). When forwarding, the lock is acquired in shared mode (without NMG_LOCK). The lock is held throughout the entire forwarding cycle, during which the thread may incur in a page fault. Hence it is important that sleepable shared locks are used.  On the rx ring, the per-port lock is grabbed initially to reserve a number of slot in the ring, then the lock is released, packets are copied from source to destination, and then the lock is acquired again and the receive ring is updated. (A similar thing is done on the tx ring for NIC and host stack ports attached to the switch)   */
end_comment

begin_comment
comment|/*  * OS-specific code that is used only within this file.  * Other OS-specific code that must be accessed by drivers  * is present in netmap_kern.h  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* defines used in kernel.h */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* types used in module initialization */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_comment
comment|/* cdevsw struct, UID, GID */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_comment
comment|/* struct socket */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/* BIOCIMMEDIATE */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* */
end_comment

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_define
define|#
directive|define
name|BDG_RWLOCK_T
value|struct rwlock
end_define

begin_comment
comment|// struct rwlock
end_comment

begin_define
define|#
directive|define
name|BDG_RWINIT
parameter_list|(
name|b
parameter_list|)
define|\
value|rw_init_flags(&(b)->bdg_lock, "bdg lock", RW_NOWITNESS)
end_define

begin_define
define|#
directive|define
name|BDG_WLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_wlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_WUNLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_wunlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_RLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_rlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_RTRYLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_try_rlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_RUNLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_runlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_RWDESTROY
parameter_list|(
name|b
parameter_list|)
value|rw_destroy(&(b)->bdg_lock)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|linux
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"bsd_glue.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_elif

begin_warning
warning|#
directive|warning
warning|OSX support is only partial
end_warning

begin_include
include|#
directive|include
file|"osx_glue.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"win_glue.h"
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|Unsupported platform
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unsupported */
end_comment

begin_comment
comment|/*  * common headers  */
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_mem2.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_VALE
end_ifdef

begin_comment
comment|/*  * system parameters (most of them in netmap_kern.h)  * NM_BDG_NAME	prefix for switch port names, default "vale"  * NM_BDG_MAXPORTS	number of ports  * NM_BRIDGES	max number of switches in the system.  *	XXX should become a sysctl or tunable  *  * Switch ports are named valeX:Y where X is the switch name and Y  * is the port. If Y matches a physical interface name, the port is  * connected to a physical device.  *  * Unlike physical interfaces, switch ports use their own memory region  * for rings and buffers.  * The virtual interfaces use per-queue lock instead of core lock.  * In the tx loop, we aggregate traffic in batches to make all operations  * faster. The batch size is bridge_batch.  */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_MAXRINGS
value|16
end_define

begin_comment
comment|/* XXX unclear how many. */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_MAXSLOTS
value|4096
end_define

begin_comment
comment|/* XXX same as above */
end_comment

begin_define
define|#
directive|define
name|NM_BRIDGE_RINGSIZE
value|1024
end_define

begin_comment
comment|/* in the device */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_HASH
value|1024
end_define

begin_comment
comment|/* forwarding table entries */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_BATCH
value|1024
end_define

begin_comment
comment|/* entries in the forwarding buffer */
end_comment

begin_define
define|#
directive|define
name|NM_MULTISEG
value|64
end_define

begin_comment
comment|/* max size of a chain of bufs */
end_comment

begin_comment
comment|/* actual size of the tables */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_BATCH_MAX
value|(NM_BDG_BATCH + NM_MULTISEG)
end_define

begin_comment
comment|/* NM_FT_NULL terminates a list of slots in the ft */
end_comment

begin_define
define|#
directive|define
name|NM_FT_NULL
value|NM_BDG_BATCH_MAX
end_define

begin_comment
comment|/*  * bridge_batch is set via sysctl to the max batch size to be  * used in the bridge. The actual value may be larger as the  * last packet in the block may overflow the size.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bridge_batch
init|=
name|NM_BDG_BATCH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bridge batch size */
end_comment

begin_expr_stmt
name|SYSBEGIN
argument_list|(
name|vars_vale
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_dev_netmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|bridge_batch
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bridge_batch
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSEND
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|netmap_vp_create
parameter_list|(
name|struct
name|nmreq
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|netmap_mem_d
modifier|*
name|nmd
parameter_list|,
name|struct
name|netmap_vp_adapter
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|netmap_vp_reg
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|netmap_bwrap_reg
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
parameter_list|,
name|int
name|onoff
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * For each output interface, nm_bdg_q is used to construct a list.  * bq_len is the number of output buffers (we can have coalescing  * during the copy).  */
end_comment

begin_struct
struct|struct
name|nm_bdg_q
block|{
name|uint16_t
name|bq_head
decl_stmt|;
name|uint16_t
name|bq_tail
decl_stmt|;
name|uint32_t
name|bq_len
decl_stmt|;
comment|/* number of buffers */
block|}
struct|;
end_struct

begin_comment
comment|/* XXX revise this */
end_comment

begin_struct
struct|struct
name|nm_hash_ent
block|{
name|uint64_t
name|mac
decl_stmt|;
comment|/* the top 2 bytes are the epoch */
name|uint64_t
name|ports
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * nm_bridge is a descriptor for a VALE switch.  * Interfaces for a bridge are all in bdg_ports[].  * The array has fixed size, an empty entry does not terminate  * the search, but lookups only occur on attach/detach so we  * don't mind if they are slow.  *  * The bridge is non blocking on the transmit ports: excess  * packets are dropped if there is no room on the output port.  *  * bdg_lock protects accesses to the bdg_ports array.  * This is a rw lock (or equivalent).  */
end_comment

begin_struct
struct|struct
name|nm_bridge
block|{
comment|/* XXX what is the proper alignment/layout ? */
name|BDG_RWLOCK_T
name|bdg_lock
decl_stmt|;
comment|/* protects bdg_ports */
name|int
name|bdg_namelen
decl_stmt|;
name|uint32_t
name|bdg_active_ports
decl_stmt|;
comment|/* 0 means free */
name|char
name|bdg_basename
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
comment|/* Indexes of active ports (up to active_ports) 	 * and all other remaining ports. 	 */
name|uint8_t
name|bdg_port_index
index|[
name|NM_BDG_MAXPORTS
index|]
decl_stmt|;
name|struct
name|netmap_vp_adapter
modifier|*
name|bdg_ports
index|[
name|NM_BDG_MAXPORTS
index|]
decl_stmt|;
comment|/* 	 * The function to decide the destination port. 	 * It returns either of an index of the destination port, 	 * NM_BDG_BROADCAST to broadcast this packet, or NM_BDG_NOPORT not to 	 * forward this packet.  ring_nr is the source ring index, and the 	 * function may overwrite this value to forward this packet to a 	 * different ring index. 	 * This function must be set by netmap_bdg_ctl(). 	 */
name|struct
name|netmap_bdg_ops
name|bdg_ops
decl_stmt|;
comment|/* the forwarding table, MAC+ports. 	 * XXX should be changed to an argument to be passed to 	 * the lookup function, and allocated on attach 	 */
name|struct
name|nm_hash_ent
name|ht
index|[
name|NM_BDG_HASH
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_NET_NS
name|struct
name|net
modifier|*
name|ns
decl_stmt|;
endif|#
directive|endif
comment|/* CONFIG_NET_NS */
block|}
struct|;
end_struct

begin_function
specifier|const
name|char
modifier|*
name|netmap_bdg_name
parameter_list|(
name|struct
name|netmap_vp_adapter
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|vp
operator|->
name|na_bdg
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|b
operator|->
name|bdg_basename
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CONFIG_NET_NS
end_ifndef

begin_comment
comment|/*  * XXX in principle nm_bridges could be created dynamically  * Right now we have a static array and deletions are protected  * by an exclusive lock.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|nm_bridge
modifier|*
name|nm_bridges
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !CONFIG_NET_NS */
end_comment

begin_comment
comment|/*  * this is a slightly optimized copy routine which rounds  * to multiple of 64 bytes and is often faster than dealing  * with other odd sizes. We assume there is enough room  * in the source and destination buffers.  *  * XXX only for multiples of 64 bytes, non overlapped.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pkt_copy
parameter_list|(
name|void
modifier|*
name|_src
parameter_list|,
name|void
modifier|*
name|_dst
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|uint64_t
modifier|*
name|src
init|=
name|_src
decl_stmt|;
name|uint64_t
modifier|*
name|dst
init|=
name|_dst
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|l
operator|>=
literal|1024
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
name|likely
argument_list|(
name|l
operator|>
literal|0
argument_list|)
condition|;
name|l
operator|-=
literal|64
control|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nm_is_id_char
parameter_list|(
specifier|const
name|char
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'_'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Validate the name of a VALE bridge port and return the  * position of the ":" character. */
end_comment

begin_function
specifier|static
name|int
name|nm_vale_name_validate
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|colon_pos
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
name|strlen
argument_list|(
name|name
argument_list|)
operator|<
name|strlen
argument_list|(
name|NM_BDG_NAME
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|name
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|colon_pos
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|colon_pos
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|nm_is_id_char
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|IFNAMSIZ
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|colon_pos
return|;
block|}
end_function

begin_comment
comment|/*  * locate a bridge among the existing ones.  * MUST BE CALLED WITH NMG_LOCK()  *  * a ':' in the name terminates the bridge name. Otherwise, just NM_NAME.  * We assume that this is called with a name of at least NM_NAME chars.  */
end_comment

begin_function
specifier|static
name|struct
name|nm_bridge
modifier|*
name|nm_find_bridge
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|namelen
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|NULL
decl_stmt|,
modifier|*
name|bridges
decl_stmt|;
name|u_int
name|num_bridges
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|netmap_bns_getbridges
argument_list|(
operator|&
name|bridges
argument_list|,
operator|&
name|num_bridges
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|nm_vale_name_validate
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|<
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"invalid bridge name %s"
argument_list|,
name|name
condition|?
name|name
else|:
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* lookup the name, remember empty slot if there is one */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_bridges
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nm_bridge
modifier|*
name|x
init|=
name|bridges
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|bdg_active_ports
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|create
operator|&&
name|b
operator|==
name|NULL
condition|)
name|b
operator|=
name|x
expr_stmt|;
comment|/* record empty slot */
block|}
elseif|else
if|if
condition|(
name|x
operator|->
name|bdg_namelen
operator|!=
name|namelen
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|x
operator|->
name|bdg_basename
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ND
argument_list|(
literal|"found '%.*s' at %d"
argument_list|,
name|namelen
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|b
operator|=
name|x
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|num_bridges
operator|&&
name|b
condition|)
block|{
comment|/* name not found, can create entry */
comment|/* initialize the bridge */
name|strncpy
argument_list|(
name|b
operator|->
name|bdg_basename
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"create new bridge %s with ports %d"
argument_list|,
name|b
operator|->
name|bdg_basename
argument_list|,
name|b
operator|->
name|bdg_active_ports
argument_list|)
expr_stmt|;
name|b
operator|->
name|bdg_namelen
operator|=
name|namelen
expr_stmt|;
name|b
operator|->
name|bdg_active_ports
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BDG_MAXPORTS
condition|;
name|i
operator|++
control|)
name|b
operator|->
name|bdg_port_index
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* set the default function */
name|b
operator|->
name|bdg_ops
operator|.
name|lookup
operator|=
name|netmap_bdg_learning
expr_stmt|;
comment|/* reset the MAC address table */
name|bzero
argument_list|(
name|b
operator|->
name|ht
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nm_hash_ent
argument_list|)
operator|*
name|NM_BDG_HASH
argument_list|)
expr_stmt|;
name|NM_BNS_GET
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Free the forwarding tables for rings attached to switch ports.  */
end_comment

begin_function
specifier|static
name|void
name|nm_free_bdgfwd
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|int
name|nrings
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|nrings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|kring
operator|=
name|na
operator|->
name|tx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrings
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
condition|)
block|{
name|nm_os_free
argument_list|(
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
argument_list|)
expr_stmt|;
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
operator|=
name|NULL
expr_stmt|;
comment|/* protect from freeing twice */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate the forwarding tables for the rings attached to the bridge ports.  */
end_comment

begin_function
specifier|static
name|int
name|nm_alloc_bdgfwd
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|int
name|nrings
decl_stmt|,
name|l
decl_stmt|,
name|i
decl_stmt|,
name|num_dstq
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* all port:rings + broadcast */
name|num_dstq
operator|=
name|NM_BDG_MAXPORTS
operator|*
name|NM_BDG_MAXRINGS
operator|+
literal|1
expr_stmt|;
name|l
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nm_bdg_fwd
argument_list|)
operator|*
name|NM_BDG_BATCH_MAX
expr_stmt|;
name|l
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|nm_bdg_q
argument_list|)
operator|*
name|num_dstq
expr_stmt|;
name|l
operator|+=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|NM_BDG_BATCH_MAX
expr_stmt|;
name|nrings
operator|=
name|netmap_real_rings
argument_list|(
name|na
argument_list|,
name|NR_TX
argument_list|)
expr_stmt|;
name|kring
operator|=
name|na
operator|->
name|tx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
decl_stmt|;
name|struct
name|nm_bdg_q
modifier|*
name|dstq
decl_stmt|;
name|int
name|j
decl_stmt|;
name|ft
operator|=
name|nm_os_malloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ft
condition|)
block|{
name|nm_free_bdgfwd
argument_list|(
name|na
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|dstq
operator|=
operator|(
expr|struct
name|nm_bdg_q
operator|*
operator|)
operator|(
name|ft
operator|+
name|NM_BDG_BATCH_MAX
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_dstq
condition|;
name|j
operator|++
control|)
block|{
name|dstq
index|[
name|j
index|]
operator|.
name|bq_head
operator|=
name|dstq
index|[
name|j
index|]
operator|.
name|bq_tail
operator|=
name|NM_FT_NULL
expr_stmt|;
name|dstq
index|[
name|j
index|]
operator|.
name|bq_len
operator|=
literal|0
expr_stmt|;
block|}
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
operator|=
name|ft
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* remove from bridge b the ports in slots hw and sw  * (sw can be -1 if not needed)  */
end_comment

begin_function
specifier|static
name|void
name|netmap_bdg_detach_common
parameter_list|(
name|struct
name|nm_bridge
modifier|*
name|b
parameter_list|,
name|int
name|hw
parameter_list|,
name|int
name|sw
parameter_list|)
block|{
name|int
name|s_hw
init|=
name|hw
decl_stmt|,
name|s_sw
init|=
name|sw
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lim
init|=
name|b
operator|->
name|bdg_active_ports
decl_stmt|;
name|uint8_t
name|tmp
index|[
name|NM_BDG_MAXPORTS
index|]
decl_stmt|;
comment|/* 	New algorithm: 	make a copy of bdg_port_index; 	lookup NA(ifp)->bdg_port and SWNA(ifp)->bdg_port 	in the array of bdg_port_index, replacing them with 	entries from the bottom of the array; 	decrement bdg_active_ports; 	acquire BDG_WLOCK() and copy back the array. 	 */
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"detach %d and %d (lim %d)"
argument_list|,
name|hw
argument_list|,
name|sw
argument_list|,
name|lim
argument_list|)
expr_stmt|;
comment|/* make a copy of the list of active ports, update it, 	 * and then copy back within BDG_WLOCK(). 	 */
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|b
operator|->
name|bdg_port_index
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|hw
operator|>=
literal|0
operator|||
name|sw
operator|>=
literal|0
operator|)
operator|&&
name|i
operator|<
name|lim
condition|;
control|)
block|{
if|if
condition|(
name|hw
operator|>=
literal|0
operator|&&
name|tmp
index|[
name|i
index|]
operator|==
name|hw
condition|)
block|{
name|ND
argument_list|(
literal|"detach hw %d at %d"
argument_list|,
name|hw
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lim
operator|--
expr_stmt|;
comment|/* point to last active port */
name|tmp
index|[
name|i
index|]
operator|=
name|tmp
index|[
name|lim
index|]
expr_stmt|;
comment|/* swap with i */
name|tmp
index|[
name|lim
index|]
operator|=
name|hw
expr_stmt|;
comment|/* now this is inactive */
name|hw
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sw
operator|>=
literal|0
operator|&&
name|tmp
index|[
name|i
index|]
operator|==
name|sw
condition|)
block|{
name|ND
argument_list|(
literal|"detach sw %d at %d"
argument_list|,
name|sw
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lim
operator|--
expr_stmt|;
name|tmp
index|[
name|i
index|]
operator|=
name|tmp
index|[
name|lim
index|]
expr_stmt|;
name|tmp
index|[
name|lim
index|]
operator|=
name|sw
expr_stmt|;
name|sw
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hw
operator|>=
literal|0
operator|||
name|sw
operator|>=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"XXX delete failed hw %d sw %d, should panic..."
argument_list|,
name|hw
argument_list|,
name|sw
argument_list|)
expr_stmt|;
block|}
name|BDG_WLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|bdg_ops
operator|.
name|dtor
condition|)
name|b
operator|->
name|bdg_ops
operator|.
name|dtor
argument_list|(
name|b
operator|->
name|bdg_ports
index|[
name|s_hw
index|]
argument_list|)
expr_stmt|;
name|b
operator|->
name|bdg_ports
index|[
name|s_hw
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s_sw
operator|>=
literal|0
condition|)
block|{
name|b
operator|->
name|bdg_ports
index|[
name|s_sw
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|b
operator|->
name|bdg_port_index
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|bdg_active_ports
operator|=
name|lim
expr_stmt|;
name|BDG_WUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"now %d active ports"
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|lim
operator|==
literal|0
condition|)
block|{
name|ND
argument_list|(
literal|"marking bridge %s as free"
argument_list|,
name|b
operator|->
name|bdg_basename
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|b
operator|->
name|bdg_ops
argument_list|,
sizeof|sizeof
argument_list|(
name|b
operator|->
name|bdg_ops
argument_list|)
argument_list|)
expr_stmt|;
name|NM_BNS_PUT
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* nm_bdg_ctl callback for VALE ports */
end_comment

begin_function
specifier|static
name|int
name|netmap_vp_bdg_ctl
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|int
name|attach
parameter_list|)
block|{
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
init|=
operator|(
expr|struct
name|netmap_vp_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|vpna
operator|->
name|na_bdg
decl_stmt|;
operator|(
name|void
operator|)
name|nmr
expr_stmt|;
comment|// XXX merge ?
if|if
condition|(
name|attach
condition|)
return|return
literal|0
return|;
comment|/* nothing to do */
if|if
condition|(
name|b
condition|)
block|{
name|netmap_set_all_rings
argument_list|(
name|na
argument_list|,
literal|0
comment|/* disable */
argument_list|)
expr_stmt|;
name|netmap_bdg_detach_common
argument_list|(
name|b
argument_list|,
name|vpna
operator|->
name|bdg_port
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vpna
operator|->
name|na_bdg
operator|=
name|NULL
expr_stmt|;
name|netmap_set_all_rings
argument_list|(
name|na
argument_list|,
literal|1
comment|/* enable */
argument_list|)
expr_stmt|;
block|}
comment|/* I have took reference just for attach */
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* nm_dtor callback for ephemeral VALE ports */
end_comment

begin_function
specifier|static
name|void
name|netmap_vp_dtor
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
init|=
operator|(
expr|struct
name|netmap_vp_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|vpna
operator|->
name|na_bdg
decl_stmt|;
name|ND
argument_list|(
literal|"%s has %d references"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|na
operator|->
name|na_refcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
condition|)
block|{
name|netmap_bdg_detach_common
argument_list|(
name|b
argument_list|,
name|vpna
operator|->
name|bdg_port
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vpna
operator|->
name|autodelete
operator|&&
name|na
operator|->
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ND
argument_list|(
literal|"releasing %s"
argument_list|,
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
name|nm_os_vi_detach
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* remove a persistent VALE port from the system */
end_comment

begin_function
specifier|static
name|int
name|nm_vi_destroy
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ifp
operator|=
name|ifunit_ref
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifp
condition|)
return|return
name|ENXIO
return|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
comment|/* make sure this is actually a VALE port */
if|if
condition|(
operator|!
name|NM_NA_VALID
argument_list|(
name|ifp
argument_list|)
operator|||
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|nm_register
operator|!=
name|netmap_vp_reg
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|vpna
operator|=
operator|(
expr|struct
name|netmap_vp_adapter
operator|*
operator|)
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* we can only destroy ports that were created via NETMAP_BDG_NEWIF */
if|if
condition|(
name|vpna
operator|->
name|autodelete
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* also make sure that nobody is using the inferface */
if|if
condition|(
name|NETMAP_OWNED_BY_ANY
argument_list|(
operator|&
name|vpna
operator|->
name|up
argument_list|)
operator|||
name|vpna
operator|->
name|up
operator|.
name|na_refcount
operator|>
literal|1
comment|/* any ref besides the one in nm_vi_create()? */
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
name|D
argument_list|(
literal|"destroying a persistent vale interface %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* Linux requires all the references are released 	 * before unregister 	 */
name|netmap_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|nm_os_vi_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nm_update_info
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
return|return
name|netmap_mem_get_info
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
operator|&
name|nmr
operator|->
name|nr_memsize
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmr
operator|->
name|nr_arg2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a virtual interface registered to the system.  * The interface will be attached to a bridge later.  */
end_comment

begin_function
name|int
name|netmap_vi_create
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|int
name|autodelete
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
decl_stmt|;
name|struct
name|netmap_mem_d
modifier|*
name|nmd
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* don't include VALE prefix */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
name|NM_BDG_NAME
argument_list|,
name|strlen
argument_list|(
name|NM_BDG_NAME
argument_list|)
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|ifp
operator|=
name|ifunit_ref
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
condition|)
block|{
comment|/* already exist, cannot create new one */
name|error
operator|=
name|EEXIST
expr_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|NM_NA_VALID
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|int
name|update_err
init|=
name|nm_update_info
argument_list|(
name|nmr
argument_list|,
name|NA
argument_list|(
name|ifp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|update_err
condition|)
name|error
operator|=
name|update_err
expr_stmt|;
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|nm_os_vi_persist
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_arg2
condition|)
block|{
name|nmd
operator|=
name|netmap_mem_find
argument_list|(
name|nmr
operator|->
name|nr_arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmd
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err_1
goto|;
block|}
block|}
comment|/* netmap_vp_create creates a struct netmap_vp_adapter */
name|error
operator|=
name|netmap_vp_create
argument_list|(
name|nmr
argument_list|,
name|ifp
argument_list|,
name|nmd
argument_list|,
operator|&
name|vpna
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_1
goto|;
block|}
comment|/* persist-specific routines */
name|vpna
operator|->
name|up
operator|.
name|nm_bdg_ctl
operator|=
name|netmap_vp_bdg_ctl
expr_stmt|;
if|if
condition|(
operator|!
name|autodelete
condition|)
block|{
name|netmap_adapter_get
argument_list|(
operator|&
name|vpna
operator|->
name|up
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vpna
operator|->
name|autodelete
operator|=
literal|1
expr_stmt|;
block|}
name|NM_ATTACH_NA
argument_list|(
name|ifp
argument_list|,
operator|&
name|vpna
operator|->
name|up
argument_list|)
expr_stmt|;
comment|/* return the updated info */
name|error
operator|=
name|nm_update_info
argument_list|(
name|nmr
argument_list|,
operator|&
name|vpna
operator|->
name|up
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|err_2
goto|;
block|}
name|D
argument_list|(
literal|"returning nr_arg2 %d"
argument_list|,
name|nmr
operator|->
name|nr_arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmd
condition|)
name|netmap_mem_put
argument_list|(
name|nmd
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
name|D
argument_list|(
literal|"created %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_2
label|:
name|netmap_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|err_1
label|:
if|if
condition|(
name|nmd
condition|)
name|netmap_mem_put
argument_list|(
name|nmd
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
name|nm_os_vi_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Try to get a reference to a netmap adapter attached to a VALE switch.  * If the adapter is found (or is created), this function returns 0, a  * non NULL pointer is returned into *na, and the caller holds a  * reference to the adapter.  * If an adapter is not found, then no reference is grabbed and the  * function returns an error code, or 0 if there is just a VALE prefix  * mismatch. Therefore the caller holds a reference when  * (*na != NULL&& return == 0).  */
end_comment

begin_function
name|int
name|netmap_get_bdg_na
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
modifier|*
name|na
parameter_list|,
name|struct
name|netmap_mem_d
modifier|*
name|nmd
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|char
modifier|*
name|nr_name
init|=
name|nmr
operator|->
name|nr_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|ifname
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
decl_stmt|,
modifier|*
name|hostna
init|=
name|NULL
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cand
init|=
operator|-
literal|1
decl_stmt|,
name|cand2
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|needed
decl_stmt|;
operator|*
name|na
operator|=
name|NULL
expr_stmt|;
comment|/* default return value */
comment|/* first try to see if this is a bridge port. */
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|nr_name
argument_list|,
name|NM_BDG_NAME
argument_list|,
sizeof|sizeof
argument_list|(
name|NM_BDG_NAME
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
comment|/* no error, but no VALE prefix */
block|}
name|b
operator|=
name|nm_find_bridge
argument_list|(
name|nr_name
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"no bridges available for '%s'"
argument_list|,
name|nr_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|create
condition|?
name|ENOMEM
else|:
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|nr_name
argument_list|)
operator|<
name|b
operator|->
name|bdg_namelen
condition|)
comment|/* impossible */
name|panic
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
comment|/* Now we are sure that name starts with the bridge's name, 	 * lookup the port in the bridge. We need to scan the entire 	 * list. It is not important to hold a WLOCK on the bridge 	 * during the search because NMG_LOCK already guarantees 	 * that there are no other possible writers. 	 */
comment|/* lookup in the local list of ports */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|bdg_active_ports
condition|;
name|j
operator|++
control|)
block|{
name|i
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|j
index|]
expr_stmt|;
name|vpna
operator|=
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
expr_stmt|;
comment|// KASSERT(na != NULL);
name|ND
argument_list|(
literal|"checking %s"
argument_list|,
name|vpna
operator|->
name|up
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|vpna
operator|->
name|up
operator|.
name|name
argument_list|,
name|nr_name
argument_list|)
condition|)
block|{
name|netmap_adapter_get
argument_list|(
operator|&
name|vpna
operator|->
name|up
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"found existing if %s refs %d"
argument_list|,
name|nr_name
argument_list|)
operator|*
name|na
operator|=
operator|&
name|vpna
operator|->
name|up
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* not found, should we create it? */
if|if
condition|(
operator|!
name|create
condition|)
return|return
name|ENXIO
return|;
comment|/* yes we should, see if we have space to attach entries */
name|needed
operator|=
literal|2
expr_stmt|;
comment|/* in some cases we only need 1 */
if|if
condition|(
name|b
operator|->
name|bdg_active_ports
operator|+
name|needed
operator|>=
name|NM_BDG_MAXPORTS
condition|)
block|{
name|D
argument_list|(
literal|"bridge full %d, cannot create new port"
argument_list|,
name|b
operator|->
name|bdg_active_ports
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* record the next two ports available, but do not allocate yet */
name|cand
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|b
operator|->
name|bdg_active_ports
index|]
expr_stmt|;
name|cand2
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|b
operator|->
name|bdg_active_ports
operator|+
literal|1
index|]
expr_stmt|;
name|ND
argument_list|(
literal|"+++ bridge %s port %s used %d avail %d %d"
argument_list|,
name|b
operator|->
name|bdg_basename
argument_list|,
name|ifname
argument_list|,
name|b
operator|->
name|bdg_active_ports
argument_list|,
name|cand
argument_list|,
name|cand2
argument_list|)
expr_stmt|;
comment|/* 	 * try see if there is a matching NIC with this name 	 * (after the bridge's name) 	 */
name|ifname
operator|=
name|nr_name
operator|+
name|b
operator|->
name|bdg_namelen
operator|+
literal|1
expr_stmt|;
name|ifp
operator|=
name|ifunit_ref
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifp
condition|)
block|{
comment|/* Create an ephemeral virtual port 		 * This block contains all the ephemeral-specific logics 		 */
if|if
condition|(
name|nmr
operator|->
name|nr_cmd
condition|)
block|{
comment|/* nr_cmd must be 0 for a virtual port */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* bdg_netmap_attach creates a struct netmap_adapter */
name|error
operator|=
name|netmap_vp_create
argument_list|(
name|nmr
argument_list|,
name|NULL
argument_list|,
name|nmd
argument_list|,
operator|&
name|vpna
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* shortcut - we can skip get_hw_na(), 		 * ownership check and nm_bdg_attach() 		 */
block|}
else|else
block|{
name|struct
name|netmap_adapter
modifier|*
name|hw
decl_stmt|;
name|error
operator|=
name|netmap_get_hw_na
argument_list|(
name|ifp
argument_list|,
name|nmd
argument_list|,
operator|&
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|hw
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* host adapter might not be created */
name|error
operator|=
name|hw
operator|->
name|nm_bdg_attach
argument_list|(
name|nr_name
argument_list|,
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|vpna
operator|=
name|hw
operator|->
name|na_vp
expr_stmt|;
name|hostna
operator|=
name|hw
operator|->
name|na_hostvp
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_arg1
operator|!=
name|NETMAP_BDG_HOST
condition|)
name|hostna
operator|=
name|NULL
expr_stmt|;
block|}
name|BDG_WLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|vpna
operator|->
name|bdg_port
operator|=
name|cand
expr_stmt|;
name|ND
argument_list|(
literal|"NIC  %p to bridge port %d"
argument_list|,
name|vpna
argument_list|,
name|cand
argument_list|)
expr_stmt|;
comment|/* bind the port to the bridge (virtual ports are not active) */
name|b
operator|->
name|bdg_ports
index|[
name|cand
index|]
operator|=
name|vpna
expr_stmt|;
name|vpna
operator|->
name|na_bdg
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|bdg_active_ports
operator|++
expr_stmt|;
if|if
condition|(
name|hostna
operator|!=
name|NULL
condition|)
block|{
comment|/* also bind the host stack to the bridge */
name|b
operator|->
name|bdg_ports
index|[
name|cand2
index|]
operator|=
name|hostna
expr_stmt|;
name|hostna
operator|->
name|bdg_port
operator|=
name|cand2
expr_stmt|;
name|hostna
operator|->
name|na_bdg
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|bdg_active_ports
operator|++
expr_stmt|;
name|ND
argument_list|(
literal|"host %p to bridge port %d"
argument_list|,
name|hostna
argument_list|,
name|cand2
argument_list|)
expr_stmt|;
block|}
name|ND
argument_list|(
literal|"if %s refs %d"
argument_list|,
name|ifname
argument_list|,
name|vpna
operator|->
name|up
operator|.
name|na_refcount
argument_list|)
expr_stmt|;
name|BDG_WUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
operator|*
name|na
operator|=
operator|&
name|vpna
operator|->
name|up
expr_stmt|;
name|netmap_adapter_get
argument_list|(
operator|*
name|na
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ifp
condition|)
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Process NETMAP_BDG_ATTACH */
end_comment

begin_function
specifier|static
name|int
name|nm_bdg_ctl_attach
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|netmap_mem_d
modifier|*
name|nmd
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_arg2
condition|)
block|{
name|nmd
operator|=
name|netmap_mem_find
argument_list|(
name|nmr
operator|->
name|nr_arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmd
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|unlock_exit
goto|;
block|}
block|}
name|error
operator|=
name|netmap_get_bdg_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
name|nmd
argument_list|,
literal|1
comment|/* create if not exists */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
comment|/* no device */
goto|goto
name|unlock_exit
goto|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
block|{
comment|/* VALE prefix missing */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|unlock_exit
goto|;
block|}
if|if
condition|(
name|NETMAP_OWNED_BY_ANY
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|unref_exit
goto|;
block|}
if|if
condition|(
name|na
operator|->
name|nm_bdg_ctl
condition|)
block|{
comment|/* nop for VALE ports. The bwrap needs to put the hwna 		 * in netmap mode (see netmap_bwrap_bdg_ctl) 		 */
name|error
operator|=
name|na
operator|->
name|nm_bdg_ctl
argument_list|(
name|na
argument_list|,
name|nmr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|unref_exit
goto|;
name|ND
argument_list|(
literal|"registered %s to netmap-mode"
argument_list|,
name|na
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
name|unref_exit
label|:
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|unlock_exit
label|:
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|nm_is_bwrap
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
return|return
name|na
operator|->
name|nm_register
operator|==
name|netmap_bwrap_reg
return|;
block|}
end_function

begin_comment
comment|/* process NETMAP_BDG_DETACH */
end_comment

begin_function
specifier|static
name|int
name|nm_bdg_ctl_detach
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|int
name|error
decl_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_get_bdg_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
name|NULL
argument_list|,
literal|0
comment|/* don't create */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* no device, or another bridge or user owns the device */
goto|goto
name|unlock_exit
goto|;
block|}
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
block|{
comment|/* VALE prefix missing */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|unlock_exit
goto|;
block|}
elseif|else
if|if
condition|(
name|nm_is_bwrap
argument_list|(
name|na
argument_list|)
operator|&&
operator|(
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
operator|)
operator|->
name|na_polling_state
condition|)
block|{
comment|/* Don't detach a NIC with polling */
name|error
operator|=
name|EBUSY
expr_stmt|;
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
goto|goto
name|unlock_exit
goto|;
block|}
if|if
condition|(
name|na
operator|->
name|nm_bdg_ctl
condition|)
block|{
comment|/* remove the port from bridge. The bwrap 		 * also needs to put the hwna in normal mode 		 */
name|error
operator|=
name|na
operator|->
name|nm_bdg_ctl
argument_list|(
name|na
argument_list|,
name|nmr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|unlock_exit
label|:
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_struct_decl
struct_decl|struct
name|nm_bdg_polling_state
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|nm_bdg_kthread
block|{
name|struct
name|nm_kctx
modifier|*
name|nmk
decl_stmt|;
name|u_int
name|qfirst
decl_stmt|;
name|u_int
name|qlast
decl_stmt|;
name|struct
name|nm_bdg_polling_state
modifier|*
name|bps
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nm_bdg_polling_state
block|{
name|bool
name|configured
decl_stmt|;
name|bool
name|stopped
decl_stmt|;
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
decl_stmt|;
name|u_int
name|reg
decl_stmt|;
name|u_int
name|qfirst
decl_stmt|;
name|u_int
name|qlast
decl_stmt|;
name|u_int
name|cpu_from
decl_stmt|;
name|u_int
name|ncpus
decl_stmt|;
name|struct
name|nm_bdg_kthread
modifier|*
name|kthreads
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|netmap_bwrap_polling
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|is_kthread
parameter_list|)
block|{
name|struct
name|nm_bdg_kthread
modifier|*
name|nbk
init|=
name|data
decl_stmt|;
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
decl_stmt|;
name|u_int
name|qfirst
decl_stmt|,
name|qlast
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring0
decl_stmt|,
modifier|*
name|kring
decl_stmt|;
if|if
condition|(
operator|!
name|nbk
condition|)
return|return;
name|qfirst
operator|=
name|nbk
operator|->
name|qfirst
expr_stmt|;
name|qlast
operator|=
name|nbk
operator|->
name|qlast
expr_stmt|;
name|bna
operator|=
name|nbk
operator|->
name|bps
operator|->
name|bna
expr_stmt|;
name|kring0
operator|=
name|NMR
argument_list|(
name|bna
operator|->
name|hwna
argument_list|,
name|NR_RX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|qfirst
init|;
name|i
operator|<
name|qlast
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
name|kring0
operator|+
name|i
expr_stmt|;
name|kring
operator|->
name|nm_notify
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nm_bdg_create_kthreads
parameter_list|(
name|struct
name|nm_bdg_polling_state
modifier|*
name|bps
parameter_list|)
block|{
name|struct
name|nm_kctx_cfg
name|kcfg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bps
operator|->
name|kthreads
operator|=
name|nm_os_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nm_bdg_kthread
argument_list|)
operator|*
name|bps
operator|->
name|ncpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|bps
operator|->
name|kthreads
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|bzero
argument_list|(
operator|&
name|kcfg
argument_list|,
sizeof|sizeof
argument_list|(
name|kcfg
argument_list|)
argument_list|)
expr_stmt|;
name|kcfg
operator|.
name|worker_fn
operator|=
name|netmap_bwrap_polling
expr_stmt|;
name|kcfg
operator|.
name|use_kthread
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bps
operator|->
name|ncpus
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nm_bdg_kthread
modifier|*
name|t
init|=
name|bps
operator|->
name|kthreads
operator|+
name|i
decl_stmt|;
name|int
name|all
init|=
operator|(
name|bps
operator|->
name|ncpus
operator|==
literal|1
operator|&&
name|bps
operator|->
name|reg
operator|==
name|NR_REG_ALL_NIC
operator|)
decl_stmt|;
name|int
name|affinity
init|=
name|bps
operator|->
name|cpu_from
operator|+
name|i
decl_stmt|;
name|t
operator|->
name|bps
operator|=
name|bps
expr_stmt|;
name|t
operator|->
name|qfirst
operator|=
name|all
condition|?
name|bps
operator|->
name|qfirst
comment|/* must be 0 */
else|:
name|affinity
expr_stmt|;
name|t
operator|->
name|qlast
operator|=
name|all
condition|?
name|bps
operator|->
name|qlast
else|:
name|t
operator|->
name|qfirst
operator|+
literal|1
expr_stmt|;
name|D
argument_list|(
literal|"kthread %d a:%u qf:%u ql:%u"
argument_list|,
name|i
argument_list|,
name|affinity
argument_list|,
name|t
operator|->
name|qfirst
argument_list|,
name|t
operator|->
name|qlast
argument_list|)
expr_stmt|;
name|kcfg
operator|.
name|type
operator|=
name|i
expr_stmt|;
name|kcfg
operator|.
name|worker_private
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|nmk
operator|=
name|nm_os_kctx_create
argument_list|(
operator|&
name|kcfg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|nmk
operator|==
name|NULL
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|nm_os_kctx_worker_setaff
argument_list|(
name|t
operator|->
name|nmk
argument_list|,
name|affinity
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|cleanup
label|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|nm_bdg_kthread
modifier|*
name|t
init|=
name|bps
operator|->
name|kthreads
operator|+
name|i
decl_stmt|;
name|nm_os_kctx_destroy
argument_list|(
name|t
operator|->
name|nmk
argument_list|)
expr_stmt|;
block|}
name|nm_os_free
argument_list|(
name|bps
operator|->
name|kthreads
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
end_function

begin_comment
comment|/* A variant of ptnetmap_start_kthreads() */
end_comment

begin_function
specifier|static
name|int
name|nm_bdg_polling_start_kthreads
parameter_list|(
name|struct
name|nm_bdg_polling_state
modifier|*
name|bps
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|bps
condition|)
block|{
name|D
argument_list|(
literal|"polling is not configured"
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
name|bps
operator|->
name|stopped
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bps
operator|->
name|ncpus
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nm_bdg_kthread
modifier|*
name|t
init|=
name|bps
operator|->
name|kthreads
operator|+
name|i
decl_stmt|;
name|error
operator|=
name|nm_os_kctx_worker_start
argument_list|(
name|t
operator|->
name|nmk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"error in nm_kthread_start()"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
return|return
literal|0
return|;
name|cleanup
label|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|nm_bdg_kthread
modifier|*
name|t
init|=
name|bps
operator|->
name|kthreads
operator|+
name|i
decl_stmt|;
name|nm_os_kctx_worker_stop
argument_list|(
name|t
operator|->
name|nmk
argument_list|)
expr_stmt|;
block|}
name|bps
operator|->
name|stopped
operator|=
name|true
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nm_bdg_polling_stop_delete_kthreads
parameter_list|(
name|struct
name|nm_bdg_polling_state
modifier|*
name|bps
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|bps
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bps
operator|->
name|ncpus
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nm_bdg_kthread
modifier|*
name|t
init|=
name|bps
operator|->
name|kthreads
operator|+
name|i
decl_stmt|;
name|nm_os_kctx_worker_stop
argument_list|(
name|t
operator|->
name|nmk
argument_list|)
expr_stmt|;
name|nm_os_kctx_destroy
argument_list|(
name|t
operator|->
name|nmk
argument_list|)
expr_stmt|;
block|}
name|bps
operator|->
name|stopped
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_polling_cfg
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|struct
name|nm_bdg_polling_state
modifier|*
name|bps
parameter_list|)
block|{
name|int
name|req_cpus
decl_stmt|,
name|avail_cpus
decl_stmt|,
name|core_from
decl_stmt|;
name|u_int
name|reg
decl_stmt|,
name|i
decl_stmt|,
name|qfirst
decl_stmt|,
name|qlast
decl_stmt|;
name|avail_cpus
operator|=
name|nm_os_ncpus
argument_list|()
expr_stmt|;
name|req_cpus
operator|=
name|nmr
operator|->
name|nr_arg1
expr_stmt|;
if|if
condition|(
name|req_cpus
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"req_cpus must be> 0"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
elseif|else
if|if
condition|(
name|req_cpus
operator|>=
name|avail_cpus
condition|)
block|{
name|D
argument_list|(
literal|"for safety, we need at least one core left in the system"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|reg
operator|=
name|nmr
operator|->
name|nr_flags
operator|&
name|NR_REG_MASK
expr_stmt|;
name|i
operator|=
name|nmr
operator|->
name|nr_ringid
operator|&
name|NETMAP_RING_MASK
expr_stmt|;
comment|/* 	 * ONE_NIC: dedicate one core to one ring. If multiple cores 	 *          are specified, consecutive rings are also polled. 	 *          For example, if ringid=2 and 2 cores are given, 	 *          ring 2 and 3 are polled by core 2 and 3, respectively. 	 * ALL_NIC: poll all the rings using a core specified by ringid. 	 *          the number of cores must be 1. 	 */
if|if
condition|(
name|reg
operator|==
name|NR_REG_ONE_NIC
condition|)
block|{
if|if
condition|(
name|i
operator|+
name|req_cpus
operator|>
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|NR_RX
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"only %d rings exist (ring %u-%u is given)"
argument_list|,
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|NR_RX
argument_list|)
argument_list|,
name|i
argument_list|,
name|i
operator|+
name|req_cpus
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|qfirst
operator|=
name|i
expr_stmt|;
name|qlast
operator|=
name|qfirst
operator|+
name|req_cpus
expr_stmt|;
name|core_from
operator|=
name|qfirst
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|==
name|NR_REG_ALL_NIC
condition|)
block|{
if|if
condition|(
name|req_cpus
operator|!=
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"ncpus must be 1 not %d for REG_ALL_NIC"
argument_list|,
name|req_cpus
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|qfirst
operator|=
literal|0
expr_stmt|;
name|qlast
operator|=
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|NR_RX
argument_list|)
expr_stmt|;
name|core_from
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|D
argument_list|(
literal|"reg must be ALL_NIC or ONE_NIC"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|bps
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
name|bps
operator|->
name|qfirst
operator|=
name|qfirst
expr_stmt|;
name|bps
operator|->
name|qlast
operator|=
name|qlast
expr_stmt|;
name|bps
operator|->
name|cpu_from
operator|=
name|core_from
expr_stmt|;
name|bps
operator|->
name|ncpus
operator|=
name|req_cpus
expr_stmt|;
name|D
argument_list|(
literal|"%s qfirst %u qlast %u cpu_from %u ncpus %u"
argument_list|,
name|reg
operator|==
name|NR_REG_ALL_NIC
condition|?
literal|"REG_ALL_NIC"
else|:
literal|"REG_ONE_NIC"
argument_list|,
name|qfirst
argument_list|,
name|qlast
argument_list|,
name|core_from
argument_list|,
name|req_cpus
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nm_bdg_ctl_polling_start
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|nm_bdg_polling_state
modifier|*
name|bps
decl_stmt|;
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bna
operator|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
expr_stmt|;
if|if
condition|(
name|bna
operator|->
name|na_polling_state
condition|)
block|{
name|D
argument_list|(
literal|"ERROR adapter already in polling mode"
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
name|bps
operator|=
name|nm_os_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bps
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bps
condition|)
return|return
name|ENOMEM
return|;
name|bps
operator|->
name|configured
operator|=
name|false
expr_stmt|;
name|bps
operator|->
name|stopped
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|get_polling_cfg
argument_list|(
name|nmr
argument_list|,
name|na
argument_list|,
name|bps
argument_list|)
condition|)
block|{
name|nm_os_free
argument_list|(
name|bps
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|nm_bdg_create_kthreads
argument_list|(
name|bps
argument_list|)
condition|)
block|{
name|nm_os_free
argument_list|(
name|bps
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
name|bps
operator|->
name|configured
operator|=
name|true
expr_stmt|;
name|bna
operator|->
name|na_polling_state
operator|=
name|bps
expr_stmt|;
name|bps
operator|->
name|bna
operator|=
name|bna
expr_stmt|;
comment|/* disable interrupt if possible */
if|if
condition|(
name|bna
operator|->
name|hwna
operator|->
name|nm_intr
condition|)
name|bna
operator|->
name|hwna
operator|->
name|nm_intr
argument_list|(
name|bna
operator|->
name|hwna
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* start kthread now */
name|error
operator|=
name|nm_bdg_polling_start_kthreads
argument_list|(
name|bps
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"ERROR nm_bdg_polling_start_kthread()"
argument_list|)
expr_stmt|;
name|nm_os_free
argument_list|(
name|bps
operator|->
name|kthreads
argument_list|)
expr_stmt|;
name|nm_os_free
argument_list|(
name|bps
argument_list|)
expr_stmt|;
name|bna
operator|->
name|na_polling_state
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bna
operator|->
name|hwna
operator|->
name|nm_intr
condition|)
name|bna
operator|->
name|hwna
operator|->
name|nm_intr
argument_list|(
name|bna
operator|->
name|hwna
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nm_bdg_ctl_polling_stop
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|nm_bdg_polling_state
modifier|*
name|bps
decl_stmt|;
if|if
condition|(
operator|!
name|bna
operator|->
name|na_polling_state
condition|)
block|{
name|D
argument_list|(
literal|"ERROR adapter is not in polling mode"
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
name|bps
operator|=
name|bna
operator|->
name|na_polling_state
expr_stmt|;
name|nm_bdg_polling_stop_delete_kthreads
argument_list|(
name|bna
operator|->
name|na_polling_state
argument_list|)
expr_stmt|;
name|bps
operator|->
name|configured
operator|=
name|false
expr_stmt|;
name|nm_os_free
argument_list|(
name|bps
argument_list|)
expr_stmt|;
name|bna
operator|->
name|na_polling_state
operator|=
name|NULL
expr_stmt|;
comment|/* reenable interrupt */
if|if
condition|(
name|bna
operator|->
name|hwna
operator|->
name|nm_intr
condition|)
name|bna
operator|->
name|hwna
operator|->
name|nm_intr
argument_list|(
name|bna
operator|->
name|hwna
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called by either user's context (netmap_ioctl())  * or external kernel modules (e.g., Openvswitch).  * Operation is indicated in nmr->nr_cmd.  * NETMAP_BDG_OPS that sets configure/lookup/dtor functions to the bridge  * requires bdg_ops argument; the other commands ignore this argument.  *  * Called without NMG_LOCK.  */
end_comment

begin_function
name|int
name|netmap_bdg_ctl
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|netmap_bdg_ops
modifier|*
name|bdg_ops
parameter_list|)
block|{
name|struct
name|nm_bridge
modifier|*
name|b
decl_stmt|,
modifier|*
name|bridges
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|nmr
operator|->
name|nr_name
decl_stmt|;
name|int
name|cmd
init|=
name|nmr
operator|->
name|nr_cmd
decl_stmt|,
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int
name|num_bridges
decl_stmt|;
name|netmap_bns_getbridges
argument_list|(
operator|&
name|bridges
argument_list|,
operator|&
name|num_bridges
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NETMAP_BDG_NEWIF
case|:
name|error
operator|=
name|netmap_vi_create
argument_list|(
name|nmr
argument_list|,
literal|0
comment|/* no autodelete */
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_BDG_DELIF
case|:
name|error
operator|=
name|nm_vi_destroy
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_BDG_ATTACH
case|:
name|error
operator|=
name|nm_bdg_ctl_attach
argument_list|(
name|nmr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_BDG_DETACH
case|:
name|error
operator|=
name|nm_bdg_ctl_detach
argument_list|(
name|nmr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_BDG_LIST
case|:
comment|/* this is used to enumerate bridges and ports */
if|if
condition|(
name|namelen
condition|)
block|{
comment|/* look up indexes of bridge and port */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|NM_BDG_NAME
argument_list|,
name|strlen
argument_list|(
name|NM_BDG_NAME
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|b
operator|=
name|nm_find_bridge
argument_list|(
name|name
argument_list|,
literal|0
comment|/* don't create */
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|nmr
operator|->
name|nr_arg1
operator|=
name|b
operator|-
name|bridges
expr_stmt|;
comment|/* bridge index */
name|nmr
operator|->
name|nr_arg2
operator|=
name|NM_BDG_NOPORT
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|bdg_active_ports
condition|;
name|j
operator|++
control|)
block|{
name|i
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|j
index|]
expr_stmt|;
name|vpna
operator|=
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vpna
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"---AAAAAAAAARGH-------"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* the former and the latter identify a 				 * virtual port and a NIC, respectively 				 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|vpna
operator|->
name|up
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|nmr
operator|->
name|nr_arg2
operator|=
name|i
expr_stmt|;
comment|/* port index */
break|break;
block|}
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* return the first non-empty entry starting from 			 * bridge nr_arg1 and port nr_arg2. 			 * 			 * Users can detect the end of the same bridge by 			 * seeing the new and old value of nr_arg1, and can 			 * detect the end of all the bridge by error != 0 			 */
name|i
operator|=
name|nmr
operator|->
name|nr_arg1
expr_stmt|;
name|j
operator|=
name|nmr
operator|->
name|nr_arg2
expr_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|error
operator|=
name|ENOENT
init|;
name|i
operator|<
name|NM_BRIDGES
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|bridges
operator|+
name|i
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|NM_BDG_MAXPORTS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|b
operator|->
name|bdg_ports
index|[
name|j
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|vpna
operator|=
name|b
operator|->
name|bdg_ports
index|[
name|j
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|vpna
operator|->
name|up
operator|.
name|name
argument_list|,
operator|(
name|size_t
operator|)
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|j
operator|=
literal|0
expr_stmt|;
comment|/* following bridges scan from 0 */
block|}
name|out
label|:
name|nmr
operator|->
name|nr_arg1
operator|=
name|i
expr_stmt|;
name|nmr
operator|->
name|nr_arg2
operator|=
name|j
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|NETMAP_BDG_REGOPS
case|:
comment|/* XXX this should not be available from userspace */
comment|/* register callbacks to the given bridge. 		 * nmr->nr_name may be just bridge's name (including ':' 		 * if it is not just NM_NAME). 		 */
if|if
condition|(
operator|!
name|bdg_ops
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|b
operator|=
name|nm_find_bridge
argument_list|(
name|name
argument_list|,
literal|0
comment|/* don't create */
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|b
operator|->
name|bdg_ops
operator|=
operator|*
name|bdg_ops
expr_stmt|;
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|NETMAP_BDG_VNET_HDR
case|:
comment|/* Valid lengths for the virtio-net header are 0 (no header), 		   10 and 12. */
if|if
condition|(
name|nmr
operator|->
name|nr_arg1
operator|!=
literal|0
operator|&&
name|nmr
operator|->
name|nr_arg1
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|nm_vnet_hdr
argument_list|)
operator|&&
name|nmr
operator|->
name|nr_arg1
operator|!=
literal|12
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_get_bdg_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|&&
operator|!
name|error
condition|)
block|{
name|vpna
operator|=
operator|(
expr|struct
name|netmap_vp_adapter
operator|*
operator|)
name|na
expr_stmt|;
name|na
operator|->
name|virt_hdr_len
operator|=
name|nmr
operator|->
name|nr_arg1
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|virt_hdr_len
condition|)
block|{
name|vpna
operator|->
name|mfs
operator|=
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
name|D
argument_list|(
literal|"Using vnet_hdr_len %d for %p"
argument_list|,
name|na
operator|->
name|virt_hdr_len
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|na
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|NETMAP_BDG_POLLING_ON
case|:
case|case
name|NETMAP_BDG_POLLING_OFF
case|:
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_get_bdg_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|&&
operator|!
name|error
condition|)
block|{
if|if
condition|(
operator|!
name|nm_is_bwrap
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|NETMAP_BDG_POLLING_ON
condition|)
block|{
name|error
operator|=
name|nm_bdg_ctl_polling_start
argument_list|(
name|nmr
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|netmap_adapter_get
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nm_bdg_ctl_polling_stop
argument_list|(
name|nmr
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
default|default:
name|D
argument_list|(
literal|"invalid cmd (nmr->nr_cmd) (0x%x)"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|netmap_bdg_config
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
block|{
name|struct
name|nm_bridge
modifier|*
name|b
decl_stmt|;
name|int
name|error
init|=
name|EINVAL
decl_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|b
operator|=
name|nm_find_bridge
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Don't call config() with NMG_LOCK() held */
name|BDG_RLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|bdg_ops
operator|.
name|config
operator|!=
name|NULL
condition|)
name|error
operator|=
name|b
operator|->
name|bdg_ops
operator|.
name|config
argument_list|(
operator|(
expr|struct
name|nm_ifreq
operator|*
operator|)
name|nmr
argument_list|)
expr_stmt|;
name|BDG_RUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* nm_krings_create callback for VALE ports.  * Calls the standard netmap_krings_create, then adds leases on rx  * rings and bdgfwd on tx rings.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_vp_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|u_int
name|tailroom
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|leases
decl_stmt|;
name|u_int
name|nrx
init|=
name|netmap_real_rings
argument_list|(
name|na
argument_list|,
name|NR_RX
argument_list|)
decl_stmt|;
comment|/* 	 * Leases are attached to RX rings on vale ports 	 */
name|tailroom
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|na
operator|->
name|num_rx_desc
operator|*
name|nrx
expr_stmt|;
name|error
operator|=
name|netmap_krings_create
argument_list|(
name|na
argument_list|,
name|tailroom
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|leases
operator|=
name|na
operator|->
name|tailroom
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrx
condition|;
name|i
operator|++
control|)
block|{
comment|/* Receive rings */
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nkr_leases
operator|=
name|leases
expr_stmt|;
name|leases
operator|+=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
block|}
name|error
operator|=
name|nm_alloc_bdgfwd
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|netmap_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* nm_krings_delete callback for VALE ports. */
end_comment

begin_function
specifier|static
name|void
name|netmap_vp_krings_delete
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|nm_free_bdgfwd
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|netmap_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|nm_bdg_flush
parameter_list|(
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
parameter_list|,
name|u_int
name|n
parameter_list|,
name|struct
name|netmap_vp_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * main dispatch routine for the bridge.  * Grab packets from a kring, move them into the ft structure  * associated to the tx (input) port. Max one instance per port,  * filtered on input (ioctl, poll or XXX).  * Returns the next position in the ring.  */
end_comment

begin_function
specifier|static
name|int
name|nm_bdg_preflush
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|u_int
name|end
parameter_list|)
block|{
name|struct
name|netmap_vp_adapter
modifier|*
name|na
init|=
operator|(
expr|struct
name|netmap_vp_adapter
operator|*
operator|)
name|kring
operator|->
name|na
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
decl_stmt|;
name|u_int
name|ring_nr
init|=
name|kring
operator|->
name|ring_id
decl_stmt|;
name|u_int
name|j
init|=
name|kring
operator|->
name|nr_hwcur
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
name|ft_i
init|=
literal|0
decl_stmt|;
comment|/* start from 0 */
name|u_int
name|frags
init|=
literal|1
decl_stmt|;
comment|/* how many frags ? */
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|na
operator|->
name|na_bdg
decl_stmt|;
comment|/* To protect against modifications to the bridge we acquire a 	 * shared lock, waiting if we can sleep (if the source port is 	 * attached to a user process) or with a trylock otherwise (NICs). 	 */
name|ND
argument_list|(
literal|"wait rlock for %d packets"
argument_list|,
operator|(
operator|(
name|j
operator|>
name|end
condition|?
name|lim
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
name|end
operator|)
operator|-
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|up
operator|.
name|na_flags
operator|&
name|NAF_BDG_MAYSLEEP
condition|)
name|BDG_RLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|BDG_RTRYLOCK
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|j
return|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"rlock acquired for %d packets"
argument_list|,
operator|(
operator|(
name|j
operator|>
name|end
condition|?
name|lim
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
name|end
operator|)
operator|-
name|j
argument_list|)
expr_stmt|;
name|ft
operator|=
name|kring
operator|->
name|nkr_ft
expr_stmt|;
for|for
control|(
init|;
name|likely
argument_list|(
name|j
operator|!=
name|end
argument_list|)
condition|;
name|j
operator|=
name|nm_next
argument_list|(
name|j
argument_list|,
name|lim
argument_list|)
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|j
index|]
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_len
operator|=
name|slot
operator|->
name|len
expr_stmt|;
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_flags
operator|=
name|slot
operator|->
name|flags
expr_stmt|;
name|ND
argument_list|(
literal|"flags is 0x%x"
argument_list|,
name|slot
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* we do not use the buf changed flag, but we still need to reset it */
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_BUF_CHANGED
expr_stmt|;
comment|/* this slot goes into a list so initialize the link field */
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_next
operator|=
name|NM_FT_NULL
expr_stmt|;
name|buf
operator|=
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_buf
operator|=
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_INDIRECT
operator|)
condition|?
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|slot
operator|->
name|ptr
else|:
name|NMB
argument_list|(
operator|&
name|na
operator|->
name|up
argument_list|,
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|buf
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"NULL %s buffer pointer from %s slot %d len %d"
argument_list|,
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_INDIRECT
operator|)
condition|?
literal|"INDIRECT"
else|:
literal|"DIRECT"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|j
argument_list|,
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_len
argument_list|)
expr_stmt|;
name|buf
operator|=
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_buf
operator|=
name|NETMAP_BUF_BASE
argument_list|(
operator|&
name|na
operator|->
name|up
argument_list|)
expr_stmt|;
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_len
operator|=
literal|0
expr_stmt|;
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_flags
operator|=
literal|0
expr_stmt|;
block|}
name|__builtin_prefetch
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|++
name|ft_i
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|flags
operator|&
name|NS_MOREFRAG
condition|)
block|{
name|frags
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|netmap_verbose
operator|&&
name|frags
operator|>
literal|1
argument_list|)
condition|)
name|RD
argument_list|(
literal|5
argument_list|,
literal|"%d frags at %d"
argument_list|,
name|frags
argument_list|,
name|ft_i
operator|-
name|frags
argument_list|)
expr_stmt|;
name|ft
index|[
name|ft_i
operator|-
name|frags
index|]
operator|.
name|ft_frags
operator|=
name|frags
expr_stmt|;
name|frags
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|int
operator|)
name|ft_i
operator|>=
name|bridge_batch
argument_list|)
condition|)
name|ft_i
operator|=
name|nm_bdg_flush
argument_list|(
name|ft
argument_list|,
name|ft_i
argument_list|,
name|na
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frags
operator|>
literal|1
condition|)
block|{
comment|/* Here ft_i> 0, ft[ft_i-1].flags has NS_MOREFRAG, and we 		 * have to fix frags count. */
name|frags
operator|--
expr_stmt|;
name|ft
index|[
name|ft_i
operator|-
literal|1
index|]
operator|.
name|ft_flags
operator|&=
operator|~
name|NS_MOREFRAG
expr_stmt|;
name|ft
index|[
name|ft_i
operator|-
name|frags
index|]
operator|.
name|ft_frags
operator|=
name|frags
expr_stmt|;
name|D
argument_list|(
literal|"Truncate incomplete fragment at %d (%d frags)"
argument_list|,
name|ft_i
argument_list|,
name|frags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ft_i
condition|)
name|ft_i
operator|=
name|nm_bdg_flush
argument_list|(
name|ft
argument_list|,
name|ft_i
argument_list|,
name|na
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
name|BDG_RUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|j
return|;
block|}
end_function

begin_comment
comment|/* ----- FreeBSD if_bridge hash function ------- */
end_comment

begin_comment
comment|/*  * The following hash function is adapted from "Hash Functions" by Bob Jenkins  * ("Algorithm Alley", Dr. Dobbs Journal, September 1997).  *  * http://www.burtleburtle.net/bob/hash/spooky.html  */
end_comment

begin_define
define|#
directive|define
name|mix
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|do {                                                                    \         a -= b; a -= c; a ^= (c>> 13);                                 \         b -= c; b -= a; b ^= (a<< 8);                                  \         c -= a; c -= b; c ^= (b>> 13);                                 \         a -= b; a -= c; a ^= (c>> 12);                                 \         b -= c; b -= a; b ^= (a<< 16);                                 \         c -= a; c -= b; c ^= (b>> 5);                                  \         a -= b; a -= c; a ^= (c>> 3);                                  \         b -= c; b -= a; b ^= (a<< 10);                                 \         c -= a; c -= b; c ^= (b>> 15);                                 \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_function
specifier|static
name|__inline
name|uint32_t
name|nm_bridge_rthash
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint32_t
name|a
init|=
literal|0x9e3779b9
decl_stmt|,
name|b
init|=
literal|0x9e3779b9
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
comment|// hask key
name|b
operator|+=
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
name|b
operator|+=
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
define|#
directive|define
name|BRIDGE_RTHASH_MASK
value|(NM_BDG_HASH-1)
return|return
operator|(
name|c
operator|&
name|BRIDGE_RTHASH_MASK
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|mix
end_undef

begin_comment
comment|/* nm_register callback for VALE ports */
end_comment

begin_function
specifier|static
name|int
name|netmap_vp_reg
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
init|=
operator|(
expr|struct
name|netmap_vp_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* persistent ports may be put in netmap mode 	 * before being attached to a bridge 	 */
if|if
condition|(
name|vpna
operator|->
name|na_bdg
condition|)
name|BDG_WLOCK
argument_list|(
name|vpna
operator|->
name|na_bdg
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|nm_kring_pending_on
argument_list|(
name|kring
argument_list|)
condition|)
name|kring
operator|->
name|nr_mode
operator|=
name|NKR_NETMAP_ON
expr_stmt|;
block|}
block|}
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
name|na
operator|->
name|na_flags
operator||=
name|NAF_NETMAP_ON
expr_stmt|;
comment|/* XXX on FreeBSD, persistent VALE ports should also 		 * toggle IFCAP_NETMAP in na->ifp (2014-03-16) 		 */
block|}
else|else
block|{
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
name|na
operator|->
name|na_flags
operator|&=
operator|~
name|NAF_NETMAP_ON
expr_stmt|;
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|nm_kring_pending_off
argument_list|(
name|kring
argument_list|)
condition|)
name|kring
operator|->
name|nr_mode
operator|=
name|NKR_NETMAP_OFF
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|vpna
operator|->
name|na_bdg
condition|)
name|BDG_WUNLOCK
argument_list|(
name|vpna
operator|->
name|na_bdg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup function for a learning bridge.  * Update the hash table with the source address,  * and then returns the destination port index, and the  * ring in *dst_ring (at the moment, always use ring 0)  */
end_comment

begin_function
name|u_int
name|netmap_bdg_learning
parameter_list|(
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
parameter_list|,
name|uint8_t
modifier|*
name|dst_ring
parameter_list|,
name|struct
name|netmap_vp_adapter
modifier|*
name|na
parameter_list|)
block|{
name|uint8_t
modifier|*
name|buf
init|=
name|ft
operator|->
name|ft_buf
decl_stmt|;
name|u_int
name|buf_len
init|=
name|ft
operator|->
name|ft_len
decl_stmt|;
name|struct
name|nm_hash_ent
modifier|*
name|ht
init|=
name|na
operator|->
name|na_bdg
operator|->
name|ht
decl_stmt|;
name|uint32_t
name|sh
decl_stmt|,
name|dh
decl_stmt|;
name|u_int
name|dst
decl_stmt|,
name|mysrc
init|=
name|na
operator|->
name|bdg_port
decl_stmt|;
name|uint64_t
name|smac
decl_stmt|,
name|dmac
decl_stmt|;
name|uint8_t
name|indbuf
index|[
literal|12
index|]
decl_stmt|;
comment|/* safety check, unfortunately we have many cases */
if|if
condition|(
name|buf_len
operator|>=
literal|14
operator|+
name|na
operator|->
name|up
operator|.
name|virt_hdr_len
condition|)
block|{
comment|/* virthdr + mac_hdr in the same slot */
name|buf
operator|+=
name|na
operator|->
name|up
operator|.
name|virt_hdr_len
expr_stmt|;
name|buf_len
operator|-=
name|na
operator|->
name|up
operator|.
name|virt_hdr_len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf_len
operator|==
name|na
operator|->
name|up
operator|.
name|virt_hdr_len
operator|&&
name|ft
operator|->
name|ft_flags
operator|&
name|NS_MOREFRAG
condition|)
block|{
comment|/* only header in first fragment */
name|ft
operator|++
expr_stmt|;
name|buf
operator|=
name|ft
operator|->
name|ft_buf
expr_stmt|;
name|buf_len
operator|=
name|ft
operator|->
name|ft_len
expr_stmt|;
block|}
else|else
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"invalid buf format, length %d"
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
return|return
name|NM_BDG_NOPORT
return|;
block|}
if|if
condition|(
name|ft
operator|->
name|ft_flags
operator|&
name|NS_INDIRECT
condition|)
block|{
if|if
condition|(
name|copyin
argument_list|(
name|buf
argument_list|,
name|indbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|indbuf
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|NM_BDG_NOPORT
return|;
block|}
name|buf
operator|=
name|indbuf
expr_stmt|;
block|}
name|dmac
operator|=
name|le64toh
argument_list|(
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|buf
operator|)
argument_list|)
operator|&
literal|0xffffffffffff
expr_stmt|;
name|smac
operator|=
name|le64toh
argument_list|(
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|buf
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
name|smac
operator|>>=
literal|16
expr_stmt|;
comment|/* 	 * The hash is somewhat expensive, there might be some 	 * worthwhile optimizations here. 	 */
if|if
condition|(
operator|(
operator|(
name|buf
index|[
literal|6
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|na
operator|->
name|last_smac
operator|!=
name|smac
operator|)
condition|)
block|{
comment|/* valid src */
name|uint8_t
modifier|*
name|s
init|=
name|buf
operator|+
literal|6
decl_stmt|;
name|sh
operator|=
name|nm_bridge_rthash
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|// XXX hash of source
comment|/* update source port forwarding entry */
name|na
operator|->
name|last_smac
operator|=
name|ht
index|[
name|sh
index|]
operator|.
name|mac
operator|=
name|smac
expr_stmt|;
comment|/* XXX expire ? */
name|ht
index|[
name|sh
index|]
operator|.
name|ports
operator|=
name|mysrc
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"src %02x:%02x:%02x:%02x:%02x:%02x on port %d"
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|,
name|s
index|[
literal|4
index|]
argument_list|,
name|s
index|[
literal|5
index|]
argument_list|,
name|mysrc
argument_list|)
expr_stmt|;
block|}
name|dst
operator|=
name|NM_BDG_BROADCAST
expr_stmt|;
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* unicast */
name|dh
operator|=
name|nm_bridge_rthash
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// XXX hash of dst
if|if
condition|(
name|ht
index|[
name|dh
index|]
operator|.
name|mac
operator|==
name|dmac
condition|)
block|{
comment|/* found dst */
name|dst
operator|=
name|ht
index|[
name|dh
index|]
operator|.
name|ports
expr_stmt|;
block|}
comment|/* XXX otherwise return NM_BDG_UNKNOWN ? */
block|}
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/*  * Available space in the ring. Only used in VALE code  * and only with is_rx = 1  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|nm_kr_space
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|k
parameter_list|,
name|int
name|is_rx
parameter_list|)
block|{
name|int
name|space
decl_stmt|;
if|if
condition|(
name|is_rx
condition|)
block|{
name|int
name|busy
init|=
name|k
operator|->
name|nkr_hwlease
operator|-
name|k
operator|->
name|nr_hwcur
decl_stmt|;
if|if
condition|(
name|busy
operator|<
literal|0
condition|)
name|busy
operator|+=
name|k
operator|->
name|nkr_num_slots
expr_stmt|;
name|space
operator|=
name|k
operator|->
name|nkr_num_slots
operator|-
literal|1
operator|-
name|busy
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX never used in this branch */
name|space
operator|=
name|k
operator|->
name|nr_hwtail
operator|-
name|k
operator|->
name|nkr_hwlease
expr_stmt|;
if|if
condition|(
name|space
operator|<
literal|0
condition|)
name|space
operator|+=
name|k
operator|->
name|nkr_num_slots
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|// sanity check
block|if (k->nkr_hwlease>= k->nkr_num_slots || 		k->nr_hwcur>= k->nkr_num_slots || 		k->nr_tail>= k->nkr_num_slots || 		busy< 0 || 		busy>= k->nkr_num_slots) { 		D("invalid kring, cur %d tail %d lease %d lease_idx %d lim %d",			k->nr_hwcur, k->nr_hwtail, k->nkr_hwlease, 			k->nkr_lease_idx, k->nkr_num_slots); 	}
endif|#
directive|endif
return|return
name|space
return|;
block|}
end_function

begin_comment
comment|/* make a lease on the kring for N positions. return the  * lease index  * XXX only used in VALE code and with is_rx = 1  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|nm_kr_lease
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|k
parameter_list|,
name|u_int
name|n
parameter_list|,
name|int
name|is_rx
parameter_list|)
block|{
name|uint32_t
name|lim
init|=
name|k
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|uint32_t
name|lease_idx
init|=
name|k
operator|->
name|nkr_lease_idx
decl_stmt|;
name|k
operator|->
name|nkr_leases
index|[
name|lease_idx
index|]
operator|=
name|NR_NOSLOT
expr_stmt|;
name|k
operator|->
name|nkr_lease_idx
operator|=
name|nm_next
argument_list|(
name|lease_idx
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|nm_kr_space
argument_list|(
name|k
argument_list|,
name|is_rx
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"invalid request for %d slots"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
block|}
comment|/* XXX verify that there are n slots */
name|k
operator|->
name|nkr_hwlease
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|nkr_hwlease
operator|>
name|lim
condition|)
name|k
operator|->
name|nkr_hwlease
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|nkr_hwlease
operator|>=
name|k
operator|->
name|nkr_num_slots
operator|||
name|k
operator|->
name|nr_hwcur
operator|>=
name|k
operator|->
name|nkr_num_slots
operator|||
name|k
operator|->
name|nr_hwtail
operator|>=
name|k
operator|->
name|nkr_num_slots
operator|||
name|k
operator|->
name|nkr_lease_idx
operator|>=
name|k
operator|->
name|nkr_num_slots
condition|)
block|{
name|D
argument_list|(
literal|"invalid kring %s, cur %d tail %d lease %d lease_idx %d lim %d"
argument_list|,
name|k
operator|->
name|na
operator|->
name|name
argument_list|,
name|k
operator|->
name|nr_hwcur
argument_list|,
name|k
operator|->
name|nr_hwtail
argument_list|,
name|k
operator|->
name|nkr_hwlease
argument_list|,
name|k
operator|->
name|nkr_lease_idx
argument_list|,
name|k
operator|->
name|nkr_num_slots
argument_list|)
expr_stmt|;
block|}
return|return
name|lease_idx
return|;
block|}
end_function

begin_comment
comment|/*  *  * This flush routine supports only unicast and broadcast but a large  * number of ports, and lets us replace the learn and dispatch functions.  */
end_comment

begin_function
name|int
name|nm_bdg_flush
parameter_list|(
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
parameter_list|,
name|u_int
name|n
parameter_list|,
name|struct
name|netmap_vp_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|)
block|{
name|struct
name|nm_bdg_q
modifier|*
name|dst_ents
decl_stmt|,
modifier|*
name|brddst
decl_stmt|;
name|uint16_t
name|num_dsts
init|=
literal|0
decl_stmt|,
modifier|*
name|dsts
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|na
operator|->
name|na_bdg
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|me
init|=
name|na
operator|->
name|bdg_port
decl_stmt|;
comment|/* 	 * The work area (pointed by ft) is followed by an array of 	 * pointers to queues , dst_ents; there are NM_BDG_MAXRINGS 	 * queues per port plus one for the broadcast traffic. 	 * Then we have an array of destination indexes. 	 */
name|dst_ents
operator|=
operator|(
expr|struct
name|nm_bdg_q
operator|*
operator|)
operator|(
name|ft
operator|+
name|NM_BDG_BATCH_MAX
operator|)
expr_stmt|;
name|dsts
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|dst_ents
operator|+
name|NM_BDG_MAXPORTS
operator|*
name|NM_BDG_MAXRINGS
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* first pass: find a destination for each packet in the batch */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|likely
argument_list|(
name|i
operator|<
name|n
argument_list|)
condition|;
name|i
operator|+=
name|ft
index|[
name|i
index|]
operator|.
name|ft_frags
control|)
block|{
name|uint8_t
name|dst_ring
init|=
name|ring_nr
decl_stmt|;
comment|/* default, same ring as origin */
name|uint16_t
name|dst_port
decl_stmt|,
name|d_i
decl_stmt|;
name|struct
name|nm_bdg_q
modifier|*
name|d
decl_stmt|;
name|ND
argument_list|(
literal|"slot %d frags %d"
argument_list|,
name|i
argument_list|,
name|ft
index|[
name|i
index|]
operator|.
name|ft_frags
argument_list|)
expr_stmt|;
comment|/* Drop the packet if the virtio-net header is not into the first 		   fragment nor at the very beginning of the second. */
if|if
condition|(
name|unlikely
argument_list|(
name|na
operator|->
name|up
operator|.
name|virt_hdr_len
operator|>
name|ft
index|[
name|i
index|]
operator|.
name|ft_len
argument_list|)
condition|)
continue|continue;
name|dst_port
operator|=
name|b
operator|->
name|bdg_ops
operator|.
name|lookup
argument_list|(
operator|&
name|ft
index|[
name|i
index|]
argument_list|,
operator|&
name|dst_ring
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|>
literal|255
condition|)
name|RD
argument_list|(
literal|5
argument_list|,
literal|"slot %d port %d -> %d"
argument_list|,
name|i
argument_list|,
name|me
argument_list|,
name|dst_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_port
operator|==
name|NM_BDG_NOPORT
condition|)
continue|continue;
comment|/* this packet is identified to be dropped */
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|dst_port
operator|>
name|NM_BDG_MAXPORTS
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|dst_port
operator|==
name|NM_BDG_BROADCAST
condition|)
name|dst_ring
operator|=
literal|0
expr_stmt|;
comment|/* broadcasts always go to ring 0 */
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|dst_port
operator|==
name|me
operator|||
operator|!
name|b
operator|->
name|bdg_ports
index|[
name|dst_port
index|]
argument_list|)
condition|)
continue|continue;
comment|/* get a position in the scratch pad */
name|d_i
operator|=
name|dst_port
operator|*
name|NM_BDG_MAXRINGS
operator|+
name|dst_ring
expr_stmt|;
name|d
operator|=
name|dst_ents
operator|+
name|d_i
expr_stmt|;
comment|/* append the first fragment to the list */
if|if
condition|(
name|d
operator|->
name|bq_head
operator|==
name|NM_FT_NULL
condition|)
block|{
comment|/* new destination */
name|d
operator|->
name|bq_head
operator|=
name|d
operator|->
name|bq_tail
operator|=
name|i
expr_stmt|;
comment|/* remember this position to be scanned later */
if|if
condition|(
name|dst_port
operator|!=
name|NM_BDG_BROADCAST
condition|)
name|dsts
index|[
name|num_dsts
operator|++
index|]
operator|=
name|d_i
expr_stmt|;
block|}
else|else
block|{
name|ft
index|[
name|d
operator|->
name|bq_tail
index|]
operator|.
name|ft_next
operator|=
name|i
expr_stmt|;
name|d
operator|->
name|bq_tail
operator|=
name|i
expr_stmt|;
block|}
name|d
operator|->
name|bq_len
operator|+=
name|ft
index|[
name|i
index|]
operator|.
name|ft_frags
expr_stmt|;
block|}
comment|/* 	 * Broadcast traffic goes to ring 0 on all destinations. 	 * So we need to add these rings to the list of ports to scan. 	 * XXX at the moment we scan all NM_BDG_MAXPORTS ports, which is 	 * expensive. We should keep a compact list of active destinations 	 * so we could shorten this loop. 	 */
name|brddst
operator|=
name|dst_ents
operator|+
name|NM_BDG_BROADCAST
operator|*
name|NM_BDG_MAXRINGS
expr_stmt|;
if|if
condition|(
name|brddst
operator|->
name|bq_head
operator|!=
name|NM_FT_NULL
condition|)
block|{
name|u_int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|likely
argument_list|(
name|j
operator|<
name|b
operator|->
name|bdg_active_ports
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|uint16_t
name|d_i
decl_stmt|;
name|i
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|i
operator|==
name|me
argument_list|)
condition|)
continue|continue;
name|d_i
operator|=
name|i
operator|*
name|NM_BDG_MAXRINGS
expr_stmt|;
if|if
condition|(
name|dst_ents
index|[
name|d_i
index|]
operator|.
name|bq_head
operator|==
name|NM_FT_NULL
condition|)
name|dsts
index|[
name|num_dsts
operator|++
index|]
operator|=
name|d_i
expr_stmt|;
block|}
block|}
name|ND
argument_list|(
literal|5
argument_list|,
literal|"pass 1 done %d pkts %d dsts"
argument_list|,
name|n
argument_list|,
name|num_dsts
argument_list|)
expr_stmt|;
comment|/* second pass: scan destinations */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_dsts
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_vp_adapter
modifier|*
name|dst_na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
decl_stmt|;
name|u_int
name|dst_nr
decl_stmt|,
name|lim
decl_stmt|,
name|j
decl_stmt|,
name|d_i
decl_stmt|,
name|next
decl_stmt|,
name|brd_next
decl_stmt|;
name|u_int
name|needed
decl_stmt|,
name|howmany
decl_stmt|;
name|int
name|retry
init|=
name|netmap_txsync_retry
decl_stmt|;
name|struct
name|nm_bdg_q
modifier|*
name|d
decl_stmt|;
name|uint32_t
name|my_start
init|=
literal|0
decl_stmt|,
name|lease_idx
init|=
literal|0
decl_stmt|;
name|int
name|nrings
decl_stmt|;
name|int
name|virt_hdr_mismatch
init|=
literal|0
decl_stmt|;
name|d_i
operator|=
name|dsts
index|[
name|i
index|]
expr_stmt|;
name|ND
argument_list|(
literal|"second pass %d port %d"
argument_list|,
name|i
argument_list|,
name|d_i
argument_list|)
expr_stmt|;
name|d
operator|=
name|dst_ents
operator|+
name|d_i
expr_stmt|;
comment|// XXX fix the division
name|dst_na
operator|=
name|b
operator|->
name|bdg_ports
index|[
name|d_i
operator|/
name|NM_BDG_MAXRINGS
index|]
expr_stmt|;
comment|/* protect from the lookup function returning an inactive 		 * destination port 		 */
if|if
condition|(
name|unlikely
argument_list|(
name|dst_na
operator|==
name|NULL
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|dst_na
operator|->
name|up
operator|.
name|na_flags
operator|&
name|NAF_SW_ONLY
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 		 * The interface may be in !netmap mode in two cases: 		 * - when na is attached but not activated yet; 		 * - when na is being deactivated but is still attached. 		 */
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|nm_netmap_on
argument_list|(
operator|&
name|dst_na
operator|->
name|up
argument_list|)
argument_list|)
condition|)
block|{
name|ND
argument_list|(
literal|"not in netmap mode!"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* there is at least one either unicast or broadcast packet */
name|brd_next
operator|=
name|brddst
operator|->
name|bq_head
expr_stmt|;
name|next
operator|=
name|d
operator|->
name|bq_head
expr_stmt|;
comment|/* we need to reserve this many slots. If fewer are 		 * available, some packets will be dropped. 		 * Packets may have multiple fragments, so we may not use 		 * there is a chance that we may not use all of the slots 		 * we have claimed, so we will need to handle the leftover 		 * ones when we regain the lock. 		 */
name|needed
operator|=
name|d
operator|->
name|bq_len
operator|+
name|brddst
operator|->
name|bq_len
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|dst_na
operator|->
name|up
operator|.
name|virt_hdr_len
operator|!=
name|na
operator|->
name|up
operator|.
name|virt_hdr_len
argument_list|)
condition|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
block|{
name|RD
argument_list|(
literal|3
argument_list|,
literal|"virt_hdr_mismatch, src %d dst %d"
argument_list|,
name|na
operator|->
name|up
operator|.
name|virt_hdr_len
argument_list|,
name|dst_na
operator|->
name|up
operator|.
name|virt_hdr_len
argument_list|)
expr_stmt|;
block|}
comment|/* There is a virtio-net header/offloadings mismatch between 			 * source and destination. The slower mismatch datapath will 			 * be used to cope with all the mismatches. 			 */
name|virt_hdr_mismatch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dst_na
operator|->
name|mfs
operator|<
name|na
operator|->
name|mfs
condition|)
block|{
comment|/* We may need to do segmentation offloadings, and so 				 * we may need a number of destination slots greater 				 * than the number of input slots ('needed'). 				 * We look for the smallest integer 'x' which satisfies: 				 *	needed * na->mfs + x * H<= x * na->mfs 				 * where 'H' is the length of the longest header that may 				 * be replicated in the segmentation process (e.g. for 				 * TCPv4 we must account for ethernet header, IP header 				 * and TCPv4 header). 				 */
name|needed
operator|=
operator|(
name|needed
operator|*
name|na
operator|->
name|mfs
operator|)
operator|/
operator|(
name|dst_na
operator|->
name|mfs
operator|-
name|WORST_CASE_GSO_HEADER
operator|)
operator|+
literal|1
expr_stmt|;
name|ND
argument_list|(
literal|3
argument_list|,
literal|"srcmtu=%u, dstmtu=%u, x=%u"
argument_list|,
name|na
operator|->
name|mfs
argument_list|,
name|dst_na
operator|->
name|mfs
argument_list|,
name|needed
argument_list|)
expr_stmt|;
block|}
block|}
name|ND
argument_list|(
literal|5
argument_list|,
literal|"pass 2 dst %d is %x %s"
argument_list|,
name|i
argument_list|,
name|d_i
argument_list|,
name|is_vp
condition|?
literal|"virtual"
else|:
literal|"nic/host"
argument_list|)
expr_stmt|;
name|dst_nr
operator|=
name|d_i
operator|&
operator|(
name|NM_BDG_MAXRINGS
operator|-
literal|1
operator|)
expr_stmt|;
name|nrings
operator|=
name|dst_na
operator|->
name|up
operator|.
name|num_rx_rings
expr_stmt|;
if|if
condition|(
name|dst_nr
operator|>=
name|nrings
condition|)
name|dst_nr
operator|=
name|dst_nr
operator|%
name|nrings
expr_stmt|;
name|kring
operator|=
operator|&
name|dst_na
operator|->
name|up
operator|.
name|rx_rings
index|[
name|dst_nr
index|]
expr_stmt|;
name|ring
operator|=
name|kring
operator|->
name|ring
expr_stmt|;
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|dst_na
operator|->
name|retry
operator|&&
name|retry
condition|)
block|{
comment|/* try to get some free slot from the previous run */
name|kring
operator|->
name|nm_notify
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* actually useful only for bwraps, since there 			 * the notify will trigger a txsync on the hwna. VALE ports 			 * have dst_na->retry == 0 			 */
block|}
comment|/* reserve the buffers in the queue and an entry 		 * to report completion, and drop lock. 		 * XXX this might become a helper function. 		 */
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nkr_stopped
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|my_start
operator|=
name|j
operator|=
name|kring
operator|->
name|nkr_hwlease
expr_stmt|;
name|howmany
operator|=
name|nm_kr_space
argument_list|(
name|kring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|needed
operator|<
name|howmany
condition|)
name|howmany
operator|=
name|needed
expr_stmt|;
name|lease_idx
operator|=
name|nm_kr_lease
argument_list|(
name|kring
argument_list|,
name|howmany
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
comment|/* only retry if we need more than available slots */
if|if
condition|(
name|retry
operator|&&
name|needed
operator|<=
name|howmany
condition|)
name|retry
operator|=
literal|0
expr_stmt|;
comment|/* copy to the destination queue */
while|while
condition|(
name|howmany
operator|>
literal|0
condition|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|nm_bdg_fwd
modifier|*
name|ft_p
decl_stmt|,
modifier|*
name|ft_end
decl_stmt|;
name|u_int
name|cnt
decl_stmt|;
comment|/* find the queue from which we pick next packet. 			 * NM_FT_NULL is always higher than valid indexes 			 * so we never dereference it if the other list 			 * has packets (and if both are empty we never 			 * get here). 			 */
if|if
condition|(
name|next
operator|<
name|brd_next
condition|)
block|{
name|ft_p
operator|=
name|ft
operator|+
name|next
expr_stmt|;
name|next
operator|=
name|ft_p
operator|->
name|ft_next
expr_stmt|;
block|}
else|else
block|{
comment|/* insert broadcast */
name|ft_p
operator|=
name|ft
operator|+
name|brd_next
expr_stmt|;
name|brd_next
operator|=
name|ft_p
operator|->
name|ft_next
expr_stmt|;
block|}
name|cnt
operator|=
name|ft_p
operator|->
name|ft_frags
expr_stmt|;
comment|// cnt> 0
if|if
condition|(
name|unlikely
argument_list|(
name|cnt
operator|>
name|howmany
argument_list|)
condition|)
break|break;
comment|/* no more space */
if|if
condition|(
name|netmap_verbose
operator|&&
name|cnt
operator|>
literal|1
condition|)
name|RD
argument_list|(
literal|5
argument_list|,
literal|"rx %d frags to %d"
argument_list|,
name|cnt
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ft_end
operator|=
name|ft_p
operator|+
name|cnt
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|virt_hdr_mismatch
argument_list|)
condition|)
block|{
name|bdg_mismatch_datapath
argument_list|(
name|na
argument_list|,
name|dst_na
argument_list|,
name|ft_p
argument_list|,
name|ring
argument_list|,
operator|&
name|j
argument_list|,
name|lim
argument_list|,
operator|&
name|howmany
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|howmany
operator|-=
name|cnt
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
init|=
name|ft_p
operator|->
name|ft_buf
decl_stmt|;
name|size_t
name|copy_len
init|=
name|ft_p
operator|->
name|ft_len
decl_stmt|,
name|dst_len
init|=
name|copy_len
decl_stmt|;
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
name|j
index|]
expr_stmt|;
name|dst
operator|=
name|NMB
argument_list|(
operator|&
name|dst_na
operator|->
name|up
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"send [%d] %d(%d) bytes at %s:%d"
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|copy_len
argument_list|,
operator|(
name|int
operator|)
name|dst_len
argument_list|,
name|NM_IFPNAME
argument_list|(
name|dst_ifp
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* round to a multiple of 64 */
name|copy_len
operator|=
operator|(
name|copy_len
operator|+
literal|63
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|copy_len
operator|>
name|NETMAP_BUF_SIZE
argument_list|(
operator|&
name|dst_na
operator|->
name|up
argument_list|)
operator|||
name|copy_len
operator|>
name|NETMAP_BUF_SIZE
argument_list|(
operator|&
name|na
operator|->
name|up
argument_list|)
argument_list|)
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"invalid len %d, down to 64"
argument_list|,
operator|(
name|int
operator|)
name|copy_len
argument_list|)
expr_stmt|;
name|copy_len
operator|=
name|dst_len
operator|=
literal|64
expr_stmt|;
comment|// XXX
block|}
if|if
condition|(
name|ft_p
operator|->
name|ft_flags
operator|&
name|NS_INDIRECT
condition|)
block|{
if|if
condition|(
name|copyin
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|copy_len
argument_list|)
condition|)
block|{
comment|// invalid user pointer, pretend len is 0
name|dst_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//memcpy(dst, src, copy_len);
name|pkt_copy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|int
operator|)
name|copy_len
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|len
operator|=
name|dst_len
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
operator|(
name|cnt
operator|<<
literal|8
operator|)
operator||
name|NS_MOREFRAG
expr_stmt|;
name|j
operator|=
name|nm_next
argument_list|(
name|j
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|needed
operator|--
expr_stmt|;
name|ft_p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ft_p
operator|!=
name|ft_end
condition|)
do|;
name|slot
operator|->
name|flags
operator|=
operator|(
name|cnt
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* clear flag on last entry */
block|}
comment|/* are we done ? */
if|if
condition|(
name|next
operator|==
name|NM_FT_NULL
operator|&&
name|brd_next
operator|==
name|NM_FT_NULL
condition|)
break|break;
block|}
block|{
comment|/* current position */
name|uint32_t
modifier|*
name|p
init|=
name|kring
operator|->
name|nkr_leases
decl_stmt|;
comment|/* shorthand */
name|uint32_t
name|update_pos
decl_stmt|;
name|int
name|still_locked
init|=
literal|1
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|howmany
operator|>
literal|0
argument_list|)
condition|)
block|{
comment|/* not used all bufs. If i am the last one 			 * i can recover the slots, otherwise must 			 * fill them with 0 to mark empty packets. 			 */
name|ND
argument_list|(
literal|"leftover %d bufs"
argument_list|,
name|howmany
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_next
argument_list|(
name|lease_idx
argument_list|,
name|lim
argument_list|)
operator|==
name|kring
operator|->
name|nkr_lease_idx
condition|)
block|{
comment|/* yes i am the last one */
name|ND
argument_list|(
literal|"roll back nkr_hwlease to %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nkr_hwlease
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|howmany
operator|--
operator|>
literal|0
condition|)
block|{
name|ring
operator|->
name|slot
index|[
name|j
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|j
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|nm_next
argument_list|(
name|j
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|p
index|[
name|lease_idx
index|]
operator|=
name|j
expr_stmt|;
comment|/* report I am done */
name|update_pos
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
if|if
condition|(
name|my_start
operator|==
name|update_pos
condition|)
block|{
comment|/* all slots before my_start have been reported, 			 * so scan subsequent leases to see if other ranges 			 * have been completed, and to a selwakeup or txsync. 		         */
while|while
condition|(
name|lease_idx
operator|!=
name|kring
operator|->
name|nkr_lease_idx
operator|&&
name|p
index|[
name|lease_idx
index|]
operator|!=
name|NR_NOSLOT
condition|)
block|{
name|j
operator|=
name|p
index|[
name|lease_idx
index|]
expr_stmt|;
name|p
index|[
name|lease_idx
index|]
operator|=
name|NR_NOSLOT
expr_stmt|;
name|lease_idx
operator|=
name|nm_next
argument_list|(
name|lease_idx
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
comment|/* j is the new 'write' position. j != my_start 			 * means there are new buffers to report 			 */
if|if
condition|(
name|likely
argument_list|(
name|j
operator|!=
name|my_start
argument_list|)
condition|)
block|{
name|kring
operator|->
name|nr_hwtail
operator|=
name|j
expr_stmt|;
name|still_locked
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nm_notify
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* this is netmap_notify for VALE ports and 				 * netmap_bwrap_notify for bwrap. The latter will 				 * trigger a txsync on the underlying hwna 				 */
if|if
condition|(
name|dst_na
operator|->
name|retry
operator|&&
name|retry
operator|--
condition|)
block|{
comment|/* XXX this is going to call nm_notify again. 					 * Only useful for bwrap in virtual machines 					 */
goto|goto
name|retry
goto|;
block|}
block|}
block|}
if|if
condition|(
name|still_locked
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
name|d
operator|->
name|bq_head
operator|=
name|d
operator|->
name|bq_tail
operator|=
name|NM_FT_NULL
expr_stmt|;
comment|/* cleanup */
name|d
operator|->
name|bq_len
operator|=
literal|0
expr_stmt|;
block|}
name|brddst
operator|->
name|bq_head
operator|=
name|brddst
operator|->
name|bq_tail
operator|=
name|NM_FT_NULL
expr_stmt|;
comment|/* cleanup */
name|brddst
operator|->
name|bq_len
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* nm_txsync callback for VALE ports */
end_comment

begin_function
specifier|static
name|int
name|netmap_vp_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_vp_adapter
modifier|*
name|na
init|=
operator|(
expr|struct
name|netmap_vp_adapter
operator|*
operator|)
name|kring
operator|->
name|na
decl_stmt|;
name|u_int
name|done
decl_stmt|;
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
if|if
condition|(
name|bridge_batch
operator|<=
literal|0
condition|)
block|{
comment|/* testing only */
name|done
operator|=
name|head
expr_stmt|;
comment|// used all
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|na
operator|->
name|na_bdg
condition|)
block|{
name|done
operator|=
name|head
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|bridge_batch
operator|>
name|NM_BDG_BATCH
condition|)
name|bridge_batch
operator|=
name|NM_BDG_BATCH
expr_stmt|;
name|done
operator|=
name|nm_bdg_preflush
argument_list|(
name|kring
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|done
operator|!=
name|head
condition|)
name|D
argument_list|(
literal|"early break at %d/ %d, tail %d"
argument_list|,
name|done
argument_list|,
name|head
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
comment|/* 	 * packets between 'done' and 'cur' are left unsent. 	 */
name|kring
operator|->
name|nr_hwcur
operator|=
name|done
expr_stmt|;
name|kring
operator|->
name|nr_hwtail
operator|=
name|nm_prev
argument_list|(
name|done
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s ring %d flags %d"
argument_list|,
name|na
operator|->
name|up
operator|.
name|name
argument_list|,
name|kring
operator|->
name|ring_id
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* rxsync code used by VALE ports nm_rxsync callback and also  * internally by the brwap  */
end_comment

begin_function
specifier|static
name|int
name|netmap_vp_rxsync_locked
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|nm_i
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|head
operator|>
name|lim
condition|)
block|{
name|D
argument_list|(
literal|"ouch dangerous reset!!!"
argument_list|)
expr_stmt|;
name|n
operator|=
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* First part, import newly received packets. */
comment|/* actually nothing to do here, they are already in the kring */
comment|/* Second part, skip past packets that userspace has released. */
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|nm_i
operator|!=
name|head
condition|)
block|{
comment|/* consistency check, but nothing really important here */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|likely
argument_list|(
name|nm_i
operator|!=
name|head
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
decl_stmt|;
name|void
modifier|*
name|addr
init|=
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|NETMAP_BUF_BASE
argument_list|(
name|kring
operator|->
name|na
argument_list|)
condition|)
block|{
comment|/* bad buf */
name|D
argument_list|(
literal|"bad buffer index %d, ignore ?"
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_BUF_CHANGED
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwcur
operator|=
name|head
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
name|done
label|:
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * nm_rxsync callback for VALE ports  * user process reading from a VALE switch.  * Already protected against concurrent calls from userspace,  * but we must acquire the queue's lock to protect against  * writers on the same queue.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_vp_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|n
operator|=
name|netmap_vp_rxsync_locked
argument_list|(
name|kring
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* nm_bdg_attach callback for VALE ports  * The na_vp port is this same netmap_adapter. There is no host port.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_vp_bdg_attach
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
init|=
operator|(
expr|struct
name|netmap_vp_adapter
operator|*
operator|)
name|na
decl_stmt|;
if|if
condition|(
name|vpna
operator|->
name|na_bdg
condition|)
return|return
name|EBUSY
return|;
name|na
operator|->
name|na_vp
operator|=
name|vpna
expr_stmt|;
name|strncpy
argument_list|(
name|na
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|na
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_hostvp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* create a netmap_vp_adapter that describes a VALE port.  * Only persistent VALE ports have a non-null ifp.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_vp_create
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|netmap_mem_d
modifier|*
name|nmd
parameter_list|,
name|struct
name|netmap_vp_adapter
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int
name|npipes
init|=
literal|0
decl_stmt|;
name|vpna
operator|=
name|nm_os_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vpna
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vpna
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|na
operator|=
operator|&
name|vpna
operator|->
name|up
expr_stmt|;
name|na
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|strncpy
argument_list|(
name|na
operator|->
name|name
argument_list|,
name|nmr
operator|->
name|nr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|na
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bound checking */
name|na
operator|->
name|num_tx_rings
operator|=
name|nmr
operator|->
name|nr_tx_rings
expr_stmt|;
name|nm_bound_var
argument_list|(
operator|&
name|na
operator|->
name|num_tx_rings
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|NM_BDG_MAXRINGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
comment|// write back
name|na
operator|->
name|num_rx_rings
operator|=
name|nmr
operator|->
name|nr_rx_rings
expr_stmt|;
name|nm_bound_var
argument_list|(
operator|&
name|na
operator|->
name|num_rx_rings
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|NM_BDG_MAXRINGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
comment|// write back
name|nm_bound_var
argument_list|(
operator|&
name|nmr
operator|->
name|nr_tx_slots
argument_list|,
name|NM_BRIDGE_RINGSIZE
argument_list|,
literal|1
argument_list|,
name|NM_BDG_MAXSLOTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|na
operator|->
name|num_tx_desc
operator|=
name|nmr
operator|->
name|nr_tx_slots
expr_stmt|;
name|nm_bound_var
argument_list|(
operator|&
name|nmr
operator|->
name|nr_rx_slots
argument_list|,
name|NM_BRIDGE_RINGSIZE
argument_list|,
literal|1
argument_list|,
name|NM_BDG_MAXSLOTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* validate number of pipes. We want at least 1, 	 * but probably can do with some more. 	 * So let's use 2 as default (when 0 is supplied) 	 */
name|npipes
operator|=
name|nmr
operator|->
name|nr_arg1
expr_stmt|;
name|nm_bound_var
argument_list|(
operator|&
name|npipes
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|NM_MAXPIPES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_arg1
operator|=
name|npipes
expr_stmt|;
comment|/* write back */
comment|/* validate extra bufs */
name|nm_bound_var
argument_list|(
operator|&
name|nmr
operator|->
name|nr_arg3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|128
operator|*
name|NM_BDG_MAXSLOTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|na
operator|->
name|num_rx_desc
operator|=
name|nmr
operator|->
name|nr_rx_slots
expr_stmt|;
name|vpna
operator|->
name|mfs
operator|=
literal|1514
expr_stmt|;
name|vpna
operator|->
name|last_smac
operator|=
operator|~
literal|0llu
expr_stmt|;
comment|/*if (vpna->mfs> netmap_buf_size)  TODO netmap_buf_size is zero?? 		vpna->mfs = netmap_buf_size; */
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"max frame size %u"
argument_list|,
name|vpna
operator|->
name|mfs
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_flags
operator||=
name|NAF_BDG_MAYSLEEP
expr_stmt|;
comment|/* persistent VALE ports look like hw devices 	 * with a native netmap adapter 	 */
if|if
condition|(
name|ifp
condition|)
name|na
operator|->
name|na_flags
operator||=
name|NAF_NATIVE
expr_stmt|;
name|na
operator|->
name|nm_txsync
operator|=
name|netmap_vp_txsync
expr_stmt|;
name|na
operator|->
name|nm_rxsync
operator|=
name|netmap_vp_rxsync
expr_stmt|;
name|na
operator|->
name|nm_register
operator|=
name|netmap_vp_reg
expr_stmt|;
name|na
operator|->
name|nm_krings_create
operator|=
name|netmap_vp_krings_create
expr_stmt|;
name|na
operator|->
name|nm_krings_delete
operator|=
name|netmap_vp_krings_delete
expr_stmt|;
name|na
operator|->
name|nm_dtor
operator|=
name|netmap_vp_dtor
expr_stmt|;
name|D
argument_list|(
literal|"nr_arg2 %d"
argument_list|,
name|nmr
operator|->
name|nr_arg2
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_mem
operator|=
name|nmd
condition|?
name|netmap_mem_get
argument_list|(
name|nmd
argument_list|)
else|:
name|netmap_mem_private_new
argument_list|(
name|na
operator|->
name|num_tx_rings
argument_list|,
name|na
operator|->
name|num_tx_desc
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|,
name|na
operator|->
name|num_rx_desc
argument_list|,
name|nmr
operator|->
name|nr_arg3
argument_list|,
name|npipes
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_mem
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|na
operator|->
name|nm_bdg_attach
operator|=
name|netmap_vp_bdg_attach
expr_stmt|;
comment|/* other nmd fields are set in the common routine */
name|error
operator|=
name|netmap_attach_common
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err
goto|;
operator|*
name|ret
operator|=
name|vpna
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
if|if
condition|(
name|na
operator|->
name|nm_mem
operator|!=
name|NULL
condition|)
name|netmap_mem_put
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
expr_stmt|;
name|nm_os_free
argument_list|(
name|vpna
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Bridge wrapper code (bwrap).  * This is used to connect a non-VALE-port netmap_adapter (hwna) to a  * VALE switch.  * The main task is to swap the meaning of tx and rx rings to match the  * expectations of the VALE switch code (see nm_bdg_flush).  *  * The bwrap works by interposing a netmap_bwrap_adapter between the  * rest of the system and the hwna. The netmap_bwrap_adapter looks like  * a netmap_vp_adapter to the rest the system, but, internally, it  * translates all callbacks to what the hwna expects.  *  * Note that we have to intercept callbacks coming from two sides:  *  *  - callbacks coming from the netmap module are intercepted by  *    passing around the netmap_bwrap_adapter instead of the hwna  *  *  - callbacks coming from outside of the netmap module only know  *    about the hwna. This, however, only happens in interrupt  *    handlers, where only the hwna->nm_notify callback is called.  *    What the bwrap does is to overwrite the hwna->nm_notify callback  *    with its own netmap_bwrap_intr_notify.  *    XXX This assumes that the hwna->nm_notify callback was the  *    standard netmap_notify(), as it is the case for nic adapters.  *    Any additional action performed by hwna->nm_notify will not be  *    performed by netmap_bwrap_intr_notify.  *  * Additionally, the bwrap can optionally attach the host rings pair  * of the wrapped adapter to a different port of the switch.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_bwrap_dtor
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hwna
init|=
name|bna
operator|->
name|hwna
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|bna
operator|->
name|up
operator|.
name|na_bdg
decl_stmt|,
modifier|*
name|bh
init|=
name|bna
operator|->
name|host
operator|.
name|na_bdg
decl_stmt|;
name|netmap_mem_put
argument_list|(
name|bna
operator|->
name|host
operator|.
name|up
operator|.
name|nm_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
condition|)
block|{
name|netmap_bdg_detach_common
argument_list|(
name|b
argument_list|,
name|bna
operator|->
name|up
operator|.
name|bdg_port
argument_list|,
operator|(
name|bh
condition|?
name|bna
operator|->
name|host
operator|.
name|bdg_port
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|ND
argument_list|(
literal|"na %p"
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|na
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
name|bna
operator|->
name|host
operator|.
name|up
operator|.
name|ifp
operator|=
name|NULL
expr_stmt|;
name|hwna
operator|->
name|na_private
operator|=
name|NULL
expr_stmt|;
name|hwna
operator|->
name|na_vp
operator|=
name|hwna
operator|->
name|na_hostvp
operator|=
name|NULL
expr_stmt|;
name|hwna
operator|->
name|na_flags
operator|&=
operator|~
name|NAF_BUSY
expr_stmt|;
name|netmap_adapter_put
argument_list|(
name|hwna
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Intr callback for NICs connected to a bridge.  * Simply ignore tx interrupts (maybe we could try to recover space ?)  * and pass received packets from nic to the bridge.  *  * XXX TODO check locking: this is called from the interrupt  * handler so we should make sure that the interface is not  * disconnected while passing down an interrupt.  *  * Note, no user process can access this NIC or the host stack.  * The only part of the ring that is significant are the slots,  * and head/cur/tail are set from the kring as needed  * (part as a receive ring, part as a transmit ring).  *  * callback that overwrites the hwna notify callback.  * Packets come from the outside or from the host stack and are put on an  * hwna rx ring.  * The bridge wrapper then sends the packets through the bridge.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_bwrap_intr_notify
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
name|na
operator|->
name|na_private
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|bkring
decl_stmt|;
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
init|=
operator|&
name|bna
operator|->
name|up
decl_stmt|;
name|u_int
name|ring_nr
init|=
name|kring
operator|->
name|ring_id
decl_stmt|;
name|int
name|ret
init|=
name|NM_IRQ_COMPLETED
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s %s 0x%x"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|bkring
operator|=
operator|&
name|vpna
operator|->
name|up
operator|.
name|tx_rings
index|[
name|ring_nr
index|]
expr_stmt|;
comment|/* make sure the ring is not disabled */
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|,
literal|0
comment|/* can't sleep */
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s head %d cur %d tail %d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|kring
operator|->
name|rhead
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
comment|/* simulate a user wakeup on the rx ring 	 * fetch packets that have arrived. 	 */
name|error
operator|=
name|kring
operator|->
name|nm_sync
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|put_out
goto|;
if|if
condition|(
name|kring
operator|->
name|nr_hwcur
operator|==
name|kring
operator|->
name|nr_hwtail
condition|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"how strange, interrupt with no packets on %s"
argument_list|,
name|na
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|put_out
goto|;
block|}
comment|/* new packets are kring->rcur to kring->nr_hwtail, and the bkring 	 * had hwcur == bkring->rhead. So advance bkring->rhead to kring->nr_hwtail 	 * to push all packets out. 	 */
name|bkring
operator|->
name|rhead
operator|=
name|bkring
operator|->
name|rcur
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
name|netmap_vp_txsync
argument_list|(
name|bkring
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* mark all buffers as released on this ring */
name|kring
operator|->
name|rhead
operator|=
name|kring
operator|->
name|rcur
operator|=
name|kring
operator|->
name|rtail
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
comment|/* another call to actually release the buffers */
name|error
operator|=
name|kring
operator|->
name|nm_sync
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The second rxsync may have further advanced hwtail. If this happens, 	 *  return NM_IRQ_RESCHED, otherwise just return NM_IRQ_COMPLETED. */
if|if
condition|(
name|kring
operator|->
name|rcur
operator|!=
name|kring
operator|->
name|nr_hwtail
condition|)
block|{
name|ret
operator|=
name|NM_IRQ_RESCHED
expr_stmt|;
block|}
name|put_out
label|:
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return
name|error
condition|?
name|error
else|:
name|ret
return|;
block|}
end_function

begin_comment
comment|/* nm_register callback for bwrap */
end_comment

begin_function
specifier|static
name|int
name|netmap_bwrap_reg
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hwna
init|=
name|bna
operator|->
name|hwna
decl_stmt|;
name|struct
name|netmap_vp_adapter
modifier|*
name|hostna
init|=
operator|&
name|bna
operator|->
name|host
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
name|ND
argument_list|(
literal|"%s %s"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|onoff
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
comment|/* netmap_do_regif has been called on the bwrap na. 		 * We need to pass the information about the 		 * memory allocator down to the hwna before 		 * putting it in netmap mode 		 */
name|hwna
operator|->
name|na_lut
operator|=
name|na
operator|->
name|na_lut
expr_stmt|;
if|if
condition|(
name|hostna
operator|->
name|na_bdg
condition|)
block|{
comment|/* if the host rings have been attached to switch, 			 * we need to copy the memory allocator information 			 * in the hostna also 			 */
name|hostna
operator|->
name|up
operator|.
name|na_lut
operator|=
name|na
operator|->
name|na_lut
expr_stmt|;
block|}
comment|/* cross-link the netmap rings 		 * The original number of rings comes from hwna, 		 * rx rings on one side equals tx rings on the other. 		 */
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
name|enum
name|txrx
name|r
init|=
name|nm_txrx_swap
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* swap NR_TX<-> NR_RX */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nma_get_nrings
argument_list|(
name|hwna
argument_list|,
name|r
argument_list|)
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|NMR
argument_list|(
name|hwna
argument_list|,
name|r
argument_list|)
index|[
name|i
index|]
operator|.
name|ring
operator|=
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
operator|.
name|ring
expr_stmt|;
block|}
block|}
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_HOST_RINGS
condition|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|hna
init|=
operator|&
name|hostna
operator|->
name|up
decl_stmt|;
comment|/* the hostna rings are the host rings of the bwrap. 			 * The corresponding krings must point back to the 			 * hostna 			 */
name|hna
operator|->
name|tx_rings
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|na
operator|->
name|num_tx_rings
index|]
expr_stmt|;
name|hna
operator|->
name|tx_rings
index|[
literal|0
index|]
operator|.
name|na
operator|=
name|hna
expr_stmt|;
name|hna
operator|->
name|rx_rings
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
expr_stmt|;
name|hna
operator|->
name|rx_rings
index|[
literal|0
index|]
operator|.
name|na
operator|=
name|hna
expr_stmt|;
block|}
block|}
comment|/* pass down the pending ring state information */
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|NMR
argument_list|(
name|hwna
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
operator|.
name|nr_pending_mode
operator|=
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
operator|.
name|nr_pending_mode
expr_stmt|;
block|}
comment|/* forward the request to the hwna */
name|error
operator|=
name|hwna
operator|->
name|nm_register
argument_list|(
name|hwna
argument_list|,
name|onoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* copy up the current ring state information */
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
operator|.
name|nr_mode
operator|=
name|NMR
argument_list|(
name|hwna
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
operator|.
name|nr_mode
expr_stmt|;
block|}
comment|/* impersonate a netmap_vp_adapter */
name|netmap_vp_reg
argument_list|(
name|na
argument_list|,
name|onoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostna
operator|->
name|na_bdg
condition|)
name|netmap_vp_reg
argument_list|(
operator|&
name|hostna
operator|->
name|up
argument_list|,
name|onoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
name|u_int
name|i
decl_stmt|;
comment|/* intercept the hwna nm_nofify callback on the hw rings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hwna
operator|->
name|num_rx_rings
condition|;
name|i
operator|++
control|)
block|{
name|hwna
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|save_notify
operator|=
name|hwna
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nm_notify
expr_stmt|;
name|hwna
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nm_notify
operator|=
name|netmap_bwrap_intr_notify
expr_stmt|;
block|}
name|i
operator|=
name|hwna
operator|->
name|num_rx_rings
expr_stmt|;
comment|/* for safety */
comment|/* save the host ring notify unconditionally */
name|hwna
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|save_notify
operator|=
name|hwna
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nm_notify
expr_stmt|;
if|if
condition|(
name|hostna
operator|->
name|na_bdg
condition|)
block|{
comment|/* also intercept the host ring notify */
name|hwna
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nm_notify
operator|=
name|netmap_bwrap_intr_notify
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
name|na
operator|->
name|na_flags
operator||=
name|NAF_NETMAP_ON
expr_stmt|;
block|}
else|else
block|{
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
name|na
operator|->
name|na_flags
operator|&=
operator|~
name|NAF_NETMAP_ON
expr_stmt|;
comment|/* reset all notify callbacks (including host ring) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|hwna
operator|->
name|num_rx_rings
condition|;
name|i
operator|++
control|)
block|{
name|hwna
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nm_notify
operator|=
name|hwna
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|save_notify
expr_stmt|;
name|hwna
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|save_notify
operator|=
name|NULL
expr_stmt|;
block|}
name|hwna
operator|->
name|na_lut
operator|.
name|lut
operator|=
name|NULL
expr_stmt|;
name|hwna
operator|->
name|na_lut
operator|.
name|objtotal
operator|=
literal|0
expr_stmt|;
name|hwna
operator|->
name|na_lut
operator|.
name|objsize
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* nm_config callback for bwrap */
end_comment

begin_function
specifier|static
name|int
name|netmap_bwrap_config
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
modifier|*
name|txr
parameter_list|,
name|u_int
modifier|*
name|txd
parameter_list|,
name|u_int
modifier|*
name|rxr
parameter_list|,
name|u_int
modifier|*
name|rxd
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hwna
init|=
name|bna
operator|->
name|hwna
decl_stmt|;
comment|/* forward the request */
name|netmap_update_config
argument_list|(
name|hwna
argument_list|)
expr_stmt|;
comment|/* swap the results */
operator|*
name|txr
operator|=
name|hwna
operator|->
name|num_rx_rings
expr_stmt|;
operator|*
name|txd
operator|=
name|hwna
operator|->
name|num_rx_desc
expr_stmt|;
operator|*
name|rxr
operator|=
name|hwna
operator|->
name|num_tx_rings
expr_stmt|;
operator|*
name|rxd
operator|=
name|hwna
operator|->
name|num_rx_desc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* nm_krings_create callback for bwrap */
end_comment

begin_function
specifier|static
name|int
name|netmap_bwrap_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hwna
init|=
name|bna
operator|->
name|hwna
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
name|ND
argument_list|(
literal|"%s"
argument_list|,
name|na
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* impersonate a netmap_vp_adapter */
name|error
operator|=
name|netmap_vp_krings_create
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* also create the hwna krings */
name|error
operator|=
name|hwna
operator|->
name|nm_krings_create
argument_list|(
name|hwna
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|err_del_vp_rings
goto|;
block|}
comment|/* get each ring slot number from the corresponding hwna ring */
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
name|enum
name|txrx
name|r
init|=
name|nm_txrx_swap
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* swap NR_TX<-> NR_RX */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nma_get_nrings
argument_list|(
name|hwna
argument_list|,
name|r
argument_list|)
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
operator|.
name|nkr_num_slots
operator|=
name|NMR
argument_list|(
name|hwna
argument_list|,
name|r
argument_list|)
index|[
name|i
index|]
operator|.
name|nkr_num_slots
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
name|err_del_vp_rings
label|:
name|netmap_vp_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_bwrap_krings_delete
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hwna
init|=
name|bna
operator|->
name|hwna
decl_stmt|;
name|ND
argument_list|(
literal|"%s"
argument_list|,
name|na
operator|->
name|name
argument_list|)
expr_stmt|;
name|hwna
operator|->
name|nm_krings_delete
argument_list|(
name|hwna
argument_list|)
expr_stmt|;
name|netmap_vp_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* notify method for the bridge-->hwna direction */
end_comment

begin_function
specifier|static
name|int
name|netmap_bwrap_notify
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
name|na
operator|->
name|na_private
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hwna
init|=
name|bna
operator|->
name|hwna
decl_stmt|;
name|u_int
name|ring_n
init|=
name|kring
operator|->
name|ring_id
decl_stmt|;
name|u_int
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|hw_kring
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ND
argument_list|(
literal|"%s: na %s hwna %s"
argument_list|,
operator|(
name|kring
condition|?
name|kring
operator|->
name|name
else|:
literal|"NULL!"
operator|)
argument_list|,
operator|(
name|na
condition|?
name|na
operator|->
name|name
else|:
literal|"NULL!"
operator|)
argument_list|,
operator|(
name|hwna
condition|?
name|hwna
operator|->
name|name
else|:
literal|"NULL!"
operator|)
argument_list|)
expr_stmt|;
name|hw_kring
operator|=
operator|&
name|hwna
operator|->
name|tx_rings
index|[
name|ring_n
index|]
expr_stmt|;
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|hw_kring
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
comment|/* first step: simulate a user wakeup on the rx ring */
name|netmap_vp_rxsync
argument_list|(
name|kring
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"%s[%d] PRE rx(c%3d t%3d l%3d) ring(h%3d c%3d t%3d) tx(c%3d ht%3d t%3d)"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|ring_n
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|kring
operator|->
name|nkr_hwlease
argument_list|,
name|ring
operator|->
name|head
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|hw_kring
operator|->
name|nr_hwcur
argument_list|,
name|hw_kring
operator|->
name|nr_hwtail
argument_list|,
name|hw_ring
operator|->
name|rtail
argument_list|)
expr_stmt|;
comment|/* second step: the new packets are sent on the tx ring 	 * (which is actually the same ring) 	 */
name|hw_kring
operator|->
name|rhead
operator|=
name|hw_kring
operator|->
name|rcur
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
name|error
operator|=
name|hw_kring
operator|->
name|nm_sync
argument_list|(
name|hw_kring
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|put_out
goto|;
comment|/* third step: now we are back the rx ring */
comment|/* claim ownership on all hw owned bufs */
name|kring
operator|->
name|rhead
operator|=
name|kring
operator|->
name|rcur
operator|=
name|nm_next
argument_list|(
name|hw_kring
operator|->
name|nr_hwtail
argument_list|,
name|lim
argument_list|)
expr_stmt|;
comment|/* skip past reserved slot */
comment|/* fourth step: the user goes to sleep again, causing another rxsync */
name|netmap_vp_rxsync
argument_list|(
name|kring
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"%s[%d] PST rx(c%3d t%3d l%3d) ring(h%3d c%3d t%3d) tx(c%3d ht%3d t%3d)"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|ring_n
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|kring
operator|->
name|nkr_hwlease
argument_list|,
name|ring
operator|->
name|head
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|hw_kring
operator|->
name|nr_hwcur
argument_list|,
name|hw_kring
operator|->
name|nr_hwtail
argument_list|,
name|hw_kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
name|put_out
label|:
name|nm_kr_put
argument_list|(
name|hw_kring
argument_list|)
expr_stmt|;
return|return
name|error
condition|?
name|error
else|:
name|NM_IRQ_COMPLETED
return|;
block|}
end_function

begin_comment
comment|/* nm_bdg_ctl callback for the bwrap.  * Called on bridge-attach and detach, as an effect of vale-ctl -[ahd].  * On attach, it needs to provide a fake netmap_priv_d structure and  * perform a netmap_do_regif() on the bwrap. This will put both the  * bwrap and the hwna in netmap mode, with the netmap rings shared  * and cross linked. Moroever, it will start intercepting interrupts  * directed to hwna.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_bwrap_bdg_ctl
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|int
name|attach
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|npriv
decl_stmt|;
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|attach
condition|)
block|{
if|if
condition|(
name|NETMAP_OWNED_BY_ANY
argument_list|(
name|na
argument_list|)
condition|)
block|{
return|return
name|EBUSY
return|;
block|}
if|if
condition|(
name|bna
operator|->
name|na_kpriv
condition|)
block|{
comment|/* nothing to do */
return|return
literal|0
return|;
block|}
name|npriv
operator|=
name|netmap_priv_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|npriv
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|npriv
operator|->
name|np_ifp
operator|=
name|na
operator|->
name|ifp
expr_stmt|;
comment|/* let the priv destructor release the ref */
name|error
operator|=
name|netmap_do_regif
argument_list|(
name|npriv
argument_list|,
name|na
argument_list|,
literal|0
argument_list|,
name|NR_REG_NIC_SW
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|netmap_priv_delete
argument_list|(
name|npriv
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|bna
operator|->
name|na_kpriv
operator|=
name|npriv
expr_stmt|;
name|na
operator|->
name|na_flags
operator||=
name|NAF_BUSY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
comment|/* not registered */
return|return
name|EINVAL
return|;
name|netmap_priv_delete
argument_list|(
name|bna
operator|->
name|na_kpriv
argument_list|)
expr_stmt|;
name|bna
operator|->
name|na_kpriv
operator|=
name|NULL
expr_stmt|;
name|na
operator|->
name|na_flags
operator|&=
operator|~
name|NAF_BUSY
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* attach a bridge wrapper to the 'real' device */
end_comment

begin_function
name|int
name|netmap_bwrap_attach
parameter_list|(
specifier|const
name|char
modifier|*
name|nr_name
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|hwna
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NULL
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hostna
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
comment|/* make sure the NIC is not already in use */
if|if
condition|(
name|NETMAP_OWNED_BY_ANY
argument_list|(
name|hwna
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"NIC %s busy, cannot attach to bridge"
argument_list|,
name|hwna
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|bna
operator|=
name|nm_os_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bna
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bna
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
name|na
operator|=
operator|&
name|bna
operator|->
name|up
operator|.
name|up
expr_stmt|;
comment|/* make bwrap ifp point to the real ifp */
name|na
operator|->
name|ifp
operator|=
name|hwna
operator|->
name|ifp
expr_stmt|;
name|if_ref
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_private
operator|=
name|bna
expr_stmt|;
name|strncpy
argument_list|(
name|na
operator|->
name|name
argument_list|,
name|nr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|na
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill the ring data for the bwrap adapter with rx/tx meanings 	 * swapped. The real cross-linking will be done during register, 	 * when all the krings will have been created. 	 */
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
name|enum
name|txrx
name|r
init|=
name|nm_txrx_swap
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* swap NR_TX<-> NR_RX */
name|nma_set_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|,
name|nma_get_nrings
argument_list|(
name|hwna
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|nma_set_ndesc
argument_list|(
name|na
argument_list|,
name|t
argument_list|,
name|nma_get_ndesc
argument_list|(
name|hwna
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|na
operator|->
name|nm_dtor
operator|=
name|netmap_bwrap_dtor
expr_stmt|;
name|na
operator|->
name|nm_register
operator|=
name|netmap_bwrap_reg
expr_stmt|;
comment|// na->nm_txsync = netmap_bwrap_txsync;
comment|// na->nm_rxsync = netmap_bwrap_rxsync;
name|na
operator|->
name|nm_config
operator|=
name|netmap_bwrap_config
expr_stmt|;
name|na
operator|->
name|nm_krings_create
operator|=
name|netmap_bwrap_krings_create
expr_stmt|;
name|na
operator|->
name|nm_krings_delete
operator|=
name|netmap_bwrap_krings_delete
expr_stmt|;
name|na
operator|->
name|nm_notify
operator|=
name|netmap_bwrap_notify
expr_stmt|;
name|na
operator|->
name|nm_bdg_ctl
operator|=
name|netmap_bwrap_bdg_ctl
expr_stmt|;
name|na
operator|->
name|pdev
operator|=
name|hwna
operator|->
name|pdev
expr_stmt|;
name|na
operator|->
name|nm_mem
operator|=
name|netmap_mem_get
argument_list|(
name|hwna
operator|->
name|nm_mem
argument_list|)
expr_stmt|;
name|na
operator|->
name|virt_hdr_len
operator|=
name|hwna
operator|->
name|virt_hdr_len
expr_stmt|;
name|bna
operator|->
name|up
operator|.
name|retry
operator|=
literal|1
expr_stmt|;
comment|/* XXX maybe this should depend on the hwna */
name|bna
operator|->
name|hwna
operator|=
name|hwna
expr_stmt|;
name|netmap_adapter_get
argument_list|(
name|hwna
argument_list|)
expr_stmt|;
name|hwna
operator|->
name|na_private
operator|=
name|bna
expr_stmt|;
comment|/* weak reference */
name|hwna
operator|->
name|na_vp
operator|=
operator|&
name|bna
operator|->
name|up
expr_stmt|;
if|if
condition|(
name|hwna
operator|->
name|na_flags
operator|&
name|NAF_HOST_RINGS
condition|)
block|{
if|if
condition|(
name|hwna
operator|->
name|na_flags
operator|&
name|NAF_SW_ONLY
condition|)
name|na
operator|->
name|na_flags
operator||=
name|NAF_SW_ONLY
expr_stmt|;
name|na
operator|->
name|na_flags
operator||=
name|NAF_HOST_RINGS
expr_stmt|;
name|hostna
operator|=
operator|&
name|bna
operator|->
name|host
operator|.
name|up
expr_stmt|;
name|snprintf
argument_list|(
name|hostna
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|hostna
operator|->
name|name
argument_list|)
argument_list|,
literal|"%s^"
argument_list|,
name|nr_name
argument_list|)
expr_stmt|;
name|hostna
operator|->
name|ifp
operator|=
name|hwna
operator|->
name|ifp
expr_stmt|;
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
name|enum
name|txrx
name|r
init|=
name|nm_txrx_swap
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|nma_set_nrings
argument_list|(
name|hostna
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nma_set_ndesc
argument_list|(
name|hostna
argument_list|,
name|t
argument_list|,
name|nma_get_ndesc
argument_list|(
name|hwna
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// hostna->nm_txsync = netmap_bwrap_host_txsync;
comment|// hostna->nm_rxsync = netmap_bwrap_host_rxsync;
name|hostna
operator|->
name|nm_notify
operator|=
name|netmap_bwrap_notify
expr_stmt|;
name|hostna
operator|->
name|nm_mem
operator|=
name|netmap_mem_get
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
expr_stmt|;
name|hostna
operator|->
name|na_private
operator|=
name|bna
expr_stmt|;
name|hostna
operator|->
name|na_vp
operator|=
operator|&
name|bna
operator|->
name|up
expr_stmt|;
name|na
operator|->
name|na_hostvp
operator|=
name|hwna
operator|->
name|na_hostvp
operator|=
name|hostna
operator|->
name|na_hostvp
operator|=
operator|&
name|bna
operator|->
name|host
expr_stmt|;
name|hostna
operator|->
name|na_flags
operator|=
name|NAF_BUSY
expr_stmt|;
comment|/* prevent NIOCREGIF */
block|}
name|ND
argument_list|(
literal|"%s<->%s txr %d txd %d rxr %d rxd %d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|na
operator|->
name|num_tx_rings
argument_list|,
name|na
operator|->
name|num_tx_desc
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|,
name|na
operator|->
name|num_rx_desc
argument_list|)
expr_stmt|;
name|error
operator|=
name|netmap_attach_common
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|err_free
goto|;
block|}
name|hwna
operator|->
name|na_flags
operator||=
name|NAF_BUSY
expr_stmt|;
return|return
literal|0
return|;
name|err_free
label|:
name|hwna
operator|->
name|na_vp
operator|=
name|hwna
operator|->
name|na_hostvp
operator|=
name|NULL
expr_stmt|;
name|netmap_adapter_put
argument_list|(
name|hwna
argument_list|)
expr_stmt|;
name|nm_os_free
argument_list|(
name|bna
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|struct
name|nm_bridge
modifier|*
name|netmap_init_bridges2
parameter_list|(
name|u_int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|nm_os_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nm_bridge
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|BDG_RWINIT
argument_list|(
operator|&
name|b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
name|void
name|netmap_uninit_bridges2
parameter_list|(
name|struct
name|nm_bridge
modifier|*
name|b
parameter_list|,
name|u_int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|BDG_RWDESTROY
argument_list|(
operator|&
name|b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nm_os_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|netmap_init_bridges
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_NET_NS
return|return
name|netmap_bns_register
argument_list|()
return|;
else|#
directive|else
name|nm_bridges
operator|=
name|netmap_init_bridges2
argument_list|(
name|NM_BRIDGES
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_bridges
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|netmap_uninit_bridges
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_NET_NS
name|netmap_bns_unregister
argument_list|()
expr_stmt|;
else|#
directive|else
name|netmap_uninit_bridges2
argument_list|(
name|nm_bridges
argument_list|,
name|NM_BRIDGES
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_VALE */
end_comment

end_unit

