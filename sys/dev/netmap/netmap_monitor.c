begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2014-2016 Giuseppe Lettieri  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  *  * Monitors  *  * netmap monitors can be used to do monitoring of network traffic  * on another adapter, when the latter adapter is working in netmap mode.  *  * Monitors offer to userspace the same interface as any other netmap port,  * with as many pairs of netmap rings as the monitored adapter.  * However, only the rx rings are actually used. Each monitor rx ring receives  * the traffic transiting on both the tx and rx corresponding rings in the  * monitored adapter. During registration, the user can choose if she wants  * to intercept tx only, rx only, or both tx and rx traffic.  *  * If the monitor is not able to cope with the stream of frames, excess traffic  * will be dropped.  *  * If the monitored adapter leaves netmap mode, the monitor has to be restarted.  *  * Monitors can be either zero-copy or copy-based.  *  * Copy monitors see the frames before they are consumed:  *  *  - For tx traffic, this is when the application sends them, before they are  *    passed down to the adapter.  *  *  - For rx traffic, this is when they are received by the adapter, before  *    they are sent up to the application, if any (note that, if no  *    application is reading from a monitored ring, the ring will eventually  *    fill up and traffic will stop).  *  * Zero-copy monitors only see the frames after they have been consumed:  *  *  - For tx traffic, this is after the slots containing the frames have been  *    marked as free. Note that this may happen at a considerably delay after  *    frame transmission, since freeing of slots is often done lazily.  *  *  - For rx traffic, this is after the consumer on the monitored adapter  *    has released them. In most cases, the consumer is a userspace  *    application which may have modified the frame contents.  *  * Several copy monitors may be active on any ring.  Zero-copy monitors,  * instead, need exclusive access to each of the monitored rings.  This may  * change in the future, if we implement zero-copy monitor chaining.  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* defines used in kernel.h */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* types used in module initialization */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* */
end_comment

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|linux
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"bsd_glue.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_elif

begin_warning
warning|#
directive|warning
warning|OSX support is only partial
end_warning

begin_include
include|#
directive|include
file|"osx_glue.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"win_glue.h"
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|Unsupported platform
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unsupported */
end_comment

begin_comment
comment|/*  * common headers  */
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_mem2.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_MONITOR
end_ifdef

begin_define
define|#
directive|define
name|NM_MONITOR_MAXSLOTS
value|4096
end_define

begin_comment
comment|/*  ********************************************************************  * functions common to both kind of monitors  ********************************************************************  */
end_comment

begin_comment
comment|/* nm_sync callback for the monitor's own tx rings.  * This makes no sense and always returns error  */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|RD
argument_list|(
literal|1
argument_list|,
literal|"%s %x"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
end_function

begin_comment
comment|/* nm_sync callback for the monitor's own rx rings.  * Note that the lock in netmap_zmon_parent_sync only protects  * writers among themselves. Synchronization between writers  * (i.e., netmap_zmon_parent_txsync and netmap_zmon_parent_rxsync)  * and readers (i.e., netmap_zmon_rxsync) relies on memory barriers.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ND
argument_list|(
literal|"%s %x"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|kring
operator|->
name|rcur
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* nm_krings_create callbacks for monitors.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|int
name|error
init|=
name|netmap_krings_create
argument_list|(
name|na
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* override the host rings callbacks */
name|na
operator|->
name|tx_rings
index|[
name|na
operator|->
name|num_tx_rings
index|]
operator|.
name|nm_sync
operator|=
name|netmap_monitor_txsync
expr_stmt|;
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
operator|.
name|nm_sync
operator|=
name|netmap_monitor_rxsync
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* nm_krings_delete callback for monitors */
end_comment

begin_function
specifier|static
name|void
name|netmap_monitor_krings_delete
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|netmap_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|nm_txrx2flag
parameter_list|(
name|enum
name|txrx
name|t
parameter_list|)
block|{
return|return
operator|(
name|t
operator|==
name|NR_RX
condition|?
name|NR_MONITOR_RX
else|:
name|NR_MONITOR_TX
operator|)
return|;
block|}
end_function

begin_comment
comment|/* allocate the monitors array in the monitored kring */
end_comment

begin_function
specifier|static
name|int
name|nm_monitor_alloc
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|u_int
name|n
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
modifier|*
name|nm
decl_stmt|;
if|if
condition|(
name|n
operator|<=
name|kring
operator|->
name|max_monitors
condition|)
comment|/* we already have more entries that requested */
return|return
literal|0
return|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_kring
operator|*
argument_list|)
operator|*
name|n
expr_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
name|nm
operator|=
name|realloc
argument_list|(
name|kring
operator|->
name|monitors
argument_list|,
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
else|#
directive|else
name|nm
operator|=
name|realloc
argument_list|(
name|kring
operator|->
name|monitors
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_kring
operator|*
argument_list|)
operator|*
name|kring
operator|->
name|max_monitors
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nm
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|kring
operator|->
name|monitors
operator|=
name|nm
expr_stmt|;
name|kring
operator|->
name|max_monitors
operator|=
name|n
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* deallocate the parent array in the parent adapter */
end_comment

begin_function
specifier|static
name|void
name|nm_monitor_dealloc
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
if|if
condition|(
name|kring
operator|->
name|monitors
condition|)
block|{
if|if
condition|(
name|kring
operator|->
name|n_monitors
operator|>
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"freeing not empty monitor array for %s (%d dangling monitors)!"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|n_monitors
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|kring
operator|->
name|monitors
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|kring
operator|->
name|monitors
operator|=
name|NULL
expr_stmt|;
name|kring
operator|->
name|max_monitors
operator|=
literal|0
expr_stmt|;
name|kring
operator|->
name|n_monitors
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * monitors work by replacing the nm_sync() and possibly the  * nm_notify() callbacks in the monitored rings.  */
end_comment

begin_function_decl
specifier|static
name|int
name|netmap_zmon_parent_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|netmap_zmon_parent_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|netmap_monitor_parent_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|netmap_monitor_parent_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|netmap_monitor_parent_notify
parameter_list|(
name|struct
name|netmap_kring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* add the monitor mkring to the list of monitors of kring.  * If this is the first monitor, intercept the callbacks  */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_add
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|mkring
parameter_list|,
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|zcopy
parameter_list|)
block|{
name|int
name|error
init|=
name|NM_IRQ_COMPLETED
decl_stmt|;
comment|/* sinchronize with concurrently running nm_sync()s */
name|nm_kr_stop
argument_list|(
name|kring
argument_list|,
name|NM_KR_LOCKED
argument_list|)
expr_stmt|;
comment|/* make sure the monitor array exists and is big enough */
name|error
operator|=
name|nm_monitor_alloc
argument_list|(
name|kring
argument_list|,
name|kring
operator|->
name|n_monitors
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|kring
operator|->
name|monitors
index|[
name|kring
operator|->
name|n_monitors
index|]
operator|=
name|mkring
expr_stmt|;
name|mkring
operator|->
name|mon_pos
operator|=
name|kring
operator|->
name|n_monitors
expr_stmt|;
name|kring
operator|->
name|n_monitors
operator|++
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|n_monitors
operator|==
literal|1
condition|)
block|{
comment|/* this is the first monitor, intercept callbacks */
name|ND
argument_list|(
literal|"%s: intercept callbacks on %s"
argument_list|,
name|mkring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|name
argument_list|)
expr_stmt|;
name|kring
operator|->
name|mon_sync
operator|=
name|kring
operator|->
name|nm_sync
expr_stmt|;
comment|/* zcopy monitors do not override nm_notify(), but 		 * we save the original one regardless, so that 		 * netmap_monitor_del() does not need to know the 		 * monitor type 		 */
name|kring
operator|->
name|mon_notify
operator|=
name|kring
operator|->
name|nm_notify
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|tx
operator|==
name|NR_TX
condition|)
block|{
name|kring
operator|->
name|nm_sync
operator|=
operator|(
name|zcopy
condition|?
name|netmap_zmon_parent_txsync
else|:
name|netmap_monitor_parent_txsync
operator|)
expr_stmt|;
block|}
else|else
block|{
name|kring
operator|->
name|nm_sync
operator|=
operator|(
name|zcopy
condition|?
name|netmap_zmon_parent_rxsync
else|:
name|netmap_monitor_parent_rxsync
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|zcopy
condition|)
block|{
comment|/* also intercept notify */
name|kring
operator|->
name|nm_notify
operator|=
name|netmap_monitor_parent_notify
expr_stmt|;
name|kring
operator|->
name|mon_tail
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
block|}
block|}
block|}
name|out
label|:
name|nm_kr_start
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* remove the monitor mkring from the list of monitors of kring.  * If this is the last monitor, restore the original callbacks  */
end_comment

begin_function
specifier|static
name|void
name|netmap_monitor_del
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|mkring
parameter_list|,
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
comment|/* sinchronize with concurrently running nm_sync()s */
name|nm_kr_stop
argument_list|(
name|kring
argument_list|,
name|NM_KR_LOCKED
argument_list|)
expr_stmt|;
name|kring
operator|->
name|n_monitors
operator|--
expr_stmt|;
if|if
condition|(
name|mkring
operator|->
name|mon_pos
operator|!=
name|kring
operator|->
name|n_monitors
condition|)
block|{
name|kring
operator|->
name|monitors
index|[
name|mkring
operator|->
name|mon_pos
index|]
operator|=
name|kring
operator|->
name|monitors
index|[
name|kring
operator|->
name|n_monitors
index|]
expr_stmt|;
name|kring
operator|->
name|monitors
index|[
name|mkring
operator|->
name|mon_pos
index|]
operator|->
name|mon_pos
operator|=
name|mkring
operator|->
name|mon_pos
expr_stmt|;
block|}
name|kring
operator|->
name|monitors
index|[
name|kring
operator|->
name|n_monitors
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|n_monitors
operator|==
literal|0
condition|)
block|{
comment|/* this was the last monitor, restore callbacks  and delete monitor array */
name|ND
argument_list|(
literal|"%s: restoring sync on %s: %p"
argument_list|,
name|mkring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|mon_sync
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nm_sync
operator|=
name|kring
operator|->
name|mon_sync
expr_stmt|;
name|kring
operator|->
name|mon_sync
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|tx
operator|==
name|NR_RX
condition|)
block|{
name|ND
argument_list|(
literal|"%s: restoring notify on %s: %p"
argument_list|,
name|mkring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|mon_notify
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nm_notify
operator|=
name|kring
operator|->
name|mon_notify
expr_stmt|;
name|kring
operator|->
name|mon_notify
operator|=
name|NULL
expr_stmt|;
block|}
name|nm_monitor_dealloc
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
name|nm_kr_start
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called when the monitored adapter leaves netmap mode  * (see netmap_do_unregif).  * We need to notify the monitors that the monitored rings are gone.  * We do this by setting their mna->priv.np_na to NULL.  * Note that the rings are already stopped when this happens, so  * no monitor ring callback can be active.  */
end_comment

begin_function
name|void
name|netmap_monitor_stop
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|enum
name|txrx
name|t
decl_stmt|;
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
decl_stmt|;
name|u_int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|kring
operator|->
name|n_monitors
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|mkring
init|=
name|kring
operator|->
name|monitors
index|[
name|j
index|]
decl_stmt|;
name|struct
name|netmap_monitor_adapter
modifier|*
name|mna
init|=
operator|(
expr|struct
name|netmap_monitor_adapter
operator|*
operator|)
name|mkring
operator|->
name|na
decl_stmt|;
comment|/* forget about this adapter */
name|netmap_adapter_put
argument_list|(
name|mna
operator|->
name|priv
operator|.
name|np_na
argument_list|)
expr_stmt|;
name|mna
operator|->
name|priv
operator|.
name|np_na
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* common functions for the nm_register() callbacks of both kind of  * monitors.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_reg_common
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|,
name|int
name|zmon
parameter_list|)
block|{
name|struct
name|netmap_monitor_adapter
modifier|*
name|mna
init|=
operator|(
expr|struct
name|netmap_monitor_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
operator|&
name|mna
operator|->
name|priv
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|pna
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|,
modifier|*
name|mkring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
name|ND
argument_list|(
literal|"%p: onoff %d"
argument_list|,
name|na
argument_list|,
name|onoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
if|if
condition|(
name|pna
operator|==
name|NULL
condition|)
block|{
comment|/* parent left netmap mode, fatal */
name|D
argument_list|(
literal|"%s: internal error"
argument_list|,
name|na
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
if|if
condition|(
name|mna
operator|->
name|flags
operator|&
name|nm_txrx2flag
argument_list|(
name|t
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
init|;
name|i
operator|<
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|NMR
argument_list|(
name|pna
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
name|mkring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nm_kring_pending_on
argument_list|(
name|mkring
argument_list|)
condition|)
block|{
name|netmap_monitor_add
argument_list|(
name|mkring
argument_list|,
name|kring
argument_list|,
name|zmon
argument_list|)
expr_stmt|;
name|mkring
operator|->
name|nr_mode
operator|=
name|NKR_NETMAP_ON
expr_stmt|;
block|}
block|}
block|}
block|}
name|na
operator|->
name|na_flags
operator||=
name|NAF_NETMAP_ON
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
name|na
operator|->
name|na_flags
operator|&=
operator|~
name|NAF_NETMAP_ON
expr_stmt|;
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
if|if
condition|(
name|mna
operator|->
name|flags
operator|&
name|nm_txrx2flag
argument_list|(
name|t
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
init|;
name|i
operator|<
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
condition|;
name|i
operator|++
control|)
block|{
name|mkring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nm_kring_pending_off
argument_list|(
name|mkring
argument_list|)
condition|)
block|{
name|mkring
operator|->
name|nr_mode
operator|=
name|NKR_NETMAP_OFF
expr_stmt|;
comment|/* we cannot access the parent krings if the parent 						 * has left netmap mode. This is signaled by a NULL 						 * pna pointer 						 */
if|if
condition|(
name|pna
condition|)
block|{
name|kring
operator|=
operator|&
name|NMR
argument_list|(
name|pna
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
name|netmap_monitor_del
argument_list|(
name|mkring
argument_list|,
name|kring
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  ****************************************************************  * functions specific for zero-copy monitors  ****************************************************************  */
end_comment

begin_comment
comment|/*  * Common function for both zero-copy tx and rx nm_sync()  * callbacks  */
end_comment

begin_function
specifier|static
name|int
name|netmap_zmon_parent_sync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|,
name|enum
name|txrx
name|tx
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|mkring
init|=
name|kring
operator|->
name|monitors
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|,
modifier|*
name|mring
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|rel_slots
decl_stmt|,
name|free_slots
decl_stmt|,
name|busy
decl_stmt|,
name|sent
init|=
literal|0
decl_stmt|;
name|u_int
name|beg
decl_stmt|,
name|end
decl_stmt|,
name|i
decl_stmt|;
name|u_int
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|,
name|mlim
decl_stmt|;
comment|// = mkring->nkr_num_slots - 1;
if|if
condition|(
name|mkring
operator|==
name|NULL
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"NULL monitor on %s"
argument_list|,
name|kring
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mring
operator|=
name|mkring
operator|->
name|ring
expr_stmt|;
name|mlim
operator|=
name|mkring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
comment|/* get the relased slots (rel_slots) */
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
block|{
name|beg
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
name|error
operator|=
name|kring
operator|->
name|mon_sync
argument_list|(
name|kring
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|end
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
block|}
else|else
block|{
comment|/* NR_RX */
name|beg
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|end
operator|=
name|kring
operator|->
name|rhead
expr_stmt|;
block|}
name|rel_slots
operator|=
name|end
operator|-
name|beg
expr_stmt|;
if|if
condition|(
name|rel_slots
operator|<
literal|0
condition|)
name|rel_slots
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
if|if
condition|(
operator|!
name|rel_slots
condition|)
block|{
comment|/* no released slots, but we still need 		 * to call rxsync if this is a rx ring 		 */
goto|goto
name|out_rxsync
goto|;
block|}
comment|/* we need to lock the monitor receive ring, since it 	 * is the target of bot tx and rx traffic from the monitored 	 * adapter 	 */
name|mtx_lock
argument_list|(
operator|&
name|mkring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
comment|/* get the free slots available on the monitor ring */
name|i
operator|=
name|mkring
operator|->
name|nr_hwtail
expr_stmt|;
name|busy
operator|=
name|i
operator|-
name|mkring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|busy
operator|<
literal|0
condition|)
name|busy
operator|+=
name|mkring
operator|->
name|nkr_num_slots
expr_stmt|;
name|free_slots
operator|=
name|mlim
operator|-
name|busy
expr_stmt|;
if|if
condition|(
operator|!
name|free_slots
condition|)
goto|goto
name|out
goto|;
comment|/* swap min(free_slots, rel_slots) slots */
if|if
condition|(
name|free_slots
operator|<
name|rel_slots
condition|)
block|{
name|beg
operator|+=
operator|(
name|rel_slots
operator|-
name|free_slots
operator|)
expr_stmt|;
if|if
condition|(
name|beg
operator|>=
name|kring
operator|->
name|nkr_num_slots
condition|)
name|beg
operator|-=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|rel_slots
operator|=
name|free_slots
expr_stmt|;
block|}
name|sent
operator|=
name|rel_slots
expr_stmt|;
for|for
control|(
init|;
name|rel_slots
condition|;
name|rel_slots
operator|--
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|s
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|beg
index|]
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|ms
init|=
operator|&
name|mring
operator|->
name|slot
index|[
name|i
index|]
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ms
operator|->
name|buf_idx
expr_stmt|;
name|ms
operator|->
name|buf_idx
operator|=
name|s
operator|->
name|buf_idx
expr_stmt|;
name|s
operator|->
name|buf_idx
operator|=
name|tmp
expr_stmt|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"beg %d buf_idx %d"
argument_list|,
name|beg
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|ms
operator|->
name|len
expr_stmt|;
name|ms
operator|->
name|len
operator|=
name|s
operator|->
name|len
expr_stmt|;
name|s
operator|->
name|len
operator|=
name|tmp
expr_stmt|;
name|s
operator|->
name|flags
operator||=
name|NS_BUF_CHANGED
expr_stmt|;
name|beg
operator|=
name|nm_next
argument_list|(
name|beg
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|i
operator|=
name|nm_next
argument_list|(
name|i
argument_list|,
name|mlim
argument_list|)
expr_stmt|;
block|}
name|mb
argument_list|()
expr_stmt|;
name|mkring
operator|->
name|nr_hwtail
operator|=
name|i
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|mkring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
condition|)
block|{
comment|/* notify the new frames to the monitor */
name|mkring
operator|->
name|nm_notify
argument_list|(
name|mkring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|out_rxsync
label|:
if|if
condition|(
name|tx
operator|==
name|NR_RX
condition|)
name|error
operator|=
name|kring
operator|->
name|mon_sync
argument_list|(
name|kring
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* callback used to replace the nm_sync callback in the monitored tx rings */
end_comment

begin_function
specifier|static
name|int
name|netmap_zmon_parent_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ND
argument_list|(
literal|"%s %x"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|netmap_zmon_parent_sync
argument_list|(
name|kring
argument_list|,
name|flags
argument_list|,
name|NR_TX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* callback used to replace the nm_sync callback in the monitored rx rings */
end_comment

begin_function
specifier|static
name|int
name|netmap_zmon_parent_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ND
argument_list|(
literal|"%s %x"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|netmap_zmon_parent_sync
argument_list|(
name|kring
argument_list|,
name|flags
argument_list|,
name|NR_RX
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_zmon_reg
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
return|return
name|netmap_monitor_reg_common
argument_list|(
name|na
argument_list|,
name|onoff
argument_list|,
literal|1
comment|/* zcopy */
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* nm_dtor callback for monitors */
end_comment

begin_function
specifier|static
name|void
name|netmap_zmon_dtor
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_monitor_adapter
modifier|*
name|mna
init|=
operator|(
expr|struct
name|netmap_monitor_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
operator|&
name|mna
operator|->
name|priv
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|pna
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|netmap_adapter_put
argument_list|(
name|pna
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  ****************************************************************  * functions specific for copy monitors  ****************************************************************  */
end_comment

begin_function
specifier|static
name|void
name|netmap_monitor_parent_sync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|u_int
name|first_new
parameter_list|,
name|int
name|new_slots
parameter_list|)
block|{
name|u_int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|kring
operator|->
name|n_monitors
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|mkring
init|=
name|kring
operator|->
name|monitors
index|[
name|j
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|mlim
decl_stmt|,
name|beg
decl_stmt|;
name|int
name|free_slots
decl_stmt|,
name|busy
decl_stmt|,
name|sent
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|;
name|u_int
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|,
modifier|*
name|mring
init|=
name|mkring
operator|->
name|ring
decl_stmt|;
name|u_int
name|max_len
init|=
name|NETMAP_BUF_SIZE
argument_list|(
name|mkring
operator|->
name|na
argument_list|)
decl_stmt|;
name|mlim
operator|=
name|mkring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
comment|/* we need to lock the monitor receive ring, since it 		 * is the target of bot tx and rx traffic from the monitored 		 * adapter 		 */
name|mtx_lock
argument_list|(
operator|&
name|mkring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
comment|/* get the free slots available on the monitor ring */
name|i
operator|=
name|mkring
operator|->
name|nr_hwtail
expr_stmt|;
name|busy
operator|=
name|i
operator|-
name|mkring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|busy
operator|<
literal|0
condition|)
name|busy
operator|+=
name|mkring
operator|->
name|nkr_num_slots
expr_stmt|;
name|free_slots
operator|=
name|mlim
operator|-
name|busy
expr_stmt|;
if|if
condition|(
operator|!
name|free_slots
condition|)
goto|goto
name|out
goto|;
comment|/* copy min(free_slots, new_slots) slots */
name|m
operator|=
name|new_slots
expr_stmt|;
name|beg
operator|=
name|first_new
expr_stmt|;
if|if
condition|(
name|free_slots
operator|<
name|m
condition|)
block|{
name|beg
operator|+=
operator|(
name|m
operator|-
name|free_slots
operator|)
expr_stmt|;
if|if
condition|(
name|beg
operator|>=
name|kring
operator|->
name|nkr_num_slots
condition|)
name|beg
operator|-=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|m
operator|=
name|free_slots
expr_stmt|;
block|}
for|for
control|(
init|;
name|m
condition|;
name|m
operator|--
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|s
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|beg
index|]
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|ms
init|=
operator|&
name|mring
operator|->
name|slot
index|[
name|i
index|]
decl_stmt|;
name|u_int
name|copy_len
init|=
name|s
operator|->
name|len
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|NMB
argument_list|(
name|kring
operator|->
name|na
argument_list|,
name|s
argument_list|)
decl_stmt|,
modifier|*
name|dst
init|=
name|NMB
argument_list|(
name|mkring
operator|->
name|na
argument_list|,
name|ms
argument_list|)
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|copy_len
operator|>
name|max_len
argument_list|)
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"%s->%s: truncating %d to %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|mkring
operator|->
name|name
argument_list|,
name|copy_len
argument_list|,
name|max_len
argument_list|)
expr_stmt|;
name|copy_len
operator|=
name|max_len
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
name|ms
operator|->
name|len
operator|=
name|copy_len
expr_stmt|;
name|sent
operator|++
expr_stmt|;
name|beg
operator|=
name|nm_next
argument_list|(
name|beg
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|i
operator|=
name|nm_next
argument_list|(
name|i
argument_list|,
name|mlim
argument_list|)
expr_stmt|;
block|}
name|mb
argument_list|()
expr_stmt|;
name|mkring
operator|->
name|nr_hwtail
operator|=
name|i
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|mkring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
condition|)
block|{
comment|/* notify the new frames to the monitor */
name|mkring
operator|->
name|nm_notify
argument_list|(
name|mkring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* callback used to replace the nm_sync callback in the monitored tx rings */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_parent_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|u_int
name|first_new
decl_stmt|;
name|int
name|new_slots
decl_stmt|;
comment|/* get the new slots */
name|first_new
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|new_slots
operator|=
name|kring
operator|->
name|rhead
operator|-
name|first_new
expr_stmt|;
if|if
condition|(
name|new_slots
operator|<
literal|0
condition|)
name|new_slots
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
if|if
condition|(
name|new_slots
condition|)
name|netmap_monitor_parent_sync
argument_list|(
name|kring
argument_list|,
name|first_new
argument_list|,
name|new_slots
argument_list|)
expr_stmt|;
return|return
name|kring
operator|->
name|mon_sync
argument_list|(
name|kring
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* callback used to replace the nm_sync callback in the monitored rx rings */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_parent_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|u_int
name|first_new
decl_stmt|;
name|int
name|new_slots
decl_stmt|,
name|error
decl_stmt|;
comment|/* get the new slots */
name|error
operator|=
name|kring
operator|->
name|mon_sync
argument_list|(
name|kring
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|first_new
operator|=
name|kring
operator|->
name|mon_tail
expr_stmt|;
name|new_slots
operator|=
name|kring
operator|->
name|nr_hwtail
operator|-
name|first_new
expr_stmt|;
if|if
condition|(
name|new_slots
operator|<
literal|0
condition|)
name|new_slots
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
if|if
condition|(
name|new_slots
condition|)
name|netmap_monitor_parent_sync
argument_list|(
name|kring
argument_list|,
name|first_new
argument_list|,
name|new_slots
argument_list|)
expr_stmt|;
name|kring
operator|->
name|mon_tail
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* callback used to replace the nm_notify() callback in the monitored rx rings */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_parent_notify
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
function_decl|(
modifier|*
name|notify
function_decl|)
parameter_list|(
name|struct
name|netmap_kring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"%s %x"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* ?xsync callbacks have tryget called by their callers 	 * (NIOCREGIF and poll()), but here we have to call it 	 * by ourself 	 */
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/* in all cases, just skip the sync */
return|return
name|NM_IRQ_COMPLETED
return|;
block|}
if|if
condition|(
name|kring
operator|->
name|n_monitors
operator|>
literal|0
condition|)
block|{
name|netmap_monitor_parent_rxsync
argument_list|(
name|kring
argument_list|,
name|NAF_FORCE_READ
argument_list|)
expr_stmt|;
name|notify
operator|=
name|kring
operator|->
name|mon_notify
expr_stmt|;
block|}
else|else
block|{
comment|/* we are no longer monitoring this ring, so both 		 * mon_sync and mon_notify are NULL 		 */
name|notify
operator|=
name|kring
operator|->
name|nm_notify
expr_stmt|;
block|}
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return
name|notify
argument_list|(
name|kring
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_monitor_reg
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
return|return
name|netmap_monitor_reg_common
argument_list|(
name|na
argument_list|,
name|onoff
argument_list|,
literal|0
comment|/* no zcopy */
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_monitor_dtor
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_monitor_adapter
modifier|*
name|mna
init|=
operator|(
expr|struct
name|netmap_monitor_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
operator|&
name|mna
operator|->
name|priv
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|pna
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|netmap_adapter_put
argument_list|(
name|pna
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* check if nmr is a request for a monitor adapter that we can satisfy */
end_comment

begin_function
name|int
name|netmap_get_monitor_na
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
modifier|*
name|na
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|nmreq
name|pnmr
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|pna
decl_stmt|;
comment|/* parent adapter */
name|struct
name|netmap_monitor_adapter
modifier|*
name|mna
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
name|int
name|zcopy
init|=
operator|(
name|nmr
operator|->
name|nr_flags
operator|&
name|NR_ZCOPY_MON
operator|)
decl_stmt|;
name|char
name|monsuff
index|[
literal|10
index|]
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|(
name|nmr
operator|->
name|nr_flags
operator|&
operator|(
name|NR_MONITOR_TX
operator||
name|NR_MONITOR_RX
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nmr
operator|->
name|nr_flags
operator|&
name|NR_ZCOPY_MON
condition|)
block|{
comment|/* the flag makes no sense unless you are 			 * creating a monitor 			 */
return|return
name|EINVAL
return|;
block|}
name|ND
argument_list|(
literal|"not a monitor"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* this is a request for a monitor adapter */
name|ND
argument_list|(
literal|"flags %x"
argument_list|,
name|nmr
operator|->
name|nr_flags
argument_list|)
expr_stmt|;
name|mna
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mna
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mna
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"memory error"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* first, try to find the adapter that we want to monitor 	 * We use the same nmr, after we have turned off the monitor flags. 	 * In this way we can potentially monitor everything netmap understands, 	 * except other monitors. 	 */
name|memcpy
argument_list|(
operator|&
name|pnmr
argument_list|,
name|nmr
argument_list|,
sizeof|sizeof
argument_list|(
name|pnmr
argument_list|)
argument_list|)
expr_stmt|;
name|pnmr
operator|.
name|nr_flags
operator|&=
operator|~
operator|(
name|NR_MONITOR_TX
operator||
name|NR_MONITOR_RX
operator||
name|NR_ZCOPY_MON
operator|)
expr_stmt|;
name|error
operator|=
name|netmap_get_na
argument_list|(
operator|&
name|pnmr
argument_list|,
operator|&
name|pna
argument_list|,
operator|&
name|ifp
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"parent lookup failed: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mna
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ND
argument_list|(
literal|"found parent: %s"
argument_list|,
name|pna
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm_netmap_on
argument_list|(
name|pna
argument_list|)
condition|)
block|{
comment|/* parent not in netmap mode */
comment|/* XXX we can wait for the parent to enter netmap mode, 		 * by intercepting its nm_register callback (2014-03-16) 		 */
name|D
argument_list|(
literal|"%s not in netmap mode"
argument_list|,
name|pna
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|put_out
goto|;
block|}
comment|/* grab all the rings we need in the parent */
name|mna
operator|->
name|priv
operator|.
name|np_na
operator|=
name|pna
expr_stmt|;
name|error
operator|=
name|netmap_interp_ringid
argument_list|(
operator|&
name|mna
operator|->
name|priv
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|,
name|nmr
operator|->
name|nr_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"ringid error"
argument_list|)
expr_stmt|;
goto|goto
name|put_out
goto|;
block|}
if|if
condition|(
name|mna
operator|->
name|priv
operator|.
name|np_qlast
index|[
name|NR_TX
index|]
operator|-
name|mna
operator|->
name|priv
operator|.
name|np_qfirst
index|[
name|NR_TX
index|]
operator|==
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|monsuff
argument_list|,
literal|10
argument_list|,
literal|"-%d"
argument_list|,
name|mna
operator|->
name|priv
operator|.
name|np_qfirst
index|[
name|NR_TX
index|]
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|mna
operator|->
name|up
operator|.
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|mna
operator|->
name|up
operator|.
name|name
argument_list|)
argument_list|,
literal|"%s%s/%s%s%s"
argument_list|,
name|pna
operator|->
name|name
argument_list|,
name|monsuff
argument_list|,
name|zcopy
condition|?
literal|"z"
else|:
literal|""
argument_list|,
operator|(
name|nmr
operator|->
name|nr_flags
operator|&
name|NR_MONITOR_RX
operator|)
condition|?
literal|"r"
else|:
literal|""
argument_list|,
operator|(
name|nmr
operator|->
name|nr_flags
operator|&
name|NR_MONITOR_TX
operator|)
condition|?
literal|"t"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcopy
condition|)
block|{
comment|/* zero copy monitors need exclusive access to the monitored rings */
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|nmr
operator|->
name|nr_flags
operator|&
name|nm_txrx2flag
argument_list|(
name|t
argument_list|)
operator|)
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
name|mna
operator|->
name|priv
operator|.
name|np_qfirst
index|[
name|t
index|]
init|;
name|i
operator|<
name|mna
operator|->
name|priv
operator|.
name|np_qlast
index|[
name|t
index|]
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|NMR
argument_list|(
name|pna
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|kring
operator|->
name|n_monitors
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|D
argument_list|(
literal|"ring %s already monitored by %s"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|monitors
index|[
literal|0
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|put_out
goto|;
block|}
block|}
block|}
name|mna
operator|->
name|up
operator|.
name|nm_register
operator|=
name|netmap_zmon_reg
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|nm_dtor
operator|=
name|netmap_zmon_dtor
expr_stmt|;
comment|/* to have zero copy, we need to use the same memory allocator 		 * as the monitored port 		 */
name|mna
operator|->
name|up
operator|.
name|nm_mem
operator|=
name|pna
operator|->
name|nm_mem
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|na_lut
operator|=
name|pna
operator|->
name|na_lut
expr_stmt|;
block|}
else|else
block|{
comment|/* normal monitors are incompatible with zero copy ones */
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|nmr
operator|->
name|nr_flags
operator|&
name|nm_txrx2flag
argument_list|(
name|t
argument_list|)
operator|)
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
name|mna
operator|->
name|priv
operator|.
name|np_qfirst
index|[
name|t
index|]
init|;
name|i
operator|<
name|mna
operator|->
name|priv
operator|.
name|np_qlast
index|[
name|t
index|]
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|NMR
argument_list|(
name|pna
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|kring
operator|->
name|n_monitors
operator|>
literal|0
operator|&&
name|kring
operator|->
name|monitors
index|[
literal|0
index|]
operator|->
name|na
operator|->
name|nm_register
operator|==
name|netmap_zmon_reg
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|D
argument_list|(
literal|"ring busy"
argument_list|)
expr_stmt|;
goto|goto
name|put_out
goto|;
block|}
block|}
block|}
name|mna
operator|->
name|up
operator|.
name|nm_rxsync
operator|=
name|netmap_monitor_rxsync
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|nm_register
operator|=
name|netmap_monitor_reg
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|nm_dtor
operator|=
name|netmap_monitor_dtor
expr_stmt|;
block|}
comment|/* the monitor supports the host rings iff the parent does */
name|mna
operator|->
name|up
operator|.
name|na_flags
operator|=
operator|(
name|pna
operator|->
name|na_flags
operator|&
name|NAF_HOST_RINGS
operator|)
expr_stmt|;
comment|/* a do-nothing txsync: monitors cannot be used to inject packets */
name|mna
operator|->
name|up
operator|.
name|nm_txsync
operator|=
name|netmap_monitor_txsync
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|nm_rxsync
operator|=
name|netmap_monitor_rxsync
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|nm_krings_create
operator|=
name|netmap_monitor_krings_create
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|nm_krings_delete
operator|=
name|netmap_monitor_krings_delete
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|num_tx_rings
operator|=
literal|1
expr_stmt|;
comment|// XXX we don't need it, but field can't be zero
comment|/* we set the number of our rx_rings to be max(num_rx_rings, num_rx_rings) 	 * in the parent 	 */
name|mna
operator|->
name|up
operator|.
name|num_rx_rings
operator|=
name|pna
operator|->
name|num_rx_rings
expr_stmt|;
if|if
condition|(
name|pna
operator|->
name|num_tx_rings
operator|>
name|pna
operator|->
name|num_rx_rings
condition|)
name|mna
operator|->
name|up
operator|.
name|num_rx_rings
operator|=
name|pna
operator|->
name|num_tx_rings
expr_stmt|;
comment|/* by default, the number of slots is the same as in 	 * the parent rings, but the user may ask for a different 	 * number 	 */
name|mna
operator|->
name|up
operator|.
name|num_tx_desc
operator|=
name|nmr
operator|->
name|nr_tx_slots
expr_stmt|;
name|nm_bound_var
argument_list|(
operator|&
name|mna
operator|->
name|up
operator|.
name|num_tx_desc
argument_list|,
name|pna
operator|->
name|num_tx_desc
argument_list|,
literal|1
argument_list|,
name|NM_MONITOR_MAXSLOTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|num_rx_desc
operator|=
name|nmr
operator|->
name|nr_rx_slots
expr_stmt|;
name|nm_bound_var
argument_list|(
operator|&
name|mna
operator|->
name|up
operator|.
name|num_rx_desc
argument_list|,
name|pna
operator|->
name|num_rx_desc
argument_list|,
literal|1
argument_list|,
name|NM_MONITOR_MAXSLOTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|netmap_attach_common
argument_list|(
operator|&
name|mna
operator|->
name|up
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"attach_common error"
argument_list|)
expr_stmt|;
goto|goto
name|put_out
goto|;
block|}
comment|/* remember the traffic directions we have to monitor */
name|mna
operator|->
name|flags
operator|=
operator|(
name|nmr
operator|->
name|nr_flags
operator|&
operator|(
name|NR_MONITOR_TX
operator||
name|NR_MONITOR_RX
operator|)
operator|)
expr_stmt|;
operator|*
name|na
operator|=
operator|&
name|mna
operator|->
name|up
expr_stmt|;
name|netmap_adapter_get
argument_list|(
operator|*
name|na
argument_list|)
expr_stmt|;
comment|/* keep the reference to the parent */
name|ND
argument_list|(
literal|"monitor ok"
argument_list|)
expr_stmt|;
comment|/* drop the reference to the ifp, if any */
if|if
condition|(
name|ifp
condition|)
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|put_out
label|:
name|netmap_unget_na
argument_list|(
name|pna
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mna
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_MONITOR */
end_comment

end_unit

