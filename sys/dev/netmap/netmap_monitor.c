begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2014 Giuseppe Lettieri. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  *  * Monitors  *  * netmap monitors can be used to do zero-copy monitoring of network traffic  * on another adapter, when the latter adapter is working in netmap mode.  *  * Monitors offer to userspace the same interface as any other netmap port,  * with as many pairs of netmap rings as the monitored adapter.  * However, only the rx rings are actually used. Each monitor rx ring receives  * the traffic transiting on both the tx and rx corresponding rings in the  * monitored adapter. During registration, the user can choose if she wants  * to intercept tx only, rx only, or both tx and rx traffic.  *  * The monitor only sees the frames after they have been consumed in the  * monitored adapter:  *  *  - For tx traffic, this is after the slots containing the frames have been  *    marked as free. Note that this may happen at a considerably delay after  *    frame transmission, since freeing of slots is often done lazily.  *  *  - For rx traffic, this is after the consumer on the monitored adapter  *    has released them. In most cases, the consumer is a userspace  *    application which may have modified the frame contents.  *  * If the monitor is not able to cope with the stream of frames, excess traffic  * will be dropped.  *  * Each ring can be monitored by at most one monitor. This may change in the  * future, if we implement monitor chaining.  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* defines used in kernel.h */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* types used in module initialization */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* */
end_comment

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|linux
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"bsd_glue.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_elif

begin_warning
warning|#
directive|warning
warning|OSX support is only partial
end_warning

begin_include
include|#
directive|include
file|"osx_glue.h"
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|Unsupported platform
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unsupported */
end_comment

begin_comment
comment|/*  * common headers  */
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_mem2.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_MONITOR
end_ifdef

begin_define
define|#
directive|define
name|NM_MONITOR_MAXSLOTS
value|4096
end_define

begin_comment
comment|/* monitor works by replacing the nm_sync callbacks in the monitored rings.  * The actions to be performed are the same on both tx and rx rings, so we  * have collected them here  */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_parent_sync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|,
name|u_int
modifier|*
name|ringptr
parameter_list|)
block|{
name|struct
name|netmap_monitor_adapter
modifier|*
name|mna
init|=
name|kring
operator|->
name|monitor
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|mkring
init|=
operator|&
name|mna
operator|->
name|up
operator|.
name|rx_rings
index|[
name|kring
operator|->
name|ring_id
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|,
modifier|*
name|mring
init|=
name|mkring
operator|->
name|ring
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|rel_slots
decl_stmt|,
name|free_slots
decl_stmt|,
name|busy
decl_stmt|;
name|u_int
name|beg
decl_stmt|,
name|end
decl_stmt|,
name|i
decl_stmt|;
name|u_int
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|,
name|mlim
init|=
name|mkring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
comment|/* get the relased slots (rel_slots) */
name|beg
operator|=
operator|*
name|ringptr
expr_stmt|;
name|error
operator|=
name|kring
operator|->
name|save_sync
argument_list|(
name|kring
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|end
operator|=
operator|*
name|ringptr
expr_stmt|;
name|rel_slots
operator|=
name|end
operator|-
name|beg
expr_stmt|;
if|if
condition|(
name|rel_slots
operator|<
literal|0
condition|)
name|rel_slots
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
if|if
condition|(
operator|!
name|rel_slots
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* we need to lock the monitor receive ring, since it 	 * is the target of bot tx and rx traffic from the monitored 	 * adapter 	 */
name|mtx_lock
argument_list|(
operator|&
name|mkring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
comment|/* get the free slots available on the monitor ring */
name|i
operator|=
name|mkring
operator|->
name|nr_hwtail
expr_stmt|;
name|busy
operator|=
name|i
operator|-
name|mkring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|busy
operator|<
literal|0
condition|)
name|busy
operator|+=
name|mkring
operator|->
name|nkr_num_slots
expr_stmt|;
name|free_slots
operator|=
name|mlim
operator|-
name|busy
expr_stmt|;
if|if
condition|(
operator|!
name|free_slots
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|mkring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* swap min(free_slots, rel_slots) slots */
if|if
condition|(
name|free_slots
operator|<
name|rel_slots
condition|)
block|{
name|beg
operator|+=
operator|(
name|rel_slots
operator|-
name|free_slots
operator|)
expr_stmt|;
if|if
condition|(
name|beg
operator|>
name|lim
condition|)
name|beg
operator|=
literal|0
expr_stmt|;
name|rel_slots
operator|=
name|free_slots
expr_stmt|;
block|}
for|for
control|(
init|;
name|rel_slots
condition|;
name|rel_slots
operator|--
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|s
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|beg
index|]
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|ms
init|=
operator|&
name|mring
operator|->
name|slot
index|[
name|i
index|]
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ms
operator|->
name|buf_idx
expr_stmt|;
name|ms
operator|->
name|buf_idx
operator|=
name|s
operator|->
name|buf_idx
expr_stmt|;
name|s
operator|->
name|buf_idx
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|ms
operator|->
name|len
expr_stmt|;
name|ms
operator|->
name|len
operator|=
name|s
operator|->
name|len
expr_stmt|;
name|s
operator|->
name|len
operator|=
name|tmp
expr_stmt|;
name|s
operator|->
name|flags
operator||=
name|NS_BUF_CHANGED
expr_stmt|;
name|beg
operator|=
name|nm_next
argument_list|(
name|beg
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|i
operator|=
name|nm_next
argument_list|(
name|i
argument_list|,
name|mlim
argument_list|)
expr_stmt|;
block|}
name|wmb
argument_list|()
expr_stmt|;
name|mkring
operator|->
name|nr_hwtail
operator|=
name|i
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mkring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
comment|/* notify the new frames to the monitor */
name|mna
operator|->
name|up
operator|.
name|nm_notify
argument_list|(
operator|&
name|mna
operator|->
name|up
argument_list|,
name|mkring
operator|->
name|ring_id
argument_list|,
name|NR_RX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* callback used to replace the nm_sync callback in the monitored tx rings */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_parent_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ND
argument_list|(
literal|"%s %x"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|netmap_monitor_parent_sync
argument_list|(
name|kring
argument_list|,
name|flags
argument_list|,
operator|&
name|kring
operator|->
name|nr_hwtail
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* callback used to replace the nm_sync callback in the monitored rx rings */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_parent_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ND
argument_list|(
literal|"%s %x"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|netmap_monitor_parent_sync
argument_list|(
name|kring
argument_list|,
name|flags
argument_list|,
operator|&
name|kring
operator|->
name|rcur
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* nm_sync callback for the monitor's own tx rings.  * This makes no sense and always returns error  */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|D
argument_list|(
literal|"%s %x"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
end_function

begin_comment
comment|/* nm_sync callback for the monitor's own rx rings.  * Note that the lock in netmap_monitor_parent_sync only protects  * writers among themselves. Synchronization between writers  * (i.e., netmap_monitor_parent_txsync and netmap_monitor_parent_rxsync)  * and readers (i.e., netmap_monitor_rxsync) relies on memory barriers.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ND
argument_list|(
literal|"%s %x"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|kring
operator|->
name|rcur
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
name|nm_rxsync_finalize
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* nm_krings_create callbacks for monitors.  * We could use the default netmap_hw_krings_monitor, but  * we don't need the mbq.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
return|return
name|netmap_krings_create
argument_list|(
name|na
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* nm_register callback for monitors.  *  * On registration, replace the nm_sync callbacks in the monitored  * rings with our own, saving the previous ones in the monitored  * rings themselves, where they are used by netmap_monitor_parent_sync.  *  * On de-registration, restore the original callbacks. We need to  * stop traffic while we are doing this, since the monitored adapter may  * have already started executing a netmap_monitor_parent_sync  * and may not like the kring->save_sync pointer to become NULL.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_monitor_reg
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|netmap_monitor_adapter
modifier|*
name|mna
init|=
operator|(
expr|struct
name|netmap_monitor_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
operator|&
name|mna
operator|->
name|priv
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|pna
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ND
argument_list|(
literal|"%p: onoff %d"
argument_list|,
name|na
argument_list|,
name|onoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
if|if
condition|(
operator|!
name|nm_netmap_on
argument_list|(
name|pna
argument_list|)
condition|)
block|{
comment|/* parent left netmap mode, fatal */
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|mna
operator|->
name|flags
operator|&
name|NR_MONITOR_TX
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_txqfirst
init|;
name|i
operator|<
name|priv
operator|->
name|np_txqlast
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|pna
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|kring
operator|->
name|save_sync
operator|=
name|kring
operator|->
name|nm_sync
expr_stmt|;
name|kring
operator|->
name|nm_sync
operator|=
name|netmap_monitor_parent_txsync
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mna
operator|->
name|flags
operator|&
name|NR_MONITOR_RX
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_rxqfirst
init|;
name|i
operator|<
name|priv
operator|->
name|np_rxqlast
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|pna
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|kring
operator|->
name|save_sync
operator|=
name|kring
operator|->
name|nm_sync
expr_stmt|;
name|kring
operator|->
name|nm_sync
operator|=
name|netmap_monitor_parent_rxsync
expr_stmt|;
block|}
block|}
name|na
operator|->
name|na_flags
operator||=
name|NAF_NETMAP_ON
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|nm_netmap_on
argument_list|(
name|pna
argument_list|)
condition|)
block|{
comment|/* parent left netmap mode, nothing to restore */
return|return
literal|0
return|;
block|}
name|na
operator|->
name|na_flags
operator|&=
operator|~
name|NAF_NETMAP_ON
expr_stmt|;
if|if
condition|(
name|mna
operator|->
name|flags
operator|&
name|NR_MONITOR_TX
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_txqfirst
init|;
name|i
operator|<
name|priv
operator|->
name|np_txqlast
condition|;
name|i
operator|++
control|)
block|{
name|netmap_set_txring
argument_list|(
name|pna
argument_list|,
name|i
argument_list|,
literal|1
comment|/* stopped */
argument_list|)
expr_stmt|;
name|kring
operator|=
operator|&
name|pna
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|kring
operator|->
name|nm_sync
operator|=
name|kring
operator|->
name|save_sync
expr_stmt|;
name|kring
operator|->
name|save_sync
operator|=
name|NULL
expr_stmt|;
name|netmap_set_txring
argument_list|(
name|pna
argument_list|,
name|i
argument_list|,
literal|0
comment|/* enabled */
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mna
operator|->
name|flags
operator|&
name|NR_MONITOR_RX
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_rxqfirst
init|;
name|i
operator|<
name|priv
operator|->
name|np_rxqlast
condition|;
name|i
operator|++
control|)
block|{
name|netmap_set_rxring
argument_list|(
name|pna
argument_list|,
name|i
argument_list|,
literal|1
comment|/* stopped */
argument_list|)
expr_stmt|;
name|kring
operator|=
operator|&
name|pna
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|kring
operator|->
name|nm_sync
operator|=
name|kring
operator|->
name|save_sync
expr_stmt|;
name|kring
operator|->
name|save_sync
operator|=
name|NULL
expr_stmt|;
name|netmap_set_rxring
argument_list|(
name|pna
argument_list|,
name|i
argument_list|,
literal|0
comment|/* enabled */
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* nm_krings_delete callback for monitors */
end_comment

begin_function
specifier|static
name|void
name|netmap_monitor_krings_delete
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|netmap_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* nm_dtor callback for monitors */
end_comment

begin_function
specifier|static
name|void
name|netmap_monitor_dtor
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_monitor_adapter
modifier|*
name|mna
init|=
operator|(
expr|struct
name|netmap_monitor_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
operator|&
name|mna
operator|->
name|priv
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|pna
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ND
argument_list|(
literal|"%p"
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_netmap_on
argument_list|(
name|pna
argument_list|)
condition|)
block|{
comment|/* parent still in netmap mode, mark its krings as free */
if|if
condition|(
name|mna
operator|->
name|flags
operator|&
name|NR_MONITOR_TX
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_txqfirst
init|;
name|i
operator|<
name|priv
operator|->
name|np_txqlast
condition|;
name|i
operator|++
control|)
block|{
name|pna
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|monitor
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mna
operator|->
name|flags
operator|&
name|NR_MONITOR_RX
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_rxqfirst
init|;
name|i
operator|<
name|priv
operator|->
name|np_rxqlast
condition|;
name|i
operator|++
control|)
block|{
name|pna
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|monitor
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|netmap_adapter_put
argument_list|(
name|pna
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* check if nmr is a request for a monitor adapter that we can satisfy */
end_comment

begin_function
name|int
name|netmap_get_monitor_na
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
modifier|*
name|na
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|nmreq
name|pnmr
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|pna
decl_stmt|;
comment|/* parent adapter */
name|struct
name|netmap_monitor_adapter
modifier|*
name|mna
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|nmr
operator|->
name|nr_flags
operator|&
operator|(
name|NR_MONITOR_TX
operator||
name|NR_MONITOR_RX
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ND
argument_list|(
literal|"not a monitor"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* this is a request for a monitor adapter */
name|D
argument_list|(
literal|"flags %x"
argument_list|,
name|nmr
operator|->
name|nr_flags
argument_list|)
expr_stmt|;
name|mna
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mna
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mna
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"memory error"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* first, try to find the adapter that we want to monitor 	 * We use the same nmr, after we have turned off the monitor flags. 	 * In this way we can potentially monitor everything netmap understands, 	 * except other monitors. 	 */
name|memcpy
argument_list|(
operator|&
name|pnmr
argument_list|,
name|nmr
argument_list|,
sizeof|sizeof
argument_list|(
name|pnmr
argument_list|)
argument_list|)
expr_stmt|;
name|pnmr
operator|.
name|nr_flags
operator|&=
operator|~
operator|(
name|NR_MONITOR_TX
operator||
name|NR_MONITOR_RX
operator|)
expr_stmt|;
name|error
operator|=
name|netmap_get_na
argument_list|(
operator|&
name|pnmr
argument_list|,
operator|&
name|pna
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"parent lookup failed: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|D
argument_list|(
literal|"found parent: %s"
argument_list|,
name|pna
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm_netmap_on
argument_list|(
name|pna
argument_list|)
condition|)
block|{
comment|/* parent not in netmap mode */
comment|/* XXX we can wait for the parent to enter netmap mode, 		 * by intercepting its nm_register callback (2014-03-16) 		 */
name|D
argument_list|(
literal|"%s not in netmap mode"
argument_list|,
name|pna
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|put_out
goto|;
block|}
comment|/* grab all the rings we need in the parent */
name|mna
operator|->
name|priv
operator|.
name|np_na
operator|=
name|pna
expr_stmt|;
name|error
operator|=
name|netmap_interp_ringid
argument_list|(
operator|&
name|mna
operator|->
name|priv
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|,
name|nmr
operator|->
name|nr_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"ringid error"
argument_list|)
expr_stmt|;
goto|goto
name|put_out
goto|;
block|}
if|if
condition|(
name|nmr
operator|->
name|nr_flags
operator|&
name|NR_MONITOR_TX
condition|)
block|{
for|for
control|(
name|i
operator|=
name|mna
operator|->
name|priv
operator|.
name|np_txqfirst
init|;
name|i
operator|<
name|mna
operator|->
name|priv
operator|.
name|np_txqlast
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|pna
operator|->
name|tx_rings
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|kring
operator|->
name|monitor
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|D
argument_list|(
literal|"ring busy"
argument_list|)
expr_stmt|;
goto|goto
name|release_out
goto|;
block|}
name|kring
operator|->
name|monitor
operator|=
name|mna
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nmr
operator|->
name|nr_flags
operator|&
name|NR_MONITOR_RX
condition|)
block|{
for|for
control|(
name|i
operator|=
name|mna
operator|->
name|priv
operator|.
name|np_rxqfirst
init|;
name|i
operator|<
name|mna
operator|->
name|priv
operator|.
name|np_rxqlast
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|pna
operator|->
name|rx_rings
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|kring
operator|->
name|monitor
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|D
argument_list|(
literal|"ring busy"
argument_list|)
expr_stmt|;
goto|goto
name|release_out
goto|;
block|}
name|kring
operator|->
name|monitor
operator|=
name|mna
expr_stmt|;
block|}
block|}
name|snprintf
argument_list|(
name|mna
operator|->
name|up
operator|.
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|mna
operator|->
name|up
operator|.
name|name
argument_list|)
argument_list|,
literal|"mon:%s"
argument_list|,
name|pna
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* the monitor supports the host rings iff the parent does */
name|mna
operator|->
name|up
operator|.
name|na_flags
operator|=
operator|(
name|pna
operator|->
name|na_flags
operator|&
name|NAF_HOST_RINGS
operator|)
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|nm_txsync
operator|=
name|netmap_monitor_txsync
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|nm_rxsync
operator|=
name|netmap_monitor_rxsync
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|nm_register
operator|=
name|netmap_monitor_reg
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|nm_dtor
operator|=
name|netmap_monitor_dtor
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|nm_krings_create
operator|=
name|netmap_monitor_krings_create
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|nm_krings_delete
operator|=
name|netmap_monitor_krings_delete
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|nm_mem
operator|=
name|pna
operator|->
name|nm_mem
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|na_lut
operator|=
name|pna
operator|->
name|na_lut
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|na_lut_objtotal
operator|=
name|pna
operator|->
name|na_lut_objtotal
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|na_lut_objsize
operator|=
name|pna
operator|->
name|na_lut_objsize
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|num_tx_rings
operator|=
literal|1
expr_stmt|;
comment|// XXX we don't need it, but field can't be zero
comment|/* we set the number of our rx_rings to be max(num_rx_rings, num_rx_rings) 	 * in the parent 	 */
name|mna
operator|->
name|up
operator|.
name|num_rx_rings
operator|=
name|pna
operator|->
name|num_rx_rings
expr_stmt|;
if|if
condition|(
name|pna
operator|->
name|num_tx_rings
operator|>
name|pna
operator|->
name|num_rx_rings
condition|)
name|mna
operator|->
name|up
operator|.
name|num_rx_rings
operator|=
name|pna
operator|->
name|num_tx_rings
expr_stmt|;
comment|/* by default, the number of slots is the same as in 	 * the parent rings, but the user may ask for a different 	 * number 	 */
name|mna
operator|->
name|up
operator|.
name|num_tx_desc
operator|=
name|nmr
operator|->
name|nr_tx_slots
expr_stmt|;
name|nm_bound_var
argument_list|(
operator|&
name|mna
operator|->
name|up
operator|.
name|num_tx_desc
argument_list|,
name|pna
operator|->
name|num_tx_desc
argument_list|,
literal|1
argument_list|,
name|NM_MONITOR_MAXSLOTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mna
operator|->
name|up
operator|.
name|num_rx_desc
operator|=
name|nmr
operator|->
name|nr_rx_slots
expr_stmt|;
name|nm_bound_var
argument_list|(
operator|&
name|mna
operator|->
name|up
operator|.
name|num_rx_desc
argument_list|,
name|pna
operator|->
name|num_rx_desc
argument_list|,
literal|1
argument_list|,
name|NM_MONITOR_MAXSLOTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|netmap_attach_common
argument_list|(
operator|&
name|mna
operator|->
name|up
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"attach_common error"
argument_list|)
expr_stmt|;
goto|goto
name|release_out
goto|;
block|}
comment|/* remember the traffic directions we have to monitor */
name|mna
operator|->
name|flags
operator|=
operator|(
name|nmr
operator|->
name|nr_flags
operator|&
operator|(
name|NR_MONITOR_TX
operator||
name|NR_MONITOR_RX
operator|)
operator|)
expr_stmt|;
operator|*
name|na
operator|=
operator|&
name|mna
operator|->
name|up
expr_stmt|;
name|netmap_adapter_get
argument_list|(
operator|*
name|na
argument_list|)
expr_stmt|;
comment|/* write the configuration back */
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|mna
operator|->
name|up
operator|.
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|mna
operator|->
name|up
operator|.
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|mna
operator|->
name|up
operator|.
name|num_tx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|mna
operator|->
name|up
operator|.
name|num_rx_desc
expr_stmt|;
comment|/* keep the reference to the parent */
name|D
argument_list|(
literal|"monitor ok"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|release_out
label|:
name|D
argument_list|(
literal|"monitor error"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|mna
operator|->
name|priv
operator|.
name|np_txqfirst
init|;
name|i
operator|<
name|mna
operator|->
name|priv
operator|.
name|np_txqlast
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pna
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|monitor
operator|==
name|mna
condition|)
name|pna
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|monitor
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|mna
operator|->
name|priv
operator|.
name|np_rxqfirst
init|;
name|i
operator|<
name|mna
operator|->
name|priv
operator|.
name|np_rxqlast
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pna
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|monitor
operator|==
name|mna
condition|)
name|pna
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|monitor
operator|=
name|NULL
expr_stmt|;
block|}
name|put_out
label|:
name|netmap_adapter_put
argument_list|(
name|pna
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mna
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_MONITOR */
end_comment

end_unit

