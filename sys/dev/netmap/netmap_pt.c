begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2015 Stefano Garzarella  * Copyright (C) 2016 Vincenzo Maffione  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * common headers  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|//#define usleep_range(_1, _2)
end_comment

begin_define
define|#
directive|define
name|usleep_range
parameter_list|(
name|_1
parameter_list|,
name|_2
parameter_list|)
define|\
value|pause_sbt("ptnetmap-sleep", SBT_1US * _1, SBT_1US * 1, C_ABSOLUTE)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|linux
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<bsd_glue.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<net/netmap_virt.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_mem2.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_PTNETMAP_HOST
end_ifdef

begin_comment
comment|/* RX cycle without receive any packets */
end_comment

begin_define
define|#
directive|define
name|PTN_RX_DRY_CYCLES_MAX
value|10
end_define

begin_comment
comment|/* Limit Batch TX to half ring.  * Currently disabled, since it does not manage NS_MOREFRAG, which  * results in random drops in the VALE txsync. */
end_comment

begin_comment
comment|//#define PTN_TX_BATCH_LIM(_n)	((_n>> 1))
end_comment

begin_comment
comment|//#define BUSY_WAIT
end_comment

begin_define
define|#
directive|define
name|NETMAP_PT_DEBUG
end_define

begin_comment
comment|/* Enables communication debugging. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NETMAP_PT_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|RATE
end_undef

begin_comment
comment|//#define RATE  /* Enables communication statistics. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RATE
end_ifdef

begin_define
define|#
directive|define
name|IFRATE
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_struct
struct|struct
name|rate_batch_stats
block|{
name|unsigned
name|long
name|sync
decl_stmt|;
name|unsigned
name|long
name|sync_dry
decl_stmt|;
name|unsigned
name|long
name|pkt
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rate_stats
block|{
name|unsigned
name|long
name|gtxk
decl_stmt|;
comment|/* Guest --> Host Tx kicks. */
name|unsigned
name|long
name|grxk
decl_stmt|;
comment|/* Guest --> Host Rx kicks. */
name|unsigned
name|long
name|htxk
decl_stmt|;
comment|/* Host --> Guest Tx kicks. */
name|unsigned
name|long
name|hrxk
decl_stmt|;
comment|/* Host --> Guest Rx Kicks. */
name|unsigned
name|long
name|btxwu
decl_stmt|;
comment|/* Backend Tx wake-up. */
name|unsigned
name|long
name|brxwu
decl_stmt|;
comment|/* Backend Rx wake-up. */
name|struct
name|rate_batch_stats
name|txbs
decl_stmt|;
name|struct
name|rate_batch_stats
name|rxbs
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rate_context
block|{
name|struct
name|timer_list
name|timer
decl_stmt|;
name|struct
name|rate_stats
name|new
decl_stmt|;
name|struct
name|rate_stats
name|old
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|RATE_PERIOD
value|2
end_define

begin_function
specifier|static
name|void
name|rate_callback
parameter_list|(
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|struct
name|rate_context
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|rate_context
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|rate_stats
name|cur
init|=
name|ctx
operator|->
name|new
decl_stmt|;
name|struct
name|rate_batch_stats
modifier|*
name|txbs
init|=
operator|&
name|cur
operator|.
name|txbs
decl_stmt|;
name|struct
name|rate_batch_stats
modifier|*
name|rxbs
init|=
operator|&
name|cur
operator|.
name|rxbs
decl_stmt|;
name|struct
name|rate_batch_stats
modifier|*
name|txbs_old
init|=
operator|&
name|ctx
operator|->
name|old
operator|.
name|txbs
decl_stmt|;
name|struct
name|rate_batch_stats
modifier|*
name|rxbs_old
init|=
operator|&
name|ctx
operator|->
name|old
operator|.
name|rxbs
decl_stmt|;
name|uint64_t
name|tx_batch
decl_stmt|,
name|rx_batch
decl_stmt|;
name|unsigned
name|long
name|txpkts
decl_stmt|,
name|rxpkts
decl_stmt|;
name|unsigned
name|long
name|gtxk
decl_stmt|,
name|grxk
decl_stmt|;
name|int
name|r
decl_stmt|;
name|txpkts
operator|=
name|txbs
operator|->
name|pkt
operator|-
name|txbs_old
operator|->
name|pkt
expr_stmt|;
name|rxpkts
operator|=
name|rxbs
operator|->
name|pkt
operator|-
name|rxbs_old
operator|->
name|pkt
expr_stmt|;
name|tx_batch
operator|=
operator|(
operator|(
name|txbs
operator|->
name|sync
operator|-
name|txbs_old
operator|->
name|sync
operator|)
operator|>
literal|0
operator|)
condition|?
name|txpkts
operator|/
operator|(
name|txbs
operator|->
name|sync
operator|-
name|txbs_old
operator|->
name|sync
operator|)
else|:
literal|0
expr_stmt|;
name|rx_batch
operator|=
operator|(
operator|(
name|rxbs
operator|->
name|sync
operator|-
name|rxbs_old
operator|->
name|sync
operator|)
operator|>
literal|0
operator|)
condition|?
name|rxpkts
operator|/
operator|(
name|rxbs
operator|->
name|sync
operator|-
name|rxbs_old
operator|->
name|sync
operator|)
else|:
literal|0
expr_stmt|;
comment|/* Fix-up gtxk and grxk estimates. */
name|gtxk
operator|=
operator|(
name|cur
operator|.
name|gtxk
operator|-
name|ctx
operator|->
name|old
operator|.
name|gtxk
operator|)
operator|-
operator|(
name|cur
operator|.
name|btxwu
operator|-
name|ctx
operator|->
name|old
operator|.
name|btxwu
operator|)
expr_stmt|;
name|grxk
operator|=
operator|(
name|cur
operator|.
name|grxk
operator|-
name|ctx
operator|->
name|old
operator|.
name|grxk
operator|)
operator|-
operator|(
name|cur
operator|.
name|brxwu
operator|-
name|ctx
operator|->
name|old
operator|.
name|brxwu
operator|)
expr_stmt|;
name|printk
argument_list|(
literal|"txpkts  = %lu Hz\n"
argument_list|,
name|txpkts
operator|/
name|RATE_PERIOD
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"gtxk    = %lu Hz\n"
argument_list|,
name|gtxk
operator|/
name|RATE_PERIOD
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"htxk    = %lu Hz\n"
argument_list|,
operator|(
name|cur
operator|.
name|htxk
operator|-
name|ctx
operator|->
name|old
operator|.
name|htxk
operator|)
operator|/
name|RATE_PERIOD
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"btxw    = %lu Hz\n"
argument_list|,
operator|(
name|cur
operator|.
name|btxwu
operator|-
name|ctx
operator|->
name|old
operator|.
name|btxwu
operator|)
operator|/
name|RATE_PERIOD
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"rxpkts  = %lu Hz\n"
argument_list|,
name|rxpkts
operator|/
name|RATE_PERIOD
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"grxk    = %lu Hz\n"
argument_list|,
name|grxk
operator|/
name|RATE_PERIOD
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"hrxk    = %lu Hz\n"
argument_list|,
operator|(
name|cur
operator|.
name|hrxk
operator|-
name|ctx
operator|->
name|old
operator|.
name|hrxk
operator|)
operator|/
name|RATE_PERIOD
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"brxw    = %lu Hz\n"
argument_list|,
operator|(
name|cur
operator|.
name|brxwu
operator|-
name|ctx
operator|->
name|old
operator|.
name|brxwu
operator|)
operator|/
name|RATE_PERIOD
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"txbatch = %llu avg\n"
argument_list|,
name|tx_batch
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"rxbatch = %llu avg\n"
argument_list|,
name|rx_batch
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|old
operator|=
name|cur
expr_stmt|;
name|r
operator|=
name|mod_timer
argument_list|(
operator|&
name|ctx
operator|->
name|timer
argument_list|,
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
name|RATE_PERIOD
operator|*
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
argument_list|)
condition|)
name|D
argument_list|(
literal|"[ptnetmap] Error: mod_timer()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rate_batch_stats_update
parameter_list|(
name|struct
name|rate_batch_stats
modifier|*
name|bf
parameter_list|,
name|uint32_t
name|pre_tail
parameter_list|,
name|uint32_t
name|act_tail
parameter_list|,
name|uint32_t
name|num_slots
parameter_list|)
block|{
name|int
name|n
init|=
operator|(
name|int
operator|)
name|act_tail
operator|-
name|pre_tail
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|+=
name|num_slots
expr_stmt|;
name|bf
operator|->
name|sync
operator|++
expr_stmt|;
name|bf
operator|->
name|pkt
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|bf
operator|->
name|sync_dry
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !RATE */
end_comment

begin_define
define|#
directive|define
name|IFRATE
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RATE */
end_comment

begin_struct
struct|struct
name|ptnetmap_state
block|{
comment|/* Kthreads. */
name|struct
name|nm_kctx
modifier|*
modifier|*
name|kctxs
decl_stmt|;
comment|/* Shared memory with the guest (TX/RX) */
name|struct
name|ptnet_ring
name|__user
modifier|*
name|ptrings
decl_stmt|;
name|bool
name|stopped
decl_stmt|;
comment|/* Netmap adapter wrapping the backend. */
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
decl_stmt|;
name|IFRATE
argument_list|(
argument|struct rate_context rate_ctx;
argument_list|)
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|void
name|ptnetmap_kring_dump
parameter_list|(
specifier|const
name|char
modifier|*
name|title
parameter_list|,
specifier|const
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
name|D
argument_list|(
literal|"%s - name: %s hwcur: %d hwtail: %d rhead: %d rcur: %d"
literal|" rtail: %d head: %d cur: %d tail: %d"
argument_list|,
name|title
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|kring
operator|->
name|rhead
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|rtail
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|head
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|tail
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TX functions to set/get and to handle host/guest kick.  */
end_comment

begin_comment
comment|/* Enable or disable guest --> host kicks. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ptring_kick_enable
parameter_list|(
name|struct
name|ptnet_ring
name|__user
modifier|*
name|ptring
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|CSB_WRITE
argument_list|(
name|ptring
argument_list|,
name|host_need_kick
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Are guest interrupt enabled or disabled? */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|ptring_intr_enabled
parameter_list|(
name|struct
name|ptnet_ring
name|__user
modifier|*
name|ptring
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|CSB_READ
argument_list|(
name|ptring
argument_list|,
name|guest_need_kick
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Enable or disable guest interrupts. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ptring_intr_enable
parameter_list|(
name|struct
name|ptnet_ring
name|__user
modifier|*
name|ptring
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|CSB_WRITE
argument_list|(
name|ptring
argument_list|,
name|guest_need_kick
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle TX events: from the guest or from the backend */
end_comment

begin_function
specifier|static
name|void
name|ptnetmap_tx_handler
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|is_kthread
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
name|data
decl_stmt|;
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
init|=
operator|(
expr|struct
name|netmap_pt_host_adapter
operator|*
operator|)
name|kring
operator|->
name|na
operator|->
name|na_private
decl_stmt|;
name|struct
name|ptnetmap_state
modifier|*
name|ptns
init|=
name|pth_na
operator|->
name|ptns
decl_stmt|;
name|struct
name|ptnet_ring
name|__user
modifier|*
name|ptring
decl_stmt|;
name|struct
name|netmap_ring
name|shadow_ring
decl_stmt|;
comment|/* shadow copy of the netmap_ring */
name|bool
name|more_txspace
init|=
name|false
decl_stmt|;
name|struct
name|nm_kctx
modifier|*
name|kth
decl_stmt|;
name|uint32_t
name|num_slots
decl_stmt|;
name|int
name|batch
decl_stmt|;
name|IFRATE
argument_list|(
argument|uint32_t pre_tail
argument_list|)
empty_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|ptns
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"ERROR ptnetmap state is NULL"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|ptns
operator|->
name|stopped
argument_list|)
condition|)
block|{
name|RD
argument_list|(
literal|1
argument_list|,
literal|"backend netmap is being stopped"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"ERROR nm_kr_tryget()"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This is a guess, to be fixed in the rate callback. */
name|IFRATE
argument_list|(
name|ptns
operator|->
name|rate_ctx
operator|.
name|new
operator|.
name|gtxk
operator|++
argument_list|)
expr_stmt|;
comment|/* Get TX ptring pointer from the CSB. */
name|ptring
operator|=
name|ptns
operator|->
name|ptrings
operator|+
name|kring
operator|->
name|ring_id
expr_stmt|;
name|kth
operator|=
name|ptns
operator|->
name|kctxs
index|[
name|kring
operator|->
name|ring_id
index|]
expr_stmt|;
name|num_slots
operator|=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|shadow_ring
operator|.
name|head
operator|=
name|kring
operator|->
name|rhead
expr_stmt|;
name|shadow_ring
operator|.
name|cur
operator|=
name|kring
operator|->
name|rcur
expr_stmt|;
comment|/* Disable guest --> host notifications. */
name|ptring_kick_enable
argument_list|(
name|ptring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy the guest kring pointers from the CSB */
name|ptnetmap_host_read_kring_csb
argument_list|(
name|ptring
argument_list|,
operator|&
name|shadow_ring
argument_list|,
name|num_slots
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If guest moves ahead too fast, let's cut the move so 	 * that we don't exceed our batch limit. */
name|batch
operator|=
name|shadow_ring
operator|.
name|head
operator|-
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|batch
operator|<
literal|0
condition|)
name|batch
operator|+=
name|num_slots
expr_stmt|;
ifdef|#
directive|ifdef
name|PTN_TX_BATCH_LIM
if|if
condition|(
name|batch
operator|>
name|PTN_TX_BATCH_LIM
argument_list|(
name|num_slots
argument_list|)
condition|)
block|{
name|uint32_t
name|head_lim
init|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|PTN_TX_BATCH_LIM
argument_list|(
name|num_slots
argument_list|)
decl_stmt|;
if|if
condition|(
name|head_lim
operator|>=
name|num_slots
condition|)
name|head_lim
operator|-=
name|num_slots
expr_stmt|;
name|ND
argument_list|(
literal|1
argument_list|,
literal|"batch: %d head: %d head_lim: %d"
argument_list|,
name|batch
argument_list|,
name|shadow_ring
operator|.
name|head
argument_list|,
name|head_lim
argument_list|)
expr_stmt|;
name|shadow_ring
operator|.
name|head
operator|=
name|head_lim
expr_stmt|;
name|batch
operator|=
name|PTN_TX_BATCH_LIM
argument_list|(
name|num_slots
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PTN_TX_BATCH_LIM */
if|if
condition|(
name|nm_kr_txspace
argument_list|(
name|kring
argument_list|)
operator|<=
operator|(
name|num_slots
operator|>>
literal|1
operator|)
condition|)
block|{
name|shadow_ring
operator|.
name|flags
operator||=
name|NAF_FORCE_RECLAIM
expr_stmt|;
block|}
comment|/* Netmap prologue */
name|shadow_ring
operator|.
name|tail
operator|=
name|kring
operator|->
name|rtail
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|nm_txsync_prologue
argument_list|(
name|kring
argument_list|,
operator|&
name|shadow_ring
argument_list|)
operator|>=
name|num_slots
argument_list|)
condition|)
block|{
comment|/* Reinit ring and enable notifications. */
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|ptring_kick_enable
argument_list|(
name|ptring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
argument_list|)
condition|)
block|{
name|ptnetmap_kring_dump
argument_list|(
literal|"pre txsync"
argument_list|,
name|kring
argument_list|)
expr_stmt|;
block|}
name|IFRATE
argument_list|(
name|pre_tail
operator|=
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|kring
operator|->
name|nm_sync
argument_list|(
name|kring
argument_list|,
name|shadow_ring
operator|.
name|flags
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Reenable notifications. */
name|ptring_kick_enable
argument_list|(
name|ptring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"ERROR txsync()"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*          * Finalize          * Copy host hwcur and hwtail into the CSB for the guest sync(), and 	 * do the nm_sync_finalize.          */
name|ptnetmap_host_write_kring_csb
argument_list|(
name|ptring
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|rtail
operator|!=
name|kring
operator|->
name|nr_hwtail
condition|)
block|{
comment|/* Some more room available in the parent adapter. */
name|kring
operator|->
name|rtail
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
name|more_txspace
operator|=
name|true
expr_stmt|;
block|}
name|IFRATE
argument_list|(
name|rate_batch_stats_update
argument_list|(
operator|&
name|ptns
operator|->
name|rate_ctx
operator|.
name|new
operator|.
name|txbs
argument_list|,
name|pre_tail
argument_list|,
name|kring
operator|->
name|rtail
argument_list|,
name|num_slots
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
argument_list|)
condition|)
block|{
name|ptnetmap_kring_dump
argument_list|(
literal|"post txsync"
argument_list|,
name|kring
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|BUSY_WAIT
comment|/* Interrupt the guest if needed. */
if|if
condition|(
name|more_txspace
operator|&&
name|ptring_intr_enabled
argument_list|(
name|ptring
argument_list|)
operator|&&
name|is_kthread
condition|)
block|{
comment|/* Disable guest kick to avoid sending unnecessary kicks */
name|ptring_intr_enable
argument_list|(
name|ptring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nm_os_kctx_send_irq
argument_list|(
name|kth
argument_list|)
expr_stmt|;
name|IFRATE
argument_list|(
name|ptns
operator|->
name|rate_ctx
operator|.
name|new
operator|.
name|htxk
operator|++
argument_list|)
expr_stmt|;
name|more_txspace
operator|=
name|false
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Read CSB to see if there is more work to do. */
name|ptnetmap_host_read_kring_csb
argument_list|(
name|ptring
argument_list|,
operator|&
name|shadow_ring
argument_list|,
name|num_slots
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BUSY_WAIT
if|if
condition|(
name|shadow_ring
operator|.
name|head
operator|==
name|kring
operator|->
name|rhead
condition|)
block|{
comment|/*              * No more packets to transmit. We enable notifications and              * go to sleep, waiting for a kick from the guest when new              * new slots are ready for transmission.              */
if|if
condition|(
name|is_kthread
condition|)
block|{
name|usleep_range
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Reenable notifications. */
name|ptring_kick_enable
argument_list|(
name|ptring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Doublecheck. */
name|ptnetmap_host_read_kring_csb
argument_list|(
name|ptring
argument_list|,
operator|&
name|shadow_ring
argument_list|,
name|num_slots
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow_ring
operator|.
name|head
operator|!=
name|kring
operator|->
name|rhead
condition|)
block|{
comment|/* We won the race condition, there are more packets to 		 * transmit. Disable notifications and do another cycle */
name|ptring_kick_enable
argument_list|(
name|ptring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|nm_kr_txempty
argument_list|(
name|kring
argument_list|)
condition|)
block|{
comment|/* No more available TX slots. We stop waiting for a notification 	     * from the backend (netmap_tx_irq). */
name|ND
argument_list|(
literal|1
argument_list|,
literal|"TX ring"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|unlikely
argument_list|(
name|ptns
operator|->
name|stopped
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"backend netmap is being stopped"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
if|if
condition|(
name|more_txspace
operator|&&
name|ptring_intr_enabled
argument_list|(
name|ptring
argument_list|)
operator|&&
name|is_kthread
condition|)
block|{
name|ptring_intr_enable
argument_list|(
name|ptring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nm_os_kctx_send_irq
argument_list|(
name|kth
argument_list|)
expr_stmt|;
name|IFRATE
argument_list|(
name|ptns
operator|->
name|rate_ctx
operator|.
name|new
operator|.
name|htxk
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called on backend nm_notify when there is no worker thread. */
end_comment

begin_function
specifier|static
name|void
name|ptnetmap_tx_nothread_notify
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
name|data
decl_stmt|;
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
init|=
operator|(
expr|struct
name|netmap_pt_host_adapter
operator|*
operator|)
name|kring
operator|->
name|na
operator|->
name|na_private
decl_stmt|;
name|struct
name|ptnetmap_state
modifier|*
name|ptns
init|=
name|pth_na
operator|->
name|ptns
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|ptns
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"ERROR ptnetmap state is NULL"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|ptns
operator|->
name|stopped
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"backend netmap is being stopped"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We cannot access the CSB here (to check ptring->guest_need_kick), 	 * unless we switch address space to the one of the guest. For now 	 * we unconditionally inject an interrupt. */
name|nm_os_kctx_send_irq
argument_list|(
name|ptns
operator|->
name|kctxs
index|[
name|kring
operator|->
name|ring_id
index|]
argument_list|)
expr_stmt|;
name|IFRATE
argument_list|(
name|ptns
operator|->
name|rate_ctx
operator|.
name|new
operator|.
name|htxk
operator|++
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|1
argument_list|,
literal|"%s interrupt"
argument_list|,
name|kring
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We need RX kicks from the guest when (tail == head-1), where we wait  * for the guest to refill.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BUSY_WAIT
end_ifndef

begin_function
specifier|static
specifier|inline
name|int
name|ptnetmap_norxslots
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|uint32_t
name|g_head
parameter_list|)
block|{
return|return
operator|(
name|NM_ACCESS_ONCE
argument_list|(
name|kring
operator|->
name|nr_hwtail
argument_list|)
operator|==
name|nm_prev
argument_list|(
name|g_head
argument_list|,
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BUSY_WAIT */
end_comment

begin_comment
comment|/* Handle RX events: from the guest or from the backend */
end_comment

begin_function
specifier|static
name|void
name|ptnetmap_rx_handler
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|is_kthread
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
name|data
decl_stmt|;
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
init|=
operator|(
expr|struct
name|netmap_pt_host_adapter
operator|*
operator|)
name|kring
operator|->
name|na
operator|->
name|na_private
decl_stmt|;
name|struct
name|ptnetmap_state
modifier|*
name|ptns
init|=
name|pth_na
operator|->
name|ptns
decl_stmt|;
name|struct
name|ptnet_ring
name|__user
modifier|*
name|ptring
decl_stmt|;
name|struct
name|netmap_ring
name|shadow_ring
decl_stmt|;
comment|/* shadow copy of the netmap_ring */
name|struct
name|nm_kctx
modifier|*
name|kth
decl_stmt|;
name|uint32_t
name|num_slots
decl_stmt|;
name|int
name|dry_cycles
init|=
literal|0
decl_stmt|;
name|bool
name|some_recvd
init|=
name|false
decl_stmt|;
name|IFRATE
argument_list|(
argument|uint32_t pre_tail
argument_list|)
empty_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|ptns
operator|||
operator|!
name|ptns
operator|->
name|pth_na
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"ERROR ptnetmap state %p, ptnetmap host adapter %p"
argument_list|,
name|ptns
argument_list|,
name|ptns
condition|?
name|ptns
operator|->
name|pth_na
else|:
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|ptns
operator|->
name|stopped
argument_list|)
condition|)
block|{
name|RD
argument_list|(
literal|1
argument_list|,
literal|"backend netmap is being stopped"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"ERROR nm_kr_tryget()"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This is a guess, to be fixed in the rate callback. */
name|IFRATE
argument_list|(
name|ptns
operator|->
name|rate_ctx
operator|.
name|new
operator|.
name|grxk
operator|++
argument_list|)
expr_stmt|;
comment|/* Get RX ptring pointer from the CSB. */
name|ptring
operator|=
name|ptns
operator|->
name|ptrings
operator|+
operator|(
name|pth_na
operator|->
name|up
operator|.
name|num_tx_rings
operator|+
name|kring
operator|->
name|ring_id
operator|)
expr_stmt|;
name|kth
operator|=
name|ptns
operator|->
name|kctxs
index|[
name|pth_na
operator|->
name|up
operator|.
name|num_tx_rings
operator|+
name|kring
operator|->
name|ring_id
index|]
expr_stmt|;
name|num_slots
operator|=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|shadow_ring
operator|.
name|head
operator|=
name|kring
operator|->
name|rhead
expr_stmt|;
name|shadow_ring
operator|.
name|cur
operator|=
name|kring
operator|->
name|rcur
expr_stmt|;
comment|/* Disable notifications. */
name|ptring_kick_enable
argument_list|(
name|ptring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy the guest kring pointers from the CSB */
name|ptnetmap_host_read_kring_csb
argument_list|(
name|ptring
argument_list|,
operator|&
name|shadow_ring
argument_list|,
name|num_slots
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint32_t
name|hwtail
decl_stmt|;
comment|/* Netmap prologue */
name|shadow_ring
operator|.
name|tail
operator|=
name|kring
operator|->
name|rtail
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|nm_rxsync_prologue
argument_list|(
name|kring
argument_list|,
operator|&
name|shadow_ring
argument_list|)
operator|>=
name|num_slots
argument_list|)
condition|)
block|{
comment|/* Reinit ring and enable notifications. */
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|ptring_kick_enable
argument_list|(
name|ptring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|netmap_verbose
operator|&
name|NM_VERB_RXSYNC
argument_list|)
condition|)
block|{
name|ptnetmap_kring_dump
argument_list|(
literal|"pre rxsync"
argument_list|,
name|kring
argument_list|)
expr_stmt|;
block|}
name|IFRATE
argument_list|(
name|pre_tail
operator|=
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|kring
operator|->
name|nm_sync
argument_list|(
name|kring
argument_list|,
name|shadow_ring
operator|.
name|flags
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Reenable notifications. */
name|ptring_kick_enable
argument_list|(
name|ptring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"ERROR rxsync()"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*          * Finalize          * Copy host hwcur and hwtail into the CSB for the guest sync()          */
name|hwtail
operator|=
name|NM_ACCESS_ONCE
argument_list|(
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
name|ptnetmap_host_write_kring_csb
argument_list|(
name|ptring
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|hwtail
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|rtail
operator|!=
name|hwtail
condition|)
block|{
name|kring
operator|->
name|rtail
operator|=
name|hwtail
expr_stmt|;
name|some_recvd
operator|=
name|true
expr_stmt|;
name|dry_cycles
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dry_cycles
operator|++
expr_stmt|;
block|}
name|IFRATE
argument_list|(
name|rate_batch_stats_update
argument_list|(
operator|&
name|ptns
operator|->
name|rate_ctx
operator|.
name|new
operator|.
name|rxbs
argument_list|,
name|pre_tail
argument_list|,
name|kring
operator|->
name|rtail
argument_list|,
name|num_slots
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|netmap_verbose
operator|&
name|NM_VERB_RXSYNC
argument_list|)
condition|)
block|{
name|ptnetmap_kring_dump
argument_list|(
literal|"post rxsync"
argument_list|,
name|kring
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|BUSY_WAIT
comment|/* Interrupt the guest if needed. */
if|if
condition|(
name|some_recvd
operator|&&
name|ptring_intr_enabled
argument_list|(
name|ptring
argument_list|)
condition|)
block|{
comment|/* Disable guest kick to avoid sending unnecessary kicks */
name|ptring_intr_enable
argument_list|(
name|ptring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nm_os_kctx_send_irq
argument_list|(
name|kth
argument_list|)
expr_stmt|;
name|IFRATE
argument_list|(
name|ptns
operator|->
name|rate_ctx
operator|.
name|new
operator|.
name|hrxk
operator|++
argument_list|)
expr_stmt|;
name|some_recvd
operator|=
name|false
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Read CSB to see if there is more work to do. */
name|ptnetmap_host_read_kring_csb
argument_list|(
name|ptring
argument_list|,
operator|&
name|shadow_ring
argument_list|,
name|num_slots
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BUSY_WAIT
if|if
condition|(
name|ptnetmap_norxslots
argument_list|(
name|kring
argument_list|,
name|shadow_ring
operator|.
name|head
argument_list|)
condition|)
block|{
comment|/*              * No more slots available for reception. We enable notification and              * go to sleep, waiting for a kick from the guest when new receive 	     * slots are available.              */
name|usleep_range
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Reenable notifications. */
name|ptring_kick_enable
argument_list|(
name|ptring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Doublecheck. */
name|ptnetmap_host_read_kring_csb
argument_list|(
name|ptring
argument_list|,
operator|&
name|shadow_ring
argument_list|,
name|num_slots
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptnetmap_norxslots
argument_list|(
name|kring
argument_list|,
name|shadow_ring
operator|.
name|head
argument_list|)
condition|)
block|{
comment|/* We won the race condition, more slots are available. Disable 		 * notifications and do another cycle. */
name|ptring_kick_enable
argument_list|(
name|ptring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|hwtail
operator|=
name|NM_ACCESS_ONCE
argument_list|(
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|hwtail
operator|==
name|kring
operator|->
name|rhead
operator|||
name|dry_cycles
operator|>=
name|PTN_RX_DRY_CYCLES_MAX
argument_list|)
condition|)
block|{
comment|/* No more packets to be read from the backend. We stop and 	     * wait for a notification from the backend (netmap_rx_irq). */
name|ND
argument_list|(
literal|1
argument_list|,
literal|"nr_hwtail: %d rhead: %d dry_cycles: %d"
argument_list|,
name|hwtail
argument_list|,
name|kring
operator|->
name|rhead
argument_list|,
name|dry_cycles
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|unlikely
argument_list|(
name|ptns
operator|->
name|stopped
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"backend netmap is being stopped"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
comment|/* Interrupt the guest if needed. */
if|if
condition|(
name|some_recvd
operator|&&
name|ptring_intr_enabled
argument_list|(
name|ptring
argument_list|)
condition|)
block|{
name|ptring_intr_enable
argument_list|(
name|ptring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nm_os_kctx_send_irq
argument_list|(
name|kth
argument_list|)
expr_stmt|;
name|IFRATE
argument_list|(
name|ptns
operator|->
name|rate_ctx
operator|.
name|new
operator|.
name|hrxk
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NETMAP_PT_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ptnetmap_print_configuration
parameter_list|(
name|struct
name|ptnetmap_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|D
argument_list|(
literal|"ptnetmap configuration:"
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"  CSB ptrings @%p, num_rings=%u, cfgtype %08x"
argument_list|,
name|cfg
operator|->
name|ptrings
argument_list|,
name|cfg
operator|->
name|num_rings
argument_list|,
name|cfg
operator|->
name|cfgtype
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|cfg
operator|->
name|num_rings
condition|;
name|k
operator|++
control|)
block|{
switch|switch
condition|(
name|cfg
operator|->
name|cfgtype
condition|)
block|{
case|case
name|PTNETMAP_CFGTYPE_QEMU
case|:
block|{
name|struct
name|ptnetmap_cfgentry_qemu
modifier|*
name|e
init|=
operator|(
expr|struct
name|ptnetmap_cfgentry_qemu
operator|*
operator|)
operator|(
name|cfg
operator|+
literal|1
operator|)
operator|+
name|k
decl_stmt|;
name|D
argument_list|(
literal|"    ring #%d: ioeventfd=%lu, irqfd=%lu"
argument_list|,
name|k
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|e
operator|->
name|ioeventfd
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|e
operator|->
name|irqfd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PTNETMAP_CFGTYPE_BHYVE
case|:
block|{
name|struct
name|ptnetmap_cfgentry_bhyve
modifier|*
name|e
init|=
operator|(
expr|struct
name|ptnetmap_cfgentry_bhyve
operator|*
operator|)
operator|(
name|cfg
operator|+
literal|1
operator|)
operator|+
name|k
decl_stmt|;
name|D
argument_list|(
literal|"    ring #%d: wchan=%lu, ioctl_fd=%lu, "
literal|"ioctl_cmd=%lu, msix_msg_data=%lu, msix_addr=%lu"
argument_list|,
name|k
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|e
operator|->
name|wchan
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|e
operator|->
name|ioctl_fd
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|e
operator|->
name|ioctl_cmd
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|e
operator|->
name|ioctl_data
operator|.
name|msg_data
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|e
operator|->
name|ioctl_data
operator|.
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETMAP_PT_DEBUG */
end_comment

begin_comment
comment|/* Copy actual state of the host ring into the CSB for the guest init */
end_comment

begin_function
specifier|static
name|int
name|ptnetmap_kring_snapshot
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|struct
name|ptnet_ring
name|__user
modifier|*
name|ptring
parameter_list|)
block|{
if|if
condition|(
name|CSB_WRITE
argument_list|(
name|ptring
argument_list|,
name|head
argument_list|,
name|kring
operator|->
name|rhead
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|CSB_WRITE
argument_list|(
name|ptring
argument_list|,
name|cur
argument_list|,
name|kring
operator|->
name|rcur
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|CSB_WRITE
argument_list|(
name|ptring
argument_list|,
name|hwcur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|CSB_WRITE
argument_list|(
name|ptring
argument_list|,
name|hwtail
argument_list|,
name|NM_ACCESS_ONCE
argument_list|(
name|kring
operator|->
name|nr_hwtail
argument_list|)
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|DBG
argument_list|(
argument|ptnetmap_kring_dump(
literal|"ptnetmap_kring_snapshot"
argument|, kring);
argument_list|)
return|return
literal|0
return|;
name|err
label|:
return|return
name|EFAULT
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|netmap_kring
modifier|*
name|ptnetmap_kring
parameter_list|(
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
parameter_list|,
name|int
name|k
parameter_list|)
block|{
if|if
condition|(
name|k
operator|<
name|pth_na
operator|->
name|up
operator|.
name|num_tx_rings
condition|)
block|{
return|return
name|pth_na
operator|->
name|up
operator|.
name|tx_rings
operator|+
name|k
return|;
block|}
return|return
name|pth_na
operator|->
name|up
operator|.
name|rx_rings
operator|+
name|k
operator|-
name|pth_na
operator|->
name|up
operator|.
name|num_tx_rings
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnetmap_krings_snapshot
parameter_list|(
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
parameter_list|)
block|{
name|struct
name|ptnetmap_state
modifier|*
name|ptns
init|=
name|pth_na
operator|->
name|ptns
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|unsigned
name|int
name|num_rings
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|k
decl_stmt|;
name|num_rings
operator|=
name|pth_na
operator|->
name|up
operator|.
name|num_tx_rings
operator|+
name|pth_na
operator|->
name|up
operator|.
name|num_rx_rings
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num_rings
condition|;
name|k
operator|++
control|)
block|{
name|kring
operator|=
name|ptnetmap_kring
argument_list|(
name|pth_na
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|err
operator||=
name|ptnetmap_kring_snapshot
argument_list|(
name|kring
argument_list|,
name|ptns
operator|->
name|ptrings
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * Functions to create kernel contexts, and start/stop the workers.  */
end_comment

begin_function
specifier|static
name|int
name|ptnetmap_create_kctxs
parameter_list|(
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
parameter_list|,
name|struct
name|ptnetmap_cfg
modifier|*
name|cfg
parameter_list|,
name|int
name|use_tx_kthreads
parameter_list|)
block|{
name|struct
name|ptnetmap_state
modifier|*
name|ptns
init|=
name|pth_na
operator|->
name|ptns
decl_stmt|;
name|struct
name|nm_kctx_cfg
name|nmk_cfg
decl_stmt|;
name|unsigned
name|int
name|num_rings
decl_stmt|;
name|uint8_t
modifier|*
name|cfg_entries
init|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|cfg
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|k
decl_stmt|;
name|num_rings
operator|=
name|pth_na
operator|->
name|up
operator|.
name|num_tx_rings
operator|+
name|pth_na
operator|->
name|up
operator|.
name|num_rx_rings
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num_rings
condition|;
name|k
operator|++
control|)
block|{
name|nmk_cfg
operator|.
name|attach_user
operator|=
literal|1
expr_stmt|;
comment|/* attach kthread to user process */
name|nmk_cfg
operator|.
name|worker_private
operator|=
name|ptnetmap_kring
argument_list|(
name|pth_na
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|nmk_cfg
operator|.
name|type
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|pth_na
operator|->
name|up
operator|.
name|num_tx_rings
condition|)
block|{
name|nmk_cfg
operator|.
name|worker_fn
operator|=
name|ptnetmap_tx_handler
expr_stmt|;
name|nmk_cfg
operator|.
name|use_kthread
operator|=
name|use_tx_kthreads
expr_stmt|;
name|nmk_cfg
operator|.
name|notify_fn
operator|=
name|ptnetmap_tx_nothread_notify
expr_stmt|;
block|}
else|else
block|{
name|nmk_cfg
operator|.
name|worker_fn
operator|=
name|ptnetmap_rx_handler
expr_stmt|;
name|nmk_cfg
operator|.
name|use_kthread
operator|=
literal|1
expr_stmt|;
block|}
name|ptns
operator|->
name|kctxs
index|[
name|k
index|]
operator|=
name|nm_os_kctx_create
argument_list|(
operator|&
name|nmk_cfg
argument_list|,
name|cfg
operator|->
name|cfgtype
argument_list|,
name|cfg_entries
operator|+
name|k
operator|*
name|cfg
operator|->
name|entry_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptns
operator|->
name|kctxs
index|[
name|k
index|]
operator|==
name|NULL
condition|)
block|{
goto|goto
name|err
goto|;
block|}
block|}
return|return
literal|0
return|;
name|err
label|:
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num_rings
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|ptns
operator|->
name|kctxs
index|[
name|k
index|]
condition|)
block|{
name|nm_os_kctx_destroy
argument_list|(
name|ptns
operator|->
name|kctxs
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|ptns
operator|->
name|kctxs
index|[
name|k
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|EFAULT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnetmap_start_kctx_workers
parameter_list|(
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
parameter_list|)
block|{
name|struct
name|ptnetmap_state
modifier|*
name|ptns
init|=
name|pth_na
operator|->
name|ptns
decl_stmt|;
name|int
name|num_rings
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|ptns
condition|)
block|{
name|D
argument_list|(
literal|"BUG ptns is NULL"
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
name|ptns
operator|->
name|stopped
operator|=
name|false
expr_stmt|;
name|num_rings
operator|=
name|ptns
operator|->
name|pth_na
operator|->
name|up
operator|.
name|num_tx_rings
operator|+
name|ptns
operator|->
name|pth_na
operator|->
name|up
operator|.
name|num_rx_rings
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num_rings
condition|;
name|k
operator|++
control|)
block|{
comment|//nm_os_kctx_worker_setaff(ptns->kctxs[k], xxx);
name|error
operator|=
name|nm_os_kctx_worker_start
argument_list|(
name|ptns
operator|->
name|kctxs
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptnetmap_stop_kctx_workers
parameter_list|(
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
parameter_list|)
block|{
name|struct
name|ptnetmap_state
modifier|*
name|ptns
init|=
name|pth_na
operator|->
name|ptns
decl_stmt|;
name|int
name|num_rings
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|ptns
condition|)
block|{
comment|/* Nothing to do. */
return|return;
block|}
name|ptns
operator|->
name|stopped
operator|=
name|true
expr_stmt|;
name|num_rings
operator|=
name|ptns
operator|->
name|pth_na
operator|->
name|up
operator|.
name|num_tx_rings
operator|+
name|ptns
operator|->
name|pth_na
operator|->
name|up
operator|.
name|num_rx_rings
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num_rings
condition|;
name|k
operator|++
control|)
block|{
name|nm_os_kctx_worker_stop
argument_list|(
name|ptns
operator|->
name|kctxs
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|ptnetmap_cfg
modifier|*
name|ptnetmap_read_cfg
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
block|{
name|uintptr_t
modifier|*
name|nmr_ptncfg
init|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|nmr
operator|->
name|nr_arg1
decl_stmt|;
name|struct
name|ptnetmap_cfg
modifier|*
name|cfg
decl_stmt|;
name|struct
name|ptnetmap_cfg
name|tmp
decl_stmt|;
name|size_t
name|cfglen
decl_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
operator|*
name|nmr_ptncfg
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"Partial copyin() failed"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cfglen
operator|=
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|+
name|tmp
operator|.
name|num_rings
operator|*
name|tmp
operator|.
name|entry_size
expr_stmt|;
name|cfg
operator|=
name|nm_os_malloc
argument_list|(
name|cfglen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfg
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|copyin
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
operator|*
name|nmr_ptncfg
argument_list|,
name|cfg
argument_list|,
name|cfglen
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"Full copyin() failed"
argument_list|)
expr_stmt|;
name|nm_os_free
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|cfg
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|nm_unused_notify
parameter_list|(
name|struct
name|netmap_kring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nm_pt_host_notify
parameter_list|(
name|struct
name|netmap_kring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Create ptnetmap state and switch parent adapter to ptnetmap mode. */
end_comment

begin_function
specifier|static
name|int
name|ptnetmap_create
parameter_list|(
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
parameter_list|,
name|struct
name|ptnetmap_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|int
name|use_tx_kthreads
init|=
name|ptnetmap_tx_workers
decl_stmt|;
comment|/* snapshot */
name|struct
name|ptnetmap_state
modifier|*
name|ptns
decl_stmt|;
name|unsigned
name|int
name|num_rings
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
comment|/* Check if ptnetmap state is already there. */
if|if
condition|(
name|pth_na
operator|->
name|ptns
condition|)
block|{
name|D
argument_list|(
literal|"ERROR adapter %p already in ptnetmap mode"
argument_list|,
name|pth_na
operator|->
name|parent
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|num_rings
operator|=
name|pth_na
operator|->
name|up
operator|.
name|num_tx_rings
operator|+
name|pth_na
operator|->
name|up
operator|.
name|num_rx_rings
expr_stmt|;
if|if
condition|(
name|num_rings
operator|!=
name|cfg
operator|->
name|num_rings
condition|)
block|{
name|D
argument_list|(
literal|"ERROR configuration mismatch, expected %u rings, found %u"
argument_list|,
name|num_rings
argument_list|,
name|cfg
operator|->
name|num_rings
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
name|use_tx_kthreads
operator|&&
name|na_is_generic
argument_list|(
name|pth_na
operator|->
name|parent
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"ERROR ptnetmap direct transmission not supported with "
literal|"passed-through emulated adapters"
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
name|ptns
operator|=
name|nm_os_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ptns
argument_list|)
operator|+
name|num_rings
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ptns
operator|->
name|kctxs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptns
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
name|ptns
operator|->
name|kctxs
operator|=
operator|(
expr|struct
name|nm_kctx
operator|*
operator|*
operator|)
operator|(
name|ptns
operator|+
literal|1
operator|)
expr_stmt|;
name|ptns
operator|->
name|stopped
operator|=
name|true
expr_stmt|;
comment|/* Cross-link data structures. */
name|pth_na
operator|->
name|ptns
operator|=
name|ptns
expr_stmt|;
name|ptns
operator|->
name|pth_na
operator|=
name|pth_na
expr_stmt|;
comment|/* Store the CSB address provided by the hypervisor. */
name|ptns
operator|->
name|ptrings
operator|=
name|cfg
operator|->
name|ptrings
expr_stmt|;
name|DBG
argument_list|(
name|ptnetmap_print_configuration
argument_list|(
name|cfg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create kernel contexts. */
if|if
condition|(
operator|(
name|ret
operator|=
name|ptnetmap_create_kctxs
argument_list|(
name|pth_na
argument_list|,
name|cfg
argument_list|,
name|use_tx_kthreads
argument_list|)
operator|)
condition|)
block|{
name|D
argument_list|(
literal|"ERROR ptnetmap_create_kctxs()"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Copy krings state into the CSB for the guest initialization */
if|if
condition|(
operator|(
name|ret
operator|=
name|ptnetmap_krings_snapshot
argument_list|(
name|pth_na
argument_list|)
operator|)
condition|)
block|{
name|D
argument_list|(
literal|"ERROR ptnetmap_krings_snapshot()"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Overwrite parent nm_notify krings callback, and      * clear NAF_BDG_MAYSLEEP if needed. */
name|pth_na
operator|->
name|parent
operator|->
name|na_private
operator|=
name|pth_na
expr_stmt|;
name|pth_na
operator|->
name|parent_nm_notify
operator|=
name|pth_na
operator|->
name|parent
operator|->
name|nm_notify
expr_stmt|;
name|pth_na
operator|->
name|parent
operator|->
name|nm_notify
operator|=
name|nm_unused_notify
expr_stmt|;
name|pth_na
operator|->
name|parent_na_flags
operator|=
name|pth_na
operator|->
name|parent
operator|->
name|na_flags
expr_stmt|;
if|if
condition|(
operator|!
name|use_tx_kthreads
condition|)
block|{
comment|/* VALE port txsync is executed under spinlock on Linux, so          * we need to make sure the bridge cannot sleep. */
name|pth_na
operator|->
name|parent
operator|->
name|na_flags
operator|&=
operator|~
name|NAF_BDG_MAYSLEEP
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pth_na
operator|->
name|parent
operator|->
name|num_rx_rings
condition|;
name|i
operator|++
control|)
block|{
name|pth_na
operator|->
name|up
operator|.
name|rx_rings
index|[
name|i
index|]
operator|.
name|save_notify
operator|=
name|pth_na
operator|->
name|up
operator|.
name|rx_rings
index|[
name|i
index|]
operator|.
name|nm_notify
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|rx_rings
index|[
name|i
index|]
operator|.
name|nm_notify
operator|=
name|nm_pt_host_notify
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pth_na
operator|->
name|parent
operator|->
name|num_tx_rings
condition|;
name|i
operator|++
control|)
block|{
name|pth_na
operator|->
name|up
operator|.
name|tx_rings
index|[
name|i
index|]
operator|.
name|save_notify
operator|=
name|pth_na
operator|->
name|up
operator|.
name|tx_rings
index|[
name|i
index|]
operator|.
name|nm_notify
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|tx_rings
index|[
name|i
index|]
operator|.
name|nm_notify
operator|=
name|nm_pt_host_notify
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RATE
name|memset
argument_list|(
operator|&
name|ptns
operator|->
name|rate_ctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ptns
operator|->
name|rate_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|setup_timer
argument_list|(
operator|&
name|ptns
operator|->
name|rate_ctx
operator|.
name|timer
argument_list|,
operator|&
name|rate_callback
argument_list|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|ptns
operator|->
name|rate_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod_timer
argument_list|(
operator|&
name|ptns
operator|->
name|rate_ctx
operator|.
name|timer
argument_list|,
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
literal|1500
argument_list|)
argument_list|)
condition|)
name|D
argument_list|(
literal|"[ptn] Error: mod_timer()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DBG
argument_list|(
name|D
argument_list|(
literal|"[%s] ptnetmap configuration DONE"
argument_list|,
name|pth_na
operator|->
name|up
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
name|pth_na
operator|->
name|ptns
operator|=
name|NULL
expr_stmt|;
name|nm_os_free
argument_list|(
name|ptns
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Switch parent adapter back to normal mode and destroy  * ptnetmap state. */
end_comment

begin_function
specifier|static
name|void
name|ptnetmap_delete
parameter_list|(
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
parameter_list|)
block|{
name|struct
name|ptnetmap_state
modifier|*
name|ptns
init|=
name|pth_na
operator|->
name|ptns
decl_stmt|;
name|int
name|num_rings
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ptns
condition|)
block|{
comment|/* Nothing to do. */
return|return;
block|}
comment|/* Restore parent adapter callbacks. */
name|pth_na
operator|->
name|parent
operator|->
name|nm_notify
operator|=
name|pth_na
operator|->
name|parent_nm_notify
expr_stmt|;
name|pth_na
operator|->
name|parent
operator|->
name|na_private
operator|=
name|NULL
expr_stmt|;
name|pth_na
operator|->
name|parent
operator|->
name|na_flags
operator|=
name|pth_na
operator|->
name|parent_na_flags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pth_na
operator|->
name|parent
operator|->
name|num_rx_rings
condition|;
name|i
operator|++
control|)
block|{
name|pth_na
operator|->
name|up
operator|.
name|rx_rings
index|[
name|i
index|]
operator|.
name|nm_notify
operator|=
name|pth_na
operator|->
name|up
operator|.
name|rx_rings
index|[
name|i
index|]
operator|.
name|save_notify
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|rx_rings
index|[
name|i
index|]
operator|.
name|save_notify
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pth_na
operator|->
name|parent
operator|->
name|num_tx_rings
condition|;
name|i
operator|++
control|)
block|{
name|pth_na
operator|->
name|up
operator|.
name|tx_rings
index|[
name|i
index|]
operator|.
name|nm_notify
operator|=
name|pth_na
operator|->
name|up
operator|.
name|tx_rings
index|[
name|i
index|]
operator|.
name|save_notify
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|tx_rings
index|[
name|i
index|]
operator|.
name|save_notify
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Destroy kernel contexts. */
name|num_rings
operator|=
name|ptns
operator|->
name|pth_na
operator|->
name|up
operator|.
name|num_tx_rings
operator|+
name|ptns
operator|->
name|pth_na
operator|->
name|up
operator|.
name|num_rx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|nm_os_kctx_destroy
argument_list|(
name|ptns
operator|->
name|kctxs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ptns
operator|->
name|kctxs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|IFRATE
argument_list|(
name|del_timer
argument_list|(
operator|&
name|ptns
operator|->
name|rate_ctx
operator|.
name|timer
argument_list|)
argument_list|)
expr_stmt|;
name|nm_os_free
argument_list|(
name|ptns
argument_list|)
expr_stmt|;
name|pth_na
operator|->
name|ptns
operator|=
name|NULL
expr_stmt|;
name|DBG
argument_list|(
name|D
argument_list|(
literal|"[%s] ptnetmap deleted"
argument_list|,
name|pth_na
operator|->
name|up
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called by netmap_ioctl().  * Operation is indicated in nmr->nr_cmd.  *  * Called without NMG_LOCK.  */
end_comment

begin_function
name|int
name|ptnetmap_ctl
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
decl_stmt|;
name|struct
name|ptnetmap_cfg
modifier|*
name|cfg
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|cmd
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|name
operator|=
name|nmr
operator|->
name|nr_name
expr_stmt|;
name|cmd
operator|=
name|nmr
operator|->
name|nr_cmd
expr_stmt|;
name|DBG
argument_list|(
name|D
argument_list|(
literal|"name: %s"
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm_ptnetmap_host_on
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"ERROR Netmap adapter %p is not a ptnetmap host adapter"
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|pth_na
operator|=
operator|(
expr|struct
name|netmap_pt_host_adapter
operator|*
operator|)
name|na
expr_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NETMAP_PT_HOST_CREATE
case|:
comment|/* Read hypervisor configuration from userspace. */
name|cfg
operator|=
name|ptnetmap_read_cfg
argument_list|(
name|nmr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfg
condition|)
break|break;
comment|/* Create ptnetmap state (kctxs, ...) and switch parent 	 * adapter to ptnetmap mode. */
name|error
operator|=
name|ptnetmap_create
argument_list|(
name|pth_na
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
name|nm_os_free
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* Start kthreads. */
name|error
operator|=
name|ptnetmap_start_kctx_workers
argument_list|(
name|pth_na
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|ptnetmap_delete
argument_list|(
name|pth_na
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_PT_HOST_DELETE
case|:
comment|/* Stop kthreads. */
name|ptnetmap_stop_kctx_workers
argument_list|(
name|pth_na
argument_list|)
expr_stmt|;
comment|/* Switch parent adapter back to normal mode and destroy 	 * ptnetmap state (kthreads, ...). */
name|ptnetmap_delete
argument_list|(
name|pth_na
argument_list|)
expr_stmt|;
break|break;
default|default:
name|D
argument_list|(
literal|"ERROR invalid cmd (nmr->nr_cmd) (0x%x)"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
name|done
label|:
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* nm_notify callbacks for ptnetmap */
end_comment

begin_function
specifier|static
name|int
name|nm_pt_host_notify
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
init|=
operator|(
expr|struct
name|netmap_pt_host_adapter
operator|*
operator|)
name|na
operator|->
name|na_private
decl_stmt|;
name|struct
name|ptnetmap_state
modifier|*
name|ptns
decl_stmt|;
name|int
name|k
decl_stmt|;
comment|/* First check that the passthrough port is not being destroyed. */
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|pth_na
argument_list|)
condition|)
block|{
return|return
name|NM_IRQ_COMPLETED
return|;
block|}
name|ptns
operator|=
name|pth_na
operator|->
name|ptns
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|ptns
operator|||
name|ptns
operator|->
name|stopped
argument_list|)
condition|)
block|{
return|return
name|NM_IRQ_COMPLETED
return|;
block|}
name|k
operator|=
name|kring
operator|->
name|ring_id
expr_stmt|;
comment|/* Notify kthreads (wake up if needed) */
if|if
condition|(
name|kring
operator|->
name|tx
operator|==
name|NR_TX
condition|)
block|{
name|ND
argument_list|(
literal|1
argument_list|,
literal|"TX backend irq"
argument_list|)
expr_stmt|;
name|IFRATE
argument_list|(
name|ptns
operator|->
name|rate_ctx
operator|.
name|new
operator|.
name|btxwu
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|k
operator|+=
name|pth_na
operator|->
name|up
operator|.
name|num_tx_rings
expr_stmt|;
name|ND
argument_list|(
literal|1
argument_list|,
literal|"RX backend irq"
argument_list|)
expr_stmt|;
name|IFRATE
argument_list|(
name|ptns
operator|->
name|rate_ctx
operator|.
name|new
operator|.
name|brxwu
operator|++
argument_list|)
expr_stmt|;
block|}
name|nm_os_kctx_worker_wakeup
argument_list|(
name|ptns
operator|->
name|kctxs
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
name|NM_IRQ_COMPLETED
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nm_unused_notify
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|D
argument_list|(
literal|"BUG this should never be called"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_comment
comment|/* nm_config callback for bwrap */
end_comment

begin_function
specifier|static
name|int
name|nm_pt_host_config
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
modifier|*
name|txr
parameter_list|,
name|u_int
modifier|*
name|txd
parameter_list|,
name|u_int
modifier|*
name|rxr
parameter_list|,
name|u_int
modifier|*
name|rxd
parameter_list|)
block|{
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
init|=
operator|(
expr|struct
name|netmap_pt_host_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|parent
init|=
name|pth_na
operator|->
name|parent
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|//XXX: maybe calling parent->nm_config is better
comment|/* forward the request */
name|error
operator|=
name|netmap_update_config
argument_list|(
name|parent
argument_list|)
expr_stmt|;
operator|*
name|rxr
operator|=
name|na
operator|->
name|num_rx_rings
operator|=
name|parent
operator|->
name|num_rx_rings
expr_stmt|;
operator|*
name|txr
operator|=
name|na
operator|->
name|num_tx_rings
operator|=
name|parent
operator|->
name|num_tx_rings
expr_stmt|;
operator|*
name|txd
operator|=
name|na
operator|->
name|num_tx_desc
operator|=
name|parent
operator|->
name|num_tx_desc
expr_stmt|;
operator|*
name|rxd
operator|=
name|na
operator|->
name|num_rx_desc
operator|=
name|parent
operator|->
name|num_rx_desc
expr_stmt|;
name|DBG
argument_list|(
name|D
argument_list|(
literal|"rxr: %d txr: %d txd: %d rxd: %d"
argument_list|,
operator|*
name|rxr
argument_list|,
operator|*
name|txr
argument_list|,
operator|*
name|txd
argument_list|,
operator|*
name|rxd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* nm_krings_create callback for ptnetmap */
end_comment

begin_function
specifier|static
name|int
name|nm_pt_host_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
init|=
operator|(
expr|struct
name|netmap_pt_host_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|parent
init|=
name|pth_na
operator|->
name|parent
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DBG
argument_list|(
name|D
argument_list|(
literal|"%s"
argument_list|,
name|pth_na
operator|->
name|up
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create the parent krings */
name|error
operator|=
name|parent
operator|->
name|nm_krings_create
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* A ptnetmap host adapter points the very same krings      * as its parent adapter. These pointer are used in the      * TX/RX worker functions. */
name|na
operator|->
name|tx_rings
operator|=
name|parent
operator|->
name|tx_rings
expr_stmt|;
name|na
operator|->
name|rx_rings
operator|=
name|parent
operator|->
name|rx_rings
expr_stmt|;
name|na
operator|->
name|tailroom
operator|=
name|parent
operator|->
name|tailroom
expr_stmt|;
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
comment|/* Parent's kring_create function will initialize 	 * its own na->si. We have to init our na->si here. */
name|nm_os_selinfo_init
argument_list|(
operator|&
name|na
operator|->
name|si
index|[
name|t
index|]
argument_list|)
expr_stmt|;
comment|/* Force the mem_rings_create() method to create the 	 * host rings independently on what the regif asked for: 	 * these rings are needed by the guest ptnetmap adapter 	 * anyway. */
name|kring
operator|=
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|]
expr_stmt|;
name|kring
operator|->
name|nr_kflags
operator||=
name|NKR_NEEDRING
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* nm_krings_delete callback for ptnetmap */
end_comment

begin_function
specifier|static
name|void
name|nm_pt_host_krings_delete
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
init|=
operator|(
expr|struct
name|netmap_pt_host_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|parent
init|=
name|pth_na
operator|->
name|parent
decl_stmt|;
name|DBG
argument_list|(
name|D
argument_list|(
literal|"%s"
argument_list|,
name|pth_na
operator|->
name|up
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|parent
operator|->
name|nm_krings_delete
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|na
operator|->
name|tx_rings
operator|=
name|na
operator|->
name|rx_rings
operator|=
name|na
operator|->
name|tailroom
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* nm_register callback */
end_comment

begin_function
specifier|static
name|int
name|nm_pt_host_register
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
init|=
operator|(
expr|struct
name|netmap_pt_host_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|parent
init|=
name|pth_na
operator|->
name|parent
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DBG
argument_list|(
name|D
argument_list|(
literal|"%s onoff %d"
argument_list|,
name|pth_na
operator|->
name|up
operator|.
name|name
argument_list|,
name|onoff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
comment|/* netmap_do_regif has been called on the ptnetmap na.          * We need to pass the information about the          * memory allocator to the parent before          * putting it in netmap mode          */
name|parent
operator|->
name|na_lut
operator|=
name|na
operator|->
name|na_lut
expr_stmt|;
block|}
comment|/* forward the request to the parent */
name|error
operator|=
name|parent
operator|->
name|nm_register
argument_list|(
name|parent
argument_list|,
name|onoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|onoff
condition|)
block|{
name|na
operator|->
name|na_flags
operator||=
name|NAF_NETMAP_ON
operator||
name|NAF_PTNETMAP_HOST
expr_stmt|;
block|}
else|else
block|{
name|ptnetmap_delete
argument_list|(
name|pth_na
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_flags
operator|&=
operator|~
operator|(
name|NAF_NETMAP_ON
operator||
name|NAF_PTNETMAP_HOST
operator|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* nm_dtor callback */
end_comment

begin_function
specifier|static
name|void
name|nm_pt_host_dtor
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
init|=
operator|(
expr|struct
name|netmap_pt_host_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|parent
init|=
name|pth_na
operator|->
name|parent
decl_stmt|;
name|DBG
argument_list|(
name|D
argument_list|(
literal|"%s"
argument_list|,
name|pth_na
operator|->
name|up
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The equivalent of NETMAP_PT_HOST_DELETE if the hypervisor      * didn't do it. */
name|ptnetmap_stop_kctx_workers
argument_list|(
name|pth_na
argument_list|)
expr_stmt|;
name|ptnetmap_delete
argument_list|(
name|pth_na
argument_list|)
expr_stmt|;
name|parent
operator|->
name|na_flags
operator|&=
operator|~
name|NAF_BUSY
expr_stmt|;
name|netmap_adapter_put
argument_list|(
name|pth_na
operator|->
name|parent
argument_list|)
expr_stmt|;
name|pth_na
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* check if nmr is a request for a ptnetmap adapter that we can satisfy */
end_comment

begin_function
name|int
name|netmap_get_pt_host_na
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
modifier|*
name|na
parameter_list|,
name|struct
name|netmap_mem_d
modifier|*
name|nmd
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|nmreq
name|parent_nmr
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|parent
decl_stmt|;
comment|/* target adapter */
name|struct
name|netmap_pt_host_adapter
modifier|*
name|pth_na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Check if it is a request for a ptnetmap adapter */
if|if
condition|(
operator|(
name|nmr
operator|->
name|nr_flags
operator|&
operator|(
name|NR_PTNETMAP_HOST
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|D
argument_list|(
literal|"Requesting a ptnetmap host adapter"
argument_list|)
expr_stmt|;
name|pth_na
operator|=
name|nm_os_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pth_na
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pth_na
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"ERROR malloc"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* first, try to find the adapter that we want to passthrough      * We use the same nmr, after we have turned off the ptnetmap flag.      * In this way we can potentially passthrough everything netmap understands.      */
name|memcpy
argument_list|(
operator|&
name|parent_nmr
argument_list|,
name|nmr
argument_list|,
sizeof|sizeof
argument_list|(
name|parent_nmr
argument_list|)
argument_list|)
expr_stmt|;
name|parent_nmr
operator|.
name|nr_flags
operator|&=
operator|~
operator|(
name|NR_PTNETMAP_HOST
operator|)
expr_stmt|;
name|error
operator|=
name|netmap_get_na
argument_list|(
operator|&
name|parent_nmr
argument_list|,
operator|&
name|parent
argument_list|,
operator|&
name|ifp
argument_list|,
name|nmd
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"parent lookup failed: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|put_out_noputparent
goto|;
block|}
name|DBG
argument_list|(
name|D
argument_list|(
literal|"found parent: %s"
argument_list|,
name|parent
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make sure the interface is not already in use */
if|if
condition|(
name|NETMAP_OWNED_BY_ANY
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"NIC %s busy, cannot ptnetmap"
argument_list|,
name|parent
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|put_out
goto|;
block|}
name|pth_na
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
comment|/* Follow netmap_attach()-like operations for the host      * ptnetmap adapter. */
comment|//XXX pth_na->up.na_flags = parent->na_flags;
name|pth_na
operator|->
name|up
operator|.
name|num_rx_rings
operator|=
name|parent
operator|->
name|num_rx_rings
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|num_tx_rings
operator|=
name|parent
operator|->
name|num_tx_rings
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|num_tx_desc
operator|=
name|parent
operator|->
name|num_tx_desc
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|num_rx_desc
operator|=
name|parent
operator|->
name|num_rx_desc
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|nm_dtor
operator|=
name|nm_pt_host_dtor
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|nm_register
operator|=
name|nm_pt_host_register
expr_stmt|;
comment|/* Reuse parent's adapter txsync and rxsync methods. */
name|pth_na
operator|->
name|up
operator|.
name|nm_txsync
operator|=
name|parent
operator|->
name|nm_txsync
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|nm_rxsync
operator|=
name|parent
operator|->
name|nm_rxsync
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|nm_krings_create
operator|=
name|nm_pt_host_krings_create
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|nm_krings_delete
operator|=
name|nm_pt_host_krings_delete
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|nm_config
operator|=
name|nm_pt_host_config
expr_stmt|;
comment|/* Set the notify method only or convenience, it will never      * be used, since - differently from default krings_create - we      * ptnetmap krings_create callback inits kring->nm_notify      * directly. */
name|pth_na
operator|->
name|up
operator|.
name|nm_notify
operator|=
name|nm_unused_notify
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|nm_mem
operator|=
name|netmap_mem_get
argument_list|(
name|parent
operator|->
name|nm_mem
argument_list|)
expr_stmt|;
name|pth_na
operator|->
name|up
operator|.
name|na_flags
operator||=
name|NAF_HOST_RINGS
expr_stmt|;
name|error
operator|=
name|netmap_attach_common
argument_list|(
operator|&
name|pth_na
operator|->
name|up
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"ERROR netmap_attach_common()"
argument_list|)
expr_stmt|;
goto|goto
name|put_out
goto|;
block|}
operator|*
name|na
operator|=
operator|&
name|pth_na
operator|->
name|up
expr_stmt|;
name|netmap_adapter_get
argument_list|(
operator|*
name|na
argument_list|)
expr_stmt|;
comment|/* set parent busy, because attached for ptnetmap */
name|parent
operator|->
name|na_flags
operator||=
name|NAF_BUSY
expr_stmt|;
name|strncpy
argument_list|(
name|pth_na
operator|->
name|up
operator|.
name|name
argument_list|,
name|parent
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|pth_na
operator|->
name|up
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pth_na
operator|->
name|up
operator|.
name|name
argument_list|,
literal|"-PTN"
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|D
argument_list|(
literal|"%s ptnetmap request DONE"
argument_list|,
name|pth_na
operator|->
name|up
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* drop the reference to the ifp, if any */
if|if
condition|(
name|ifp
condition|)
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|put_out
label|:
name|netmap_adapter_put
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
condition|)
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|put_out_noputparent
label|:
name|nm_os_free
argument_list|(
name|pth_na
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_PTNETMAP_HOST */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_PTNETMAP_GUEST
end_ifdef

begin_comment
comment|/*  * Guest ptnetmap txsync()/rxsync() routines, used in ptnet device drivers.  * These routines are reused across the different operating systems supported  * by netmap.  */
end_comment

begin_comment
comment|/*  * Reconcile host and guest views of the transmit ring.  *  * Guest user wants to transmit packets up to the one before ring->head,  * and guest kernel knows tx_ring->hwcur is the first packet unsent  * by the host kernel.  *  * We push out as many packets as possible, and possibly  * reclaim buffers from previously completed transmission.  *  * Notifications from the host are enabled only if the user guest would  * block (no space in the ring).  */
end_comment

begin_function
name|bool
name|netmap_pt_guest_txsync
parameter_list|(
name|struct
name|ptnet_ring
modifier|*
name|ptring
parameter_list|,
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bool
name|notify
init|=
name|false
decl_stmt|;
comment|/* Disable notifications */
name|ptring
operator|->
name|guest_need_kick
operator|=
literal|0
expr_stmt|;
comment|/* 	 * First part: tell the host (updating the CSB) to process the new 	 * packets. 	 */
name|kring
operator|->
name|nr_hwcur
operator|=
name|ptring
operator|->
name|hwcur
expr_stmt|;
name|ptnetmap_guest_write_kring_csb
argument_list|(
name|ptring
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|rhead
argument_list|)
expr_stmt|;
comment|/* Ask for a kick from a guest to the host if needed. */
if|if
condition|(
operator|(
operator|(
name|kring
operator|->
name|rhead
operator|!=
name|kring
operator|->
name|nr_hwcur
operator|||
name|nm_kr_txempty
argument_list|(
name|kring
argument_list|)
operator|)
operator|&&
name|NM_ACCESS_ONCE
argument_list|(
name|ptring
operator|->
name|host_need_kick
argument_list|)
operator|)
operator|||
operator|(
name|flags
operator|&
name|NAF_FORCE_RECLAIM
operator|)
condition|)
block|{
name|ptring
operator|->
name|sync_flags
operator|=
name|flags
expr_stmt|;
name|notify
operator|=
name|true
expr_stmt|;
block|}
comment|/* 	 * Second part: reclaim buffers for completed transmissions. 	 */
if|if
condition|(
name|nm_kr_txempty
argument_list|(
name|kring
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|NAF_FORCE_RECLAIM
operator|)
condition|)
block|{
name|ptnetmap_guest_read_kring_csb
argument_list|(
name|ptring
argument_list|,
name|kring
argument_list|)
expr_stmt|;
block|}
comment|/*          * No more room in the ring for new transmissions. The user thread will 	 * go to sleep and we need to be notified by the host when more free 	 * space is available.          */
if|if
condition|(
name|nm_kr_txempty
argument_list|(
name|kring
argument_list|)
condition|)
block|{
comment|/* Reenable notifications. */
name|ptring
operator|->
name|guest_need_kick
operator|=
literal|1
expr_stmt|;
comment|/* Double check */
name|ptnetmap_guest_read_kring_csb
argument_list|(
name|ptring
argument_list|,
name|kring
argument_list|)
expr_stmt|;
comment|/* If there is new free space, disable notifications */
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|nm_kr_txempty
argument_list|(
name|kring
argument_list|)
argument_list|)
condition|)
block|{
name|ptring
operator|->
name|guest_need_kick
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|ND
argument_list|(
literal|1
argument_list|,
literal|"%s CSB(head:%u cur:%u hwtail:%u) KRING(head:%u cur:%u tail:%u)"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|ptring
operator|->
name|head
argument_list|,
name|ptring
operator|->
name|cur
argument_list|,
name|ptring
operator|->
name|hwtail
argument_list|,
name|kring
operator|->
name|rhead
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
return|return
name|notify
return|;
block|}
end_function

begin_comment
comment|/*  * Reconcile host and guest view of the receive ring.  *  * Update hwcur/hwtail from host (reading from CSB).  *  * If guest user has released buffers up to the one before ring->head, we  * also give them to the host.  *  * Notifications from the host are enabled only if the user guest would  * block (no more completed slots in the ring).  */
end_comment

begin_function
name|bool
name|netmap_pt_guest_rxsync
parameter_list|(
name|struct
name|ptnet_ring
modifier|*
name|ptring
parameter_list|,
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bool
name|notify
init|=
name|false
decl_stmt|;
comment|/* Disable notifications */
name|ptring
operator|->
name|guest_need_kick
operator|=
literal|0
expr_stmt|;
comment|/* 	 * First part: import newly received packets, by updating the kring 	 * hwtail to the hwtail known from the host (read from the CSB). 	 * This also updates the kring hwcur. 	 */
name|ptnetmap_guest_read_kring_csb
argument_list|(
name|ptring
argument_list|,
name|kring
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_kflags
operator|&=
operator|~
name|NKR_PENDINTR
expr_stmt|;
comment|/* 	 * Second part: tell the host about the slots that guest user has 	 * released, by updating cur and head in the CSB. 	 */
if|if
condition|(
name|kring
operator|->
name|rhead
operator|!=
name|kring
operator|->
name|nr_hwcur
condition|)
block|{
name|ptnetmap_guest_write_kring_csb
argument_list|(
name|ptring
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|rhead
argument_list|)
expr_stmt|;
comment|/* Ask for a kick from the guest to the host if needed. */
if|if
condition|(
name|NM_ACCESS_ONCE
argument_list|(
name|ptring
operator|->
name|host_need_kick
argument_list|)
condition|)
block|{
name|ptring
operator|->
name|sync_flags
operator|=
name|flags
expr_stmt|;
name|notify
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/*          * No more completed RX slots. The user thread will go to sleep and 	 * we need to be notified by the host when more RX slots have been 	 * completed.          */
if|if
condition|(
name|nm_kr_rxempty
argument_list|(
name|kring
argument_list|)
condition|)
block|{
comment|/* Reenable notifications. */
name|ptring
operator|->
name|guest_need_kick
operator|=
literal|1
expr_stmt|;
comment|/* Double check */
name|ptnetmap_guest_read_kring_csb
argument_list|(
name|ptring
argument_list|,
name|kring
argument_list|)
expr_stmt|;
comment|/* If there are new slots, disable notifications. */
if|if
condition|(
operator|!
name|nm_kr_rxempty
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|ptring
operator|->
name|guest_need_kick
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|ND
argument_list|(
literal|1
argument_list|,
literal|"%s CSB(head:%u cur:%u hwtail:%u) KRING(head:%u cur:%u tail:%u)"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|ptring
operator|->
name|head
argument_list|,
name|ptring
operator|->
name|cur
argument_list|,
name|ptring
operator|->
name|hwtail
argument_list|,
name|kring
operator|->
name|rhead
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
return|return
name|notify
return|;
block|}
end_function

begin_comment
comment|/*  * Callbacks for ptnet drivers: nm_krings_create, nm_krings_delete, nm_dtor.  */
end_comment

begin_function
name|int
name|ptnet_nm_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_pt_guest_adapter
modifier|*
name|ptna
init|=
operator|(
expr|struct
name|netmap_pt_guest_adapter
operator|*
operator|)
name|na
decl_stmt|;
comment|/* Upcast. */
name|struct
name|netmap_adapter
modifier|*
name|na_nm
init|=
operator|&
name|ptna
operator|->
name|hwup
operator|.
name|up
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na_dr
init|=
operator|&
name|ptna
operator|->
name|dr
operator|.
name|up
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|ptna
operator|->
name|backend_regifs
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* Create krings on the public netmap adapter. */
name|ret
operator|=
name|netmap_hw_krings_create
argument_list|(
name|na_nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
return|return
name|ret
return|;
block|}
comment|/* Copy krings into the netmap adapter private to the driver. */
name|na_dr
operator|->
name|tx_rings
operator|=
name|na_nm
operator|->
name|tx_rings
expr_stmt|;
name|na_dr
operator|->
name|rx_rings
operator|=
name|na_nm
operator|->
name|rx_rings
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ptnet_nm_krings_delete
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_pt_guest_adapter
modifier|*
name|ptna
init|=
operator|(
expr|struct
name|netmap_pt_guest_adapter
operator|*
operator|)
name|na
decl_stmt|;
comment|/* Upcast. */
name|struct
name|netmap_adapter
modifier|*
name|na_nm
init|=
operator|&
name|ptna
operator|->
name|hwup
operator|.
name|up
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na_dr
init|=
operator|&
name|ptna
operator|->
name|dr
operator|.
name|up
decl_stmt|;
if|if
condition|(
name|ptna
operator|->
name|backend_regifs
condition|)
block|{
return|return;
block|}
name|na_dr
operator|->
name|tx_rings
operator|=
name|NULL
expr_stmt|;
name|na_dr
operator|->
name|rx_rings
operator|=
name|NULL
expr_stmt|;
name|netmap_hw_krings_delete
argument_list|(
name|na_nm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ptnet_nm_dtor
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_pt_guest_adapter
modifier|*
name|ptna
init|=
operator|(
expr|struct
name|netmap_pt_guest_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|netmap_mem_put
argument_list|(
name|ptna
operator|->
name|dr
operator|.
name|up
operator|.
name|nm_mem
argument_list|)
expr_stmt|;
comment|// XXX is this needed?
name|memset
argument_list|(
operator|&
name|ptna
operator|->
name|dr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ptna
operator|->
name|dr
argument_list|)
argument_list|)
expr_stmt|;
name|netmap_mem_pt_guest_ifp_del
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
name|na
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|netmap_pt_guest_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|csb
parameter_list|,
name|unsigned
name|int
name|nifp_offset
parameter_list|,
name|unsigned
name|int
name|memid
parameter_list|)
block|{
name|struct
name|netmap_pt_guest_adapter
modifier|*
name|ptna
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|arg
condition|?
name|arg
operator|->
name|ifp
else|:
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* get allocator */
name|arg
operator|->
name|nm_mem
operator|=
name|netmap_mem_pt_guest_new
argument_list|(
name|ifp
argument_list|,
name|nifp_offset
argument_list|,
name|memid
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|nm_mem
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|arg
operator|->
name|na_flags
operator||=
name|NAF_MEM_OWNER
expr_stmt|;
name|error
operator|=
name|netmap_attach_ext
argument_list|(
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_pt_guest_adapter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* get the netmap_pt_guest_adapter */
name|ptna
operator|=
operator|(
expr|struct
name|netmap_pt_guest_adapter
operator|*
operator|)
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ptna
operator|->
name|csb
operator|=
name|csb
expr_stmt|;
comment|/* Initialize a separate pass-through netmap adapter that is going to 	 * be used by the ptnet driver only, and so never exposed to netmap          * applications. We only need a subset of the available fields. */
name|memset
argument_list|(
operator|&
name|ptna
operator|->
name|dr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ptna
operator|->
name|dr
argument_list|)
argument_list|)
expr_stmt|;
name|ptna
operator|->
name|dr
operator|.
name|up
operator|.
name|ifp
operator|=
name|ifp
expr_stmt|;
name|ptna
operator|->
name|dr
operator|.
name|up
operator|.
name|nm_mem
operator|=
name|netmap_mem_get
argument_list|(
name|ptna
operator|->
name|hwup
operator|.
name|up
operator|.
name|nm_mem
argument_list|)
expr_stmt|;
name|ptna
operator|->
name|dr
operator|.
name|up
operator|.
name|nm_config
operator|=
name|ptna
operator|->
name|hwup
operator|.
name|up
operator|.
name|nm_config
expr_stmt|;
name|ptna
operator|->
name|backend_regifs
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_PTNETMAP_GUEST */
end_comment

end_unit

