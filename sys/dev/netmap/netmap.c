begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011-2013 Matteo Landi, Luigi Rizzo. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  *  * This module supports memory mapped access to network devices,  * see netmap(4).  *  * The module uses a large, memory pool allocated by the kernel  * and accessible as mmapped memory by multiple userspace threads/processes.  * The memory pool contains packet buffers and "netmap rings",  * i.e. user-accessible copies of the interface's queues.  *  * Access to the network card works like this:  * 1. a process/thread issues one or more open() on /dev/netmap, to create  *    select()able file descriptor on which events are reported.  * 2. on each descriptor, the process issues an ioctl() to identify  *    the interface that should report events to the file descriptor.  * 3. on each descriptor, the process issues an mmap() request to  *    map the shared memory region within the process' address space.  *    The list of interesting queues is indicated by a location in  *    the shared memory region.  * 4. using the functions in the netmap(4) userspace API, a process  *    can look up the occupation state of a queue, access memory buffers,  *    and retrieve received packets or enqueue packets to transmit.  * 5. using some ioctl()s the process can synchronize the userspace view  *    of the queue with the actual status in the kernel. This includes both  *    receiving the notification of new packets, and transmitting new  *    packets on the output interface.  * 6. select() or poll() can be used to wait for events on individual  *    transmit or receive queues (or all queues for a given interface).  *  		SYNCHRONIZATION (USER)  The netmap rings and data structures may be shared among multiple user threads or even independent processes. Any synchronization among those threads/processes is delegated to the threads themselves. Only one thread at a time can be in a system call on the same netmap ring. The OS does not enforce this and only guarantees against system crashes in case of invalid usage.  		LOCKING (INTERNAL)  Within the kernel, access to the netmap rings is protected as follows:  - a spinlock on each ring, to handle producer/consumer races on   RX rings attached to the host stack (against multiple host   threads writing from the host stack to the same ring),   and on 'destination' rings attached to a VALE switch   (i.e. RX rings in VALE ports, and TX rings in NIC/host ports)   protecting multiple active senders for the same destination)  - an atomic variable to guarantee that there is at most one   instance of *_*xsync() on the ring at any time.   For rings connected to user file   descriptors, an atomic_test_and_set() protects this, and the   lock on the ring is not actually used.   For NIC RX rings connected to a VALE switch, an atomic_test_and_set()   is also used to prevent multiple executions (the driver might indeed   already guarantee this).   For NIC TX rings connected to a VALE switch, the lock arbitrates   access to the queue (both when allocating buffers and when pushing   them out).  - *xsync() should be protected against initializations of the card.   On FreeBSD most devices have the reset routine protected by   a RING lock (ixgbe, igb, em) or core lock (re). lem is missing   the RING protection on rx_reset(), this should be added.    On linux there is an external lock on the tx path, which probably   also arbitrates access to the reset routine. XXX to be revised  - a per-interface core_lock protecting access from the host stack   while interfaces may be detached from netmap mode.   XXX there should be no need for this lock if we detach the interfaces   only while they are down.   --- VALE SWITCH ---  NMG_LOCK() serializes all modifications to switches and ports. A switch cannot be deleted until all ports are gone.  For each switch, an SX lock (RWlock on linux) protects deletion of ports. When configuring or deleting a new port, the lock is acquired in exclusive mode (after holding NMG_LOCK). When forwarding, the lock is acquired in shared mode (without NMG_LOCK). The lock is held throughout the entire forwarding cycle, during which the thread may incur in a page fault. Hence it is important that sleepable shared locks are used.  On the rx ring, the per-port lock is grabbed initially to reserve a number of slot in the ring, then the lock is released, packets are copied from source to destination, and then the lock is acquired again and the receive ring is updated. (A similar thing is done on the tx ring for NIC and host stack ports attached to the switch)   */
end_comment

begin_comment
comment|/*  * OS-specific code that is used only within this file.  * Other OS-specific code that must be accessed by drivers  * is present in netmap_kern.h  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* defines used in kernel.h */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* types used in module initialization */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_comment
comment|/* cdevsw struct, UID, GID */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_comment
comment|/* struct socket */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/* BIOCIMMEDIATE */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* */
end_comment

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_comment
comment|/* reduce conditional code */
end_comment

begin_define
define|#
directive|define
name|init_waitqueue_head
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
comment|// only needed in linux
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|linux
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"bsd_glue.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_elif

begin_warning
warning|#
directive|warning
warning|OSX support is only partial
end_warning

begin_include
include|#
directive|include
file|"osx_glue.h"
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|Unsupported platform
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unsupported */
end_comment

begin_comment
comment|/*  * common headers  */
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_mem2.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETMAP
argument_list|,
literal|"netmap"
argument_list|,
literal|"Network memory map"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The following variables are used by the drivers and replicate  * fields in the global memory pool. They only refer to buffers  * used by physical interfaces.  */
end_comment

begin_decl_stmt
name|u_int
name|netmap_total_buffers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|netmap_buf_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|netmap_buffer_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* also address of an invalid buffer */
end_comment

begin_comment
comment|/* user-controlled variables */
end_comment

begin_decl_stmt
name|int
name|netmap_verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|netmap_no_timestamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't timestamp on rxsync */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_dev
argument_list|,
name|OID_AUTO
argument_list|,
name|netmap
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Netmap args"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_verbose
argument_list|,
literal|0
argument_list|,
literal|"Verbose mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_timestamp
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_no_timestamp
argument_list|,
literal|0
argument_list|,
literal|"no_timestamp"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_mitigate
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|mitigate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_mitigate
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_no_pendintr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_pendintr
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_no_pendintr
argument_list|,
literal|0
argument_list|,
literal|"Always look for new received packets."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_txsync_retry
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|txsync_retry
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_txsync_retry
argument_list|,
literal|0
argument_list|,
literal|"Number of txsync loops in bridge's flush."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flags */
end_comment

begin_decl_stmt
name|int
name|netmap_fwd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* force transparent mode */
end_comment

begin_decl_stmt
name|int
name|netmap_mmap_unreg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* allow mmap of unregistered fds */
end_comment

begin_comment
comment|/*  * netmap_admode selects the netmap mode to use.  * Invalid values are reset to NETMAP_ADMODE_BEST  */
end_comment

begin_enum
enum|enum
block|{
name|NETMAP_ADMODE_BEST
init|=
literal|0
block|,
comment|/* use native, fallback to generic */
name|NETMAP_ADMODE_NATIVE
block|,
comment|/* either native or none */
name|NETMAP_ADMODE_GENERIC
block|,
comment|/* force generic */
name|NETMAP_ADMODE_LAST
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|NETMAP_ADMODE_NATIVE
value|1
end_define

begin_comment
comment|/* Force native netmap adapter. */
end_comment

begin_define
define|#
directive|define
name|NETMAP_ADMODE_GENERIC
value|2
end_define

begin_comment
comment|/* Force generic netmap adapter. */
end_comment

begin_define
define|#
directive|define
name|NETMAP_ADMODE_BEST
value|0
end_define

begin_comment
comment|/* Priority to native netmap adapter. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|netmap_admode
init|=
name|NETMAP_ADMODE_BEST
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|netmap_generic_mit
init|=
literal|100
operator|*
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generic mitigation interval in nanoseconds. */
end_comment

begin_decl_stmt
name|int
name|netmap_generic_ringsize
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generic ringsize. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|flags
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_flags
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|fwd
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_fwd
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|mmap_unreg
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_mmap_unreg
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|admode
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_admode
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|generic_mit
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_generic_mit
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|generic_ringsize
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_generic_ringsize
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|NMG_LOCK_T
name|netmap_global_lock
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|nm_kr_get
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kr
parameter_list|)
block|{
while|while
condition|(
name|NM_ATOMIC_TEST_AND_SET
argument_list|(
operator|&
name|kr
operator|->
name|nr_busy
argument_list|)
condition|)
name|tsleep
argument_list|(
name|kr
argument_list|,
literal|0
argument_list|,
literal|"NM_KR_GET"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|netmap_disable_ring
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kr
parameter_list|)
block|{
name|kr
operator|->
name|nkr_stopped
operator|=
literal|1
expr_stmt|;
name|nm_kr_get
argument_list|(
name|kr
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|kr
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|kr
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|nm_kr_put
argument_list|(
name|kr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_set_all_rings
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|stopped
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
return|return;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|na
operator|->
name|num_tx_rings
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stopped
condition|)
name|netmap_disable_ring
argument_list|(
name|na
operator|->
name|tx_rings
operator|+
name|i
argument_list|)
expr_stmt|;
else|else
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|nkr_stopped
operator|=
literal|0
expr_stmt|;
name|na
operator|->
name|nm_notify
argument_list|(
name|na
argument_list|,
name|i
argument_list|,
name|NR_TX
argument_list|,
name|NAF_DISABLE_NOTIFY
operator||
operator|(
name|i
operator|==
name|na
operator|->
name|num_tx_rings
condition|?
name|NAF_GLOBAL_NOTIFY
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|na
operator|->
name|num_rx_rings
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stopped
condition|)
name|netmap_disable_ring
argument_list|(
name|na
operator|->
name|rx_rings
operator|+
name|i
argument_list|)
expr_stmt|;
else|else
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nkr_stopped
operator|=
literal|0
expr_stmt|;
name|na
operator|->
name|nm_notify
argument_list|(
name|na
argument_list|,
name|i
argument_list|,
name|NR_RX
argument_list|,
name|NAF_DISABLE_NOTIFY
operator||
operator|(
name|i
operator|==
name|na
operator|->
name|num_rx_rings
condition|?
name|NAF_GLOBAL_NOTIFY
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|netmap_disable_all_rings
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|netmap_set_all_rings
argument_list|(
name|ifp
argument_list|,
literal|1
comment|/* stopped */
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|netmap_enable_all_rings
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|netmap_set_all_rings
argument_list|(
name|ifp
argument_list|,
literal|0
comment|/* enabled */
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * generic bound_checking function  */
end_comment

begin_function
name|u_int
name|nm_bound_var
parameter_list|(
name|u_int
modifier|*
name|v
parameter_list|,
name|u_int
name|dflt
parameter_list|,
name|u_int
name|lo
parameter_list|,
name|u_int
name|hi
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|u_int
name|oldv
init|=
operator|*
name|v
decl_stmt|;
specifier|const
name|char
modifier|*
name|op
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dflt
operator|<
name|lo
condition|)
name|dflt
operator|=
name|lo
expr_stmt|;
if|if
condition|(
name|dflt
operator|>
name|hi
condition|)
name|dflt
operator|=
name|hi
expr_stmt|;
if|if
condition|(
name|oldv
operator|<
name|lo
condition|)
block|{
operator|*
name|v
operator|=
name|dflt
expr_stmt|;
name|op
operator|=
literal|"Bump"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldv
operator|>
name|hi
condition|)
block|{
operator|*
name|v
operator|=
name|hi
expr_stmt|;
name|op
operator|=
literal|"Clamp"
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&&
name|msg
condition|)
name|printf
argument_list|(
literal|"%s %s to %d (was %d)\n"
argument_list|,
name|op
argument_list|,
name|msg
argument_list|,
operator|*
name|v
argument_list|,
name|oldv
argument_list|)
expr_stmt|;
return|return
operator|*
name|v
return|;
block|}
end_function

begin_comment
comment|/*  * packet-dump function, user-supplied or static buffer.  * The destination buffer must be at least 30+4*len  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|nm_dump_buf
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|lim
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|)
block|{
specifier|static
name|char
name|_dst
index|[
literal|8192
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|i0
decl_stmt|;
specifier|static
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|char
modifier|*
name|o
decl_stmt|;
comment|/* output position */
define|#
directive|define
name|P_HI
parameter_list|(
name|x
parameter_list|)
value|hex[((x)& 0xf0)>>4]
define|#
directive|define
name|P_LO
parameter_list|(
name|x
parameter_list|)
value|hex[((x)& 0xf)]
define|#
directive|define
name|P_C
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0x20&& (x)<= 0x7e ? (x) : '.')
if|if
condition|(
operator|!
name|dst
condition|)
name|dst
operator|=
name|_dst
expr_stmt|;
if|if
condition|(
name|lim
operator|<=
literal|0
operator|||
name|lim
operator|>
name|len
condition|)
name|lim
operator|=
name|len
expr_stmt|;
name|o
operator|=
name|dst
expr_stmt|;
name|sprintf
argument_list|(
name|o
argument_list|,
literal|"buf 0x%p len %d lim %d\n"
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|o
operator|+=
name|strlen
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* hexdump routine */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
control|)
block|{
name|sprintf
argument_list|(
name|o
argument_list|,
literal|"%5d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|o
operator|+=
name|strlen
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|o
argument_list|,
literal|' '
argument_list|,
literal|48
argument_list|)
expr_stmt|;
name|i0
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|<
name|lim
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|o
index|[
name|j
operator|*
literal|3
index|]
operator|=
name|P_HI
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|o
index|[
name|j
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|P_LO
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|i0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|<
name|lim
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|o
index|[
name|j
operator|+
literal|48
index|]
operator|=
name|P_C
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|o
index|[
name|j
operator|+
literal|48
index|]
operator|=
literal|'\n'
expr_stmt|;
name|o
operator|+=
name|j
operator|+
literal|49
expr_stmt|;
block|}
operator|*
name|o
operator|=
literal|'\0'
expr_stmt|;
undef|#
directive|undef
name|P_HI
undef|#
directive|undef
name|P_LO
undef|#
directive|undef
name|P_C
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch configuration from the device, to cope with dynamic  * reconfigurations after loading the module.  */
end_comment

begin_function
name|int
name|netmap_update_config
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|u_int
name|txr
decl_stmt|,
name|txd
decl_stmt|,
name|rxr
decl_stmt|,
name|rxd
decl_stmt|;
name|txr
operator|=
name|txd
operator|=
name|rxr
operator|=
name|rxd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_config
condition|)
block|{
name|na
operator|->
name|nm_config
argument_list|(
name|na
argument_list|,
operator|&
name|txr
argument_list|,
operator|&
name|txd
argument_list|,
operator|&
name|rxr
argument_list|,
operator|&
name|rxd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* take whatever we had at init time */
name|txr
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|txd
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|rxr
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|rxd
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|==
name|txr
operator|&&
name|na
operator|->
name|num_tx_desc
operator|==
name|txd
operator|&&
name|na
operator|->
name|num_rx_rings
operator|==
name|rxr
operator|&&
name|na
operator|->
name|num_rx_desc
operator|==
name|rxd
condition|)
return|return
literal|0
return|;
comment|/* nothing changed */
if|if
condition|(
name|netmap_verbose
operator|||
name|na
operator|->
name|active_fds
operator|>
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"stored config %s: txring %d x %d, rxring %d x %d"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|na
operator|->
name|num_tx_rings
argument_list|,
name|na
operator|->
name|num_tx_desc
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|,
name|na
operator|->
name|num_rx_desc
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"new config %s: txring %d x %d, rxring %d x %d"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|txr
argument_list|,
name|txd
argument_list|,
name|rxr
argument_list|,
name|rxd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"configuration changed (but fine)"
argument_list|)
expr_stmt|;
name|na
operator|->
name|num_tx_rings
operator|=
name|txr
expr_stmt|;
name|na
operator|->
name|num_tx_desc
operator|=
name|txd
expr_stmt|;
name|na
operator|->
name|num_rx_rings
operator|=
name|rxr
expr_stmt|;
name|na
operator|->
name|num_rx_desc
operator|=
name|rxd
expr_stmt|;
return|return
literal|0
return|;
block|}
name|D
argument_list|(
literal|"configuration changed while active, this is bad..."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|netmap_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ntx
parameter_list|,
name|u_int
name|nrx
parameter_list|,
name|u_int
name|tailroom
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|ndesc
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|len
operator|=
operator|(
name|ntx
operator|+
name|nrx
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_kring
argument_list|)
operator|+
name|tailroom
expr_stmt|;
name|na
operator|->
name|tx_rings
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|tx_rings
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"Cannot allocate krings"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|na
operator|->
name|rx_rings
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|ntx
expr_stmt|;
name|ndesc
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntx
condition|;
name|i
operator|++
control|)
block|{
comment|/* Transmit rings */
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|bzero
argument_list|(
name|kring
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kring
argument_list|)
argument_list|)
expr_stmt|;
name|kring
operator|->
name|na
operator|=
name|na
expr_stmt|;
name|kring
operator|->
name|nkr_num_slots
operator|=
name|ndesc
expr_stmt|;
comment|/* 		 * IMPORTANT: 		 * Always keep one slot empty, so we can detect new 		 * transmissions comparing cur and nr_hwcur (they are 		 * the same only if there are no new transmissions). 		 */
name|kring
operator|->
name|nr_hwavail
operator|=
name|ndesc
operator|-
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|,
literal|"nm_txq_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|init_waitqueue_head
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
block|}
name|ndesc
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrx
condition|;
name|i
operator|++
control|)
block|{
comment|/* Receive rings */
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|bzero
argument_list|(
name|kring
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kring
argument_list|)
argument_list|)
expr_stmt|;
name|kring
operator|->
name|na
operator|=
name|na
expr_stmt|;
name|kring
operator|->
name|nkr_num_slots
operator|=
name|ndesc
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|,
literal|"nm_rxq_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|init_waitqueue_head
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
block|}
name|init_waitqueue_head
argument_list|(
operator|&
name|na
operator|->
name|tx_si
argument_list|)
expr_stmt|;
name|init_waitqueue_head
argument_list|(
operator|&
name|na
operator|->
name|rx_si
argument_list|)
expr_stmt|;
name|na
operator|->
name|tailroom
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|nrx
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|netmap_krings_delete
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|na
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|na
operator|->
name|tx_rings
operator|=
name|na
operator|->
name|rx_rings
operator|=
name|na
operator|->
name|tailroom
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|netmap_if
modifier|*
name|netmap_if_new
parameter_list|(
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
if|if
condition|(
name|netmap_update_config
argument_list|(
name|na
argument_list|)
condition|)
block|{
comment|/* configuration mismatch, report and fail */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|na
operator|->
name|active_fds
condition|)
goto|goto
name|final
goto|;
if|if
condition|(
name|na
operator|->
name|nm_krings_create
argument_list|(
name|na
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|netmap_mem_rings_create
argument_list|(
name|na
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
name|final
label|:
name|nifp
operator|=
name|netmap_mem_if_new
argument_list|(
name|ifname
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
return|return
operator|(
name|nifp
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
block|{
name|netmap_mem_rings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* grab a reference to the memory allocator, if we don't have one already.  The  * reference is taken from the netmap_adapter registered with the priv.  *  */
end_comment

begin_function
specifier|static
name|int
name|netmap_get_memory_locked
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|netmap_mem_d
modifier|*
name|nmd
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|np_na
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|netmap_mmap_unreg
condition|)
return|return
name|ENODEV
return|;
comment|/* for compatibility with older versions of the API  		 * we use the global allocator when no interface has been  		 * registered  		 */
name|nmd
operator|=
operator|&
name|nm_mem
expr_stmt|;
block|}
else|else
block|{
name|nmd
operator|=
name|p
operator|->
name|np_na
operator|->
name|nm_mem
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|np_mref
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|netmap_mem_finalize
argument_list|(
name|nmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|p
operator|->
name|np_mref
operator|=
name|nmd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|np_mref
operator|!=
name|nmd
condition|)
block|{
comment|/* a virtual port has been registered, but previous  		 * syscalls already used the global allocator.  		 * We cannot continue  		 */
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|netmap_get_memory
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_get_memory_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_have_memory_locked
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|p
parameter_list|)
block|{
return|return
name|p
operator|->
name|np_mref
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_drop_memory_locked
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|np_mref
condition|)
block|{
name|netmap_mem_deref
argument_list|(
name|p
operator|->
name|np_mref
argument_list|)
expr_stmt|;
name|p
operator|->
name|np_mref
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * File descriptor's private data destructor.  *  * Call nm_register(ifp,0) to stop netmap mode on the interface and  * revert to normal operation. We expect that np_na->ifp has not gone.  * The second argument is the nifp to work on. In some cases it is  * not attached yet to the netmap_priv_d so we need to pass it as  * a separate argument.  */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
specifier|static
name|void
name|netmap_do_unregif
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|struct
name|netmap_if
modifier|*
name|nifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|na
operator|->
name|active_fds
operator|--
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|active_fds
operator|<=
literal|0
condition|)
block|{
comment|/* last instance */
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"deleting last instance for %s"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * (TO CHECK) This function is only called 		 * when the last reference to this file descriptor goes 		 * away. This means we cannot have any pending poll() 		 * or interrupt routine operating on the structure. 		 * XXX The file may be closed in a thread while 		 * another thread is using it. 		 * Linux keeps the file opened until the last reference 		 * by any outstanding ioctl/poll or mmap is gone. 		 * FreeBSD does not track mmap()s (but we do) and 		 * wakes up any sleeping poll(). Need to check what 		 * happens if the close() occurs while a concurrent 		 * syscall is running. 		 */
if|if
condition|(
name|ifp
condition|)
name|na
operator|->
name|nm_register
argument_list|(
name|na
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* off, clear flags */
comment|/* Wake up any sleeping threads. netmap_poll will 		 * then return POLLERR 		 * XXX The wake up now must happen during *_down(), when 		 * we order all activities to stop. -gl 		 */
comment|/* XXX kqueue(9) needed; these will mirror knlist_init. */
comment|/* knlist_destroy(&na->tx_si.si_note); */
comment|/* knlist_destroy(&na->rx_si.si_note); */
comment|/* delete rings and buffers */
name|netmap_mem_rings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
comment|/* delete the nifp */
name|netmap_mem_if_delete
argument_list|(
name|na
argument_list|,
name|nifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * returns 1 if this is the last instance and we can free priv  */
end_comment

begin_function
name|int
name|netmap_dtor_locked
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* 	 * np_refcount is the number of active mmaps on 	 * this file descriptor 	 */
if|if
condition|(
operator|--
name|priv
operator|->
name|np_refcount
operator|>
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* __FreeBSD__ */
if|if
condition|(
operator|!
name|na
condition|)
block|{
return|return
literal|1
return|;
comment|//XXX is it correct?
block|}
name|netmap_do_unregif
argument_list|(
name|priv
argument_list|,
name|priv
operator|->
name|np_nifp
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_nifp
operator|=
name|NULL
expr_stmt|;
name|netmap_drop_memory_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_na
condition|)
block|{
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_na
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|netmap_dtor
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|data
decl_stmt|;
name|int
name|last_instance
decl_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|last_instance
operator|=
name|netmap_dtor_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_instance
condition|)
block|{
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for safety */
name|free
argument_list|(
name|priv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handlers for synchronization of the queues from/to the host.  * Netmap has two operating modes:  * - in the default mode, the rings connected to the host stack are  *   just another ring pair managed by userspace;  * - in transparent mode (XXX to be defined) incoming packets  *   (from the host or the NIC) are marked as NS_FORWARD upon  *   arrival, and the user application has a chance to reset the  *   flag for packets that should be dropped.  *   On the RXSYNC or poll(), packets in RX rings between  *   kring->nr_kcur and ring->cur with NS_FORWARD still set are moved  *   to the other side.  * The transfer NIC --> host is relatively easy, just encapsulate  * into mbufs and we are done. The host --> NIC side is slightly  * harder because there might not be room in the tx ring so it  * might take a while before releasing the buffer.  */
end_comment

begin_comment
comment|/*  * pass a chain of buffers to the host stack as coming from 'dst'  */
end_comment

begin_function
specifier|static
name|void
name|netmap_send_up
parameter_list|(
name|struct
name|ifnet
modifier|*
name|dst
parameter_list|,
name|struct
name|mbq
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* send packets up, outside the lock */
while|while
condition|(
operator|(
name|m
operator|=
name|mbq_dequeue
argument_list|(
name|q
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"sending up pkt %p size %d"
argument_list|,
name|m
argument_list|,
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|NM_SEND_UP
argument_list|(
name|dst
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|mbq_destroy
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * put a copy of the buffers marked NS_FORWARD into an mbuf chain.  * Run from hwcur to cur - reserved  */
end_comment

begin_function
specifier|static
name|void
name|netmap_grab_packets
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|struct
name|mbq
modifier|*
name|q
parameter_list|,
name|int
name|force
parameter_list|)
block|{
comment|/* Take packets from hwcur to cur-reserved and pass them up. 	 * In case of no buffers we give up. At the end of the loop, 	 * the queue is drained in all cases. 	 * XXX handle reserved 	 */
name|u_int
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|k
init|=
name|kring
operator|->
name|ring
operator|->
name|cur
decl_stmt|,
name|n
init|=
name|kring
operator|->
name|ring
operator|->
name|reserved
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
comment|/* compute the final position, ring->cur - ring->reserved */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|k
operator|<
name|n
condition|)
name|k
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|k
operator|+=
name|n
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
name|kring
operator|->
name|nr_hwcur
init|;
name|n
operator|!=
name|k
condition|;
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|n
index|]
decl_stmt|;
name|n
operator|=
name|nm_next
argument_list|(
name|n
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_FORWARD
operator|)
operator|==
literal|0
operator|&&
operator|!
name|force
condition|)
continue|continue;
if|if
condition|(
name|slot
operator|->
name|len
operator|<
literal|14
operator|||
name|slot
operator|->
name|len
operator|>
name|NETMAP_BDG_BUF_SIZE
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"bad pkt at %d len %d"
argument_list|,
name|n
argument_list|,
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_FORWARD
expr_stmt|;
comment|// XXX needed ?
comment|/* XXX adapt to the case of a multisegment packet */
name|m
operator|=
name|m_devget
argument_list|(
name|BDG_NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
argument_list|,
name|slot
operator|->
name|len
argument_list|,
literal|0
argument_list|,
name|na
operator|->
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|mbq_enqueue
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The host ring has packets from nr_hwcur to (cur - reserved)  * to be sent down to the NIC.  * We need to use the queue lock on the source (host RX ring)  * to protect against netmap_transmit.  * If the user is well behaved we do not need to acquire locks  * on the destination(s),  * so we only need to make sure that there are no panics because  * of user errors.  * XXX verify  *  * We scan the tx rings, which have just been  * flushed so nr_hwcur == cur. Pushing packets down means  * increment cur and decrement avail.  * XXX to be verified  */
end_comment

begin_function
specifier|static
name|void
name|netmap_sw_to_nic
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|k1
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
literal|0
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|howmany
decl_stmt|,
name|src_lim
decl_stmt|,
name|dst_lim
decl_stmt|;
comment|/* XXX we should also check that the carrier is on */
if|if
condition|(
name|kring
operator|->
name|nkr_stopped
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nkr_stopped
condition|)
goto|goto
name|out
goto|;
name|howmany
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
comment|/* XXX otherwise cur - reserved - nr_hwcur */
name|src_lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|howmany
operator|>
literal|0
operator|&&
name|i
operator|<
name|na
operator|->
name|num_tx_rings
condition|;
name|i
operator|++
operator|,
name|k1
operator|++
control|)
block|{
name|ND
argument_list|(
literal|"%d packets left to ring %d (space %d)"
argument_list|,
name|howmany
argument_list|,
name|i
argument_list|,
name|k1
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
name|dst_lim
operator|=
name|k1
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|howmany
operator|>
literal|0
operator|&&
name|k1
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|struct
name|netmap_slot
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
name|tmp
decl_stmt|;
name|src
operator|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|kring
operator|->
name|nr_hwcur
index|]
expr_stmt|;
name|dst
operator|=
operator|&
name|k1
operator|->
name|ring
operator|->
name|slot
index|[
name|k1
operator|->
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|tmp
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|->
name|buf_idx
operator|=
name|dst
operator|->
name|buf_idx
expr_stmt|;
name|src
operator|->
name|flags
operator|=
name|NS_BUF_CHANGED
expr_stmt|;
name|dst
operator|->
name|buf_idx
operator|=
name|tmp
operator|.
name|buf_idx
expr_stmt|;
name|dst
operator|->
name|len
operator|=
name|tmp
operator|.
name|len
expr_stmt|;
name|dst
operator|->
name|flags
operator|=
name|NS_BUF_CHANGED
expr_stmt|;
name|ND
argument_list|(
literal|"out len %d buf %d from %d to %d"
argument_list|,
name|dst
operator|->
name|len
argument_list|,
name|dst
operator|->
name|buf_idx
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|k1
operator|->
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|nm_next
argument_list|(
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|src_lim
argument_list|)
expr_stmt|;
name|howmany
operator|--
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|--
expr_stmt|;
name|k1
operator|->
name|ring
operator|->
name|cur
operator|=
name|nm_next
argument_list|(
name|k1
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|dst_lim
argument_list|)
expr_stmt|;
name|k1
operator|->
name|ring
operator|->
name|avail
operator|--
expr_stmt|;
block|}
name|kring
operator|->
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
comment|// XXX
name|k1
operator|++
expr_stmt|;
comment|// XXX why?
block|}
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * netmap_txsync_to_host() passes packets up. We are called from a  * system call in user process context, and the only contention  * can be among multiple user threads erroneously calling  * this routine concurrently.  */
end_comment

begin_function
name|void
name|netmap_txsync_to_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|na
operator|->
name|num_tx_rings
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|k
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|mbq
name|q
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|NM_KR_BUSY
condition|)
name|D
argument_list|(
literal|"ring %p busy (user error)"
argument_list|,
name|kring
argument_list|)
expr_stmt|;
return|return;
block|}
name|k
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|lim
condition|)
block|{
name|D
argument_list|(
literal|"invalid ring index in stack TX kring %p"
argument_list|,
name|kring
argument_list|)
expr_stmt|;
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Take packets from hwcur to cur and pass them up. 	 * In case of no buffers we give up. At the end of the loop, 	 * the queue is drained in all cases. 	 */
name|mbq_init
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
name|netmap_grab_packets
argument_list|(
name|kring
argument_list|,
operator|&
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|k
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|=
name|ring
operator|->
name|avail
operator|=
name|lim
expr_stmt|;
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|netmap_send_up
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
operator|&
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rxsync backend for packets coming from the host stack.  * They have been put in the queue by netmap_transmit() so we  * need to protect access to the kring using a lock.  *  * This routine also does the selrecord if called from the poll handler  * (we know because td != NULL).  *  * NOTE: on linux, selrecord() is defined as a macro and uses pwait  *     as an additional hidden argument.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_rxsync_from_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|pwait
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|j
decl_stmt|,
name|n
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
decl_stmt|;
name|u_int
name|k
init|=
name|ring
operator|->
name|cur
decl_stmt|,
name|resvd
init|=
name|ring
operator|->
name|reserved
decl_stmt|;
operator|(
name|void
operator|)
name|pwait
expr_stmt|;
comment|/* disable unused warnings */
if|if
condition|(
name|kring
operator|->
name|nkr_stopped
condition|)
comment|/* check a first time without lock */
return|return;
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nkr_stopped
condition|)
comment|/* check again with lock held */
goto|goto
name|unlock_out
goto|;
if|if
condition|(
name|k
operator|>=
name|lim
condition|)
block|{
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
goto|goto
name|unlock_out
goto|;
block|}
comment|/* new packets are already set in nr_hwavail */
comment|/* skip past packets that userspace has released */
name|j
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|resvd
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|resvd
operator|+
name|ring
operator|->
name|avail
operator|>=
name|lim
operator|+
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"XXX invalid reserve/avail %d %d"
argument_list|,
name|resvd
argument_list|,
name|ring
operator|->
name|avail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|reserved
operator|=
name|resvd
operator|=
literal|0
expr_stmt|;
comment|// XXX panic...
block|}
name|k
operator|=
operator|(
name|k
operator|>=
name|resvd
operator|)
condition|?
name|k
operator|-
name|resvd
else|:
name|k
operator|+
name|lim
operator|-
name|resvd
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
name|k
condition|)
block|{
name|n
operator|=
name|k
operator|>=
name|j
condition|?
name|k
operator|-
name|j
else|:
name|k
operator|+
name|lim
operator|-
name|j
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|-=
name|n
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|k
expr_stmt|;
block|}
name|k
operator|=
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
operator|-
name|resvd
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
operator|&&
name|td
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|&&
operator|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
operator|)
condition|)
name|D
argument_list|(
literal|"%d pkts from stack"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|unlock_out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a netmap adapter for the port.  *  * If it is possible to satisfy the request, return 0  * with *na containing the netmap adapter found.  * Otherwise return an error code, with *na containing NULL.  *  * When the port is attached to a bridge, we always return  * EBUSY.  * Otherwise, if the port is already bound to a file descriptor,  * then we unconditionally return the existing adapter into *na.  * In all the other cases, we return (into *na) either native,  * generic or NULL, according to the following table:  *  *					native_support  * active_fds   dev.netmap.admode         YES     NO  * -------------------------------------------------------  *>0              *                 NA(ifp) NA(ifp)  *  *     0        NETMAP_ADMODE_BEST      NATIVE  GENERIC  *     0        NETMAP_ADMODE_NATIVE    NATIVE   NULL  *     0        NETMAP_ADMODE_GENERIC   GENERIC GENERIC  *  */
end_comment

begin_function
name|int
name|netmap_get_hw_na
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
modifier|*
name|na
parameter_list|)
block|{
comment|/* generic support */
name|int
name|i
init|=
name|netmap_admode
decl_stmt|;
comment|/* Take a snapshot. */
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|prev_na
decl_stmt|;
name|struct
name|netmap_generic_adapter
modifier|*
name|gna
decl_stmt|;
operator|*
name|na
operator|=
name|NULL
expr_stmt|;
comment|/* default */
comment|/* reset in case of invalid value */
if|if
condition|(
name|i
operator|<
name|NETMAP_ADMODE_BEST
operator|||
name|i
operator|>=
name|NETMAP_ADMODE_LAST
condition|)
name|i
operator|=
name|netmap_admode
operator|=
name|NETMAP_ADMODE_BEST
expr_stmt|;
if|if
condition|(
name|NETMAP_CAPABLE
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
comment|/* If an adapter already exists, but is 		 * attached to a vale port, we report that the 		 * port is busy. 		 */
if|if
condition|(
name|NETMAP_OWNED_BY_KERN
argument_list|(
name|NA
argument_list|(
name|ifp
argument_list|)
argument_list|)
condition|)
return|return
name|EBUSY
return|;
comment|/* If an adapter already exists, return it if 		 * there are active file descriptors or if 		 * netmap is not forced to use generic 		 * adapters. 		 */
if|if
condition|(
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|active_fds
operator|>
literal|0
operator|||
name|i
operator|!=
name|NETMAP_ADMODE_GENERIC
condition|)
block|{
operator|*
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* If there isn't native support and netmap is not allowed 	 * to use generic adapters, we cannot satisfy the request. 	 */
if|if
condition|(
operator|!
name|NETMAP_CAPABLE
argument_list|(
name|ifp
argument_list|)
operator|&&
name|i
operator|==
name|NETMAP_ADMODE_NATIVE
condition|)
return|return
name|EINVAL
return|;
comment|/* Otherwise, create a generic adapter and return it, 	 * saving the previously used netmap adapter, if any. 	 * 	 * Note that here 'prev_na', if not NULL, MUST be a 	 * native adapter, and CANNOT be a generic one. This is 	 * true because generic adapters are created on demand, and 	 * destroyed when not used anymore. Therefore, if the adapter 	 * currently attached to an interface 'ifp' is generic, it 	 * must be that 	 * (NA(ifp)->active_fds> 0 || NETMAP_OWNED_BY_KERN(NA(ifp))). 	 * Consequently, if NA(ifp) is generic, we will enter one of 	 * the branches above. This ensures that we never override 	 * a generic adapter with another generic adapter. 	 */
name|prev_na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|error
operator|=
name|generic_netmap_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|*
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|gna
operator|=
operator|(
expr|struct
name|netmap_generic_adapter
operator|*
operator|)
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|gna
operator|->
name|prev
operator|=
name|prev_na
expr_stmt|;
comment|/* save old na */
if|if
condition|(
name|prev_na
operator|!=
name|NULL
condition|)
block|{
name|ifunit_ref
argument_list|(
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|// XXX add a refcount ?
name|netmap_adapter_get
argument_list|(
name|prev_na
argument_list|)
expr_stmt|;
block|}
name|D
argument_list|(
literal|"Created generic NA %p (prev %p)"
argument_list|,
name|gna
argument_list|,
name|gna
operator|->
name|prev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * MUST BE CALLED UNDER NMG_LOCK()  *  * get a refcounted reference to an interface.  * This is always called in the execution of an ioctl().  *  * Return ENXIO if the interface does not exist, EINVAL if netmap  * is not supported by the interface.  * If successful, hold a reference.  *  * When the NIC is attached to a bridge, reference is managed  * at na->na_bdg_refcount using ADD/DROP_BDG_REF() as well as  * virtual ports.  Hence, on the final DROP_BDG_REF(), the NIC  * is detached from the bridge, then ifp's refcount is dropped (this  * is equivalent to that ifp is destroyed in case of virtual ports.  *  * This function uses if_rele() when we want to prevent the NIC from  * being detached from the bridge in error handling.  But once refcount  * is acquired by this function, it must be released using nm_if_rele().  */
end_comment

begin_function
name|int
name|netmap_get_na
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
modifier|*
name|na
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|ret
decl_stmt|;
operator|*
name|na
operator|=
name|NULL
expr_stmt|;
comment|/* default return value */
comment|/* first try to see if this is a bridge port. */
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_get_bdg_na
argument_list|(
name|nmr
argument_list|,
name|na
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|*
name|na
operator|!=
name|NULL
condition|)
comment|/* valid match in netmap_get_bdg_na() */
return|return
name|error
return|;
name|ifp
operator|=
name|ifunit_ref
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|error
operator|=
name|netmap_get_hw_na
argument_list|(
name|ifp
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
comment|/* Users cannot use the NIC attached to a bridge directly */
if|if
condition|(
name|NETMAP_OWNED_BY_KERN
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
operator|*
name|na
operator|=
name|ret
expr_stmt|;
name|netmap_adapter_get
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * validate parameters on entry for *_txsync()  * Returns ring->cur if ok, or something>= kring->nkr_num_slots  * in case of error. The extra argument is a pointer to  * 'new_bufs'. XXX this may be deprecated at some point.  *  * Below is a correct configuration on input. ring->cur  * must be in the region covered by kring->hwavail,  * and ring->avail and kring->avail should end at the same slot.  *  *         +-hwcur  *         |  *         v<--hwres-->|<-----hwavail---->  *   ------+------------------------------+-------- ring  *                          |  *                          |<---avail--->  *                          +--cur  *  */
end_comment

begin_function
name|u_int
name|nm_txsync_prologue
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|u_int
modifier|*
name|new_slots
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|cur
init|=
name|ring
operator|->
name|cur
decl_stmt|;
comment|/* read only once */
name|u_int
name|avail
init|=
name|ring
operator|->
name|avail
decl_stmt|;
comment|/* read only once */
name|u_int
name|n
init|=
name|kring
operator|->
name|nkr_num_slots
decl_stmt|;
name|u_int
name|kstart
decl_stmt|,
name|kend
decl_stmt|,
name|a
decl_stmt|;
if|#
directive|if
literal|1
comment|/* kernel sanity checks */
if|if
condition|(
name|kring
operator|->
name|nr_hwcur
operator|>=
name|n
operator|||
name|kring
operator|->
name|nr_hwreserved
operator|>=
name|n
operator|||
name|kring
operator|->
name|nr_hwavail
operator|>=
name|n
operator|||
name|kring
operator|->
name|nr_hwreserved
operator|+
name|kring
operator|->
name|nr_hwavail
operator|>=
name|n
condition|)
goto|goto
name|error
goto|;
endif|#
directive|endif
comment|/* kernel sanity checks */
name|kstart
operator|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwreserved
expr_stmt|;
if|if
condition|(
name|kstart
operator|>=
name|n
condition|)
name|kstart
operator|-=
name|n
expr_stmt|;
name|kend
operator|=
name|kstart
operator|+
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
comment|/* user sanity checks. a is the expected avail */
if|if
condition|(
name|cur
operator|<
name|kstart
condition|)
block|{
comment|/* too low, but maybe wraparound */
if|if
condition|(
name|cur
operator|+
name|n
operator|>
name|kend
condition|)
goto|goto
name|error
goto|;
operator|*
name|new_slots
operator|=
name|cur
operator|+
name|n
operator|-
name|kstart
expr_stmt|;
name|a
operator|=
name|kend
operator|-
name|cur
operator|-
name|n
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cur
operator|>
name|kend
condition|)
goto|goto
name|error
goto|;
operator|*
name|new_slots
operator|=
name|cur
operator|-
name|kstart
expr_stmt|;
name|a
operator|=
name|kend
operator|-
name|cur
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|!=
name|avail
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"wrong but fixable avail have %d need %d"
argument_list|,
name|avail
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|avail
operator|=
name|a
expr_stmt|;
block|}
return|return
name|cur
return|;
name|error
label|:
name|RD
argument_list|(
literal|5
argument_list|,
literal|"kring error: hwcur %d hwres %d hwavail %d cur %d av %d"
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwreserved
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|,
name|cur
argument_list|,
name|avail
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * validate parameters on entry for *_rxsync()  * Returns ring->cur - ring->reserved if ok,  * or something>= kring->nkr_num_slots  * in case of error. The extra argument is a pointer to  * 'resvd'. XXX this may be deprecated at some point.  *  * Below is a correct configuration on input. ring->cur and  * ring->reserved must be in the region covered by kring->hwavail,  * and ring->avail and kring->avail should end at the same slot.  *  *            +-hwcur  *            |  *            v<-------hwavail---------->  *   ---------+--------------------------+-------- ring  *               |<--res-->|  *                         |<---avail--->  *                         +--cur  *  */
end_comment

begin_function
name|u_int
name|nm_rxsync_prologue
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|u_int
modifier|*
name|resvd
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|cur
init|=
name|ring
operator|->
name|cur
decl_stmt|;
comment|/* read only once */
name|u_int
name|avail
init|=
name|ring
operator|->
name|avail
decl_stmt|;
comment|/* read only once */
name|u_int
name|res
init|=
name|ring
operator|->
name|reserved
decl_stmt|;
comment|/* read only once */
name|u_int
name|n
init|=
name|kring
operator|->
name|nkr_num_slots
decl_stmt|;
name|u_int
name|kend
init|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
decl_stmt|;
name|u_int
name|a
decl_stmt|;
if|#
directive|if
literal|1
comment|/* kernel sanity checks */
if|if
condition|(
name|kring
operator|->
name|nr_hwcur
operator|>=
name|n
operator|||
name|kring
operator|->
name|nr_hwavail
operator|>=
name|n
condition|)
goto|goto
name|error
goto|;
endif|#
directive|endif
comment|/* kernel sanity checks */
comment|/* user sanity checks */
if|if
condition|(
name|res
operator|>=
name|n
condition|)
goto|goto
name|error
goto|;
comment|/* check that cur is valid, a is the expected value of avail */
if|if
condition|(
name|cur
operator|<
name|kring
operator|->
name|nr_hwcur
condition|)
block|{
comment|/* too low, but maybe wraparound */
if|if
condition|(
name|cur
operator|+
name|n
operator|>
name|kend
condition|)
goto|goto
name|error
goto|;
name|a
operator|=
name|kend
operator|-
operator|(
name|cur
operator|+
name|n
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cur
operator|>
name|kend
condition|)
goto|goto
name|error
goto|;
name|a
operator|=
name|kend
operator|-
name|cur
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|!=
name|avail
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"wrong but fixable avail have %d need %d"
argument_list|,
name|avail
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|avail
operator|=
name|a
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
comment|/* then repeat the check for cur + res */
name|cur
operator|=
operator|(
name|cur
operator|>=
name|res
operator|)
condition|?
name|cur
operator|-
name|res
else|:
name|n
operator|+
name|cur
operator|-
name|res
expr_stmt|;
if|if
condition|(
name|cur
operator|<
name|kring
operator|->
name|nr_hwcur
condition|)
block|{
comment|/* too low, but maybe wraparound */
if|if
condition|(
name|cur
operator|+
name|n
operator|>
name|kend
condition|)
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|>
name|kend
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
operator|*
name|resvd
operator|=
name|res
expr_stmt|;
return|return
name|cur
return|;
name|error
label|:
name|RD
argument_list|(
literal|5
argument_list|,
literal|"kring error: hwcur %d hwres %d hwavail %d cur %d av %d res %d"
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwreserved
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|avail
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Error routine called when txsync/rxsync detects an error.  * Can't do much more than resetting cur = hwcur, avail = hwavail.  * Return 1 on reinit.  *  * This routine is only called by the upper half of the kernel.  * It only reads hwcur (which is changed only by the upper half, too)  * and hwavail (which may be changed by the lower half, but only on  * a tx ring and only to increase it, so any error will be recovered  * on the next call). For the above, we don't strictly need to call  * it under lock.  */
end_comment

begin_function
name|int
name|netmap_ring_reinit
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
comment|// XXX KASSERT nm_kr_tryget
name|RD
argument_list|(
literal|10
argument_list|,
literal|"called for %s"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|kring
operator|->
name|na
operator|->
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|cur
operator|>
name|lim
condition|)
name|errors
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|idx
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
decl_stmt|;
name|u_int
name|len
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|2
operator|||
name|idx
operator|>=
name|netmap_total_buffers
condition|)
block|{
if|if
condition|(
operator|!
name|errors
operator|++
condition|)
name|D
argument_list|(
literal|"bad buffer at slot %d idx %d len %d "
argument_list|,
name|i
argument_list|,
name|idx
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
name|NETMAP_BDG_BUF_SIZE
argument_list|(
name|kring
operator|->
name|na
operator|->
name|nm_mem
argument_list|)
condition|)
block|{
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|errors
operator|++
condition|)
name|D
argument_list|(
literal|"bad len %d at slot %d idx %d"
argument_list|,
name|len
argument_list|,
name|i
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errors
condition|)
block|{
name|int
name|pos
init|=
name|kring
operator|-
name|kring
operator|->
name|na
operator|->
name|tx_rings
decl_stmt|;
name|int
name|n
init|=
name|kring
operator|->
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
decl_stmt|;
name|RD
argument_list|(
literal|10
argument_list|,
literal|"total %d errors"
argument_list|,
name|errors
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|RD
argument_list|(
literal|10
argument_list|,
literal|"%s %s[%d] reinit, cur %d -> %d avail %d -> %d"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|kring
operator|->
name|na
operator|->
name|ifp
argument_list|)
argument_list|,
name|pos
operator|<
name|n
condition|?
literal|"TX"
else|:
literal|"RX"
argument_list|,
name|pos
operator|<
name|n
condition|?
name|pos
else|:
name|pos
operator|-
name|n
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|ring
operator|->
name|avail
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
block|}
return|return
operator|(
name|errors
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the ring ID. For devices with a single queue, a request  * for all rings is the same as a single ring.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_set_ringid
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|u_int
name|ringid
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|u_int
name|i
init|=
name|ringid
operator|&
name|NETMAP_RING_MASK
decl_stmt|;
comment|/* initially (np_qfirst == np_qlast) we don't want to lock */
name|u_int
name|lim
init|=
name|na
operator|->
name|num_rx_rings
decl_stmt|;
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|>
name|lim
condition|)
name|lim
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
if|if
condition|(
operator|(
name|ringid
operator|&
name|NETMAP_HW_RING
operator|)
operator|&&
name|i
operator|>=
name|lim
condition|)
block|{
name|D
argument_list|(
literal|"invalid ring id %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|priv
operator|->
name|np_ringid
operator|=
name|ringid
expr_stmt|;
if|if
condition|(
name|ringid
operator|&
name|NETMAP_SW_RING
condition|)
block|{
name|priv
operator|->
name|np_qfirst
operator|=
name|NETMAP_SW_RING
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ringid
operator|&
name|NETMAP_HW_RING
condition|)
block|{
name|priv
operator|->
name|np_qfirst
operator|=
name|i
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|->
name|np_qfirst
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
name|NETMAP_HW_RING
expr_stmt|;
block|}
name|priv
operator|->
name|np_txpoll
operator|=
operator|(
name|ringid
operator|&
name|NETMAP_NO_TX_POLL
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
block|{
if|if
condition|(
name|ringid
operator|&
name|NETMAP_SW_RING
condition|)
name|D
argument_list|(
literal|"ringid %s set to SW RING"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ringid
operator|&
name|NETMAP_HW_RING
condition|)
name|D
argument_list|(
literal|"ringid %s set to HW RING %d"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|priv
operator|->
name|np_qfirst
argument_list|)
expr_stmt|;
else|else
name|D
argument_list|(
literal|"ringid %s set to all %d HW RINGS"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * possibly move the interface to netmap-mode.  * If success it returns a pointer to netmap_if, otherwise NULL.  * This must be called with NMG_LOCK held.  */
end_comment

begin_function
name|struct
name|netmap_if
modifier|*
name|netmap_do_regif
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|uint16_t
name|ringid
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|,
name|need_mem
init|=
literal|0
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* ring configuration may have changed, fetch from the card */
name|netmap_update_config
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_na
operator|=
name|na
expr_stmt|;
comment|/* store the reference */
name|error
operator|=
name|netmap_set_ringid
argument_list|(
name|priv
argument_list|,
name|ringid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* ensure allocators are ready */
name|need_mem
operator|=
operator|!
name|netmap_have_memory_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_mem
condition|)
block|{
name|error
operator|=
name|netmap_get_memory_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"get_memory returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
name|nifp
operator|=
name|netmap_if_new
argument_list|(
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
block|{
comment|/* allocation failed */
comment|/* we should drop the allocator, but only 		 * if we were the ones who grabbed it 		 */
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|na
operator|->
name|active_fds
operator|++
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
comment|/* was already set */
block|}
else|else
block|{
comment|/* Otherwise set the card in netmap mode 		 * and make it use the shared buffers. 		 * 		 * do not core lock because the race is harmless here, 		 * there cannot be any traffic to netmap_transmit() 		 */
name|na
operator|->
name|na_lut
operator|=
name|na
operator|->
name|nm_mem
operator|->
name|pools
index|[
name|NETMAP_BUF_POOL
index|]
operator|.
name|lut
expr_stmt|;
name|ND
argument_list|(
literal|"%p->na_lut == %p"
argument_list|,
name|na
argument_list|,
name|na
operator|->
name|na_lut
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_lut_objtotal
operator|=
name|na
operator|->
name|nm_mem
operator|->
name|pools
index|[
name|NETMAP_BUF_POOL
index|]
operator|.
name|objtotal
expr_stmt|;
name|error
operator|=
name|na
operator|->
name|nm_register
argument_list|(
name|na
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* mode on */
if|if
condition|(
name|error
condition|)
block|{
name|netmap_do_unregif
argument_list|(
name|priv
argument_list|,
name|nifp
argument_list|)
expr_stmt|;
name|nifp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|out
label|:
operator|*
name|err
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|priv
operator|->
name|np_na
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|need_mem
condition|)
name|netmap_drop_memory_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nifp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * advertise that the interface is ready bt setting ni_nifp. 		 * The barrier is needed because readers (poll and *SYNC) 		 * check for priv->np_nifp != NULL without locking 		 */
name|wmb
argument_list|()
expr_stmt|;
comment|/* make sure previous writes are visible to all CPUs */
name|priv
operator|->
name|np_nifp
operator|=
name|nifp
expr_stmt|;
block|}
return|return
name|nifp
return|;
block|}
end_function

begin_comment
comment|/*  * ioctl(2) support for the "netmap" device.  *  * Following a list of accepted commands:  * - NIOCGINFO  * - SIOCGIFADDR	just for convenience  * - NIOCREGIF  * - NIOCUNREGIF  * - NIOCTXSYNC  * - NIOCRXSYNC  *  * Return 0 on success, errno otherwise.  */
end_comment

begin_function
name|int
name|netmap_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|struct
name|nmreq
modifier|*
name|nmr
init|=
operator|(
expr|struct
name|nmreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|lim
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|krings
decl_stmt|;
operator|(
name|void
operator|)
name|dev
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|fflag
expr_stmt|;
comment|/* UNUSED */
ifdef|#
directive|ifdef
name|linux
define|#
directive|define
name|devfs_get_cdevpriv
parameter_list|(
name|pp
parameter_list|)
define|\
value|({ *(struct netmap_priv_d **)pp = ((struct file *)td)->private_data; 	\ 		(*pp ? 0 : ENOENT); })
comment|/* devfs_set_cdevpriv cannot fail on linux */
define|#
directive|define
name|devfs_set_cdevpriv
parameter_list|(
name|p
parameter_list|,
name|fn
parameter_list|)
define|\
value|({ ((struct file *)td)->private_data = p; (p ? 0 : EINVAL); })
define|#
directive|define
name|devfs_clear_cdevpriv
parameter_list|()
value|do {				\ 		netmap_dtor(priv); ((struct file *)td)->private_data = 0;	\ 	} while (0)
endif|#
directive|endif
comment|/* linux */
name|CURVNET_SET
argument_list|(
name|TD_TO_VNET
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
comment|/* XXX ENOENT should be impossible, since the priv 		 * is now created in the open */
return|return
operator|(
name|error
operator|==
name|ENOENT
condition|?
name|ENXIO
else|:
name|error
operator|)
return|;
block|}
name|nmr
operator|->
name|nr_name
index|[
sizeof|sizeof
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* truncate name */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NIOCGINFO
case|:
comment|/* return capabilities etc */
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|!=
name|NETMAP_API
condition|)
block|{
name|D
argument_list|(
literal|"API mismatch got %d have %d"
argument_list|,
name|nmr
operator|->
name|nr_version
argument_list|,
name|NETMAP_API
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nmr
operator|->
name|nr_cmd
operator|==
name|NETMAP_BDG_LIST
condition|)
block|{
name|error
operator|=
name|netmap_bdg_ctl
argument_list|(
name|nmr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|NMG_LOCK
argument_list|()
expr_stmt|;
do|do
block|{
comment|/* memsize is always valid */
name|struct
name|netmap_mem_d
modifier|*
name|nmd
init|=
operator|&
name|nm_mem
decl_stmt|;
name|u_int
name|memflags
decl_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* get a refcount */
name|error
operator|=
name|netmap_get_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
literal|1
comment|/* create */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|nmd
operator|=
name|na
operator|->
name|nm_mem
expr_stmt|;
comment|/* get memory allocator */
block|}
name|error
operator|=
name|netmap_mem_get_info
argument_list|(
name|nmd
argument_list|,
operator|&
name|nmr
operator|->
name|nr_memsize
argument_list|,
operator|&
name|memflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
comment|/* only memory info */
break|break;
name|nmr
operator|->
name|nr_offset
operator|=
literal|0
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|nmr
operator|->
name|nr_tx_slots
operator|=
literal|0
expr_stmt|;
name|netmap_update_config
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
if|if
condition|(
name|memflags
operator|&
name|NETMAP_MEM_PRIVATE
condition|)
name|nmr
operator|->
name|nr_ringid
operator||=
name|NETMAP_PRIV_MEM
expr_stmt|;
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|NIOCREGIF
case|:
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|!=
name|NETMAP_API
condition|)
block|{
name|nmr
operator|->
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* possibly attach/detach NIC and VALE switch */
name|i
operator|=
name|nmr
operator|->
name|nr_cmd
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NETMAP_BDG_ATTACH
operator|||
name|i
operator|==
name|NETMAP_BDG_DETACH
operator|||
name|i
operator|==
name|NETMAP_BDG_OFFSET
condition|)
block|{
name|error
operator|=
name|netmap_bdg_ctl
argument_list|(
name|nmr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"nr_cmd must be 0 not %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* protect access to priv from concurrent NIOCREGIF */
name|NMG_LOCK
argument_list|()
expr_stmt|;
do|do
block|{
name|u_int
name|memflags
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_na
operator|!=
name|NULL
condition|)
block|{
comment|/* thread already registered */
name|error
operator|=
name|netmap_set_ringid
argument_list|(
name|priv
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* find the interface and a reference */
name|error
operator|=
name|netmap_get_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
literal|1
comment|/* create */
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
break|break;
name|ifp
operator|=
name|na
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|NETMAP_OWNED_BY_KERN
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|nifp
operator|=
name|netmap_do_regif
argument_list|(
name|priv
argument_list|,
name|na
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nifp
condition|)
block|{
comment|/* reg. failed, release priv and ref */
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_nifp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* return the offset of the netmap_if object */
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|error
operator|=
name|netmap_mem_get_info
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
operator|&
name|nmr
operator|->
name|nr_memsize
argument_list|,
operator|&
name|memflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|memflags
operator|&
name|NETMAP_MEM_PRIVATE
condition|)
block|{
name|nmr
operator|->
name|nr_ringid
operator||=
name|NETMAP_PRIV_MEM
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|nifp
operator|->
name|ni_flags
operator||=
name|NI_PRIV_MEM
expr_stmt|;
block|}
name|nmr
operator|->
name|nr_offset
operator|=
name|netmap_mem_if_offset
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
name|nifp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|NIOCUNREGIF
case|:
comment|// XXX we have no data here ?
name|D
argument_list|(
literal|"deprecated, data is %p"
argument_list|,
name|nmr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NIOCTXSYNC
case|:
case|case
name|NIOCRXSYNC
case|:
name|nifp
operator|=
name|priv
operator|->
name|np_nifp
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|rmb
argument_list|()
expr_stmt|;
comment|/* make sure following reads are not from cache */
name|na
operator|=
name|priv
operator|->
name|np_na
expr_stmt|;
comment|/* we have a reference */
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"Internal error: nifp != NULL&& na == NULL"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|ifp
operator|=
name|na
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|RD
argument_list|(
literal|1
argument_list|,
literal|"the ifp is gone"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|priv
operator|->
name|np_qfirst
operator|==
name|NETMAP_SW_RING
condition|)
block|{
comment|/* host rings */
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
name|netmap_txsync_to_host
argument_list|(
name|na
argument_list|)
expr_stmt|;
else|else
name|netmap_rxsync_from_host
argument_list|(
name|na
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* find the last ring to scan */
name|lim
operator|=
name|priv
operator|->
name|np_qlast
expr_stmt|;
if|if
condition|(
name|lim
operator|==
name|NETMAP_HW_RING
condition|)
name|lim
operator|=
operator|(
name|cmd
operator|==
name|NIOCTXSYNC
operator|)
condition|?
name|na
operator|->
name|num_tx_rings
else|:
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|krings
operator|=
operator|(
name|cmd
operator|==
name|NIOCTXSYNC
operator|)
condition|?
name|na
operator|->
name|tx_rings
else|:
name|na
operator|->
name|rx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
name|krings
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
block|{
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"pre txsync ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_txsync
argument_list|(
name|na
argument_list|,
name|i
argument_list|,
name|NAF_FORCE_RECLAIM
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"post txsync ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|na
operator|->
name|nm_rxsync
argument_list|(
name|na
argument_list|,
name|i
argument_list|,
name|NAF_FORCE_READ
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|__FreeBSD__
case|case
name|BIOCIMMEDIATE
case|:
case|case
name|BIOCGHDRCMPLT
case|:
case|case
name|BIOCSHDRCMPLT
case|:
case|case
name|BIOCSSEESENT
case|:
name|D
argument_list|(
literal|"ignore BIOCIMMEDIATE/BIOCSHDRCMPLT/BIOCSHDRCMPLT/BIOCSSEESENT"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* allow device-specific ioctls */
block|{
name|struct
name|socket
name|so
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|so
argument_list|,
sizeof|sizeof
argument_list|(
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_get_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
literal|0
comment|/* don't create */
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
block|{
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
name|ifp
operator|=
name|na
operator|->
name|ifp
expr_stmt|;
name|so
operator|.
name|so_vnet
operator|=
name|ifp
operator|->
name|if_vnet
expr_stmt|;
comment|// so->so_proto not null.
name|error
operator|=
name|ifioctl
argument_list|(
operator|&
name|so
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
else|#
directive|else
comment|/* linux */
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
comment|/* linux */
block|}
name|out
label|:
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * select(2) and poll(2) handlers for the "netmap" device.  *  * Can be called for one or more queues.  * Return true the event mask corresponding to ready events.  * If there are no ready events, do a selrecord on either individual  * selinfo or on the global one.  * Device-dependent parts (locking and sync of tx/rx rings)  * are done through callbacks.  *  * On linux, arguments are really pwait, the poll table, and 'td' is struct file *  * The first one is remapped to pwait as selrecord() uses the name as an  * hidden argument.  */
end_comment

begin_function
name|int
name|netmap_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|check_all_tx
decl_stmt|,
name|check_all_rx
decl_stmt|,
name|want_tx
decl_stmt|,
name|want_rx
decl_stmt|,
name|revents
init|=
literal|0
decl_stmt|;
name|u_int
name|lim_tx
decl_stmt|,
name|lim_rx
decl_stmt|,
name|host_forwarded
init|=
literal|0
decl_stmt|;
name|struct
name|mbq
name|q
decl_stmt|;
name|void
modifier|*
name|pwait
init|=
name|dev
decl_stmt|;
comment|/* linux compatibility */
comment|/* 	 * In order to avoid nested locks, we need to "double check" 	 * txsync and rxsync if we decide to do a selrecord(). 	 * retry_tx (and retry_rx, later) prevent looping forever. 	 */
name|int
name|retry_tx
init|=
literal|1
decl_stmt|;
operator|(
name|void
operator|)
name|pwait
expr_stmt|;
name|mbq_init
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
operator|!=
literal|0
operator|||
name|priv
operator|==
name|NULL
condition|)
return|return
name|POLLERR
return|;
if|if
condition|(
name|priv
operator|->
name|np_nifp
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"No if registered"
argument_list|)
expr_stmt|;
return|return
name|POLLERR
return|;
block|}
name|rmb
argument_list|()
expr_stmt|;
comment|/* make sure following reads are not from cache */
name|na
operator|=
name|priv
operator|->
name|np_na
expr_stmt|;
name|ifp
operator|=
name|na
operator|->
name|ifp
expr_stmt|;
comment|// check for deleted
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|RD
argument_list|(
literal|1
argument_list|,
literal|"the ifp is gone"
argument_list|)
expr_stmt|;
return|return
name|POLLERR
return|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
operator|==
literal|0
condition|)
return|return
name|POLLERR
return|;
if|if
condition|(
name|netmap_verbose
operator|&
literal|0x8000
condition|)
name|D
argument_list|(
literal|"device %s events 0x%x"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|events
argument_list|)
expr_stmt|;
name|want_tx
operator|=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
name|want_rx
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
name|lim_tx
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|lim_rx
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_qfirst
operator|==
name|NETMAP_SW_RING
condition|)
block|{
comment|/* handle the host stack ring */
if|if
condition|(
name|priv
operator|->
name|np_txpoll
operator|||
name|want_tx
condition|)
block|{
comment|/* push any packets up, then we are always ready */
name|netmap_txsync_to_host
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|revents
operator||=
name|want_tx
expr_stmt|;
block|}
if|if
condition|(
name|want_rx
condition|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|lim_rx
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|==
literal|0
condition|)
name|netmap_rxsync_from_host
argument_list|(
name|na
argument_list|,
name|td
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
block|}
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
comment|/* 	 * If we are in transparent mode, check also the host rx ring 	 * XXX Transparent mode at the moment requires to bind all  	 * rings to a single file descriptor. 	 */
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|lim_rx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|np_qlast
operator|==
name|NETMAP_HW_RING
operator|)
comment|// XXX check_all
operator|&&
name|want_rx
operator|&&
operator|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
operator|)
condition|)
block|{
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|==
literal|0
condition|)
name|netmap_rxsync_from_host
argument_list|(
name|na
argument_list|,
name|td
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
name|revents
operator||=
name|want_rx
expr_stmt|;
block|}
comment|/* 	 * check_all_{tx|rx} are set if the card has more than one queue AND 	 * the file descriptor is bound to all of them. If so, we sleep on 	 * the "global" selinfo, otherwise we sleep on individual selinfo 	 * (FreeBSD only allows two selinfo's per file descriptor). 	 * The interrupt routine in the driver wake one or the other 	 * (or both) depending on which clients are active. 	 * 	 * rxsync() is only called if we run out of buffers on a POLLIN. 	 * txsync() is called if we run out of buffers on POLLOUT, or 	 * there are pending packets to send. The latter can be disabled 	 * passing NETMAP_NO_TX_POLL in the NIOCREG call. 	 */
name|check_all_tx
operator|=
operator|(
name|priv
operator|->
name|np_qlast
operator|==
name|NETMAP_HW_RING
operator|)
operator|&&
operator|(
name|lim_tx
operator|>
literal|1
operator|)
expr_stmt|;
name|check_all_rx
operator|=
operator|(
name|priv
operator|->
name|np_qlast
operator|==
name|NETMAP_HW_RING
operator|)
operator|&&
operator|(
name|lim_rx
operator|>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_qlast
operator|!=
name|NETMAP_HW_RING
condition|)
block|{
name|lim_tx
operator|=
name|lim_rx
operator|=
name|priv
operator|->
name|np_qlast
expr_stmt|;
block|}
comment|/* 	 * We start with a lock free round which is cheap if we have 	 * slots available. If this fails, then lock and call the sync 	 * routines. 	 * XXX rather than ring->avail>0 should check that 	 * ring->cur has not reached hwcur+hwavail 	 */
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|want_rx
operator|&&
name|i
operator|<
name|lim_rx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
name|want_rx
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|want_tx
operator|&&
name|i
operator|<
name|lim_tx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
comment|/* 	 * If we to push packets out (priv->np_txpoll) or want_tx is 	 * still set, we do need to run the txsync calls (on all rings, 	 * to avoid that the tx rings stall). 	 * XXX should also check cur != hwcur on the tx rings. 	 * Fortunately, normal tx mode has np_txpoll set. 	 */
if|if
condition|(
name|priv
operator|->
name|np_txpoll
operator|||
name|want_tx
condition|)
block|{
comment|/* If we really want to be woken up (want_tx), 		 * do a selrecord, either on the global or on 		 * the private structure.  Then issue the txsync 		 * so there is no race in the selrecord/selwait 		 */
name|flush_tx
label|:
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim_tx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
comment|/* 			 * Skip this ring if want_tx == 0 			 * (we have already done a successful sync on 			 * a previous ring) AND kring->cur == kring->hwcur 			 * (there are no pending transmissions for this ring). 			 */
if|if
condition|(
operator|!
name|want_tx
operator|&&
name|kring
operator|->
name|ring
operator|->
name|cur
operator|==
name|kring
operator|->
name|nr_hwcur
condition|)
continue|continue;
comment|/* make sure only one user thread is doing this */
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|ND
argument_list|(
literal|"ring %p busy is %d"
argument_list|,
name|kring
argument_list|,
operator|(
name|int
operator|)
name|kring
operator|->
name|nr_busy
argument_list|)
expr_stmt|;
name|revents
operator||=
name|POLLERR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"send %d on %s %d"
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_txsync
argument_list|(
name|na
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
comment|/* Check avail and call selrecord only if 			 * called with POLLOUT and run out of bufs. 			 * XXX Note, we cannot trust much ring->avail 			 * as it is exposed to userspace (even though 			 * just updated by txsync). We should really 			 * check kring->nr_hwavail or better have 			 * txsync set a flag telling if we need 			 * to do a selrecord(). 			 */
if|if
condition|(
name|want_tx
condition|)
block|{
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
comment|/* stop at the first ring. We don't risk 					 * starvation. 					 */
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|want_tx
operator|&&
name|retry_tx
condition|)
block|{
name|selrecord
argument_list|(
name|td
argument_list|,
name|check_all_tx
condition|?
operator|&
name|na
operator|->
name|tx_si
else|:
operator|&
name|na
operator|->
name|tx_rings
index|[
name|priv
operator|->
name|np_qfirst
index|]
operator|.
name|si
argument_list|)
expr_stmt|;
name|retry_tx
operator|=
literal|0
expr_stmt|;
goto|goto
name|flush_tx
goto|;
block|}
block|}
comment|/* 	 * now if want_rx is still set we need to lock and rxsync. 	 * Do it on all rings because otherwise we starve. 	 */
if|if
condition|(
name|want_rx
condition|)
block|{
name|int
name|retry_rx
init|=
literal|1
decl_stmt|;
name|do_retry_rx
label|:
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim_rx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|revents
operator||=
name|POLLERR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* XXX NR_FORWARD should only be read on 			 * physical or NIC ports 			 */
if|if
condition|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
condition|)
block|{
name|ND
argument_list|(
literal|10
argument_list|,
literal|"forwarding some buffers up %d to %d"
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|netmap_grab_packets
argument_list|(
name|kring
argument_list|,
operator|&
name|q
argument_list|,
name|netmap_fwd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|nm_rxsync
argument_list|(
name|na
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
if|if
condition|(
name|netmap_no_timestamp
operator|==
literal|0
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_TIMESTAMP
condition|)
block|{
name|microtime
argument_list|(
operator|&
name|kring
operator|->
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
name|retry_rx
operator|=
literal|0
expr_stmt|;
block|}
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retry_rx
condition|)
block|{
name|retry_rx
operator|=
literal|0
expr_stmt|;
name|selrecord
argument_list|(
name|td
argument_list|,
name|check_all_rx
condition|?
operator|&
name|na
operator|->
name|rx_si
else|:
operator|&
name|na
operator|->
name|rx_rings
index|[
name|priv
operator|->
name|np_qfirst
index|]
operator|.
name|si
argument_list|)
expr_stmt|;
goto|goto
name|do_retry_rx
goto|;
block|}
block|}
comment|/* forward host to the netmap ring. 	 * I am accessing nr_hwavail without lock, but netmap_transmit 	 * can only increment it, so the operation is safe. 	 */
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|lim_rx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|np_qlast
operator|==
name|NETMAP_HW_RING
operator|)
comment|// XXX check_all
operator|&&
operator|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
operator|)
operator|&&
name|kring
operator|->
name|nr_hwavail
operator|>
literal|0
operator|&&
operator|!
name|host_forwarded
condition|)
block|{
name|netmap_sw_to_nic
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|host_forwarded
operator|=
literal|1
expr_stmt|;
comment|/* prevent another pass */
name|want_rx
operator|=
literal|0
expr_stmt|;
goto|goto
name|flush_tx
goto|;
block|}
if|if
condition|(
name|q
operator|.
name|head
condition|)
name|netmap_send_up
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
operator|&
name|q
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------- driver support routines ------*/
end_comment

begin_function_decl
specifier|static
name|int
name|netmap_hw_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|netmap_notify
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|n_ring
parameter_list|,
name|enum
name|txrx
name|tx
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
block|{
name|kring
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|n_ring
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NAF_GLOBAL_NOTIFY
condition|)
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|tx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kring
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|n_ring
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NAF_GLOBAL_NOTIFY
condition|)
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|rx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|// XXX check handling of failures
end_comment

begin_function
name|int
name|netmap_attach_common
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|==
literal|0
operator|||
name|na
operator|->
name|num_rx_rings
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"%s: invalid rings tx %d rx %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|na
operator|->
name|num_tx_rings
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|WNA
argument_list|(
name|ifp
argument_list|)
operator|=
name|na
expr_stmt|;
name|NETMAP_SET_CAPABLE
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_krings_create
operator|==
name|NULL
condition|)
block|{
name|na
operator|->
name|nm_krings_create
operator|=
name|netmap_hw_krings_create
expr_stmt|;
name|na
operator|->
name|nm_krings_delete
operator|=
name|netmap_krings_delete
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|nm_notify
operator|==
name|NULL
condition|)
name|na
operator|->
name|nm_notify
operator|=
name|netmap_notify
expr_stmt|;
name|na
operator|->
name|active_fds
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_mem
operator|==
name|NULL
condition|)
name|na
operator|->
name|nm_mem
operator|=
operator|&
name|nm_mem
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|netmap_detach_common
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
if|if
condition|(
name|na
operator|->
name|ifp
condition|)
name|WNA
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* XXX do we need this? */
if|if
condition|(
name|na
operator|->
name|tx_rings
condition|)
block|{
comment|/* XXX should not happen */
name|D
argument_list|(
literal|"freeing leftover tx_rings"
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_MEM_OWNER
condition|)
name|netmap_mem_private_delete
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|na
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|na
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a ``netmap_adapter`` object created by driver on attach.  * We allocate a block of memory with room for a struct netmap_adapter  * plus two sets of N+2 struct netmap_kring (where N is the number  * of hardware rings):  * krings	0..N-1	are for the hardware queues.  * kring	N	is for the host stack queue  * kring	N+1	is only used for the selinfo for all queues.  * Return 0 on success, ENOMEM otherwise.  *  * By default the receive and transmit adapter ring counts are both initialized  * to num_queues.  na->num_tx_rings can be set for cards with different tx/rx  * setups.  */
end_comment

begin_function
name|int
name|netmap_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|netmap_hw_adapter
modifier|*
name|hwna
init|=
name|NULL
decl_stmt|;
comment|// XXX when is arg == NULL ?
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|arg
condition|?
name|arg
operator|->
name|ifp
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
name|ifp
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|hwna
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hwna
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwna
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|hwna
operator|->
name|up
operator|=
operator|*
name|arg
expr_stmt|;
if|if
condition|(
name|netmap_attach_common
argument_list|(
operator|&
name|hwna
operator|->
name|up
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|hwna
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|netmap_adapter_get
argument_list|(
operator|&
name|hwna
operator|->
name|up
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|linux
if|if
condition|(
name|ifp
operator|->
name|netdev_ops
condition|)
block|{
comment|/* prepare a clone of the netdev ops */
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|28
argument_list|)
name|hwna
operator|->
name|nm_ndo
operator|.
name|ndo_start_xmit
operator|=
name|ifp
operator|->
name|netdev_ops
expr_stmt|;
else|#
directive|else
name|hwna
operator|->
name|nm_ndo
operator|=
operator|*
name|ifp
operator|->
name|netdev_ops
expr_stmt|;
endif|#
directive|endif
block|}
name|hwna
operator|->
name|nm_ndo
operator|.
name|ndo_start_xmit
operator|=
name|linux_netmap_start_xmit
expr_stmt|;
endif|#
directive|endif
comment|/* linux */
name|D
argument_list|(
literal|"success for %s"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|D
argument_list|(
literal|"fail, arg %p ifp %p na %p"
argument_list|,
name|arg
argument_list|,
name|ifp
argument_list|,
name|hwna
argument_list|)
expr_stmt|;
name|netmap_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|hwna
condition|?
name|EINVAL
else|:
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
name|void
name|NM_DBG
function|(
name|netmap_adapter_get
function|)
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
if|if
condition|(
operator|!
name|na
condition|)
block|{
return|return;
block|}
name|refcount_acquire
argument_list|(
operator|&
name|na
operator|->
name|na_refcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* returns 1 iff the netmap_adapter is destroyed */
end_comment

begin_function
name|int
name|NM_DBG
function|(
name|netmap_adapter_put
function|)
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
if|if
condition|(
operator|!
name|na
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|refcount_release
argument_list|(
operator|&
name|na
operator|->
name|na_refcount
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|na
operator|->
name|nm_dtor
condition|)
name|na
operator|->
name|nm_dtor
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|netmap_detach_common
argument_list|(
name|na
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|netmap_hw_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
return|return
name|netmap_krings_create
argument_list|(
name|na
argument_list|,
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
argument_list|,
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the allocated memory linked to the given ``netmap_adapter``  * object.  */
end_comment

begin_function
name|void
name|netmap_detach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|na
condition|)
return|return;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|netmap_disable_all_rings
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|na
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
name|netmap_enable_all_rings
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Intercept packets from the network stack and pass them  * to netmap as incoming packets on the 'software' ring.  * We rely on the OS to make sure that the ifp and na do not go  * away (typically the caller checks for IFF_DRV_RUNNING or the like).  * In nm_register() or whenever there is a reinitialization,  * we make sure to make the mode change visible here.  */
end_comment

begin_function
name|int
name|netmap_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|len
init|=
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|u_int
name|error
init|=
name|EBUSY
decl_stmt|,
name|lim
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
comment|// XXX [Linux] we do not need this lock
comment|// if we follow the down/configure/up protocol -gl
comment|// mtx_lock(&na->core_lock);
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* interface not in netmap mode anymore */
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
expr_stmt|;
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"%s packet %d len %d from the stack"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|// XXX reconsider long packets if we handle fragments
if|if
condition|(
name|len
operator|>
name|NETMAP_BDG_BUF_SIZE
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
condition|)
block|{
comment|/* too long for us */
name|D
argument_list|(
literal|"%s from_host, drop packet size %d> %d"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|len
argument_list|,
name|NETMAP_BDG_BUF_SIZE
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* protect against other instances of netmap_transmit, 	 * and userspace invocations of rxsync(). 	 */
comment|// XXX [Linux] there can be no other instances of netmap_transmit
comment|// on this same ring, but we still need this lock to protect
comment|// concurrent access from netmap_sw_to_nic() -gl
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwavail
operator|>=
name|lim
condition|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"stack ring %s full\n"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* compute the insert position */
name|i
operator|=
name|nm_kr_rxpos
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|slot
operator|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|i
index|]
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|BDG_NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
name|kring
operator|->
name|nkr_slot_flags
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|++
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"wake up host ring %s %d"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_notify
argument_list|(
name|na
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|,
name|NR_RX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|done
label|:
comment|// mtx_unlock(&na->core_lock);
comment|/* release the mbuf in either cases of success or failure. As an 	 * alternative, put the mbuf in a free list and free the list 	 * only when really necessary. 	 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * netmap_reset() is called by the driver routines when reinitializing  * a ring. The driver is in charge of locking to protect the kring.  * If native netmap mode is not set just return NULL.  */
end_comment

begin_function
name|struct
name|netmap_slot
modifier|*
name|netmap_reset
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|enum
name|txrx
name|tx
parameter_list|,
name|u_int
name|n
parameter_list|,
name|u_int
name|new_cur
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|int
name|new_hwofs
decl_stmt|,
name|lim
decl_stmt|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"NULL na, should not happen"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* no netmap support here */
block|}
if|if
condition|(
operator|!
operator|(
name|na
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
block|{
name|ND
argument_list|(
literal|"interface not in netmap mode"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* nothing to reinitialize */
block|}
comment|/* XXX note- in the new scheme, we are not guaranteed to be 	 * under lock (e.g. when called on a device reset). 	 * In this case, we should set a flag and do not trust too 	 * much the values. In practice: TODO 	 * - set a RESET flag somewhere in the kring 	 * - do the processing in a conservative way 	 * - let the *sync() fixup at the end. 	 */
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|na
operator|->
name|num_tx_rings
condition|)
return|return
name|NULL
return|;
name|kring
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|n
expr_stmt|;
name|new_hwofs
operator|=
name|kring
operator|->
name|nr_hwcur
operator|-
name|new_cur
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|n
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
return|return
name|NULL
return|;
name|kring
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|n
expr_stmt|;
name|new_hwofs
operator|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
operator|-
name|new_cur
expr_stmt|;
block|}
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new_hwofs
operator|>
name|lim
condition|)
name|new_hwofs
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
comment|/* Always set the new offset value and realign the ring. */
name|D
argument_list|(
literal|"%s hwofs %d -> %d, hwavail %d -> %d"
argument_list|,
name|tx
operator|==
name|NR_TX
condition|?
literal|"TX"
else|:
literal|"RX"
argument_list|,
name|kring
operator|->
name|nkr_hwofs
argument_list|,
name|new_hwofs
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|,
name|tx
operator|==
name|NR_TX
condition|?
name|lim
else|:
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nkr_hwofs
operator|=
name|new_hwofs
expr_stmt|;
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
name|kring
operator|->
name|nr_hwavail
operator|=
name|lim
expr_stmt|;
name|kring
operator|->
name|nr_hwreserved
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|// def linux
comment|/* XXX check that the mappings are correct */
comment|/* need ring_nr, adapter->pdev, direction */
block|buffer_info->dma = dma_map_single(&pdev->dev, addr, adapter->rx_buffer_len, DMA_FROM_DEVICE); 	if (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)) { 		D("error mapping rx netmap buffer %d", i);
comment|// XXX fix error handling
block|}
endif|#
directive|endif
comment|/* linux */
comment|/* 	 * Wakeup on the individual and global selwait 	 * We do the wakeup here, but the ring is not yet reconfigured. 	 * However, we are under lock so there are no races. 	 */
name|na
operator|->
name|nm_notify
argument_list|(
name|na
argument_list|,
name|n
argument_list|,
name|tx
argument_list|,
name|NAF_GLOBAL_NOTIFY
argument_list|)
expr_stmt|;
return|return
name|kring
operator|->
name|ring
operator|->
name|slot
return|;
block|}
end_function

begin_comment
comment|/*  * Dispatch rx/tx interrupts to the netmap rings.  *  * "work_done" is non-null on the RX path, NULL for the TX path.  * We rely on the OS to make sure that there is only one active  * instance per queue, and that there is appropriate locking.  *  * The 'notify' routine depends on what the ring is attached to.  * - for a netmap file descriptor, do a selwakeup on the individual  *   waitqueue, plus one on the global one if needed  * - for a switch, call the proper forwarding routine  * - XXX more ?  */
end_comment

begin_function
name|void
name|netmap_common_irq
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|q
parameter_list|,
name|u_int
modifier|*
name|work_done
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|q
operator|&=
name|NETMAP_RING_MASK
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"received %s queue %d"
argument_list|,
name|work_done
condition|?
literal|"RX"
else|:
literal|"TX"
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|work_done
condition|)
block|{
comment|/* RX path */
if|if
condition|(
name|q
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
return|return;
comment|// not a physical queue
name|kring
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|q
expr_stmt|;
name|kring
operator|->
name|nr_kflags
operator||=
name|NKR_PENDINTR
expr_stmt|;
comment|// XXX atomic ?
name|na
operator|->
name|nm_notify
argument_list|(
name|na
argument_list|,
name|q
argument_list|,
name|NR_RX
argument_list|,
operator|(
name|na
operator|->
name|num_rx_rings
operator|>
literal|1
condition|?
name|NAF_GLOBAL_NOTIFY
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
operator|*
name|work_done
operator|=
literal|1
expr_stmt|;
comment|/* do not fire napi again */
block|}
else|else
block|{
comment|/* TX path */
if|if
condition|(
name|q
operator|>=
name|na
operator|->
name|num_tx_rings
condition|)
return|return;
comment|// not a physical queue
name|kring
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|q
expr_stmt|;
name|na
operator|->
name|nm_notify
argument_list|(
name|na
argument_list|,
name|q
argument_list|,
name|NR_TX
argument_list|,
operator|(
name|na
operator|->
name|num_tx_rings
operator|>
literal|1
condition|?
name|NAF_GLOBAL_NOTIFY
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Default functions to handle rx/tx interrupts from a physical device.  * "work_done" is non-null on the RX path, NULL for the TX path.  *  * If the card is not in netmap mode, simply return 0,  * so that the caller proceeds with regular processing.  * Otherwise call netmap_common_irq() and return 1.  *  * If the card is connected to a netmap file descriptor,  * do a selwakeup on the individual queue, plus one on the global one  * if needed (multiqueue card _and_ there are multiqueue listeners),  * and return 1.  *  * Finally, if called on rx from an interface connected to a switch,  * calls the proper forwarding routine, and return 1.  */
end_comment

begin_function
name|int
name|netmap_rx_irq
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|q
parameter_list|,
name|u_int
modifier|*
name|work_done
parameter_list|)
block|{
comment|// XXX could we check NAF_NATIVE_ON ?
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_flags
operator|&
name|NAF_SKIP_INTR
condition|)
block|{
name|ND
argument_list|(
literal|"use regular interrupt"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|netmap_common_irq
argument_list|(
name|ifp
argument_list|,
name|q
argument_list|,
name|work_done
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Module loader and unloader  *  * netmap_init() creates the /dev/netmap device and initializes  * all global variables. Returns 0 on success, errno on failure  * (but there is no chance)  *  * netmap_fini() destroys everything.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|netmap_dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* /dev/netmap character device. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|cdevsw
name|netmap_cdevsw
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|netmap_fini
parameter_list|(
name|void
parameter_list|)
block|{
comment|// XXX destroy_bridges() ?
if|if
condition|(
name|netmap_dev
condition|)
name|destroy_dev
argument_list|(
name|netmap_dev
argument_list|)
expr_stmt|;
name|netmap_mem_fini
argument_list|()
expr_stmt|;
name|NMG_LOCK_DESTROY
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"netmap: unloaded module.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|netmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|NMG_LOCK_INIT
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_mem_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* XXX could use make_dev_credv() to get error number */
name|netmap_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|netmap_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0660
argument_list|,
literal|"netmap"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netmap_dev
condition|)
goto|goto
name|fail
goto|;
name|netmap_init_bridges
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"netmap: loaded module\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|netmap_fini
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* may be incorrect */
block|}
end_function

end_unit

