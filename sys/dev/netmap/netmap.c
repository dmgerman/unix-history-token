begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011-2013 Matteo Landi, Luigi Rizzo. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|TEST_STUFF
end_define

begin_comment
comment|// test code, does not compile yet on linux
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/*  * This module supports memory mapped access to network devices,  * see netmap(4).  *  * The module uses a large, memory pool allocated by the kernel  * and accessible as mmapped memory by multiple userspace threads/processes.  * The memory pool contains packet buffers and "netmap rings",  * i.e. user-accessible copies of the interface's queues.  *  * Access to the network card works like this:  * 1. a process/thread issues one or more open() on /dev/netmap, to create  *    select()able file descriptor on which events are reported.  * 2. on each descriptor, the process issues an ioctl() to identify  *    the interface that should report events to the file descriptor.  * 3. on each descriptor, the process issues an mmap() request to  *    map the shared memory region within the process' address space.  *    The list of interesting queues is indicated by a location in  *    the shared memory region.  * 4. using the functions in the netmap(4) userspace API, a process  *    can look up the occupation state of a queue, access memory buffers,  *    and retrieve received packets or enqueue packets to transmit.  * 5. using some ioctl()s the process can synchronize the userspace view  *    of the queue with the actual status in the kernel. This includes both  *    receiving the notification of new packets, and transmitting new  *    packets on the output interface.  * 6. select() or poll() can be used to wait for events on individual  *    transmit or receive queues (or all queues for a given interface).  *  		SYNCHRONIZATION (USER)  The netmap rings and data structures may be shared among multiple user threads or even independent processes. Any synchronization among those threads/processes is delegated to the threads themselves. Only one thread at a time can be in a system call on the same netmap ring. The OS does not enforce this and only guarantees against system crashes in case of invalid usage.  		LOCKING (INTERNAL)  Within the kernel, access to the netmap rings is protected as follows:  - a spinlock on each ring, to handle producer/consumer races on   RX rings attached to the host stack (against multiple host   threads writing from the host stack to the same ring),   and on 'destination' rings attached to a VALE switch   (i.e. RX rings in VALE ports, and TX rings in NIC/host ports)   protecting multiple active senders for the same destination)  - an atomic variable to guarantee that there is at most one   instance of *_*xsync() on the ring at any time.   For rings connected to user file   descriptors, an atomic_test_and_set() protects this, and the   lock on the ring is not actually used.   For NIC RX rings connected to a VALE switch, an atomic_test_and_set()   is also used to prevent multiple executions (the driver might indeed   already guarantee this).   For NIC TX rings connected to a VALE switch, the lock arbitrates   access to the queue (both when allocating buffers and when pushing   them out).  - *xsync() should be protected against initializations of the card.   On FreeBSD most devices have the reset routine protected by   a RING lock (ixgbe, igb, em) or core lock (re). lem is missing   the RING protection on rx_reset(), this should be added.    On linux there is an external lock on the tx path, which probably   also arbitrates access to the reset routine. XXX to be revised  - a per-interface core_lock protecting access from the host stack   while interfaces may be detached from netmap mode.   XXX there should be no need for this lock if we detach the interfaces   only while they are down.   --- VALE SWITCH ---  NMG_LOCK() serializes all modifications to switches and ports. A switch cannot be deleted until all ports are gone.  For each switch, an SX lock (RWlock on linux) protects deletion of ports. When configuring or deleting a new port, the lock is acquired in exclusive mode (after holding NMG_LOCK). When forwarding, the lock is acquired in shared mode (without NMG_LOCK). The lock is held throughout the entire forwarding cycle, during which the thread may incur in a page fault. Hence it is important that sleepable shared locks are used.  On the rx ring, the per-port lock is grabbed initially to reserve a number of slot in the ring, then the lock is released, packets are copied from source to destination, and then the lock is acquired again and the receive ring is updated. (A similar thing is done on the tx ring for NIC and host stack ports attached to the switch)   */
end_comment

begin_comment
comment|/*  * OS-specific code that is used only within this file.  * Other OS-specific code that must be accessed by drivers  * is present in netmap_kern.h  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* defines used in kernel.h */
end_comment

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* types used in module initialization */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_comment
comment|/* cdevsw struct */
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_comment
comment|/* uio struct */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_comment
comment|/* struct socket */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_comment
comment|/* PROT_EXEC */
end_comment

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* vtophys */
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* vtophys */
end_comment

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/* BIOCIMMEDIATE */
end_comment

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* */
end_comment

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_define
define|#
directive|define
name|prefetch
parameter_list|(
name|x
parameter_list|)
value|__builtin_prefetch(x)
end_define

begin_define
define|#
directive|define
name|BDG_RWLOCK_T
value|struct rwlock
end_define

begin_comment
comment|// struct rwlock
end_comment

begin_define
define|#
directive|define
name|BDG_RWINIT
parameter_list|(
name|b
parameter_list|)
define|\
value|rw_init_flags(&(b)->bdg_lock, "bdg lock", RW_NOWITNESS)
end_define

begin_define
define|#
directive|define
name|BDG_WLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_wlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_WUNLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_wunlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_RLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_rlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_RTRYLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_try_rlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_RUNLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_runlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_RWDESTROY
parameter_list|(
name|b
parameter_list|)
value|rw_destroy(&(b)->bdg_lock)
end_define

begin_comment
comment|/* netmap global lock.  * normally called within the user thread (upon a system call)  * or when a file descriptor or process is terminated  * (last close or last munmap)  */
end_comment

begin_define
define|#
directive|define
name|NMG_LOCK_T
value|struct mtx
end_define

begin_define
define|#
directive|define
name|NMG_LOCK_INIT
parameter_list|()
value|mtx_init(&netmap_global_lock, "netmap global lock", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|NMG_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&netmap_global_lock)
end_define

begin_define
define|#
directive|define
name|NMG_LOCK
parameter_list|()
value|mtx_lock(&netmap_global_lock)
end_define

begin_define
define|#
directive|define
name|NMG_UNLOCK
parameter_list|()
value|mtx_unlock(&netmap_global_lock)
end_define

begin_define
define|#
directive|define
name|NMG_LOCK_ASSERT
parameter_list|()
value|mtx_assert(&netmap_global_lock, MA_OWNED)
end_define

begin_comment
comment|/* atomic operations */
end_comment

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_define
define|#
directive|define
name|NM_ATOMIC_TEST_AND_SET
parameter_list|(
name|p
parameter_list|)
value|(!atomic_cmpset_acq_int((p), 0, 1))
end_define

begin_define
define|#
directive|define
name|NM_ATOMIC_CLEAR
parameter_list|(
name|p
parameter_list|)
value|atomic_store_rel_int((p), 0)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|linux
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"bsd_glue.h"
end_include

begin_function_decl
specifier|static
name|netdev_tx_t
name|linux_netmap_start_xmit
parameter_list|(
name|struct
name|sk_buff
modifier|*
parameter_list|,
name|struct
name|net_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|device_driver
modifier|*
name|linux_netmap_find_driver
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|device_driver
modifier|*
name|dd
decl_stmt|;
while|while
condition|(
operator|(
name|dd
operator|=
name|dev
operator|->
name|driver
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|dev
operator|=
name|dev
operator|->
name|parent
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|dd
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|net_device
modifier|*
name|ifunit_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|net_device
modifier|*
name|ifp
init|=
name|dev_get_by_name
argument_list|(
operator|&
name|init_net
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|struct
name|device_driver
modifier|*
name|dd
decl_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|dd
operator|=
name|linux_netmap_find_driver
argument_list|(
operator|&
name|ifp
operator|->
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|try_module_get
argument_list|(
name|dd
operator|->
name|owner
argument_list|)
condition|)
goto|goto
name|error
goto|;
return|return
name|ifp
return|;
name|error
label|:
name|dev_put
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|if_rele
parameter_list|(
name|struct
name|net_device
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|device_driver
modifier|*
name|dd
decl_stmt|;
name|dd
operator|=
name|linux_netmap_find_driver
argument_list|(
operator|&
name|ifp
operator|->
name|dev
argument_list|)
expr_stmt|;
name|dev_put
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dd
condition|)
name|module_put
argument_list|(
name|dd
operator|->
name|owner
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// XXX a mtx would suffice here too 20130404 gl
end_comment

begin_define
define|#
directive|define
name|NMG_LOCK_T
value|struct semaphore
end_define

begin_define
define|#
directive|define
name|NMG_LOCK_INIT
parameter_list|()
value|sema_init(&netmap_global_lock, 1)
end_define

begin_define
define|#
directive|define
name|NMG_LOCK_DESTROY
parameter_list|()
end_define

begin_define
define|#
directive|define
name|NMG_LOCK
parameter_list|()
value|down(&netmap_global_lock)
end_define

begin_define
define|#
directive|define
name|NMG_UNLOCK
parameter_list|()
value|up(&netmap_global_lock)
end_define

begin_define
define|#
directive|define
name|NMG_LOCK_ASSERT
parameter_list|()
end_define

begin_comment
comment|//	XXX to be completed
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_elif

begin_warning
warning|#
directive|warning
warning|OSX support is only partial
end_warning

begin_include
include|#
directive|include
file|"osx_glue.h"
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|Unsupported platform
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unsupported */
end_comment

begin_comment
comment|/*  * common headers  */
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_mem2.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETMAP
argument_list|,
literal|"netmap"
argument_list|,
literal|"Network memory map"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The following variables are used by the drivers and replicate  * fields in the global memory pool. They only refer to buffers  * used by physical interfaces.  */
end_comment

begin_decl_stmt
name|u_int
name|netmap_total_buffers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|netmap_buf_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|netmap_buffer_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* also address of an invalid buffer */
end_comment

begin_comment
comment|/* user-controlled variables */
end_comment

begin_decl_stmt
name|int
name|netmap_verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|netmap_no_timestamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't timestamp on rxsync */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_dev
argument_list|,
name|OID_AUTO
argument_list|,
name|netmap
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Netmap args"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_verbose
argument_list|,
literal|0
argument_list|,
literal|"Verbose mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_timestamp
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_no_timestamp
argument_list|,
literal|0
argument_list|,
literal|"no_timestamp"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_mitigate
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|mitigate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_mitigate
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_no_pendintr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_pendintr
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_no_pendintr
argument_list|,
literal|0
argument_list|,
literal|"Always look for new received packets."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_txsync_retry
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|txsync_retry
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_txsync_retry
argument_list|,
literal|0
argument_list|,
literal|"Number of txsync loops in bridge's flush."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_drop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debugging */
end_comment

begin_decl_stmt
name|int
name|netmap_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flags */
end_comment

begin_decl_stmt
name|int
name|netmap_fwd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* force transparent mode */
end_comment

begin_decl_stmt
name|int
name|netmap_mmap_unreg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* allow mmap of unregistered fds */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|drop
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_drop
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|flags
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_flags
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|fwd
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_fwd
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|mmap_unreg
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_mmap_unreg
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|NMG_LOCK_T
name|netmap_global_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * protect against multiple threads using the same ring.  * also check that the ring has not been stopped.  */
end_comment

begin_define
define|#
directive|define
name|NM_KR_BUSY
value|1
end_define

begin_define
define|#
directive|define
name|NM_KR_STOPPED
value|2
end_define

begin_function_decl
specifier|static
name|void
name|nm_kr_put
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kr
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|int
name|nm_kr_tryget
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kr
parameter_list|)
block|{
comment|/* check a first time without taking the lock  	 * to avoid starvation for nm_kr_get() 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|kr
operator|->
name|nkr_stopped
argument_list|)
condition|)
block|{
name|ND
argument_list|(
literal|"ring %p stopped (%d)"
argument_list|,
name|kr
argument_list|,
name|kr
operator|->
name|nkr_stopped
argument_list|)
expr_stmt|;
return|return
name|NM_KR_STOPPED
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|NM_ATOMIC_TEST_AND_SET
argument_list|(
operator|&
name|kr
operator|->
name|nr_busy
argument_list|)
argument_list|)
condition|)
return|return
name|NM_KR_BUSY
return|;
comment|/* check a second time with lock held */
if|if
condition|(
name|unlikely
argument_list|(
name|kr
operator|->
name|nkr_stopped
argument_list|)
condition|)
block|{
name|ND
argument_list|(
literal|"ring %p stopped (%d)"
argument_list|,
name|kr
argument_list|,
name|kr
operator|->
name|nkr_stopped
argument_list|)
expr_stmt|;
name|nm_kr_put
argument_list|(
name|kr
argument_list|)
expr_stmt|;
return|return
name|NM_KR_STOPPED
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|nm_kr_put
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kr
parameter_list|)
block|{
name|NM_ATOMIC_CLEAR
argument_list|(
operator|&
name|kr
operator|->
name|nr_busy
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nm_kr_get
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kr
parameter_list|)
block|{
while|while
condition|(
name|NM_ATOMIC_TEST_AND_SET
argument_list|(
operator|&
name|kr
operator|->
name|nr_busy
argument_list|)
condition|)
name|tsleep
argument_list|(
name|kr
argument_list|,
literal|0
argument_list|,
literal|"NM_KR_GET"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nm_disable_ring
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kr
parameter_list|)
block|{
name|kr
operator|->
name|nkr_stopped
operator|=
literal|1
expr_stmt|;
name|nm_kr_get
argument_list|(
name|kr
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|kr
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|kr
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|nm_kr_put
argument_list|(
name|kr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|netmap_disable_all_rings
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
return|return;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|nm_disable_ring
argument_list|(
name|na
operator|->
name|tx_rings
operator|+
name|i
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|nm_disable_ring
argument_list|(
name|na
operator|->
name|rx_rings
operator|+
name|i
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
block|}
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|tx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|rx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|netmap_enable_all_rings
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
return|return;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|D
argument_list|(
literal|"enabling %p"
argument_list|,
name|na
operator|->
name|tx_rings
operator|+
name|i
argument_list|)
expr_stmt|;
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|nkr_stopped
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|D
argument_list|(
literal|"enabling %p"
argument_list|,
name|na
operator|->
name|rx_rings
operator|+
name|i
argument_list|)
expr_stmt|;
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nkr_stopped
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * generic bound_checking function  */
end_comment

begin_function
name|u_int
name|nm_bound_var
parameter_list|(
name|u_int
modifier|*
name|v
parameter_list|,
name|u_int
name|dflt
parameter_list|,
name|u_int
name|lo
parameter_list|,
name|u_int
name|hi
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|u_int
name|oldv
init|=
operator|*
name|v
decl_stmt|;
specifier|const
name|char
modifier|*
name|op
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dflt
operator|<
name|lo
condition|)
name|dflt
operator|=
name|lo
expr_stmt|;
if|if
condition|(
name|dflt
operator|>
name|hi
condition|)
name|dflt
operator|=
name|hi
expr_stmt|;
if|if
condition|(
name|oldv
operator|<
name|lo
condition|)
block|{
operator|*
name|v
operator|=
name|dflt
expr_stmt|;
name|op
operator|=
literal|"Bump"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldv
operator|>
name|hi
condition|)
block|{
operator|*
name|v
operator|=
name|hi
expr_stmt|;
name|op
operator|=
literal|"Clamp"
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&&
name|msg
condition|)
name|printf
argument_list|(
literal|"%s %s to %d (was %d)\n"
argument_list|,
name|op
argument_list|,
name|msg
argument_list|,
operator|*
name|v
argument_list|,
name|oldv
argument_list|)
expr_stmt|;
return|return
operator|*
name|v
return|;
block|}
end_function

begin_comment
comment|/*  * packet-dump function, user-supplied or static buffer.  * The destination buffer must be at least 30+4*len  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|nm_dump_buf
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|lim
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|)
block|{
specifier|static
name|char
name|_dst
index|[
literal|8192
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|i0
decl_stmt|;
specifier|static
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|char
modifier|*
name|o
decl_stmt|;
comment|/* output position */
define|#
directive|define
name|P_HI
parameter_list|(
name|x
parameter_list|)
value|hex[((x)& 0xf0)>>4]
define|#
directive|define
name|P_LO
parameter_list|(
name|x
parameter_list|)
value|hex[((x)& 0xf)]
define|#
directive|define
name|P_C
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0x20&& (x)<= 0x7e ? (x) : '.')
if|if
condition|(
operator|!
name|dst
condition|)
name|dst
operator|=
name|_dst
expr_stmt|;
if|if
condition|(
name|lim
operator|<=
literal|0
operator|||
name|lim
operator|>
name|len
condition|)
name|lim
operator|=
name|len
expr_stmt|;
name|o
operator|=
name|dst
expr_stmt|;
name|sprintf
argument_list|(
name|o
argument_list|,
literal|"buf 0x%p len %d lim %d\n"
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|o
operator|+=
name|strlen
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* hexdump routine */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
control|)
block|{
name|sprintf
argument_list|(
name|o
argument_list|,
literal|"%5d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|o
operator|+=
name|strlen
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|o
argument_list|,
literal|' '
argument_list|,
literal|48
argument_list|)
expr_stmt|;
name|i0
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|<
name|lim
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|o
index|[
name|j
operator|*
literal|3
index|]
operator|=
name|P_HI
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|o
index|[
name|j
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|P_LO
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|i0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|<
name|lim
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|o
index|[
name|j
operator|+
literal|48
index|]
operator|=
name|P_C
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|o
index|[
name|j
operator|+
literal|48
index|]
operator|=
literal|'\n'
expr_stmt|;
name|o
operator|+=
name|j
operator|+
literal|49
expr_stmt|;
block|}
operator|*
name|o
operator|=
literal|'\0'
expr_stmt|;
undef|#
directive|undef
name|P_HI
undef|#
directive|undef
name|P_LO
undef|#
directive|undef
name|P_C
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/*  * system parameters (most of them in netmap_kern.h)  * NM_NAME	prefix for switch port names, default "vale"  * NM_BDG_MAXPORTS	number of ports  * NM_BRIDGES	max number of switches in the system.  *	XXX should become a sysctl or tunable  *  * Switch ports are named valeX:Y where X is the switch name and Y  * is the port. If Y matches a physical interface name, the port is  * connected to a physical device.  *  * Unlike physical interfaces, switch ports use their own memory region  * for rings and buffers.  * The virtual interfaces use per-queue lock instead of core lock.  * In the tx loop, we aggregate traffic in batches to make all operations  * faster. The batch size is bridge_batch.  */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_MAXRINGS
value|16
end_define

begin_comment
comment|/* XXX unclear how many. */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_MAXSLOTS
value|4096
end_define

begin_comment
comment|/* XXX same as above */
end_comment

begin_define
define|#
directive|define
name|NM_BRIDGE_RINGSIZE
value|1024
end_define

begin_comment
comment|/* in the device */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_HASH
value|1024
end_define

begin_comment
comment|/* forwarding table entries */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_BATCH
value|1024
end_define

begin_comment
comment|/* entries in the forwarding buffer */
end_comment

begin_define
define|#
directive|define
name|NM_MULTISEG
value|64
end_define

begin_comment
comment|/* max size of a chain of bufs */
end_comment

begin_comment
comment|/* actual size of the tables */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_BATCH_MAX
value|(NM_BDG_BATCH + NM_MULTISEG)
end_define

begin_comment
comment|/* NM_FT_NULL terminates a list of slots in the ft */
end_comment

begin_define
define|#
directive|define
name|NM_FT_NULL
value|NM_BDG_BATCH_MAX
end_define

begin_define
define|#
directive|define
name|NM_BRIDGES
value|8
end_define

begin_comment
comment|/* number of bridges */
end_comment

begin_comment
comment|/*  * bridge_batch is set via sysctl to the max batch size to be  * used in the bridge. The actual value may be larger as the  * last packet in the block may overflow the size.  */
end_comment

begin_decl_stmt
name|int
name|bridge_batch
init|=
name|NM_BDG_BATCH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bridge batch size */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|bridge_batch
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bridge_batch
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * These are used to handle reference counters for bridge ports.  */
end_comment

begin_define
define|#
directive|define
name|ADD_BDG_REF
parameter_list|(
name|ifp
parameter_list|)
value|refcount_acquire(&NA(ifp)->na_bdg_refcount)
end_define

begin_define
define|#
directive|define
name|DROP_BDG_REF
parameter_list|(
name|ifp
parameter_list|)
value|refcount_release(&NA(ifp)->na_bdg_refcount)
end_define

begin_comment
comment|/* The bridge references the buffers using the device specific look up table */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|BDG_NMB
parameter_list|(
name|struct
name|netmap_mem_d
modifier|*
name|nmd
parameter_list|,
name|struct
name|netmap_slot
modifier|*
name|slot
parameter_list|)
block|{
name|struct
name|lut_entry
modifier|*
name|lut
init|=
name|nmd
operator|->
name|pools
index|[
name|NETMAP_BUF_POOL
index|]
operator|.
name|lut
decl_stmt|;
name|uint32_t
name|i
init|=
name|slot
operator|->
name|buf_idx
decl_stmt|;
return|return
operator|(
name|unlikely
argument_list|(
name|i
operator|>=
name|nmd
operator|->
name|pools
index|[
name|NETMAP_BUF_POOL
index|]
operator|.
name|objtotal
argument_list|)
operator|)
condition|?
name|lut
index|[
literal|0
index|]
operator|.
name|vaddr
else|:
name|lut
index|[
name|i
index|]
operator|.
name|vaddr
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|bdg_netmap_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bdg_netmap_reg
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|onoff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|kern_netmap_regif
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Each transmit queue accumulates a batch of packets into  * a structure before forwarding. Packets to the same  * destination are put in a list using ft_next as a link field.  * ft_frags and ft_next are valid only on the first fragment.  */
end_comment

begin_struct
struct|struct
name|nm_bdg_fwd
block|{
comment|/* forwarding entry for a bridge */
name|void
modifier|*
name|ft_buf
decl_stmt|;
comment|/* netmap or indirect buffer */
name|uint8_t
name|ft_frags
decl_stmt|;
comment|/* how many fragments (only on 1st frag) */
name|uint8_t
name|_ft_port
decl_stmt|;
comment|/* dst port (unused) */
name|uint16_t
name|ft_flags
decl_stmt|;
comment|/* flags, e.g. indirect */
name|uint16_t
name|ft_len
decl_stmt|;
comment|/* src fragment len */
name|uint16_t
name|ft_next
decl_stmt|;
comment|/* next packet to same destination */
block|}
struct|;
end_struct

begin_comment
comment|/*  * For each output interface, nm_bdg_q is used to construct a list.  * bq_len is the number of output buffers (we can have coalescing  * during the copy).  */
end_comment

begin_struct
struct|struct
name|nm_bdg_q
block|{
name|uint16_t
name|bq_head
decl_stmt|;
name|uint16_t
name|bq_tail
decl_stmt|;
name|uint32_t
name|bq_len
decl_stmt|;
comment|/* number of buffers */
block|}
struct|;
end_struct

begin_comment
comment|/* XXX revise this */
end_comment

begin_struct
struct|struct
name|nm_hash_ent
block|{
name|uint64_t
name|mac
decl_stmt|;
comment|/* the top 2 bytes are the epoch */
name|uint64_t
name|ports
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * nm_bridge is a descriptor for a VALE switch.  * Interfaces for a bridge are all in bdg_ports[].  * The array has fixed size, an empty entry does not terminate  * the search, but lookups only occur on attach/detach so we  * don't mind if they are slow.  *  * The bridge is non blocking on the transmit ports: excess  * packets are dropped if there is no room on the output port.  *  * bdg_lock protects accesses to the bdg_ports array.  * This is a rw lock (or equivalent).  */
end_comment

begin_struct
struct|struct
name|nm_bridge
block|{
comment|/* XXX what is the proper alignment/layout ? */
name|BDG_RWLOCK_T
name|bdg_lock
decl_stmt|;
comment|/* protects bdg_ports */
name|int
name|bdg_namelen
decl_stmt|;
name|uint32_t
name|bdg_active_ports
decl_stmt|;
comment|/* 0 means free */
name|char
name|bdg_basename
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
comment|/* Indexes of active ports (up to active_ports) 	 * and all other remaining ports. 	 */
name|uint8_t
name|bdg_port_index
index|[
name|NM_BDG_MAXPORTS
index|]
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|bdg_ports
index|[
name|NM_BDG_MAXPORTS
index|]
decl_stmt|;
comment|/* 	 * The function to decide the destination port. 	 * It returns either of an index of the destination port, 	 * NM_BDG_BROADCAST to broadcast this packet, or NM_BDG_NOPORT not to 	 * forward this packet.  ring_nr is the source ring index, and the 	 * function may overwrite this value to forward this packet to a 	 * different ring index. 	 * This function must be set by netmap_bdgctl(). 	 */
name|bdg_lookup_fn_t
name|nm_bdg_lookup
decl_stmt|;
comment|/* the forwarding table, MAC+ports. 	 * XXX should be changed to an argument to be passed to 	 * the lookup function, and allocated on attach 	 */
name|struct
name|nm_hash_ent
name|ht
index|[
name|NM_BDG_HASH
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * XXX in principle nm_bridges could be created dynamically  * Right now we have a static array and deletions are protected  * by an exclusive lock.  */
end_comment

begin_decl_stmt
name|struct
name|nm_bridge
name|nm_bridges
index|[
name|NM_BRIDGES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A few function to tell which kind of port are we using.  * XXX should we hold a lock ?  *  * nma_is_vp()		virtual port  * nma_is_host()	port connected to the host stack  * nma_is_hw()		port connected to a NIC  */
end_comment

begin_function_decl
name|int
name|nma_is_vp
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|nma_is_vp
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
return|return
name|na
operator|->
name|nm_register
operator|==
name|bdg_netmap_reg
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|nma_is_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
return|return
name|na
operator|->
name|nm_register
operator|==
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|nma_is_hw
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
comment|/* In case of sw adapter, nm_register is NULL */
return|return
operator|!
name|nma_is_vp
argument_list|(
name|na
argument_list|)
operator|&&
operator|!
name|nma_is_host
argument_list|(
name|na
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * If the NIC is owned by the kernel  * (i.e., bridge), neither another bridge nor user can use it;  * if the NIC is owned by a user, only users can share it.  * Evaluation must be done under NMG_LOCK().  */
end_comment

begin_define
define|#
directive|define
name|NETMAP_OWNED_BY_KERN
parameter_list|(
name|ifp
parameter_list|)
value|(!nma_is_vp(NA(ifp))&& NA(ifp)->na_bdg)
end_define

begin_define
define|#
directive|define
name|NETMAP_OWNED_BY_ANY
parameter_list|(
name|ifp
parameter_list|)
define|\
value|(NETMAP_OWNED_BY_KERN(ifp) || (NA(ifp)->refcount> 0))
end_define

begin_comment
comment|/*  * NA(ifp)->bdg_port	port index  */
end_comment

begin_comment
comment|/*  * this is a slightly optimized copy routine which rounds  * to multiple of 64 bytes and is often faster than dealing  * with other odd sizes. We assume there is enough room  * in the source and destination buffers.  *  * XXX only for multiples of 64 bytes, non overlapped.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pkt_copy
parameter_list|(
name|void
modifier|*
name|_src
parameter_list|,
name|void
modifier|*
name|_dst
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|uint64_t
modifier|*
name|src
init|=
name|_src
decl_stmt|;
name|uint64_t
modifier|*
name|dst
init|=
name|_dst
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|l
operator|>=
literal|1024
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
name|likely
argument_list|(
name|l
operator|>
literal|0
argument_list|)
condition|;
name|l
operator|-=
literal|64
control|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_STUFF
end_ifdef

begin_struct
struct|struct
name|xxx
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|uint32_t
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|nm_test_defmtx
parameter_list|(
name|uint32_t
name|n
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|struct
name|mtx
name|m
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|m
argument_list|,
literal|"test"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|nm_test_spinmtx
parameter_list|(
name|uint32_t
name|n
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|struct
name|mtx
name|m
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|m
argument_list|,
literal|"test"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|nm_test_rlock
parameter_list|(
name|uint32_t
name|n
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|struct
name|rwlock
name|m
decl_stmt|;
name|rw_init
argument_list|(
operator|&
name|m
argument_list|,
literal|"test"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|rw_rlock
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
name|rw_destroy
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|nm_test_wlock
parameter_list|(
name|uint32_t
name|n
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|struct
name|rwlock
name|m
decl_stmt|;
name|rw_init
argument_list|(
operator|&
name|m
argument_list|,
literal|"test"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
name|rw_destroy
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|nm_test_slock
parameter_list|(
name|uint32_t
name|n
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|struct
name|sx
name|m
decl_stmt|;
name|sx_init
argument_list|(
operator|&
name|m
argument_list|,
literal|"test"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|sx_slock
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
name|sx_destroy
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|nm_test_xlock
parameter_list|(
name|uint32_t
name|n
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|struct
name|sx
name|m
decl_stmt|;
name|sx_init
argument_list|(
operator|&
name|m
argument_list|,
literal|"test"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
name|sx_destroy
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
name|struct
name|xxx
name|nm_tests
index|[]
init|=
block|{
block|{
literal|"defmtx"
block|,
name|nm_test_defmtx
block|}
block|,
block|{
literal|"spinmtx"
block|,
name|nm_test_spinmtx
block|}
block|,
block|{
literal|"rlock"
block|,
name|nm_test_rlock
block|}
block|,
block|{
literal|"wlock"
block|,
name|nm_test_wlock
block|}
block|,
block|{
literal|"slock"
block|,
name|nm_test_slock
block|}
block|,
block|{
literal|"xlock"
block|,
name|nm_test_xlock
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|nm_test
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
block|{
name|uint32_t
name|scale
decl_stmt|,
name|n
decl_stmt|,
name|test
decl_stmt|;
specifier|static
name|int
name|old_test
init|=
operator|-
literal|1
decl_stmt|;
name|test
operator|=
name|nmr
operator|->
name|nr_cmd
expr_stmt|;
name|scale
operator|=
name|nmr
operator|->
name|nr_offset
expr_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|nm_tests
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|xxx
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|test
operator|>
name|n
condition|)
block|{
name|D
argument_list|(
literal|"test index too high, max %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|old_test
operator|!=
name|test
condition|)
block|{
name|D
argument_list|(
literal|"test %s scale %d"
argument_list|,
name|nm_tests
index|[
name|test
index|]
operator|.
name|name
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|old_test
operator|=
name|test
expr_stmt|;
block|}
name|nm_tests
index|[
name|test
index|]
operator|.
name|fn
argument_list|(
name|scale
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_STUFF */
end_comment

begin_comment
comment|/*  * locate a bridge among the existing ones.  * MUST BE CALLED WITH NMG_LOCK()  *  * a ':' in the name terminates the bridge name. Otherwise, just NM_NAME.  * We assume that this is called with a name of at least NM_NAME chars.  */
end_comment

begin_function
specifier|static
name|struct
name|nm_bridge
modifier|*
name|nm_find_bridge
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|namelen
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|NM_NAME
argument_list|)
expr_stmt|;
comment|/* base length */
name|l
operator|=
name|name
condition|?
name|strlen
argument_list|(
name|name
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* actual length */
if|if
condition|(
name|l
operator|<
name|namelen
condition|)
block|{
name|D
argument_list|(
literal|"invalid bridge name %s"
argument_list|,
name|name
condition|?
name|name
else|:
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
name|namelen
operator|+
literal|1
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|':'
condition|)
block|{
name|namelen
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|namelen
operator|>=
name|IFNAMSIZ
condition|)
name|namelen
operator|=
name|IFNAMSIZ
expr_stmt|;
name|ND
argument_list|(
literal|"--- prefix is '%.*s' ---"
argument_list|,
name|namelen
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* lookup the name, remember empty slot if there is one */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BRIDGES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nm_bridge
modifier|*
name|x
init|=
name|nm_bridges
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|bdg_active_ports
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|create
operator|&&
name|b
operator|==
name|NULL
condition|)
name|b
operator|=
name|x
expr_stmt|;
comment|/* record empty slot */
block|}
elseif|else
if|if
condition|(
name|x
operator|->
name|bdg_namelen
operator|!=
name|namelen
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|x
operator|->
name|bdg_basename
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ND
argument_list|(
literal|"found '%.*s' at %d"
argument_list|,
name|namelen
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|b
operator|=
name|x
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|NM_BRIDGES
operator|&&
name|b
condition|)
block|{
comment|/* name not found, can create entry */
comment|/* initialize the bridge */
name|strncpy
argument_list|(
name|b
operator|->
name|bdg_basename
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"create new bridge %s with ports %d"
argument_list|,
name|b
operator|->
name|bdg_basename
argument_list|,
name|b
operator|->
name|bdg_active_ports
argument_list|)
expr_stmt|;
name|b
operator|->
name|bdg_namelen
operator|=
name|namelen
expr_stmt|;
name|b
operator|->
name|bdg_active_ports
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BDG_MAXPORTS
condition|;
name|i
operator|++
control|)
name|b
operator|->
name|bdg_port_index
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* set the default function */
name|b
operator|->
name|nm_bdg_lookup
operator|=
name|netmap_bdg_learning
expr_stmt|;
comment|/* reset the MAC address table */
name|bzero
argument_list|(
name|b
operator|->
name|ht
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nm_hash_ent
argument_list|)
operator|*
name|NM_BDG_HASH
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Free the forwarding tables for rings attached to switch ports.  */
end_comment

begin_function
specifier|static
name|void
name|nm_free_bdgfwd
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|int
name|nrings
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|nrings
operator|=
name|nma_is_vp
argument_list|(
name|na
argument_list|)
condition|?
name|na
operator|->
name|num_tx_rings
else|:
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|kring
operator|=
name|nma_is_vp
argument_list|(
name|na
argument_list|)
condition|?
name|na
operator|->
name|tx_rings
else|:
name|na
operator|->
name|rx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrings
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
condition|)
block|{
name|free
argument_list|(
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
operator|=
name|NULL
expr_stmt|;
comment|/* protect from freeing twice */
block|}
block|}
if|if
condition|(
name|nma_is_hw
argument_list|(
name|na
argument_list|)
condition|)
name|nm_free_bdgfwd
argument_list|(
name|SWNA
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate the forwarding tables for the rings attached to the bridge ports.  */
end_comment

begin_function
specifier|static
name|int
name|nm_alloc_bdgfwd
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|int
name|nrings
decl_stmt|,
name|l
decl_stmt|,
name|i
decl_stmt|,
name|num_dstq
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* all port:rings + broadcast */
name|num_dstq
operator|=
name|NM_BDG_MAXPORTS
operator|*
name|NM_BDG_MAXRINGS
operator|+
literal|1
expr_stmt|;
name|l
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nm_bdg_fwd
argument_list|)
operator|*
name|NM_BDG_BATCH_MAX
expr_stmt|;
name|l
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|nm_bdg_q
argument_list|)
operator|*
name|num_dstq
expr_stmt|;
name|l
operator|+=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|NM_BDG_BATCH_MAX
expr_stmt|;
name|nrings
operator|=
name|nma_is_vp
argument_list|(
name|na
argument_list|)
condition|?
name|na
operator|->
name|num_tx_rings
else|:
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|kring
operator|=
name|nma_is_vp
argument_list|(
name|na
argument_list|)
condition|?
name|na
operator|->
name|tx_rings
else|:
name|na
operator|->
name|rx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
decl_stmt|;
name|struct
name|nm_bdg_q
modifier|*
name|dstq
decl_stmt|;
name|int
name|j
decl_stmt|;
name|ft
operator|=
name|malloc
argument_list|(
name|l
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ft
condition|)
block|{
name|nm_free_bdgfwd
argument_list|(
name|na
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|dstq
operator|=
operator|(
expr|struct
name|nm_bdg_q
operator|*
operator|)
operator|(
name|ft
operator|+
name|NM_BDG_BATCH_MAX
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_dstq
condition|;
name|j
operator|++
control|)
block|{
name|dstq
index|[
name|j
index|]
operator|.
name|bq_head
operator|=
name|dstq
index|[
name|j
index|]
operator|.
name|bq_tail
operator|=
name|NM_FT_NULL
expr_stmt|;
name|dstq
index|[
name|j
index|]
operator|.
name|bq_len
operator|=
literal|0
expr_stmt|;
block|}
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
operator|=
name|ft
expr_stmt|;
block|}
if|if
condition|(
name|nma_is_hw
argument_list|(
name|na
argument_list|)
condition|)
name|nm_alloc_bdgfwd
argument_list|(
name|SWNA
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch configuration from the device, to cope with dynamic  * reconfigurations after loading the module.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_update_config
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|u_int
name|txr
decl_stmt|,
name|txd
decl_stmt|,
name|rxr
decl_stmt|,
name|rxd
decl_stmt|;
name|txr
operator|=
name|txd
operator|=
name|rxr
operator|=
name|rxd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_config
condition|)
block|{
name|na
operator|->
name|nm_config
argument_list|(
name|ifp
argument_list|,
operator|&
name|txr
argument_list|,
operator|&
name|txd
argument_list|,
operator|&
name|rxr
argument_list|,
operator|&
name|rxd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* take whatever we had at init time */
name|txr
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|txd
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|rxr
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|rxd
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|==
name|txr
operator|&&
name|na
operator|->
name|num_tx_desc
operator|==
name|txd
operator|&&
name|na
operator|->
name|num_rx_rings
operator|==
name|rxr
operator|&&
name|na
operator|->
name|num_rx_desc
operator|==
name|rxd
condition|)
return|return
literal|0
return|;
comment|/* nothing changed */
if|if
condition|(
name|netmap_verbose
operator|||
name|na
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"stored config %s: txring %d x %d, rxring %d x %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|na
operator|->
name|num_tx_rings
argument_list|,
name|na
operator|->
name|num_tx_desc
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|,
name|na
operator|->
name|num_rx_desc
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"new config %s: txring %d x %d, rxring %d x %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|txr
argument_list|,
name|txd
argument_list|,
name|rxr
argument_list|,
name|rxd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"configuration changed (but fine)"
argument_list|)
expr_stmt|;
name|na
operator|->
name|num_tx_rings
operator|=
name|txr
expr_stmt|;
name|na
operator|->
name|num_tx_desc
operator|=
name|txd
expr_stmt|;
name|na
operator|->
name|num_rx_rings
operator|=
name|rxr
expr_stmt|;
name|na
operator|->
name|num_rx_desc
operator|=
name|rxd
expr_stmt|;
return|return
literal|0
return|;
block|}
name|D
argument_list|(
literal|"configuration changed while active, this is bad..."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|netmap_if
modifier|*
name|netmap_if_new
parameter_list|(
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
if|if
condition|(
name|netmap_update_config
argument_list|(
name|na
argument_list|)
condition|)
block|{
comment|/* configuration mismatch, report and fail */
return|return
name|NULL
return|;
block|}
return|return
name|netmap_mem_if_new
argument_list|(
name|ifname
argument_list|,
name|na
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Structure associated to each thread which registered an interface.  *  * The first 4 fields of this structure are written by NIOCREGIF and  * read by poll() and NIOC?XSYNC.  * There is low contention among writers (actually, a correct user program  * should have no contention among writers) and among writers and readers,  * so we use a single global lock to protect the structure initialization.  * Since initialization involves the allocation of memory, we reuse the memory  * allocator lock.  * Read access to the structure is lock free. Readers must check that  * np_nifp is not NULL before using the other fields.  * If np_nifp is NULL initialization has not been performed, so they should  * return an error to userlevel.  *  * The ref_done field is used to regulate access to the refcount in the  * memory allocator. The refcount must be incremented at most once for  * each open("/dev/netmap"). The increment is performed by the first  * function that calls netmap_get_memory() (currently called by  * mmap(), NIOCGINFO and NIOCREGIF).  * If the refcount is incremented, it is then decremented when the  * private structure is destroyed.  */
end_comment

begin_struct
struct|struct
name|netmap_priv_d
block|{
name|struct
name|netmap_if
modifier|*
specifier|volatile
name|np_nifp
decl_stmt|;
comment|/* netmap if descriptor. */
name|struct
name|ifnet
modifier|*
name|np_ifp
decl_stmt|;
comment|/* device for which we hold a ref. */
name|int
name|np_ringid
decl_stmt|;
comment|/* from the ioctl */
name|u_int
name|np_qfirst
decl_stmt|,
name|np_qlast
decl_stmt|;
comment|/* range of rings to scan */
name|uint16_t
name|np_txpoll
decl_stmt|;
name|struct
name|netmap_mem_d
modifier|*
name|np_mref
decl_stmt|;
comment|/* use with NMG_LOCK held */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|int
name|np_refcount
decl_stmt|;
comment|/* use with NMG_LOCK held */
endif|#
directive|endif
comment|/* __FreeBSD__ */
block|}
struct|;
end_struct

begin_comment
comment|/* grab a reference to the memory allocator, if we don't have one already.  The  * reference is taken from the netmap_adapter registered with the priv.  *  */
end_comment

begin_function
specifier|static
name|int
name|netmap_get_memory_locked
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|netmap_mem_d
modifier|*
name|nmd
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|np_ifp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|netmap_mmap_unreg
condition|)
return|return
name|ENODEV
return|;
comment|/* for compatibility with older versions of the API  		 * we use the global allocator when no interface has been  		 * registered  		 */
name|nmd
operator|=
operator|&
name|nm_mem
expr_stmt|;
block|}
else|else
block|{
name|nmd
operator|=
name|NA
argument_list|(
name|p
operator|->
name|np_ifp
argument_list|)
operator|->
name|nm_mem
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|np_mref
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|netmap_mem_finalize
argument_list|(
name|nmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|p
operator|->
name|np_mref
operator|=
name|nmd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|np_mref
operator|!=
name|nmd
condition|)
block|{
comment|/* a virtual port has been registered, but previous  		 * syscalls already used the global allocator.  		 * We cannot continue  		 */
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_get_memory
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_get_memory_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_have_memory_locked
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|p
parameter_list|)
block|{
return|return
name|p
operator|->
name|np_mref
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_drop_memory_locked
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|np_mref
condition|)
block|{
name|netmap_mem_deref
argument_list|(
name|p
operator|->
name|np_mref
argument_list|)
expr_stmt|;
name|p
operator|->
name|np_mref
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * File descriptor's private data destructor.  *  * Call nm_register(ifp,0) to stop netmap mode on the interface and  * revert to normal operation. We expect that np_ifp has not gone.  * The second argument is the nifp to work on. In some cases it is  * not attached yet to the netmap_priv_d so we need to pass it as  * a separate argument.  */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
specifier|static
name|void
name|netmap_do_unregif
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|struct
name|netmap_if
modifier|*
name|nifp
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|np_ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|na
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|refcount
operator|<=
literal|0
condition|)
block|{
comment|/* last instance */
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"deleting last instance for %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* 		 * (TO CHECK) This function is only called 		 * when the last reference to this file descriptor goes 		 * away. This means we cannot have any pending poll() 		 * or interrupt routine operating on the structure. 		 * XXX The file may be closed in a thread while 		 * another thread is using it. 		 * Linux keeps the file opened until the last reference 		 * by any outstanding ioctl/poll or mmap is gone. 		 * FreeBSD does not track mmap()s (but we do) and 		 * wakes up any sleeping poll(). Need to check what 		 * happens if the close() occurs while a concurrent 		 * syscall is running. 		 */
name|na
operator|->
name|nm_register
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* off, clear IFCAP_NETMAP */
comment|/* Wake up any sleeping threads. netmap_poll will 		 * then return POLLERR 		 * XXX The wake up now must happen during *_down(), when 		 * we order all activities to stop. -gl 		 */
name|nm_free_bdgfwd
argument_list|(
name|na
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
block|}
comment|/* XXX kqueue(9) needed; these will mirror knlist_init. */
comment|/* knlist_destroy(&na->tx_si.si_note); */
comment|/* knlist_destroy(&na->rx_si.si_note); */
if|if
condition|(
name|nma_is_hw
argument_list|(
name|na
argument_list|)
condition|)
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|tx_rings
operator|=
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|rx_rings
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * netmap_mem_if_delete() deletes the nifp, and if this is 	 * the last instance also buffers, rings and krings. 	 */
name|netmap_mem_if_delete
argument_list|(
name|na
argument_list|,
name|nifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* we assume netmap adapter exists  * Called with NMG_LOCK held  */
end_comment

begin_function
specifier|static
name|void
name|nm_if_rele
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|is_hw
decl_stmt|,
name|hw
decl_stmt|,
name|sw
decl_stmt|,
name|lim
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|uint8_t
name|tmp
index|[
name|NM_BDG_MAXPORTS
index|]
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* I can be called not only for get_ifp()-ed references where netmap's 	 * capability is guaranteed, but also for non-netmap-capable NICs. 	 */
if|if
condition|(
operator|!
name|NETMAP_CAPABLE
argument_list|(
name|ifp
argument_list|)
operator|||
operator|!
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_bdg
condition|)
block|{
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|b
operator|=
name|na
operator|->
name|na_bdg
expr_stmt|;
name|is_hw
operator|=
name|nma_is_hw
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"%s has %d references"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_bdg_refcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DROP_BDG_REF
argument_list|(
name|ifp
argument_list|)
condition|)
return|return;
comment|/* 	New algorithm: 	make a copy of bdg_port_index; 	lookup NA(ifp)->bdg_port and SWNA(ifp)->bdg_port 	in the array of bdg_port_index, replacing them with 	entries from the bottom of the array; 	decrement bdg_active_ports; 	acquire BDG_WLOCK() and copy back the array. 	 */
name|hw
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|bdg_port
expr_stmt|;
name|sw
operator|=
operator|(
name|is_hw
operator|&&
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_bdg
operator|)
condition|?
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|bdg_port
else|:
operator|-
literal|1
expr_stmt|;
name|lim
operator|=
name|b
operator|->
name|bdg_active_ports
expr_stmt|;
name|ND
argument_list|(
literal|"detach %d and %d (lim %d)"
argument_list|,
name|hw
argument_list|,
name|sw
argument_list|,
name|lim
argument_list|)
expr_stmt|;
comment|/* make a copy of the list of active ports, update it, 	 * and then copy back within BDG_WLOCK(). 	 */
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|b
operator|->
name|bdg_port_index
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|hw
operator|>=
literal|0
operator|||
name|sw
operator|>=
literal|0
operator|)
operator|&&
name|i
operator|<
name|lim
condition|;
control|)
block|{
if|if
condition|(
name|hw
operator|>=
literal|0
operator|&&
name|tmp
index|[
name|i
index|]
operator|==
name|hw
condition|)
block|{
name|ND
argument_list|(
literal|"detach hw %d at %d"
argument_list|,
name|hw
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lim
operator|--
expr_stmt|;
comment|/* point to last active port */
name|tmp
index|[
name|i
index|]
operator|=
name|tmp
index|[
name|lim
index|]
expr_stmt|;
comment|/* swap with i */
name|tmp
index|[
name|lim
index|]
operator|=
name|hw
expr_stmt|;
comment|/* now this is inactive */
name|hw
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sw
operator|>=
literal|0
operator|&&
name|tmp
index|[
name|i
index|]
operator|==
name|sw
condition|)
block|{
name|ND
argument_list|(
literal|"detach sw %d at %d"
argument_list|,
name|sw
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lim
operator|--
expr_stmt|;
name|tmp
index|[
name|i
index|]
operator|=
name|tmp
index|[
name|lim
index|]
expr_stmt|;
name|tmp
index|[
name|lim
index|]
operator|=
name|sw
expr_stmt|;
name|sw
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hw
operator|>=
literal|0
operator|||
name|sw
operator|>=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"XXX delete failed hw %d sw %d, should panic..."
argument_list|,
name|hw
argument_list|,
name|sw
argument_list|)
expr_stmt|;
block|}
name|hw
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|bdg_port
expr_stmt|;
name|sw
operator|=
operator|(
name|is_hw
operator|&&
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_bdg
operator|)
condition|?
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|bdg_port
else|:
operator|-
literal|1
expr_stmt|;
name|BDG_WLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|bdg_ports
index|[
name|hw
index|]
operator|=
name|NULL
expr_stmt|;
name|na
operator|->
name|na_bdg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sw
operator|>=
literal|0
condition|)
block|{
name|b
operator|->
name|bdg_ports
index|[
name|sw
index|]
operator|=
name|NULL
expr_stmt|;
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_bdg
operator|=
name|NULL
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|b
operator|->
name|bdg_port_index
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|bdg_active_ports
operator|=
name|lim
expr_stmt|;
name|BDG_WUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"now %d active ports"
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|lim
operator|==
literal|0
condition|)
block|{
name|ND
argument_list|(
literal|"marking bridge %s as free"
argument_list|,
name|b
operator|->
name|bdg_basename
argument_list|)
expr_stmt|;
name|b
operator|->
name|nm_bdg_lookup
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|is_hw
condition|)
block|{
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_MEM_OWNER
condition|)
name|netmap_mem_private_delete
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|na
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|na
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ifp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ifp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * returns 1 if this is the last instance and we can free priv  */
end_comment

begin_function
specifier|static
name|int
name|netmap_dtor_locked
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|np_ifp
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* 	 * np_refcount is the number of active mmaps on 	 * this file descriptor 	 */
if|if
condition|(
operator|--
name|priv
operator|->
name|np_refcount
operator|>
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* __FreeBSD__ */
if|if
condition|(
name|ifp
condition|)
block|{
name|netmap_do_unregif
argument_list|(
name|priv
argument_list|,
name|priv
operator|->
name|np_nifp
argument_list|)
expr_stmt|;
block|}
name|netmap_drop_memory_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
condition|)
block|{
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* might also destroy *na */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_dtor
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|data
decl_stmt|;
name|int
name|last_instance
decl_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|last_instance
operator|=
name|netmap_dtor_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_instance
condition|)
block|{
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for safety */
name|free
argument_list|(
name|priv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_comment
comment|/*  * In order to track whether pages are still mapped, we hook into  * the standard cdev_pager and intercept the constructor and  * destructor.  */
end_comment

begin_struct
struct|struct
name|netmap_vm_handle_t
block|{
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|priv
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|netmap_dev_pager_ctor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_ooffset_t
name|foff
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|u_short
modifier|*
name|color
parameter_list|)
block|{
name|struct
name|netmap_vm_handle_t
modifier|*
name|vmh
init|=
name|handle
decl_stmt|;
name|D
argument_list|(
literal|"handle %p size %jd prot %d foff %jd"
argument_list|,
name|handle
argument_list|,
operator|(
name|intmax_t
operator|)
name|size
argument_list|,
name|prot
argument_list|,
operator|(
name|intmax_t
operator|)
name|foff
argument_list|)
expr_stmt|;
name|dev_ref
argument_list|(
name|vmh
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_dev_pager_dtor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|netmap_vm_handle_t
modifier|*
name|vmh
init|=
name|handle
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
init|=
name|vmh
operator|->
name|dev
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|vmh
operator|->
name|priv
decl_stmt|;
name|D
argument_list|(
literal|"handle %p"
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|netmap_dtor
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vmh
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|dev_rel
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_dev_pager_fault
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|int
name|prot
parameter_list|,
name|vm_page_t
modifier|*
name|mres
parameter_list|)
block|{
name|struct
name|netmap_vm_handle_t
modifier|*
name|vmh
init|=
name|object
operator|->
name|handle
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|vmh
operator|->
name|priv
decl_stmt|;
name|vm_paddr_t
name|paddr
decl_stmt|;
name|vm_page_t
name|page
decl_stmt|;
name|vm_memattr_t
name|memattr
decl_stmt|;
name|vm_pindex_t
name|pidx
decl_stmt|;
name|ND
argument_list|(
literal|"object %p offset %jd prot %d mres %p"
argument_list|,
name|object
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|,
name|prot
argument_list|,
name|mres
argument_list|)
expr_stmt|;
name|memattr
operator|=
name|object
operator|->
name|memattr
expr_stmt|;
name|pidx
operator|=
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|netmap_mem_ofstophys
argument_list|(
name|priv
operator|->
name|np_mref
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|paddr
operator|==
literal|0
condition|)
return|return
name|VM_PAGER_FAIL
return|;
if|if
condition|(
operator|(
operator|(
operator|*
name|mres
operator|)
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If the passed in result page is a fake page, update it with 		 * the new physical address. 		 */
name|page
operator|=
operator|*
name|mres
expr_stmt|;
name|vm_page_updatefake
argument_list|(
name|page
argument_list|,
name|paddr
argument_list|,
name|memattr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Replace the passed in reqpage page with our own fake page and 		 * free up the all of the original pages. 		 */
ifndef|#
directive|ifndef
name|VM_OBJECT_WUNLOCK
comment|/* FreeBSD< 10.x */
define|#
directive|define
name|VM_OBJECT_WUNLOCK
value|VM_OBJECT_UNLOCK
define|#
directive|define
name|VM_OBJECT_WLOCK
value|VM_OBJECT_LOCK
endif|#
directive|endif
comment|/* VM_OBJECT_WUNLOCK */
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|page
operator|=
name|vm_page_getfake
argument_list|(
name|paddr
argument_list|,
name|memattr
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
operator|*
name|mres
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
operator|*
name|mres
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
operator|*
name|mres
argument_list|)
expr_stmt|;
operator|*
name|mres
operator|=
name|page
expr_stmt|;
name|vm_page_insert
argument_list|(
name|page
argument_list|,
name|object
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
block|}
name|page
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
return|return
operator|(
name|VM_PAGER_OK
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdev_pager_ops
name|netmap_cdev_pager_ops
init|=
block|{
operator|.
name|cdev_pg_ctor
operator|=
name|netmap_dev_pager_ctor
block|,
operator|.
name|cdev_pg_dtor
operator|=
name|netmap_dev_pager_dtor
block|,
operator|.
name|cdev_pg_fault
operator|=
name|netmap_dev_pager_fault
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|netmap_mmap_single
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|vm_ooffset_t
modifier|*
name|foff
parameter_list|,
name|vm_size_t
name|objsize
parameter_list|,
name|vm_object_t
modifier|*
name|objp
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|netmap_vm_handle_t
modifier|*
name|vmh
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|priv
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|D
argument_list|(
literal|"cdev %p foff %jd size %jd objp %p prot %d"
argument_list|,
name|cdev
argument_list|,
operator|(
name|intmax_t
operator|)
operator|*
name|foff
argument_list|,
operator|(
name|intmax_t
operator|)
name|objsize
argument_list|,
name|objp
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|vmh
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_vm_handle_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmh
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|vmh
operator|->
name|dev
operator|=
name|cdev
expr_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_unlock
goto|;
name|vmh
operator|->
name|priv
operator|=
name|priv
expr_stmt|;
name|priv
operator|->
name|np_refcount
operator|++
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_get_memory
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_deref
goto|;
name|obj
operator|=
name|cdev_pager_allocate
argument_list|(
name|vmh
argument_list|,
name|OBJT_DEVICE
argument_list|,
operator|&
name|netmap_cdev_pager_ops
argument_list|,
name|objsize
argument_list|,
name|prot
argument_list|,
operator|*
name|foff
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"cdev_pager_allocate failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err_deref
goto|;
block|}
operator|*
name|objp
operator|=
name|obj
expr_stmt|;
return|return
literal|0
return|;
name|err_deref
label|:
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|priv
operator|->
name|np_refcount
operator|--
expr_stmt|;
name|err_unlock
label|:
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
comment|// err:
name|free
argument_list|(
name|vmh
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|// XXX can we remove this ?
end_comment

begin_function
specifier|static
name|int
name|netmap_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"dev %p fflag 0x%x devtype %d td %p"
argument_list|,
name|dev
argument_list|,
name|fflag
argument_list|,
name|devtype
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|dev
expr_stmt|;
operator|(
name|void
operator|)
name|oflags
expr_stmt|;
operator|(
name|void
operator|)
name|devtype
expr_stmt|;
operator|(
name|void
operator|)
name|td
expr_stmt|;
comment|// XXX wait or nowait ?
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_priv_d
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|error
operator|=
name|devfs_set_cdevpriv
argument_list|(
name|priv
argument_list|,
name|netmap_dtor
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|priv
operator|->
name|np_refcount
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/*  * Handlers for synchronization of the queues from/to the host.  * Netmap has two operating modes:  * - in the default mode, the rings connected to the host stack are  *   just another ring pair managed by userspace;  * - in transparent mode (XXX to be defined) incoming packets  *   (from the host or the NIC) are marked as NS_FORWARD upon  *   arrival, and the user application has a chance to reset the  *   flag for packets that should be dropped.  *   On the RXSYNC or poll(), packets in RX rings between  *   kring->nr_kcur and ring->cur with NS_FORWARD still set are moved  *   to the other side.  * The transfer NIC --> host is relatively easy, just encapsulate  * into mbufs and we are done. The host --> NIC side is slightly  * harder because there might not be room in the tx ring so it  * might take a while before releasing the buffer.  */
end_comment

begin_comment
comment|/*  * pass a chain of buffers to the host stack as coming from 'dst'  */
end_comment

begin_function
specifier|static
name|void
name|netmap_send_up
parameter_list|(
name|struct
name|ifnet
modifier|*
name|dst
parameter_list|,
name|struct
name|mbuf
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* send packets up, outside the lock */
while|while
condition|(
operator|(
name|m
operator|=
name|head
operator|)
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
name|head
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"sending up pkt %p size %d"
argument_list|,
name|m
argument_list|,
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|NM_SEND_UP
argument_list|(
name|dst
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|mbq
block|{
name|struct
name|mbuf
modifier|*
name|head
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|tail
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * put a copy of the buffers marked NS_FORWARD into an mbuf chain.  * Run from hwcur to cur - reserved  */
end_comment

begin_function
specifier|static
name|void
name|netmap_grab_packets
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|struct
name|mbq
modifier|*
name|q
parameter_list|,
name|int
name|force
parameter_list|)
block|{
comment|/* Take packets from hwcur to cur-reserved and pass them up. 	 * In case of no buffers we give up. At the end of the loop, 	 * the queue is drained in all cases. 	 * XXX handle reserved 	 */
name|u_int
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|tail
init|=
name|q
operator|->
name|tail
decl_stmt|;
name|u_int
name|k
init|=
name|kring
operator|->
name|ring
operator|->
name|cur
decl_stmt|,
name|n
init|=
name|kring
operator|->
name|ring
operator|->
name|reserved
decl_stmt|;
name|struct
name|netmap_mem_d
modifier|*
name|nmd
init|=
name|kring
operator|->
name|na
operator|->
name|nm_mem
decl_stmt|;
comment|/* compute the final position, ring->cur - ring->reserved */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|k
operator|<
name|n
condition|)
name|k
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|k
operator|+=
name|n
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
name|kring
operator|->
name|nr_hwcur
init|;
name|n
operator|!=
name|k
condition|;
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|n
index|]
decl_stmt|;
name|n
operator|=
name|nm_next
argument_list|(
name|n
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_FORWARD
operator|)
operator|==
literal|0
operator|&&
operator|!
name|force
condition|)
continue|continue;
if|if
condition|(
name|slot
operator|->
name|len
operator|<
literal|14
operator|||
name|slot
operator|->
name|len
operator|>
name|NETMAP_BDG_BUF_SIZE
argument_list|(
name|nmd
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"bad pkt at %d len %d"
argument_list|,
name|n
argument_list|,
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_FORWARD
expr_stmt|;
comment|// XXX needed ?
comment|/* XXX adapt to the case of a multisegment packet */
name|m
operator|=
name|m_devget
argument_list|(
name|BDG_NMB
argument_list|(
name|nmd
argument_list|,
name|slot
argument_list|)
argument_list|,
name|slot
operator|->
name|len
argument_list|,
literal|0
argument_list|,
name|kring
operator|->
name|na
operator|->
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|tail
condition|)
name|tail
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
else|else
name|q
operator|->
name|head
operator|=
name|m
expr_stmt|;
name|tail
operator|=
name|m
expr_stmt|;
name|q
operator|->
name|count
operator|++
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
block|}
name|q
operator|->
name|tail
operator|=
name|tail
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The host ring has packets from nr_hwcur to (cur - reserved)  * to be sent down to the NIC.  * We need to use the queue lock on the source (host RX ring)  * to protect against netmap_transmit.  * If the user is well behaved we do not need to acquire locks  * on the destination(s),  * so we only need to make sure that there are no panics because  * of user errors.  * XXX verify  *  * We scan the tx rings, which have just been  * flushed so nr_hwcur == cur. Pushing packets down means  * increment cur and decrement avail.  * XXX to be verified  */
end_comment

begin_function
specifier|static
name|void
name|netmap_sw_to_nic
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|k1
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
literal|0
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|howmany
decl_stmt|,
name|src_lim
decl_stmt|,
name|dst_lim
decl_stmt|;
comment|/* XXX we should also check that the carrier is on */
if|if
condition|(
name|kring
operator|->
name|nkr_stopped
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nkr_stopped
condition|)
goto|goto
name|out
goto|;
name|howmany
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
comment|/* XXX otherwise cur - reserved - nr_hwcur */
name|src_lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|howmany
operator|>
literal|0
operator|&&
name|i
operator|<
name|na
operator|->
name|num_tx_rings
condition|;
name|i
operator|++
operator|,
name|k1
operator|++
control|)
block|{
name|ND
argument_list|(
literal|"%d packets left to ring %d (space %d)"
argument_list|,
name|howmany
argument_list|,
name|i
argument_list|,
name|k1
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
name|dst_lim
operator|=
name|k1
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|howmany
operator|>
literal|0
operator|&&
name|k1
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|struct
name|netmap_slot
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
name|tmp
decl_stmt|;
name|src
operator|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|kring
operator|->
name|nr_hwcur
index|]
expr_stmt|;
name|dst
operator|=
operator|&
name|k1
operator|->
name|ring
operator|->
name|slot
index|[
name|k1
operator|->
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|tmp
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|->
name|buf_idx
operator|=
name|dst
operator|->
name|buf_idx
expr_stmt|;
name|src
operator|->
name|flags
operator|=
name|NS_BUF_CHANGED
expr_stmt|;
name|dst
operator|->
name|buf_idx
operator|=
name|tmp
operator|.
name|buf_idx
expr_stmt|;
name|dst
operator|->
name|len
operator|=
name|tmp
operator|.
name|len
expr_stmt|;
name|dst
operator|->
name|flags
operator|=
name|NS_BUF_CHANGED
expr_stmt|;
name|ND
argument_list|(
literal|"out len %d buf %d from %d to %d"
argument_list|,
name|dst
operator|->
name|len
argument_list|,
name|dst
operator|->
name|buf_idx
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|k1
operator|->
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|nm_next
argument_list|(
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|src_lim
argument_list|)
expr_stmt|;
name|howmany
operator|--
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|--
expr_stmt|;
name|k1
operator|->
name|ring
operator|->
name|cur
operator|=
name|nm_next
argument_list|(
name|k1
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|dst_lim
argument_list|)
expr_stmt|;
name|k1
operator|->
name|ring
operator|->
name|avail
operator|--
expr_stmt|;
block|}
name|kring
operator|->
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
comment|// XXX
name|k1
operator|++
expr_stmt|;
comment|// XXX why?
block|}
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * netmap_txsync_to_host() passes packets up. We are called from a  * system call in user process context, and the only contention  * can be among multiple user threads erroneously calling  * this routine concurrently.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_txsync_to_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|na
operator|->
name|num_tx_rings
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|k
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|mbq
name|q
init|=
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"ring %p busy (user error)"
argument_list|,
name|kring
argument_list|)
expr_stmt|;
return|return;
block|}
name|k
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|lim
condition|)
block|{
name|D
argument_list|(
literal|"invalid ring index in stack TX kring %p"
argument_list|,
name|kring
argument_list|)
expr_stmt|;
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Take packets from hwcur to cur and pass them up. 	 * In case of no buffers we give up. At the end of the loop, 	 * the queue is drained in all cases. 	 */
name|netmap_grab_packets
argument_list|(
name|kring
argument_list|,
operator|&
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|k
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|=
name|ring
operator|->
name|avail
operator|=
name|lim
expr_stmt|;
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|netmap_send_up
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|q
operator|.
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the 'txsync' handler to send from a software ring to the  * host stack.  */
end_comment

begin_comment
comment|/* SWNA(ifp)->txrings[0] is always NA(ifp)->txrings[NA(ifp)->num_txrings] */
end_comment

begin_function
specifier|static
name|int
name|netmap_bdg_to_host
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ring_nr
expr_stmt|;
operator|(
name|void
operator|)
name|flags
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|>
literal|255
condition|)
name|RD
argument_list|(
literal|5
argument_list|,
literal|"sync to host %s ring %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
name|netmap_txsync_to_host
argument_list|(
name|NA
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * rxsync backend for packets coming from the host stack.  * They have been put in the queue by netmap_transmit() so we  * need to protect access to the kring using a lock.  *  * This routine also does the selrecord if called from the poll handler  * (we know because td != NULL).  *  * NOTE: on linux, selrecord() is defined as a macro and uses pwait  *     as an additional hidden argument.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_rxsync_from_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|pwait
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|j
decl_stmt|,
name|n
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
decl_stmt|;
name|u_int
name|k
init|=
name|ring
operator|->
name|cur
decl_stmt|,
name|resvd
init|=
name|ring
operator|->
name|reserved
decl_stmt|;
operator|(
name|void
operator|)
name|pwait
expr_stmt|;
comment|/* disable unused warnings */
if|if
condition|(
name|kring
operator|->
name|nkr_stopped
condition|)
comment|/* check a first time without lock */
return|return;
comment|/* XXX as an optimization we could reuse na->core_lock */
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nkr_stopped
condition|)
comment|/* check again with lock held */
goto|goto
name|unlock_out
goto|;
if|if
condition|(
name|k
operator|>=
name|lim
condition|)
block|{
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
goto|goto
name|unlock_out
goto|;
block|}
comment|/* new packets are already set in nr_hwavail */
comment|/* skip past packets that userspace has released */
name|j
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|resvd
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|resvd
operator|+
name|ring
operator|->
name|avail
operator|>=
name|lim
operator|+
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"XXX invalid reserve/avail %d %d"
argument_list|,
name|resvd
argument_list|,
name|ring
operator|->
name|avail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|reserved
operator|=
name|resvd
operator|=
literal|0
expr_stmt|;
comment|// XXX panic...
block|}
name|k
operator|=
operator|(
name|k
operator|>=
name|resvd
operator|)
condition|?
name|k
operator|-
name|resvd
else|:
name|k
operator|+
name|lim
operator|-
name|resvd
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
name|k
condition|)
block|{
name|n
operator|=
name|k
operator|>=
name|j
condition|?
name|k
operator|-
name|j
else|:
name|k
operator|+
name|lim
operator|-
name|j
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|-=
name|n
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|k
expr_stmt|;
block|}
name|k
operator|=
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
operator|-
name|resvd
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
operator|&&
name|td
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|&&
operator|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
operator|)
condition|)
name|D
argument_list|(
literal|"%d pkts from stack"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|unlock_out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MUST BE CALLED UNDER NMG_LOCK()  *  * get a refcounted reference to an interface.  * This is always called in the execution of an ioctl().  *  * Return ENXIO if the interface does not exist, EINVAL if netmap  * is not supported by the interface.  * If successful, hold a reference.  *  * When the NIC is attached to a bridge, reference is managed  * at na->na_bdg_refcount using ADD/DROP_BDG_REF() as well as  * virtual ports.  Hence, on the final DROP_BDG_REF(), the NIC  * is detached from the bridge, then ifp's refcount is dropped (this  * is equivalent to that ifp is destroyed in case of virtual ports.  *  * This function uses if_rele() when we want to prevent the NIC from  * being detached from the bridge in error handling.  But once refcount  * is acquired by this function, it must be released using nm_if_rele().  */
end_comment

begin_function
specifier|static
name|int
name|get_ifp
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|ifnet
modifier|*
modifier|*
name|ifp
parameter_list|,
name|int
name|create
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|nmr
operator|->
name|nr_name
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|iter
init|=
name|NULL
decl_stmt|;
name|int
name|no_prefix
init|=
literal|0
decl_stmt|;
comment|/* first try to see if this is a bridge port. */
name|struct
name|nm_bridge
modifier|*
name|b
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cand
init|=
operator|-
literal|1
decl_stmt|,
name|cand2
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|needed
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
operator|*
name|ifp
operator|=
name|NULL
expr_stmt|;
comment|/* default */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|NM_NAME
argument_list|,
sizeof|sizeof
argument_list|(
name|NM_NAME
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|no_prefix
operator|=
literal|1
expr_stmt|;
comment|/* no VALE prefix */
goto|goto
name|no_bridge_port
goto|;
block|}
name|b
operator|=
name|nm_find_bridge
argument_list|(
name|name
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"no bridges available for '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Now we are sure that name starts with the bridge's name, 	 * lookup the port in the bridge. We need to scan the entire 	 * list. It is not important to hold a WLOCK on the bridge 	 * during the search because NMG_LOCK already guarantees 	 * that there are no other possible writers. 	 */
comment|/* lookup in the local list of ports */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|bdg_active_ports
condition|;
name|j
operator|++
control|)
block|{
name|i
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|j
index|]
expr_stmt|;
name|na
operator|=
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
expr_stmt|;
comment|// KASSERT(na != NULL);
name|iter
operator|=
name|na
operator|->
name|ifp
expr_stmt|;
comment|/* XXX make sure the name only contains one : */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|iter
operator|->
name|if_xname
argument_list|,
name|name
argument_list|)
comment|/* virtual port */
operator|||
operator|(
name|namelen
operator|>
name|b
operator|->
name|bdg_namelen
operator|&&
operator|!
name|strcmp
argument_list|(
name|iter
operator|->
name|if_xname
argument_list|,
name|name
operator|+
name|b
operator|->
name|bdg_namelen
operator|+
literal|1
argument_list|)
operator|)
comment|/* NIC */
condition|)
block|{
name|ADD_BDG_REF
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"found existing if %s refs %d"
argument_list|,
name|name
argument_list|,
name|NA
argument_list|(
name|iter
argument_list|)
operator|->
name|na_bdg_refcount
argument_list|)
expr_stmt|;
operator|*
name|ifp
operator|=
name|iter
expr_stmt|;
comment|/* we are done, this is surely netmap capable */
return|return
literal|0
return|;
block|}
block|}
comment|/* not found, should we create it? */
if|if
condition|(
operator|!
name|create
condition|)
return|return
name|ENXIO
return|;
comment|/* yes we should, see if we have space to attach entries */
name|needed
operator|=
literal|2
expr_stmt|;
comment|/* in some cases we only need 1 */
if|if
condition|(
name|b
operator|->
name|bdg_active_ports
operator|+
name|needed
operator|>=
name|NM_BDG_MAXPORTS
condition|)
block|{
name|D
argument_list|(
literal|"bridge full %d, cannot create new port"
argument_list|,
name|b
operator|->
name|bdg_active_ports
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* record the next two ports available, but do not allocate yet */
name|cand
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|b
operator|->
name|bdg_active_ports
index|]
expr_stmt|;
name|cand2
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|b
operator|->
name|bdg_active_ports
operator|+
literal|1
index|]
expr_stmt|;
name|ND
argument_list|(
literal|"+++ bridge %s port %s used %d avail %d %d"
argument_list|,
name|b
operator|->
name|bdg_basename
argument_list|,
name|name
argument_list|,
name|b
operator|->
name|bdg_active_ports
argument_list|,
name|cand
argument_list|,
name|cand2
argument_list|)
expr_stmt|;
comment|/* 	 * try see if there is a matching NIC with this name 	 * (after the bridge's name) 	 */
name|iter
operator|=
name|ifunit_ref
argument_list|(
name|name
operator|+
name|b
operator|->
name|bdg_namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iter
condition|)
block|{
comment|/* this is a virtual port */
comment|/* Create a temporary NA with arguments, then 		 * bdg_netmap_attach() will allocate the real one 		 * and attach it to the ifp 		 */
name|struct
name|netmap_adapter
name|tmp_na
decl_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_cmd
condition|)
block|{
comment|/* nr_cmd must be 0 for a virtual port */
return|return
name|EINVAL
return|;
block|}
name|bzero
argument_list|(
operator|&
name|tmp_na
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_na
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bound checking */
name|tmp_na
operator|.
name|num_tx_rings
operator|=
name|nmr
operator|->
name|nr_tx_rings
expr_stmt|;
name|nm_bound_var
argument_list|(
operator|&
name|tmp_na
operator|.
name|num_tx_rings
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|NM_BDG_MAXRINGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|tmp_na
operator|.
name|num_tx_rings
expr_stmt|;
comment|// write back
name|tmp_na
operator|.
name|num_rx_rings
operator|=
name|nmr
operator|->
name|nr_rx_rings
expr_stmt|;
name|nm_bound_var
argument_list|(
operator|&
name|tmp_na
operator|.
name|num_rx_rings
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|NM_BDG_MAXRINGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|tmp_na
operator|.
name|num_rx_rings
expr_stmt|;
comment|// write back
name|nm_bound_var
argument_list|(
operator|&
name|nmr
operator|->
name|nr_tx_slots
argument_list|,
name|NM_BRIDGE_RINGSIZE
argument_list|,
literal|1
argument_list|,
name|NM_BDG_MAXSLOTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tmp_na
operator|.
name|num_tx_desc
operator|=
name|nmr
operator|->
name|nr_tx_slots
expr_stmt|;
name|nm_bound_var
argument_list|(
operator|&
name|nmr
operator|->
name|nr_rx_slots
argument_list|,
name|NM_BRIDGE_RINGSIZE
argument_list|,
literal|1
argument_list|,
name|NM_BDG_MAXSLOTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tmp_na
operator|.
name|num_rx_desc
operator|=
name|nmr
operator|->
name|nr_rx_slots
expr_stmt|;
comment|/* create a struct ifnet for the new port. 		 * need M_NOWAIT as we are under nma_lock 		 */
name|iter
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|iter
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iter
condition|)
return|return
name|ENOMEM
return|;
name|strcpy
argument_list|(
name|iter
operator|->
name|if_xname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|tmp_na
operator|.
name|ifp
operator|=
name|iter
expr_stmt|;
comment|/* bdg_netmap_attach creates a struct netmap_adapter */
name|bdg_netmap_attach
argument_list|(
operator|&
name|tmp_na
argument_list|)
expr_stmt|;
name|cand2
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* only need one port */
block|}
elseif|else
if|if
condition|(
name|NETMAP_CAPABLE
argument_list|(
name|iter
argument_list|)
condition|)
block|{
comment|/* this is a NIC */
comment|/* make sure the NIC is not already in use */
if|if
condition|(
name|NETMAP_OWNED_BY_ANY
argument_list|(
name|iter
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"NIC %s busy, cannot attach to bridge"
argument_list|,
name|iter
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|if_rele
argument_list|(
name|iter
argument_list|)
expr_stmt|;
comment|/* don't detach from bridge */
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|nmr
operator|->
name|nr_arg1
operator|!=
name|NETMAP_BDG_HOST
condition|)
name|cand2
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* only need one port */
block|}
else|else
block|{
comment|/* not a netmap-capable NIC */
name|if_rele
argument_list|(
name|iter
argument_list|)
expr_stmt|;
comment|/* don't detach from bridge */
return|return
name|EINVAL
return|;
block|}
name|na
operator|=
name|NA
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|BDG_WLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|na
operator|->
name|bdg_port
operator|=
name|cand
expr_stmt|;
name|ND
argument_list|(
literal|"NIC  %p to bridge port %d"
argument_list|,
name|NA
argument_list|(
name|iter
argument_list|)
argument_list|,
name|cand
argument_list|)
expr_stmt|;
comment|/* bind the port to the bridge (virtual ports are not active) */
name|b
operator|->
name|bdg_ports
index|[
name|cand
index|]
operator|=
name|na
expr_stmt|;
name|na
operator|->
name|na_bdg
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|bdg_active_ports
operator|++
expr_stmt|;
if|if
condition|(
name|cand2
operator|>=
literal|0
condition|)
block|{
comment|/* also bind the host stack to the bridge */
name|b
operator|->
name|bdg_ports
index|[
name|cand2
index|]
operator|=
name|SWNA
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|SWNA
argument_list|(
name|iter
argument_list|)
operator|->
name|bdg_port
operator|=
name|cand2
expr_stmt|;
name|SWNA
argument_list|(
name|iter
argument_list|)
operator|->
name|na_bdg
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|bdg_active_ports
operator|++
expr_stmt|;
name|ND
argument_list|(
literal|"host %p to bridge port %d"
argument_list|,
name|SWNA
argument_list|(
name|iter
argument_list|)
argument_list|,
name|cand2
argument_list|)
expr_stmt|;
block|}
name|ADD_BDG_REF
argument_list|(
name|iter
argument_list|)
expr_stmt|;
comment|// XXX one or two ?
name|ND
argument_list|(
literal|"if %s refs %d"
argument_list|,
name|name
argument_list|,
name|NA
argument_list|(
name|iter
argument_list|)
operator|->
name|na_bdg_refcount
argument_list|)
expr_stmt|;
name|BDG_WUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
operator|*
name|ifp
operator|=
name|iter
expr_stmt|;
return|return
literal|0
return|;
name|no_bridge_port
label|:
operator|*
name|ifp
operator|=
name|iter
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ifp
condition|)
operator|*
name|ifp
operator|=
name|ifunit_ref
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|NETMAP_CAPABLE
argument_list|(
operator|*
name|ifp
argument_list|)
condition|)
block|{
comment|/* Users cannot use the NIC attached to a bridge directly */
if|if
condition|(
name|no_prefix
operator|&&
name|NETMAP_OWNED_BY_KERN
argument_list|(
operator|*
name|ifp
argument_list|)
condition|)
block|{
name|if_rele
argument_list|(
operator|*
name|ifp
argument_list|)
expr_stmt|;
comment|/* don't detach from bridge */
return|return
name|EINVAL
return|;
block|}
else|else
return|return
literal|0
return|;
comment|/* valid pointer, we hold the refcount */
block|}
name|nm_if_rele
argument_list|(
operator|*
name|ifp
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
comment|// not NETMAP capable
block|}
end_function

begin_comment
comment|/*  * Error routine called when txsync/rxsync detects an error.  * Can't do much more than resetting cur = hwcur, avail = hwavail.  * Return 1 on reinit.  *  * This routine is only called by the upper half of the kernel.  * It only reads hwcur (which is changed only by the upper half, too)  * and hwavail (which may be changed by the lower half, but only on  * a tx ring and only to increase it, so any error will be recovered  * on the next call). For the above, we don't strictly need to call  * it under lock.  */
end_comment

begin_function
name|int
name|netmap_ring_reinit
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
comment|// XXX KASSERT nm_kr_tryget
name|RD
argument_list|(
literal|10
argument_list|,
literal|"called for %s"
argument_list|,
name|kring
operator|->
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|cur
operator|>
name|lim
condition|)
name|errors
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|idx
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
decl_stmt|;
name|u_int
name|len
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|2
operator|||
name|idx
operator|>=
name|netmap_total_buffers
condition|)
block|{
if|if
condition|(
operator|!
name|errors
operator|++
condition|)
name|D
argument_list|(
literal|"bad buffer at slot %d idx %d len %d "
argument_list|,
name|i
argument_list|,
name|idx
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
name|NETMAP_BDG_BUF_SIZE
argument_list|(
name|kring
operator|->
name|na
operator|->
name|nm_mem
argument_list|)
condition|)
block|{
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|errors
operator|++
condition|)
name|D
argument_list|(
literal|"bad len %d at slot %d idx %d"
argument_list|,
name|len
argument_list|,
name|i
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errors
condition|)
block|{
name|int
name|pos
init|=
name|kring
operator|-
name|kring
operator|->
name|na
operator|->
name|tx_rings
decl_stmt|;
name|int
name|n
init|=
name|kring
operator|->
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
decl_stmt|;
name|RD
argument_list|(
literal|10
argument_list|,
literal|"total %d errors"
argument_list|,
name|errors
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|RD
argument_list|(
literal|10
argument_list|,
literal|"%s %s[%d] reinit, cur %d -> %d avail %d -> %d"
argument_list|,
name|kring
operator|->
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|pos
operator|<
name|n
condition|?
literal|"TX"
else|:
literal|"RX"
argument_list|,
name|pos
operator|<
name|n
condition|?
name|pos
else|:
name|pos
operator|-
name|n
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|ring
operator|->
name|avail
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
block|}
return|return
operator|(
name|errors
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the ring ID. For devices with a single queue, a request  * for all rings is the same as a single ring.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_set_ringid
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|u_int
name|ringid
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|np_ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|u_int
name|i
init|=
name|ringid
operator|&
name|NETMAP_RING_MASK
decl_stmt|;
comment|/* initially (np_qfirst == np_qlast) we don't want to lock */
name|u_int
name|lim
init|=
name|na
operator|->
name|num_rx_rings
decl_stmt|;
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|>
name|lim
condition|)
name|lim
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
if|if
condition|(
operator|(
name|ringid
operator|&
name|NETMAP_HW_RING
operator|)
operator|&&
name|i
operator|>=
name|lim
condition|)
block|{
name|D
argument_list|(
literal|"invalid ring id %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|priv
operator|->
name|np_ringid
operator|=
name|ringid
expr_stmt|;
if|if
condition|(
name|ringid
operator|&
name|NETMAP_SW_RING
condition|)
block|{
name|priv
operator|->
name|np_qfirst
operator|=
name|NETMAP_SW_RING
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ringid
operator|&
name|NETMAP_HW_RING
condition|)
block|{
name|priv
operator|->
name|np_qfirst
operator|=
name|i
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|->
name|np_qfirst
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
name|NETMAP_HW_RING
expr_stmt|;
block|}
name|priv
operator|->
name|np_txpoll
operator|=
operator|(
name|ringid
operator|&
name|NETMAP_NO_TX_POLL
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
block|{
if|if
condition|(
name|ringid
operator|&
name|NETMAP_SW_RING
condition|)
name|D
argument_list|(
literal|"ringid %s set to SW RING"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ringid
operator|&
name|NETMAP_HW_RING
condition|)
name|D
argument_list|(
literal|"ringid %s set to HW RING %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|priv
operator|->
name|np_qfirst
argument_list|)
expr_stmt|;
else|else
name|D
argument_list|(
literal|"ringid %s set to all %d HW RINGS"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * possibly move the interface to netmap-mode.  * If success it returns a pointer to netmap_if, otherwise NULL.  * This must be called with NMG_LOCK held.  */
end_comment

begin_function
specifier|static
name|struct
name|netmap_if
modifier|*
name|netmap_do_regif
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint16_t
name|ringid
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|,
name|need_mem
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* ring configuration may have changed, fetch from the card */
name|netmap_update_config
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* store the reference */
name|error
operator|=
name|netmap_set_ringid
argument_list|(
name|priv
argument_list|,
name|ringid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* ensure allocators are ready */
name|need_mem
operator|=
operator|!
name|netmap_have_memory_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_mem
condition|)
block|{
name|error
operator|=
name|netmap_get_memory_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"get_memory returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
name|nifp
operator|=
name|netmap_if_new
argument_list|(
name|ifp
operator|->
name|if_xname
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
block|{
comment|/* allocation failed */
comment|/* we should drop the allocator, but only 		 * if we were the ones who grabbed it 		 */
if|if
condition|(
name|need_mem
condition|)
name|netmap_drop_memory_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|na
operator|->
name|refcount
operator|++
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
comment|/* was already set */
block|}
else|else
block|{
name|u_int
name|i
decl_stmt|;
comment|/* Otherwise set the card in netmap mode 		 * and make it use the shared buffers. 		 * 		 * If the interface is attached to a bridge, lock it. 		 */
if|if
condition|(
name|NETMAP_OWNED_BY_KERN
argument_list|(
name|ifp
argument_list|)
condition|)
name|BDG_WLOCK
argument_list|(
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_bdg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|,
literal|"nm_txq_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|mtx_init
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|,
literal|"nm_rxq_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nma_is_hw
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|tx_rings
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|na
operator|->
name|num_tx_rings
index|]
expr_stmt|;
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|rx_rings
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
expr_stmt|;
block|}
comment|/* 		 * do not core lock because the race is harmless here, 		 * there cannot be any traffic to netmap_transmit() 		 */
name|error
operator|=
name|na
operator|->
name|nm_register
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* mode on */
comment|// XXX do we need to nm_alloc_bdgfwd() in all cases ?
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nm_alloc_bdgfwd
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|netmap_do_unregif
argument_list|(
name|priv
argument_list|,
name|nifp
argument_list|)
expr_stmt|;
name|nifp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|NETMAP_OWNED_BY_KERN
argument_list|(
name|ifp
argument_list|)
condition|)
name|BDG_WUNLOCK
argument_list|(
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_bdg
argument_list|)
expr_stmt|;
block|}
name|out
label|:
operator|*
name|err
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|nifp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * advertise that the interface is ready bt setting ni_nifp. 		 * The barrier is needed because readers (poll and *SYNC) 		 * check for priv->np_nifp != NULL without locking 		 */
name|wmb
argument_list|()
expr_stmt|;
comment|/* make sure previous writes are visible to all CPUs */
name|priv
operator|->
name|np_nifp
operator|=
name|nifp
expr_stmt|;
block|}
return|return
name|nifp
return|;
block|}
end_function

begin_comment
comment|/* Process NETMAP_BDG_ATTACH and NETMAP_BDG_DETACH */
end_comment

begin_function
specifier|static
name|int
name|nm_bdg_attach
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|npriv
decl_stmt|;
name|int
name|error
decl_stmt|;
name|npriv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|npriv
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|npriv
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
argument_list|,
operator|&
name|ifp
argument_list|,
literal|1
comment|/* create if not exists */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
comment|/* no device, or another bridge or user owns the device */
goto|goto
name|unlock_exit
goto|;
comment|/* get_ifp() sets na_bdg if this is a physical interface 	 * that we can attach to a switch. 	 */
if|if
condition|(
operator|!
name|NETMAP_OWNED_BY_KERN
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
comment|/* got reference to a virtual port or direct access to a NIC. 		 * perhaps specified no bridge prefix or wrong NIC name 		 */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|unref_exit
goto|;
block|}
if|if
condition|(
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* already registered */
name|error
operator|=
name|EBUSY
expr_stmt|;
name|DROP_BDG_REF
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|unlock_exit
goto|;
block|}
name|nifp
operator|=
name|netmap_do_regif
argument_list|(
name|npriv
argument_list|,
name|ifp
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nifp
condition|)
block|{
goto|goto
name|unref_exit
goto|;
block|}
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_kpriv
operator|=
name|npriv
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
name|ND
argument_list|(
literal|"registered %s to netmap-mode"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|unref_exit
label|:
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|unlock_exit
label|:
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|npriv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|npriv
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|npriv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nm_bdg_detach
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|last_instance
decl_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
argument_list|,
operator|&
name|ifp
argument_list|,
literal|0
comment|/* don't create */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* no device, or another bridge or user owns the device */
goto|goto
name|unlock_exit
goto|;
block|}
comment|/* XXX do we need to check this ? */
if|if
condition|(
operator|!
name|NETMAP_OWNED_BY_KERN
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
comment|/* got reference to a virtual port or direct access to a NIC. 		 * perhaps specified no bridge's prefix or wrong NIC's name 		 */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|unref_exit
goto|;
block|}
if|if
condition|(
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
comment|/* not registered */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|unref_exit
goto|;
block|}
name|DROP_BDG_REF
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* the one from get_ifp */
name|last_instance
operator|=
name|netmap_dtor_locked
argument_list|(
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_kpriv
argument_list|)
expr_stmt|;
comment|/* unregister */
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|last_instance
condition|)
block|{
name|D
argument_list|(
literal|"--- error, trying to detach an entry with active mmaps"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|netmap_priv_d
modifier|*
name|npriv
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_kpriv
decl_stmt|;
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_kpriv
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|npriv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|npriv
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|npriv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
name|unref_exit
label|:
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|unlock_exit
label|:
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Initialize necessary fields of sw adapter located in right after hw's  * one.  sw adapter attaches a pair of sw rings of the netmap-mode NIC.  * It is always activated and deactivated at the same tie with the hw's one.  * Thus we don't need refcounting on the sw adapter.  * Regardless of NIC's feature we use separate lock so that anybody can lock  * me independently from the hw adapter.  * Make sure nm_register is NULL to be handled as FALSE in nma_is_hw  */
end_comment

begin_function
specifier|static
name|void
name|netmap_attach_sw
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|hw_na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|SWNA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|na
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|na
operator|->
name|num_rx_rings
operator|=
name|na
operator|->
name|num_tx_rings
operator|=
literal|1
expr_stmt|;
name|na
operator|->
name|num_tx_desc
operator|=
name|hw_na
operator|->
name|num_tx_desc
expr_stmt|;
name|na
operator|->
name|num_rx_desc
operator|=
name|hw_na
operator|->
name|num_rx_desc
expr_stmt|;
name|na
operator|->
name|nm_txsync
operator|=
name|netmap_bdg_to_host
expr_stmt|;
comment|/* we use the same memory allocator as the 	 * the hw adapter */
name|na
operator|->
name|nm_mem
operator|=
name|hw_na
operator|->
name|nm_mem
expr_stmt|;
block|}
end_function

begin_comment
comment|/* exported to kernel callers, e.g. OVS ?  * Entry point.  * Called without NMG_LOCK.  */
end_comment

begin_function
name|int
name|netmap_bdg_ctl
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|bdg_lookup_fn_t
name|func
parameter_list|)
block|{
name|struct
name|nm_bridge
modifier|*
name|b
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|iter
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|nmr
operator|->
name|nr_name
decl_stmt|;
name|int
name|cmd
init|=
name|nmr
operator|->
name|nr_cmd
decl_stmt|,
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NETMAP_BDG_ATTACH
case|:
name|error
operator|=
name|nm_bdg_attach
argument_list|(
name|nmr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_BDG_DETACH
case|:
name|error
operator|=
name|nm_bdg_detach
argument_list|(
name|nmr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_BDG_LIST
case|:
comment|/* this is used to enumerate bridges and ports */
if|if
condition|(
name|namelen
condition|)
block|{
comment|/* look up indexes of bridge and port */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|NM_NAME
argument_list|,
name|strlen
argument_list|(
name|NM_NAME
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|b
operator|=
name|nm_find_bridge
argument_list|(
name|name
argument_list|,
literal|0
comment|/* don't create */
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|ENOENT
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|bdg_active_ports
condition|;
name|j
operator|++
control|)
block|{
name|i
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|j
index|]
expr_stmt|;
name|na
operator|=
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"---AAAAAAAAARGH-------"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|iter
operator|=
name|na
operator|->
name|ifp
expr_stmt|;
comment|/* the former and the latter identify a 				 * virtual port and a NIC, respectively 				 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|iter
operator|->
name|if_xname
argument_list|,
name|name
argument_list|)
operator|||
operator|(
name|namelen
operator|>
name|b
operator|->
name|bdg_namelen
operator|&&
operator|!
name|strcmp
argument_list|(
name|iter
operator|->
name|if_xname
argument_list|,
name|name
operator|+
name|b
operator|->
name|bdg_namelen
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
comment|/* bridge index */
name|nmr
operator|->
name|nr_arg1
operator|=
name|b
operator|-
name|nm_bridges
expr_stmt|;
name|nmr
operator|->
name|nr_arg2
operator|=
name|i
expr_stmt|;
comment|/* port index */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* return the first non-empty entry starting from 			 * bridge nr_arg1 and port nr_arg2. 			 * 			 * Users can detect the end of the same bridge by 			 * seeing the new and old value of nr_arg1, and can 			 * detect the end of all the bridge by error != 0 			 */
name|i
operator|=
name|nmr
operator|->
name|nr_arg1
expr_stmt|;
name|j
operator|=
name|nmr
operator|->
name|nr_arg2
expr_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|error
operator|=
name|ENOENT
init|;
name|i
operator|<
name|NM_BRIDGES
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|nm_bridges
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|b
operator|->
name|bdg_active_ports
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
comment|/* following bridges scan from 0 */
continue|continue;
block|}
name|nmr
operator|->
name|nr_arg1
operator|=
name|i
expr_stmt|;
name|nmr
operator|->
name|nr_arg2
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|j
index|]
expr_stmt|;
name|na
operator|=
name|b
operator|->
name|bdg_ports
index|[
name|j
index|]
expr_stmt|;
name|iter
operator|=
name|na
operator|->
name|ifp
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|iter
operator|->
name|if_xname
argument_list|,
operator|(
name|size_t
operator|)
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|NETMAP_BDG_LOOKUP_REG
case|:
comment|/* register a lookup function to the given bridge. 		 * nmr->nr_name may be just bridge's name (including ':' 		 * if it is not just NM_NAME). 		 */
if|if
condition|(
operator|!
name|func
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|b
operator|=
name|nm_find_bridge
argument_list|(
name|name
argument_list|,
literal|0
comment|/* don't create */
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|b
operator|->
name|nm_bdg_lookup
operator|=
name|func
expr_stmt|;
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
default|default:
name|D
argument_list|(
literal|"invalid cmd (nmr->nr_cmd) (0x%x)"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * ioctl(2) support for the "netmap" device.  *  * Following a list of accepted commands:  * - NIOCGINFO  * - SIOCGIFADDR	just for convenience  * - NIOCREGIF  * - NIOCUNREGIF  * - NIOCTXSYNC  * - NIOCRXSYNC  *  * Return 0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|struct
name|nmreq
modifier|*
name|nmr
init|=
operator|(
expr|struct
name|nmreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|lim
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|krings
decl_stmt|;
operator|(
name|void
operator|)
name|dev
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|fflag
expr_stmt|;
comment|/* UNUSED */
ifdef|#
directive|ifdef
name|linux
define|#
directive|define
name|devfs_get_cdevpriv
parameter_list|(
name|pp
parameter_list|)
define|\
value|({ *(struct netmap_priv_d **)pp = ((struct file *)td)->private_data; 	\ 		(*pp ? 0 : ENOENT); })
comment|/* devfs_set_cdevpriv cannot fail on linux */
define|#
directive|define
name|devfs_set_cdevpriv
parameter_list|(
name|p
parameter_list|,
name|fn
parameter_list|)
define|\
value|({ ((struct file *)td)->private_data = p; (p ? 0 : EINVAL); })
define|#
directive|define
name|devfs_clear_cdevpriv
parameter_list|()
value|do {				\ 		netmap_dtor(priv); ((struct file *)td)->private_data = 0;	\ 	} while (0)
endif|#
directive|endif
comment|/* linux */
name|CURVNET_SET
argument_list|(
name|TD_TO_VNET
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
comment|/* XXX ENOENT should be impossible, since the priv 		 * is now created in the open */
return|return
operator|(
name|error
operator|==
name|ENOENT
condition|?
name|ENXIO
else|:
name|error
operator|)
return|;
block|}
name|nmr
operator|->
name|nr_name
index|[
sizeof|sizeof
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* truncate name */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NIOCGINFO
case|:
comment|/* return capabilities etc */
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|!=
name|NETMAP_API
condition|)
block|{
ifdef|#
directive|ifdef
name|TEST_STUFF
comment|/* some test code for locks etc */
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|==
literal|666
condition|)
block|{
name|error
operator|=
name|nm_test
argument_list|(
name|nmr
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* TEST_STUFF */
name|D
argument_list|(
literal|"API mismatch got %d have %d"
argument_list|,
name|nmr
operator|->
name|nr_version
argument_list|,
name|NETMAP_API
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nmr
operator|->
name|nr_cmd
operator|==
name|NETMAP_BDG_LIST
condition|)
block|{
name|error
operator|=
name|netmap_bdg_ctl
argument_list|(
name|nmr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|NMG_LOCK
argument_list|()
expr_stmt|;
do|do
block|{
comment|/* memsize is always valid */
name|struct
name|netmap_mem_d
modifier|*
name|nmd
init|=
operator|&
name|nm_mem
decl_stmt|;
name|u_int
name|memflags
decl_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* get a refcount */
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
argument_list|,
operator|&
name|ifp
argument_list|,
literal|1
comment|/* create */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve the netmap adapter */
name|nmd
operator|=
name|na
operator|->
name|nm_mem
expr_stmt|;
comment|/* and its memory allocator */
block|}
name|error
operator|=
name|netmap_mem_get_info
argument_list|(
name|nmd
argument_list|,
operator|&
name|nmr
operator|->
name|nr_memsize
argument_list|,
operator|&
name|memflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
comment|/* only memory info */
break|break;
name|nmr
operator|->
name|nr_offset
operator|=
literal|0
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|nmr
operator|->
name|nr_tx_slots
operator|=
literal|0
expr_stmt|;
name|netmap_update_config
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
if|if
condition|(
name|memflags
operator|&
name|NETMAP_MEM_PRIVATE
condition|)
name|nmr
operator|->
name|nr_ringid
operator||=
name|NETMAP_PRIV_MEM
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|ifp
condition|)
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|NIOCREGIF
case|:
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|!=
name|NETMAP_API
condition|)
block|{
name|nmr
operator|->
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* possibly attach/detach NIC and VALE switch */
name|i
operator|=
name|nmr
operator|->
name|nr_cmd
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NETMAP_BDG_ATTACH
operator|||
name|i
operator|==
name|NETMAP_BDG_DETACH
condition|)
block|{
name|error
operator|=
name|netmap_bdg_ctl
argument_list|(
name|nmr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"nr_cmd must be 0 not %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* protect access to priv from concurrent NIOCREGIF */
name|NMG_LOCK
argument_list|()
expr_stmt|;
do|do
block|{
name|u_int
name|memflags
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_ifp
operator|!=
name|NULL
condition|)
block|{
comment|/* thread already registered */
name|error
operator|=
name|netmap_set_ringid
argument_list|(
name|priv
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* find the interface and a reference */
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
argument_list|,
operator|&
name|ifp
argument_list|,
literal|1
comment|/* create */
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|NETMAP_OWNED_BY_KERN
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|nifp
operator|=
name|netmap_do_regif
argument_list|(
name|priv
argument_list|,
name|ifp
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nifp
condition|)
block|{
comment|/* reg. failed, release priv and ref */
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
name|priv
operator|->
name|np_ifp
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|np_nifp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* return the offset of the netmap_if object */
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|error
operator|=
name|netmap_mem_get_info
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
operator|&
name|nmr
operator|->
name|nr_memsize
argument_list|,
operator|&
name|memflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|memflags
operator|&
name|NETMAP_MEM_PRIVATE
condition|)
block|{
name|nmr
operator|->
name|nr_ringid
operator||=
name|NETMAP_PRIV_MEM
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|nifp
operator|->
name|ni_flags
operator||=
name|NI_PRIV_MEM
expr_stmt|;
block|}
name|nmr
operator|->
name|nr_offset
operator|=
name|netmap_mem_if_offset
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
name|nifp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|NIOCUNREGIF
case|:
comment|// XXX we have no data here ?
name|D
argument_list|(
literal|"deprecated, data is %p"
argument_list|,
name|nmr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NIOCTXSYNC
case|:
case|case
name|NIOCRXSYNC
case|:
name|nifp
operator|=
name|priv
operator|->
name|np_nifp
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|rmb
argument_list|()
expr_stmt|;
comment|/* make sure following reads are not from cache */
name|ifp
operator|=
name|priv
operator|->
name|np_ifp
expr_stmt|;
comment|/* we have a reference */
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"Internal error: nifp != NULL&& ifp == NULL"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
if|if
condition|(
name|priv
operator|->
name|np_qfirst
operator|==
name|NETMAP_SW_RING
condition|)
block|{
comment|/* host rings */
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
name|netmap_txsync_to_host
argument_list|(
name|na
argument_list|)
expr_stmt|;
else|else
name|netmap_rxsync_from_host
argument_list|(
name|na
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* find the last ring to scan */
name|lim
operator|=
name|priv
operator|->
name|np_qlast
expr_stmt|;
if|if
condition|(
name|lim
operator|==
name|NETMAP_HW_RING
condition|)
name|lim
operator|=
operator|(
name|cmd
operator|==
name|NIOCTXSYNC
operator|)
condition|?
name|na
operator|->
name|num_tx_rings
else|:
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|krings
operator|=
operator|(
name|cmd
operator|==
name|NIOCTXSYNC
operator|)
condition|?
name|na
operator|->
name|tx_rings
else|:
name|na
operator|->
name|rx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
name|krings
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
block|{
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"pre txsync ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_txsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
name|NAF_FORCE_RECLAIM
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"post txsync ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|na
operator|->
name|nm_rxsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
name|NAF_FORCE_READ
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|__FreeBSD__
case|case
name|BIOCIMMEDIATE
case|:
case|case
name|BIOCGHDRCMPLT
case|:
case|case
name|BIOCSHDRCMPLT
case|:
case|case
name|BIOCSSEESENT
case|:
name|D
argument_list|(
literal|"ignore BIOCIMMEDIATE/BIOCSHDRCMPLT/BIOCSHDRCMPLT/BIOCSSEESENT"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* allow device-specific ioctls */
block|{
name|struct
name|socket
name|so
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|so
argument_list|,
sizeof|sizeof
argument_list|(
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
argument_list|,
operator|&
name|ifp
argument_list|,
literal|0
comment|/* don't create */
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
block|{
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
name|so
operator|.
name|so_vnet
operator|=
name|ifp
operator|->
name|if_vnet
expr_stmt|;
comment|// so->so_proto not null.
name|error
operator|=
name|ifioctl
argument_list|(
operator|&
name|so
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
else|#
directive|else
comment|/* linux */
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
comment|/* linux */
block|}
name|out
label|:
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * select(2) and poll(2) handlers for the "netmap" device.  *  * Can be called for one or more queues.  * Return true the event mask corresponding to ready events.  * If there are no ready events, do a selrecord on either individual  * selinfo or on the global one.  * Device-dependent parts (locking and sync of tx/rx rings)  * are done through callbacks.  *  * On linux, arguments are really pwait, the poll table, and 'td' is struct file *  * The first one is remapped to pwait as selrecord() uses the name as an  * hidden argument.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|check_all
decl_stmt|,
name|want_tx
decl_stmt|,
name|want_rx
decl_stmt|,
name|revents
init|=
literal|0
decl_stmt|;
name|u_int
name|lim_tx
decl_stmt|,
name|lim_rx
decl_stmt|,
name|host_forwarded
init|=
literal|0
decl_stmt|;
name|struct
name|mbq
name|q
init|=
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|void
modifier|*
name|pwait
init|=
name|dev
decl_stmt|;
comment|/* linux compatibility */
name|int
name|retry_tx
init|=
literal|1
decl_stmt|;
operator|(
name|void
operator|)
name|pwait
expr_stmt|;
if|if
condition|(
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
operator|!=
literal|0
operator|||
name|priv
operator|==
name|NULL
condition|)
return|return
name|POLLERR
return|;
if|if
condition|(
name|priv
operator|->
name|np_nifp
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"No if registered"
argument_list|)
expr_stmt|;
return|return
name|POLLERR
return|;
block|}
name|rmb
argument_list|()
expr_stmt|;
comment|/* make sure following reads are not from cache */
name|ifp
operator|=
name|priv
operator|->
name|np_ifp
expr_stmt|;
comment|// XXX check for deleting() ?
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
operator|==
literal|0
condition|)
return|return
name|POLLERR
return|;
if|if
condition|(
name|netmap_verbose
operator|&
literal|0x8000
condition|)
name|D
argument_list|(
literal|"device %s events 0x%x"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|events
argument_list|)
expr_stmt|;
name|want_tx
operator|=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
name|want_rx
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
name|lim_tx
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|lim_rx
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_qfirst
operator|==
name|NETMAP_SW_RING
condition|)
block|{
comment|/* handle the host stack ring */
if|if
condition|(
name|priv
operator|->
name|np_txpoll
operator|||
name|want_tx
condition|)
block|{
comment|/* push any packets up, then we are always ready */
name|netmap_txsync_to_host
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|revents
operator||=
name|want_tx
expr_stmt|;
block|}
if|if
condition|(
name|want_rx
condition|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|lim_rx
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|==
literal|0
condition|)
name|netmap_rxsync_from_host
argument_list|(
name|na
argument_list|,
name|td
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
block|}
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
comment|/* if we are in transparent mode, check also the host rx ring */
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|lim_rx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|np_qlast
operator|==
name|NETMAP_HW_RING
operator|)
comment|// XXX check_all
operator|&&
name|want_rx
operator|&&
operator|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
operator|)
condition|)
block|{
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|==
literal|0
condition|)
name|netmap_rxsync_from_host
argument_list|(
name|na
argument_list|,
name|td
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
name|revents
operator||=
name|want_rx
expr_stmt|;
block|}
comment|/* 	 * check_all is set if the card has more than one queue AND 	 * the client is polling all of them. If true, we sleep on 	 * the "global" selinfo, otherwise we sleep on individual selinfo 	 * (FreeBSD only allows two selinfo's per file descriptor). 	 * The interrupt routine in the driver wake one or the other 	 * (or both) depending on which clients are active. 	 * 	 * rxsync() is only called if we run out of buffers on a POLLIN. 	 * txsync() is called if we run out of buffers on POLLOUT, or 	 * there are pending packets to send. The latter can be disabled 	 * passing NETMAP_NO_TX_POLL in the NIOCREG call. 	 */
name|check_all
operator|=
operator|(
name|priv
operator|->
name|np_qlast
operator|==
name|NETMAP_HW_RING
operator|)
operator|&&
operator|(
name|lim_tx
operator|>
literal|1
operator|||
name|lim_rx
operator|>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_qlast
operator|!=
name|NETMAP_HW_RING
condition|)
block|{
name|lim_tx
operator|=
name|lim_rx
operator|=
name|priv
operator|->
name|np_qlast
expr_stmt|;
block|}
comment|/* 	 * We start with a lock free round which is good if we have 	 * data available. If this fails, then lock and call the sync 	 * routines. 	 */
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|want_rx
operator|&&
name|i
operator|<
name|lim_rx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
name|want_rx
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|want_tx
operator|&&
name|i
operator|<
name|lim_tx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
comment|/* 	 * If we to push packets out (priv->np_txpoll) or want_tx is 	 * still set, we do need to run the txsync calls (on all rings, 	 * to avoid that the tx rings stall). 	 */
if|if
condition|(
name|priv
operator|->
name|np_txpoll
operator|||
name|want_tx
condition|)
block|{
comment|/* If we really want to be woken up (want_tx), 		 * do a selrecord, either on the global or on 		 * the private structure.  Then issue the txsync 		 * so there is no race in the selrecord/selwait 		 */
name|flush_tx
label|:
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim_tx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
comment|/* 			 * Skip this ring if want_tx == 0 			 * (we have already done a successful sync on 			 * a previous ring) AND kring->cur == kring->hwcur 			 * (there are no pending transmissions for this ring). 			 */
if|if
condition|(
operator|!
name|want_tx
operator|&&
name|kring
operator|->
name|ring
operator|->
name|cur
operator|==
name|kring
operator|->
name|nr_hwcur
condition|)
continue|continue;
comment|/* make sure only one user thread is doing this */
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|ND
argument_list|(
literal|"ring %p busy is %d"
argument_list|,
name|kring
argument_list|,
operator|(
name|int
operator|)
name|kring
operator|->
name|nr_busy
argument_list|)
expr_stmt|;
name|revents
operator||=
name|POLLERR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"send %d on %s %d"
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_txsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
comment|/* Check avail/call selrecord only if called with POLLOUT */
if|if
condition|(
name|want_tx
condition|)
block|{
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
comment|/* stop at the first ring. We don't risk 					 * starvation. 					 */
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|want_tx
operator|&&
name|retry_tx
condition|)
block|{
name|selrecord
argument_list|(
name|td
argument_list|,
name|check_all
condition|?
operator|&
name|na
operator|->
name|tx_si
else|:
operator|&
name|na
operator|->
name|tx_rings
index|[
name|priv
operator|->
name|np_qfirst
index|]
operator|.
name|si
argument_list|)
expr_stmt|;
name|retry_tx
operator|=
literal|0
expr_stmt|;
goto|goto
name|flush_tx
goto|;
block|}
block|}
comment|/* 	 * now if want_rx is still set we need to lock and rxsync. 	 * Do it on all rings because otherwise we starve. 	 */
if|if
condition|(
name|want_rx
condition|)
block|{
name|int
name|retry_rx
init|=
literal|1
decl_stmt|;
name|do_retry_rx
label|:
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim_rx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|revents
operator||=
name|POLLERR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* XXX NR_FORWARD should only be read on 			 * physical or NIC ports 			 */
if|if
condition|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
condition|)
block|{
name|ND
argument_list|(
literal|10
argument_list|,
literal|"forwarding some buffers up %d to %d"
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|netmap_grab_packets
argument_list|(
name|kring
argument_list|,
operator|&
name|q
argument_list|,
name|netmap_fwd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|nm_rxsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
if|if
condition|(
name|netmap_no_timestamp
operator|==
literal|0
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_TIMESTAMP
condition|)
block|{
name|microtime
argument_list|(
operator|&
name|kring
operator|->
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
name|retry_rx
operator|=
literal|0
expr_stmt|;
block|}
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retry_rx
condition|)
block|{
name|retry_rx
operator|=
literal|0
expr_stmt|;
name|selrecord
argument_list|(
name|td
argument_list|,
name|check_all
condition|?
operator|&
name|na
operator|->
name|rx_si
else|:
operator|&
name|na
operator|->
name|rx_rings
index|[
name|priv
operator|->
name|np_qfirst
index|]
operator|.
name|si
argument_list|)
expr_stmt|;
goto|goto
name|do_retry_rx
goto|;
block|}
block|}
comment|/* forward host to the netmap ring. 	 * I am accessing nr_hwavail without lock, but netmap_transmit 	 * can only increment it, so the operation is safe. 	 */
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|lim_rx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|np_qlast
operator|==
name|NETMAP_HW_RING
operator|)
comment|// XXX check_all
operator|&&
operator|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
operator|)
operator|&&
name|kring
operator|->
name|nr_hwavail
operator|>
literal|0
operator|&&
operator|!
name|host_forwarded
condition|)
block|{
name|netmap_sw_to_nic
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|host_forwarded
operator|=
literal|1
expr_stmt|;
comment|/* prevent another pass */
name|want_rx
operator|=
literal|0
expr_stmt|;
goto|goto
name|flush_tx
goto|;
block|}
if|if
condition|(
name|q
operator|.
name|head
condition|)
name|netmap_send_up
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|q
operator|.
name|head
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------- driver support routines ------*/
end_comment

begin_comment
comment|/*  * Initialize a ``netmap_adapter`` object created by driver on attach.  * We allocate a block of memory with room for a struct netmap_adapter  * plus two sets of N+2 struct netmap_kring (where N is the number  * of hardware rings):  * krings	0..N-1	are for the hardware queues.  * kring	N	is for the host stack queue  * kring	N+1	is only used for the selinfo for all queues.  * Return 0 on success, ENOMEM otherwise.  *  * By default the receive and transmit adapter ring counts are both initialized  * to num_queues.  na->num_tx_rings can be set for cards with different tx/rx  * setups.  */
end_comment

begin_function
name|int
name|netmap_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|arg
parameter_list|,
name|u_int
name|num_queues
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|arg
condition|?
name|arg
operator|->
name|ifp
else|:
name|NULL
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
name|ifp
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
comment|/* a VALE port uses two endpoints */
name|len
operator|=
name|nma_is_vp
argument_list|(
name|arg
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
else|:
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
operator|*
literal|2
expr_stmt|;
name|na
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|WNA
argument_list|(
name|ifp
argument_list|)
operator|=
name|na
expr_stmt|;
operator|*
name|na
operator|=
operator|*
name|arg
expr_stmt|;
comment|/* copy everything, trust the driver to not pass junk */
name|NETMAP_SET_CAPABLE
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|==
literal|0
condition|)
name|na
operator|->
name|num_tx_rings
operator|=
name|num_queues
expr_stmt|;
name|na
operator|->
name|num_rx_rings
operator|=
name|num_queues
expr_stmt|;
name|na
operator|->
name|refcount
operator|=
name|na
operator|->
name|na_single
operator|=
name|na
operator|->
name|na_multi
operator|=
literal|0
expr_stmt|;
comment|/* Core lock initialized here, others after netmap_if_new. */
name|mtx_init
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|,
literal|"netmap core lock"
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|linux
if|if
condition|(
name|ifp
operator|->
name|netdev_ops
condition|)
block|{
name|ND
argument_list|(
literal|"netdev_ops %p"
argument_list|,
name|ifp
operator|->
name|netdev_ops
argument_list|)
expr_stmt|;
comment|/* prepare a clone of the netdev ops */
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|28
argument_list|)
name|na
operator|->
name|nm_ndo
operator|.
name|ndo_start_xmit
operator|=
name|ifp
operator|->
name|netdev_ops
expr_stmt|;
else|#
directive|else
name|na
operator|->
name|nm_ndo
operator|=
operator|*
name|ifp
operator|->
name|netdev_ops
expr_stmt|;
endif|#
directive|endif
block|}
name|na
operator|->
name|nm_ndo
operator|.
name|ndo_start_xmit
operator|=
name|linux_netmap_start_xmit
expr_stmt|;
endif|#
directive|endif
comment|/* linux */
name|na
operator|->
name|nm_mem
operator|=
name|arg
operator|->
name|nm_mem
condition|?
name|arg
operator|->
name|nm_mem
else|:
operator|&
name|nm_mem
expr_stmt|;
if|if
condition|(
operator|!
name|nma_is_vp
argument_list|(
name|arg
argument_list|)
condition|)
name|netmap_attach_sw
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"success for %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|D
argument_list|(
literal|"fail, arg %p ifp %p na %p"
argument_list|,
name|arg
argument_list|,
name|ifp
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|netmap_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|na
condition|?
name|EINVAL
else|:
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the allocated memory linked to the given ``netmap_adapter``  * object.  */
end_comment

begin_function
name|void
name|netmap_detach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|na
condition|)
return|return;
name|mtx_destroy
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|tx_rings
condition|)
block|{
comment|/* XXX should not happen */
name|D
argument_list|(
literal|"freeing leftover tx_rings"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|na
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_MEM_OWNER
condition|)
name|netmap_mem_private_delete
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|na
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|WNA
argument_list|(
name|ifp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|na
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|int
name|nm_bdg_flush
parameter_list|(
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
parameter_list|,
name|u_int
name|n
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Intercept packets from the network stack and pass them  * to netmap as incoming packets on the 'software' ring.  * We rely on the OS to make sure that the ifp and na do not go  * away (typically the caller checks for IFF_DRV_RUNNING or the like).  * In nm_register() or whenever there is a reinitialization,  * we make sure to access the core lock and per-ring locks  * so that IFCAP_NETMAP is visible here.  */
end_comment

begin_function
name|int
name|netmap_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|len
init|=
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|u_int
name|error
init|=
name|EBUSY
decl_stmt|,
name|lim
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
comment|// XXX [Linux] we do not need this lock
comment|// if we follow the down/configure/up protocol -gl
comment|// mtx_lock(&na->core_lock);
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* interface not in netmap mode anymore */
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
expr_stmt|;
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"%s packet %d len %d from the stack"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|// XXX reconsider long packets if we handle fragments
if|if
condition|(
name|len
operator|>
name|NETMAP_BDG_BUF_SIZE
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
condition|)
block|{
comment|/* too long for us */
name|D
argument_list|(
literal|"%s from_host, drop packet size %d> %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|len
argument_list|,
name|NETMAP_BDG_BUF_SIZE
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_bdg
condition|)
block|{
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|na
operator|=
name|SWNA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* we operate on the host port */
name|ft
operator|=
name|na
operator|->
name|rx_rings
index|[
literal|0
index|]
operator|.
name|nkr_ft
expr_stmt|;
name|dst
operator|=
name|BDG_NMB
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
operator|&
name|na
operator|->
name|rx_rings
index|[
literal|0
index|]
operator|.
name|ring
operator|->
name|slot
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* use slot 0 in the ft, there is nothing queued here */
comment|/* XXX we can save the copy calling m_copydata in nm_bdg_flush, 		 * need a special flag for this. 		 */
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|ft
operator|->
name|ft_flags
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|ft_len
operator|=
name|len
expr_stmt|;
name|ft
operator|->
name|ft_buf
operator|=
name|dst
expr_stmt|;
name|ft
operator|->
name|ft_next
operator|=
name|NM_FT_NULL
expr_stmt|;
name|ft
operator|->
name|ft_frags
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|RD
argument_list|(
literal|5
argument_list|,
literal|"pkt %p size %d to bridge port %d"
argument_list|,
name|dst
argument_list|,
name|len
argument_list|,
name|na
operator|->
name|bdg_port
argument_list|)
expr_stmt|;
name|nm_bdg_flush
argument_list|(
name|ft
argument_list|,
literal|1
argument_list|,
name|na
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* back to the regular object/lock */
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* protect against other instances of netmap_transmit, 	 * and userspace invocations of rxsync(). 	 * XXX could reuse core_lock 	 */
comment|// XXX [Linux] there can be no other instances of netmap_transmit
comment|// on this same ring, but we still need this lock to protect
comment|// concurrent access from netmap_sw_to_nic() -gl
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwavail
operator|>=
name|lim
condition|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"stack ring %s full\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* compute the insert position */
name|i
operator|=
name|nm_kr_rxpos
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|slot
operator|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|i
index|]
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|BDG_NMB
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
name|slot
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
name|kring
operator|->
name|nkr_slot_flags
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|++
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"wake up host ring %s %d"
argument_list|,
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|done
label|:
comment|// mtx_unlock(&na->core_lock);
comment|/* release the mbuf in either cases of success or failure. As an 	 * alternative, put the mbuf in a free list and free the list 	 * only when really necessary. 	 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * netmap_reset() is called by the driver routines when reinitializing  * a ring. The driver is in charge of locking to protect the kring.  * If netmap mode is not set just return NULL.  */
end_comment

begin_function
name|struct
name|netmap_slot
modifier|*
name|netmap_reset
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|enum
name|txrx
name|tx
parameter_list|,
name|u_int
name|n
parameter_list|,
name|u_int
name|new_cur
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|int
name|new_hwofs
decl_stmt|,
name|lim
decl_stmt|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"NULL na, should not happen"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* no netmap support here */
block|}
if|if
condition|(
operator|!
operator|(
name|na
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
block|{
name|D
argument_list|(
literal|"interface not in netmap mode"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* nothing to reinitialize */
block|}
comment|/* XXX note- in the new scheme, we are not guaranteed to be 	 * under lock (e.g. when called on a device reset). 	 * In this case, we should set a flag and do not trust too 	 * much the values. In practice: TODO 	 * - set a RESET flag somewhere in the kring 	 * - do the processing in a conservative way 	 * - let the *sync() fixup at the end. 	 */
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|na
operator|->
name|num_tx_rings
condition|)
return|return
name|NULL
return|;
name|kring
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|n
expr_stmt|;
name|new_hwofs
operator|=
name|kring
operator|->
name|nr_hwcur
operator|-
name|new_cur
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|n
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
return|return
name|NULL
return|;
name|kring
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|n
expr_stmt|;
name|new_hwofs
operator|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
operator|-
name|new_cur
expr_stmt|;
block|}
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new_hwofs
operator|>
name|lim
condition|)
name|new_hwofs
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
comment|/* Always set the new offset value and realign the ring. */
name|D
argument_list|(
literal|"%s hwofs %d -> %d, hwavail %d -> %d"
argument_list|,
name|tx
operator|==
name|NR_TX
condition|?
literal|"TX"
else|:
literal|"RX"
argument_list|,
name|kring
operator|->
name|nkr_hwofs
argument_list|,
name|new_hwofs
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|,
name|tx
operator|==
name|NR_TX
condition|?
name|lim
else|:
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nkr_hwofs
operator|=
name|new_hwofs
expr_stmt|;
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
name|kring
operator|->
name|nr_hwavail
operator|=
name|lim
expr_stmt|;
if|#
directive|if
literal|0
comment|// def linux
comment|/* XXX check that the mappings are correct */
comment|/* need ring_nr, adapter->pdev, direction */
block|buffer_info->dma = dma_map_single(&pdev->dev, addr, adapter->rx_buffer_len, DMA_FROM_DEVICE); 	if (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)) { 		D("error mapping rx netmap buffer %d", i);
comment|// XXX fix error handling
block|}
endif|#
directive|endif
comment|/* linux */
comment|/* 	 * Wakeup on the individual and global selwait 	 * We do the wakeup here, but the ring is not yet reconfigured. 	 * However, we are under lock so there are no races. 	 */
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
name|tx
operator|==
name|NR_TX
condition|?
operator|&
name|na
operator|->
name|tx_si
else|:
operator|&
name|na
operator|->
name|rx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
return|return
name|kring
operator|->
name|ring
operator|->
name|slot
return|;
block|}
end_function

begin_comment
comment|/*  * Grab packets from a kring, move them into the ft structure  * associated to the tx (input) port. Max one instance per port,  * filtered on input (ioctl, poll or XXX).  * Returns the next position in the ring.  */
end_comment

begin_function
specifier|static
name|int
name|nm_bdg_preflush
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|u_int
name|end
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
decl_stmt|;
name|u_int
name|j
init|=
name|kring
operator|->
name|nr_hwcur
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
name|ft_i
init|=
literal|0
decl_stmt|;
comment|/* start from 0 */
name|u_int
name|frags
init|=
literal|1
decl_stmt|;
comment|/* how many frags ? */
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|na
operator|->
name|na_bdg
decl_stmt|;
comment|/* To protect against modifications to the bridge we acquire a 	 * shared lock, waiting if we can sleep (if the source port is 	 * attached to a user process) or with a trylock otherwise (NICs). 	 */
name|ND
argument_list|(
literal|"wait rlock for %d packets"
argument_list|,
operator|(
operator|(
name|j
operator|>
name|end
condition|?
name|lim
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
name|end
operator|)
operator|-
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_BDG_MAYSLEEP
condition|)
name|BDG_RLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|BDG_RTRYLOCK
argument_list|(
name|b
argument_list|)
condition|)
return|return
literal|0
return|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"rlock acquired for %d packets"
argument_list|,
operator|(
operator|(
name|j
operator|>
name|end
condition|?
name|lim
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
name|end
operator|)
operator|-
name|j
argument_list|)
expr_stmt|;
name|ft
operator|=
name|kring
operator|->
name|nkr_ft
expr_stmt|;
for|for
control|(
init|;
name|likely
argument_list|(
name|j
operator|!=
name|end
argument_list|)
condition|;
name|j
operator|=
name|nm_next
argument_list|(
name|j
argument_list|,
name|lim
argument_list|)
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|j
index|]
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_len
operator|=
name|slot
operator|->
name|len
expr_stmt|;
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_flags
operator|=
name|slot
operator|->
name|flags
expr_stmt|;
name|ND
argument_list|(
literal|"flags is 0x%x"
argument_list|,
name|slot
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* this slot goes into a list so initialize the link field */
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_next
operator|=
name|NM_FT_NULL
expr_stmt|;
name|buf
operator|=
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_buf
operator|=
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_INDIRECT
operator|)
condition|?
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|slot
operator|->
name|ptr
else|:
name|BDG_NMB
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|++
name|ft_i
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|flags
operator|&
name|NS_MOREFRAG
condition|)
block|{
name|frags
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|netmap_verbose
operator|&&
name|frags
operator|>
literal|1
argument_list|)
condition|)
name|RD
argument_list|(
literal|5
argument_list|,
literal|"%d frags at %d"
argument_list|,
name|frags
argument_list|,
name|ft_i
operator|-
name|frags
argument_list|)
expr_stmt|;
name|ft
index|[
name|ft_i
operator|-
name|frags
index|]
operator|.
name|ft_frags
operator|=
name|frags
expr_stmt|;
name|frags
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|int
operator|)
name|ft_i
operator|>=
name|bridge_batch
argument_list|)
condition|)
name|ft_i
operator|=
name|nm_bdg_flush
argument_list|(
name|ft
argument_list|,
name|ft_i
argument_list|,
name|na
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frags
operator|>
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"truncate incomplete fragment at %d (%d frags)"
argument_list|,
name|ft_i
argument_list|,
name|frags
argument_list|)
expr_stmt|;
comment|// ft_i> 0, ft[ft_i-1].flags has NS_MOREFRAG
name|ft
index|[
name|ft_i
operator|-
literal|1
index|]
operator|.
name|ft_frags
operator|&=
operator|~
name|NS_MOREFRAG
expr_stmt|;
name|ft
index|[
name|ft_i
operator|-
name|frags
index|]
operator|.
name|ft_frags
operator|=
name|frags
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ft_i
condition|)
name|ft_i
operator|=
name|nm_bdg_flush
argument_list|(
name|ft
argument_list|,
name|ft_i
argument_list|,
name|na
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
name|BDG_RUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|j
return|;
block|}
end_function

begin_comment
comment|/*  * Pass packets from nic to the bridge.  * XXX TODO check locking: this is called from the interrupt  * handler so we should make sure that the interface is not  * disconnected while passing down an interrupt.  *  * Note, no user process can access this NIC so we can ignore  * the info in the 'ring'.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_nic_to_bdg
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|ring_nr
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|ring_nr
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* make sure that only one thread is ever in here, 	 * after which we can unlock. Probably unnecessary XXX. 	 */
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|)
condition|)
return|return;
comment|/* fetch packets that have arrived. 	 * XXX maybe do this in a loop ? 	 */
if|if
condition|(
name|na
operator|->
name|nm_rxsync
argument_list|(
name|ifp
argument_list|,
name|ring_nr
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|put_out
goto|;
if|if
condition|(
name|kring
operator|->
name|nr_hwavail
operator|==
literal|0
operator|&&
name|netmap_verbose
condition|)
block|{
name|D
argument_list|(
literal|"how strange, interrupt with no packets on %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
goto|goto
name|put_out
goto|;
block|}
name|k
operator|=
name|nm_kr_rxpos
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|j
operator|=
name|nm_bdg_preflush
argument_list|(
name|na
argument_list|,
name|ring_nr
argument_list|,
name|kring
argument_list|,
name|k
argument_list|)
expr_stmt|;
comment|/* we consume everything, but we cannot update kring directly 	 * because the nic may have destroyed the info in the NIC ring. 	 * So we need to call rxsync again to restore it. 	 */
name|ring
operator|->
name|cur
operator|=
name|j
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
literal|0
expr_stmt|;
name|na
operator|->
name|nm_rxsync
argument_list|(
name|ifp
argument_list|,
name|ring_nr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_out
label|:
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Default functions to handle rx/tx interrupts from a physical device.  * "work_done" is non-null on the RX path, NULL for the TX path.  * We rely on the OS to make sure that there is only one active  * instance per queue, and that there is appropriate locking.  *  * If the card is not in netmap mode, simply return 0,  * so that the caller proceeds with regular processing.  *  * If the card is connected to a netmap file descriptor,  * do a selwakeup on the individual queue, plus one on the global one  * if needed (multiqueue card _and_ there are multiqueue listeners),  * and return 1.  *  * Finally, if called on rx from an interface connected to a switch,  * calls the proper forwarding routine, and return 1.  */
end_comment

begin_function
name|int
name|netmap_rx_irq
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|q
parameter_list|,
name|u_int
modifier|*
name|work_done
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
return|return
literal|0
return|;
name|q
operator|&=
name|NETMAP_RING_MASK
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|RD
argument_list|(
literal|5
argument_list|,
literal|"received %s queue %d"
argument_list|,
name|work_done
condition|?
literal|"RX"
else|:
literal|"TX"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_SKIP_INTR
condition|)
block|{
name|ND
argument_list|(
literal|"use regular interrupt"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|work_done
condition|)
block|{
comment|/* RX path */
if|if
condition|(
name|q
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
return|return
literal|0
return|;
comment|// not a physical queue
name|kring
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|q
expr_stmt|;
name|kring
operator|->
name|nr_kflags
operator||=
name|NKR_PENDINTR
expr_stmt|;
comment|// XXX atomic ?
if|if
condition|(
name|na
operator|->
name|na_bdg
operator|!=
name|NULL
condition|)
block|{
name|netmap_nic_to_bdg
argument_list|(
name|ifp
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|num_rx_rings
operator|>
literal|1
comment|/* or multiple listeners */
condition|)
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|rx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
block|}
operator|*
name|work_done
operator|=
literal|1
expr_stmt|;
comment|/* do not fire napi again */
block|}
else|else
block|{
comment|/* TX path */
if|if
condition|(
name|q
operator|>=
name|na
operator|->
name|num_tx_rings
condition|)
return|return
literal|0
return|;
comment|// not a physical queue
name|kring
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|q
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|>
literal|1
comment|/* or multiple listeners */
condition|)
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|tx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_comment
comment|/* linux-specific routines */
end_comment

begin_comment
comment|/*  * Remap linux arguments into the FreeBSD call.  * - pwait is the poll table, passed as 'dev';  *   If pwait == NULL someone else already woke up before. We can report  *   events but they are filtered upstream.  *   If pwait != NULL, then pwait->key contains the list of events.  * - events is computed from pwait as above.  * - file is passed as 'td';  */
end_comment

begin_function
specifier|static
name|u_int
name|linux_netmap_poll
parameter_list|(
name|struct
name|file
modifier|*
name|file
parameter_list|,
name|struct
name|poll_table_struct
modifier|*
name|pwait
parameter_list|)
block|{
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|28
argument_list|)
name|int
name|events
init|=
name|POLLIN
operator||
name|POLLOUT
decl_stmt|;
comment|/* XXX maybe... */
elif|#
directive|elif
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|3
operator|,
literal|4
operator|,
literal|0
argument_list|)
name|int
name|events
init|=
name|pwait
condition|?
name|pwait
operator|->
name|key
else|:
name|POLLIN
operator||
name|POLLOUT
decl_stmt|;
else|#
directive|else
comment|/* in 3.4.0 field 'key' was renamed to '_key' */
name|int
name|events
init|=
name|pwait
condition|?
name|pwait
operator|->
name|_key
else|:
name|POLLIN
operator||
name|POLLOUT
decl_stmt|;
endif|#
directive|endif
return|return
name|netmap_poll
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pwait
argument_list|,
name|events
argument_list|,
operator|(
name|void
operator|*
operator|)
name|file
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|linux_netmap_mmap
parameter_list|(
name|struct
name|file
modifier|*
name|f
parameter_list|,
name|struct
name|vm_area_struct
modifier|*
name|vma
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|off
decl_stmt|,
name|va
decl_stmt|;
name|vm_ooffset_t
name|pa
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|f
operator|->
name|private_data
decl_stmt|;
comment|/* 	 * vma->vm_start: start of mapping user address space 	 * vma->vm_end: end of the mapping user address space 	 * vma->vm_pfoff: offset of first page in the device 	 */
comment|// XXX security checks
name|error
operator|=
name|netmap_get_memory
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"get_memory returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
if|if
condition|(
operator|(
name|vma
operator|->
name|vm_start
operator|&
operator|~
name|PAGE_MASK
operator|)
operator|||
operator|(
name|vma
operator|->
name|vm_end
operator|&
operator|~
name|PAGE_MASK
operator|)
condition|)
block|{
name|ND
argument_list|(
literal|"vm_start = %lx vm_end = %lx"
argument_list|,
name|vma
operator|->
name|vm_start
argument_list|,
name|vma
operator|->
name|vm_end
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
for|for
control|(
name|va
operator|=
name|vma
operator|->
name|vm_start
operator|,
name|off
operator|=
name|vma
operator|->
name|vm_pgoff
init|;
name|va
operator|<
name|vma
operator|->
name|vm_end
condition|;
name|va
operator|+=
name|PAGE_SIZE
operator|,
name|off
operator|++
control|)
block|{
name|pa
operator|=
name|netmap_mem_ofstophys
argument_list|(
name|priv
operator|->
name|np_mref
argument_list|,
name|off
operator|<<
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|ND
argument_list|(
literal|"va %lx pa %p"
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|error
operator|=
name|remap_pfn_range
argument_list|(
name|vma
argument_list|,
name|va
argument_list|,
name|pa
operator|>>
name|PAGE_SHIFT
argument_list|,
name|PAGE_SIZE
argument_list|,
name|vma
operator|->
name|vm_page_prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This one is probably already protected by the netif lock XXX  */
end_comment

begin_function
specifier|static
name|netdev_tx_t
name|linux_netmap_start_xmit
parameter_list|(
name|struct
name|sk_buff
modifier|*
name|skb
parameter_list|,
name|struct
name|net_device
modifier|*
name|dev
parameter_list|)
block|{
name|netmap_transmit
argument_list|(
name|dev
argument_list|,
name|skb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NETDEV_TX_OK
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|36
argument_list|)
end_if

begin_comment
comment|// XXX was 37
end_comment

begin_define
define|#
directive|define
name|LIN_IOCTL_NAME
value|.ioctl
end_define

begin_decl_stmt
name|int
name|linux_netmap_ioctl
argument_list|(
expr|struct
name|inode
operator|*
name|inode
argument_list|,
expr|struct
name|file
operator|*
name|file
argument_list|,
name|u_int
name|cmd
argument_list|,
name|u_long
name|data
comment|/* arg */
argument_list|)
else|#
directive|else
define|#
directive|define
name|LIN_IOCTL_NAME
value|.unlocked_ioctl
name|long
name|linux_netmap_ioctl
argument_list|(
expr|struct
name|file
operator|*
name|file
argument_list|,
name|u_int
name|cmd
argument_list|,
name|u_long
name|data
comment|/* arg */
argument_list|)
endif|#
directive|endif
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|nmreq
name|nmr
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|nmr
argument_list|,
sizeof|sizeof
argument_list|(
name|nmr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
operator|||
name|cmd
operator|==
name|NIOCRXSYNC
condition|)
block|{
name|data
operator|=
literal|0
expr_stmt|;
comment|/* no argument required here */
block|}
if|if
condition|(
name|data
operator|&&
name|copy_from_user
argument_list|(
operator|&
name|nmr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|nmr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
name|EFAULT
return|;
name|ret
operator|=
name|netmap_ioctl
argument_list|(
name|NULL
argument_list|,
name|cmd
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nmr
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&&
name|copy_to_user
argument_list|(
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
operator|&
name|nmr
argument_list|,
sizeof|sizeof
argument_list|(
name|nmr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
name|EFAULT
return|;
return|return
operator|-
name|ret
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|netmap_release
parameter_list|(
name|struct
name|inode
modifier|*
name|inode
parameter_list|,
name|struct
name|file
modifier|*
name|file
parameter_list|)
block|{
operator|(
name|void
operator|)
name|inode
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
name|file
operator|->
name|private_data
condition|)
name|netmap_dtor
argument_list|(
name|file
operator|->
name|private_data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|linux_netmap_open
parameter_list|(
name|struct
name|inode
modifier|*
name|inode
parameter_list|,
name|struct
name|file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
decl_stmt|;
operator|(
name|void
operator|)
name|inode
expr_stmt|;
comment|/* UNUSED */
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_priv_d
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|file
operator|->
name|private_data
operator|=
name|priv
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|file_operations
name|netmap_fops
init|=
block|{
operator|.
name|owner
operator|=
name|THIS_MODULE
block|,
operator|.
name|open
operator|=
name|linux_netmap_open
block|,
operator|.
name|mmap
operator|=
name|linux_netmap_mmap
block|,
name|LIN_IOCTL_NAME
operator|=
name|linux_netmap_ioctl
block|,
operator|.
name|poll
operator|=
name|linux_netmap_poll
block|,
operator|.
name|release
operator|=
name|netmap_release
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|miscdevice
name|netmap_cdevsw
init|=
block|{
comment|/* same name as FreeBSD */
name|MISC_DYNAMIC_MINOR
block|,
literal|"netmap"
block|,
operator|&
name|netmap_fops
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|netmap_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|netmap_fini
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Errors have negative values on linux */
end_comment

begin_function
specifier|static
name|int
name|linux_netmap_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|-
name|netmap_init
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|module_init
argument_list|(
name|linux_netmap_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|netmap_fini
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* export certain symbols to other modules */
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_attach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// driver attach routines
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_detach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// driver detach routines
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_ring_reinit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// ring init on error
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_buffer_lut
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_total_buffers
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// index check
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_buffer_base
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_reset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// ring init routines
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_buf_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_rx_irq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// default irq handler
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_no_pendintr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// XXX mitigation - should go away
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_bdg_ctl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// bridge configuration routine
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_bdg_learning
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// the default lookup function
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_disable_all_rings
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_enable_all_rings
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"http://info.iet.unipi.it/~luigi/netmap/"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"The netmap packet I/O framework"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"Dual BSD/GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* the code here is all BSD. */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|netmap_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_name
operator|=
literal|"netmap"
block|,
operator|.
name|d_open
operator|=
name|netmap_open
block|,
operator|.
name|d_mmap_single
operator|=
name|netmap_mmap_single
block|,
operator|.
name|d_ioctl
operator|=
name|netmap_ioctl
block|,
operator|.
name|d_poll
operator|=
name|netmap_poll
block|,
operator|.
name|d_close
operator|=
name|netmap_close
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/*  *---- support for virtual bridge -----  */
end_comment

begin_comment
comment|/* ----- FreeBSD if_bridge hash function ------- */
end_comment

begin_comment
comment|/*  * The following hash function is adapted from "Hash Functions" by Bob Jenkins  * ("Algorithm Alley", Dr. Dobbs Journal, September 1997).  *  * http://www.burtleburtle.net/bob/hash/spooky.html  */
end_comment

begin_define
define|#
directive|define
name|mix
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|do {                                                                    \         a -= b; a -= c; a ^= (c>> 13);                                 \         b -= c; b -= a; b ^= (a<< 8);                                  \         c -= a; c -= b; c ^= (b>> 13);                                 \         a -= b; a -= c; a ^= (c>> 12);                                 \         b -= c; b -= a; b ^= (a<< 16);                                 \         c -= a; c -= b; c ^= (b>> 5);                                  \         a -= b; a -= c; a ^= (c>> 3);                                  \         b -= c; b -= a; b ^= (a<< 10);                                 \         c -= a; c -= b; c ^= (b>> 15);                                 \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_function
specifier|static
name|__inline
name|uint32_t
name|nm_bridge_rthash
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint32_t
name|a
init|=
literal|0x9e3779b9
decl_stmt|,
name|b
init|=
literal|0x9e3779b9
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
comment|// hask key
name|b
operator|+=
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
name|b
operator|+=
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
define|#
directive|define
name|BRIDGE_RTHASH_MASK
value|(NM_BDG_HASH-1)
return|return
operator|(
name|c
operator|&
name|BRIDGE_RTHASH_MASK
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|mix
end_undef

begin_function
specifier|static
name|int
name|bdg_netmap_reg
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
comment|/* the interface is already attached to the bridge, 	 * so we only need to toggle IFCAP_NETMAP. 	 */
if|if
condition|(
name|onoff
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_NETMAP
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_NETMAP
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup function for a learning bridge.  * Update the hash table with the source address,  * and then returns the destination port index, and the  * ring in *dst_ring (at the moment, always use ring 0)  */
end_comment

begin_function
name|u_int
name|netmap_bdg_learning
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|u_int
name|buf_len
parameter_list|,
name|uint8_t
modifier|*
name|dst_ring
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|nm_hash_ent
modifier|*
name|ht
init|=
name|na
operator|->
name|na_bdg
operator|->
name|ht
decl_stmt|;
name|uint32_t
name|sh
decl_stmt|,
name|dh
decl_stmt|;
name|u_int
name|dst
decl_stmt|,
name|mysrc
init|=
name|na
operator|->
name|bdg_port
decl_stmt|;
name|uint64_t
name|smac
decl_stmt|,
name|dmac
decl_stmt|;
if|if
condition|(
name|buf_len
operator|<
literal|14
condition|)
block|{
name|D
argument_list|(
literal|"invalid buf length %d"
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
return|return
name|NM_BDG_NOPORT
return|;
block|}
name|dmac
operator|=
name|le64toh
argument_list|(
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|buf
operator|)
argument_list|)
operator|&
literal|0xffffffffffff
expr_stmt|;
name|smac
operator|=
name|le64toh
argument_list|(
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|buf
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
name|smac
operator|>>=
literal|16
expr_stmt|;
comment|/* 	 * The hash is somewhat expensive, there might be some 	 * worthwhile optimizations here. 	 */
if|if
condition|(
operator|(
name|buf
index|[
literal|6
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* valid src */
name|uint8_t
modifier|*
name|s
init|=
name|buf
operator|+
literal|6
decl_stmt|;
name|sh
operator|=
name|nm_bridge_rthash
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|// XXX hash of source
comment|/* update source port forwarding entry */
name|ht
index|[
name|sh
index|]
operator|.
name|mac
operator|=
name|smac
expr_stmt|;
comment|/* XXX expire ? */
name|ht
index|[
name|sh
index|]
operator|.
name|ports
operator|=
name|mysrc
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"src %02x:%02x:%02x:%02x:%02x:%02x on port %d"
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|,
name|s
index|[
literal|4
index|]
argument_list|,
name|s
index|[
literal|5
index|]
argument_list|,
name|mysrc
argument_list|)
expr_stmt|;
block|}
name|dst
operator|=
name|NM_BDG_BROADCAST
expr_stmt|;
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* unicast */
name|dh
operator|=
name|nm_bridge_rthash
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// XXX hash of dst
if|if
condition|(
name|ht
index|[
name|dh
index|]
operator|.
name|mac
operator|==
name|dmac
condition|)
block|{
comment|/* found dst */
name|dst
operator|=
name|ht
index|[
name|dh
index|]
operator|.
name|ports
expr_stmt|;
block|}
comment|/* XXX otherwise return NM_BDG_UNKNOWN ? */
block|}
operator|*
name|dst_ring
operator|=
literal|0
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/*  * This flush routine supports only unicast and broadcast but a large  * number of ports, and lets us replace the learn and dispatch functions.  */
end_comment

begin_function
name|int
name|nm_bdg_flush
parameter_list|(
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
parameter_list|,
name|u_int
name|n
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|)
block|{
name|struct
name|nm_bdg_q
modifier|*
name|dst_ents
decl_stmt|,
modifier|*
name|brddst
decl_stmt|;
name|uint16_t
name|num_dsts
init|=
literal|0
decl_stmt|,
modifier|*
name|dsts
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|na
operator|->
name|na_bdg
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|me
init|=
name|na
operator|->
name|bdg_port
decl_stmt|;
comment|/* 	 * The work area (pointed by ft) is followed by an array of 	 * pointers to queues , dst_ents; there are NM_BDG_MAXRINGS 	 * queues per port plus one for the broadcast traffic. 	 * Then we have an array of destination indexes. 	 */
name|dst_ents
operator|=
operator|(
expr|struct
name|nm_bdg_q
operator|*
operator|)
operator|(
name|ft
operator|+
name|NM_BDG_BATCH_MAX
operator|)
expr_stmt|;
name|dsts
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|dst_ents
operator|+
name|NM_BDG_MAXPORTS
operator|*
name|NM_BDG_MAXRINGS
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* first pass: find a destination for each packet in the batch */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|likely
argument_list|(
name|i
operator|<
name|n
argument_list|)
condition|;
name|i
operator|+=
name|ft
index|[
name|i
index|]
operator|.
name|ft_frags
control|)
block|{
name|uint8_t
name|dst_ring
init|=
name|ring_nr
decl_stmt|;
comment|/* default, same ring as origin */
name|uint16_t
name|dst_port
decl_stmt|,
name|d_i
decl_stmt|;
name|struct
name|nm_bdg_q
modifier|*
name|d
decl_stmt|;
name|ND
argument_list|(
literal|"slot %d frags %d"
argument_list|,
name|i
argument_list|,
name|ft
index|[
name|i
index|]
operator|.
name|ft_frags
argument_list|)
expr_stmt|;
name|dst_port
operator|=
name|b
operator|->
name|nm_bdg_lookup
argument_list|(
name|ft
index|[
name|i
index|]
operator|.
name|ft_buf
argument_list|,
name|ft
index|[
name|i
index|]
operator|.
name|ft_len
argument_list|,
operator|&
name|dst_ring
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|>
literal|255
condition|)
name|RD
argument_list|(
literal|5
argument_list|,
literal|"slot %d port %d -> %d"
argument_list|,
name|i
argument_list|,
name|me
argument_list|,
name|dst_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_port
operator|==
name|NM_BDG_NOPORT
condition|)
continue|continue;
comment|/* this packet is identified to be dropped */
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|dst_port
operator|>
name|NM_BDG_MAXPORTS
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|dst_port
operator|==
name|NM_BDG_BROADCAST
condition|)
name|dst_ring
operator|=
literal|0
expr_stmt|;
comment|/* broadcasts always go to ring 0 */
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|dst_port
operator|==
name|me
operator|||
operator|!
name|b
operator|->
name|bdg_ports
index|[
name|dst_port
index|]
argument_list|)
condition|)
continue|continue;
comment|/* get a position in the scratch pad */
name|d_i
operator|=
name|dst_port
operator|*
name|NM_BDG_MAXRINGS
operator|+
name|dst_ring
expr_stmt|;
name|d
operator|=
name|dst_ents
operator|+
name|d_i
expr_stmt|;
comment|/* append the first fragment to the list */
if|if
condition|(
name|d
operator|->
name|bq_head
operator|==
name|NM_FT_NULL
condition|)
block|{
comment|/* new destination */
name|d
operator|->
name|bq_head
operator|=
name|d
operator|->
name|bq_tail
operator|=
name|i
expr_stmt|;
comment|/* remember this position to be scanned later */
if|if
condition|(
name|dst_port
operator|!=
name|NM_BDG_BROADCAST
condition|)
name|dsts
index|[
name|num_dsts
operator|++
index|]
operator|=
name|d_i
expr_stmt|;
block|}
else|else
block|{
name|ft
index|[
name|d
operator|->
name|bq_tail
index|]
operator|.
name|ft_next
operator|=
name|i
expr_stmt|;
name|d
operator|->
name|bq_tail
operator|=
name|i
expr_stmt|;
block|}
name|d
operator|->
name|bq_len
operator|+=
name|ft
index|[
name|i
index|]
operator|.
name|ft_frags
expr_stmt|;
block|}
comment|/* 	 * Broadcast traffic goes to ring 0 on all destinations. 	 * So we need to add these rings to the list of ports to scan. 	 * XXX at the moment we scan all NM_BDG_MAXPORTS ports, which is 	 * expensive. We should keep a compact list of active destinations 	 * so we could shorten this loop. 	 */
name|brddst
operator|=
name|dst_ents
operator|+
name|NM_BDG_BROADCAST
operator|*
name|NM_BDG_MAXRINGS
expr_stmt|;
if|if
condition|(
name|brddst
operator|->
name|bq_head
operator|!=
name|NM_FT_NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|likely
argument_list|(
name|j
operator|<
name|b
operator|->
name|bdg_active_ports
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|uint16_t
name|d_i
decl_stmt|;
name|i
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|i
operator|==
name|me
argument_list|)
condition|)
continue|continue;
name|d_i
operator|=
name|i
operator|*
name|NM_BDG_MAXRINGS
expr_stmt|;
if|if
condition|(
name|dst_ents
index|[
name|d_i
index|]
operator|.
name|bq_head
operator|==
name|NM_FT_NULL
condition|)
name|dsts
index|[
name|num_dsts
operator|++
index|]
operator|=
name|d_i
expr_stmt|;
block|}
block|}
name|ND
argument_list|(
literal|5
argument_list|,
literal|"pass 1 done %d pkts %d dsts"
argument_list|,
name|n
argument_list|,
name|num_dsts
argument_list|)
expr_stmt|;
comment|/* second pass: scan destinations (XXX will be modular somehow) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_dsts
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ifnet
modifier|*
name|dst_ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|dst_na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
decl_stmt|;
name|u_int
name|dst_nr
decl_stmt|,
name|is_vp
decl_stmt|,
name|lim
decl_stmt|,
name|j
decl_stmt|,
name|sent
init|=
literal|0
decl_stmt|,
name|d_i
decl_stmt|,
name|next
decl_stmt|,
name|brd_next
decl_stmt|;
name|u_int
name|needed
decl_stmt|,
name|howmany
decl_stmt|;
name|int
name|retry
init|=
name|netmap_txsync_retry
decl_stmt|;
name|struct
name|nm_bdg_q
modifier|*
name|d
decl_stmt|;
name|uint32_t
name|my_start
init|=
literal|0
decl_stmt|,
name|lease_idx
init|=
literal|0
decl_stmt|;
name|int
name|nrings
decl_stmt|;
name|d_i
operator|=
name|dsts
index|[
name|i
index|]
expr_stmt|;
name|ND
argument_list|(
literal|"second pass %d port %d"
argument_list|,
name|i
argument_list|,
name|d_i
argument_list|)
expr_stmt|;
name|d
operator|=
name|dst_ents
operator|+
name|d_i
expr_stmt|;
comment|// XXX fix the division
name|dst_na
operator|=
name|b
operator|->
name|bdg_ports
index|[
name|d_i
operator|/
name|NM_BDG_MAXRINGS
index|]
expr_stmt|;
comment|/* protect from the lookup function returning an inactive 		 * destination port 		 */
if|if
condition|(
name|unlikely
argument_list|(
name|dst_na
operator|==
name|NULL
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|dst_na
operator|->
name|na_flags
operator|&
name|NAF_SW_ONLY
condition|)
goto|goto
name|cleanup
goto|;
name|dst_ifp
operator|=
name|dst_na
operator|->
name|ifp
expr_stmt|;
comment|/* 		 * The interface may be in !netmap mode in two cases: 		 * - when na is attached but not activated yet; 		 * - when na is being deactivated but is still attached. 		 */
if|if
condition|(
name|unlikely
argument_list|(
operator|!
operator|(
name|dst_ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
argument_list|)
condition|)
block|{
name|ND
argument_list|(
literal|"not in netmap mode!"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* there is at least one either unicast or broadcast packet */
name|brd_next
operator|=
name|brddst
operator|->
name|bq_head
expr_stmt|;
name|next
operator|=
name|d
operator|->
name|bq_head
expr_stmt|;
comment|/* we need to reserve this many slots. If fewer are 		 * available, some packets will be dropped. 		 * Packets may have multiple fragments, so we may not use 		 * there is a chance that we may not use all of the slots 		 * we have claimed, so we will need to handle the leftover 		 * ones when we regain the lock. 		 */
name|needed
operator|=
name|d
operator|->
name|bq_len
operator|+
name|brddst
operator|->
name|bq_len
expr_stmt|;
name|is_vp
operator|=
name|nma_is_vp
argument_list|(
name|dst_na
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"pass 2 dst %d is %x %s"
argument_list|,
name|i
argument_list|,
name|d_i
argument_list|,
name|is_vp
condition|?
literal|"virtual"
else|:
literal|"nic/host"
argument_list|)
expr_stmt|;
name|dst_nr
operator|=
name|d_i
operator|&
operator|(
name|NM_BDG_MAXRINGS
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|is_vp
condition|)
block|{
comment|/* virtual port */
name|nrings
operator|=
name|dst_na
operator|->
name|num_rx_rings
expr_stmt|;
block|}
else|else
block|{
name|nrings
operator|=
name|dst_na
operator|->
name|num_tx_rings
expr_stmt|;
block|}
if|if
condition|(
name|dst_nr
operator|>=
name|nrings
condition|)
name|dst_nr
operator|=
name|dst_nr
operator|%
name|nrings
expr_stmt|;
name|kring
operator|=
name|is_vp
condition|?
operator|&
name|dst_na
operator|->
name|rx_rings
index|[
name|dst_nr
index|]
else|:
operator|&
name|dst_na
operator|->
name|tx_rings
index|[
name|dst_nr
index|]
expr_stmt|;
name|ring
operator|=
name|kring
operator|->
name|ring
expr_stmt|;
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
name|retry
label|:
comment|/* reserve the buffers in the queue and an entry 		 * to report completion, and drop lock. 		 * XXX this might become a helper function. 		 */
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nkr_stopped
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* on physical interfaces, do a txsync to recover 		 * slots for packets already transmitted. 		 * XXX maybe we could be optimistic and rely on a retry 		 * in case of failure. 		 */
if|if
condition|(
name|nma_is_hw
argument_list|(
name|dst_na
argument_list|)
condition|)
block|{
name|dst_na
operator|->
name|nm_txsync
argument_list|(
name|dst_ifp
argument_list|,
name|dst_nr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|my_start
operator|=
name|j
operator|=
name|kring
operator|->
name|nkr_hwlease
expr_stmt|;
name|howmany
operator|=
name|nm_kr_space
argument_list|(
name|kring
argument_list|,
name|is_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|needed
operator|<
name|howmany
condition|)
name|howmany
operator|=
name|needed
expr_stmt|;
name|lease_idx
operator|=
name|nm_kr_lease
argument_list|(
name|kring
argument_list|,
name|howmany
argument_list|,
name|is_vp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
comment|/* only retry if we need more than available slots */
if|if
condition|(
name|retry
operator|&&
name|needed
operator|<=
name|howmany
condition|)
name|retry
operator|=
literal|0
expr_stmt|;
comment|/* copy to the destination queue */
while|while
condition|(
name|howmany
operator|>
literal|0
condition|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|nm_bdg_fwd
modifier|*
name|ft_p
decl_stmt|,
modifier|*
name|ft_end
decl_stmt|;
name|u_int
name|cnt
decl_stmt|;
comment|/* find the queue from which we pick next packet. 			 * NM_FT_NULL is always higher than valid indexes 			 * so we never dereference it if the other list 			 * has packets (and if both are empty we never 			 * get here). 			 */
if|if
condition|(
name|next
operator|<
name|brd_next
condition|)
block|{
name|ft_p
operator|=
name|ft
operator|+
name|next
expr_stmt|;
name|next
operator|=
name|ft_p
operator|->
name|ft_next
expr_stmt|;
block|}
else|else
block|{
comment|/* insert broadcast */
name|ft_p
operator|=
name|ft
operator|+
name|brd_next
expr_stmt|;
name|brd_next
operator|=
name|ft_p
operator|->
name|ft_next
expr_stmt|;
block|}
name|cnt
operator|=
name|ft_p
operator|->
name|ft_frags
expr_stmt|;
comment|// cnt> 0
if|if
condition|(
name|unlikely
argument_list|(
name|cnt
operator|>
name|howmany
argument_list|)
condition|)
break|break;
comment|/* no more space */
name|howmany
operator|-=
name|cnt
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&&
name|cnt
operator|>
literal|1
condition|)
name|RD
argument_list|(
literal|5
argument_list|,
literal|"rx %d frags to %d"
argument_list|,
name|cnt
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ft_end
operator|=
name|ft_p
operator|+
name|cnt
expr_stmt|;
do|do
block|{
name|void
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
init|=
name|ft_p
operator|->
name|ft_buf
decl_stmt|;
name|size_t
name|len
init|=
operator|(
name|ft_p
operator|->
name|ft_len
operator|+
literal|63
operator|)
operator|&
operator|~
literal|63
decl_stmt|;
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
name|j
index|]
expr_stmt|;
name|dst
operator|=
name|BDG_NMB
argument_list|(
name|dst_na
operator|->
name|nm_mem
argument_list|,
name|slot
argument_list|)
expr_stmt|;
comment|/* round to a multiple of 64 */
name|ND
argument_list|(
literal|"send %d %d bytes at %s:%d"
argument_list|,
name|i
argument_list|,
name|ft_p
operator|->
name|ft_len
argument_list|,
name|dst_ifp
operator|->
name|if_xname
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|ft_p
operator|->
name|ft_flags
operator|&
name|NS_INDIRECT
condition|)
block|{
if|if
condition|(
name|copyin
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|len
argument_list|)
condition|)
block|{
comment|// invalid user pointer, pretend len is 0
name|ft_p
operator|->
name|ft_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//memcpy(dst, src, len);
name|pkt_copy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|len
operator|=
name|ft_p
operator|->
name|ft_len
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
operator|(
name|cnt
operator|<<
literal|8
operator|)
operator||
name|NS_MOREFRAG
expr_stmt|;
name|j
operator|=
name|nm_next
argument_list|(
name|j
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|ft_p
operator|++
expr_stmt|;
name|sent
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ft_p
operator|!=
name|ft_end
condition|)
do|;
name|slot
operator|->
name|flags
operator|=
operator|(
name|cnt
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* clear flag on last entry */
comment|/* are we done ? */
if|if
condition|(
name|next
operator|==
name|NM_FT_NULL
operator|&&
name|brd_next
operator|==
name|NM_FT_NULL
condition|)
break|break;
block|}
block|{
comment|/* current position */
name|uint32_t
modifier|*
name|p
init|=
name|kring
operator|->
name|nkr_leases
decl_stmt|;
comment|/* shorthand */
name|uint32_t
name|update_pos
decl_stmt|;
name|int
name|still_locked
init|=
literal|1
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|howmany
operator|>
literal|0
argument_list|)
condition|)
block|{
comment|/* not used all bufs. If i am the last one 			 * i can recover the slots, otherwise must 			 * fill them with 0 to mark empty packets. 			 */
name|ND
argument_list|(
literal|"leftover %d bufs"
argument_list|,
name|howmany
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_next
argument_list|(
name|lease_idx
argument_list|,
name|lim
argument_list|)
operator|==
name|kring
operator|->
name|nkr_lease_idx
condition|)
block|{
comment|/* yes i am the last one */
name|ND
argument_list|(
literal|"roll back nkr_hwlease to %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nkr_hwlease
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|howmany
operator|--
operator|>
literal|0
condition|)
block|{
name|ring
operator|->
name|slot
index|[
name|j
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|j
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|nm_next
argument_list|(
name|j
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|p
index|[
name|lease_idx
index|]
operator|=
name|j
expr_stmt|;
comment|/* report I am done */
name|update_pos
operator|=
name|is_vp
condition|?
name|nm_kr_rxpos
argument_list|(
name|kring
argument_list|)
else|:
name|ring
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|my_start
operator|==
name|update_pos
condition|)
block|{
comment|/* all slots before my_start have been reported, 			 * so scan subsequent leases to see if other ranges 			 * have been completed, and to a selwakeup or txsync. 		         */
while|while
condition|(
name|lease_idx
operator|!=
name|kring
operator|->
name|nkr_lease_idx
operator|&&
name|p
index|[
name|lease_idx
index|]
operator|!=
name|NR_NOSLOT
condition|)
block|{
name|j
operator|=
name|p
index|[
name|lease_idx
index|]
expr_stmt|;
name|p
index|[
name|lease_idx
index|]
operator|=
name|NR_NOSLOT
expr_stmt|;
name|lease_idx
operator|=
name|nm_next
argument_list|(
name|lease_idx
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
comment|/* j is the new 'write' position. j != my_start 			 * means there are new buffers to report 			 */
if|if
condition|(
name|likely
argument_list|(
name|j
operator|!=
name|my_start
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_vp
condition|)
block|{
name|uint32_t
name|old_avail
init|=
name|kring
operator|->
name|nr_hwavail
decl_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|=
operator|(
name|j
operator|>=
name|kring
operator|->
name|nr_hwcur
operator|)
condition|?
name|j
operator|-
name|kring
operator|->
name|nr_hwcur
else|:
name|j
operator|+
name|lim
operator|+
literal|1
operator|-
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwavail
operator|<
name|old_avail
condition|)
block|{
name|D
argument_list|(
literal|"avail shrink %d -> %d"
argument_list|,
name|old_avail
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
block|}
name|still_locked
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ring
operator|->
name|cur
operator|=
name|j
expr_stmt|;
comment|/* XXX update avail ? */
name|still_locked
operator|=
literal|0
expr_stmt|;
name|dst_na
operator|->
name|nm_txsync
argument_list|(
name|dst_ifp
argument_list|,
name|dst_nr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
comment|/* retry to send more packets */
if|if
condition|(
name|nma_is_hw
argument_list|(
name|dst_na
argument_list|)
operator|&&
name|retry
operator|--
condition|)
goto|goto
name|retry
goto|;
block|}
block|}
block|}
if|if
condition|(
name|still_locked
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
name|d
operator|->
name|bq_head
operator|=
name|d
operator|->
name|bq_tail
operator|=
name|NM_FT_NULL
expr_stmt|;
comment|/* cleanup */
name|d
operator|->
name|bq_len
operator|=
literal|0
expr_stmt|;
block|}
name|brddst
operator|->
name|bq_head
operator|=
name|brddst
operator|->
name|bq_tail
operator|=
name|NM_FT_NULL
expr_stmt|;
comment|/* cleanup */
name|brddst
operator|->
name|bq_len
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * main dispatch routine for the bridge.  * We already know that only one thread is running this.  * we must run nm_bdg_preflush without lock.  */
end_comment

begin_function
specifier|static
name|int
name|bdg_netmap_txsync
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|ring_nr
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|k
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|lim
condition|)
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
if|if
condition|(
name|bridge_batch
operator|<=
literal|0
condition|)
block|{
comment|/* testing only */
name|j
operator|=
name|k
expr_stmt|;
comment|// used all
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|bridge_batch
operator|>
name|NM_BDG_BATCH
condition|)
name|bridge_batch
operator|=
name|NM_BDG_BATCH
expr_stmt|;
name|j
operator|=
name|nm_bdg_preflush
argument_list|(
name|na
argument_list|,
name|ring_nr
argument_list|,
name|kring
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|k
condition|)
name|D
argument_list|(
literal|"early break at %d/ %d, avail %d"
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
comment|/* k-j modulo ring size is the number of slots processed */
if|if
condition|(
name|k
operator|<
name|j
condition|)
name|k
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|=
name|lim
operator|-
operator|(
name|k
operator|-
name|j
operator|)
expr_stmt|;
name|done
label|:
name|kring
operator|->
name|nr_hwcur
operator|=
name|j
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s ring %d flags %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|ring_nr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * user process reading from a VALE switch.  * Already protected against concurrent calls from userspace,  * but we must acquire the queue's lock to protect against  * writers on the same queue.  */
end_comment

begin_function
specifier|static
name|int
name|bdg_netmap_rxsync
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|ring_nr
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|j
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
name|k
init|=
name|ring
operator|->
name|cur
decl_stmt|,
name|resvd
init|=
name|ring
operator|->
name|reserved
decl_stmt|;
name|int
name|n
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|lim
condition|)
block|{
name|D
argument_list|(
literal|"ouch dangerous reset!!!"
argument_list|)
expr_stmt|;
name|n
operator|=
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* skip past packets that userspace has released */
name|j
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
comment|/* netmap ring index */
if|if
condition|(
name|resvd
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|resvd
operator|+
name|ring
operator|->
name|avail
operator|>=
name|lim
operator|+
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"XXX invalid reserve/avail %d %d"
argument_list|,
name|resvd
argument_list|,
name|ring
operator|->
name|avail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|reserved
operator|=
name|resvd
operator|=
literal|0
expr_stmt|;
comment|// XXX panic...
block|}
name|k
operator|=
operator|(
name|k
operator|>=
name|resvd
operator|)
condition|?
name|k
operator|-
name|resvd
else|:
name|k
operator|+
name|lim
operator|+
literal|1
operator|-
name|resvd
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
name|k
condition|)
block|{
comment|/* userspace has released some packets. */
name|n
operator|=
name|k
operator|-
name|j
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|ND
argument_list|(
literal|"userspace releases %d packets"
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|likely
argument_list|(
name|j
operator|!=
name|k
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|j
index|]
decl_stmt|;
name|void
modifier|*
name|addr
init|=
name|BDG_NMB
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
name|slot
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|netmap_buffer_base
condition|)
block|{
comment|/* bad buf */
name|D
argument_list|(
literal|"bad buffer index %d, ignore ?"
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_BUF_CHANGED
expr_stmt|;
name|j
operator|=
name|nm_next
argument_list|(
name|j
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwavail
operator|-=
name|n
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|k
expr_stmt|;
block|}
comment|/* tell userspace that there are new packets */
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
operator|-
name|resvd
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bdg_netmap_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|netmap_adapter
name|na
decl_stmt|;
name|ND
argument_list|(
literal|"attaching virtual bridge"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|na
argument_list|,
sizeof|sizeof
argument_list|(
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|na
operator|.
name|ifp
operator|=
name|arg
operator|->
name|ifp
expr_stmt|;
name|na
operator|.
name|na_flags
operator|=
name|NAF_BDG_MAYSLEEP
operator||
name|NAF_MEM_OWNER
expr_stmt|;
name|na
operator|.
name|num_tx_rings
operator|=
name|arg
operator|->
name|num_tx_rings
expr_stmt|;
name|na
operator|.
name|num_rx_rings
operator|=
name|arg
operator|->
name|num_rx_rings
expr_stmt|;
name|na
operator|.
name|num_tx_desc
operator|=
name|arg
operator|->
name|num_tx_desc
expr_stmt|;
name|na
operator|.
name|num_rx_desc
operator|=
name|arg
operator|->
name|num_rx_desc
expr_stmt|;
name|na
operator|.
name|nm_txsync
operator|=
name|bdg_netmap_txsync
expr_stmt|;
name|na
operator|.
name|nm_rxsync
operator|=
name|bdg_netmap_rxsync
expr_stmt|;
name|na
operator|.
name|nm_register
operator|=
name|bdg_netmap_reg
expr_stmt|;
name|na
operator|.
name|nm_mem
operator|=
name|netmap_mem_private_new
argument_list|(
name|arg
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|na
operator|.
name|num_tx_rings
argument_list|,
name|na
operator|.
name|num_tx_desc
argument_list|,
name|na
operator|.
name|num_rx_rings
argument_list|,
name|na
operator|.
name|num_rx_desc
argument_list|)
expr_stmt|;
name|netmap_attach
argument_list|(
operator|&
name|na
argument_list|,
name|na
operator|.
name|num_tx_rings
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|netmap_dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* /dev/netmap character device. */
end_comment

begin_comment
comment|/*  * Module loader.  *  * Create the /dev/netmap device and initialize all global  * variables.  *  * Return 0 on success, errno on failure.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|NMG_LOCK_INIT
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_mem_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"netmap: unable to initialize the memory allocator.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"netmap: loaded module\n"
argument_list|)
expr_stmt|;
name|netmap_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|netmap_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0660
argument_list|,
literal|"netmap"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|nm_bridges
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nm_bridge
argument_list|)
operator|*
name|NM_BRIDGES
argument_list|)
expr_stmt|;
comment|/* safety */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BRIDGES
condition|;
name|i
operator|++
control|)
name|BDG_RWINIT
argument_list|(
operator|&
name|nm_bridges
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Module unloader.  *  * Free all the memory, and destroy the ``/dev/netmap`` device.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|destroy_dev
argument_list|(
name|netmap_dev
argument_list|)
expr_stmt|;
name|netmap_mem_fini
argument_list|()
expr_stmt|;
name|NMG_LOCK_DESTROY
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"netmap: unloaded module.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_comment
comment|/*  * Kernel entry point.  *  * Initialize/finalize the module and return.  *  * Return 0 on success, errno on failure.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_loader
parameter_list|(
name|__unused
name|struct
name|module
modifier|*
name|module
parameter_list|,
name|int
name|event
parameter_list|,
name|__unused
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
name|netmap_init
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|netmap_fini
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|netmap
argument_list|,
name|netmap_loader
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

end_unit

