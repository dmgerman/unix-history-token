begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 Matteo Landi, Luigi Rizzo. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  * $Id: netmap.c 9662 2011-11-16 13:18:06Z luigi $  *  * This module supports memory mapped access to network devices,  * see netmap(4).  *  * The module uses a large, memory pool allocated by the kernel  * and accessible as mmapped memory by multiple userspace threads/processes.  * The memory pool contains packet buffers and "netmap rings",  * i.e. user-accessible copies of the interface's queues.  *  * Access to the network card works like this:  * 1. a process/thread issues one or more open() on /dev/netmap, to create  *    select()able file descriptor on which events are reported.  * 2. on each descriptor, the process issues an ioctl() to identify  *    the interface that should report events to the file descriptor.  * 3. on each descriptor, the process issues an mmap() request to  *    map the shared memory region within the process' address space.  *    The list of interesting queues is indicated by a location in  *    the shared memory region.  * 4. using the functions in the netmap(4) userspace API, a process  *    can look up the occupation state of a queue, access memory buffers,  *    and retrieve received packets or enqueue packets to transmit.  * 5. using some ioctl()s the process can synchronize the userspace view  *    of the queue with the actual status in the kernel. This includes both  *    receiving the notification of new packets, and transmitting new  *    packets on the output interface.  * 6. select() or poll() can be used to wait for events on individual  *    transmit or receive queues (or all queues for a given interface).  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* defines used in kernel.h */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* types used in module initialization */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_comment
comment|/* cdevsw struct */
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_comment
comment|/* uio struct */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_comment
comment|/* struct socket */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_comment
comment|/* PROT_EXEC */
end_comment

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* vtophys */
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* vtophys */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/* BIOCIMMEDIATE */
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETMAP
argument_list|,
literal|"netmap"
argument_list|,
literal|"Network memory map"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * lock and unlock for the netmap memory allocator  */
end_comment

begin_define
define|#
directive|define
name|NMA_LOCK
parameter_list|()
value|mtx_lock(&netmap_mem_d->nm_mtx);
end_define

begin_define
define|#
directive|define
name|NMA_UNLOCK
parameter_list|()
value|mtx_unlock(&netmap_mem_d->nm_mtx);
end_define

begin_comment
comment|/*  * Default amount of memory pre-allocated by the module.  * We start with a large size and then shrink our demand  * according to what is avalable when the module is loaded.  * At the moment the block is contiguous, but we can easily  * restrict our demand to smaller units (16..64k)  */
end_comment

begin_define
define|#
directive|define
name|NETMAP_MEMORY_SIZE
value|(64 * 1024 * PAGE_SIZE)
end_define

begin_function_decl
specifier|static
name|void
modifier|*
name|netmap_malloc
parameter_list|(
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|netmap_free
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Allocator for a pool of packet buffers. For each buffer we have  * one entry in the bitmap to signal the state. Allocation scans  * the bitmap, but since this is done only on attach, we are not  * too worried about performance  * XXX if we need to allocate small blocks, a translation  * table is used both for kernel virtual address and physical  * addresses.  */
end_comment

begin_struct
struct|struct
name|netmap_buf_pool
block|{
name|u_int
name|total_buffers
decl_stmt|;
comment|/* total buffers. */
name|u_int
name|free
decl_stmt|;
name|u_int
name|bufsize
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
comment|/* buffer base address */
name|uint32_t
modifier|*
name|bitmap
decl_stmt|;
comment|/* one bit per buffer, 1 means free */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|netmap_buf_pool
name|nm_buf_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX move these two vars back into netmap_buf_pool */
end_comment

begin_decl_stmt
name|u_int
name|netmap_total_buffers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|netmap_buffer_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user-controlled variables */
end_comment

begin_decl_stmt
name|int
name|netmap_verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|no_timestamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't timestamp on rxsync */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_dev
argument_list|,
name|OID_AUTO
argument_list|,
name|netmap
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Netmap args"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_verbose
argument_list|,
literal|0
argument_list|,
literal|"Verbose mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_timestamp
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|no_timestamp
argument_list|,
literal|0
argument_list|,
literal|"no_timestamp"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|total_buffers
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nm_buf_pool
operator|.
name|total_buffers
argument_list|,
literal|0
argument_list|,
literal|"total_buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|free_buffers
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nm_buf_pool
operator|.
name|free
argument_list|,
literal|0
argument_list|,
literal|"free_buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Allocate n buffers from the ring, and fill the slot.  * Buffer 0 is the 'junk' buffer.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_new_bufs
parameter_list|(
name|struct
name|netmap_buf_pool
modifier|*
name|p
parameter_list|,
name|struct
name|netmap_slot
modifier|*
name|slot
parameter_list|,
name|u_int
name|n
parameter_list|)
block|{
name|uint32_t
name|bi
init|=
literal|0
decl_stmt|;
comment|/* index in the bitmap */
name|uint32_t
name|mask
decl_stmt|,
name|j
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
comment|/* slot counter */
if|if
condition|(
name|n
operator|>
name|p
operator|->
name|free
condition|)
block|{
name|D
argument_list|(
literal|"only %d out of %d buffers available"
argument_list|,
name|i
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* termination is guaranteed by p->free */
while|while
condition|(
name|i
operator|<
name|n
operator|&&
name|p
operator|->
name|free
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|cur
init|=
name|p
operator|->
name|bitmap
index|[
name|bi
index|]
decl_stmt|;
if|if
condition|(
name|cur
operator|==
literal|0
condition|)
block|{
comment|/* bitmask is fully used */
name|bi
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* locate a slot */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|mask
operator|=
literal|1
init|;
operator|(
name|cur
operator|&
name|mask
operator|)
operator|==
literal|0
condition|;
name|j
operator|++
operator|,
name|mask
operator|<<=
literal|1
control|)
empty_stmt|;
name|p
operator|->
name|bitmap
index|[
name|bi
index|]
operator|&=
operator|~
name|mask
expr_stmt|;
comment|/* slot in use */
name|p
operator|->
name|free
operator|--
expr_stmt|;
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
operator|=
name|bi
operator|*
literal|32
operator|+
name|j
expr_stmt|;
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
name|p
operator|->
name|bufsize
expr_stmt|;
name|slot
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|NS_BUF_CHANGED
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|ND
argument_list|(
literal|"allocated %d buffers, %d available"
argument_list|,
name|n
argument_list|,
name|p
operator|->
name|free
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_free_buf
parameter_list|(
name|struct
name|netmap_buf_pool
modifier|*
name|p
parameter_list|,
name|uint32_t
name|i
parameter_list|)
block|{
name|uint32_t
name|pos
decl_stmt|,
name|mask
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|p
operator|->
name|total_buffers
condition|)
block|{
name|D
argument_list|(
literal|"invalid free index %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|pos
operator|=
name|i
operator|/
literal|32
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|i
operator|%
literal|32
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bitmap
index|[
name|pos
index|]
operator|&
name|mask
condition|)
block|{
name|D
argument_list|(
literal|"slot %d already free"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|bitmap
index|[
name|pos
index|]
operator||=
name|mask
expr_stmt|;
name|p
operator|->
name|free
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Descriptor of the memory objects handled by our memory allocator. */
end_comment

begin_struct
struct|struct
name|netmap_mem_obj
block|{
name|TAILQ_ENTRY
argument_list|(
argument|netmap_mem_obj
argument_list|)
name|nmo_next
expr_stmt|;
comment|/* next object in the 						 chain. */
name|int
name|nmo_used
decl_stmt|;
comment|/* flag set on used memory objects. */
name|size_t
name|nmo_size
decl_stmt|;
comment|/* size of the memory area reserved for the 			    object. */
name|void
modifier|*
name|nmo_data
decl_stmt|;
comment|/* pointer to the memory area. */
block|}
struct|;
end_struct

begin_comment
comment|/* Wrap our memory objects to make them ``chainable``. */
end_comment

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|netmap_mem_obj_h
argument_list|,
name|netmap_mem_obj
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Descriptor of our custom memory allocator. */
end_comment

begin_struct
struct|struct
name|netmap_mem_d
block|{
name|struct
name|mtx
name|nm_mtx
decl_stmt|;
comment|/* lock used to handle the chain of memory 			      objects. */
name|struct
name|netmap_mem_obj_h
name|nm_molist
decl_stmt|;
comment|/* list of memory objects */
name|size_t
name|nm_size
decl_stmt|;
comment|/* total amount of memory used for rings etc. */
name|size_t
name|nm_totalsize
decl_stmt|;
comment|/* total amount of allocated memory 		(the difference is used for buffers) */
name|size_t
name|nm_buf_start
decl_stmt|;
comment|/* offset of packet buffers. 			This is page-aligned. */
name|size_t
name|nm_buf_len
decl_stmt|;
comment|/* total memory for buffers */
name|void
modifier|*
name|nm_buffer
decl_stmt|;
comment|/* pointer to the whole pre-allocated memory 			    area. */
block|}
struct|;
end_struct

begin_comment
comment|/* Structure associated to each thread which registered an interface. */
end_comment

begin_struct
struct|struct
name|netmap_priv_d
block|{
name|struct
name|netmap_if
modifier|*
name|np_nifp
decl_stmt|;
comment|/* netmap interface descriptor. */
name|struct
name|ifnet
modifier|*
name|np_ifp
decl_stmt|;
comment|/* device for which we hold a reference */
name|int
name|np_ringid
decl_stmt|;
comment|/* from the ioctl */
name|u_int
name|np_qfirst
decl_stmt|,
name|np_qlast
decl_stmt|;
comment|/* range of rings to scan */
name|uint16_t
name|np_txpoll
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|netmap_dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* /dev/netmap character device. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|netmap_mem_d
modifier|*
name|netmap_mem_d
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our memory allocator. */
end_comment

begin_decl_stmt
specifier|static
name|d_mmap_t
name|netmap_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|netmap_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|netmap_poll
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NETMAP_KEVENT
end_ifdef

begin_decl_stmt
specifier|static
name|d_kqfilter_t
name|netmap_kqfilter
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|netmap_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_name
operator|=
literal|"netmap"
block|,
operator|.
name|d_mmap
operator|=
name|netmap_mmap
block|,
operator|.
name|d_ioctl
operator|=
name|netmap_ioctl
block|,
operator|.
name|d_poll
operator|=
name|netmap_poll
block|,
ifdef|#
directive|ifdef
name|NETMAP_KEVENT
operator|.
name|d_kqfilter
operator|=
name|netmap_kqfilter
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NETMAP_KEVENT
end_ifdef

begin_function_decl
specifier|static
name|int
name|netmap_kqread
parameter_list|(
name|struct
name|knote
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|netmap_kqwrite
parameter_list|(
name|struct
name|knote
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|netmap_kqdetach
parameter_list|(
name|struct
name|knote
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|netmap_read_filterops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_attach
operator|=
name|NULL
block|,
operator|.
name|f_detach
operator|=
name|netmap_kqdetach
block|,
operator|.
name|f_event
operator|=
name|netmap_kqread
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|netmap_write_filterops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_attach
operator|=
name|NULL
block|,
operator|.
name|f_detach
operator|=
name|netmap_kqdetach
block|,
operator|.
name|f_event
operator|=
name|netmap_kqwrite
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * support for the kevent() system call.  *  * This is the kevent filter, and is executed each time a new event  * is triggered on the device. This function execute some operation  * depending on the received filter.  *  * The implementation should test the filters and should implement  * filter operations we are interested on (a full list in /sys/event.h).  *  * On a match we should:  * - set kn->kn_fop  * - set kn->kn_hook  * - call knlist_add() to deliver the event to the application.  *  * Return 0 if the event should be delivered to the application.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_kqfilter
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
comment|/* declare variables needed to read/write */
switch|switch
condition|(
name|kn
operator|->
name|kn_filter
condition|)
block|{
case|case
name|EVFILT_READ
case|:
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s kqfilter: EVFILT_READ"
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* read operations */
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|netmap_read_filterops
expr_stmt|;
break|break;
case|case
name|EVFILT_WRITE
case|:
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s kqfilter: EVFILT_WRITE"
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* write operations */
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|netmap_write_filterops
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s kqfilter: invalid filter"
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|kn
operator|->
name|kn_hook
operator|=
literal|0
expr_stmt|;
comment|//
name|knlist_add
argument_list|(
operator|&
name|netmap_sc
operator|->
name|tun_rsel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETMAP_KEVENT */
end_comment

begin_comment
comment|/*  * File descriptor's private data destructor.  *  * Call nm_register(ifp,0) to stop netmap mode on the interface and  * revert to normal operation. We expect that np_ifp has not gone.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_dtor
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|np_ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|priv
operator|->
name|np_nifp
decl_stmt|;
if|if
condition|(
literal|0
condition|)
name|printf
argument_list|(
literal|"%s starting for %p ifp %p\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|priv
argument_list|,
name|priv
condition|?
name|priv
operator|->
name|np_ifp
else|:
name|NULL
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|na
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|refcount
operator|<=
literal|0
condition|)
block|{
comment|/* last instance */
name|u_int
name|i
decl_stmt|;
name|D
argument_list|(
literal|"deleting last netmap instance for %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* 		 * there is a race here with *_netmap_task() and 		 * netmap_poll(), which don't run under NETMAP_CORE_LOCK. 		 * na->refcount == 0&& na->ifp->if_capenable& IFCAP_NETMAP 		 * (aka NETMAP_DELETING(na)) are a unique marker that the 		 * device is dying. 		 * Before destroying stuff we sleep a bit, and then complete 		 * the job. NIOCREG should realize the condition and 		 * loop until they can continue; the other routines 		 * should check the condition at entry and quit if 		 * they cannot run. 		 */
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|na
argument_list|,
literal|0
argument_list|,
literal|"NIOCUNREG"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_register
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* off, clear IFCAP_NETMAP */
comment|/* Wake up any sleeping threads. netmap_poll will 		 * then return POLLERR 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_queues
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
block|}
comment|/* release all buffers */
name|NMA_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_queues
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|,
name|lim
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
decl_stmt|;
name|ND
argument_list|(
literal|"tx queue %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ring
operator|=
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|ring
expr_stmt|;
name|lim
operator|=
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|nkr_num_slots
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lim
condition|;
name|j
operator|++
control|)
name|netmap_free_buf
argument_list|(
operator|&
name|nm_buf_pool
argument_list|,
name|ring
operator|->
name|slot
index|[
name|j
index|]
operator|.
name|buf_idx
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"rx queue %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ring
operator|=
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
expr_stmt|;
name|lim
operator|=
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nkr_num_slots
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lim
condition|;
name|j
operator|++
control|)
name|netmap_free_buf
argument_list|(
operator|&
name|nm_buf_pool
argument_list|,
name|ring
operator|->
name|slot
index|[
name|j
index|]
operator|.
name|buf_idx
argument_list|)
expr_stmt|;
block|}
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
name|netmap_free
argument_list|(
name|na
operator|->
name|tx_rings
index|[
literal|0
index|]
operator|.
name|ring
argument_list|,
literal|"shadow rings"
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
name|netmap_free
argument_list|(
name|nifp
argument_list|,
literal|"nifp"
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX for safety */
name|free
argument_list|(
name|priv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create and return a new ``netmap_if`` object, and possibly also  * rings and packet buffors.  *  * Return NULL on failure.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|netmap_if_new
parameter_list|(
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|ofs
decl_stmt|;
name|u_int
name|n
init|=
name|na
operator|->
name|num_queues
operator|+
literal|1
decl_stmt|;
comment|/* shorthand, include stack queue */
comment|/* 	 * the descriptor is followed inline by an array of offsets 	 * to the tx and rx rings in the shared memory region. 	 */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_if
argument_list|)
operator|+
literal|2
operator|*
name|n
operator|*
sizeof|sizeof
argument_list|(
name|ssize_t
argument_list|)
expr_stmt|;
name|nifp
operator|=
name|netmap_malloc
argument_list|(
name|len
argument_list|,
literal|"nifp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* initialize base fields */
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|nifp
operator|->
name|ni_num_queues
operator|=
name|na
operator|->
name|num_queues
expr_stmt|;
name|strncpy
argument_list|(
name|nifp
operator|->
name|ni_name
argument_list|,
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
operator|(
name|na
operator|->
name|refcount
operator|)
operator|++
expr_stmt|;
comment|/* XXX atomic ? we are under lock */
if|if
condition|(
name|na
operator|->
name|refcount
operator|>
literal|1
condition|)
goto|goto
name|final
goto|;
comment|/* 	 * If this is the first instance, allocate the shadow rings and 	 * buffers for this card (one for each hw queue, one for the host). 	 * The rings are contiguous, but have variable size. 	 * The entire block is reachable at 	 *	na->tx_rings[0].ring 	 */
name|len
operator|=
name|n
operator|*
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_ring
argument_list|)
operator|+
operator|(
name|na
operator|->
name|num_tx_desc
operator|+
name|na
operator|->
name|num_rx_desc
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_slot
argument_list|)
operator|)
expr_stmt|;
name|buff
operator|=
name|netmap_malloc
argument_list|(
name|len
argument_list|,
literal|"shadow rings"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"failed to allocate %d bytes for %s shadow ring"
argument_list|,
name|len
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|error
label|:
operator|(
name|na
operator|->
name|refcount
operator|)
operator|--
expr_stmt|;
name|netmap_free
argument_list|(
name|nifp
argument_list|,
literal|"nifp, rings failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* do we have the bufers ? we are in need of num_tx_desc buffers for 	 * each tx ring and num_tx_desc buffers for each rx ring. */
name|len
operator|=
name|n
operator|*
operator|(
name|na
operator|->
name|num_tx_desc
operator|+
name|na
operator|->
name|num_rx_desc
operator|)
expr_stmt|;
name|NMA_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|nm_buf_pool
operator|.
name|free
operator|<
name|len
condition|)
block|{
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
name|netmap_free
argument_list|(
name|buff
argument_list|,
literal|"not enough bufs"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * in the kring, store the pointers to the shared rings 	 * and initialize the rings. We are under NMA_LOCK(). 	 */
name|ofs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|int
name|numdesc
decl_stmt|;
comment|/* Transmit rings */
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|numdesc
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|bzero
argument_list|(
name|kring
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kring
argument_list|)
argument_list|)
expr_stmt|;
name|kring
operator|->
name|na
operator|=
name|na
expr_stmt|;
name|ring
operator|=
name|kring
operator|->
name|ring
operator|=
operator|(
expr|struct
name|netmap_ring
operator|*
operator|)
operator|(
name|buff
operator|+
name|ofs
operator|)
expr_stmt|;
operator|*
operator|(
name|ssize_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|ring
operator|->
name|buf_ofs
operator|=
name|nm_buf_pool
operator|.
name|base
operator|-
operator|(
name|char
operator|*
operator|)
name|ring
expr_stmt|;
name|ND
argument_list|(
literal|"txring[%d] at %p ofs %d"
argument_list|,
name|i
argument_list|,
name|ring
argument_list|,
name|ring
operator|->
name|buf_ofs
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|int
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|ring
operator|->
name|num_slots
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|=
name|numdesc
expr_stmt|;
comment|/* 		 * IMPORTANT: 		 * Always keep one slot empty, so we can detect new 		 * transmissions comparing cur and nr_hwcur (they are 		 * the same only if there are no new transmissions). 		 */
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
operator|=
name|numdesc
operator|-
literal|1
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwcur
operator|=
literal|0
expr_stmt|;
name|netmap_new_bufs
argument_list|(
operator|&
name|nm_buf_pool
argument_list|,
name|ring
operator|->
name|slot
argument_list|,
name|numdesc
argument_list|)
expr_stmt|;
name|ofs
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_ring
argument_list|)
operator|+
name|numdesc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_slot
argument_list|)
expr_stmt|;
comment|/* Receive rings */
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|numdesc
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|bzero
argument_list|(
name|kring
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kring
argument_list|)
argument_list|)
expr_stmt|;
name|kring
operator|->
name|na
operator|=
name|na
expr_stmt|;
name|ring
operator|=
name|kring
operator|->
name|ring
operator|=
operator|(
expr|struct
name|netmap_ring
operator|*
operator|)
operator|(
name|buff
operator|+
name|ofs
operator|)
expr_stmt|;
operator|*
operator|(
name|ssize_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|ring
operator|->
name|buf_ofs
operator|=
name|nm_buf_pool
operator|.
name|base
operator|-
operator|(
name|char
operator|*
operator|)
name|ring
expr_stmt|;
name|ND
argument_list|(
literal|"rxring[%d] at %p offset %d"
argument_list|,
name|i
argument_list|,
name|ring
argument_list|,
name|ring
operator|->
name|buf_ofs
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|int
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|ring
operator|->
name|num_slots
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|=
name|numdesc
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwcur
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
operator|=
literal|0
expr_stmt|;
comment|/* empty */
name|netmap_new_bufs
argument_list|(
operator|&
name|nm_buf_pool
argument_list|,
name|ring
operator|->
name|slot
argument_list|,
name|numdesc
argument_list|)
expr_stmt|;
name|ofs
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_ring
argument_list|)
operator|+
name|numdesc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_slot
argument_list|)
expr_stmt|;
block|}
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|// XXX initialize the selrecord structs.
block|}
name|final
label|:
comment|/* 	 * fill the slots for the rx and tx queues. They contain the offset 	 * between the ring and nifp, so the information is usable in 	 * userspace to reach the ring from the nifp. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|base
init|=
operator|(
name|char
operator|*
operator|)
name|nifp
decl_stmt|;
operator|*
operator|(
name|ssize_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|nifp
operator|->
name|ring_ofs
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|ring
operator|-
name|base
expr_stmt|;
operator|*
operator|(
name|ssize_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|nifp
operator|->
name|ring_ofs
index|[
name|i
operator|+
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
operator|-
name|base
expr_stmt|;
block|}
return|return
operator|(
name|nifp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mmap(2) support for the "netmap" device.  *  * Expose all the memory previously allocated by our custom memory  * allocator: this way the user has only to issue a single mmap(2), and  * can work on all the data structures flawlessly.  *  * Return 0 on success, -1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|900000
name|netmap_mmap
parameter_list|(
name|__unused
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|)
else|#
directive|else
function|netmap_mmap
parameter_list|(
name|__unused
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|,
name|__unused
name|vm_memattr_t
modifier|*
name|memattr
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|// XXX -1 or EINVAL ?
name|ND
argument_list|(
literal|"request for offset 0x%x"
argument_list|,
operator|(
name|uint32_t
operator|)
name|offset
argument_list|)
expr_stmt|;
operator|*
name|paddr
operator|=
name|vtophys
argument_list|(
name|netmap_mem_d
operator|->
name|nm_buffer
argument_list|)
operator|+
name|offset
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * handler for synchronization of the queues from/to the host  */
end_comment

begin_function
specifier|static
name|void
name|netmap_sync_to_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|na
operator|->
name|num_queues
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|head
init|=
name|NULL
decl_stmt|,
modifier|*
name|tail
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|u_int
name|n
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|na
operator|->
name|ifp
operator|->
name|if_softc
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Take packets from hwcur to cur and pass them up. 	 * In case of no buffers we give up. At the end of the loop, 	 * the queue is drained in all cases. 	 */
for|for
control|(
name|n
operator|=
name|kring
operator|->
name|nr_hwcur
init|;
name|n
operator|!=
name|ring
operator|->
name|cur
condition|;
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|n
index|]
decl_stmt|;
name|n
operator|=
operator|(
name|n
operator|==
name|lim
operator|)
condition|?
literal|0
else|:
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|len
operator|<
literal|14
operator|||
name|slot
operator|->
name|len
operator|>
name|NETMAP_BUF_SIZE
condition|)
block|{
name|D
argument_list|(
literal|"bad pkt at %d len %d"
argument_list|,
name|n
argument_list|,
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m
operator|=
name|m_devget
argument_list|(
name|NMB
argument_list|(
name|slot
argument_list|)
argument_list|,
name|slot
operator|->
name|len
argument_list|,
literal|0
argument_list|,
name|na
operator|->
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|tail
condition|)
name|tail
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
else|else
name|head
operator|=
name|m
expr_stmt|;
name|tail
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwcur
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|=
name|ring
operator|->
name|avail
operator|=
name|lim
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|na
operator|->
name|ifp
operator|->
name|if_softc
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send packets up, outside the lock */
while|while
condition|(
operator|(
name|m
operator|=
name|head
operator|)
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
name|head
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|na
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"sending up pkt %p size %d"
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
call|(
name|na
operator|->
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This routine also does the selrecord if called from the poll handler  * (we know because td != NULL).  */
end_comment

begin_function
specifier|static
name|void
name|netmap_sync_from_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_queues
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|int
name|delta
decl_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|na
operator|->
name|ifp
operator|->
name|if_softc
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* skip past packets processed by userspace, 	 * and then sync cur/avail with hwcur/hwavail 	 */
name|delta
operator|=
name|ring
operator|->
name|cur
operator|-
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|-=
name|delta
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|avail
operator|==
literal|0
operator|&&
name|td
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|avail
operator|&&
operator|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
operator|)
condition|)
name|D
argument_list|(
literal|"%d pkts from stack"
argument_list|,
name|ring
operator|->
name|avail
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|na
operator|->
name|ifp
operator|->
name|if_softc
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a refcounted reference to an interface.  * Return ENXIO if the interface does not exist, EINVAL if netmap  * is not supported by the interface.  * If successful, hold a reference.  */
end_comment

begin_function
specifier|static
name|int
name|get_ifp
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ifnet
modifier|*
modifier|*
name|ifp
parameter_list|)
block|{
operator|*
name|ifp
operator|=
name|ifunit_ref
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* can do this if the capability exists and if_pspare[0] 	 * points to the netmap descriptor. 	 */
if|if
condition|(
operator|(
operator|*
name|ifp
operator|)
operator|->
name|if_capabilities
operator|&
name|IFCAP_NETMAP
operator|&&
name|NA
argument_list|(
operator|*
name|ifp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* valid pointer, we hold the refcount */
name|if_rele
argument_list|(
operator|*
name|ifp
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
comment|// not NETMAP capable
block|}
end_function

begin_comment
comment|/*  * Error routine called when txsync/rxsync detects an error.  * Can't do much more than resetting cur = hwcur, avail = hwavail.  * Return 1 on reinit.  */
end_comment

begin_function
name|int
name|netmap_ring_reinit
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|D
argument_list|(
literal|"called for %s"
argument_list|,
name|kring
operator|->
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|cur
operator|>
name|lim
condition|)
name|errors
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|idx
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
decl_stmt|;
name|u_int
name|len
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|2
operator|||
name|idx
operator|>=
name|netmap_total_buffers
condition|)
block|{
if|if
condition|(
operator|!
name|errors
operator|++
condition|)
name|D
argument_list|(
literal|"bad buffer at slot %d idx %d len %d "
argument_list|,
name|i
argument_list|,
name|idx
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
name|NETMAP_BUF_SIZE
condition|)
block|{
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|errors
operator|++
condition|)
name|D
argument_list|(
literal|"bad len %d at slot %d idx %d"
argument_list|,
name|len
argument_list|,
name|i
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errors
condition|)
block|{
name|int
name|pos
init|=
name|kring
operator|-
name|kring
operator|->
name|na
operator|->
name|tx_rings
decl_stmt|;
name|int
name|n
init|=
name|kring
operator|->
name|na
operator|->
name|num_queues
operator|+
literal|2
decl_stmt|;
name|D
argument_list|(
literal|"total %d errors"
argument_list|,
name|errors
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|D
argument_list|(
literal|"%s %s[%d] reinit, cur %d -> %d avail %d -> %d"
argument_list|,
name|kring
operator|->
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|pos
operator|<
name|n
condition|?
literal|"TX"
else|:
literal|"RX"
argument_list|,
name|pos
operator|<
name|n
condition|?
name|pos
else|:
name|pos
operator|-
name|n
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|ring
operator|->
name|avail
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
name|ring
operator|->
name|flags
operator||=
name|NR_REINIT
expr_stmt|;
name|kring
operator|->
name|na
operator|->
name|flags
operator||=
name|NR_REINIT
expr_stmt|;
block|}
return|return
operator|(
name|errors
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clean the reinit flag for our rings.  * XXX at the moment, clear for all rings  */
end_comment

begin_function
specifier|static
name|void
name|netmap_clean_reinit
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
comment|//struct netmap_kring *kring;
name|u_int
name|i
decl_stmt|;
name|na
operator|->
name|flags
operator|&=
operator|~
name|NR_REINIT
expr_stmt|;
name|D
argument_list|(
literal|"--- NR_REINIT reset on %s"
argument_list|,
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_queues
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|ring
operator|->
name|flags
operator|&=
operator|~
name|NR_REINIT
expr_stmt|;
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
operator|->
name|flags
operator|&=
operator|~
name|NR_REINIT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the ring ID. For devices with a single queue, a request  * for all rings is the same as a single ring.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_set_ringid
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|u_int
name|ringid
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|np_ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|void
modifier|*
name|adapter
init|=
name|na
operator|->
name|ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* shorthand */
name|u_int
name|i
init|=
name|ringid
operator|&
name|NETMAP_RING_MASK
decl_stmt|;
comment|/* first time we don't lock */
name|int
name|need_lock
init|=
operator|(
name|priv
operator|->
name|np_qfirst
operator|!=
name|priv
operator|->
name|np_qlast
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|ringid
operator|&
name|NETMAP_HW_RING
operator|)
operator|&&
name|i
operator|>=
name|na
operator|->
name|num_queues
condition|)
block|{
name|D
argument_list|(
literal|"invalid ring id %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|need_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|adapter
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_ringid
operator|=
name|ringid
expr_stmt|;
if|if
condition|(
name|ringid
operator|&
name|NETMAP_SW_RING
condition|)
block|{
name|priv
operator|->
name|np_qfirst
operator|=
name|na
operator|->
name|num_queues
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
name|na
operator|->
name|num_queues
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ringid
operator|&
name|NETMAP_HW_RING
condition|)
block|{
name|priv
operator|->
name|np_qfirst
operator|=
name|i
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|->
name|np_qfirst
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
name|na
operator|->
name|num_queues
expr_stmt|;
block|}
name|priv
operator|->
name|np_txpoll
operator|=
operator|(
name|ringid
operator|&
name|NETMAP_NO_TX_POLL
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|need_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|adapter
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ringid
operator|&
name|NETMAP_SW_RING
condition|)
name|D
argument_list|(
literal|"ringid %s set to SW RING"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ringid
operator|&
name|NETMAP_HW_RING
condition|)
name|D
argument_list|(
literal|"ringid %s set to HW RING %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|priv
operator|->
name|np_qfirst
argument_list|)
expr_stmt|;
else|else
name|D
argument_list|(
literal|"ringid %s set to all %d HW RINGS"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|priv
operator|->
name|np_qlast
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ioctl(2) support for the "netmap" device.  *  * Following a list of accepted commands:  * - NIOCGINFO  * - SIOCGIFADDR	just for convenience  * - NIOCREGIF  * - NIOCUNREGIF  * - NIOCTXSYNC  * - NIOCRXSYNC  *  * Return 0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_ioctl
parameter_list|(
name|__unused
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|__unused
name|int
name|fflag
parameter_list|,
name|__unused
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|nmreq
modifier|*
name|nmr
init|=
operator|(
expr|struct
name|nmreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|void
modifier|*
name|adapter
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
operator|&&
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Could be ENOENT */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NIOCGINFO
case|:
comment|/* return capabilities etc */
comment|/* memsize is always valid */
name|nmr
operator|->
name|nr_memsize
operator|=
name|netmap_mem_d
operator|->
name|nm_totalsize
expr_stmt|;
name|nmr
operator|->
name|nr_offset
operator|=
literal|0
expr_stmt|;
name|nmr
operator|->
name|nr_numrings
operator|=
literal|0
expr_stmt|;
name|nmr
operator|->
name|nr_numslots
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* just get memory info */
break|break;
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
comment|/* get a refcount */
if|if
condition|(
name|error
condition|)
break|break;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap_adapter */
name|nmr
operator|->
name|nr_numrings
operator|=
name|na
operator|->
name|num_queues
expr_stmt|;
name|nmr
operator|->
name|nr_numslots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
break|break;
case|case
name|NIOCREGIF
case|:
if|if
condition|(
name|priv
operator|!=
name|NULL
condition|)
comment|/* thread already registered */
return|return
name|netmap_set_ringid
argument_list|(
name|priv
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|)
return|;
comment|/* find the interface and a reference */
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
break|break;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
name|adapter
operator|=
name|na
operator|->
name|ifp
operator|->
name|if_softc
expr_stmt|;
comment|/* shorthand */
comment|/* 		 * Allocate the private per-thread structure. 		 * XXX perhaps we can use a blocking malloc ? 		 */
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_priv_d
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|10
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|na
operator|->
name|nm_lock
argument_list|(
name|adapter
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NETMAP_DELETING
argument_list|(
name|na
argument_list|)
condition|)
break|break;
name|na
operator|->
name|nm_lock
argument_list|(
name|adapter
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|na
argument_list|,
literal|0
argument_list|,
literal|"NIOCREGIF"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"too many NIOCREGIF attempts, give up"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|free
argument_list|(
name|priv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
break|break;
block|}
name|priv
operator|->
name|np_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* store the reference */
name|error
operator|=
name|netmap_set_ringid
argument_list|(
name|priv
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
name|priv
operator|->
name|np_nifp
operator|=
name|nifp
operator|=
name|netmap_if_new
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
block|{
comment|/* allocation failed */
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
comment|/* was already set */
block|}
else|else
block|{
comment|/* Otherwise set the card in netmap mode 			 * and make it use the shared buffers. 			 */
name|error
operator|=
name|na
operator|->
name|nm_register
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* mode on */
if|if
condition|(
name|error
condition|)
block|{
comment|/* 				 * do something similar to netmap_dtor(). 				 */
name|netmap_free
argument_list|(
name|na
operator|->
name|tx_rings
index|[
literal|0
index|]
operator|.
name|ring
argument_list|,
literal|"rings, reg.failed"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|na
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|na
operator|->
name|tx_rings
operator|=
name|na
operator|->
name|rx_rings
operator|=
name|NULL
expr_stmt|;
name|na
operator|->
name|refcount
operator|--
expr_stmt|;
name|netmap_free
argument_list|(
name|nifp
argument_list|,
literal|"nifp, rings failed"
argument_list|)
expr_stmt|;
name|nifp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* reg. failed, release priv and ref */
name|error
label|:
name|na
operator|->
name|nm_lock
argument_list|(
name|adapter
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|priv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
break|break;
block|}
name|na
operator|->
name|nm_lock
argument_list|(
name|adapter
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|devfs_set_cdevpriv
argument_list|(
name|priv
argument_list|,
name|netmap_dtor
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* could not assign the private storage for the 			 * thread, call the destructor explicitly. 			 */
name|netmap_dtor
argument_list|(
name|priv
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* return the offset of the netmap_if object */
name|nmr
operator|->
name|nr_numrings
operator|=
name|na
operator|->
name|num_queues
expr_stmt|;
name|nmr
operator|->
name|nr_numslots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_memsize
operator|=
name|netmap_mem_d
operator|->
name|nm_totalsize
expr_stmt|;
name|nmr
operator|->
name|nr_offset
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|nifp
operator|-
operator|(
name|char
operator|*
operator|)
name|netmap_mem_d
operator|->
name|nm_buffer
operator|)
expr_stmt|;
break|break;
case|case
name|NIOCUNREGIF
case|:
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* the interface is unregistered inside the 		   destructor of the private data. */
name|devfs_clear_cdevpriv
argument_list|()
expr_stmt|;
break|break;
case|case
name|NIOCTXSYNC
case|:
case|case
name|NIOCRXSYNC
case|:
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ifp
operator|=
name|priv
operator|->
name|np_ifp
expr_stmt|;
comment|/* we have a reference */
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
name|adapter
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
comment|/* shorthand */
if|if
condition|(
name|na
operator|->
name|flags
operator|&
name|NR_REINIT
condition|)
name|netmap_clean_reinit
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_qfirst
operator|==
name|na
operator|->
name|num_queues
condition|)
block|{
comment|/* queues to/from host */
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
name|netmap_sync_to_host
argument_list|(
name|na
argument_list|)
expr_stmt|;
else|else
name|netmap_sync_from_host
argument_list|(
name|na
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|priv
operator|->
name|np_qlast
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"sync tx ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_txsync
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
literal|1
comment|/* do lock */
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"after sync tx ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|na
operator|->
name|nm_rxsync
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
literal|1
comment|/* do lock */
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BIOCIMMEDIATE
case|:
case|case
name|BIOCGHDRCMPLT
case|:
case|case
name|BIOCSHDRCMPLT
case|:
case|case
name|BIOCSSEESENT
case|:
name|D
argument_list|(
literal|"ignore BIOCIMMEDIATE/BIOCSHDRCMPLT/BIOCSHDRCMPLT/BIOCSSEESENT"
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
comment|/* 		 * allow device calls 		 */
name|struct
name|socket
name|so
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|so
argument_list|,
sizeof|sizeof
argument_list|(
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
break|break;
name|so
operator|.
name|so_vnet
operator|=
name|ifp
operator|->
name|if_vnet
expr_stmt|;
comment|// so->so_proto not null.
name|error
operator|=
name|ifioctl
argument_list|(
operator|&
name|so
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * select(2) and poll(2) handlers for the "netmap" device.  *  * Can be called for one or more queues.  * Return true the event mask corresponding to ready events.  * If there are no ready events, do a selrecord on either individual  * selfd or on the global one.  * Device-dependent parts (locking and sync of tx/rx rings)  * are done through callbacks.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_poll
parameter_list|(
name|__unused
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|check_all
decl_stmt|,
name|want_tx
decl_stmt|,
name|want_rx
decl_stmt|,
name|revents
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|adapter
decl_stmt|;
if|if
condition|(
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
operator|!=
literal|0
operator|||
name|priv
operator|==
name|NULL
condition|)
return|return
name|POLLERR
return|;
name|ifp
operator|=
name|priv
operator|->
name|np_ifp
expr_stmt|;
comment|// XXX check for deleting() ?
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
operator|==
literal|0
condition|)
return|return
name|POLLERR
return|;
if|if
condition|(
name|netmap_verbose
operator|&
literal|0x8000
condition|)
name|D
argument_list|(
literal|"device %s events 0x%x"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|events
argument_list|)
expr_stmt|;
name|want_tx
operator|=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
name|want_rx
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
name|adapter
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
comment|/* pending reinit, report up as a poll error. Pending 	 * reads and writes are lost. 	 */
if|if
condition|(
name|na
operator|->
name|flags
operator|&
name|NR_REINIT
condition|)
block|{
name|netmap_clean_reinit
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|revents
operator||=
name|POLLERR
expr_stmt|;
block|}
comment|/* how many queues we are scanning */
name|i
operator|=
name|priv
operator|->
name|np_qfirst
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|na
operator|->
name|num_queues
condition|)
block|{
comment|/* from/to host */
if|if
condition|(
name|priv
operator|->
name|np_txpoll
operator|||
name|want_tx
condition|)
block|{
comment|/* push any packets up, then we are always ready */
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|netmap_sync_to_host
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|revents
operator||=
name|want_tx
expr_stmt|;
block|}
if|if
condition|(
name|want_rx
condition|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|==
literal|0
condition|)
name|netmap_sync_from_host
argument_list|(
name|na
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
block|}
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
comment|/* 	 * check_all is set if the card has more than one queue and 	 * the client is polling all of them. If true, we sleep on 	 * the "global" selfd, otherwise we sleep on individual selfd 	 * (we can only sleep on one of them per direction). 	 * The interrupt routine in the driver should always wake on 	 * the individual selfd, and also on the global one if the card 	 * has more than one ring. 	 * 	 * If the card has only one lock, we just use that. 	 * If the card has separate ring locks, we just use those 	 * unless we are doing check_all, in which case the whole 	 * loop is wrapped by the global lock. 	 * We acquire locks only when necessary: if poll is called 	 * when buffers are available, we can just return without locks. 	 * 	 * rxsync() is only called if we run out of buffers on a POLLIN. 	 * txsync() is called if we run out of buffers on POLLOUT, or 	 * there are pending packets to send. The latter can be disabled 	 * passing NETMAP_NO_TX_POLL in the NIOCREG call. 	 */
name|check_all
operator|=
operator|(
name|i
operator|+
literal|1
operator|!=
name|priv
operator|->
name|np_qlast
operator|)
expr_stmt|;
comment|/* 	 * core_lock indicates what to do with the core lock. 	 * The core lock is used when either the card has no individual 	 * locks, or it has individual locks but we are cheking all 	 * rings so we need the core lock to avoid missing wakeup events. 	 * 	 * It has three possible states: 	 * NO_CL	we don't need to use the core lock, e.g. 	 *		because we are protected by individual locks. 	 * NEED_CL	we need the core lock. In this case, when we 	 *		call the lock routine, move to LOCKED_CL 	 *		to remember to release the lock once done. 	 * LOCKED_CL	core lock is set, so we need to release it. 	 */
enum|enum
block|{
name|NO_CL
block|,
name|NEED_CL
block|,
name|LOCKED_CL
block|}
enum|;
name|int
name|core_lock
init|=
operator|(
name|check_all
operator|||
operator|!
name|na
operator|->
name|separate_locks
operator|)
condition|?
name|NEED_CL
else|:
name|NO_CL
decl_stmt|;
comment|/* 	 * We start with a lock free round which is good if we have 	 * data available. If this fails, then lock and call the sync 	 * routines. 	 */
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|want_rx
operator|&&
name|i
operator|<
name|priv
operator|->
name|np_qlast
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
name|want_rx
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|want_tx
operator|&&
name|i
operator|<
name|priv
operator|->
name|np_qlast
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
comment|/* 	 * If we to push packets out (priv->np_txpoll) or want_tx is 	 * still set, we do need to run the txsync calls (on all rings, 	 * to avoid that the tx rings stall). 	 */
if|if
condition|(
name|priv
operator|->
name|np_txpoll
operator|||
name|want_tx
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|priv
operator|->
name|np_qlast
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|want_tx
operator|&&
name|kring
operator|->
name|ring
operator|->
name|cur
operator|==
name|kring
operator|->
name|nr_hwcur
condition|)
continue|continue;
if|if
condition|(
name|core_lock
operator|==
name|NEED_CL
condition|)
block|{
name|na
operator|->
name|nm_lock
argument_list|(
name|adapter
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|core_lock
operator|=
name|LOCKED_CL
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|adapter
argument_list|,
name|NETMAP_TX_LOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"send %d on %s %d"
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_txsync
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
literal|0
comment|/* no lock */
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
if|if
condition|(
name|want_tx
condition|)
block|{
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
comment|/* stop at the first ring. We don't risk 					 * starvation. 					 */
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|check_all
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|adapter
argument_list|,
name|NETMAP_TX_UNLOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * now if want_rx is still set we need to lock and rxsync. 	 * Do it on all rings because otherwise we starve. 	 */
if|if
condition|(
name|want_rx
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|priv
operator|->
name|np_qlast
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|core_lock
operator|==
name|NEED_CL
condition|)
block|{
name|na
operator|->
name|nm_lock
argument_list|(
name|adapter
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|core_lock
operator|=
name|LOCKED_CL
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|adapter
argument_list|,
name|NETMAP_RX_LOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_rxsync
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
literal|0
comment|/* no lock */
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
if|if
condition|(
name|no_timestamp
operator|==
literal|0
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_TIMESTAMP
condition|)
name|microtime
argument_list|(
operator|&
name|kring
operator|->
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
name|revents
operator||=
name|want_rx
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|check_all
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|adapter
argument_list|,
name|NETMAP_RX_UNLOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|check_all
operator|&&
name|revents
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|na
operator|->
name|num_queues
operator|+
literal|1
expr_stmt|;
comment|/* the global queue */
if|if
condition|(
name|want_tx
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_rx
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|si
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|core_lock
operator|==
name|LOCKED_CL
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|adapter
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------- driver support routines ------*/
end_comment

begin_comment
comment|/*  * Initialize a ``netmap_adapter`` object created by driver on attach.  * We allocate a block of memory with room for a struct netmap_adapter  * plus two sets of N+2 struct netmap_kring (where N is the number  * of hardware rings):  * krings	0..N-1	are for the hardware queues.  * kring	N	is for the host stack queue  * kring	N+1	is only used for the selinfo for all queues.  * Return 0 on success, ENOMEM otherwise.  */
end_comment

begin_function
name|int
name|netmap_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|num_queues
parameter_list|)
block|{
name|int
name|n
init|=
name|num_queues
operator|+
literal|2
decl_stmt|;
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
operator|+
literal|2
operator|*
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_kring
argument_list|)
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"ifp not set, giving up"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|na
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
name|na
operator|->
name|num_queues
operator|=
name|num_queues
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
name|ifp
operator|->
name|if_pspare
index|[
literal|0
index|]
operator|=
name|buf
expr_stmt|;
name|na
operator|->
name|tx_rings
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
operator|)
expr_stmt|;
name|na
operator|->
name|rx_rings
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|n
expr_stmt|;
name|bcopy
argument_list|(
name|na
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_NETMAP
expr_stmt|;
block|}
name|D
argument_list|(
literal|"%s for %s"
argument_list|,
name|buf
condition|?
literal|"ok"
else|:
literal|"failed"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
condition|?
literal|0
else|:
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the allocated memory linked to the given ``netmap_adapter``  * object.  */
end_comment

begin_function
name|void
name|netmap_detach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|na
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_queues
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|knlist_destroy
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|si
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|si
operator|.
name|si_note
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|na
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_pspare
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|na
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * intercept packets coming from the network stack and present  * them to netmap as incoming packets on a separate ring.  * We are not locked when called.  */
end_comment

begin_function
name|int
name|netmap_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|n
init|=
name|na
operator|->
name|num_queues
decl_stmt|;
name|int
name|error
init|=
name|EBUSY
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|n
index|]
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"%s packet %d len %d from the stack"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwavail
operator|>=
operator|(
name|int
operator|)
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"stack ring %s full\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* no space */
block|}
if|if
condition|(
name|len
operator|>
name|na
operator|->
name|buff_size
condition|)
block|{
name|D
argument_list|(
literal|"drop packet size %d> %d"
argument_list|,
name|len
argument_list|,
name|na
operator|->
name|buff_size
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* too long for us */
block|}
comment|/* compute the insert position */
name|i
operator|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|kring
operator|->
name|nkr_num_slots
condition|)
name|i
operator|-=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|slot
operator|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|i
index|]
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|NMB
argument_list|(
name|slot
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|++
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"wake up host ring %s %d"
argument_list|,
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|na
operator|->
name|num_queues
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* release the mbuf in either cases of success or failure. As an 	 * alternative, put the mbuf in a free list and free the list 	 * only when really necessary. 	 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * netmap_reset() is called by the driver routines when reinitializing  * a ring. The driver is in charge of locking to protect the kring.  * If netmap mode is not set just return NULL.  * Otherwise set NR_REINIT (in the ring and in na) to signal  * that a ring has been reinitialized,  * set cur = hwcur = 0 and avail = hwavail = num_slots - 1 .  * IT IS IMPORTANT to leave one slot free even in the tx ring because  * we rely on cur=hwcur only for empty rings.  * These are good defaults but can be overridden later in the device  * specific code if, after a reinit, the ring does not start from 0  * (e.g. if_em.c does this).  *  * XXX we shouldn't be touching the ring, but there is a  * race anyways and this is our best option.  *  * XXX setting na->flags makes the syscall code faster, as there is  * only one place to check. On the other hand, we will need a better  * way to notify multiple threads that rings have been reset.  * One way is to increment na->rst_count at each ring reset.  * Each thread in its own priv structure will keep a matching counter,  * and on a reset will acknowledge and clean its own rings.  */
end_comment

begin_function
name|struct
name|netmap_slot
modifier|*
name|netmap_reset
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|enum
name|txrx
name|tx
parameter_list|,
name|int
name|n
parameter_list|,
name|u_int
name|new_cur
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* no netmap support here */
if|if
condition|(
operator|!
operator|(
name|na
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* nothing to reinitialize */
name|kring
operator|=
name|tx
operator|==
name|NR_TX
condition|?
name|na
operator|->
name|tx_rings
operator|+
name|n
else|:
name|na
operator|->
name|rx_rings
operator|+
name|n
expr_stmt|;
name|ring
operator|=
name|kring
operator|->
name|ring
expr_stmt|;
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
block|{
comment|/* 	 * The last argument is the new value of next_to_clean. 	 * 	 * In the TX ring, we have P pending transmissions (from 	 * next_to_clean to nr_hwcur) followed by nr_hwavail free slots. 	 * Generally we can use all the slots in the ring so 	 * P = ring_size - nr_hwavail hence (modulo ring_size): 	 *	next_to_clean == nr_hwcur + nr_hwavail 	 *  	 * If, upon a reset, nr_hwavail == ring_size and next_to_clean 	 * does not change we have nothing to report. Otherwise some 	 * pending packets may be lost, or newly injected packets will. 	 */
comment|/* if hwcur does not change, nothing to report. 	 * otherwise remember the change so perhaps we can 	 * shift the block at the next reinit 	 */
if|if
condition|(
name|new_cur
operator|==
name|kring
operator|->
name|nr_hwcur
operator|&&
name|kring
operator|->
name|nr_hwavail
operator|==
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
condition|)
block|{
comment|/* all ok */
name|D
argument_list|(
literal|"+++ NR_REINIT ok on %s TX[%d]"
argument_list|,
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|D
argument_list|(
literal|"+++ NR_REINIT set on %s TX[%d]"
argument_list|,
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|ring
operator|->
name|flags
operator||=
name|NR_REINIT
expr_stmt|;
name|na
operator|->
name|flags
operator||=
name|NR_REINIT
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwcur
operator|=
name|new_cur
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * The last argument is the next free slot. 	 * In the RX ring we have nr_hwavail full buffers starting 	 * from nr_hwcur. 	 * If nr_hwavail == 0 and nr_hwcur does not change we are ok 	 * otherwise we might be in trouble as the buffers are 	 * changing. 	 */
if|if
condition|(
name|new_cur
operator|==
name|kring
operator|->
name|nr_hwcur
operator|&&
name|kring
operator|->
name|nr_hwavail
operator|==
literal|0
condition|)
block|{
comment|/* all ok */
name|D
argument_list|(
literal|"+++ NR_REINIT ok on %s RX[%d]"
argument_list|,
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|D
argument_list|(
literal|"+++ NR_REINIT set on %s RX[%d]"
argument_list|,
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|ring
operator|->
name|flags
operator||=
name|NR_REINIT
expr_stmt|;
name|na
operator|->
name|flags
operator||=
name|NR_REINIT
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
operator|=
literal|0
expr_stmt|;
comment|/* no data */
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwcur
operator|=
name|new_cur
expr_stmt|;
block|}
name|slot
operator|=
name|ring
operator|->
name|slot
expr_stmt|;
comment|/* 	 * Check that buffer indexes are correct. If we find a 	 * bogus value we are a bit in trouble because we cannot 	 * recover easily. Best we can do is (probably) persistently 	 * reset the ring. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|kring
operator|->
name|nkr_num_slots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
operator|>=
name|netmap_total_buffers
condition|)
block|{
name|D
argument_list|(
literal|"invalid buf_idx %d at slot %d"
argument_list|,
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
operator|=
literal|0
expr_stmt|;
comment|/* XXX reset */
block|}
comment|/* XXX we don't really need to set the length */
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* wakeup possible waiters, both on the ring and on the global 	 * selfd. Perhaps a bit early now but the device specific 	 * routine is locked so hopefully we won't have a race. 	 */
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|kring
index|[
name|na
operator|->
name|num_queues
operator|+
literal|1
operator|-
name|n
index|]
operator|.
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
return|return
name|kring
operator|->
name|ring
operator|->
name|slot
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ns_dmamap_cb
parameter_list|(
name|__unused
name|void
modifier|*
name|arg
parameter_list|,
name|__unused
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|__unused
name|int
name|nseg
parameter_list|,
name|__unused
name|int
name|error
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* unload a bus_dmamap and create a new one. Used when the  * buffer in the slot is changed.  * XXX buflen is probably not needed, buffers have constant size.  */
end_comment

begin_function
name|void
name|netmap_reload_map
parameter_list|(
name|bus_dma_tag_t
name|tag
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|bus_size_t
name|buflen
parameter_list|)
block|{
name|bus_addr_t
name|paddr
decl_stmt|;
name|bus_dmamap_unload
argument_list|(
name|tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|tag
argument_list|,
name|map
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|ns_dmamap_cb
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|netmap_load_map
parameter_list|(
name|bus_dma_tag_t
name|tag
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|bus_size_t
name|buflen
parameter_list|)
block|{
name|bus_addr_t
name|paddr
decl_stmt|;
name|bus_dmamap_load
argument_list|(
name|tag
argument_list|,
name|map
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|ns_dmamap_cb
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------ netmap memory allocator -------*/
end_comment

begin_comment
comment|/*  * Request for a chunk of memory.  *  * Memory objects are arranged into a list, hence we need to walk this  * list until we find an object with the needed amount of data free.   * This sounds like a completely inefficient implementation, but given  * the fact that data allocation is done once, we can handle it  * flawlessly.  *  * Return NULL on failure.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|netmap_malloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|__unused
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|netmap_mem_obj
modifier|*
name|mem_obj
decl_stmt|,
modifier|*
name|new_mem_obj
decl_stmt|;
name|void
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|NMA_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|mem_obj
argument_list|,
argument|&netmap_mem_d->nm_molist
argument_list|,
argument|nmo_next
argument_list|)
block|{
if|if
condition|(
name|mem_obj
operator|->
name|nmo_used
operator|!=
literal|0
operator|||
name|mem_obj
operator|->
name|nmo_size
operator|<
name|size
condition|)
continue|continue;
name|new_mem_obj
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_mem_obj
argument_list|)
argument_list|,
name|M_NETMAP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|mem_obj
argument_list|,
name|new_mem_obj
argument_list|,
name|nmo_next
argument_list|)
expr_stmt|;
name|new_mem_obj
operator|->
name|nmo_used
operator|=
literal|1
expr_stmt|;
name|new_mem_obj
operator|->
name|nmo_size
operator|=
name|size
expr_stmt|;
name|new_mem_obj
operator|->
name|nmo_data
operator|=
name|mem_obj
operator|->
name|nmo_data
expr_stmt|;
name|memset
argument_list|(
name|new_mem_obj
operator|->
name|nmo_data
argument_list|,
literal|0
argument_list|,
name|new_mem_obj
operator|->
name|nmo_size
argument_list|)
expr_stmt|;
name|mem_obj
operator|->
name|nmo_size
operator|-=
name|size
expr_stmt|;
name|mem_obj
operator|->
name|nmo_data
operator|=
operator|(
name|char
operator|*
operator|)
name|mem_obj
operator|->
name|nmo_data
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|mem_obj
operator|->
name|nmo_size
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|netmap_mem_d
operator|->
name|nm_molist
argument_list|,
name|mem_obj
argument_list|,
name|nmo_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mem_obj
argument_list|,
name|M_NETMAP
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|new_mem_obj
operator|->
name|nmo_data
expr_stmt|;
break|break;
block|}
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
name|ND
argument_list|(
literal|"%s: %d bytes at %p"
argument_list|,
name|msg
argument_list|,
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the memory to the allocator.  *  * While freeing a memory object, we try to merge adjacent chunks in  * order to reduce memory fragmentation.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_free
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|struct
name|netmap_mem_obj
modifier|*
name|cur
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"NULL addr for %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|NMA_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cur
argument_list|,
argument|&netmap_mem_d->nm_molist
argument_list|,
argument|nmo_next
argument_list|)
block|{
if|if
condition|(
name|cur
operator|->
name|nmo_data
operator|==
name|addr
operator|&&
name|cur
operator|->
name|nmo_used
condition|)
break|break;
block|}
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
name|D
argument_list|(
literal|"invalid addr %s %p"
argument_list|,
name|msg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return;
block|}
name|size
operator|=
name|cur
operator|->
name|nmo_size
expr_stmt|;
name|cur
operator|->
name|nmo_used
operator|=
literal|0
expr_stmt|;
comment|/* merge current chunk of memory with the previous one, 	   if present. */
name|prev
operator|=
name|TAILQ_PREV
argument_list|(
name|cur
argument_list|,
name|netmap_mem_obj_h
argument_list|,
name|nmo_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|&&
name|prev
operator|->
name|nmo_used
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|netmap_mem_d
operator|->
name|nm_molist
argument_list|,
name|cur
argument_list|,
name|nmo_next
argument_list|)
expr_stmt|;
name|prev
operator|->
name|nmo_size
operator|+=
name|cur
operator|->
name|nmo_size
expr_stmt|;
name|free
argument_list|(
name|cur
argument_list|,
name|M_NETMAP
argument_list|)
expr_stmt|;
name|cur
operator|=
name|prev
expr_stmt|;
block|}
comment|/* merge with the next one */
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|cur
argument_list|,
name|nmo_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|next
operator|->
name|nmo_used
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|netmap_mem_d
operator|->
name|nm_molist
argument_list|,
name|next
argument_list|,
name|nmo_next
argument_list|)
expr_stmt|;
name|cur
operator|->
name|nmo_size
operator|+=
name|next
operator|->
name|nmo_size
expr_stmt|;
name|free
argument_list|(
name|next
argument_list|,
name|M_NETMAP
argument_list|)
expr_stmt|;
block|}
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
name|ND
argument_list|(
literal|"freed %s %d bytes at %p"
argument_list|,
name|msg
argument_list|,
name|size
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the memory allocator.  *  * Create the descriptor for the memory , allocate the pool of memory  * and initialize the list of memory objects with a single chunk  * containing the whole pre-allocated memory marked as free.  *  * Start with a large size, then halve as needed if we fail to  * allocate the block. While halving, always add one extra page  * because buffers 0 and 1 are used for special purposes.  * Return 0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_memory_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|netmap_mem_obj
modifier|*
name|mem_obj
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|sz
init|=
name|NETMAP_MEMORY_SIZE
decl_stmt|;
name|int
name|extra_sz
init|=
literal|0
decl_stmt|;
comment|// space for rings and two spare buffers
for|for
control|(
init|;
operator|!
name|buf
operator|&&
name|sz
operator|>=
literal|1
operator|<<
literal|20
condition|;
name|sz
operator|>>=
literal|1
control|)
block|{
name|extra_sz
operator|=
name|sz
operator|/
literal|200
expr_stmt|;
name|extra_sz
operator|=
operator|(
name|extra_sz
operator|+
literal|2
operator|*
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|buf
operator|=
name|contigmalloc
argument_list|(
name|sz
operator|+
name|extra_sz
argument_list|,
name|M_NETMAP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|,
literal|0
argument_list|,
comment|/* low address */
operator|-
literal|1UL
argument_list|,
comment|/* high address */
name|PAGE_SIZE
argument_list|,
comment|/* alignment */
literal|0
comment|/* boundary */
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sz
operator|+=
name|extra_sz
expr_stmt|;
name|netmap_mem_d
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_mem_d
argument_list|)
argument_list|,
name|M_NETMAP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|netmap_mem_d
operator|->
name|nm_mtx
argument_list|,
literal|"netmap memory allocator lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|netmap_mem_d
operator|->
name|nm_molist
argument_list|)
expr_stmt|;
name|netmap_mem_d
operator|->
name|nm_buffer
operator|=
name|buf
expr_stmt|;
name|netmap_mem_d
operator|->
name|nm_totalsize
operator|=
name|sz
expr_stmt|;
comment|/* 	 * A buffer takes 2k, a slot takes 8 bytes + ring overhead, 	 * so the ratio is 200:1. In other words, we can use 1/200 of 	 * the memory for the rings, and the rest for the buffers, 	 * and be sure we never run out. 	 */
name|netmap_mem_d
operator|->
name|nm_size
operator|=
name|sz
operator|/
literal|200
expr_stmt|;
name|netmap_mem_d
operator|->
name|nm_buf_start
operator|=
operator|(
name|netmap_mem_d
operator|->
name|nm_size
operator|+
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|netmap_mem_d
operator|->
name|nm_buf_len
operator|=
name|sz
operator|-
name|netmap_mem_d
operator|->
name|nm_buf_start
expr_stmt|;
name|nm_buf_pool
operator|.
name|base
operator|=
name|netmap_mem_d
operator|->
name|nm_buffer
expr_stmt|;
name|nm_buf_pool
operator|.
name|base
operator|+=
name|netmap_mem_d
operator|->
name|nm_buf_start
expr_stmt|;
name|netmap_buffer_base
operator|=
name|nm_buf_pool
operator|.
name|base
expr_stmt|;
name|D
argument_list|(
literal|"netmap_buffer_base %p (offset %d)"
argument_list|,
name|netmap_buffer_base
argument_list|,
name|netmap_mem_d
operator|->
name|nm_buf_start
argument_list|)
expr_stmt|;
comment|/* number of buffers, they all start as free */
name|netmap_total_buffers
operator|=
name|nm_buf_pool
operator|.
name|total_buffers
operator|=
name|netmap_mem_d
operator|->
name|nm_buf_len
operator|/
name|NETMAP_BUF_SIZE
expr_stmt|;
name|nm_buf_pool
operator|.
name|bufsize
operator|=
name|NETMAP_BUF_SIZE
expr_stmt|;
name|D
argument_list|(
literal|"Have %d MB, use %dKB for rings, %d buffers at %p"
argument_list|,
operator|(
name|sz
operator|>>
literal|20
operator|)
argument_list|,
operator|(
name|netmap_mem_d
operator|->
name|nm_size
operator|>>
literal|10
operator|)
argument_list|,
name|nm_buf_pool
operator|.
name|total_buffers
argument_list|,
name|nm_buf_pool
operator|.
name|base
argument_list|)
expr_stmt|;
comment|/* allocate and initialize the bitmap. Entry 0 is considered 	 * always busy (used as default when there are no buffers left). 	 */
name|n
operator|=
operator|(
name|nm_buf_pool
operator|.
name|total_buffers
operator|+
literal|31
operator|)
operator|/
literal|32
expr_stmt|;
name|nm_buf_pool
operator|.
name|bitmap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|n
argument_list|,
name|M_NETMAP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|nm_buf_pool
operator|.
name|bitmap
index|[
literal|0
index|]
operator|=
operator|~
literal|3
expr_stmt|;
comment|/* slot 0 and 1 always busy */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|nm_buf_pool
operator|.
name|bitmap
index|[
name|i
index|]
operator|=
operator|~
literal|0
expr_stmt|;
name|nm_buf_pool
operator|.
name|free
operator|=
name|nm_buf_pool
operator|.
name|total_buffers
operator|-
literal|2
expr_stmt|;
name|mem_obj
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_mem_obj
argument_list|)
argument_list|,
name|M_NETMAP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|netmap_mem_d
operator|->
name|nm_molist
argument_list|,
name|mem_obj
argument_list|,
name|nmo_next
argument_list|)
expr_stmt|;
name|mem_obj
operator|->
name|nmo_used
operator|=
literal|0
expr_stmt|;
name|mem_obj
operator|->
name|nmo_size
operator|=
name|netmap_mem_d
operator|->
name|nm_size
expr_stmt|;
name|mem_obj
operator|->
name|nmo_data
operator|=
name|netmap_mem_d
operator|->
name|nm_buffer
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finalize the memory allocator.  *  * Free all the memory objects contained inside the list, and deallocate  * the pool of memory; finally free the memory allocator descriptor.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_memory_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|netmap_mem_obj
modifier|*
name|mem_obj
decl_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|netmap_mem_d
operator|->
name|nm_molist
argument_list|)
condition|)
block|{
name|mem_obj
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|netmap_mem_d
operator|->
name|nm_molist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|netmap_mem_d
operator|->
name|nm_molist
argument_list|,
name|mem_obj
argument_list|,
name|nmo_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_obj
operator|->
name|nmo_used
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"netmap: leaked %d bytes at %p\n"
argument_list|,
name|mem_obj
operator|->
name|nmo_size
argument_list|,
name|mem_obj
operator|->
name|nmo_data
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mem_obj
argument_list|,
name|M_NETMAP
argument_list|)
expr_stmt|;
block|}
name|contigfree
argument_list|(
name|netmap_mem_d
operator|->
name|nm_buffer
argument_list|,
name|netmap_mem_d
operator|->
name|nm_totalsize
argument_list|,
name|M_NETMAP
argument_list|)
expr_stmt|;
comment|// XXX mutex_destroy(nm_mtx);
name|free
argument_list|(
name|netmap_mem_d
argument_list|,
name|M_NETMAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Module loader.  *  * Create the /dev/netmap device and initialize all global  * variables.  *  * Return 0 on success, errno on failure.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|netmap_memory_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"netmap: unable to initialize the memory allocator."
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"netmap: loaded module with %d Mbytes\n"
argument_list|,
name|netmap_mem_d
operator|->
name|nm_totalsize
operator|>>
literal|20
argument_list|)
expr_stmt|;
name|netmap_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|netmap_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0660
argument_list|,
literal|"netmap"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Module unloader.  *  * Free all the memory, and destroy the ``/dev/netmap`` device.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|destroy_dev
argument_list|(
name|netmap_dev
argument_list|)
expr_stmt|;
name|netmap_memory_fini
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"netmap: unloaded module.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Kernel entry point.  *  * Initialize/finalize the module and return.  *  * Return 0 on success, errno on failure.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_loader
parameter_list|(
name|__unused
name|struct
name|module
modifier|*
name|module
parameter_list|,
name|int
name|event
parameter_list|,
name|__unused
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
name|netmap_init
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|netmap_fini
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|netmap
argument_list|,
name|netmap_loader
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

