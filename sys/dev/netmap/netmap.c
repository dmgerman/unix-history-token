begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011-2014 Matteo Landi, Luigi Rizzo. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  *  * This module supports memory mapped access to network devices,  * see netmap(4).  *  * The module uses a large, memory pool allocated by the kernel  * and accessible as mmapped memory by multiple userspace threads/processes.  * The memory pool contains packet buffers and "netmap rings",  * i.e. user-accessible copies of the interface's queues.  *  * Access to the network card works like this:  * 1. a process/thread issues one or more open() on /dev/netmap, to create  *    select()able file descriptor on which events are reported.  * 2. on each descriptor, the process issues an ioctl() to identify  *    the interface that should report events to the file descriptor.  * 3. on each descriptor, the process issues an mmap() request to  *    map the shared memory region within the process' address space.  *    The list of interesting queues is indicated by a location in  *    the shared memory region.  * 4. using the functions in the netmap(4) userspace API, a process  *    can look up the occupation state of a queue, access memory buffers,  *    and retrieve received packets or enqueue packets to transmit.  * 5. using some ioctl()s the process can synchronize the userspace view  *    of the queue with the actual status in the kernel. This includes both  *    receiving the notification of new packets, and transmitting new  *    packets on the output interface.  * 6. select() or poll() can be used to wait for events on individual  *    transmit or receive queues (or all queues for a given interface).  *  		SYNCHRONIZATION (USER)  The netmap rings and data structures may be shared among multiple user threads or even independent processes. Any synchronization among those threads/processes is delegated to the threads themselves. Only one thread at a time can be in a system call on the same netmap ring. The OS does not enforce this and only guarantees against system crashes in case of invalid usage.  		LOCKING (INTERNAL)  Within the kernel, access to the netmap rings is protected as follows:  - a spinlock on each ring, to handle producer/consumer races on   RX rings attached to the host stack (against multiple host   threads writing from the host stack to the same ring),   and on 'destination' rings attached to a VALE switch   (i.e. RX rings in VALE ports, and TX rings in NIC/host ports)   protecting multiple active senders for the same destination)  - an atomic variable to guarantee that there is at most one   instance of *_*xsync() on the ring at any time.   For rings connected to user file   descriptors, an atomic_test_and_set() protects this, and the   lock on the ring is not actually used.   For NIC RX rings connected to a VALE switch, an atomic_test_and_set()   is also used to prevent multiple executions (the driver might indeed   already guarantee this).   For NIC TX rings connected to a VALE switch, the lock arbitrates   access to the queue (both when allocating buffers and when pushing   them out).  - *xsync() should be protected against initializations of the card.   On FreeBSD most devices have the reset routine protected by   a RING lock (ixgbe, igb, em) or core lock (re). lem is missing   the RING protection on rx_reset(), this should be added.    On linux there is an external lock on the tx path, which probably   also arbitrates access to the reset routine. XXX to be revised  - a per-interface core_lock protecting access from the host stack   while interfaces may be detached from netmap mode.   XXX there should be no need for this lock if we detach the interfaces   only while they are down.   --- VALE SWITCH ---  NMG_LOCK() serializes all modifications to switches and ports. A switch cannot be deleted until all ports are gone.  For each switch, an SX lock (RWlock on linux) protects deletion of ports. When configuring or deleting a new port, the lock is acquired in exclusive mode (after holding NMG_LOCK). When forwarding, the lock is acquired in shared mode (without NMG_LOCK). The lock is held throughout the entire forwarding cycle, during which the thread may incur in a page fault. Hence it is important that sleepable shared locks are used.  On the rx ring, the per-port lock is grabbed initially to reserve a number of slot in the ring, then the lock is released, packets are copied from source to destination, and then the lock is acquired again and the receive ring is updated. (A similar thing is done on the tx ring for NIC and host stack ports attached to the switch)   */
end_comment

begin_comment
comment|/* --- internals ----  *  * Roadmap to the code that implements the above.  *  *> 1. a process/thread issues one or more open() on /dev/netmap, to create  *>    select()able file descriptor on which events are reported.  *  *  	Internally, we allocate a netmap_priv_d structure, that will be  *  	initialized on ioctl(NIOCREGIF).  *  *      os-specific:  *  	    FreeBSD: netmap_open (netmap_freebsd.c). The priv is  *  		     per-thread.  *  	    linux:   linux_netmap_open (netmap_linux.c). The priv is  *  		     per-open.  *  *> 2. on each descriptor, the process issues an ioctl() to identify  *>    the interface that should report events to the file descriptor.  *  * 	Implemented by netmap_ioctl(), NIOCREGIF case, with nmr->nr_cmd==0.  * 	Most important things happen in netmap_get_na() and  * 	netmap_do_regif(), called from there. Additional details can be  * 	found in the comments above those functions.  *  * 	In all cases, this action creates/takes-a-reference-to a  * 	netmap_*_adapter describing the port, and allocates a netmap_if  * 	and all necessary netmap rings, filling them with netmap buffers.  *  *      In this phase, the sync callbacks for each ring are set (these are used  *      in steps 5 and 6 below).  The callbacks depend on the type of adapter.  *      The adapter creation/initialization code puts them in the  * 	netmap_adapter (fields na->nm_txsync and na->nm_rxsync).  Then, they  * 	are copied from there to the netmap_kring's during netmap_do_regif(), by  * 	the nm_krings_create() callback.  All the nm_krings_create callbacks  * 	actually call netmap_krings_create() to perform this and the other  * 	common stuff. netmap_krings_create() also takes care of the host rings,  * 	if needed, by setting their sync callbacks appropriately.  *  * 	Additional actions depend on the kind of netmap_adapter that has been  * 	registered:  *  * 	- netmap_hw_adapter:  	     [netmap.c]  * 	     This is a system netdev/ifp with native netmap support.  * 	     The ifp is detached from the host stack by redirecting:  * 	       - transmissions (from the network stack) to netmap_transmit()  * 	       - receive notifications to the nm_notify() callback for  * 	         this adapter. The callback is normally netmap_notify(), unless  * 	         the ifp is attached to a bridge using bwrap, in which case it  * 	         is netmap_bwrap_intr_notify().  *  * 	- netmap_generic_adapter:      [netmap_generic.c]  * 	      A system netdev/ifp without native netmap support.  *  * 	(the decision about native/non native support is taken in  * 	 netmap_get_hw_na(), called by netmap_get_na())  *  * 	- netmap_vp_adapter 		[netmap_vale.c]  * 	      Returned by netmap_get_bdg_na().  * 	      This is a persistent or ephemeral VALE port. Ephemeral ports  * 	      are created on the fly if they don't already exist, and are  * 	      always attached to a bridge.  * 	      Persistent VALE ports must must be created seperately, and i  * 	      then attached like normal NICs. The NIOCREGIF we are examining  * 	      will find them only if they had previosly been created and  * 	      attached (see VALE_CTL below).  *  * 	- netmap_pipe_adapter 	      [netmap_pipe.c]  * 	      Returned by netmap_get_pipe_na().  * 	      Both pipe ends are created, if they didn't already exist.  *  * 	- netmap_monitor_adapter      [netmap_monitor.c]  * 	      Returned by netmap_get_monitor_na().  * 	      If successful, the nm_sync callbacks of the monitored adapter  * 	      will be intercepted by the returned monitor.  *  * 	- netmap_bwrap_adapter	      [netmap_vale.c]  * 	      Cannot be obtained in this way, see VALE_CTL below  *  *  * 	os-specific:  * 	    linux: we first go through linux_netmap_ioctl() to  * 	           adapt the FreeBSD interface to the linux one.  *  *  *> 3. on each descriptor, the process issues an mmap() request to  *>    map the shared memory region within the process' address space.  *>    The list of interesting queues is indicated by a location in  *>    the shared memory region.  *  *      os-specific:  *  	    FreeBSD: netmap_mmap_single (netmap_freebsd.c).  *  	    linux:   linux_netmap_mmap (netmap_linux.c).  *  *> 4. using the functions in the netmap(4) userspace API, a process  *>    can look up the occupation state of a queue, access memory buffers,  *>    and retrieve received packets or enqueue packets to transmit.  *  * 	these actions do not involve the kernel.  *  *> 5. using some ioctl()s the process can synchronize the userspace view  *>    of the queue with the actual status in the kernel. This includes both  *>    receiving the notification of new packets, and transmitting new  *>    packets on the output interface.  *  * 	These are implemented in netmap_ioctl(), NIOCTXSYNC and NIOCRXSYNC  * 	cases. They invoke the nm_sync callbacks on the netmap_kring  * 	structures, as initialized in step 2 and maybe later modified  * 	by a monitor. Monitors, however, will always call the original  * 	callback before doing anything else.  *  *  *> 6. select() or poll() can be used to wait for events on individual  *>    transmit or receive queues (or all queues for a given interface).  *  * 	Implemented in netmap_poll(). This will call the same nm_sync()  * 	callbacks as in step 5 above.  *  * 	os-specific:  * 		linux: we first go through linux_netmap_poll() to adapt  * 		       the FreeBSD interface to the linux one.  *  *  *  ----  VALE_CTL -----  *  *  VALE switches are controlled by issuing a NIOCREGIF with a non-null  *  nr_cmd in the nmreq structure. These subcommands are handled by  *  netmap_bdg_ctl() in netmap_vale.c. Persistent VALE ports are created  *  and destroyed by issuing the NETMAP_BDG_NEWIF and NETMAP_BDG_DELIF  *  subcommands, respectively.  *  *  Any network interface known to the system (including a persistent VALE  *  port) can be attached to a VALE switch by issuing the  *  NETMAP_BDG_ATTACH subcommand. After the attachment, persistent VALE ports  *  look exactly like ephemeral VALE ports (as created in step 2 above).  The  *  attachment of other interfaces, instead, requires the creation of a  *  netmap_bwrap_adapter.  Moreover, the attached interface must be put in  *  netmap mode. This may require the creation of a netmap_generic_adapter if  *  we have no native support for the interface, or if generic adapters have  *  been forced by sysctl.  *  *  Both persistent VALE ports and bwraps are handled by netmap_get_bdg_na(),  *  called by nm_bdg_ctl_attach(), and discriminated by the nm_bdg_attach()  *  callback.  In the case of the bwrap, the callback creates the  *  netmap_bwrap_adapter.  The initialization of the bwrap is then  *  completed by calling netmap_do_regif() on it, in the nm_bdg_ctl()  *  callback (netmap_bwrap_bdg_ctl in netmap_vale.c).  *  A generic adapter for the wrapped ifp will be created if needed, when  *  netmap_get_bdg_na() calls netmap_get_hw_na().  *  *  *  ---- DATAPATHS -----  *  *              -= SYSTEM DEVICE WITH NATIVE SUPPORT =-  *  *    na == NA(ifp) == netmap_hw_adapter created in DEVICE_netmap_attach()  *  *    - tx from netmap userspace:  *	 concurrently:  *           1) ioctl(NIOCTXSYNC)/netmap_poll() in process context  *                kring->nm_sync() == DEVICE_netmap_txsync()  *           2) device interrupt handler  *                na->nm_notify()  == netmap_notify()  *    - rx from netmap userspace:  *       concurrently:  *           1) ioctl(NIOCRXSYNC)/netmap_poll() in process context  *                kring->nm_sync() == DEVICE_netmap_rxsync()  *           2) device interrupt handler  *                na->nm_notify()  == netmap_notify()  *    - tx from host stack  *       concurrently:  *           1) host stack  *                netmap_transmit()  *                  na->nm_notify  == netmap_notify()  *           2) ioctl(NIOCRXSYNC)/netmap_poll() in process context  *                kring->nm_sync() == netmap_rxsync_from_host_compat  *                  netmap_rxsync_from_host(na, NULL, NULL)  *    - tx to host stack  *           ioctl(NIOCTXSYNC)/netmap_poll() in process context  *             kring->nm_sync() == netmap_txsync_to_host_compat  *               netmap_txsync_to_host(na)  *                 NM_SEND_UP()  *                   FreeBSD: na->if_input() == ?? XXX  *                   linux: netif_rx() with NM_MAGIC_PRIORITY_RX  *  *  *  *               -= SYSTEM DEVICE WITH GENERIC SUPPORT =-  *  *  *  *                           -= VALE PORT =-  *  *  *  *                           -= NETMAP PIPE =-  *  *  *  *  -= SYSTEM DEVICE WITH NATIVE SUPPORT, CONNECTED TO VALE, NO HOST RINGS =-  *  *  *  *  -= SYSTEM DEVICE WITH NATIVE SUPPORT, CONNECTED TO VALE, WITH HOST RINGS =-  *  *  *  *  -= SYSTEM DEVICE WITH GENERIC SUPPORT, CONNECTED TO VALE, NO HOST RINGS =-  *  *  *  *  -= SYSTEM DEVICE WITH GENERIC SUPPORT, CONNECTED TO VALE, WITH HOST RINGS =-  *  *  *  */
end_comment

begin_comment
comment|/*  * OS-specific code that is used only within this file.  * Other OS-specific code that must be accessed by drivers  * is present in netmap_kern.h  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* defines used in kernel.h */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* types used in module initialization */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_comment
comment|/* cdevsw struct, UID, GID */
end_comment

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_comment
comment|/* FIONBIO */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_comment
comment|/* struct socket */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/* BIOCIMMEDIATE */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* */
end_comment

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_comment
comment|/* reduce conditional code */
end_comment

begin_comment
comment|// linux API, use for the knlist in FreeBSD
end_comment

begin_define
define|#
directive|define
name|init_waitqueue_head
parameter_list|(
name|x
parameter_list|)
value|knlist_init_mtx(&(x)->si_note, NULL)
end_define

begin_function_decl
name|void
name|freebsd_selwakeup
parameter_list|(
name|struct
name|selinfo
modifier|*
name|si
parameter_list|,
name|int
name|pri
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|OS_selwakeup
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|freebsd_selwakeup(a, b)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|linux
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"bsd_glue.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_elif

begin_warning
warning|#
directive|warning
warning|OSX support is only partial
end_warning

begin_include
include|#
directive|include
file|"osx_glue.h"
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|Unsupported platform
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unsupported */
end_comment

begin_comment
comment|/*  * common headers  */
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_mem2.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETMAP
argument_list|,
literal|"netmap"
argument_list|,
literal|"Network memory map"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The following variables are used by the drivers and replicate  * fields in the global memory pool. They only refer to buffers  * used by physical interfaces.  */
end_comment

begin_decl_stmt
name|u_int
name|netmap_total_buffers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|netmap_buf_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|netmap_buffer_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* also address of an invalid buffer */
end_comment

begin_comment
comment|/* user-controlled variables */
end_comment

begin_decl_stmt
name|int
name|netmap_verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|netmap_no_timestamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't timestamp on rxsync */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_dev
argument_list|,
name|OID_AUTO
argument_list|,
name|netmap
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Netmap args"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_verbose
argument_list|,
literal|0
argument_list|,
literal|"Verbose mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_timestamp
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_no_timestamp
argument_list|,
literal|0
argument_list|,
literal|"no_timestamp"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_mitigate
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|mitigate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_mitigate
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_no_pendintr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_pendintr
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_no_pendintr
argument_list|,
literal|0
argument_list|,
literal|"Always look for new received packets."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_txsync_retry
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|txsync_retry
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_txsync_retry
argument_list|,
literal|0
argument_list|,
literal|"Number of txsync loops in bridge's flush."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_adaptive_io
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|adaptive_io
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_adaptive_io
argument_list|,
literal|0
argument_list|,
literal|"Adaptive I/O on paravirt"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flags */
end_comment

begin_decl_stmt
name|int
name|netmap_fwd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* force transparent mode */
end_comment

begin_decl_stmt
name|int
name|netmap_mmap_unreg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* allow mmap of unregistered fds */
end_comment

begin_comment
comment|/*  * netmap_admode selects the netmap mode to use.  * Invalid values are reset to NETMAP_ADMODE_BEST  */
end_comment

begin_enum
enum|enum
block|{
name|NETMAP_ADMODE_BEST
init|=
literal|0
block|,
comment|/* use native, fallback to generic */
name|NETMAP_ADMODE_NATIVE
block|,
comment|/* either native or none */
name|NETMAP_ADMODE_GENERIC
block|,
comment|/* force generic */
name|NETMAP_ADMODE_LAST
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|netmap_admode
init|=
name|NETMAP_ADMODE_BEST
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|netmap_generic_mit
init|=
literal|100
operator|*
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generic mitigation interval in nanoseconds. */
end_comment

begin_decl_stmt
name|int
name|netmap_generic_ringsize
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generic ringsize. */
end_comment

begin_decl_stmt
name|int
name|netmap_generic_rings
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of queues in generic. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|flags
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_flags
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|fwd
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_fwd
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|mmap_unreg
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_mmap_unreg
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|admode
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_admode
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|generic_mit
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_generic_mit
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|generic_ringsize
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_generic_ringsize
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|generic_rings
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_generic_rings
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|NMG_LOCK_T
name|netmap_global_lock
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|nm_kr_get
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kr
parameter_list|)
block|{
while|while
condition|(
name|NM_ATOMIC_TEST_AND_SET
argument_list|(
operator|&
name|kr
operator|->
name|nr_busy
argument_list|)
condition|)
name|tsleep
argument_list|(
name|kr
argument_list|,
literal|0
argument_list|,
literal|"NM_KR_GET"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mark the ring as stopped, and run through the locks  * to make sure other users get to see it.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_disable_ring
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kr
parameter_list|)
block|{
name|kr
operator|->
name|nkr_stopped
operator|=
literal|1
expr_stmt|;
name|nm_kr_get
argument_list|(
name|kr
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|kr
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|kr
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|nm_kr_put
argument_list|(
name|kr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* stop or enable a single tx ring */
end_comment

begin_function
name|void
name|netmap_set_txring
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_id
parameter_list|,
name|int
name|stopped
parameter_list|)
block|{
if|if
condition|(
name|stopped
condition|)
name|netmap_disable_ring
argument_list|(
name|na
operator|->
name|tx_rings
operator|+
name|ring_id
argument_list|)
expr_stmt|;
else|else
name|na
operator|->
name|tx_rings
index|[
name|ring_id
index|]
operator|.
name|nkr_stopped
operator|=
literal|0
expr_stmt|;
comment|/* nofify that the stopped state has changed. This is currently 	 *only used by bwrap to propagate the state to its own krings. 	 * (see netmap_bwrap_intr_notify). 	 */
name|na
operator|->
name|nm_notify
argument_list|(
name|na
argument_list|,
name|ring_id
argument_list|,
name|NR_TX
argument_list|,
name|NAF_DISABLE_NOTIFY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* stop or enable a single rx ring */
end_comment

begin_function
name|void
name|netmap_set_rxring
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_id
parameter_list|,
name|int
name|stopped
parameter_list|)
block|{
if|if
condition|(
name|stopped
condition|)
name|netmap_disable_ring
argument_list|(
name|na
operator|->
name|rx_rings
operator|+
name|ring_id
argument_list|)
expr_stmt|;
else|else
name|na
operator|->
name|rx_rings
index|[
name|ring_id
index|]
operator|.
name|nkr_stopped
operator|=
literal|0
expr_stmt|;
comment|/* nofify that the stopped state has changed. This is currently 	 *only used by bwrap to propagate the state to its own krings. 	 * (see netmap_bwrap_intr_notify). 	 */
name|na
operator|->
name|nm_notify
argument_list|(
name|na
argument_list|,
name|ring_id
argument_list|,
name|NR_RX
argument_list|,
name|NAF_DISABLE_NOTIFY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* stop or enable all the rings of na */
end_comment

begin_function
name|void
name|netmap_set_all_rings
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|stopped
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|ntx
decl_stmt|,
name|nrx
decl_stmt|;
if|if
condition|(
operator|!
name|nm_netmap_on
argument_list|(
name|na
argument_list|)
condition|)
return|return;
name|ntx
operator|=
name|netmap_real_tx_rings
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|nrx
operator|=
name|netmap_real_rx_rings
argument_list|(
name|na
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntx
condition|;
name|i
operator|++
control|)
block|{
name|netmap_set_txring
argument_list|(
name|na
argument_list|,
name|i
argument_list|,
name|stopped
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrx
condition|;
name|i
operator|++
control|)
block|{
name|netmap_set_rxring
argument_list|(
name|na
argument_list|,
name|i
argument_list|,
name|stopped
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convenience function used in drivers.  Waits for current txsync()s/rxsync()s  * to finish and prevents any new one from starting.  Call this before turning  * netmap mode off, or before removing the harware rings (e.g., on module  * onload).  As a rule of thumb for linux drivers, this should be placed near  * each napi_disable().  */
end_comment

begin_function
name|void
name|netmap_disable_all_rings
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|netmap_set_all_rings
argument_list|(
name|NA
argument_list|(
name|ifp
argument_list|)
argument_list|,
literal|1
comment|/* stopped */
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convenience function used in drivers.  Re-enables rxsync and txsync on the  * adapter's rings In linux drivers, this should be placed near each  * napi_enable().  */
end_comment

begin_function
name|void
name|netmap_enable_all_rings
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|netmap_set_all_rings
argument_list|(
name|NA
argument_list|(
name|ifp
argument_list|)
argument_list|,
literal|0
comment|/* enabled */
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * generic bound_checking function  */
end_comment

begin_function
name|u_int
name|nm_bound_var
parameter_list|(
name|u_int
modifier|*
name|v
parameter_list|,
name|u_int
name|dflt
parameter_list|,
name|u_int
name|lo
parameter_list|,
name|u_int
name|hi
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|u_int
name|oldv
init|=
operator|*
name|v
decl_stmt|;
specifier|const
name|char
modifier|*
name|op
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dflt
operator|<
name|lo
condition|)
name|dflt
operator|=
name|lo
expr_stmt|;
if|if
condition|(
name|dflt
operator|>
name|hi
condition|)
name|dflt
operator|=
name|hi
expr_stmt|;
if|if
condition|(
name|oldv
operator|<
name|lo
condition|)
block|{
operator|*
name|v
operator|=
name|dflt
expr_stmt|;
name|op
operator|=
literal|"Bump"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldv
operator|>
name|hi
condition|)
block|{
operator|*
name|v
operator|=
name|hi
expr_stmt|;
name|op
operator|=
literal|"Clamp"
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&&
name|msg
condition|)
name|printf
argument_list|(
literal|"%s %s to %d (was %d)\n"
argument_list|,
name|op
argument_list|,
name|msg
argument_list|,
operator|*
name|v
argument_list|,
name|oldv
argument_list|)
expr_stmt|;
return|return
operator|*
name|v
return|;
block|}
end_function

begin_comment
comment|/*  * packet-dump function, user-supplied or static buffer.  * The destination buffer must be at least 30+4*len  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|nm_dump_buf
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|lim
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|)
block|{
specifier|static
name|char
name|_dst
index|[
literal|8192
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|i0
decl_stmt|;
specifier|static
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|char
modifier|*
name|o
decl_stmt|;
comment|/* output position */
define|#
directive|define
name|P_HI
parameter_list|(
name|x
parameter_list|)
value|hex[((x)& 0xf0)>>4]
define|#
directive|define
name|P_LO
parameter_list|(
name|x
parameter_list|)
value|hex[((x)& 0xf)]
define|#
directive|define
name|P_C
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0x20&& (x)<= 0x7e ? (x) : '.')
if|if
condition|(
operator|!
name|dst
condition|)
name|dst
operator|=
name|_dst
expr_stmt|;
if|if
condition|(
name|lim
operator|<=
literal|0
operator|||
name|lim
operator|>
name|len
condition|)
name|lim
operator|=
name|len
expr_stmt|;
name|o
operator|=
name|dst
expr_stmt|;
name|sprintf
argument_list|(
name|o
argument_list|,
literal|"buf 0x%p len %d lim %d\n"
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|o
operator|+=
name|strlen
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* hexdump routine */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
control|)
block|{
name|sprintf
argument_list|(
name|o
argument_list|,
literal|"%5d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|o
operator|+=
name|strlen
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|o
argument_list|,
literal|' '
argument_list|,
literal|48
argument_list|)
expr_stmt|;
name|i0
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|<
name|lim
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|o
index|[
name|j
operator|*
literal|3
index|]
operator|=
name|P_HI
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|o
index|[
name|j
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|P_LO
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|i0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|<
name|lim
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|o
index|[
name|j
operator|+
literal|48
index|]
operator|=
name|P_C
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|o
index|[
name|j
operator|+
literal|48
index|]
operator|=
literal|'\n'
expr_stmt|;
name|o
operator|+=
name|j
operator|+
literal|49
expr_stmt|;
block|}
operator|*
name|o
operator|=
literal|'\0'
expr_stmt|;
undef|#
directive|undef
name|P_HI
undef|#
directive|undef
name|P_LO
undef|#
directive|undef
name|P_C
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch configuration from the device, to cope with dynamic  * reconfigurations after loading the module.  */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
name|int
name|netmap_update_config
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|u_int
name|txr
decl_stmt|,
name|txd
decl_stmt|,
name|rxr
decl_stmt|,
name|rxd
decl_stmt|;
name|txr
operator|=
name|txd
operator|=
name|rxr
operator|=
name|rxd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_config
condition|)
block|{
name|na
operator|->
name|nm_config
argument_list|(
name|na
argument_list|,
operator|&
name|txr
argument_list|,
operator|&
name|txd
argument_list|,
operator|&
name|rxr
argument_list|,
operator|&
name|rxd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* take whatever we had at init time */
name|txr
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|txd
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|rxr
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|rxd
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|==
name|txr
operator|&&
name|na
operator|->
name|num_tx_desc
operator|==
name|txd
operator|&&
name|na
operator|->
name|num_rx_rings
operator|==
name|rxr
operator|&&
name|na
operator|->
name|num_rx_desc
operator|==
name|rxd
condition|)
return|return
literal|0
return|;
comment|/* nothing changed */
if|if
condition|(
name|netmap_verbose
operator|||
name|na
operator|->
name|active_fds
operator|>
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"stored config %s: txring %d x %d, rxring %d x %d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|na
operator|->
name|num_tx_rings
argument_list|,
name|na
operator|->
name|num_tx_desc
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|,
name|na
operator|->
name|num_rx_desc
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"new config %s: txring %d x %d, rxring %d x %d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|txr
argument_list|,
name|txd
argument_list|,
name|rxr
argument_list|,
name|rxd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"configuration changed (but fine)"
argument_list|)
expr_stmt|;
name|na
operator|->
name|num_tx_rings
operator|=
name|txr
expr_stmt|;
name|na
operator|->
name|num_tx_desc
operator|=
name|txd
expr_stmt|;
name|na
operator|->
name|num_rx_rings
operator|=
name|rxr
expr_stmt|;
name|na
operator|->
name|num_rx_desc
operator|=
name|rxd
expr_stmt|;
return|return
literal|0
return|;
block|}
name|D
argument_list|(
literal|"configuration changed while active, this is bad..."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* kring->nm_sync callback for the host tx ring */
end_comment

begin_function
specifier|static
name|int
name|netmap_txsync_to_host_compat
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
operator|(
name|void
operator|)
name|flags
expr_stmt|;
comment|/* unused */
name|netmap_txsync_to_host
argument_list|(
name|kring
operator|->
name|na
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* kring->nm_sync callback for the host rx ring */
end_comment

begin_function
specifier|static
name|int
name|netmap_rxsync_from_host_compat
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
operator|(
name|void
operator|)
name|flags
expr_stmt|;
comment|/* unused */
name|netmap_rxsync_from_host
argument_list|(
name|kring
operator|->
name|na
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* create the krings array and initialize the fields common to all adapters.  * The array layout is this:  *  *                    +----------+  * na->tx_rings ----->|          | \  *                    |          |  } na->num_tx_ring  *                    |          | /  *                    +----------+  *                    |          |    host tx kring  * na->rx_rings ----> +----------+  *                    |          | \  *                    |          |  } na->num_rx_rings  *                    |          | /  *                    +----------+  *                    |          |    host rx kring  *                    +----------+  * na->tailroom ----->|          | \  *                    |          |  } tailroom bytes  *                    |          | /  *                    +----------+  *  * Note: for compatibility, host krings are created even when not needed.  * The tailroom space is currently used by vale ports for allocating leases.  */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
name|int
name|netmap_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|tailroom
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|ndesc
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|u_int
name|ntx
decl_stmt|,
name|nrx
decl_stmt|;
comment|/* account for the (possibly fake) host rings */
name|ntx
operator|=
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
expr_stmt|;
name|nrx
operator|=
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
expr_stmt|;
name|len
operator|=
operator|(
name|ntx
operator|+
name|nrx
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_kring
argument_list|)
operator|+
name|tailroom
expr_stmt|;
name|na
operator|->
name|tx_rings
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|tx_rings
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"Cannot allocate krings"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|na
operator|->
name|rx_rings
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|ntx
expr_stmt|;
comment|/* 	 * All fields in krings are 0 except the one initialized below. 	 * but better be explicit on important kring fields. 	 */
name|ndesc
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntx
condition|;
name|i
operator|++
control|)
block|{
comment|/* Transmit rings */
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|bzero
argument_list|(
name|kring
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kring
argument_list|)
argument_list|)
expr_stmt|;
name|kring
operator|->
name|na
operator|=
name|na
expr_stmt|;
name|kring
operator|->
name|ring_id
operator|=
name|i
expr_stmt|;
name|kring
operator|->
name|nkr_num_slots
operator|=
name|ndesc
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|na
operator|->
name|num_tx_rings
condition|)
block|{
name|kring
operator|->
name|nm_sync
operator|=
name|na
operator|->
name|nm_txsync
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|na
operator|->
name|num_tx_rings
condition|)
block|{
name|kring
operator|->
name|nm_sync
operator|=
name|netmap_txsync_to_host_compat
expr_stmt|;
block|}
comment|/* 		 * IMPORTANT: Always keep one slot empty. 		 */
name|kring
operator|->
name|rhead
operator|=
name|kring
operator|->
name|rcur
operator|=
name|kring
operator|->
name|nr_hwcur
operator|=
literal|0
expr_stmt|;
name|kring
operator|->
name|rtail
operator|=
name|kring
operator|->
name|nr_hwtail
operator|=
name|ndesc
operator|-
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|kring
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|kring
operator|->
name|name
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%s TX%d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"ktx %s h %d c %d t %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|rhead
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|,
literal|"nm_txq_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|init_waitqueue_head
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
block|}
name|ndesc
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrx
condition|;
name|i
operator|++
control|)
block|{
comment|/* Receive rings */
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|bzero
argument_list|(
name|kring
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kring
argument_list|)
argument_list|)
expr_stmt|;
name|kring
operator|->
name|na
operator|=
name|na
expr_stmt|;
name|kring
operator|->
name|ring_id
operator|=
name|i
expr_stmt|;
name|kring
operator|->
name|nkr_num_slots
operator|=
name|ndesc
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|na
operator|->
name|num_rx_rings
condition|)
block|{
name|kring
operator|->
name|nm_sync
operator|=
name|na
operator|->
name|nm_rxsync
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|na
operator|->
name|num_rx_rings
condition|)
block|{
name|kring
operator|->
name|nm_sync
operator|=
name|netmap_rxsync_from_host_compat
expr_stmt|;
block|}
name|kring
operator|->
name|rhead
operator|=
name|kring
operator|->
name|rcur
operator|=
name|kring
operator|->
name|nr_hwcur
operator|=
literal|0
expr_stmt|;
name|kring
operator|->
name|rtail
operator|=
name|kring
operator|->
name|nr_hwtail
operator|=
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|kring
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|kring
operator|->
name|name
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%s RX%d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"krx %s h %d c %d t %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|rhead
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|,
literal|"nm_rxq_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|init_waitqueue_head
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
block|}
name|init_waitqueue_head
argument_list|(
operator|&
name|na
operator|->
name|tx_si
argument_list|)
expr_stmt|;
name|init_waitqueue_head
argument_list|(
operator|&
name|na
operator|->
name|rx_si
argument_list|)
expr_stmt|;
name|na
operator|->
name|tailroom
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|nrx
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* undo the actions performed by netmap_krings_create */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
name|void
name|netmap_krings_delete
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
name|na
operator|->
name|tx_rings
decl_stmt|;
comment|/* we rely on the krings layout described above */
for|for
control|(
init|;
name|kring
operator|!=
name|na
operator|->
name|tailroom
condition|;
name|kring
operator|++
control|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|na
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|na
operator|->
name|tx_rings
operator|=
name|na
operator|->
name|rx_rings
operator|=
name|na
operator|->
name|tailroom
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Destructor for NIC ports. They also have an mbuf queue  * on the rings connected to the host so we need to purge  * them first.  */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
specifier|static
name|void
name|netmap_hw_krings_delete
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|mbq
modifier|*
name|q
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
operator|.
name|rx_queue
decl_stmt|;
name|ND
argument_list|(
literal|"destroy sw mbq with len %d"
argument_list|,
name|mbq_len
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|mbq_purge
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|mbq_safe_destroy
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|netmap_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* create a new netmap_if for a newly registered fd.  * If this is the first registration of the adapter,  * also create the netmap rings and their in-kernel view,  * the netmap krings.  */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
specifier|static
name|struct
name|netmap_if
modifier|*
name|netmap_if_new
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
if|if
condition|(
name|netmap_update_config
argument_list|(
name|na
argument_list|)
condition|)
block|{
comment|/* configuration mismatch, report and fail */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|na
operator|->
name|active_fds
condition|)
comment|/* already registered */
goto|goto
name|final
goto|;
comment|/* create and init the krings arrays. 	 * Depending on the adapter, this may also create 	 * the netmap rings themselves 	 */
if|if
condition|(
name|na
operator|->
name|nm_krings_create
argument_list|(
name|na
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* create all missing netmap rings */
if|if
condition|(
name|netmap_mem_rings_create
argument_list|(
name|na
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
name|final
label|:
comment|/* in all cases, create a new netmap if */
name|nifp
operator|=
name|netmap_mem_if_new
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
return|return
operator|(
name|nifp
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
block|{
name|netmap_mem_rings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* grab a reference to the memory allocator, if we don't have one already.  The  * reference is taken from the netmap_adapter registered with the priv.  */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
specifier|static
name|int
name|netmap_get_memory_locked
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|netmap_mem_d
modifier|*
name|nmd
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|np_na
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|netmap_mmap_unreg
condition|)
return|return
name|ENODEV
return|;
comment|/* for compatibility with older versions of the API  		 * we use the global allocator when no interface has been  		 * registered  		 */
name|nmd
operator|=
operator|&
name|nm_mem
expr_stmt|;
block|}
else|else
block|{
name|nmd
operator|=
name|p
operator|->
name|np_na
operator|->
name|nm_mem
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|np_mref
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|netmap_mem_finalize
argument_list|(
name|nmd
argument_list|,
name|p
operator|->
name|np_na
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|p
operator|->
name|np_mref
operator|=
name|nmd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|np_mref
operator|!=
name|nmd
condition|)
block|{
comment|/* a virtual port has been registered, but previous  		 * syscalls already used the global allocator.  		 * We cannot continue  		 */
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* call with NMG_LOCK *not* held */
end_comment

begin_function
name|int
name|netmap_get_memory
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_get_memory_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
specifier|static
name|int
name|netmap_have_memory_locked
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|p
parameter_list|)
block|{
return|return
name|p
operator|->
name|np_mref
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
specifier|static
name|void
name|netmap_drop_memory_locked
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|np_mref
condition|)
block|{
name|netmap_mem_deref
argument_list|(
name|p
operator|->
name|np_mref
argument_list|,
name|p
operator|->
name|np_na
argument_list|)
expr_stmt|;
name|p
operator|->
name|np_mref
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Call nm_register(ifp,0) to stop netmap mode on the interface and  * revert to normal operation.  * The second argument is the nifp to work on. In some cases it is  * not attached yet to the netmap_priv_d so we need to pass it as  * a separate argument.  */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
specifier|static
name|void
name|netmap_do_unregif
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|struct
name|netmap_if
modifier|*
name|nifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|na
operator|->
name|active_fds
operator|--
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|active_fds
operator|<=
literal|0
condition|)
block|{
comment|/* last instance */
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"deleting last instance for %s"
argument_list|,
name|na
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * (TO CHECK) This function is only called 		 * when the last reference to this file descriptor goes 		 * away. This means we cannot have any pending poll() 		 * or interrupt routine operating on the structure. 		 * XXX The file may be closed in a thread while 		 * another thread is using it. 		 * Linux keeps the file opened until the last reference 		 * by any outstanding ioctl/poll or mmap is gone. 		 * FreeBSD does not track mmap()s (but we do) and 		 * wakes up any sleeping poll(). Need to check what 		 * happens if the close() occurs while a concurrent 		 * syscall is running. 		 */
name|na
operator|->
name|nm_register
argument_list|(
name|na
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* off, clear flags */
comment|/* Wake up any sleeping threads. netmap_poll will 		 * then return POLLERR 		 * XXX The wake up now must happen during *_down(), when 		 * we order all activities to stop. -gl 		 */
comment|/* XXX kqueue(9) needed; these will mirror knlist_init. */
comment|/* knlist_destroy(&na->tx_si.si_note); */
comment|/* knlist_destroy(&na->rx_si.si_note); */
comment|/* delete rings and buffers */
name|netmap_mem_rings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
comment|/* delete the nifp */
name|netmap_mem_if_delete
argument_list|(
name|na
argument_list|,
name|nifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|nm_tx_si_user
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|)
block|{
return|return
operator|(
name|priv
operator|->
name|np_na
operator|!=
name|NULL
operator|&&
operator|(
name|priv
operator|->
name|np_txqlast
operator|-
name|priv
operator|->
name|np_txqfirst
operator|>
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|nm_rx_si_user
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|)
block|{
return|return
operator|(
name|priv
operator|->
name|np_na
operator|!=
name|NULL
operator|&&
operator|(
name|priv
operator|->
name|np_rxqlast
operator|-
name|priv
operator|->
name|np_rxqfirst
operator|>
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destructor of the netmap_priv_d, called when the fd has  * no active open() and mmap(). Also called in error paths.  *  * returns 1 if this is the last instance and we can free priv  */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
name|int
name|netmap_dtor_locked
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* 	 * np_refcount is the number of active mmaps on 	 * this file descriptor 	 */
if|if
condition|(
operator|--
name|priv
operator|->
name|np_refcount
operator|>
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* __FreeBSD__ */
if|if
condition|(
operator|!
name|na
condition|)
block|{
return|return
literal|1
return|;
comment|//XXX is it correct?
block|}
name|netmap_do_unregif
argument_list|(
name|priv
argument_list|,
name|priv
operator|->
name|np_nifp
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_nifp
operator|=
name|NULL
expr_stmt|;
name|netmap_drop_memory_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_na
condition|)
block|{
if|if
condition|(
name|nm_tx_si_user
argument_list|(
name|priv
argument_list|)
condition|)
name|na
operator|->
name|tx_si_users
operator|--
expr_stmt|;
if|if
condition|(
name|nm_rx_si_user
argument_list|(
name|priv
argument_list|)
condition|)
name|na
operator|->
name|rx_si_users
operator|--
expr_stmt|;
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_na
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* call with NMG_LOCK *not* held */
end_comment

begin_function
name|void
name|netmap_dtor
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|data
decl_stmt|;
name|int
name|last_instance
decl_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|last_instance
operator|=
name|netmap_dtor_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_instance
condition|)
block|{
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for safety */
name|free
argument_list|(
name|priv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handlers for synchronization of the queues from/to the host.  * Netmap has two operating modes:  * - in the default mode, the rings connected to the host stack are  *   just another ring pair managed by userspace;  * - in transparent mode (XXX to be defined) incoming packets  *   (from the host or the NIC) are marked as NS_FORWARD upon  *   arrival, and the user application has a chance to reset the  *   flag for packets that should be dropped.  *   On the RXSYNC or poll(), packets in RX rings between  *   kring->nr_kcur and ring->cur with NS_FORWARD still set are moved  *   to the other side.  * The transfer NIC --> host is relatively easy, just encapsulate  * into mbufs and we are done. The host --> NIC side is slightly  * harder because there might not be room in the tx ring so it  * might take a while before releasing the buffer.  */
end_comment

begin_comment
comment|/*  * pass a chain of buffers to the host stack as coming from 'dst'  * We do not need to lock because the queue is private.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_send_up
parameter_list|(
name|struct
name|ifnet
modifier|*
name|dst
parameter_list|,
name|struct
name|mbq
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* send packets up, outside the lock */
while|while
condition|(
operator|(
name|m
operator|=
name|mbq_dequeue
argument_list|(
name|q
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"sending up pkt %p size %d"
argument_list|,
name|m
argument_list|,
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|NM_SEND_UP
argument_list|(
name|dst
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|mbq_destroy
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * put a copy of the buffers marked NS_FORWARD into an mbuf chain.  * Take packets from hwcur to ring->head marked NS_FORWARD (or forced)  * and pass them up. Drop remaining packets in the unlikely event  * of an mbuf shortage.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_grab_packets
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|struct
name|mbq
modifier|*
name|q
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|ring
operator|->
name|head
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
for|for
control|(
name|n
operator|=
name|kring
operator|->
name|nr_hwcur
init|;
name|n
operator|!=
name|head
condition|;
name|n
operator|=
name|nm_next
argument_list|(
name|n
argument_list|,
name|lim
argument_list|)
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_FORWARD
operator|)
operator|==
literal|0
operator|&&
operator|!
name|force
condition|)
continue|continue;
if|if
condition|(
name|slot
operator|->
name|len
operator|<
literal|14
operator|||
name|slot
operator|->
name|len
operator|>
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"bad pkt at %d len %d"
argument_list|,
name|n
argument_list|,
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_FORWARD
expr_stmt|;
comment|// XXX needed ?
comment|/* XXX TODO: adapt to the case of a multisegment packet */
name|m
operator|=
name|m_devget
argument_list|(
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
argument_list|,
name|slot
operator|->
name|len
argument_list|,
literal|0
argument_list|,
name|na
operator|->
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|mbq_enqueue
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send to the NIC rings packets marked NS_FORWARD between  * kring->nr_hwcur and kring->rhead  * Called under kring->rx_queue.lock on the sw rx ring,  */
end_comment

begin_function
specifier|static
name|u_int
name|netmap_sw_to_nic
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|rxslot
init|=
name|kring
operator|->
name|ring
operator|->
name|slot
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|rxcur
init|=
name|kring
operator|->
name|nr_hwcur
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|u_int
specifier|const
name|src_lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
name|sent
init|=
literal|0
decl_stmt|;
comment|/* scan rings to find space, then fill as much as possible */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kdst
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|rdst
init|=
name|kdst
operator|->
name|ring
decl_stmt|;
name|u_int
specifier|const
name|dst_lim
init|=
name|kdst
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
comment|/* XXX do we trust ring or kring->rcur,rtail ? */
for|for
control|(
init|;
name|rxcur
operator|!=
name|head
operator|&&
operator|!
name|nm_ring_empty
argument_list|(
name|rdst
argument_list|)
condition|;
name|rxcur
operator|=
name|nm_next
argument_list|(
name|rxcur
argument_list|,
name|src_lim
argument_list|)
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
name|tmp
decl_stmt|;
name|u_int
name|dst_cur
init|=
name|rdst
operator|->
name|cur
decl_stmt|;
name|src
operator|=
operator|&
name|rxslot
index|[
name|rxcur
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|src
operator|->
name|flags
operator|&
name|NS_FORWARD
operator|)
operator|==
literal|0
operator|&&
operator|!
name|netmap_fwd
condition|)
continue|continue;
name|sent
operator|++
expr_stmt|;
name|dst
operator|=
operator|&
name|rdst
operator|->
name|slot
index|[
name|dst_cur
index|]
expr_stmt|;
name|tmp
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|->
name|buf_idx
operator|=
name|dst
operator|->
name|buf_idx
expr_stmt|;
name|src
operator|->
name|flags
operator|=
name|NS_BUF_CHANGED
expr_stmt|;
name|dst
operator|->
name|buf_idx
operator|=
name|tmp
operator|.
name|buf_idx
expr_stmt|;
name|dst
operator|->
name|len
operator|=
name|tmp
operator|.
name|len
expr_stmt|;
name|dst
operator|->
name|flags
operator|=
name|NS_BUF_CHANGED
expr_stmt|;
name|rdst
operator|->
name|cur
operator|=
name|nm_next
argument_list|(
name|dst_cur
argument_list|,
name|dst_lim
argument_list|)
expr_stmt|;
block|}
comment|/* if (sent) XXX txsync ? */
block|}
return|return
name|sent
return|;
block|}
end_function

begin_comment
comment|/*  * netmap_txsync_to_host() passes packets up. We are called from a  * system call in user process context, and the only contention  * can be among multiple user threads erroneously calling  * this routine concurrently.  */
end_comment

begin_function
name|void
name|netmap_txsync_to_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|na
operator|->
name|num_tx_rings
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|struct
name|mbq
name|q
decl_stmt|;
comment|/* Take packets from hwcur to head and pass them up. 	 * force head = cur since netmap_grab_packets() stops at head 	 * In case of no buffers we give up. At the end of the loop, 	 * the queue is drained in all cases. 	 */
name|mbq_init
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|head
expr_stmt|;
name|netmap_grab_packets
argument_list|(
name|kring
argument_list|,
operator|&
name|q
argument_list|,
literal|1
comment|/* force */
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"have %d pkts in queue"
argument_list|,
name|mbq_len
argument_list|(
operator|&
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|head
expr_stmt|;
name|kring
operator|->
name|nr_hwtail
operator|=
name|head
operator|+
name|lim
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwtail
operator|>
name|lim
condition|)
name|kring
operator|->
name|nr_hwtail
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
name|nm_txsync_finalize
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|netmap_send_up
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
operator|&
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rxsync backend for packets coming from the host stack.  * They have been put in kring->rx_queue by netmap_transmit().  * We protect access to the kring using kring->rx_queue.lock  *  * This routine also does the selrecord if called from the poll handler  * (we know because td != NULL).  *  * NOTE: on linux, selrecord() is defined as a macro and uses pwait  *     as an additional hidden argument.  * returns the number of packets delivered to tx queues in  * transparent mode, or a negative value if error  */
end_comment

begin_function
name|int
name|netmap_rxsync_from_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|pwait
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|nm_i
decl_stmt|,
name|n
decl_stmt|;
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|mbq
modifier|*
name|q
init|=
operator|&
name|kring
operator|->
name|rx_queue
decl_stmt|;
operator|(
name|void
operator|)
name|pwait
expr_stmt|;
comment|/* disable unused warnings */
operator|(
name|void
operator|)
name|td
expr_stmt|;
name|mbq_lock
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* First part: import newly received packets */
name|n
operator|=
name|mbq_len
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|/* grab packets from the queue */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|stop_i
decl_stmt|;
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
name|stop_i
operator|=
name|nm_prev
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
while|while
condition|(
name|nm_i
operator|!=
name|stop_i
operator|&&
operator|(
name|m
operator|=
name|mbq_dequeue
argument_list|(
name|q
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
init|=
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
decl_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"nm %d len %d"
argument_list|,
name|nm_i
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s"
argument_list|,
name|nm_dump_buf
argument_list|(
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
argument_list|,
name|len
argument_list|,
literal|128
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
name|kring
operator|->
name|nkr_slot_flags
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwtail
operator|=
name|nm_i
expr_stmt|;
block|}
comment|/* 	 * Second part: skip past packets that userspace has released. 	 */
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|nm_i
operator|!=
name|head
condition|)
block|{
comment|/* something was released */
if|if
condition|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
condition|)
name|ret
operator|=
name|netmap_sw_to_nic
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|head
expr_stmt|;
block|}
name|nm_rxsync_finalize
argument_list|(
name|kring
argument_list|)
expr_stmt|;
comment|/* access copies of cur,tail in the kring */
if|if
condition|(
name|kring
operator|->
name|rcur
operator|==
name|kring
operator|->
name|rtail
operator|&&
name|td
condition|)
comment|/* no bufs available */
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
name|mbq_unlock
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Get a netmap adapter for the port.  *  * If it is possible to satisfy the request, return 0  * with *na containing the netmap adapter found.  * Otherwise return an error code, with *na containing NULL.  *  * When the port is attached to a bridge, we always return  * EBUSY.  * Otherwise, if the port is already bound to a file descriptor,  * then we unconditionally return the existing adapter into *na.  * In all the other cases, we return (into *na) either native,  * generic or NULL, according to the following table:  *  *					native_support  * active_fds   dev.netmap.admode         YES     NO  * -------------------------------------------------------  *>0              *                 NA(ifp) NA(ifp)  *  *     0        NETMAP_ADMODE_BEST      NATIVE  GENERIC  *     0        NETMAP_ADMODE_NATIVE    NATIVE   NULL  *     0        NETMAP_ADMODE_GENERIC   GENERIC GENERIC  *  */
end_comment

begin_function
name|int
name|netmap_get_hw_na
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
modifier|*
name|na
parameter_list|)
block|{
comment|/* generic support */
name|int
name|i
init|=
name|netmap_admode
decl_stmt|;
comment|/* Take a snapshot. */
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|prev_na
decl_stmt|;
name|struct
name|netmap_generic_adapter
modifier|*
name|gna
decl_stmt|;
operator|*
name|na
operator|=
name|NULL
expr_stmt|;
comment|/* default */
comment|/* reset in case of invalid value */
if|if
condition|(
name|i
operator|<
name|NETMAP_ADMODE_BEST
operator|||
name|i
operator|>=
name|NETMAP_ADMODE_LAST
condition|)
name|i
operator|=
name|netmap_admode
operator|=
name|NETMAP_ADMODE_BEST
expr_stmt|;
if|if
condition|(
name|NETMAP_CAPABLE
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|prev_na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* If an adapter already exists, return it if 		 * there are active file descriptors or if 		 * netmap is not forced to use generic 		 * adapters. 		 */
if|if
condition|(
name|NETMAP_OWNED_BY_ANY
argument_list|(
name|prev_na
argument_list|)
operator|||
name|i
operator|!=
name|NETMAP_ADMODE_GENERIC
operator|||
name|prev_na
operator|->
name|na_flags
operator|&
name|NAF_FORCE_NATIVE
ifdef|#
directive|ifdef
name|WITH_PIPES
comment|/* ugly, but we cannot allow an adapter switch 			 * if some pipe is referring to this one 			 */
operator|||
name|prev_na
operator|->
name|na_next_pipe
operator|>
literal|0
endif|#
directive|endif
condition|)
block|{
operator|*
name|na
operator|=
name|prev_na
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* If there isn't native support and netmap is not allowed 	 * to use generic adapters, we cannot satisfy the request. 	 */
if|if
condition|(
operator|!
name|NETMAP_CAPABLE
argument_list|(
name|ifp
argument_list|)
operator|&&
name|i
operator|==
name|NETMAP_ADMODE_NATIVE
condition|)
return|return
name|EOPNOTSUPP
return|;
comment|/* Otherwise, create a generic adapter and return it, 	 * saving the previously used netmap adapter, if any. 	 * 	 * Note that here 'prev_na', if not NULL, MUST be a 	 * native adapter, and CANNOT be a generic one. This is 	 * true because generic adapters are created on demand, and 	 * destroyed when not used anymore. Therefore, if the adapter 	 * currently attached to an interface 'ifp' is generic, it 	 * must be that 	 * (NA(ifp)->active_fds> 0 || NETMAP_OWNED_BY_KERN(NA(ifp))). 	 * Consequently, if NA(ifp) is generic, we will enter one of 	 * the branches above. This ensures that we never override 	 * a generic adapter with another generic adapter. 	 */
name|prev_na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|error
operator|=
name|generic_netmap_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|*
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|gna
operator|=
operator|(
expr|struct
name|netmap_generic_adapter
operator|*
operator|)
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|gna
operator|->
name|prev
operator|=
name|prev_na
expr_stmt|;
comment|/* save old na */
if|if
condition|(
name|prev_na
operator|!=
name|NULL
condition|)
block|{
name|ifunit_ref
argument_list|(
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|// XXX add a refcount ?
name|netmap_adapter_get
argument_list|(
name|prev_na
argument_list|)
expr_stmt|;
block|}
name|ND
argument_list|(
literal|"Created generic NA %p (prev %p)"
argument_list|,
name|gna
argument_list|,
name|gna
operator|->
name|prev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * MUST BE CALLED UNDER NMG_LOCK()  *  * Get a refcounted reference to a netmap adapter attached  * to the interface specified by nmr.  * This is always called in the execution of an ioctl().  *  * Return ENXIO if the interface specified by the request does  * not exist, ENOTSUP if netmap is not supported by the interface,  * EBUSY if the interface is already attached to a bridge,  * EINVAL if parameters are invalid, ENOMEM if needed resources  * could not be allocated.  * If successful, hold a reference to the netmap adapter.  *  * No reference is kept on the real interface, which may then  * disappear at any time.  */
end_comment

begin_function
name|int
name|netmap_get_na
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
modifier|*
name|na
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
operator|*
name|na
operator|=
name|NULL
expr_stmt|;
comment|/* default return value */
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* we cascade through all possibile types of netmap adapter. 	 * All netmap_get_*_na() functions return an error and an na, 	 * with the following combinations: 	 * 	 * error    na 	 *   0	   NULL		type doesn't match 	 *  !0	   NULL		type matches, but na creation/lookup failed 	 *   0	  !NULL		type matches and na created/found 	 *  !0    !NULL		impossible 	 */
comment|/* try to see if this is a monitor port */
name|error
operator|=
name|netmap_get_monitor_na
argument_list|(
name|nmr
argument_list|,
name|na
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|*
name|na
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
comment|/* try to see if this is a pipe port */
name|error
operator|=
name|netmap_get_pipe_na
argument_list|(
name|nmr
argument_list|,
name|na
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|*
name|na
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
comment|/* try to see if this is a bridge port */
name|error
operator|=
name|netmap_get_bdg_na
argument_list|(
name|nmr
argument_list|,
name|na
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|*
name|na
operator|!=
name|NULL
condition|)
comment|/* valid match in netmap_get_bdg_na() */
goto|goto
name|pipes
goto|;
comment|/* 	 * This must be a hardware na, lookup the name in the system. 	 * Note that by hardware we actually mean "it shows up in ifconfig". 	 * This may still be a tap, a veth/epair, or even a 	 * persistent VALE port. 	 */
name|ifp
operator|=
name|ifunit_ref
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|error
operator|=
name|netmap_get_hw_na
argument_list|(
name|ifp
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
operator|*
name|na
operator|=
name|ret
expr_stmt|;
name|netmap_adapter_get
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|pipes
label|:
comment|/* 	 * If we are opening a pipe whose parent was not in netmap mode, 	 * we have to allocate the pipe array now. 	 * XXX get rid of this clumsiness (2014-03-15) 	 */
name|error
operator|=
name|netmap_pipe_alloc
argument_list|(
operator|*
name|na
argument_list|,
name|nmr
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|&&
name|ret
operator|!=
name|NULL
condition|)
name|netmap_adapter_put
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
condition|)
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* allow live unloading of drivers modules */
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * validate parameters on entry for *_txsync()  * Returns ring->cur if ok, or something>= kring->nkr_num_slots  * in case of error.  *  * rhead, rcur and rtail=hwtail are stored from previous round.  * hwcur is the next packet to send to the ring.  *  * We want  *    hwcur<= *rhead<= head<= cur<= tail = *rtail<= hwtail  *  * hwcur, rhead, rtail and hwtail are reliable  */
end_comment

begin_function
name|u_int
name|nm_txsync_prologue
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|head
init|=
name|ring
operator|->
name|head
decl_stmt|;
comment|/* read only once */
name|u_int
name|cur
init|=
name|ring
operator|->
name|cur
decl_stmt|;
comment|/* read only once */
name|u_int
name|n
init|=
name|kring
operator|->
name|nkr_num_slots
decl_stmt|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"%s kcur %d ktail %d head %d cur %d tail %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|ring
operator|->
name|head
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|ring
operator|->
name|tail
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* kernel sanity checks; but we can trust the kring. */
if|if
condition|(
name|kring
operator|->
name|nr_hwcur
operator|>=
name|n
operator|||
name|kring
operator|->
name|rhead
operator|>=
name|n
operator|||
name|kring
operator|->
name|rtail
operator|>=
name|n
operator|||
name|kring
operator|->
name|nr_hwtail
operator|>=
name|n
condition|)
goto|goto
name|error
goto|;
endif|#
directive|endif
comment|/* kernel sanity checks */
comment|/* 	 * user sanity checks. We only use 'cur', 	 * A, B, ... are possible positions for cur: 	 * 	 *  0    A  cur   B  tail  C  n-1 	 *  0    D  tail  E  cur   F  n-1 	 * 	 * B, F, D are valid. A, C, E are wrong 	 */
if|if
condition|(
name|kring
operator|->
name|rtail
operator|>=
name|kring
operator|->
name|rhead
condition|)
block|{
comment|/* want rhead<= head<= rtail */
if|if
condition|(
name|head
operator|<
name|kring
operator|->
name|rhead
operator|||
name|head
operator|>
name|kring
operator|->
name|rtail
condition|)
goto|goto
name|error
goto|;
comment|/* and also head<= cur<= rtail */
if|if
condition|(
name|cur
operator|<
name|head
operator|||
name|cur
operator|>
name|kring
operator|->
name|rtail
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
comment|/* here rtail< rhead */
comment|/* we need head outside rtail .. rhead */
if|if
condition|(
name|head
operator|>
name|kring
operator|->
name|rtail
operator|&&
name|head
operator|<
name|kring
operator|->
name|rhead
condition|)
goto|goto
name|error
goto|;
comment|/* two cases now: head<= rtail or head>= rhead  */
if|if
condition|(
name|head
operator|<=
name|kring
operator|->
name|rtail
condition|)
block|{
comment|/* want head<= cur<= rtail */
if|if
condition|(
name|cur
operator|<
name|head
operator|||
name|cur
operator|>
name|kring
operator|->
name|rtail
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
comment|/* head>= rhead */
comment|/* cur must be outside rtail..head */
if|if
condition|(
name|cur
operator|>
name|kring
operator|->
name|rtail
operator|&&
name|cur
operator|<
name|head
condition|)
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
name|ring
operator|->
name|tail
operator|!=
name|kring
operator|->
name|rtail
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"tail overwritten was %d need %d"
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|tail
operator|=
name|kring
operator|->
name|rtail
expr_stmt|;
block|}
name|kring
operator|->
name|rhead
operator|=
name|head
expr_stmt|;
name|kring
operator|->
name|rcur
operator|=
name|cur
expr_stmt|;
return|return
name|head
return|;
name|error
label|:
name|RD
argument_list|(
literal|5
argument_list|,
literal|"%s kring error: hwcur %d rcur %d hwtail %d cur %d tail %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|cur
argument_list|,
name|ring
operator|->
name|tail
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * validate parameters on entry for *_rxsync()  * Returns ring->head if ok, kring->nkr_num_slots on error.  *  * For a valid configuration,  * hwcur<= head<= cur<= tail<= hwtail  *  * We only consider head and cur.  * hwcur and hwtail are reliable.  *  */
end_comment

begin_function
name|u_int
name|nm_rxsync_prologue
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|uint32_t
specifier|const
name|n
init|=
name|kring
operator|->
name|nkr_num_slots
decl_stmt|;
name|uint32_t
name|head
decl_stmt|,
name|cur
decl_stmt|;
name|ND
argument_list|(
literal|"%s kc %d kt %d h %d c %d t %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|ring
operator|->
name|head
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|ring
operator|->
name|tail
argument_list|)
expr_stmt|;
comment|/* 	 * Before storing the new values, we should check they do not 	 * move backwards. However: 	 * - head is not an issue because the previous value is hwcur; 	 * - cur could in principle go back, however it does not matter 	 *   because we are processing a brand new rxsync() 	 */
name|cur
operator|=
name|kring
operator|->
name|rcur
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
comment|/* read only once */
name|head
operator|=
name|kring
operator|->
name|rhead
operator|=
name|ring
operator|->
name|head
expr_stmt|;
comment|/* read only once */
if|#
directive|if
literal|1
comment|/* kernel sanity checks */
if|if
condition|(
name|kring
operator|->
name|nr_hwcur
operator|>=
name|n
operator|||
name|kring
operator|->
name|nr_hwtail
operator|>=
name|n
condition|)
goto|goto
name|error
goto|;
endif|#
directive|endif
comment|/* kernel sanity checks */
comment|/* user sanity checks */
if|if
condition|(
name|kring
operator|->
name|nr_hwtail
operator|>=
name|kring
operator|->
name|nr_hwcur
condition|)
block|{
comment|/* want hwcur<= rhead<= hwtail */
if|if
condition|(
name|head
operator|<
name|kring
operator|->
name|nr_hwcur
operator|||
name|head
operator|>
name|kring
operator|->
name|nr_hwtail
condition|)
goto|goto
name|error
goto|;
comment|/* and also rhead<= rcur<= hwtail */
if|if
condition|(
name|cur
operator|<
name|head
operator|||
name|cur
operator|>
name|kring
operator|->
name|nr_hwtail
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
comment|/* we need rhead outside hwtail..hwcur */
if|if
condition|(
name|head
operator|<
name|kring
operator|->
name|nr_hwcur
operator|&&
name|head
operator|>
name|kring
operator|->
name|nr_hwtail
condition|)
goto|goto
name|error
goto|;
comment|/* two cases now: head<= hwtail or head>= hwcur  */
if|if
condition|(
name|head
operator|<=
name|kring
operator|->
name|nr_hwtail
condition|)
block|{
comment|/* want head<= cur<= hwtail */
if|if
condition|(
name|cur
operator|<
name|head
operator|||
name|cur
operator|>
name|kring
operator|->
name|nr_hwtail
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
comment|/* cur must be outside hwtail..head */
if|if
condition|(
name|cur
operator|<
name|head
operator|&&
name|cur
operator|>
name|kring
operator|->
name|nr_hwtail
condition|)
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
name|ring
operator|->
name|tail
operator|!=
name|kring
operator|->
name|rtail
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"%s tail overwritten was %d need %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|tail
operator|=
name|kring
operator|->
name|rtail
expr_stmt|;
block|}
return|return
name|head
return|;
name|error
label|:
name|RD
argument_list|(
literal|5
argument_list|,
literal|"kring error: hwcur %d rcur %d hwtail %d head %d cur %d tail %d"
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|kring
operator|->
name|rhead
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|ring
operator|->
name|tail
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Error routine called when txsync/rxsync detects an error.  * Can't do much more than resetting head =cur = hwcur, tail = hwtail  * Return 1 on reinit.  *  * This routine is only called by the upper half of the kernel.  * It only reads hwcur (which is changed only by the upper half, too)  * and hwtail (which may be changed by the lower half, but only on  * a tx ring and only to increase it, so any error will be recovered  * on the next call). For the above, we don't strictly need to call  * it under lock.  */
end_comment

begin_function
name|int
name|netmap_ring_reinit
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
comment|// XXX KASSERT nm_kr_tryget
name|RD
argument_list|(
literal|10
argument_list|,
literal|"called for %s"
argument_list|,
name|kring
operator|->
name|name
argument_list|)
expr_stmt|;
comment|// XXX probably wrong to trust userspace
name|kring
operator|->
name|rhead
operator|=
name|ring
operator|->
name|head
expr_stmt|;
name|kring
operator|->
name|rcur
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|kring
operator|->
name|rtail
operator|=
name|ring
operator|->
name|tail
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|cur
operator|>
name|lim
condition|)
name|errors
operator|++
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|head
operator|>
name|lim
condition|)
name|errors
operator|++
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|tail
operator|>
name|lim
condition|)
name|errors
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|idx
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
decl_stmt|;
name|u_int
name|len
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|2
operator|||
name|idx
operator|>=
name|netmap_total_buffers
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"bad index at slot %d idx %d len %d "
argument_list|,
name|i
argument_list|,
name|idx
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
name|NETMAP_BUF_SIZE
argument_list|(
name|kring
operator|->
name|na
argument_list|)
condition|)
block|{
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|RD
argument_list|(
literal|5
argument_list|,
literal|"bad len at slot %d idx %d len %d"
argument_list|,
name|i
argument_list|,
name|idx
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errors
condition|)
block|{
name|RD
argument_list|(
literal|10
argument_list|,
literal|"total %d errors"
argument_list|,
name|errors
argument_list|)
expr_stmt|;
name|RD
argument_list|(
literal|10
argument_list|,
literal|"%s reinit, cur %d -> %d tail %d -> %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|head
operator|=
name|kring
operator|->
name|rhead
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|rcur
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|ring
operator|->
name|tail
operator|=
name|kring
operator|->
name|rtail
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
block|}
return|return
operator|(
name|errors
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* interpret the ringid and flags fields of an nmreq, by translating them  * into a pair of intervals of ring indices:  *  * [priv->np_txqfirst, priv->np_txqlast) and  * [priv->np_rxqfirst, priv->np_rxqlast)  *  */
end_comment

begin_function
name|int
name|netmap_interp_ringid
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|uint16_t
name|ringid
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|u_int
name|j
decl_stmt|,
name|i
init|=
name|ringid
operator|&
name|NETMAP_RING_MASK
decl_stmt|;
name|u_int
name|reg
init|=
name|flags
operator|&
name|NR_REG_MASK
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|NR_REG_DEFAULT
condition|)
block|{
comment|/* convert from old ringid to flags */
if|if
condition|(
name|ringid
operator|&
name|NETMAP_SW_RING
condition|)
block|{
name|reg
operator|=
name|NR_REG_SW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ringid
operator|&
name|NETMAP_HW_RING
condition|)
block|{
name|reg
operator|=
name|NR_REG_ONE_NIC
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|NR_REG_ALL_NIC
expr_stmt|;
block|}
name|D
argument_list|(
literal|"deprecated API, old ringid 0x%x -> ringid %x reg %d"
argument_list|,
name|ringid
argument_list|,
name|i
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|NR_REG_ALL_NIC
case|:
case|case
name|NR_REG_PIPE_MASTER
case|:
case|case
name|NR_REG_PIPE_SLAVE
case|:
name|priv
operator|->
name|np_txqfirst
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|np_txqlast
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|priv
operator|->
name|np_rxqfirst
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|np_rxqlast
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|ND
argument_list|(
literal|"%s %d %d"
argument_list|,
literal|"ALL/PIPE"
argument_list|,
name|priv
operator|->
name|np_rxqfirst
argument_list|,
name|priv
operator|->
name|np_rxqlast
argument_list|)
expr_stmt|;
break|break;
case|case
name|NR_REG_SW
case|:
case|case
name|NR_REG_NIC_SW
case|:
if|if
condition|(
operator|!
operator|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_HOST_RINGS
operator|)
condition|)
block|{
name|D
argument_list|(
literal|"host rings not supported"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|priv
operator|->
name|np_txqfirst
operator|=
operator|(
name|reg
operator|==
name|NR_REG_SW
condition|?
name|na
operator|->
name|num_tx_rings
else|:
literal|0
operator|)
expr_stmt|;
name|priv
operator|->
name|np_txqlast
operator|=
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
expr_stmt|;
name|priv
operator|->
name|np_rxqfirst
operator|=
operator|(
name|reg
operator|==
name|NR_REG_SW
condition|?
name|na
operator|->
name|num_rx_rings
else|:
literal|0
operator|)
expr_stmt|;
name|priv
operator|->
name|np_rxqlast
operator|=
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
expr_stmt|;
name|ND
argument_list|(
literal|"%s %d %d"
argument_list|,
name|reg
operator|==
name|NR_REG_SW
condition|?
literal|"SW"
else|:
literal|"NIC+SW"
argument_list|,
name|priv
operator|->
name|np_rxqfirst
argument_list|,
name|priv
operator|->
name|np_rxqlast
argument_list|)
expr_stmt|;
break|break;
case|case
name|NR_REG_ONE_NIC
case|:
if|if
condition|(
name|i
operator|>=
name|na
operator|->
name|num_tx_rings
operator|&&
name|i
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
block|{
name|D
argument_list|(
literal|"invalid ring id %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* if not enough rings, use the first one */
name|j
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|na
operator|->
name|num_tx_rings
condition|)
name|j
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|np_txqfirst
operator|=
name|j
expr_stmt|;
name|priv
operator|->
name|np_txqlast
operator|=
name|j
operator|+
literal|1
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
name|j
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|np_rxqfirst
operator|=
name|j
expr_stmt|;
name|priv
operator|->
name|np_rxqlast
operator|=
name|j
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
name|D
argument_list|(
literal|"invalid regif type %d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|priv
operator|->
name|np_flags
operator|=
operator|(
name|flags
operator|&
operator|~
name|NR_REG_MASK
operator|)
operator||
name|reg
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
block|{
name|D
argument_list|(
literal|"%s: tx [%d,%d) rx [%d,%d) id %d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|priv
operator|->
name|np_txqfirst
argument_list|,
name|priv
operator|->
name|np_txqlast
argument_list|,
name|priv
operator|->
name|np_rxqfirst
argument_list|,
name|priv
operator|->
name|np_rxqlast
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Set the ring ID. For devices with a single queue, a request  * for all rings is the same as a single ring.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_set_ringid
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|uint16_t
name|ringid
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|netmap_interp_ringid
argument_list|(
name|priv
argument_list|,
name|ringid
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|priv
operator|->
name|np_txpoll
operator|=
operator|(
name|ringid
operator|&
name|NETMAP_NO_TX_POLL
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/* optimization: count the users registered for more than 	 * one ring, which are the ones sleeping on the global queue. 	 * The default netmap_notify() callback will then 	 * avoid signaling the global queue if nobody is using it 	 */
if|if
condition|(
name|nm_tx_si_user
argument_list|(
name|priv
argument_list|)
condition|)
name|na
operator|->
name|tx_si_users
operator|++
expr_stmt|;
if|if
condition|(
name|nm_rx_si_user
argument_list|(
name|priv
argument_list|)
condition|)
name|na
operator|->
name|rx_si_users
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * possibly move the interface to netmap-mode.  * If success it returns a pointer to netmap_if, otherwise NULL.  * This must be called with NMG_LOCK held.  *  * The following na callbacks are called in the process:  *  * na->nm_config()			[by netmap_update_config]  * (get current number and size of rings)  *  *  	We have a generic one for linux (netmap_linux_config).  *  	The bwrap has to override this, since it has to forward  *  	the request to the wrapped adapter (netmap_bwrap_config).  *  *    	XXX netmap_if_new calls this again (2014-03-15)  *  * na->nm_krings_create()		[by netmap_if_new]  * (create and init the krings array)  *  * 	One of the following:  *  *	* netmap_hw_krings_create, 			(hw ports)  *		creates the standard layout for the krings  * 		and adds the mbq (used for the host rings).  *  * 	* netmap_vp_krings_create			(VALE ports)  * 		add leases and scratchpads  *  * 	* netmap_pipe_krings_create			(pipes)  * 		create the krings and rings of both ends and  * 		cross-link them  *  *      * netmap_monitor_krings_create 			(monitors)  *      	avoid allocating the mbq  *  *      * netmap_bwrap_krings_create			(bwraps)  *      	create both the brap krings array,  *      	the krings array of the wrapped adapter, and  *      	(if needed) the fake array for the host adapter  *  * na->nm_register(, 1)  * (put the adapter in netmap mode)  *  * 	This may be one of the following:  * 	(XXX these should be either all *_register or all *_reg 2014-03-15)  *  * 	* netmap_hw_register				(hw ports)  * 		checks that the ifp is still there, then calls  * 		the hardware specific callback;  *  * 	* netmap_vp_reg					(VALE ports)  *		If the port is connected to a bridge,  *		set the NAF_NETMAP_ON flag under the  *		bridge write lock.  *  *	* netmap_pipe_reg				(pipes)  *		inform the other pipe end that it is no  *		longer responsibile for the lifetime of this  *		pipe end  *  *	* netmap_monitor_reg				(monitors)  *		intercept the sync callbacks of the monitored  *		rings  *  *	* netmap_bwrap_register				(bwraps)  *		cross-link the bwrap and hwna rings,  *		forward the request to the hwna, override  *		the hwna notify callback (to get the frames  *		coming from outside go through the bridge).  *  * XXX maybe netmap_if_new() should be merged with this (2014-03-15).  *  */
end_comment

begin_function
name|struct
name|netmap_if
modifier|*
name|netmap_do_regif
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|uint16_t
name|ringid
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|,
name|need_mem
init|=
literal|0
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* ring configuration may have changed, fetch from the card */
name|netmap_update_config
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_na
operator|=
name|na
expr_stmt|;
comment|/* store the reference */
name|error
operator|=
name|netmap_set_ringid
argument_list|(
name|priv
argument_list|,
name|ringid
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* ensure allocators are ready */
name|need_mem
operator|=
operator|!
name|netmap_have_memory_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_mem
condition|)
block|{
name|error
operator|=
name|netmap_get_memory_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"get_memory returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* Allocate a netmap_if and, if necessary, all the netmap_ring's */
name|nifp
operator|=
name|netmap_if_new
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
block|{
comment|/* allocation failed */
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|na
operator|->
name|active_fds
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|nm_netmap_on
argument_list|(
name|na
argument_list|)
condition|)
block|{
comment|/* Netmap not active, set the card in netmap mode 		 * and make it use the shared buffers. 		 */
comment|/* cache the allocator info in the na */
name|na
operator|->
name|na_lut
operator|=
name|netmap_mem_get_lut
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"%p->na_lut == %p"
argument_list|,
name|na
argument_list|,
name|na
operator|->
name|na_lut
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_lut_objtotal
operator|=
name|netmap_mem_get_buftotal
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_lut_objsize
operator|=
name|netmap_mem_get_bufsize
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
expr_stmt|;
name|error
operator|=
name|na
operator|->
name|nm_register
argument_list|(
name|na
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* mode on */
if|if
condition|(
name|error
condition|)
block|{
name|netmap_do_unregif
argument_list|(
name|priv
argument_list|,
name|nifp
argument_list|)
expr_stmt|;
name|nifp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|out
label|:
operator|*
name|err
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* we should drop the allocator, but only 		 * if we were the ones who grabbed it 		 */
if|if
condition|(
name|need_mem
condition|)
name|netmap_drop_memory_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_na
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|nifp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * advertise that the interface is ready bt setting ni_nifp. 		 * The barrier is needed because readers (poll and *SYNC) 		 * check for priv->np_nifp != NULL without locking 		 */
name|wmb
argument_list|()
expr_stmt|;
comment|/* make sure previous writes are visible to all CPUs */
name|priv
operator|->
name|np_nifp
operator|=
name|nifp
expr_stmt|;
block|}
return|return
name|nifp
return|;
block|}
end_function

begin_comment
comment|/*  * ioctl(2) support for the "netmap" device.  *  * Following a list of accepted commands:  * - NIOCGINFO  * - SIOCGIFADDR	just for convenience  * - NIOCREGIF  * - NIOCTXSYNC  * - NIOCRXSYNC  *  * Return 0 on success, errno otherwise.  */
end_comment

begin_function
name|int
name|netmap_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|struct
name|nmreq
modifier|*
name|nmr
init|=
operator|(
expr|struct
name|nmreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|qfirst
decl_stmt|,
name|qlast
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|krings
decl_stmt|;
operator|(
name|void
operator|)
name|dev
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|fflag
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
name|cmd
operator|==
name|NIOCGINFO
operator|||
name|cmd
operator|==
name|NIOCREGIF
condition|)
block|{
comment|/* truncate name */
name|nmr
operator|->
name|nr_name
index|[
sizeof|sizeof
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|!=
name|NETMAP_API
condition|)
block|{
name|D
argument_list|(
literal|"API mismatch for %s got %d need %d"
argument_list|,
name|nmr
operator|->
name|nr_name
argument_list|,
name|nmr
operator|->
name|nr_version
argument_list|,
name|NETMAP_API
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
block|}
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|<
name|NETMAP_MIN_API
operator|||
name|nmr
operator|->
name|nr_version
operator|>
name|NETMAP_MAX_API
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
block|}
name|CURVNET_SET
argument_list|(
name|TD_TO_VNET
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
comment|/* XXX ENOENT should be impossible, since the priv 		 * is now created in the open */
return|return
operator|(
name|error
operator|==
name|ENOENT
condition|?
name|ENXIO
else|:
name|error
operator|)
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NIOCGINFO
case|:
comment|/* return capabilities etc */
if|if
condition|(
name|nmr
operator|->
name|nr_cmd
operator|==
name|NETMAP_BDG_LIST
condition|)
block|{
name|error
operator|=
name|netmap_bdg_ctl
argument_list|(
name|nmr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|NMG_LOCK
argument_list|()
expr_stmt|;
do|do
block|{
comment|/* memsize is always valid */
name|struct
name|netmap_mem_d
modifier|*
name|nmd
init|=
operator|&
name|nm_mem
decl_stmt|;
name|u_int
name|memflags
decl_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* get a refcount */
name|error
operator|=
name|netmap_get_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
literal|1
comment|/* create */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|nmd
operator|=
name|na
operator|->
name|nm_mem
expr_stmt|;
comment|/* get memory allocator */
block|}
name|error
operator|=
name|netmap_mem_get_info
argument_list|(
name|nmd
argument_list|,
operator|&
name|nmr
operator|->
name|nr_memsize
argument_list|,
operator|&
name|memflags
argument_list|,
operator|&
name|nmr
operator|->
name|nr_arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
comment|/* only memory info */
break|break;
name|nmr
operator|->
name|nr_offset
operator|=
literal|0
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|nmr
operator|->
name|nr_tx_slots
operator|=
literal|0
expr_stmt|;
name|netmap_update_config
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|NIOCREGIF
case|:
comment|/* possibly attach/detach NIC and VALE switch */
name|i
operator|=
name|nmr
operator|->
name|nr_cmd
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NETMAP_BDG_ATTACH
operator|||
name|i
operator|==
name|NETMAP_BDG_DETACH
operator|||
name|i
operator|==
name|NETMAP_BDG_VNET_HDR
operator|||
name|i
operator|==
name|NETMAP_BDG_NEWIF
operator|||
name|i
operator|==
name|NETMAP_BDG_DELIF
condition|)
block|{
name|error
operator|=
name|netmap_bdg_ctl
argument_list|(
name|nmr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"nr_cmd must be 0 not %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* protect access to priv from concurrent NIOCREGIF */
name|NMG_LOCK
argument_list|()
expr_stmt|;
do|do
block|{
name|u_int
name|memflags
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_na
operator|!=
name|NULL
condition|)
block|{
comment|/* thread already registered */
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* find the interface and a reference */
name|error
operator|=
name|netmap_get_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
literal|1
comment|/* create */
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|NETMAP_OWNED_BY_KERN
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|nifp
operator|=
name|netmap_do_regif
argument_list|(
name|priv
argument_list|,
name|na
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|,
name|nmr
operator|->
name|nr_flags
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nifp
condition|)
block|{
comment|/* reg. failed, release priv and ref */
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_nifp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|priv
operator|->
name|np_td
operator|=
name|td
expr_stmt|;
comment|// XXX kqueue, debugging only
comment|/* return the offset of the netmap_if object */
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|error
operator|=
name|netmap_mem_get_info
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
operator|&
name|nmr
operator|->
name|nr_memsize
argument_list|,
operator|&
name|memflags
argument_list|,
operator|&
name|nmr
operator|->
name|nr_arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|memflags
operator|&
name|NETMAP_MEM_PRIVATE
condition|)
block|{
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|nifp
operator|->
name|ni_flags
operator||=
name|NI_PRIV_MEM
expr_stmt|;
block|}
name|priv
operator|->
name|np_txsi
operator|=
operator|(
name|priv
operator|->
name|np_txqlast
operator|-
name|priv
operator|->
name|np_txqfirst
operator|>
literal|1
operator|)
condition|?
operator|&
name|na
operator|->
name|tx_si
else|:
operator|&
name|na
operator|->
name|tx_rings
index|[
name|priv
operator|->
name|np_txqfirst
index|]
operator|.
name|si
expr_stmt|;
name|priv
operator|->
name|np_rxsi
operator|=
operator|(
name|priv
operator|->
name|np_rxqlast
operator|-
name|priv
operator|->
name|np_rxqfirst
operator|>
literal|1
operator|)
condition|?
operator|&
name|na
operator|->
name|rx_si
else|:
operator|&
name|na
operator|->
name|rx_rings
index|[
name|priv
operator|->
name|np_rxqfirst
index|]
operator|.
name|si
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_arg3
condition|)
block|{
name|D
argument_list|(
literal|"requested %d extra buffers"
argument_list|,
name|nmr
operator|->
name|nr_arg3
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_arg3
operator|=
name|netmap_extra_alloc
argument_list|(
name|na
argument_list|,
operator|&
name|nifp
operator|->
name|ni_bufs_head
argument_list|,
name|nmr
operator|->
name|nr_arg3
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"got %d extra buffers"
argument_list|,
name|nmr
operator|->
name|nr_arg3
argument_list|)
expr_stmt|;
block|}
name|nmr
operator|->
name|nr_offset
operator|=
name|netmap_mem_if_offset
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
name|nifp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|NIOCTXSYNC
case|:
case|case
name|NIOCRXSYNC
case|:
name|nifp
operator|=
name|priv
operator|->
name|np_nifp
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|rmb
argument_list|()
expr_stmt|;
comment|/* make sure following reads are not from cache */
name|na
operator|=
name|priv
operator|->
name|np_na
expr_stmt|;
comment|/* we have a reference */
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"Internal error: nifp != NULL&& na == NULL"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|nm_netmap_on
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
block|{
name|krings
operator|=
name|na
operator|->
name|tx_rings
expr_stmt|;
name|qfirst
operator|=
name|priv
operator|->
name|np_txqfirst
expr_stmt|;
name|qlast
operator|=
name|priv
operator|->
name|np_txqlast
expr_stmt|;
block|}
else|else
block|{
name|krings
operator|=
name|na
operator|->
name|rx_rings
expr_stmt|;
name|qfirst
operator|=
name|priv
operator|->
name|np_rxqfirst
expr_stmt|;
name|qlast
operator|=
name|priv
operator|->
name|np_rxqlast
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|qfirst
init|;
name|i
operator|<
name|qlast
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
name|krings
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
block|{
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"pre txsync ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_txsync_prologue
argument_list|(
name|kring
argument_list|)
operator|>=
name|kring
operator|->
name|nkr_num_slots
condition|)
block|{
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kring
operator|->
name|nm_sync
argument_list|(
name|kring
argument_list|,
name|NAF_FORCE_RECLAIM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"post txsync ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kring
operator|->
name|nm_sync
argument_list|(
name|kring
argument_list|,
name|NAF_FORCE_READ
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NIOCCONFIG
case|:
name|error
operator|=
name|netmap_bdg_config
argument_list|(
name|nmr
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|__FreeBSD__
case|case
name|FIONBIO
case|:
case|case
name|FIOASYNC
case|:
name|ND
argument_list|(
literal|"FIONBIO/FIOASYNC are no-ops"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOCIMMEDIATE
case|:
case|case
name|BIOCGHDRCMPLT
case|:
case|case
name|BIOCSHDRCMPLT
case|:
case|case
name|BIOCSSEESENT
case|:
name|D
argument_list|(
literal|"ignore BIOCIMMEDIATE/BIOCSHDRCMPLT/BIOCSHDRCMPLT/BIOCSSEESENT"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* allow device-specific ioctls */
block|{
name|struct
name|socket
name|so
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|so
argument_list|,
sizeof|sizeof
argument_list|(
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_get_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
literal|0
comment|/* don't create */
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
block|{
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
name|ifp
operator|=
name|na
operator|->
name|ifp
expr_stmt|;
name|so
operator|.
name|so_vnet
operator|=
name|ifp
operator|->
name|if_vnet
expr_stmt|;
comment|// so->so_proto not null.
name|error
operator|=
name|ifioctl
argument_list|(
operator|&
name|so
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
else|#
directive|else
comment|/* linux */
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
comment|/* linux */
block|}
name|out
label|:
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * select(2) and poll(2) handlers for the "netmap" device.  *  * Can be called for one or more queues.  * Return true the event mask corresponding to ready events.  * If there are no ready events, do a selrecord on either individual  * selinfo or on the global one.  * Device-dependent parts (locking and sync of tx/rx rings)  * are done through callbacks.  *  * On linux, arguments are really pwait, the poll table, and 'td' is struct file *  * The first one is remapped to pwait as selrecord() uses the name as an  * hidden argument.  */
end_comment

begin_function
name|int
name|netmap_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|check_all_tx
decl_stmt|,
name|check_all_rx
decl_stmt|,
name|want_tx
decl_stmt|,
name|want_rx
decl_stmt|,
name|revents
init|=
literal|0
decl_stmt|;
name|struct
name|mbq
name|q
decl_stmt|;
comment|/* packets from hw queues to host stack */
name|void
modifier|*
name|pwait
init|=
name|dev
decl_stmt|;
comment|/* linux compatibility */
name|int
name|is_kevent
init|=
literal|0
decl_stmt|;
comment|/* 	 * In order to avoid nested locks, we need to "double check" 	 * txsync and rxsync if we decide to do a selrecord(). 	 * retry_tx (and retry_rx, later) prevent looping forever. 	 */
name|int
name|retry_tx
init|=
literal|1
decl_stmt|,
name|retry_rx
init|=
literal|1
decl_stmt|;
operator|(
name|void
operator|)
name|pwait
expr_stmt|;
name|mbq_init
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
comment|/* 	 * XXX kevent has curthread->tp_fop == NULL, 	 * so devfs_get_cdevpriv() fails. We circumvent this by passing 	 * priv as the first argument, which is also useful to avoid 	 * the selrecord() which are not necessary in that case. 	 */
if|if
condition|(
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|is_kevent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"called from kevent"
argument_list|)
expr_stmt|;
name|priv
operator|=
operator|(
expr|struct
name|netmap_priv_d
operator|*
operator|)
name|dev
expr_stmt|;
block|}
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
name|POLLERR
return|;
if|if
condition|(
name|priv
operator|->
name|np_nifp
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"No if registered"
argument_list|)
expr_stmt|;
return|return
name|POLLERR
return|;
block|}
name|rmb
argument_list|()
expr_stmt|;
comment|/* make sure following reads are not from cache */
name|na
operator|=
name|priv
operator|->
name|np_na
expr_stmt|;
if|if
condition|(
operator|!
name|nm_netmap_on
argument_list|(
name|na
argument_list|)
condition|)
return|return
name|POLLERR
return|;
if|if
condition|(
name|netmap_verbose
operator|&
literal|0x8000
condition|)
name|D
argument_list|(
literal|"device %s events 0x%x"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|events
argument_list|)
expr_stmt|;
name|want_tx
operator|=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
name|want_rx
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
comment|/* 	 * check_all_{tx|rx} are set if the card has more than one queue AND 	 * the file descriptor is bound to all of them. If so, we sleep on 	 * the "global" selinfo, otherwise we sleep on individual selinfo 	 * (FreeBSD only allows two selinfo's per file descriptor). 	 * The interrupt routine in the driver wake one or the other 	 * (or both) depending on which clients are active. 	 * 	 * rxsync() is only called if we run out of buffers on a POLLIN. 	 * txsync() is called if we run out of buffers on POLLOUT, or 	 * there are pending packets to send. The latter can be disabled 	 * passing NETMAP_NO_TX_POLL in the NIOCREG call. 	 */
name|check_all_tx
operator|=
name|nm_tx_si_user
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|check_all_rx
operator|=
name|nm_rx_si_user
argument_list|(
name|priv
argument_list|)
expr_stmt|;
comment|/* 	 * We start with a lock free round which is cheap if we have 	 * slots available. If this fails, then lock and call the sync 	 * routines. 	 */
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_rxqfirst
init|;
name|want_rx
operator|&&
name|i
operator|<
name|priv
operator|->
name|np_rxqlast
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
comment|/* XXX compare ring->cur and kring->tail */
if|if
condition|(
operator|!
name|nm_ring_empty
argument_list|(
name|kring
operator|->
name|ring
argument_list|)
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
name|want_rx
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_txqfirst
init|;
name|want_tx
operator|&&
name|i
operator|<
name|priv
operator|->
name|np_txqlast
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
comment|/* XXX compare ring->cur and kring->tail */
if|if
condition|(
operator|!
name|nm_ring_empty
argument_list|(
name|kring
operator|->
name|ring
argument_list|)
condition|)
block|{
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
comment|/* 	 * If we want to push packets out (priv->np_txpoll) or 	 * want_tx is still set, we must issue txsync calls 	 * (on all rings, to avoid that the tx rings stall). 	 * XXX should also check cur != hwcur on the tx rings. 	 * Fortunately, normal tx mode has np_txpoll set. 	 */
if|if
condition|(
name|priv
operator|->
name|np_txpoll
operator|||
name|want_tx
condition|)
block|{
comment|/* 		 * The first round checks if anyone is ready, if not 		 * do a selrecord and another round to handle races. 		 * want_tx goes to 0 if any space is found, and is 		 * used to skip rings with no pending transmissions. 		 */
name|flush_tx
label|:
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_txqfirst
init|;
name|i
operator|<
name|priv
operator|->
name|np_txqlast
condition|;
name|i
operator|++
control|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|want_tx
operator|&&
name|kring
operator|->
name|ring
operator|->
name|cur
operator|==
name|kring
operator|->
name|nr_hwcur
condition|)
continue|continue;
comment|/* only one thread does txsync */
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|)
condition|)
block|{
comment|/* either busy or stopped 				 * XXX if the ring is stopped, sleeping would 				 * be better. In current code, however, we only 				 * stop the rings for brief intervals (2014-03-14) 				 */
if|if
condition|(
name|netmap_verbose
condition|)
name|RD
argument_list|(
literal|2
argument_list|,
literal|"%p lost race on txring %d, ok"
argument_list|,
name|priv
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nm_txsync_prologue
argument_list|(
name|kring
argument_list|)
operator|>=
name|kring
operator|->
name|nkr_num_slots
condition|)
block|{
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|revents
operator||=
name|POLLERR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|kring
operator|->
name|nm_sync
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
block|}
comment|/* 			 * If we found new slots, notify potential 			 * listeners on the same ring. 			 * Since we just did a txsync, look at the copies 			 * of cur,tail in the kring. 			 */
name|found
operator|=
name|kring
operator|->
name|rcur
operator|!=
name|kring
operator|->
name|rtail
expr_stmt|;
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
comment|/* notify other listeners */
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
name|na
operator|->
name|nm_notify
argument_list|(
name|na
argument_list|,
name|i
argument_list|,
name|NR_TX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|want_tx
operator|&&
name|retry_tx
operator|&&
operator|!
name|is_kevent
condition|)
block|{
name|selrecord
argument_list|(
name|td
argument_list|,
name|check_all_tx
condition|?
operator|&
name|na
operator|->
name|tx_si
else|:
operator|&
name|na
operator|->
name|tx_rings
index|[
name|priv
operator|->
name|np_txqfirst
index|]
operator|.
name|si
argument_list|)
expr_stmt|;
name|retry_tx
operator|=
literal|0
expr_stmt|;
goto|goto
name|flush_tx
goto|;
block|}
block|}
comment|/* 	 * If want_rx is still set scan receive rings. 	 * Do it on all rings because otherwise we starve. 	 */
if|if
condition|(
name|want_rx
condition|)
block|{
name|int
name|send_down
init|=
literal|0
decl_stmt|;
comment|/* transparent mode */
comment|/* two rounds here for race avoidance */
name|do_retry_rx
label|:
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_rxqfirst
init|;
name|i
operator|<
name|priv
operator|->
name|np_rxqlast
condition|;
name|i
operator|++
control|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|)
condition|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
name|RD
argument_list|(
literal|2
argument_list|,
literal|"%p lost race on rxring %d, ok"
argument_list|,
name|priv
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * transparent mode support: collect packets 			 * from the rxring(s). 			 * XXX NR_FORWARD should only be read on 			 * physical or NIC ports 			 */
if|if
condition|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
condition|)
block|{
name|ND
argument_list|(
literal|10
argument_list|,
literal|"forwarding some buffers up %d to %d"
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|netmap_grab_packets
argument_list|(
name|kring
argument_list|,
operator|&
name|q
argument_list|,
name|netmap_fwd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kring
operator|->
name|nm_sync
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
if|if
condition|(
name|netmap_no_timestamp
operator|==
literal|0
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_TIMESTAMP
condition|)
block|{
name|microtime
argument_list|(
operator|&
name|kring
operator|->
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
comment|/* after an rxsync we can use kring->rcur, rtail */
name|found
operator|=
name|kring
operator|->
name|rcur
operator|!=
name|kring
operator|->
name|rtail
expr_stmt|;
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
name|retry_rx
operator|=
literal|0
expr_stmt|;
name|na
operator|->
name|nm_notify
argument_list|(
name|na
argument_list|,
name|i
argument_list|,
name|NR_RX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* transparent mode XXX only during first pass ? */
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_HOST_RINGS
condition|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
expr_stmt|;
if|if
condition|(
name|check_all_rx
operator|&&
operator|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
operator|)
condition|)
block|{
comment|/* XXX fix to use kring fields */
if|if
condition|(
name|nm_ring_empty
argument_list|(
name|kring
operator|->
name|ring
argument_list|)
condition|)
name|send_down
operator|=
name|netmap_rxsync_from_host
argument_list|(
name|na
argument_list|,
name|td
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm_ring_empty
argument_list|(
name|kring
operator|->
name|ring
argument_list|)
condition|)
name|revents
operator||=
name|want_rx
expr_stmt|;
block|}
block|}
if|if
condition|(
name|retry_rx
operator|&&
operator|!
name|is_kevent
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
name|check_all_rx
condition|?
operator|&
name|na
operator|->
name|rx_si
else|:
operator|&
name|na
operator|->
name|rx_rings
index|[
name|priv
operator|->
name|np_rxqfirst
index|]
operator|.
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_down
operator|>
literal|0
operator|||
name|retry_rx
condition|)
block|{
name|retry_rx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|send_down
condition|)
goto|goto
name|flush_tx
goto|;
comment|/* and retry_rx */
else|else
goto|goto
name|do_retry_rx
goto|;
block|}
block|}
comment|/* 	 * Transparent mode: marked bufs on rx rings between 	 * kring->nr_hwcur and ring->head 	 * are passed to the other endpoint. 	 * 	 * In this mode we also scan the sw rxring, which in 	 * turn passes packets up. 	 * 	 * XXX Transparent mode at the moment requires to bind all  	 * rings to a single file descriptor. 	 */
if|if
condition|(
name|q
operator|.
name|head
operator|&&
name|na
operator|->
name|ifp
operator|!=
name|NULL
condition|)
name|netmap_send_up
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
operator|&
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-------------------- driver support routines -------------------*/
end_comment

begin_function_decl
specifier|static
name|int
name|netmap_hw_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* default notify callback */
end_comment

begin_function
specifier|static
name|int
name|netmap_notify
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|n_ring
parameter_list|,
name|enum
name|txrx
name|tx
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
block|{
name|kring
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|n_ring
expr_stmt|;
name|OS_selwakeup
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
comment|/* optimization: avoid a wake up on the global 		 * queue if nobody has registered for more 		 * than one ring 		 */
if|if
condition|(
name|na
operator|->
name|tx_si_users
operator|>
literal|0
condition|)
name|OS_selwakeup
argument_list|(
operator|&
name|na
operator|->
name|tx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kring
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|n_ring
expr_stmt|;
name|OS_selwakeup
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
comment|/* optimization: same as above */
if|if
condition|(
name|na
operator|->
name|rx_si_users
operator|>
literal|0
condition|)
name|OS_selwakeup
argument_list|(
operator|&
name|na
operator|->
name|rx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* called by all routines that create netmap_adapters.  * Attach na to the ifp (if any) and provide defaults  * for optional callbacks. Defaults assume that we  * are creating an hardware netmap_adapter.  */
end_comment

begin_function
name|int
name|netmap_attach_common
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|==
literal|0
operator|||
name|na
operator|->
name|num_rx_rings
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"%s: invalid rings tx %d rx %d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|na
operator|->
name|num_tx_rings
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* ifp is NULL for virtual adapters (bwrap, non-persistent VALE ports, 	 * pipes, monitors). For bwrap we actually have a non-null ifp for 	 * use by the external modules, but that is set after this 	 * function has been called. 	 * XXX this is ugly, maybe split this function in two (2014-03-14) 	 */
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|WNA
argument_list|(
name|ifp
argument_list|)
operator|=
name|na
expr_stmt|;
comment|/* the following is only needed for na that use the host port. 	 * XXX do we have something similar for linux ? 	 */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|na
operator|->
name|if_input
operator|=
name|ifp
operator|->
name|if_input
expr_stmt|;
comment|/* for netmap_send_up */
endif|#
directive|endif
comment|/* __FreeBSD__ */
name|NETMAP_SET_CAPABLE
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|nm_krings_create
operator|==
name|NULL
condition|)
block|{
comment|/* we assume that we have been called by a driver, 		 * since other port types all provide their own 		 * nm_krings_create 		 */
name|na
operator|->
name|nm_krings_create
operator|=
name|netmap_hw_krings_create
expr_stmt|;
name|na
operator|->
name|nm_krings_delete
operator|=
name|netmap_hw_krings_delete
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|nm_notify
operator|==
name|NULL
condition|)
name|na
operator|->
name|nm_notify
operator|=
name|netmap_notify
expr_stmt|;
name|na
operator|->
name|active_fds
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_mem
operator|==
name|NULL
condition|)
comment|/* use the global allocator */
name|na
operator|->
name|nm_mem
operator|=
operator|&
name|nm_mem
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_bdg_attach
operator|==
name|NULL
condition|)
comment|/* no special nm_bdg_attach callback. On VALE 		 * attach, we need to interpose a bwrap 		 */
name|na
operator|->
name|nm_bdg_attach
operator|=
name|netmap_bwrap_attach
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* standard cleanup, called by all destructors */
end_comment

begin_function
name|void
name|netmap_detach_common
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
if|if
condition|(
name|na
operator|->
name|ifp
operator|!=
name|NULL
condition|)
name|WNA
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* XXX do we need this? */
if|if
condition|(
name|na
operator|->
name|tx_rings
condition|)
block|{
comment|/* XXX should not happen */
name|D
argument_list|(
literal|"freeing leftover tx_rings"
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
name|netmap_pipe_dealloc
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_MEM_OWNER
condition|)
name|netmap_mem_private_delete
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|na
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|na
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper for the register callback provided hardware drivers.  * na->ifp == NULL means the the driver module has been  * unloaded, so we cannot call into it.  * Note that module unloading, in our patched linux drivers,  * happens under NMG_LOCK and after having stopped all the  * nic rings (see netmap_detach). This provides sufficient  * protection for the other driver-provied callbacks  * (i.e., nm_config and nm_*xsync), that therefore don't need  * to wrapped.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_hw_register
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|netmap_hw_adapter
modifier|*
name|hwna
init|=
operator|(
expr|struct
name|netmap_hw_adapter
operator|*
operator|)
name|na
decl_stmt|;
if|if
condition|(
name|na
operator|->
name|ifp
operator|==
name|NULL
condition|)
return|return
name|onoff
condition|?
name|ENXIO
else|:
literal|0
return|;
return|return
name|hwna
operator|->
name|nm_hw_register
argument_list|(
name|na
argument_list|,
name|onoff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a ``netmap_adapter`` object created by driver on attach.  * We allocate a block of memory with room for a struct netmap_adapter  * plus two sets of N+2 struct netmap_kring (where N is the number  * of hardware rings):  * krings	0..N-1	are for the hardware queues.  * kring	N	is for the host stack queue  * kring	N+1	is only used for the selinfo for all queues. // XXX still true ?  * Return 0 on success, ENOMEM otherwise.  */
end_comment

begin_function
name|int
name|netmap_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|netmap_hw_adapter
modifier|*
name|hwna
init|=
name|NULL
decl_stmt|;
comment|// XXX when is arg == NULL ?
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|arg
condition|?
name|arg
operator|->
name|ifp
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
name|ifp
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|hwna
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hwna
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwna
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|hwna
operator|->
name|up
operator|=
operator|*
name|arg
expr_stmt|;
name|hwna
operator|->
name|up
operator|.
name|na_flags
operator||=
name|NAF_HOST_RINGS
expr_stmt|;
name|strncpy
argument_list|(
name|hwna
operator|->
name|up
operator|.
name|name
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|hwna
operator|->
name|up
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|hwna
operator|->
name|nm_hw_register
operator|=
name|hwna
operator|->
name|up
operator|.
name|nm_register
expr_stmt|;
name|hwna
operator|->
name|up
operator|.
name|nm_register
operator|=
name|netmap_hw_register
expr_stmt|;
if|if
condition|(
name|netmap_attach_common
argument_list|(
operator|&
name|hwna
operator|->
name|up
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|hwna
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|netmap_adapter_get
argument_list|(
operator|&
name|hwna
operator|->
name|up
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|linux
if|if
condition|(
name|ifp
operator|->
name|netdev_ops
condition|)
block|{
comment|/* prepare a clone of the netdev ops */
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|28
argument_list|)
name|hwna
operator|->
name|nm_ndo
operator|.
name|ndo_start_xmit
operator|=
name|ifp
operator|->
name|netdev_ops
expr_stmt|;
else|#
directive|else
name|hwna
operator|->
name|nm_ndo
operator|=
operator|*
name|ifp
operator|->
name|netdev_ops
expr_stmt|;
endif|#
directive|endif
block|}
name|hwna
operator|->
name|nm_ndo
operator|.
name|ndo_start_xmit
operator|=
name|linux_netmap_start_xmit
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|ethtool_ops
condition|)
block|{
name|hwna
operator|->
name|nm_eto
operator|=
operator|*
name|ifp
operator|->
name|ethtool_ops
expr_stmt|;
block|}
name|hwna
operator|->
name|nm_eto
operator|.
name|set_ringparam
operator|=
name|linux_netmap_set_ringparam
expr_stmt|;
ifdef|#
directive|ifdef
name|ETHTOOL_SCHANNELS
name|hwna
operator|->
name|nm_eto
operator|.
name|set_channels
operator|=
name|linux_netmap_set_channels
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|arg
operator|->
name|nm_config
operator|==
name|NULL
condition|)
block|{
name|hwna
operator|->
name|up
operator|.
name|nm_config
operator|=
name|netmap_linux_config
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* linux */
name|D
argument_list|(
literal|"success for %s tx %d/%d rx %d/%d queues/slots"
argument_list|,
name|hwna
operator|->
name|up
operator|.
name|name
argument_list|,
name|hwna
operator|->
name|up
operator|.
name|num_tx_rings
argument_list|,
name|hwna
operator|->
name|up
operator|.
name|num_tx_desc
argument_list|,
name|hwna
operator|->
name|up
operator|.
name|num_rx_rings
argument_list|,
name|hwna
operator|->
name|up
operator|.
name|num_rx_desc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|D
argument_list|(
literal|"fail, arg %p ifp %p na %p"
argument_list|,
name|arg
argument_list|,
name|ifp
argument_list|,
name|hwna
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
condition|)
name|netmap_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|hwna
condition|?
name|EINVAL
else|:
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
name|void
name|NM_DBG
function|(
name|netmap_adapter_get
function|)
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
if|if
condition|(
operator|!
name|na
condition|)
block|{
return|return;
block|}
name|refcount_acquire
argument_list|(
operator|&
name|na
operator|->
name|na_refcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* returns 1 iff the netmap_adapter is destroyed */
end_comment

begin_function
name|int
name|NM_DBG
function|(
name|netmap_adapter_put
function|)
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
if|if
condition|(
operator|!
name|na
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|refcount_release
argument_list|(
operator|&
name|na
operator|->
name|na_refcount
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|na
operator|->
name|nm_dtor
condition|)
name|na
operator|->
name|nm_dtor
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|netmap_detach_common
argument_list|(
name|na
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* nm_krings_create callback for all hardware native adapters */
end_comment

begin_function
name|int
name|netmap_hw_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|int
name|ret
init|=
name|netmap_krings_create
argument_list|(
name|na
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* initialize the mbq for the sw rx ring */
name|mbq_safe_init
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
operator|.
name|rx_queue
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"initialized sw rx queue %d"
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Called on module unload by the netmap-enabled drivers  */
end_comment

begin_function
name|void
name|netmap_detach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|na
condition|)
return|return;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|netmap_disable_all_rings
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
condition|)
block|{
comment|/* someone is still using the adapter, 		 * tell them that the interface is gone 		 */
name|na
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
comment|// XXX also clear NAF_NATIVE_ON ?
name|na
operator|->
name|na_flags
operator|&=
operator|~
name|NAF_NETMAP_ON
expr_stmt|;
comment|/* give them a chance to notice */
name|netmap_enable_all_rings
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Intercept packets from the network stack and pass them  * to netmap as incoming packets on the 'software' ring.  *  * We only store packets in a bounded mbq and then copy them  * in the relevant rxsync routine.  *  * We rely on the OS to make sure that the ifp and na do not go  * away (typically the caller checks for IFF_DRV_RUNNING or the like).  * In nm_register() or whenever there is a reinitialization,  * we make sure to make the mode change visible here.  */
end_comment

begin_function
name|int
name|netmap_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|u_int
name|len
init|=
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|u_int
name|error
init|=
name|ENOBUFS
decl_stmt|;
name|struct
name|mbq
modifier|*
name|q
decl_stmt|;
name|int
name|space
decl_stmt|;
comment|// XXX [Linux] we do not need this lock
comment|// if we follow the down/configure/up protocol -gl
comment|// mtx_lock(&na->core_lock);
if|if
condition|(
operator|!
name|nm_netmap_on
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"%s not in netmap mode anymore"
argument_list|,
name|na
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
expr_stmt|;
name|q
operator|=
operator|&
name|kring
operator|->
name|rx_queue
expr_stmt|;
comment|// XXX reconsider long packets if we handle fragments
if|if
condition|(
name|len
operator|>
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
condition|)
block|{
comment|/* too long for us */
name|D
argument_list|(
literal|"%s from_host, drop packet size %d> %d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|len
argument_list|,
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* protect against rxsync_from_host(), netmap_sw_to_nic() 	 * and maybe other instances of netmap_transmit (the latter 	 * not possible on Linux). 	 * Also avoid overflowing the queue. 	 */
name|mbq_lock
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|space
operator|=
name|kring
operator|->
name|nr_hwtail
operator|-
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|space
operator|<
literal|0
condition|)
name|space
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
if|if
condition|(
name|space
operator|+
name|mbq_len
argument_list|(
name|q
argument_list|)
operator|>=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
condition|)
block|{
comment|// XXX
name|RD
argument_list|(
literal|10
argument_list|,
literal|"%s full hwcur %d hwtail %d qlen %d len %d m %p"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|mbq_len
argument_list|(
name|q
argument_list|)
argument_list|,
name|len
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mbq_enqueue
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|10
argument_list|,
literal|"%s %d bufs in queue len %d m %p"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|mbq_len
argument_list|(
name|q
argument_list|)
argument_list|,
name|len
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* notify outside the lock */
name|m
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|mbq_unlock
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* unconditionally wake up listeners */
name|na
operator|->
name|nm_notify
argument_list|(
name|na
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|,
name|NR_RX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* this is normally netmap_notify(), but for nics 	 * connected to a bridge it is netmap_bwrap_intr_notify(), 	 * that possibly forwards the frames through the switch 	 */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * netmap_reset() is called by the driver routines when reinitializing  * a ring. The driver is in charge of locking to protect the kring.  * If native netmap mode is not set just return NULL.  */
end_comment

begin_function
name|struct
name|netmap_slot
modifier|*
name|netmap_reset
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|enum
name|txrx
name|tx
parameter_list|,
name|u_int
name|n
parameter_list|,
name|u_int
name|new_cur
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|int
name|new_hwofs
decl_stmt|,
name|lim
decl_stmt|;
if|if
condition|(
operator|!
name|nm_native_on
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|ND
argument_list|(
literal|"interface not in native netmap mode"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* nothing to reinitialize */
block|}
comment|/* XXX note- in the new scheme, we are not guaranteed to be 	 * under lock (e.g. when called on a device reset). 	 * In this case, we should set a flag and do not trust too 	 * much the values. In practice: TODO 	 * - set a RESET flag somewhere in the kring 	 * - do the processing in a conservative way 	 * - let the *sync() fixup at the end. 	 */
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|na
operator|->
name|num_tx_rings
condition|)
return|return
name|NULL
return|;
name|kring
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|n
expr_stmt|;
comment|// XXX check whether we should use hwcur or rcur
name|new_hwofs
operator|=
name|kring
operator|->
name|nr_hwcur
operator|-
name|new_cur
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|n
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
return|return
name|NULL
return|;
name|kring
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|n
expr_stmt|;
name|new_hwofs
operator|=
name|kring
operator|->
name|nr_hwtail
operator|-
name|new_cur
expr_stmt|;
block|}
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new_hwofs
operator|>
name|lim
condition|)
name|new_hwofs
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
comment|/* Always set the new offset value and realign the ring. */
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s %s%d hwofs %d -> %d, hwtail %d -> %d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|tx
operator|==
name|NR_TX
condition|?
literal|"TX"
else|:
literal|"RX"
argument_list|,
name|n
argument_list|,
name|kring
operator|->
name|nkr_hwofs
argument_list|,
name|new_hwofs
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|tx
operator|==
name|NR_TX
condition|?
name|lim
else|:
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nkr_hwofs
operator|=
name|new_hwofs
expr_stmt|;
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
block|{
name|kring
operator|->
name|nr_hwtail
operator|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|lim
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwtail
operator|>
name|lim
condition|)
name|kring
operator|->
name|nr_hwtail
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|// def linux
comment|/* XXX check that the mappings are correct */
comment|/* need ring_nr, adapter->pdev, direction */
block|buffer_info->dma = dma_map_single(&pdev->dev, addr, adapter->rx_buffer_len, DMA_FROM_DEVICE); 	if (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)) { 		D("error mapping rx netmap buffer %d", i);
comment|// XXX fix error handling
block|}
endif|#
directive|endif
comment|/* linux */
comment|/* 	 * Wakeup on the individual and global selwait 	 * We do the wakeup here, but the ring is not yet reconfigured. 	 * However, we are under lock so there are no races. 	 */
name|na
operator|->
name|nm_notify
argument_list|(
name|na
argument_list|,
name|n
argument_list|,
name|tx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|kring
operator|->
name|ring
operator|->
name|slot
return|;
block|}
end_function

begin_comment
comment|/*  * Dispatch rx/tx interrupts to the netmap rings.  *  * "work_done" is non-null on the RX path, NULL for the TX path.  * We rely on the OS to make sure that there is only one active  * instance per queue, and that there is appropriate locking.  *  * The 'notify' routine depends on what the ring is attached to.  * - for a netmap file descriptor, do a selwakeup on the individual  *   waitqueue, plus one on the global one if needed  *   (see netmap_notify)  * - for a nic connected to a switch, call the proper forwarding routine  *   (see netmap_bwrap_intr_notify)  */
end_comment

begin_function
name|void
name|netmap_common_irq
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|q
parameter_list|,
name|u_int
modifier|*
name|work_done
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|q
operator|&=
name|NETMAP_RING_MASK
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"received %s queue %d"
argument_list|,
name|work_done
condition|?
literal|"RX"
else|:
literal|"TX"
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|work_done
condition|)
block|{
comment|/* RX path */
if|if
condition|(
name|q
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
return|return;
comment|// not a physical queue
name|kring
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|q
expr_stmt|;
name|kring
operator|->
name|nr_kflags
operator||=
name|NKR_PENDINTR
expr_stmt|;
comment|// XXX atomic ?
name|na
operator|->
name|nm_notify
argument_list|(
name|na
argument_list|,
name|q
argument_list|,
name|NR_RX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|work_done
operator|=
literal|1
expr_stmt|;
comment|/* do not fire napi again */
block|}
else|else
block|{
comment|/* TX path */
if|if
condition|(
name|q
operator|>=
name|na
operator|->
name|num_tx_rings
condition|)
return|return;
comment|// not a physical queue
name|kring
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|q
expr_stmt|;
name|na
operator|->
name|nm_notify
argument_list|(
name|na
argument_list|,
name|q
argument_list|,
name|NR_TX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Default functions to handle rx/tx interrupts from a physical device.  * "work_done" is non-null on the RX path, NULL for the TX path.  *  * If the card is not in netmap mode, simply return 0,  * so that the caller proceeds with regular processing.  * Otherwise call netmap_common_irq() and return 1.  *  * If the card is connected to a netmap file descriptor,  * do a selwakeup on the individual queue, plus one on the global one  * if needed (multiqueue card _and_ there are multiqueue listeners),  * and return 1.  *  * Finally, if called on rx from an interface connected to a switch,  * calls the proper forwarding routine, and return 1.  */
end_comment

begin_function
name|int
name|netmap_rx_irq
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|q
parameter_list|,
name|u_int
modifier|*
name|work_done
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
comment|/* 	 * XXX emulated netmap mode sets NAF_SKIP_INTR so 	 * we still use the regular driver even though the previous 	 * check fails. It is unclear whether we should use 	 * nm_native_on() here. 	 */
if|if
condition|(
operator|!
name|nm_netmap_on
argument_list|(
name|na
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_SKIP_INTR
condition|)
block|{
name|ND
argument_list|(
literal|"use regular interrupt"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|netmap_common_irq
argument_list|(
name|ifp
argument_list|,
name|q
argument_list|,
name|work_done
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Module loader and unloader  *  * netmap_init() creates the /dev/netmap device and initializes  * all global variables. Returns 0 on success, errno on failure  * (but there is no chance)  *  * netmap_fini() destroys everything.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|netmap_dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* /dev/netmap character device. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|cdevsw
name|netmap_cdevsw
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|netmap_fini
parameter_list|(
name|void
parameter_list|)
block|{
comment|// XXX destroy_bridges() ?
if|if
condition|(
name|netmap_dev
condition|)
name|destroy_dev
argument_list|(
name|netmap_dev
argument_list|)
expr_stmt|;
name|netmap_mem_fini
argument_list|()
expr_stmt|;
name|NMG_LOCK_DESTROY
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"netmap: unloaded module.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|netmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|NMG_LOCK_INIT
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_mem_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* XXX could use make_dev_credv() to get error number */
name|netmap_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|netmap_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0660
argument_list|,
literal|"netmap"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netmap_dev
condition|)
goto|goto
name|fail
goto|;
name|netmap_init_bridges
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|nm_vi_init_index
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"netmap: loaded module\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|netmap_fini
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* may be incorrect */
block|}
end_function

end_unit

