begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 Matteo Landi, Luigi Rizzo. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This module supports memory mapped access to network devices,  * see netmap(4).  *  * The module uses a large, memory pool allocated by the kernel  * and accessible as mmapped memory by multiple userspace threads/processes.  * The memory pool contains packet buffers and "netmap rings",  * i.e. user-accessible copies of the interface's queues.  *  * Access to the network card works like this:  * 1. a process/thread issues one or more open() on /dev/netmap, to create  *    select()able file descriptor on which events are reported.  * 2. on each descriptor, the process issues an ioctl() to identify  *    the interface that should report events to the file descriptor.  * 3. on each descriptor, the process issues an mmap() request to  *    map the shared memory region within the process' address space.  *    The list of interesting queues is indicated by a location in  *    the shared memory region.  * 4. using the functions in the netmap(4) userspace API, a process  *    can look up the occupation state of a queue, access memory buffers,  *    and retrieve received packets or enqueue packets to transmit.  * 5. using some ioctl()s the process can synchronize the userspace view  *    of the queue with the actual status in the kernel. This includes both  *    receiving the notification of new packets, and transmitting new  *    packets on the output interface.  * 6. select() or poll() can be used to wait for events on individual  *    transmit or receive queues (or all queues for a given interface).  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* defines used in kernel.h */
end_comment

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* types used in module initialization */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_comment
comment|/* cdevsw struct */
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_comment
comment|/* uio struct */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_comment
comment|/* struct socket */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_comment
comment|/* PROT_EXEC */
end_comment

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* vtophys */
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* vtophys */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/* BIOCIMMEDIATE */
end_comment

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETMAP
argument_list|,
literal|"netmap"
argument_list|,
literal|"Network memory map"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * lock and unlock for the netmap memory allocator  */
end_comment

begin_define
define|#
directive|define
name|NMA_LOCK
parameter_list|()
value|mtx_lock(&nm_mem->nm_mtx);
end_define

begin_define
define|#
directive|define
name|NMA_UNLOCK
parameter_list|()
value|mtx_unlock(&nm_mem->nm_mtx);
end_define

begin_struct_decl
struct_decl|struct
name|netmap_mem_d
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|struct
name|netmap_mem_d
modifier|*
name|nm_mem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our memory allocator. */
end_comment

begin_decl_stmt
name|u_int
name|netmap_total_buffers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|netmap_buffer_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address of an invalid buffer */
end_comment

begin_comment
comment|/* user-controlled variables */
end_comment

begin_decl_stmt
name|int
name|netmap_verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|netmap_no_timestamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't timestamp on rxsync */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_dev
argument_list|,
name|OID_AUTO
argument_list|,
name|netmap
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Netmap args"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_verbose
argument_list|,
literal|0
argument_list|,
literal|"Verbose mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_timestamp
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_no_timestamp
argument_list|,
literal|0
argument_list|,
literal|"no_timestamp"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_buf_size
init|=
literal|2048
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.netmap.buf_size"
argument_list|,
operator|&
name|netmap_buf_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|buf_size
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|netmap_buf_size
argument_list|,
literal|0
argument_list|,
literal|"Size of packet buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_mitigate
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|mitigate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_mitigate
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_no_pendintr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_pendintr
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_no_pendintr
argument_list|,
literal|0
argument_list|,
literal|"Always look for new received packets."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*------------- memory allocator -----------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NETMAP_MEM2
end_ifdef

begin_include
include|#
directive|include
file|"netmap_mem2.c"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !NETMAP_MEM2 */
end_comment

begin_include
include|#
directive|include
file|"netmap_mem1.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NETMAP_MEM2 */
end_comment

begin_comment
comment|/*------------ end of memory allocator ----------*/
end_comment

begin_comment
comment|/* Structure associated to each thread which registered an interface. */
end_comment

begin_struct
struct|struct
name|netmap_priv_d
block|{
name|struct
name|netmap_if
modifier|*
name|np_nifp
decl_stmt|;
comment|/* netmap interface descriptor. */
name|struct
name|ifnet
modifier|*
name|np_ifp
decl_stmt|;
comment|/* device for which we hold a reference */
name|int
name|np_ringid
decl_stmt|;
comment|/* from the ioctl */
name|u_int
name|np_qfirst
decl_stmt|,
name|np_qlast
decl_stmt|;
comment|/* range of rings to scan */
name|uint16_t
name|np_txpoll
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * File descriptor's private data destructor.  *  * Call nm_register(ifp,0) to stop netmap mode on the interface and  * revert to normal operation. We expect that np_ifp has not gone.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_dtor_locked
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|np_ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|priv
operator|->
name|np_nifp
decl_stmt|;
name|na
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|refcount
operator|<=
literal|0
condition|)
block|{
comment|/* last instance */
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|lim
decl_stmt|;
name|D
argument_list|(
literal|"deleting last netmap instance for %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* 		 * there is a race here with *_netmap_task() and 		 * netmap_poll(), which don't run under NETMAP_REG_LOCK. 		 * na->refcount == 0&& na->ifp->if_capenable& IFCAP_NETMAP 		 * (aka NETMAP_DELETING(na)) are a unique marker that the 		 * device is dying. 		 * Before destroying stuff we sleep a bit, and then complete 		 * the job. NIOCREG should realize the condition and 		 * loop until they can continue; the other routines 		 * should check the condition at entry and quit if 		 * they cannot run. 		 */
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|na
argument_list|,
literal|0
argument_list|,
literal|"NIOCUNREG"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_register
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* off, clear IFCAP_NETMAP */
comment|/* Wake up any sleeping threads. netmap_poll will 		 * then return POLLERR 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|tx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|rx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
comment|/* release all buffers */
name|NMA_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|ring
decl_stmt|;
name|lim
operator|=
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|nkr_num_slots
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lim
condition|;
name|j
operator|++
control|)
name|netmap_free_buf
argument_list|(
name|nifp
argument_list|,
name|ring
operator|->
name|slot
index|[
name|j
index|]
operator|.
name|buf_idx
argument_list|)
expr_stmt|;
comment|/* knlist_destroy(&na->tx_rings[i].si.si_note); */
name|mtx_destroy
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
decl_stmt|;
name|lim
operator|=
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nkr_num_slots
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lim
condition|;
name|j
operator|++
control|)
name|netmap_free_buf
argument_list|(
name|nifp
argument_list|,
name|ring
operator|->
name|slot
index|[
name|j
index|]
operator|.
name|buf_idx
argument_list|)
expr_stmt|;
comment|/* knlist_destroy(&na->rx_rings[i].si.si_note); */
name|mtx_destroy
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
block|}
comment|/* XXX kqueue(9) needed; these will mirror knlist_init. */
comment|/* knlist_destroy(&na->tx_si.si_note); */
comment|/* knlist_destroy(&na->rx_si.si_note); */
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
name|netmap_free_rings
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
name|netmap_if_free
argument_list|(
name|nifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_dtor
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|np_ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|netmap_dtor_locked
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX for safety */
name|free
argument_list|(
name|priv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mmap(2) support for the "netmap" device.  *  * Expose all the memory previously allocated by our custom memory  * allocator: this way the user has only to issue a single mmap(2), and  * can work on all the data structures flawlessly.  *  * Return 0 on success, -1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_mmap
parameter_list|(
name|__unused
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|900000
name|vm_offset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
else|#
directive|else
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|,
name|__unused
name|vm_memattr_t
modifier|*
name|memattr
endif|#
directive|endif
parameter_list|)
block|{
if|if
condition|(
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|// XXX -1 or EINVAL ?
name|ND
argument_list|(
literal|"request for offset 0x%x"
argument_list|,
operator|(
name|uint32_t
operator|)
name|offset
argument_list|)
expr_stmt|;
operator|*
name|paddr
operator|=
name|netmap_ofstophys
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handlers for synchronization of the queues from/to the host.  *  * netmap_sync_to_host() passes packets up. We are called from a  * system call in user process context, and the only contention  * can be among multiple user threads erroneously calling  * this routine concurrently. In principle we should not even  * need to lock.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_sync_to_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|na
operator|->
name|num_tx_rings
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|head
init|=
name|NULL
decl_stmt|,
modifier|*
name|tail
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|u_int
name|k
decl_stmt|,
name|n
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|k
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|lim
condition|)
block|{
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// na->nm_lock(na->ifp, NETMAP_CORE_LOCK, 0);
comment|/* Take packets from hwcur to cur and pass them up. 	 * In case of no buffers we give up. At the end of the loop, 	 * the queue is drained in all cases. 	 */
for|for
control|(
name|n
operator|=
name|kring
operator|->
name|nr_hwcur
init|;
name|n
operator|!=
name|k
condition|;
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|n
index|]
decl_stmt|;
name|n
operator|=
operator|(
name|n
operator|==
name|lim
operator|)
condition|?
literal|0
else|:
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|len
operator|<
literal|14
operator|||
name|slot
operator|->
name|len
operator|>
name|NETMAP_BUF_SIZE
condition|)
block|{
name|D
argument_list|(
literal|"bad pkt at %d len %d"
argument_list|,
name|n
argument_list|,
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m
operator|=
name|m_devget
argument_list|(
name|NMB
argument_list|(
name|slot
argument_list|)
argument_list|,
name|slot
operator|->
name|len
argument_list|,
literal|0
argument_list|,
name|na
operator|->
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|tail
condition|)
name|tail
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
else|else
name|head
operator|=
name|m
expr_stmt|;
name|tail
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwcur
operator|=
name|k
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|=
name|ring
operator|->
name|avail
operator|=
name|lim
expr_stmt|;
comment|// na->nm_lock(na->ifp, NETMAP_CORE_UNLOCK, 0);
comment|/* send packets up, outside the lock */
while|while
condition|(
operator|(
name|m
operator|=
name|head
operator|)
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
name|head
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"sending up pkt %p size %d"
argument_list|,
name|m
argument_list|,
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|NM_SEND_UP
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * rxsync backend for packets coming from the host stack.  * They have been put in the queue by netmap_start() so we  * need to protect access to the kring using a lock.  *  * This routine also does the selrecord if called from the poll handler  * (we know because td != NULL).  */
end_comment

begin_function
specifier|static
name|void
name|netmap_sync_from_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|j
decl_stmt|,
name|n
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
decl_stmt|;
name|u_int
name|k
init|=
name|ring
operator|->
name|cur
decl_stmt|,
name|resvd
init|=
name|ring
operator|->
name|reserved
decl_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|lim
condition|)
block|{
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* new packets are already set in nr_hwavail */
comment|/* skip past packets that userspace has released */
name|j
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|resvd
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|resvd
operator|+
name|ring
operator|->
name|avail
operator|>=
name|lim
operator|+
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"XXX invalid reserve/avail %d %d"
argument_list|,
name|resvd
argument_list|,
name|ring
operator|->
name|avail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|reserved
operator|=
name|resvd
operator|=
literal|0
expr_stmt|;
comment|// XXX panic...
block|}
name|k
operator|=
operator|(
name|k
operator|>=
name|resvd
operator|)
condition|?
name|k
operator|-
name|resvd
else|:
name|k
operator|+
name|lim
operator|-
name|resvd
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
name|k
condition|)
block|{
name|n
operator|=
name|k
operator|>=
name|j
condition|?
name|k
operator|-
name|j
else|:
name|k
operator|+
name|lim
operator|-
name|j
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|-=
name|n
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|k
expr_stmt|;
block|}
name|k
operator|=
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
operator|-
name|resvd
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
operator|&&
name|td
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|&&
operator|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
operator|)
condition|)
name|D
argument_list|(
literal|"%d pkts from stack"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a refcounted reference to an interface.  * Return ENXIO if the interface does not exist, EINVAL if netmap  * is not supported by the interface.  * If successful, hold a reference.  */
end_comment

begin_function
specifier|static
name|int
name|get_ifp
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ifnet
modifier|*
modifier|*
name|ifp
parameter_list|)
block|{
operator|*
name|ifp
operator|=
name|ifunit_ref
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* can do this if the capability exists and if_pspare[0] 	 * points to the netmap descriptor. 	 */
if|if
condition|(
operator|(
operator|*
name|ifp
operator|)
operator|->
name|if_capabilities
operator|&
name|IFCAP_NETMAP
operator|&&
name|NA
argument_list|(
operator|*
name|ifp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* valid pointer, we hold the refcount */
name|if_rele
argument_list|(
operator|*
name|ifp
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
comment|// not NETMAP capable
block|}
end_function

begin_comment
comment|/*  * Error routine called when txsync/rxsync detects an error.  * Can't do much more than resetting cur = hwcur, avail = hwavail.  * Return 1 on reinit.  *  * This routine is only called by the upper half of the kernel.  * It only reads hwcur (which is changed only by the upper half, too)  * and hwavail (which may be changed by the lower half, but only on  * a tx ring and only to increase it, so any error will be recovered  * on the next call). For the above, we don't strictly need to call  * it under lock.  */
end_comment

begin_function
name|int
name|netmap_ring_reinit
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|D
argument_list|(
literal|"called for %s"
argument_list|,
name|kring
operator|->
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|cur
operator|>
name|lim
condition|)
name|errors
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|idx
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
decl_stmt|;
name|u_int
name|len
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|2
operator|||
name|idx
operator|>=
name|netmap_total_buffers
condition|)
block|{
if|if
condition|(
operator|!
name|errors
operator|++
condition|)
name|D
argument_list|(
literal|"bad buffer at slot %d idx %d len %d "
argument_list|,
name|i
argument_list|,
name|idx
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
name|NETMAP_BUF_SIZE
condition|)
block|{
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|errors
operator|++
condition|)
name|D
argument_list|(
literal|"bad len %d at slot %d idx %d"
argument_list|,
name|len
argument_list|,
name|i
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errors
condition|)
block|{
name|int
name|pos
init|=
name|kring
operator|-
name|kring
operator|->
name|na
operator|->
name|tx_rings
decl_stmt|;
name|int
name|n
init|=
name|kring
operator|->
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
decl_stmt|;
name|D
argument_list|(
literal|"total %d errors"
argument_list|,
name|errors
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|D
argument_list|(
literal|"%s %s[%d] reinit, cur %d -> %d avail %d -> %d"
argument_list|,
name|kring
operator|->
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|pos
operator|<
name|n
condition|?
literal|"TX"
else|:
literal|"RX"
argument_list|,
name|pos
operator|<
name|n
condition|?
name|pos
else|:
name|pos
operator|-
name|n
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|ring
operator|->
name|avail
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
block|}
return|return
operator|(
name|errors
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the ring ID. For devices with a single queue, a request  * for all rings is the same as a single ring.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_set_ringid
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|u_int
name|ringid
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|np_ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|u_int
name|i
init|=
name|ringid
operator|&
name|NETMAP_RING_MASK
decl_stmt|;
comment|/* initially (np_qfirst == np_qlast) we don't want to lock */
name|int
name|need_lock
init|=
operator|(
name|priv
operator|->
name|np_qfirst
operator|!=
name|priv
operator|->
name|np_qlast
operator|)
decl_stmt|;
name|int
name|lim
init|=
name|na
operator|->
name|num_rx_rings
decl_stmt|;
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|>
name|lim
condition|)
name|lim
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
if|if
condition|(
operator|(
name|ringid
operator|&
name|NETMAP_HW_RING
operator|)
operator|&&
name|i
operator|>=
name|lim
condition|)
block|{
name|D
argument_list|(
literal|"invalid ring id %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|need_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_ringid
operator|=
name|ringid
expr_stmt|;
if|if
condition|(
name|ringid
operator|&
name|NETMAP_SW_RING
condition|)
block|{
name|priv
operator|->
name|np_qfirst
operator|=
name|NETMAP_SW_RING
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ringid
operator|&
name|NETMAP_HW_RING
condition|)
block|{
name|priv
operator|->
name|np_qfirst
operator|=
name|i
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|->
name|np_qfirst
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
name|NETMAP_HW_RING
expr_stmt|;
block|}
name|priv
operator|->
name|np_txpoll
operator|=
operator|(
name|ringid
operator|&
name|NETMAP_NO_TX_POLL
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|need_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ringid
operator|&
name|NETMAP_SW_RING
condition|)
name|D
argument_list|(
literal|"ringid %s set to SW RING"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ringid
operator|&
name|NETMAP_HW_RING
condition|)
name|D
argument_list|(
literal|"ringid %s set to HW RING %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|priv
operator|->
name|np_qfirst
argument_list|)
expr_stmt|;
else|else
name|D
argument_list|(
literal|"ringid %s set to all %d HW RINGS"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|lim
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ioctl(2) support for the "netmap" device.  *  * Following a list of accepted commands:  * - NIOCGINFO  * - SIOCGIFADDR	just for convenience  * - NIOCREGIF  * - NIOCUNREGIF  * - NIOCTXSYNC  * - NIOCRXSYNC  *  * Return 0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_ioctl
parameter_list|(
name|__unused
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|__unused
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|nmreq
modifier|*
name|nmr
init|=
operator|(
expr|struct
name|nmreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|lim
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|TD_TO_VNET
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
operator|&&
name|error
operator|!=
literal|0
condition|)
block|{
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Could be ENOENT */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NIOCGINFO
case|:
comment|/* return capabilities etc */
comment|/* memsize is always valid */
name|nmr
operator|->
name|nr_memsize
operator|=
name|nm_mem
operator|->
name|nm_totalsize
expr_stmt|;
name|nmr
operator|->
name|nr_offset
operator|=
literal|0
expr_stmt|;
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|nmr
operator|->
name|nr_tx_rings
operator|=
literal|0
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|nmr
operator|->
name|nr_tx_slots
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|!=
name|NETMAP_API
condition|)
block|{
name|D
argument_list|(
literal|"API mismatch got %d have %d"
argument_list|,
name|nmr
operator|->
name|nr_version
argument_list|,
name|NETMAP_API
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nmr
operator|->
name|nr_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* just get memory info */
break|break;
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
comment|/* get a refcount */
if|if
condition|(
name|error
condition|)
break|break;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap_adapter */
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
break|break;
case|case
name|NIOCREGIF
case|:
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|!=
name|NETMAP_API
condition|)
block|{
name|nmr
operator|->
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|priv
operator|!=
name|NULL
condition|)
block|{
comment|/* thread already registered */
name|error
operator|=
name|netmap_set_ringid
argument_list|(
name|priv
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* find the interface and a reference */
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
break|break;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
comment|/* 		 * Allocate the private per-thread structure. 		 * XXX perhaps we can use a blocking malloc ? 		 */
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_priv_d
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|10
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NETMAP_DELETING
argument_list|(
name|na
argument_list|)
condition|)
break|break;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|na
argument_list|,
literal|0
argument_list|,
literal|"NIOCREGIF"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"too many NIOCREGIF attempts, give up"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|free
argument_list|(
name|priv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
break|break;
block|}
name|priv
operator|->
name|np_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* store the reference */
name|error
operator|=
name|netmap_set_ringid
argument_list|(
name|priv
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
name|priv
operator|->
name|np_nifp
operator|=
name|nifp
operator|=
name|netmap_if_new
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
block|{
comment|/* allocation failed */
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
comment|/* was already set */
block|}
else|else
block|{
comment|/* Otherwise set the card in netmap mode 			 * and make it use the shared buffers. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|,
literal|"nm_txq_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|,
literal|"nm_rxq_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|error
operator|=
name|na
operator|->
name|nm_register
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* mode on */
if|if
condition|(
name|error
condition|)
name|netmap_dtor_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* reg. failed, release priv and ref */
name|error
label|:
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|priv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|devfs_set_cdevpriv
argument_list|(
name|priv
argument_list|,
name|netmap_dtor
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* could not assign the private storage for the 			 * thread, call the destructor explicitly. 			 */
name|netmap_dtor
argument_list|(
name|priv
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* return the offset of the netmap_if object */
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_memsize
operator|=
name|nm_mem
operator|->
name|nm_totalsize
expr_stmt|;
name|nmr
operator|->
name|nr_offset
operator|=
name|netmap_if_offset
argument_list|(
name|nifp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIOCUNREGIF
case|:
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
comment|/* the interface is unregistered inside the 		   destructor of the private data. */
name|devfs_clear_cdevpriv
argument_list|()
expr_stmt|;
break|break;
case|case
name|NIOCTXSYNC
case|:
case|case
name|NIOCRXSYNC
case|:
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|ifp
operator|=
name|priv
operator|->
name|np_ifp
expr_stmt|;
comment|/* we have a reference */
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
if|if
condition|(
name|priv
operator|->
name|np_qfirst
operator|==
name|NETMAP_SW_RING
condition|)
block|{
comment|/* host rings */
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
name|netmap_sync_to_host
argument_list|(
name|na
argument_list|)
expr_stmt|;
else|else
name|netmap_sync_from_host
argument_list|(
name|na
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* find the last ring to scan */
name|lim
operator|=
name|priv
operator|->
name|np_qlast
expr_stmt|;
if|if
condition|(
name|lim
operator|==
name|NETMAP_HW_RING
condition|)
name|lim
operator|=
operator|(
name|cmd
operator|==
name|NIOCTXSYNC
operator|)
condition|?
name|na
operator|->
name|num_tx_rings
else|:
name|na
operator|->
name|num_rx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"pre txsync ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_txsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
literal|1
comment|/* do lock */
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"post txsync ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|na
operator|->
name|nm_rxsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
literal|1
comment|/* do lock */
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BIOCIMMEDIATE
case|:
case|case
name|BIOCGHDRCMPLT
case|:
case|case
name|BIOCSHDRCMPLT
case|:
case|case
name|BIOCSSEESENT
case|:
name|D
argument_list|(
literal|"ignore BIOCIMMEDIATE/BIOCSHDRCMPLT/BIOCSHDRCMPLT/BIOCSSEESENT"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* allow device-specific ioctls */
block|{
name|struct
name|socket
name|so
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|so
argument_list|,
sizeof|sizeof
argument_list|(
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
break|break;
name|so
operator|.
name|so_vnet
operator|=
name|ifp
operator|->
name|if_vnet
expr_stmt|;
comment|// so->so_proto not null.
name|error
operator|=
name|ifioctl
argument_list|(
operator|&
name|so
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * select(2) and poll(2) handlers for the "netmap" device.  *  * Can be called for one or more queues.  * Return true the event mask corresponding to ready events.  * If there are no ready events, do a selrecord on either individual  * selfd or on the global one.  * Device-dependent parts (locking and sync of tx/rx rings)  * are done through callbacks.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_poll
parameter_list|(
name|__unused
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|u_int
name|core_lock
decl_stmt|,
name|i
decl_stmt|,
name|check_all
decl_stmt|,
name|want_tx
decl_stmt|,
name|want_rx
decl_stmt|,
name|revents
init|=
literal|0
decl_stmt|;
name|u_int
name|lim_tx
decl_stmt|,
name|lim_rx
decl_stmt|;
enum|enum
block|{
name|NO_CL
block|,
name|NEED_CL
block|,
name|LOCKED_CL
block|}
enum|;
comment|/* see below */
if|if
condition|(
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
operator|!=
literal|0
operator|||
name|priv
operator|==
name|NULL
condition|)
return|return
name|POLLERR
return|;
name|ifp
operator|=
name|priv
operator|->
name|np_ifp
expr_stmt|;
comment|// XXX check for deleting() ?
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
operator|==
literal|0
condition|)
return|return
name|POLLERR
return|;
if|if
condition|(
name|netmap_verbose
operator|&
literal|0x8000
condition|)
name|D
argument_list|(
literal|"device %s events 0x%x"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|events
argument_list|)
expr_stmt|;
name|want_tx
operator|=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
name|want_rx
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
name|lim_tx
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|lim_rx
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
comment|/* how many queues we are scanning */
if|if
condition|(
name|priv
operator|->
name|np_qfirst
operator|==
name|NETMAP_SW_RING
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|np_txpoll
operator|||
name|want_tx
condition|)
block|{
comment|/* push any packets up, then we are always ready */
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|lim_tx
index|]
expr_stmt|;
name|netmap_sync_to_host
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|revents
operator||=
name|want_tx
expr_stmt|;
block|}
if|if
condition|(
name|want_rx
condition|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|lim_rx
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|==
literal|0
condition|)
name|netmap_sync_from_host
argument_list|(
name|na
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
block|}
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
comment|/* 	 * check_all is set if the card has more than one queue and 	 * the client is polling all of them. If true, we sleep on 	 * the "global" selfd, otherwise we sleep on individual selfd 	 * (we can only sleep on one of them per direction). 	 * The interrupt routine in the driver should always wake on 	 * the individual selfd, and also on the global one if the card 	 * has more than one ring. 	 * 	 * If the card has only one lock, we just use that. 	 * If the card has separate ring locks, we just use those 	 * unless we are doing check_all, in which case the whole 	 * loop is wrapped by the global lock. 	 * We acquire locks only when necessary: if poll is called 	 * when buffers are available, we can just return without locks. 	 * 	 * rxsync() is only called if we run out of buffers on a POLLIN. 	 * txsync() is called if we run out of buffers on POLLOUT, or 	 * there are pending packets to send. The latter can be disabled 	 * passing NETMAP_NO_TX_POLL in the NIOCREG call. 	 */
name|check_all
operator|=
operator|(
name|priv
operator|->
name|np_qlast
operator|==
name|NETMAP_HW_RING
operator|)
operator|&&
operator|(
name|lim_tx
operator|>
literal|1
operator|||
name|lim_rx
operator|>
literal|1
operator|)
expr_stmt|;
comment|/* 	 * core_lock indicates what to do with the core lock. 	 * The core lock is used when either the card has no individual 	 * locks, or it has individual locks but we are cheking all 	 * rings so we need the core lock to avoid missing wakeup events. 	 * 	 * It has three possible states: 	 * NO_CL	we don't need to use the core lock, e.g. 	 *		because we are protected by individual locks. 	 * NEED_CL	we need the core lock. In this case, when we 	 *		call the lock routine, move to LOCKED_CL 	 *		to remember to release the lock once done. 	 * LOCKED_CL	core lock is set, so we need to release it. 	 */
name|core_lock
operator|=
operator|(
name|check_all
operator|||
operator|!
name|na
operator|->
name|separate_locks
operator|)
condition|?
name|NEED_CL
else|:
name|NO_CL
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_qlast
operator|!=
name|NETMAP_HW_RING
condition|)
block|{
name|lim_tx
operator|=
name|lim_rx
operator|=
name|priv
operator|->
name|np_qlast
expr_stmt|;
block|}
comment|/* 	 * We start with a lock free round which is good if we have 	 * data available. If this fails, then lock and call the sync 	 * routines. 	 */
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|want_rx
operator|&&
name|i
operator|<
name|lim_rx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
name|want_rx
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|want_tx
operator|&&
name|i
operator|<
name|lim_tx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
comment|/* 	 * If we to push packets out (priv->np_txpoll) or want_tx is 	 * still set, we do need to run the txsync calls (on all rings, 	 * to avoid that the tx rings stall). 	 */
if|if
condition|(
name|priv
operator|->
name|np_txpoll
operator|||
name|want_tx
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim_tx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
comment|/* 			 * Skip the current ring if want_tx == 0 			 * (we have already done a successful sync on 			 * a previous ring) AND kring->cur == kring->hwcur 			 * (there are no pending transmissions for this ring). 			 */
if|if
condition|(
operator|!
name|want_tx
operator|&&
name|kring
operator|->
name|ring
operator|->
name|cur
operator|==
name|kring
operator|->
name|nr_hwcur
condition|)
continue|continue;
if|if
condition|(
name|core_lock
operator|==
name|NEED_CL
condition|)
block|{
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|core_lock
operator|=
name|LOCKED_CL
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_TX_LOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"send %d on %s %d"
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_txsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
literal|0
comment|/* no lock */
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
comment|/* Check avail/call selrecord only if called with POLLOUT */
if|if
condition|(
name|want_tx
condition|)
block|{
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
comment|/* stop at the first ring. We don't risk 					 * starvation. 					 */
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|check_all
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_TX_UNLOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * now if want_rx is still set we need to lock and rxsync. 	 * Do it on all rings because otherwise we starve. 	 */
if|if
condition|(
name|want_rx
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim_rx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|core_lock
operator|==
name|NEED_CL
condition|)
block|{
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|core_lock
operator|=
name|LOCKED_CL
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_RX_LOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_rxsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
literal|0
comment|/* no lock */
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
if|if
condition|(
name|netmap_no_timestamp
operator|==
literal|0
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_TIMESTAMP
condition|)
block|{
name|microtime
argument_list|(
operator|&
name|kring
operator|->
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
name|revents
operator||=
name|want_rx
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|check_all
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_RX_UNLOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|check_all
operator|&&
name|revents
operator|==
literal|0
condition|)
block|{
comment|/* signal on the global queue */
if|if
condition|(
name|want_tx
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|na
operator|->
name|tx_si
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_rx
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|na
operator|->
name|rx_si
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|core_lock
operator|==
name|LOCKED_CL
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------- driver support routines ------*/
end_comment

begin_comment
comment|/*  * default lock wrapper.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_lock_wrapper
parameter_list|(
name|struct
name|ifnet
modifier|*
name|dev
parameter_list|,
name|int
name|what
parameter_list|,
name|u_int
name|queueid
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
ifdef|#
directive|ifdef
name|linux
comment|/* some system do not need lock on register */
case|case
name|NETMAP_REG_LOCK
case|:
case|case
name|NETMAP_REG_UNLOCK
case|:
break|break;
endif|#
directive|endif
comment|/* linux */
case|case
name|NETMAP_CORE_LOCK
case|:
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_CORE_UNLOCK
case|:
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_TX_LOCK
case|:
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_TX_UNLOCK
case|:
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_RX_LOCK
case|:
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_RX_UNLOCK
case|:
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize a ``netmap_adapter`` object created by driver on attach.  * We allocate a block of memory with room for a struct netmap_adapter  * plus two sets of N+2 struct netmap_kring (where N is the number  * of hardware rings):  * krings	0..N-1	are for the hardware queues.  * kring	N	is for the host stack queue  * kring	N+1	is only used for the selinfo for all queues.  * Return 0 on success, ENOMEM otherwise.  *  * By default the receive and transmit adapter ring counts are both initialized  * to num_queues.  na->num_tx_rings can be set for cards with different tx/rx  * setups.  */
end_comment

begin_function
name|int
name|netmap_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|num_queues
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|size
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"ifp not set, giving up"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* clear other fields ? */
name|na
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|==
literal|0
condition|)
name|na
operator|->
name|num_tx_rings
operator|=
name|num_queues
expr_stmt|;
name|na
operator|->
name|num_rx_rings
operator|=
name|num_queues
expr_stmt|;
comment|/* on each direction we have N+1 resources 	 * 0..n-1	are the hardware rings 	 * n		is the ring attached to the stack. 	 */
name|n
operator|=
name|na
operator|->
name|num_rx_rings
operator|+
name|na
operator|->
name|num_tx_rings
operator|+
literal|2
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
operator|+
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_kring
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
name|WNA
argument_list|(
name|ifp
argument_list|)
operator|=
name|buf
expr_stmt|;
name|na
operator|->
name|tx_rings
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
operator|)
expr_stmt|;
name|na
operator|->
name|rx_rings
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|na
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_NETMAP
expr_stmt|;
name|na
operator|=
name|buf
expr_stmt|;
comment|/* Core lock initialized here.  Others are initialized after 		 * netmap_if_new. 		 */
name|mtx_init
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|,
literal|"netmap core lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_lock
operator|==
name|NULL
condition|)
block|{
name|ND
argument_list|(
literal|"using default locks for %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
operator|=
name|netmap_lock_wrapper
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|linux
name|D
argument_list|(
literal|"netdev_ops %p"
argument_list|,
name|ifp
operator|->
name|netdev_ops
argument_list|)
expr_stmt|;
comment|/* prepare a clone of the netdev ops */
name|na
operator|->
name|nm_ndo
operator|=
operator|*
name|ifp
operator|->
name|netdev_ops
expr_stmt|;
name|na
operator|->
name|nm_ndo
operator|.
name|ndo_start_xmit
operator|=
name|netmap_start_linux
expr_stmt|;
endif|#
directive|endif
name|D
argument_list|(
literal|"%s for %s"
argument_list|,
name|buf
condition|?
literal|"ok"
else|:
literal|"failed"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
condition|?
literal|0
else|:
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the allocated memory linked to the given ``netmap_adapter``  * object.  */
end_comment

begin_function
name|void
name|netmap_detach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|na
condition|)
return|return;
name|mtx_destroy
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|na
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|WNA
argument_list|(
name|ifp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|na
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Intercept packets from the network stack and pass them  * to netmap as incoming packets on the 'software' ring.  * We are not locked when called.  */
end_comment

begin_function
name|int
name|netmap_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|len
init|=
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|int
name|error
init|=
name|EBUSY
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"%s packet %d len %d from the stack"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwavail
operator|>=
name|lim
condition|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"stack ring %s full\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* no space */
block|}
if|if
condition|(
name|len
operator|>
name|NETMAP_BUF_SIZE
condition|)
block|{
name|D
argument_list|(
literal|"drop packet size %d> %d"
argument_list|,
name|len
argument_list|,
name|NETMAP_BUF_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* too long for us */
block|}
comment|/* compute the insert position */
name|i
operator|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|lim
condition|)
name|i
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
name|slot
operator|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|i
index|]
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|NMB
argument_list|(
name|slot
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|++
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"wake up host ring %s %d"
argument_list|,
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* release the mbuf in either cases of success or failure. As an 	 * alternative, put the mbuf in a free list and free the list 	 * only when really necessary. 	 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * netmap_reset() is called by the driver routines when reinitializing  * a ring. The driver is in charge of locking to protect the kring.  * If netmap mode is not set just return NULL.  */
end_comment

begin_function
name|struct
name|netmap_slot
modifier|*
name|netmap_reset
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|enum
name|txrx
name|tx
parameter_list|,
name|int
name|n
parameter_list|,
name|u_int
name|new_cur
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|int
name|new_hwofs
decl_stmt|,
name|lim
decl_stmt|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* no netmap support here */
if|if
condition|(
operator|!
operator|(
name|na
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* nothing to reinitialize */
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
block|{
name|kring
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|n
expr_stmt|;
name|new_hwofs
operator|=
name|kring
operator|->
name|nr_hwcur
operator|-
name|new_cur
expr_stmt|;
block|}
else|else
block|{
name|kring
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|n
expr_stmt|;
name|new_hwofs
operator|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
operator|-
name|new_cur
expr_stmt|;
block|}
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new_hwofs
operator|>
name|lim
condition|)
name|new_hwofs
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
comment|/* Alwayws set the new offset value and realign the ring. */
name|kring
operator|->
name|nkr_hwofs
operator|=
name|new_hwofs
expr_stmt|;
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
name|kring
operator|->
name|nr_hwavail
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
name|D
argument_list|(
literal|"new hwofs %d on %s %s[%d]"
argument_list|,
name|kring
operator|->
name|nkr_hwofs
argument_list|,
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|tx
operator|==
name|NR_TX
condition|?
literal|"TX"
else|:
literal|"RX"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* 	 * Wakeup on the individual and global lock 	 * We do the wakeup here, but the ring is not yet reconfigured. 	 * However, we are under lock so there are no races. 	 */
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
name|tx
operator|==
name|NR_TX
condition|?
operator|&
name|na
operator|->
name|tx_si
else|:
operator|&
name|na
operator|->
name|rx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
return|return
name|kring
operator|->
name|ring
operator|->
name|slot
return|;
block|}
end_function

begin_comment
comment|/*  * Default functions to handle rx/tx interrupts  * we have 4 cases:  * 1 ring, single lock:  *	lock(core); wake(i=0); unlock(core)  * N rings, single lock:  *	lock(core); wake(i); wake(N+1) unlock(core)  * 1 ring, separate locks: (i=0)  *	lock(i); wake(i); unlock(i)  * N rings, separate locks:  *	lock(i); wake(i); unlock(i); lock(core) wake(N+1) unlock(core)  * work_done is non-null on the RX path.  */
end_comment

begin_function
name|int
name|netmap_rx_irq
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|q
parameter_list|,
name|int
modifier|*
name|work_done
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|r
decl_stmt|;
name|NM_SELINFO_T
modifier|*
name|main_wq
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
return|return
literal|0
return|;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_done
condition|)
block|{
comment|/* RX path */
name|r
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|q
expr_stmt|;
name|r
operator|->
name|nr_kflags
operator||=
name|NKR_PENDINTR
expr_stmt|;
name|main_wq
operator|=
operator|(
name|na
operator|->
name|num_rx_rings
operator|>
literal|1
operator|)
condition|?
operator|&
name|na
operator|->
name|rx_si
else|:
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* tx path */
name|r
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|q
expr_stmt|;
name|main_wq
operator|=
operator|(
name|na
operator|->
name|num_tx_rings
operator|>
literal|1
operator|)
condition|?
operator|&
name|na
operator|->
name|tx_si
else|:
name|NULL
expr_stmt|;
name|work_done
operator|=
operator|&
name|q
expr_stmt|;
comment|/* dummy */
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|r
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|r
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|r
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_wq
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
name|main_wq
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|r
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_wq
condition|)
name|selwakeuppri
argument_list|(
name|main_wq
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
block|}
operator|*
name|work_done
operator|=
literal|1
expr_stmt|;
comment|/* do not fire napi again */
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|netmap_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_name
operator|=
literal|"netmap"
block|,
operator|.
name|d_mmap
operator|=
name|netmap_mmap
block|,
operator|.
name|d_ioctl
operator|=
name|netmap_ioctl
block|,
operator|.
name|d_poll
operator|=
name|netmap_poll
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|netmap_dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* /dev/netmap character device. */
end_comment

begin_comment
comment|/*  * Module loader.  *  * Create the /dev/netmap device and initialize all global  * variables.  *  * Return 0 on success, errno on failure.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|netmap_memory_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"netmap: unable to initialize the memory allocator."
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"netmap: loaded module with %d Mbytes\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|nm_mem
operator|->
name|nm_totalsize
operator|>>
literal|20
argument_list|)
argument_list|)
expr_stmt|;
name|netmap_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|netmap_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0660
argument_list|,
literal|"netmap"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Module unloader.  *  * Free all the memory, and destroy the ``/dev/netmap`` device.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|destroy_dev
argument_list|(
name|netmap_dev
argument_list|)
expr_stmt|;
name|netmap_memory_fini
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"netmap: unloaded module.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Kernel entry point.  *  * Initialize/finalize the module and return.  *  * Return 0 on success, errno on failure.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_loader
parameter_list|(
name|__unused
name|struct
name|module
modifier|*
name|module
parameter_list|,
name|int
name|event
parameter_list|,
name|__unused
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
name|netmap_init
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|netmap_fini
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|netmap
argument_list|,
name|netmap_loader
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

