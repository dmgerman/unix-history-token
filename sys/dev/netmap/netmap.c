begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011-2012 Matteo Landi, Luigi Rizzo. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_define
define|#
directive|define
name|NM_BRIDGE
end_define

begin_comment
comment|/*  * This module supports memory mapped access to network devices,  * see netmap(4).  *  * The module uses a large, memory pool allocated by the kernel  * and accessible as mmapped memory by multiple userspace threads/processes.  * The memory pool contains packet buffers and "netmap rings",  * i.e. user-accessible copies of the interface's queues.  *  * Access to the network card works like this:  * 1. a process/thread issues one or more open() on /dev/netmap, to create  *    select()able file descriptor on which events are reported.  * 2. on each descriptor, the process issues an ioctl() to identify  *    the interface that should report events to the file descriptor.  * 3. on each descriptor, the process issues an mmap() request to  *    map the shared memory region within the process' address space.  *    The list of interesting queues is indicated by a location in  *    the shared memory region.  * 4. using the functions in the netmap(4) userspace API, a process  *    can look up the occupation state of a queue, access memory buffers,  *    and retrieve received packets or enqueue packets to transmit.  * 5. using some ioctl()s the process can synchronize the userspace view  *    of the queue with the actual status in the kernel. This includes both  *    receiving the notification of new packets, and transmitting new  *    packets on the output interface.  * 6. select() or poll() can be used to wait for events on individual  *    transmit or receive queues (or all queues for a given interface).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_include
include|#
directive|include
file|"bsd_glue.h"
end_include

begin_function_decl
specifier|static
name|netdev_tx_t
name|linux_netmap_start
parameter_list|(
name|struct
name|sk_buff
modifier|*
name|skb
parameter_list|,
name|struct
name|net_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* linux */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__APPLE__
end_ifdef

begin_include
include|#
directive|include
file|"osx_glue.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __APPLE__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* defines used in kernel.h */
end_comment

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* types used in module initialization */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_comment
comment|/* cdevsw struct */
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_comment
comment|/* uio struct */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_comment
comment|/* struct socket */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_comment
comment|/* PROT_EXEC */
end_comment

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* vtophys */
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* vtophys */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/* BIOCIMMEDIATE */
end_comment

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETMAP
argument_list|,
literal|"netmap"
argument_list|,
literal|"Network memory map"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_decl_stmt
name|u_int
name|netmap_total_buffers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|netmap_buf_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|netmap_buffer_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address of an invalid buffer */
end_comment

begin_comment
comment|/* user-controlled variables */
end_comment

begin_decl_stmt
name|int
name|netmap_verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|netmap_no_timestamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't timestamp on rxsync */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_dev
argument_list|,
name|OID_AUTO
argument_list|,
name|netmap
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Netmap args"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_verbose
argument_list|,
literal|0
argument_list|,
literal|"Verbose mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_timestamp
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_no_timestamp
argument_list|,
literal|0
argument_list|,
literal|"no_timestamp"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_mitigate
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|mitigate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_mitigate
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_no_pendintr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_pendintr
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_no_pendintr
argument_list|,
literal|0
argument_list|,
literal|"Always look for new received packets."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_drop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debugging */
end_comment

begin_decl_stmt
name|int
name|netmap_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flags */
end_comment

begin_decl_stmt
name|int
name|netmap_fwd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* force transparent mode */
end_comment

begin_decl_stmt
name|int
name|netmap_copy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debugging, copy content */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|drop
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_drop
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|flags
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_flags
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|fwd
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_fwd
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|copy
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_copy
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NM_BRIDGE
end_ifdef

begin_comment
comment|/* support for netmap bridge */
end_comment

begin_comment
comment|/*  * system parameters.  *  * All switched ports have prefix NM_NAME.  * The switch has a max of NM_BDG_MAXPORTS ports (often stored in a bitmap,  * so a practical upper bound is 64).  * Each tx ring is read-write, whereas rx rings are readonly (XXX not done yet).  * The virtual interfaces use per-queue lock instead of core lock.  * In the tx loop, we aggregate traffic in batches to make all operations  * faster. The batch size is NM_BDG_BATCH  */
end_comment

begin_define
define|#
directive|define
name|NM_NAME
value|"vale"
end_define

begin_comment
comment|/* prefix for the interface */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_MAXPORTS
value|16
end_define

begin_comment
comment|/* up to 64 ? */
end_comment

begin_define
define|#
directive|define
name|NM_BRIDGE_RINGSIZE
value|1024
end_define

begin_comment
comment|/* in the device */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_HASH
value|1024
end_define

begin_comment
comment|/* forwarding table entries */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_BATCH
value|1024
end_define

begin_comment
comment|/* entries in the forwarding buffer */
end_comment

begin_define
define|#
directive|define
name|NM_BRIDGES
value|4
end_define

begin_comment
comment|/* number of bridges */
end_comment

begin_decl_stmt
name|int
name|netmap_bridge
init|=
name|NM_BDG_BATCH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bridge batch size */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|bridge
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_bridge
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_define
define|#
directive|define
name|ADD_BDG_REF
parameter_list|(
name|ifp
parameter_list|)
value|(NA(ifp)->if_refcount++)
end_define

begin_define
define|#
directive|define
name|DROP_BDG_REF
parameter_list|(
name|ifp
parameter_list|)
value|(NA(ifp)->if_refcount--<= 1)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !linux */
end_comment

begin_define
define|#
directive|define
name|ADD_BDG_REF
parameter_list|(
name|ifp
parameter_list|)
value|(ifp)->if_refcount++
end_define

begin_define
define|#
directive|define
name|DROP_BDG_REF
parameter_list|(
name|ifp
parameter_list|)
value|refcount_release(&(ifp)->if_refcount)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_define
define|#
directive|define
name|prefetch
parameter_list|(
name|x
parameter_list|)
value|__builtin_prefetch(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !linux */
end_comment

begin_function_decl
specifier|static
name|void
name|bdg_netmap_attach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bdg_netmap_reg
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|onoff
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* per-tx-queue entry */
end_comment

begin_struct
struct|struct
name|nm_bdg_fwd
block|{
comment|/* forwarding entry for a bridge */
name|void
modifier|*
name|buf
decl_stmt|;
name|uint64_t
name|dst
decl_stmt|;
comment|/* dst mask */
name|uint32_t
name|src
decl_stmt|;
comment|/* src index ? */
name|uint16_t
name|len
decl_stmt|;
comment|/* src len */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nm_hash_ent
block|{
name|uint64_t
name|mac
decl_stmt|;
comment|/* the top 2 bytes are the epoch */
name|uint64_t
name|ports
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Interfaces for a bridge are all in ports[].  * The array has fixed size, an empty entry does not terminate  * the search.  */
end_comment

begin_struct
struct|struct
name|nm_bridge
block|{
name|struct
name|ifnet
modifier|*
name|bdg_ports
index|[
name|NM_BDG_MAXPORTS
index|]
decl_stmt|;
name|int
name|n_ports
decl_stmt|;
name|uint64_t
name|act_ports
decl_stmt|;
name|int
name|freelist
decl_stmt|;
comment|/* first buffer index */
name|NM_SELINFO_T
name|si
decl_stmt|;
comment|/* poll/select wait queue */
name|NM_LOCK_T
name|bdg_lock
decl_stmt|;
comment|/* protect the selinfo ? */
comment|/* the forwarding table, MAC+ports */
name|struct
name|nm_hash_ent
name|ht
index|[
name|NM_BDG_HASH
index|]
decl_stmt|;
name|int
name|namelen
decl_stmt|;
comment|/* 0 means free */
name|char
name|basename
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|nm_bridge
name|nm_bridges
index|[
name|NM_BRIDGES
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BDG_LOCK
parameter_list|(
name|b
parameter_list|)
value|mtx_lock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_UNLOCK
parameter_list|(
name|b
parameter_list|)
value|mtx_unlock(&(b)->bdg_lock)
end_define

begin_comment
comment|/*  * NA(ifp)->bdg_port	port index  */
end_comment

begin_comment
comment|// XXX only for multiples of 64 bytes, non overlapped.
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pkt_copy
parameter_list|(
name|void
modifier|*
name|_src
parameter_list|,
name|void
modifier|*
name|_dst
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|uint64_t
modifier|*
name|src
init|=
name|_src
decl_stmt|;
name|uint64_t
modifier|*
name|dst
init|=
name|_dst
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|l
operator|>=
literal|1024
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
name|likely
argument_list|(
name|l
operator|>
literal|0
argument_list|)
condition|;
name|l
operator|-=
literal|64
control|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * locate a bridge among the existing ones.  * a ':' in the name terminates the bridge name. Otherwise, just NM_NAME.  * We assume that this is called with a name of at least NM_NAME chars.  */
end_comment

begin_function
specifier|static
name|struct
name|nm_bridge
modifier|*
name|nm_find_bridge
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|namelen
decl_stmt|,
name|e
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|NM_NAME
argument_list|)
expr_stmt|;
comment|/* base length */
name|l
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* actual length */
for|for
control|(
name|i
operator|=
name|namelen
operator|+
literal|1
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|':'
condition|)
block|{
name|namelen
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|namelen
operator|>=
name|IFNAMSIZ
condition|)
name|namelen
operator|=
name|IFNAMSIZ
expr_stmt|;
name|ND
argument_list|(
literal|"--- prefix is '%.*s' ---"
argument_list|,
name|namelen
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* use the first entry for locking */
name|BDG_LOCK
argument_list|(
name|nm_bridges
argument_list|)
expr_stmt|;
comment|// XXX do better
for|for
control|(
name|e
operator|=
operator|-
literal|1
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NM_BRIDGES
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|nm_bridges
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|namelen
operator|==
literal|0
condition|)
name|e
operator|=
name|i
expr_stmt|;
comment|/* record empty slot */
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|b
operator|->
name|basename
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ND
argument_list|(
literal|"found '%.*s' at %d"
argument_list|,
name|namelen
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|NM_BRIDGES
condition|)
block|{
comment|/* all full */
if|if
condition|(
name|e
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* no empty slot */
name|b
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|nm_bridges
operator|+
name|e
expr_stmt|;
name|strncpy
argument_list|(
name|b
operator|->
name|basename
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|b
operator|->
name|namelen
operator|=
name|namelen
expr_stmt|;
block|}
block|}
name|BDG_UNLOCK
argument_list|(
name|nm_bridges
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NM_BRIDGE */
end_comment

begin_comment
comment|/*  * Fetch configuration from the device, to cope with dynamic  * reconfigurations after loading the module.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_update_config
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|u_int
name|txr
decl_stmt|,
name|txd
decl_stmt|,
name|rxr
decl_stmt|,
name|rxd
decl_stmt|;
name|txr
operator|=
name|txd
operator|=
name|rxr
operator|=
name|rxd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_config
condition|)
block|{
name|na
operator|->
name|nm_config
argument_list|(
name|ifp
argument_list|,
operator|&
name|txr
argument_list|,
operator|&
name|txd
argument_list|,
operator|&
name|rxr
argument_list|,
operator|&
name|rxd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* take whatever we had at init time */
name|txr
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|txd
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|rxr
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|rxd
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|==
name|txr
operator|&&
name|na
operator|->
name|num_tx_desc
operator|==
name|txd
operator|&&
name|na
operator|->
name|num_rx_rings
operator|==
name|rxr
operator|&&
name|na
operator|->
name|num_rx_desc
operator|==
name|rxd
condition|)
return|return
literal|0
return|;
comment|/* nothing changed */
if|if
condition|(
name|netmap_verbose
operator|||
name|na
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"stored config %s: txring %d x %d, rxring %d x %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|na
operator|->
name|num_tx_rings
argument_list|,
name|na
operator|->
name|num_tx_desc
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|,
name|na
operator|->
name|num_rx_desc
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"new config %s: txring %d x %d, rxring %d x %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|txr
argument_list|,
name|txd
argument_list|,
name|rxr
argument_list|,
name|rxd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"configuration changed (but fine)"
argument_list|)
expr_stmt|;
name|na
operator|->
name|num_tx_rings
operator|=
name|txr
expr_stmt|;
name|na
operator|->
name|num_tx_desc
operator|=
name|txd
expr_stmt|;
name|na
operator|->
name|num_rx_rings
operator|=
name|rxr
expr_stmt|;
name|na
operator|->
name|num_rx_desc
operator|=
name|rxd
expr_stmt|;
return|return
literal|0
return|;
block|}
name|D
argument_list|(
literal|"configuration changed while active, this is bad..."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*------------- memory allocator -----------------*/
end_comment

begin_include
include|#
directive|include
file|"netmap_mem2.c"
end_include

begin_comment
comment|/*------------ end of memory allocator ----------*/
end_comment

begin_comment
comment|/* Structure associated to each thread which registered an interface.  *  * The first 4 fields of this structure are written by NIOCREGIF and  * read by poll() and NIOC?XSYNC.  * There is low contention among writers (actually, a correct user program  * should have no contention among writers) and among writers and readers,  * so we use a single global lock to protect the structure initialization.  * Since initialization involves the allocation of memory, we reuse the memory  * allocator lock.  * Read access to the structure is lock free. Readers must check that  * np_nifp is not NULL before using the other fields.  * If np_nifp is NULL initialization has not been performed, so they should  * return an error to userlevel.  *  * The ref_done field is used to regulate access to the refcount in the  * memory allocator. The refcount must be incremented at most once for  * each open("/dev/netmap"). The increment is performed by the first  * function that calls netmap_get_memory() (currently called by  * mmap(), NIOCGINFO and NIOCREGIF).  * If the refcount is incremented, it is then decremented when the  * private structure is destroyed.  */
end_comment

begin_struct
struct|struct
name|netmap_priv_d
block|{
name|struct
name|netmap_if
modifier|*
specifier|volatile
name|np_nifp
decl_stmt|;
comment|/* netmap interface descriptor. */
name|struct
name|ifnet
modifier|*
name|np_ifp
decl_stmt|;
comment|/* device for which we hold a reference */
name|int
name|np_ringid
decl_stmt|;
comment|/* from the ioctl */
name|u_int
name|np_qfirst
decl_stmt|,
name|np_qlast
decl_stmt|;
comment|/* range of rings to scan */
name|uint16_t
name|np_txpoll
decl_stmt|;
name|unsigned
name|long
name|ref_done
decl_stmt|;
comment|/* use with NMA_LOCK held */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|netmap_get_memory
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|NMA_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|ref_done
condition|)
block|{
name|error
operator|=
name|netmap_memory_finalize
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|p
operator|->
name|ref_done
operator|=
literal|1
expr_stmt|;
block|}
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * File descriptor's private data destructor.  *  * Call nm_register(ifp,0) to stop netmap mode on the interface and  * revert to normal operation. We expect that np_ifp has not gone.  */
end_comment

begin_comment
comment|/* call with NMA_LOCK held */
end_comment

begin_function
specifier|static
name|void
name|netmap_dtor_locked
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|np_ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|priv
operator|->
name|np_nifp
decl_stmt|;
name|na
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|refcount
operator|<=
literal|0
condition|)
block|{
comment|/* last instance */
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|lim
decl_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"deleting last instance for %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* 		 * there is a race here with *_netmap_task() and 		 * netmap_poll(), which don't run under NETMAP_REG_LOCK. 		 * na->refcount == 0&& na->ifp->if_capenable& IFCAP_NETMAP 		 * (aka NETMAP_DELETING(na)) are a unique marker that the 		 * device is dying. 		 * Before destroying stuff we sleep a bit, and then complete 		 * the job. NIOCREG should realize the condition and 		 * loop until they can continue; the other routines 		 * should check the condition at entry and quit if 		 * they cannot run. 		 */
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|na
argument_list|,
literal|0
argument_list|,
literal|"NIOCUNREG"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_register
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* off, clear IFCAP_NETMAP */
comment|/* Wake up any sleeping threads. netmap_poll will 		 * then return POLLERR 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|tx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|rx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
comment|/* release all buffers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|ring
decl_stmt|;
name|lim
operator|=
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|nkr_num_slots
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lim
condition|;
name|j
operator|++
control|)
name|netmap_free_buf
argument_list|(
name|nifp
argument_list|,
name|ring
operator|->
name|slot
index|[
name|j
index|]
operator|.
name|buf_idx
argument_list|)
expr_stmt|;
comment|/* knlist_destroy(&na->tx_rings[i].si.si_note); */
name|mtx_destroy
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
decl_stmt|;
name|lim
operator|=
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nkr_num_slots
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lim
condition|;
name|j
operator|++
control|)
name|netmap_free_buf
argument_list|(
name|nifp
argument_list|,
name|ring
operator|->
name|slot
index|[
name|j
index|]
operator|.
name|buf_idx
argument_list|)
expr_stmt|;
comment|/* knlist_destroy(&na->rx_rings[i].si.si_note); */
name|mtx_destroy
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
block|}
comment|/* XXX kqueue(9) needed; these will mirror knlist_init. */
comment|/* knlist_destroy(&na->tx_si.si_note); */
comment|/* knlist_destroy(&na->rx_si.si_note); */
name|netmap_free_rings
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
name|netmap_if_free
argument_list|(
name|nifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nm_if_rele
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NM_BRIDGE
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NM_BRIDGE */
name|int
name|i
decl_stmt|,
name|full
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ifp
operator|->
name|if_xname
argument_list|,
name|NM_NAME
argument_list|,
sizeof|sizeof
argument_list|(
name|NM_NAME
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|DROP_BDG_REF
argument_list|(
name|ifp
argument_list|)
condition|)
return|return;
name|b
operator|=
name|ifp
operator|->
name|if_bridge
expr_stmt|;
name|BDG_LOCK
argument_list|(
name|nm_bridges
argument_list|)
expr_stmt|;
name|BDG_LOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"want to disconnect %s from the bridge"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|full
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BDG_MAXPORTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
operator|==
name|ifp
condition|)
block|{
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|ifp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ifp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|full
operator|=
literal|1
expr_stmt|;
block|}
name|BDG_UNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|full
operator|==
literal|0
condition|)
block|{
name|ND
argument_list|(
literal|"freeing bridge %d"
argument_list|,
name|b
operator|-
name|nm_bridges
argument_list|)
expr_stmt|;
name|b
operator|->
name|namelen
operator|=
literal|0
expr_stmt|;
block|}
name|BDG_UNLOCK
argument_list|(
name|nm_bridges
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NM_BDG_MAXPORTS
condition|)
name|D
argument_list|(
literal|"ouch, cannot find ifp to remove"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NM_BRIDGE */
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_dtor
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|np_ifp
decl_stmt|;
name|NMA_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|ifp
condition|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|netmap_dtor_locked
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* might also destroy *na */
block|}
if|if
condition|(
name|priv
operator|->
name|ref_done
condition|)
block|{
name|netmap_memory_deref
argument_list|()
expr_stmt|;
block|}
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX for safety */
name|free
argument_list|(
name|priv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|cdev_pager_ops
name|saved_cdev_pager_ops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|netmap_dev_pager_ctor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_ooffset_t
name|foff
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|u_short
modifier|*
name|color
parameter_list|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"first mmap for %p"
argument_list|,
name|handle
argument_list|)
expr_stmt|;
return|return
name|saved_cdev_pager_ops
operator|.
name|cdev_pg_ctor
argument_list|(
name|handle
argument_list|,
name|size
argument_list|,
name|prot
argument_list|,
name|foff
argument_list|,
name|cred
argument_list|,
name|color
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_dev_pager_dtor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|saved_cdev_pager_ops
operator|.
name|cdev_pg_dtor
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"ready to release memory for %p"
argument_list|,
name|handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdev_pager_ops
name|netmap_cdev_pager_ops
init|=
block|{
operator|.
name|cdev_pg_ctor
operator|=
name|netmap_dev_pager_ctor
block|,
operator|.
name|cdev_pg_dtor
operator|=
name|netmap_dev_pager_dtor
block|,
operator|.
name|cdev_pg_fault
operator|=
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|netmap_mmap_single
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|vm_ooffset_t
modifier|*
name|foff
parameter_list|,
name|vm_size_t
name|objsize
parameter_list|,
name|vm_object_t
modifier|*
name|objp
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|ND
argument_list|(
literal|"cdev %p foff %jd size %jd objp %p prot %d"
argument_list|,
name|cdev
argument_list|,
operator|(
name|intmax_t
operator|)
operator|*
name|foff
argument_list|,
operator|(
name|intmax_t
operator|)
name|objsize
argument_list|,
name|objp
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|obj
operator|=
name|vm_pager_allocate
argument_list|(
name|OBJT_DEVICE
argument_list|,
name|cdev
argument_list|,
name|objsize
argument_list|,
name|prot
argument_list|,
operator|*
name|foff
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"returns obj %p"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|saved_cdev_pager_ops
operator|.
name|cdev_pg_fault
operator|==
name|NULL
condition|)
block|{
name|ND
argument_list|(
literal|"initialize cdev_pager_ops"
argument_list|)
expr_stmt|;
name|saved_cdev_pager_ops
operator|=
operator|*
operator|(
name|obj
operator|->
name|un_pager
operator|.
name|devp
operator|.
name|ops
operator|)
expr_stmt|;
name|netmap_cdev_pager_ops
operator|.
name|cdev_pg_fault
operator|=
name|saved_cdev_pager_ops
operator|.
name|cdev_pg_fault
expr_stmt|;
block|}
empty_stmt|;
name|obj
operator|->
name|un_pager
operator|.
name|devp
operator|.
name|ops
operator|=
operator|&
name|netmap_cdev_pager_ops
expr_stmt|;
operator|*
name|objp
operator|=
name|obj
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/*  * mmap(2) support for the "netmap" device.  *  * Expose all the memory previously allocated by our custom memory  * allocator: this way the user has only to issue a single mmap(2), and  * can work on all the data structures flawlessly.  *  * Return 0 on success, -1 otherwise.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
specifier|static
name|int
name|netmap_mmap
parameter_list|(
name|__unused
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|900000
name|vm_offset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
else|#
directive|else
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|,
name|__unused
name|vm_memattr_t
modifier|*
name|memattr
endif|#
directive|endif
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|priv
decl_stmt|;
if|if
condition|(
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|// XXX -1 or EINVAL ?
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EBADF
condition|)
block|{
comment|/* called on fault, memory is initialized */
name|ND
argument_list|(
literal|5
argument_list|,
literal|"handling fault at ofs 0x%x"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
literal|0
condition|)
comment|/* make sure memory is set */
name|error
operator|=
name|netmap_get_memory
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ND
argument_list|(
literal|"request for offset 0x%x"
argument_list|,
operator|(
name|uint32_t
operator|)
name|offset
argument_list|)
expr_stmt|;
operator|*
name|paddr
operator|=
name|netmap_ofstophys
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|paddr
condition|?
literal|0
else|:
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"dev %p fflag 0x%x devtype %d td %p"
argument_list|,
name|dev
argument_list|,
name|fflag
argument_list|,
name|devtype
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
decl_stmt|;
name|int
name|error
decl_stmt|;
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_priv_d
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|error
operator|=
name|devfs_set_cdevpriv
argument_list|(
name|priv
argument_list|,
name|netmap_dtor
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/*  * Handlers for synchronization of the queues from/to the host.  * Netmap has two operating modes:  * - in the default mode, the rings connected to the host stack are  *   just another ring pair managed by userspace;  * - in transparent mode (XXX to be defined) incoming packets  *   (from the host or the NIC) are marked as NS_FORWARD upon  *   arrival, and the user application has a chance to reset the  *   flag for packets that should be dropped.  *   On the RXSYNC or poll(), packets in RX rings between  *   kring->nr_kcur and ring->cur with NS_FORWARD still set are moved  *   to the other side.  * The transfer NIC --> host is relatively easy, just encapsulate  * into mbufs and we are done. The host --> NIC side is slightly  * harder because there might not be room in the tx ring so it  * might take a while before releasing the buffer.  */
end_comment

begin_comment
comment|/*  * pass a chain of buffers to the host stack as coming from 'dst'  */
end_comment

begin_function
specifier|static
name|void
name|netmap_send_up
parameter_list|(
name|struct
name|ifnet
modifier|*
name|dst
parameter_list|,
name|struct
name|mbuf
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* send packets up, outside the lock */
while|while
condition|(
operator|(
name|m
operator|=
name|head
operator|)
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
name|head
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"sending up pkt %p size %d"
argument_list|,
name|m
argument_list|,
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|NM_SEND_UP
argument_list|(
name|dst
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|mbq
block|{
name|struct
name|mbuf
modifier|*
name|head
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|tail
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * put a copy of the buffers marked NS_FORWARD into an mbuf chain.  * Run from hwcur to cur - reserved  */
end_comment

begin_function
specifier|static
name|void
name|netmap_grab_packets
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|struct
name|mbq
modifier|*
name|q
parameter_list|,
name|int
name|force
parameter_list|)
block|{
comment|/* Take packets from hwcur to cur-reserved and pass them up. 	 * In case of no buffers we give up. At the end of the loop, 	 * the queue is drained in all cases. 	 * XXX handle reserved 	 */
name|int
name|k
init|=
name|kring
operator|->
name|ring
operator|->
name|cur
operator|-
name|kring
operator|->
name|ring
operator|->
name|reserved
decl_stmt|;
name|u_int
name|n
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|tail
init|=
name|q
operator|->
name|tail
decl_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
name|k
operator|=
name|k
operator|+
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
for|for
control|(
name|n
operator|=
name|kring
operator|->
name|nr_hwcur
init|;
name|n
operator|!=
name|k
condition|;
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|n
index|]
decl_stmt|;
name|n
operator|=
operator|(
name|n
operator|==
name|lim
operator|)
condition|?
literal|0
else|:
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_FORWARD
operator|)
operator|==
literal|0
operator|&&
operator|!
name|force
condition|)
continue|continue;
if|if
condition|(
name|slot
operator|->
name|len
operator|<
literal|14
operator|||
name|slot
operator|->
name|len
operator|>
name|NETMAP_BUF_SIZE
condition|)
block|{
name|D
argument_list|(
literal|"bad pkt at %d len %d"
argument_list|,
name|n
argument_list|,
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_FORWARD
expr_stmt|;
comment|// XXX needed ?
name|m
operator|=
name|m_devget
argument_list|(
name|NMB
argument_list|(
name|slot
argument_list|)
argument_list|,
name|slot
operator|->
name|len
argument_list|,
literal|0
argument_list|,
name|kring
operator|->
name|na
operator|->
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|tail
condition|)
name|tail
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
else|else
name|q
operator|->
name|head
operator|=
name|m
expr_stmt|;
name|tail
operator|=
name|m
expr_stmt|;
name|q
operator|->
name|count
operator|++
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
block|}
name|q
operator|->
name|tail
operator|=
name|tail
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * called under main lock to send packets from the host to the NIC  * The host ring has packets from nr_hwcur to (cur - reserved)  * to be sent down. We scan the tx rings, which have just been  * flushed so nr_hwcur == cur. Pushing packets down means  * increment cur and decrement avail.  * XXX to be verified  */
end_comment

begin_function
specifier|static
name|void
name|netmap_sw_to_nic
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|k1
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
literal|0
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|howmany
decl_stmt|,
name|src_lim
decl_stmt|,
name|dst_lim
decl_stmt|;
name|howmany
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
comment|/* XXX otherwise cur - reserved - nr_hwcur */
name|src_lim
operator|=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|howmany
operator|>
literal|0
operator|&&
name|i
operator|<
name|na
operator|->
name|num_tx_rings
condition|;
name|i
operator|++
operator|,
name|k1
operator|++
control|)
block|{
name|ND
argument_list|(
literal|"%d packets left to ring %d (space %d)"
argument_list|,
name|howmany
argument_list|,
name|i
argument_list|,
name|k1
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
name|dst_lim
operator|=
name|k1
operator|->
name|nkr_num_slots
expr_stmt|;
while|while
condition|(
name|howmany
operator|>
literal|0
operator|&&
name|k1
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|struct
name|netmap_slot
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
name|tmp
decl_stmt|;
name|src
operator|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|kring
operator|->
name|nr_hwcur
index|]
expr_stmt|;
name|dst
operator|=
operator|&
name|k1
operator|->
name|ring
operator|->
name|slot
index|[
name|k1
operator|->
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|tmp
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|->
name|buf_idx
operator|=
name|dst
operator|->
name|buf_idx
expr_stmt|;
name|src
operator|->
name|flags
operator|=
name|NS_BUF_CHANGED
expr_stmt|;
name|dst
operator|->
name|buf_idx
operator|=
name|tmp
operator|.
name|buf_idx
expr_stmt|;
name|dst
operator|->
name|len
operator|=
name|tmp
operator|.
name|len
expr_stmt|;
name|dst
operator|->
name|flags
operator|=
name|NS_BUF_CHANGED
expr_stmt|;
name|ND
argument_list|(
literal|"out len %d buf %d from %d to %d"
argument_list|,
name|dst
operator|->
name|len
argument_list|,
name|dst
operator|->
name|buf_idx
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|k1
operator|->
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|kring
operator|->
name|nr_hwcur
operator|>=
name|src_lim
condition|)
name|kring
operator|->
name|nr_hwcur
operator|=
literal|0
expr_stmt|;
name|howmany
operator|--
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|--
expr_stmt|;
if|if
condition|(
operator|++
name|k1
operator|->
name|ring
operator|->
name|cur
operator|>=
name|dst_lim
condition|)
name|k1
operator|->
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|k1
operator|->
name|ring
operator|->
name|avail
operator|--
expr_stmt|;
block|}
name|kring
operator|->
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
comment|// XXX
name|k1
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * netmap_sync_to_host() passes packets up. We are called from a  * system call in user process context, and the only contention  * can be among multiple user threads erroneously calling  * this routine concurrently.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_sync_to_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|na
operator|->
name|num_tx_rings
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|k
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|mbq
name|q
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|k
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|lim
condition|)
block|{
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// na->nm_lock(na->ifp, NETMAP_CORE_LOCK, 0);
comment|/* Take packets from hwcur to cur and pass them up. 	 * In case of no buffers we give up. At the end of the loop, 	 * the queue is drained in all cases. 	 */
name|netmap_grab_packets
argument_list|(
name|kring
argument_list|,
operator|&
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|k
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|=
name|ring
operator|->
name|avail
operator|=
name|lim
expr_stmt|;
comment|// na->nm_lock(na->ifp, NETMAP_CORE_UNLOCK, 0);
name|netmap_send_up
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|q
operator|.
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rxsync backend for packets coming from the host stack.  * They have been put in the queue by netmap_start() so we  * need to protect access to the kring using a lock.  *  * This routine also does the selrecord if called from the poll handler  * (we know because td != NULL).  *  * NOTE: on linux, selrecord() is defined as a macro and uses pwait  *     as an additional hidden argument.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_sync_from_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|pwait
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|j
decl_stmt|,
name|n
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
decl_stmt|;
name|u_int
name|k
init|=
name|ring
operator|->
name|cur
decl_stmt|,
name|resvd
init|=
name|ring
operator|->
name|reserved
decl_stmt|;
operator|(
name|void
operator|)
name|pwait
expr_stmt|;
comment|/* disable unused warnings */
name|na
operator|->
name|nm_lock
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|lim
condition|)
block|{
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* new packets are already set in nr_hwavail */
comment|/* skip past packets that userspace has released */
name|j
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|resvd
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|resvd
operator|+
name|ring
operator|->
name|avail
operator|>=
name|lim
operator|+
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"XXX invalid reserve/avail %d %d"
argument_list|,
name|resvd
argument_list|,
name|ring
operator|->
name|avail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|reserved
operator|=
name|resvd
operator|=
literal|0
expr_stmt|;
comment|// XXX panic...
block|}
name|k
operator|=
operator|(
name|k
operator|>=
name|resvd
operator|)
condition|?
name|k
operator|-
name|resvd
else|:
name|k
operator|+
name|lim
operator|-
name|resvd
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
name|k
condition|)
block|{
name|n
operator|=
name|k
operator|>=
name|j
condition|?
name|k
operator|-
name|j
else|:
name|k
operator|+
name|lim
operator|-
name|j
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|-=
name|n
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|k
expr_stmt|;
block|}
name|k
operator|=
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
operator|-
name|resvd
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
operator|&&
name|td
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|&&
operator|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
operator|)
condition|)
name|D
argument_list|(
literal|"%d pkts from stack"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a refcounted reference to an interface.  * Return ENXIO if the interface does not exist, EINVAL if netmap  * is not supported by the interface.  * If successful, hold a reference.  */
end_comment

begin_function
specifier|static
name|int
name|get_ifp
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ifnet
modifier|*
modifier|*
name|ifp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NM_BRIDGE
name|struct
name|ifnet
modifier|*
name|iter
init|=
name|NULL
decl_stmt|;
do|do
block|{
name|struct
name|nm_bridge
modifier|*
name|b
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|cand
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|NM_NAME
argument_list|,
sizeof|sizeof
argument_list|(
name|NM_NAME
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
break|break;
name|b
operator|=
name|nm_find_bridge
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"no bridges available for '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* XXX locking */
name|BDG_LOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* lookup in the local list of ports */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BDG_MAXPORTS
condition|;
name|i
operator|++
control|)
block|{
name|iter
operator|=
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|iter
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|cand
operator|==
operator|-
literal|1
condition|)
name|cand
operator|=
name|i
expr_stmt|;
comment|/* potential insert point */
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|iter
operator|->
name|if_xname
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|ADD_BDG_REF
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"found existing interface"
argument_list|)
expr_stmt|;
name|BDG_UNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|NM_BDG_MAXPORTS
condition|)
comment|/* already unlocked */
break|break;
if|if
condition|(
name|cand
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"bridge full, cannot create new port"
argument_list|)
expr_stmt|;
name|no_port
label|:
name|BDG_UNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
operator|*
name|ifp
operator|=
name|NULL
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|ND
argument_list|(
literal|"create new bridge port %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* space for forwarding list after the ifnet */
name|l
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|iter
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|nm_bdg_fwd
argument_list|)
operator|*
name|NM_BDG_BATCH
expr_stmt|;
name|iter
operator|=
name|malloc
argument_list|(
name|l
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iter
condition|)
goto|goto
name|no_port
goto|;
name|strcpy
argument_list|(
name|iter
operator|->
name|if_xname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bdg_netmap_attach
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|b
operator|->
name|bdg_ports
index|[
name|cand
index|]
operator|=
name|iter
expr_stmt|;
name|iter
operator|->
name|if_bridge
operator|=
name|b
expr_stmt|;
name|ADD_BDG_REF
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|BDG_UNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"attaching virtual bridge %p"
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
operator|*
name|ifp
operator|=
name|iter
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ifp
condition|)
endif|#
directive|endif
comment|/* NM_BRIDGE */
operator|*
name|ifp
operator|=
name|ifunit_ref
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* can do this if the capability exists and if_pspare[0] 	 * points to the netmap descriptor. 	 */
if|if
condition|(
name|NETMAP_CAPABLE
argument_list|(
operator|*
name|ifp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* valid pointer, we hold the refcount */
name|nm_if_rele
argument_list|(
operator|*
name|ifp
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
comment|// not NETMAP capable
block|}
end_function

begin_comment
comment|/*  * Error routine called when txsync/rxsync detects an error.  * Can't do much more than resetting cur = hwcur, avail = hwavail.  * Return 1 on reinit.  *  * This routine is only called by the upper half of the kernel.  * It only reads hwcur (which is changed only by the upper half, too)  * and hwavail (which may be changed by the lower half, but only on  * a tx ring and only to increase it, so any error will be recovered  * on the next call). For the above, we don't strictly need to call  * it under lock.  */
end_comment

begin_function
name|int
name|netmap_ring_reinit
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|RD
argument_list|(
literal|10
argument_list|,
literal|"called for %s"
argument_list|,
name|kring
operator|->
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|cur
operator|>
name|lim
condition|)
name|errors
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|idx
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
decl_stmt|;
name|u_int
name|len
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|2
operator|||
name|idx
operator|>=
name|netmap_total_buffers
condition|)
block|{
if|if
condition|(
operator|!
name|errors
operator|++
condition|)
name|D
argument_list|(
literal|"bad buffer at slot %d idx %d len %d "
argument_list|,
name|i
argument_list|,
name|idx
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
name|NETMAP_BUF_SIZE
condition|)
block|{
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|errors
operator|++
condition|)
name|D
argument_list|(
literal|"bad len %d at slot %d idx %d"
argument_list|,
name|len
argument_list|,
name|i
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errors
condition|)
block|{
name|int
name|pos
init|=
name|kring
operator|-
name|kring
operator|->
name|na
operator|->
name|tx_rings
decl_stmt|;
name|int
name|n
init|=
name|kring
operator|->
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
decl_stmt|;
name|RD
argument_list|(
literal|10
argument_list|,
literal|"total %d errors"
argument_list|,
name|errors
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|RD
argument_list|(
literal|10
argument_list|,
literal|"%s %s[%d] reinit, cur %d -> %d avail %d -> %d"
argument_list|,
name|kring
operator|->
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|pos
operator|<
name|n
condition|?
literal|"TX"
else|:
literal|"RX"
argument_list|,
name|pos
operator|<
name|n
condition|?
name|pos
else|:
name|pos
operator|-
name|n
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|ring
operator|->
name|avail
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
block|}
return|return
operator|(
name|errors
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the ring ID. For devices with a single queue, a request  * for all rings is the same as a single ring.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_set_ringid
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|u_int
name|ringid
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|np_ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|u_int
name|i
init|=
name|ringid
operator|&
name|NETMAP_RING_MASK
decl_stmt|;
comment|/* initially (np_qfirst == np_qlast) we don't want to lock */
name|int
name|need_lock
init|=
operator|(
name|priv
operator|->
name|np_qfirst
operator|!=
name|priv
operator|->
name|np_qlast
operator|)
decl_stmt|;
name|int
name|lim
init|=
name|na
operator|->
name|num_rx_rings
decl_stmt|;
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|>
name|lim
condition|)
name|lim
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
if|if
condition|(
operator|(
name|ringid
operator|&
name|NETMAP_HW_RING
operator|)
operator|&&
name|i
operator|>=
name|lim
condition|)
block|{
name|D
argument_list|(
literal|"invalid ring id %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|need_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_ringid
operator|=
name|ringid
expr_stmt|;
if|if
condition|(
name|ringid
operator|&
name|NETMAP_SW_RING
condition|)
block|{
name|priv
operator|->
name|np_qfirst
operator|=
name|NETMAP_SW_RING
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ringid
operator|&
name|NETMAP_HW_RING
condition|)
block|{
name|priv
operator|->
name|np_qfirst
operator|=
name|i
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|->
name|np_qfirst
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
name|NETMAP_HW_RING
expr_stmt|;
block|}
name|priv
operator|->
name|np_txpoll
operator|=
operator|(
name|ringid
operator|&
name|NETMAP_NO_TX_POLL
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|need_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
block|{
if|if
condition|(
name|ringid
operator|&
name|NETMAP_SW_RING
condition|)
name|D
argument_list|(
literal|"ringid %s set to SW RING"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ringid
operator|&
name|NETMAP_HW_RING
condition|)
name|D
argument_list|(
literal|"ringid %s set to HW RING %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|priv
operator|->
name|np_qfirst
argument_list|)
expr_stmt|;
else|else
name|D
argument_list|(
literal|"ringid %s set to all %d HW RINGS"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ioctl(2) support for the "netmap" device.  *  * Following a list of accepted commands:  * - NIOCGINFO  * - SIOCGIFADDR	just for convenience  * - NIOCREGIF  * - NIOCUNREGIF  * - NIOCTXSYNC  * - NIOCRXSYNC  *  * Return 0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|nmreq
modifier|*
name|nmr
init|=
operator|(
expr|struct
name|nmreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|lim
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
operator|(
name|void
operator|)
name|dev
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|fflag
expr_stmt|;
comment|/* UNUSED */
ifdef|#
directive|ifdef
name|linux
define|#
directive|define
name|devfs_get_cdevpriv
parameter_list|(
name|pp
parameter_list|)
define|\
value|({ *(struct netmap_priv_d **)pp = ((struct file *)td)->private_data; 	\ 		(*pp ? 0 : ENOENT); })
comment|/* devfs_set_cdevpriv cannot fail on linux */
define|#
directive|define
name|devfs_set_cdevpriv
parameter_list|(
name|p
parameter_list|,
name|fn
parameter_list|)
define|\
value|({ ((struct file *)td)->private_data = p; (p ? 0 : EINVAL); })
define|#
directive|define
name|devfs_clear_cdevpriv
parameter_list|()
value|do {				\ 		netmap_dtor(priv); ((struct file *)td)->private_data = 0;	\ 	} while (0)
endif|#
directive|endif
comment|/* linux */
name|CURVNET_SET
argument_list|(
name|TD_TO_VNET
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
comment|/* XXX ENOENT should be impossible, since the priv 		 * is now created in the open */
return|return
operator|(
name|error
operator|==
name|ENOENT
condition|?
name|ENXIO
else|:
name|error
operator|)
return|;
block|}
name|nmr
operator|->
name|nr_name
index|[
sizeof|sizeof
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* truncate name */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NIOCGINFO
case|:
comment|/* return capabilities etc */
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|!=
name|NETMAP_API
condition|)
block|{
name|D
argument_list|(
literal|"API mismatch got %d have %d"
argument_list|,
name|nmr
operator|->
name|nr_version
argument_list|,
name|NETMAP_API
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* update configuration */
name|error
operator|=
name|netmap_get_memory
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"get_memory returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* memsize is always valid */
name|nmr
operator|->
name|nr_memsize
operator|=
name|nm_mem
operator|.
name|nm_totalsize
expr_stmt|;
name|nmr
operator|->
name|nr_offset
operator|=
literal|0
expr_stmt|;
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|nmr
operator|->
name|nr_tx_rings
operator|=
literal|0
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|nmr
operator|->
name|nr_tx_slots
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* just get memory info */
break|break;
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
comment|/* get a refcount */
if|if
condition|(
name|error
condition|)
break|break;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap_adapter */
name|netmap_update_config
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
break|break;
case|case
name|NIOCREGIF
case|:
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|!=
name|NETMAP_API
condition|)
block|{
name|nmr
operator|->
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* ensure allocators are ready */
name|error
operator|=
name|netmap_get_memory
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"get_memory returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* protect access to priv from concurrent NIOCREGIF */
name|NMA_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_ifp
operator|!=
name|NULL
condition|)
block|{
comment|/* thread already registered */
name|error
operator|=
name|netmap_set_ringid
argument_list|(
name|priv
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|)
expr_stmt|;
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* find the interface and a reference */
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
block|{
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
for|for
control|(
name|i
operator|=
literal|10
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NETMAP_DELETING
argument_list|(
name|na
argument_list|)
condition|)
break|break;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|na
argument_list|,
literal|0
argument_list|,
literal|"NIOCREGIF"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"too many NIOCREGIF attempts, give up"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* ring configuration may have changed, fetch from the card */
name|netmap_update_config
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* store the reference */
name|error
operator|=
name|netmap_set_ringid
argument_list|(
name|priv
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
name|nifp
operator|=
name|netmap_if_new
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
block|{
comment|/* allocation failed */
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
comment|/* was already set */
block|}
else|else
block|{
comment|/* Otherwise set the card in netmap mode 			 * and make it use the shared buffers. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|,
literal|"nm_txq_lock"
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|mtx_init
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|,
literal|"nm_rxq_lock"
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|na
operator|->
name|nm_register
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* mode on */
if|if
condition|(
name|error
condition|)
block|{
name|netmap_dtor_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|netmap_if_free
argument_list|(
name|nifp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* reg. failed, release priv and ref */
name|error
label|:
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
name|priv
operator|->
name|np_ifp
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|np_nifp
operator|=
name|NULL
expr_stmt|;
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* the following assignment is a commitment. 		 * Readers (i.e., poll and *SYNC) check for 		 * np_nifp != NULL without locking 		 */
name|wmb
argument_list|()
expr_stmt|;
comment|/* make sure previous writes are visible to all CPUs */
name|priv
operator|->
name|np_nifp
operator|=
name|nifp
expr_stmt|;
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
comment|/* return the offset of the netmap_if object */
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_memsize
operator|=
name|nm_mem
operator|.
name|nm_totalsize
expr_stmt|;
name|nmr
operator|->
name|nr_offset
operator|=
name|netmap_if_offset
argument_list|(
name|nifp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIOCUNREGIF
case|:
comment|// XXX we have no data here ?
name|D
argument_list|(
literal|"deprecated, data is %p"
argument_list|,
name|nmr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NIOCTXSYNC
case|:
case|case
name|NIOCRXSYNC
case|:
name|nifp
operator|=
name|priv
operator|->
name|np_nifp
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|rmb
argument_list|()
expr_stmt|;
comment|/* make sure following reads are not from cache */
name|ifp
operator|=
name|priv
operator|->
name|np_ifp
expr_stmt|;
comment|/* we have a reference */
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"Internal error: nifp != NULL&& ifp == NULL"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
if|if
condition|(
name|priv
operator|->
name|np_qfirst
operator|==
name|NETMAP_SW_RING
condition|)
block|{
comment|/* host rings */
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
name|netmap_sync_to_host
argument_list|(
name|na
argument_list|)
expr_stmt|;
else|else
name|netmap_sync_from_host
argument_list|(
name|na
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* find the last ring to scan */
name|lim
operator|=
name|priv
operator|->
name|np_qlast
expr_stmt|;
if|if
condition|(
name|lim
operator|==
name|NETMAP_HW_RING
condition|)
name|lim
operator|=
operator|(
name|cmd
operator|==
name|NIOCTXSYNC
operator|)
condition|?
name|na
operator|->
name|num_tx_rings
else|:
name|na
operator|->
name|num_rx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"pre txsync ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_txsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
literal|1
comment|/* do lock */
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"post txsync ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|na
operator|->
name|nm_rxsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
literal|1
comment|/* do lock */
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|__FreeBSD__
case|case
name|BIOCIMMEDIATE
case|:
case|case
name|BIOCGHDRCMPLT
case|:
case|case
name|BIOCSHDRCMPLT
case|:
case|case
name|BIOCSSEESENT
case|:
name|D
argument_list|(
literal|"ignore BIOCIMMEDIATE/BIOCSHDRCMPLT/BIOCSHDRCMPLT/BIOCSSEESENT"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* allow device-specific ioctls */
block|{
name|struct
name|socket
name|so
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|so
argument_list|,
sizeof|sizeof
argument_list|(
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
break|break;
name|so
operator|.
name|so_vnet
operator|=
name|ifp
operator|->
name|if_vnet
expr_stmt|;
comment|// so->so_proto not null.
name|error
operator|=
name|ifioctl
argument_list|(
operator|&
name|so
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
comment|/* linux */
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
comment|/* linux */
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * select(2) and poll(2) handlers for the "netmap" device.  *  * Can be called for one or more queues.  * Return true the event mask corresponding to ready events.  * If there are no ready events, do a selrecord on either individual  * selfd or on the global one.  * Device-dependent parts (locking and sync of tx/rx rings)  * are done through callbacks.  *  * On linux, arguments are really pwait, the poll table, and 'td' is struct file *  * The first one is remapped to pwait as selrecord() uses the name as an  * hidden argument.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|u_int
name|core_lock
decl_stmt|,
name|i
decl_stmt|,
name|check_all
decl_stmt|,
name|want_tx
decl_stmt|,
name|want_rx
decl_stmt|,
name|revents
init|=
literal|0
decl_stmt|;
name|u_int
name|lim_tx
decl_stmt|,
name|lim_rx
decl_stmt|,
name|host_forwarded
init|=
literal|0
decl_stmt|;
name|struct
name|mbq
name|q
init|=
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
enum|enum
block|{
name|NO_CL
block|,
name|NEED_CL
block|,
name|LOCKED_CL
block|}
enum|;
comment|/* see below */
name|void
modifier|*
name|pwait
init|=
name|dev
decl_stmt|;
comment|/* linux compatibility */
operator|(
name|void
operator|)
name|pwait
expr_stmt|;
if|if
condition|(
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
operator|!=
literal|0
operator|||
name|priv
operator|==
name|NULL
condition|)
return|return
name|POLLERR
return|;
if|if
condition|(
name|priv
operator|->
name|np_nifp
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"No if registered"
argument_list|)
expr_stmt|;
return|return
name|POLLERR
return|;
block|}
name|rmb
argument_list|()
expr_stmt|;
comment|/* make sure following reads are not from cache */
name|ifp
operator|=
name|priv
operator|->
name|np_ifp
expr_stmt|;
comment|// XXX check for deleting() ?
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
operator|==
literal|0
condition|)
return|return
name|POLLERR
return|;
if|if
condition|(
name|netmap_verbose
operator|&
literal|0x8000
condition|)
name|D
argument_list|(
literal|"device %s events 0x%x"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|events
argument_list|)
expr_stmt|;
name|want_tx
operator|=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
name|want_rx
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
name|lim_tx
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|lim_rx
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
comment|/* how many queues we are scanning */
if|if
condition|(
name|priv
operator|->
name|np_qfirst
operator|==
name|NETMAP_SW_RING
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|np_txpoll
operator|||
name|want_tx
condition|)
block|{
comment|/* push any packets up, then we are always ready */
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|lim_tx
index|]
expr_stmt|;
name|netmap_sync_to_host
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|revents
operator||=
name|want_tx
expr_stmt|;
block|}
if|if
condition|(
name|want_rx
condition|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|lim_rx
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|==
literal|0
condition|)
name|netmap_sync_from_host
argument_list|(
name|na
argument_list|,
name|td
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
block|}
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
comment|/* if we are in transparent mode, check also the host rx ring */
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|lim_rx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|np_qlast
operator|==
name|NETMAP_HW_RING
operator|)
comment|// XXX check_all
operator|&&
name|want_rx
operator|&&
operator|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
operator|)
condition|)
block|{
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|==
literal|0
condition|)
name|netmap_sync_from_host
argument_list|(
name|na
argument_list|,
name|td
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
name|revents
operator||=
name|want_rx
expr_stmt|;
block|}
comment|/* 	 * check_all is set if the card has more than one queue and 	 * the client is polling all of them. If true, we sleep on 	 * the "global" selfd, otherwise we sleep on individual selfd 	 * (we can only sleep on one of them per direction). 	 * The interrupt routine in the driver should always wake on 	 * the individual selfd, and also on the global one if the card 	 * has more than one ring. 	 * 	 * If the card has only one lock, we just use that. 	 * If the card has separate ring locks, we just use those 	 * unless we are doing check_all, in which case the whole 	 * loop is wrapped by the global lock. 	 * We acquire locks only when necessary: if poll is called 	 * when buffers are available, we can just return without locks. 	 * 	 * rxsync() is only called if we run out of buffers on a POLLIN. 	 * txsync() is called if we run out of buffers on POLLOUT, or 	 * there are pending packets to send. The latter can be disabled 	 * passing NETMAP_NO_TX_POLL in the NIOCREG call. 	 */
name|check_all
operator|=
operator|(
name|priv
operator|->
name|np_qlast
operator|==
name|NETMAP_HW_RING
operator|)
operator|&&
operator|(
name|lim_tx
operator|>
literal|1
operator|||
name|lim_rx
operator|>
literal|1
operator|)
expr_stmt|;
comment|/* 	 * core_lock indicates what to do with the core lock. 	 * The core lock is used when either the card has no individual 	 * locks, or it has individual locks but we are cheking all 	 * rings so we need the core lock to avoid missing wakeup events. 	 * 	 * It has three possible states: 	 * NO_CL	we don't need to use the core lock, e.g. 	 *		because we are protected by individual locks. 	 * NEED_CL	we need the core lock. In this case, when we 	 *		call the lock routine, move to LOCKED_CL 	 *		to remember to release the lock once done. 	 * LOCKED_CL	core lock is set, so we need to release it. 	 */
name|core_lock
operator|=
operator|(
name|check_all
operator|||
operator|!
name|na
operator|->
name|separate_locks
operator|)
condition|?
name|NEED_CL
else|:
name|NO_CL
expr_stmt|;
ifdef|#
directive|ifdef
name|NM_BRIDGE
comment|/* the bridge uses separate locks */
if|if
condition|(
name|na
operator|->
name|nm_register
operator|==
name|bdg_netmap_reg
condition|)
block|{
name|ND
argument_list|(
literal|"not using core lock for %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|core_lock
operator|=
name|NO_CL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NM_BRIDGE */
if|if
condition|(
name|priv
operator|->
name|np_qlast
operator|!=
name|NETMAP_HW_RING
condition|)
block|{
name|lim_tx
operator|=
name|lim_rx
operator|=
name|priv
operator|->
name|np_qlast
expr_stmt|;
block|}
comment|/* 	 * We start with a lock free round which is good if we have 	 * data available. If this fails, then lock and call the sync 	 * routines. 	 */
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|want_rx
operator|&&
name|i
operator|<
name|lim_rx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
name|want_rx
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|want_tx
operator|&&
name|i
operator|<
name|lim_tx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
comment|/* 	 * If we to push packets out (priv->np_txpoll) or want_tx is 	 * still set, we do need to run the txsync calls (on all rings, 	 * to avoid that the tx rings stall). 	 */
if|if
condition|(
name|priv
operator|->
name|np_txpoll
operator|||
name|want_tx
condition|)
block|{
name|flush_tx
label|:
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim_tx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
comment|/* 			 * Skip the current ring if want_tx == 0 			 * (we have already done a successful sync on 			 * a previous ring) AND kring->cur == kring->hwcur 			 * (there are no pending transmissions for this ring). 			 */
if|if
condition|(
operator|!
name|want_tx
operator|&&
name|kring
operator|->
name|ring
operator|->
name|cur
operator|==
name|kring
operator|->
name|nr_hwcur
condition|)
continue|continue;
if|if
condition|(
name|core_lock
operator|==
name|NEED_CL
condition|)
block|{
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|core_lock
operator|=
name|LOCKED_CL
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_TX_LOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"send %d on %s %d"
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_txsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
literal|0
comment|/* no lock */
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
comment|/* Check avail/call selrecord only if called with POLLOUT */
if|if
condition|(
name|want_tx
condition|)
block|{
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
comment|/* stop at the first ring. We don't risk 					 * starvation. 					 */
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|check_all
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_TX_UNLOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * now if want_rx is still set we need to lock and rxsync. 	 * Do it on all rings because otherwise we starve. 	 */
if|if
condition|(
name|want_rx
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim_rx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|core_lock
operator|==
name|NEED_CL
condition|)
block|{
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|core_lock
operator|=
name|LOCKED_CL
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_RX_LOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
condition|)
block|{
name|ND
argument_list|(
literal|10
argument_list|,
literal|"forwarding some buffers up %d to %d"
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|netmap_grab_packets
argument_list|(
name|kring
argument_list|,
operator|&
name|q
argument_list|,
name|netmap_fwd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|nm_rxsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
literal|0
comment|/* no lock */
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
if|if
condition|(
name|netmap_no_timestamp
operator|==
literal|0
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_TIMESTAMP
condition|)
block|{
name|microtime
argument_list|(
operator|&
name|kring
operator|->
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
name|revents
operator||=
name|want_rx
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|check_all
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_RX_UNLOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|check_all
operator|&&
name|revents
operator|==
literal|0
condition|)
block|{
comment|/* signal on the global queue */
if|if
condition|(
name|want_tx
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|na
operator|->
name|tx_si
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_rx
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|na
operator|->
name|rx_si
argument_list|)
expr_stmt|;
block|}
comment|/* forward host to the netmap ring */
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|lim_rx
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwavail
operator|>
literal|0
condition|)
name|ND
argument_list|(
literal|"host rx %d has %d packets"
argument_list|,
name|lim_rx
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|np_qlast
operator|==
name|NETMAP_HW_RING
operator|)
comment|// XXX check_all
operator|&&
operator|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
operator|)
operator|&&
name|kring
operator|->
name|nr_hwavail
operator|>
literal|0
operator|&&
operator|!
name|host_forwarded
condition|)
block|{
if|if
condition|(
name|core_lock
operator|==
name|NEED_CL
condition|)
block|{
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|core_lock
operator|=
name|LOCKED_CL
expr_stmt|;
block|}
name|netmap_sw_to_nic
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|host_forwarded
operator|=
literal|1
expr_stmt|;
comment|/* prevent another pass */
name|want_rx
operator|=
literal|0
expr_stmt|;
goto|goto
name|flush_tx
goto|;
block|}
if|if
condition|(
name|core_lock
operator|==
name|LOCKED_CL
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|.
name|head
condition|)
name|netmap_send_up
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|q
operator|.
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------- driver support routines ------*/
end_comment

begin_comment
comment|/*  * default lock wrapper.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_lock_wrapper
parameter_list|(
name|struct
name|ifnet
modifier|*
name|dev
parameter_list|,
name|int
name|what
parameter_list|,
name|u_int
name|queueid
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
ifdef|#
directive|ifdef
name|linux
comment|/* some system do not need lock on register */
case|case
name|NETMAP_REG_LOCK
case|:
case|case
name|NETMAP_REG_UNLOCK
case|:
break|break;
endif|#
directive|endif
comment|/* linux */
case|case
name|NETMAP_CORE_LOCK
case|:
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_CORE_UNLOCK
case|:
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_TX_LOCK
case|:
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_TX_UNLOCK
case|:
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_RX_LOCK
case|:
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_RX_UNLOCK
case|:
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize a ``netmap_adapter`` object created by driver on attach.  * We allocate a block of memory with room for a struct netmap_adapter  * plus two sets of N+2 struct netmap_kring (where N is the number  * of hardware rings):  * krings	0..N-1	are for the hardware queues.  * kring	N	is for the host stack queue  * kring	N+1	is only used for the selinfo for all queues.  * Return 0 on success, ENOMEM otherwise.  *  * By default the receive and transmit adapter ring counts are both initialized  * to num_queues.  na->num_tx_rings can be set for cards with different tx/rx  * setups.  */
end_comment

begin_function
name|int
name|netmap_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|arg
parameter_list|,
name|int
name|num_queues
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|arg
condition|?
name|arg
operator|->
name|ifp
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
name|ifp
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|na
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|WNA
argument_list|(
name|ifp
argument_list|)
operator|=
name|na
expr_stmt|;
operator|*
name|na
operator|=
operator|*
name|arg
expr_stmt|;
comment|/* copy everything, trust the driver to not pass junk */
name|NETMAP_SET_CAPABLE
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|==
literal|0
condition|)
name|na
operator|->
name|num_tx_rings
operator|=
name|num_queues
expr_stmt|;
name|na
operator|->
name|num_rx_rings
operator|=
name|num_queues
expr_stmt|;
name|na
operator|->
name|refcount
operator|=
name|na
operator|->
name|na_single
operator|=
name|na
operator|->
name|na_multi
operator|=
literal|0
expr_stmt|;
comment|/* Core lock initialized here, others after netmap_if_new. */
name|mtx_init
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|,
literal|"netmap core lock"
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_lock
operator|==
name|NULL
condition|)
block|{
name|ND
argument_list|(
literal|"using default locks for %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
operator|=
name|netmap_lock_wrapper
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|linux
if|if
condition|(
name|ifp
operator|->
name|netdev_ops
condition|)
block|{
name|ND
argument_list|(
literal|"netdev_ops %p"
argument_list|,
name|ifp
operator|->
name|netdev_ops
argument_list|)
expr_stmt|;
comment|/* prepare a clone of the netdev ops */
name|na
operator|->
name|nm_ndo
operator|=
operator|*
name|ifp
operator|->
name|netdev_ops
expr_stmt|;
block|}
name|na
operator|->
name|nm_ndo
operator|.
name|ndo_start_xmit
operator|=
name|linux_netmap_start
expr_stmt|;
endif|#
directive|endif
name|D
argument_list|(
literal|"success for %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|D
argument_list|(
literal|"fail, arg %p ifp %p na %p"
argument_list|,
name|arg
argument_list|,
name|ifp
argument_list|,
name|na
argument_list|)
expr_stmt|;
return|return
operator|(
name|na
condition|?
name|EINVAL
else|:
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the allocated memory linked to the given ``netmap_adapter``  * object.  */
end_comment

begin_function
name|void
name|netmap_detach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|na
condition|)
return|return;
name|mtx_destroy
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|tx_rings
condition|)
block|{
comment|/* XXX should not happen */
name|D
argument_list|(
literal|"freeing leftover tx_rings"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|na
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|na
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|WNA
argument_list|(
name|ifp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|na
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Intercept packets from the network stack and pass them  * to netmap as incoming packets on the 'software' ring.  * We are not locked when called.  */
end_comment

begin_function
name|int
name|netmap_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|len
init|=
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|u_int
name|error
init|=
name|EBUSY
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"%s packet %d len %d from the stack"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwavail
operator|>=
name|lim
condition|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"stack ring %s full\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* no space */
block|}
if|if
condition|(
name|len
operator|>
name|NETMAP_BUF_SIZE
condition|)
block|{
name|D
argument_list|(
literal|"%s from_host, drop packet size %d> %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|len
argument_list|,
name|NETMAP_BUF_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* too long for us */
block|}
comment|/* compute the insert position */
name|i
operator|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|lim
condition|)
name|i
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
name|slot
operator|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|i
index|]
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|NMB
argument_list|(
name|slot
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
name|kring
operator|->
name|nkr_slot_flags
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|++
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"wake up host ring %s %d"
argument_list|,
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* release the mbuf in either cases of success or failure. As an 	 * alternative, put the mbuf in a free list and free the list 	 * only when really necessary. 	 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * netmap_reset() is called by the driver routines when reinitializing  * a ring. The driver is in charge of locking to protect the kring.  * If netmap mode is not set just return NULL.  */
end_comment

begin_function
name|struct
name|netmap_slot
modifier|*
name|netmap_reset
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|enum
name|txrx
name|tx
parameter_list|,
name|int
name|n
parameter_list|,
name|u_int
name|new_cur
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|int
name|new_hwofs
decl_stmt|,
name|lim
decl_stmt|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* no netmap support here */
if|if
condition|(
operator|!
operator|(
name|na
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* nothing to reinitialize */
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|na
operator|->
name|num_tx_rings
condition|)
return|return
name|NULL
return|;
name|kring
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|n
expr_stmt|;
name|new_hwofs
operator|=
name|kring
operator|->
name|nr_hwcur
operator|-
name|new_cur
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|n
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
return|return
name|NULL
return|;
name|kring
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|n
expr_stmt|;
name|new_hwofs
operator|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
operator|-
name|new_cur
expr_stmt|;
block|}
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new_hwofs
operator|>
name|lim
condition|)
name|new_hwofs
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
comment|/* Alwayws set the new offset value and realign the ring. */
name|kring
operator|->
name|nkr_hwofs
operator|=
name|new_hwofs
expr_stmt|;
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
name|kring
operator|->
name|nr_hwavail
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
name|ND
argument_list|(
literal|10
argument_list|,
literal|"new hwofs %d on %s %s[%d]"
argument_list|,
name|kring
operator|->
name|nkr_hwofs
argument_list|,
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|tx
operator|==
name|NR_TX
condition|?
literal|"TX"
else|:
literal|"RX"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|// def linux
comment|/* XXX check that the mappings are correct */
comment|/* need ring_nr, adapter->pdev, direction */
block|buffer_info->dma = dma_map_single(&pdev->dev, addr, adapter->rx_buffer_len, DMA_FROM_DEVICE); 	if (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)) { 		D("error mapping rx netmap buffer %d", i);
comment|// XXX fix error handling
block|}
endif|#
directive|endif
comment|/* linux */
comment|/* 	 * Wakeup on the individual and global lock 	 * We do the wakeup here, but the ring is not yet reconfigured. 	 * However, we are under lock so there are no races. 	 */
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
name|tx
operator|==
name|NR_TX
condition|?
operator|&
name|na
operator|->
name|tx_si
else|:
operator|&
name|na
operator|->
name|rx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
return|return
name|kring
operator|->
name|ring
operator|->
name|slot
return|;
block|}
end_function

begin_comment
comment|/*  * Default functions to handle rx/tx interrupts  * we have 4 cases:  * 1 ring, single lock:  *	lock(core); wake(i=0); unlock(core)  * N rings, single lock:  *	lock(core); wake(i); wake(N+1) unlock(core)  * 1 ring, separate locks: (i=0)  *	lock(i); wake(i); unlock(i)  * N rings, separate locks:  *	lock(i); wake(i); unlock(i); lock(core) wake(N+1) unlock(core)  * work_done is non-null on the RX path.  */
end_comment

begin_function
name|int
name|netmap_rx_irq
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|q
parameter_list|,
name|int
modifier|*
name|work_done
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|r
decl_stmt|;
name|NM_SELINFO_T
modifier|*
name|main_wq
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
return|return
literal|0
return|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"received %s queue %d"
argument_list|,
name|work_done
condition|?
literal|"RX"
else|:
literal|"TX"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_SKIP_INTR
condition|)
block|{
name|ND
argument_list|(
literal|"use regular interrupt"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|work_done
condition|)
block|{
comment|/* RX path */
if|if
condition|(
name|q
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
return|return
literal|0
return|;
comment|// regular queue
name|r
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|q
expr_stmt|;
name|r
operator|->
name|nr_kflags
operator||=
name|NKR_PENDINTR
expr_stmt|;
name|main_wq
operator|=
operator|(
name|na
operator|->
name|num_rx_rings
operator|>
literal|1
operator|)
condition|?
operator|&
name|na
operator|->
name|rx_si
else|:
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* tx path */
if|if
condition|(
name|q
operator|>=
name|na
operator|->
name|num_tx_rings
condition|)
return|return
literal|0
return|;
comment|// regular queue
name|r
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|q
expr_stmt|;
name|main_wq
operator|=
operator|(
name|na
operator|->
name|num_tx_rings
operator|>
literal|1
operator|)
condition|?
operator|&
name|na
operator|->
name|tx_si
else|:
name|NULL
expr_stmt|;
name|work_done
operator|=
operator|&
name|q
expr_stmt|;
comment|/* dummy */
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|r
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|r
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|r
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_wq
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
name|main_wq
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|r
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_wq
condition|)
name|selwakeuppri
argument_list|(
name|main_wq
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
block|}
operator|*
name|work_done
operator|=
literal|1
expr_stmt|;
comment|/* do not fire napi again */
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_comment
comment|/* linux-specific routines */
end_comment

begin_comment
comment|/*  * Remap linux arguments into the FreeBSD call.  * - pwait is the poll table, passed as 'dev';  *   If pwait == NULL someone else already woke up before. We can report  *   events but they are filtered upstream.  *   If pwait != NULL, then pwait->key contains the list of events.  * - events is computed from pwait as above.  * - file is passed as 'td';  */
end_comment

begin_function
specifier|static
name|u_int
name|linux_netmap_poll
parameter_list|(
name|struct
name|file
modifier|*
name|file
parameter_list|,
name|struct
name|poll_table_struct
modifier|*
name|pwait
parameter_list|)
block|{
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|3
operator|,
literal|4
operator|,
literal|0
argument_list|)
name|int
name|events
init|=
name|pwait
condition|?
name|pwait
operator|->
name|key
else|:
name|POLLIN
operator||
name|POLLOUT
decl_stmt|;
else|#
directive|else
comment|/* in 3.4.0 field 'key' was renamed to '_key' */
name|int
name|events
init|=
name|pwait
condition|?
name|pwait
operator|->
name|_key
else|:
name|POLLIN
operator||
name|POLLOUT
decl_stmt|;
endif|#
directive|endif
return|return
name|netmap_poll
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pwait
argument_list|,
name|events
argument_list|,
operator|(
name|void
operator|*
operator|)
name|file
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|linux_netmap_mmap
parameter_list|(
name|struct
name|file
modifier|*
name|f
parameter_list|,
name|struct
name|vm_area_struct
modifier|*
name|vma
parameter_list|)
block|{
name|int
name|lut_skip
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|user_skip
init|=
literal|0
decl_stmt|;
name|struct
name|lut_entry
modifier|*
name|l_entry
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|off
decl_stmt|,
name|tomap
decl_stmt|;
comment|/* 	 * vma->vm_start: start of mapping user address space 	 * vma->vm_end: end of the mapping user address space 	 * vma->vm_pfoff: offset of first page in the device 	 */
comment|// XXX security checks
name|error
operator|=
name|netmap_get_memory
argument_list|(
name|f
operator|->
name|private_data
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"get_memory returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
name|off
operator|=
name|vma
operator|->
name|vm_pgoff
operator|<<
name|PAGE_SHIFT
expr_stmt|;
comment|/* offset in bytes */
name|tomap
operator|=
name|vma
operator|->
name|vm_end
operator|-
name|vma
operator|->
name|vm_start
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NETMAP_POOLS_NR
condition|;
name|i
operator|++
control|)
block|{
comment|/* loop through obj_pools */
specifier|const
name|struct
name|netmap_obj_pool
modifier|*
name|p
init|=
operator|&
name|nm_mem
operator|.
name|pools
index|[
name|i
index|]
decl_stmt|;
comment|/* 		 * In each pool memory is allocated in clusters 		 * of size _clustsize, each containing clustentries 		 * entries. For each object k we already store the 		 * vtophys mapping in lut[k] so we use that, scanning 		 * the lut[] array in steps of clustentries, 		 * and we map each cluster (not individual pages, 		 * it would be overkill). 		 */
comment|/* 		 * We interpret vm_pgoff as an offset into the whole 		 * netmap memory, as if all clusters where contiguous. 		 */
for|for
control|(
name|lut_skip
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p
operator|->
name|_numclusters
condition|;
name|j
operator|++
operator|,
name|lut_skip
operator|+=
name|p
operator|->
name|clustentries
control|)
block|{
name|unsigned
name|long
name|paddr
decl_stmt|,
name|mapsize
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|_clustsize
operator|<=
name|off
condition|)
block|{
name|off
operator|-=
name|p
operator|->
name|_clustsize
expr_stmt|;
continue|continue;
block|}
name|l_entry
operator|=
operator|&
name|p
operator|->
name|lut
index|[
name|lut_skip
index|]
expr_stmt|;
comment|/* first obj in the cluster */
name|paddr
operator|=
name|l_entry
operator|->
name|paddr
operator|+
name|off
expr_stmt|;
name|mapsize
operator|=
name|p
operator|->
name|_clustsize
operator|-
name|off
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mapsize
operator|>
name|tomap
condition|)
name|mapsize
operator|=
name|tomap
expr_stmt|;
name|ND
argument_list|(
literal|"remap_pfn_range(%lx, %lx, %lx)"
argument_list|,
name|vma
operator|->
name|vm_start
operator|+
name|user_skip
argument_list|,
name|paddr
operator|>>
name|PAGE_SHIFT
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|remap_pfn_range
argument_list|(
name|vma
argument_list|,
name|vma
operator|->
name|vm_start
operator|+
name|user_skip
argument_list|,
name|paddr
operator|>>
name|PAGE_SHIFT
argument_list|,
name|mapsize
argument_list|,
name|vma
operator|->
name|vm_page_prot
argument_list|)
condition|)
return|return
operator|-
name|EAGAIN
return|;
comment|// XXX check return value
name|user_skip
operator|+=
name|mapsize
expr_stmt|;
name|tomap
operator|-=
name|mapsize
expr_stmt|;
if|if
condition|(
name|tomap
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|netdev_tx_t
name|linux_netmap_start
parameter_list|(
name|struct
name|sk_buff
modifier|*
name|skb
parameter_list|,
name|struct
name|net_device
modifier|*
name|dev
parameter_list|)
block|{
name|netmap_start
argument_list|(
name|dev
argument_list|,
name|skb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NETDEV_TX_OK
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|37
argument_list|)
end_if

begin_comment
comment|// XXX was 38
end_comment

begin_define
define|#
directive|define
name|LIN_IOCTL_NAME
value|.ioctl
end_define

begin_decl_stmt
name|int
name|linux_netmap_ioctl
argument_list|(
expr|struct
name|inode
operator|*
name|inode
argument_list|,
expr|struct
name|file
operator|*
name|file
argument_list|,
name|u_int
name|cmd
argument_list|,
name|u_long
name|data
comment|/* arg */
argument_list|)
else|#
directive|else
define|#
directive|define
name|LIN_IOCTL_NAME
value|.unlocked_ioctl
name|long
name|linux_netmap_ioctl
argument_list|(
expr|struct
name|file
operator|*
name|file
argument_list|,
name|u_int
name|cmd
argument_list|,
name|u_long
name|data
comment|/* arg */
argument_list|)
endif|#
directive|endif
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|nmreq
name|nmr
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|nmr
argument_list|,
sizeof|sizeof
argument_list|(
name|nmr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&&
name|copy_from_user
argument_list|(
operator|&
name|nmr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|nmr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
name|EFAULT
return|;
name|ret
operator|=
name|netmap_ioctl
argument_list|(
name|NULL
argument_list|,
name|cmd
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nmr
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&&
name|copy_to_user
argument_list|(
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
operator|&
name|nmr
argument_list|,
sizeof|sizeof
argument_list|(
name|nmr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
name|EFAULT
return|;
return|return
operator|-
name|ret
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|netmap_release
parameter_list|(
name|struct
name|inode
modifier|*
name|inode
parameter_list|,
name|struct
name|file
modifier|*
name|file
parameter_list|)
block|{
operator|(
name|void
operator|)
name|inode
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
name|file
operator|->
name|private_data
condition|)
name|netmap_dtor
argument_list|(
name|file
operator|->
name|private_data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|linux_netmap_open
parameter_list|(
name|struct
name|inode
modifier|*
name|inode
parameter_list|,
name|struct
name|file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
decl_stmt|;
operator|(
name|void
operator|)
name|inode
expr_stmt|;
comment|/* UNUSED */
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_priv_d
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|file
operator|->
name|private_data
operator|=
name|priv
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|file_operations
name|netmap_fops
init|=
block|{
operator|.
name|open
operator|=
name|linux_netmap_open
block|,
operator|.
name|mmap
operator|=
name|linux_netmap_mmap
block|,
name|LIN_IOCTL_NAME
operator|=
name|linux_netmap_ioctl
block|,
operator|.
name|poll
operator|=
name|linux_netmap_poll
block|,
operator|.
name|release
operator|=
name|netmap_release
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|miscdevice
name|netmap_cdevsw
init|=
block|{
comment|/* same name as FreeBSD */
name|MISC_DYNAMIC_MINOR
block|,
literal|"netmap"
block|,
operator|&
name|netmap_fops
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|netmap_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|netmap_fini
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Errors have negative values on linux */
end_comment

begin_function
specifier|static
name|int
name|linux_netmap_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|-
name|netmap_init
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|module_init
argument_list|(
name|linux_netmap_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|netmap_fini
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* export certain symbols to other modules */
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_attach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// driver attach routines
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_detach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// driver detach routines
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_ring_reinit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// ring init on error
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_buffer_lut
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_total_buffers
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// index check
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_buffer_base
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_reset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// ring init routines
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_buf_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_rx_irq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// default irq handler
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_no_pendintr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// XXX mitigation - should go away
end_comment

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"http://info.iet.unipi.it/~luigi/netmap/"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"The netmap packet I/O framework"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"Dual BSD/GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* the code here is all BSD. */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|netmap_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_name
operator|=
literal|"netmap"
block|,
operator|.
name|d_open
operator|=
name|netmap_open
block|,
operator|.
name|d_mmap
operator|=
name|netmap_mmap
block|,
operator|.
name|d_mmap_single
operator|=
name|netmap_mmap_single
block|,
operator|.
name|d_ioctl
operator|=
name|netmap_ioctl
block|,
operator|.
name|d_poll
operator|=
name|netmap_poll
block|,
operator|.
name|d_close
operator|=
name|netmap_close
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NM_BRIDGE
end_ifdef

begin_comment
comment|/*  *---- support for virtual bridge -----  */
end_comment

begin_comment
comment|/* ----- FreeBSD if_bridge hash function ------- */
end_comment

begin_comment
comment|/*  * The following hash function is adapted from "Hash Functions" by Bob Jenkins  * ("Algorithm Alley", Dr. Dobbs Journal, September 1997).  *  * http://www.burtleburtle.net/bob/hash/spooky.html  */
end_comment

begin_define
define|#
directive|define
name|mix
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|do {                                                                    \         a -= b; a -= c; a ^= (c>> 13);                                 \         b -= c; b -= a; b ^= (a<< 8);                                  \         c -= a; c -= b; c ^= (b>> 13);                                 \         a -= b; a -= c; a ^= (c>> 12);                                 \         b -= c; b -= a; b ^= (a<< 16);                                 \         c -= a; c -= b; c ^= (b>> 5);                                  \         a -= b; a -= c; a ^= (c>> 3);                                  \         b -= c; b -= a; b ^= (a<< 10);                                 \         c -= a; c -= b; c ^= (b>> 15);                                 \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_function
specifier|static
name|__inline
name|uint32_t
name|nm_bridge_rthash
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint32_t
name|a
init|=
literal|0x9e3779b9
decl_stmt|,
name|b
init|=
literal|0x9e3779b9
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
comment|// hask key
name|b
operator|+=
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
name|b
operator|+=
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
define|#
directive|define
name|BRIDGE_RTHASH_MASK
value|(NM_BDG_HASH-1)
return|return
operator|(
name|c
operator|&
name|BRIDGE_RTHASH_MASK
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|mix
end_undef

begin_function
specifier|static
name|int
name|bdg_netmap_reg
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|ifp
operator|->
name|if_bridge
decl_stmt|;
name|BDG_LOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
comment|/* the interface must be already in the list. 		 * only need to mark the port as active 		 */
name|ND
argument_list|(
literal|"should attach %s to the bridge"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BDG_MAXPORTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
operator|==
name|ifp
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|NM_BDG_MAXPORTS
condition|)
block|{
name|D
argument_list|(
literal|"no more ports available"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ND
argument_list|(
literal|"setting %s in netmap mode"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_NETMAP
expr_stmt|;
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|bdg_port
operator|=
name|i
expr_stmt|;
name|b
operator|->
name|act_ports
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
operator|=
name|ifp
expr_stmt|;
block|}
else|else
block|{
comment|/* should be in the list, too -- remove from the mask */
name|ND
argument_list|(
literal|"removing %s from netmap mode"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_NETMAP
expr_stmt|;
name|i
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|bdg_port
expr_stmt|;
name|b
operator|->
name|act_ports
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
name|done
label|:
name|BDG_UNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nm_bdg_flush
parameter_list|(
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ifn
decl_stmt|;
name|uint64_t
name|all_dst
decl_stmt|,
name|dst
decl_stmt|;
name|uint32_t
name|sh
decl_stmt|,
name|dh
decl_stmt|;
name|uint64_t
name|mysrc
init|=
literal|1
operator|<<
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|bdg_port
decl_stmt|;
name|uint64_t
name|smac
decl_stmt|,
name|dmac
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|ifp
operator|->
name|if_bridge
decl_stmt|;
name|ND
argument_list|(
literal|"prepare to send %d packets, act_ports 0x%x"
argument_list|,
name|n
argument_list|,
name|b
operator|->
name|act_ports
argument_list|)
expr_stmt|;
comment|/* only consider valid destinations */
name|all_dst
operator|=
operator|(
name|b
operator|->
name|act_ports
operator|&
operator|~
name|mysrc
operator|)
expr_stmt|;
comment|/* first pass: hash and find destinations */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|likely
argument_list|(
name|i
operator|<
name|n
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
modifier|*
name|buf
init|=
name|ft
index|[
name|i
index|]
operator|.
name|buf
decl_stmt|;
name|dmac
operator|=
name|le64toh
argument_list|(
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|buf
operator|)
argument_list|)
operator|&
literal|0xffffffffffff
expr_stmt|;
name|smac
operator|=
name|le64toh
argument_list|(
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|buf
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
name|smac
operator|>>=
literal|16
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|netmap_verbose
argument_list|)
condition|)
block|{
name|uint8_t
modifier|*
name|s
init|=
name|buf
operator|+
literal|6
decl_stmt|,
modifier|*
name|d
init|=
name|buf
decl_stmt|;
name|D
argument_list|(
literal|"%d len %4d %02x:%02x:%02x:%02x:%02x:%02x -> %02x:%02x:%02x:%02x:%02x:%02x"
argument_list|,
name|i
argument_list|,
name|ft
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|,
name|s
index|[
literal|4
index|]
argument_list|,
name|s
index|[
literal|5
index|]
argument_list|,
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|,
name|d
index|[
literal|2
index|]
argument_list|,
name|d
index|[
literal|3
index|]
argument_list|,
name|d
index|[
literal|4
index|]
argument_list|,
name|d
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * The hash is somewhat expensive, there might be some 		 * worthwhile optimizations here. 		 */
if|if
condition|(
operator|(
name|buf
index|[
literal|6
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* valid src */
name|uint8_t
modifier|*
name|s
init|=
name|buf
operator|+
literal|6
decl_stmt|;
name|sh
operator|=
name|nm_bridge_rthash
argument_list|(
name|buf
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|// XXX hash of source
comment|/* update source port forwarding entry */
name|b
operator|->
name|ht
index|[
name|sh
index|]
operator|.
name|mac
operator|=
name|smac
expr_stmt|;
comment|/* XXX expire ? */
name|b
operator|->
name|ht
index|[
name|sh
index|]
operator|.
name|ports
operator|=
name|mysrc
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"src %02x:%02x:%02x:%02x:%02x:%02x on port %d"
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|,
name|s
index|[
literal|4
index|]
argument_list|,
name|s
index|[
literal|5
index|]
argument_list|,
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|bdg_port
argument_list|)
expr_stmt|;
block|}
name|dst
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* unicast */
name|uint8_t
modifier|*
name|d
init|=
name|buf
decl_stmt|;
name|dh
operator|=
name|nm_bridge_rthash
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// XXX hash of dst
if|if
condition|(
name|b
operator|->
name|ht
index|[
name|dh
index|]
operator|.
name|mac
operator|==
name|dmac
condition|)
block|{
comment|/* found dst */
name|dst
operator|=
name|b
operator|->
name|ht
index|[
name|dh
index|]
operator|.
name|ports
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"dst %02x:%02x:%02x:%02x:%02x:%02x to port %x"
argument_list|,
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|,
name|d
index|[
literal|2
index|]
argument_list|,
name|d
index|[
literal|3
index|]
argument_list|,
name|d
index|[
literal|4
index|]
argument_list|,
name|d
index|[
literal|5
index|]
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|dst
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dst
operator|==
literal|0
condition|)
name|dst
operator|=
name|all_dst
expr_stmt|;
name|dst
operator|&=
name|all_dst
expr_stmt|;
comment|/* only consider valid ports */
if|if
condition|(
name|unlikely
argument_list|(
name|netmap_verbose
argument_list|)
condition|)
name|D
argument_list|(
literal|"pkt goes to ports 0x%x"
argument_list|,
operator|(
name|uint32_t
operator|)
name|dst
argument_list|)
expr_stmt|;
name|ft
index|[
name|i
index|]
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
comment|/* second pass, scan interfaces and forward */
name|all_dst
operator|=
operator|(
name|b
operator|->
name|act_ports
operator|&
operator|~
name|mysrc
operator|)
expr_stmt|;
for|for
control|(
name|ifn
operator|=
literal|0
init|;
name|all_dst
condition|;
name|ifn
operator|++
control|)
block|{
name|struct
name|ifnet
modifier|*
name|dst_ifp
init|=
name|b
operator|->
name|bdg_ports
index|[
name|ifn
index|]
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
decl_stmt|;
name|int
name|j
decl_stmt|,
name|lim
decl_stmt|,
name|sent
decl_stmt|,
name|locked
decl_stmt|;
if|if
condition|(
operator|!
name|dst_ifp
condition|)
continue|continue;
name|ND
argument_list|(
literal|"scan port %d %s"
argument_list|,
name|ifn
argument_list|,
name|dst_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|dst
operator|=
literal|1
operator|<<
name|ifn
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|&
name|all_dst
operator|)
operator|==
literal|0
condition|)
comment|/* skip if not set */
continue|continue;
name|all_dst
operator|&=
operator|~
name|dst
expr_stmt|;
comment|/* clear current node */
name|na
operator|=
name|NA
argument_list|(
name|dst_ifp
argument_list|)
expr_stmt|;
name|ring
operator|=
name|NULL
expr_stmt|;
name|kring
operator|=
name|NULL
expr_stmt|;
name|lim
operator|=
name|sent
operator|=
name|locked
operator|=
literal|0
expr_stmt|;
comment|/* inside, scan slots */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|likely
argument_list|(
name|i
operator|<
name|n
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ft
index|[
name|i
index|]
operator|.
name|dst
operator|&
name|dst
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* not here */
if|if
condition|(
operator|!
name|locked
condition|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
literal|0
index|]
expr_stmt|;
name|ring
operator|=
name|kring
operator|->
name|ring
expr_stmt|;
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|dst_ifp
argument_list|,
name|NETMAP_RX_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|kring
operator|->
name|nr_hwavail
operator|>=
name|lim
argument_list|)
condition|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"rx ring full on %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
break|break;
block|}
name|j
operator|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|lim
condition|)
name|j
operator|-=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
name|j
index|]
expr_stmt|;
name|ND
argument_list|(
literal|"send %d %d bytes at %s:%d"
argument_list|,
name|i
argument_list|,
name|ft
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|dst_ifp
operator|->
name|if_xname
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|pkt_copy
argument_list|(
name|ft
index|[
name|i
index|]
operator|.
name|buf
argument_list|,
name|NMB
argument_list|(
name|slot
argument_list|)
argument_list|,
name|ft
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|slot
operator|->
name|len
operator|=
name|ft
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|++
expr_stmt|;
name|sent
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|locked
condition|)
block|{
name|ND
argument_list|(
literal|"sent %d on %s"
argument_list|,
name|sent
argument_list|,
name|dst_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
condition|)
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|dst_ifp
argument_list|,
name|NETMAP_RX_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * main dispatch routine  */
end_comment

begin_function
specifier|static
name|int
name|bdg_netmap_txsync
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|int
name|do_lock
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|ring_nr
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
init|=
operator|(
expr|struct
name|nm_bdg_fwd
operator|*
operator|)
operator|(
name|ifp
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|ft_i
decl_stmt|;
comment|/* position in the forwarding table */
name|k
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|lim
condition|)
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
if|if
condition|(
name|do_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_TX_LOCK
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_bridge
operator|<=
literal|0
condition|)
block|{
comment|/* testing only */
name|j
operator|=
name|k
expr_stmt|;
comment|// used all
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|netmap_bridge
operator|>
name|NM_BDG_BATCH
condition|)
name|netmap_bridge
operator|=
name|NM_BDG_BATCH
expr_stmt|;
name|ft_i
operator|=
literal|0
expr_stmt|;
comment|/* start from 0 */
for|for
control|(
name|j
operator|=
name|kring
operator|->
name|nr_hwcur
init|;
name|likely
argument_list|(
name|j
operator|!=
name|k
argument_list|)
condition|;
name|j
operator|=
name|unlikely
argument_list|(
name|j
operator|==
name|lim
argument_list|)
condition|?
literal|0
else|:
name|j
operator|+
literal|1
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|j
index|]
decl_stmt|;
name|int
name|len
init|=
name|ft
index|[
name|ft_i
index|]
operator|.
name|len
operator|=
name|slot
operator|->
name|len
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|ft
index|[
name|ft_i
index|]
operator|.
name|buf
operator|=
name|NMB
argument_list|(
name|slot
argument_list|)
decl_stmt|;
name|prefetch
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|len
operator|<
literal|14
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|unlikely
argument_list|(
operator|++
name|ft_i
operator|==
name|netmap_bridge
argument_list|)
condition|)
name|ft_i
operator|=
name|nm_bdg_flush
argument_list|(
name|ft
argument_list|,
name|ft_i
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ft_i
condition|)
name|ft_i
operator|=
name|nm_bdg_flush
argument_list|(
name|ft
argument_list|,
name|ft_i
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* count how many packets we sent */
name|i
operator|=
name|k
operator|-
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|k
condition|)
name|D
argument_list|(
literal|"early break at %d/ %d, avail %d"
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
name|done
label|:
name|kring
operator|->
name|nr_hwcur
operator|=
name|j
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
if|if
condition|(
name|do_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_TX_UNLOCK
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s ring %d lock %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|ring_nr
argument_list|,
name|do_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bdg_netmap_rxsync
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|int
name|do_lock
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|ring_nr
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|j
decl_stmt|,
name|n
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
name|k
init|=
name|ring
operator|->
name|cur
decl_stmt|,
name|resvd
init|=
name|ring
operator|->
name|reserved
decl_stmt|;
name|ND
argument_list|(
literal|"%s ring %d lock %d avail %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|ring_nr
argument_list|,
name|do_lock
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|lim
condition|)
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
if|if
condition|(
name|do_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_RX_LOCK
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
comment|/* skip past packets that userspace has released */
name|j
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
comment|/* netmap ring index */
if|if
condition|(
name|resvd
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|resvd
operator|+
name|ring
operator|->
name|avail
operator|>=
name|lim
operator|+
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"XXX invalid reserve/avail %d %d"
argument_list|,
name|resvd
argument_list|,
name|ring
operator|->
name|avail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|reserved
operator|=
name|resvd
operator|=
literal|0
expr_stmt|;
comment|// XXX panic...
block|}
name|k
operator|=
operator|(
name|k
operator|>=
name|resvd
operator|)
condition|?
name|k
operator|-
name|resvd
else|:
name|k
operator|+
name|lim
operator|+
literal|1
operator|-
name|resvd
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
name|k
condition|)
block|{
comment|/* userspace has released some packets. */
name|n
operator|=
name|k
operator|-
name|j
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|ND
argument_list|(
literal|"userspace releases %d packets"
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|likely
argument_list|(
name|j
operator|!=
name|k
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|j
index|]
decl_stmt|;
name|void
modifier|*
name|addr
init|=
name|NMB
argument_list|(
name|slot
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|netmap_buffer_base
condition|)
block|{
comment|/* bad buf */
if|if
condition|(
name|do_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_RX_UNLOCK
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
block|}
comment|/* decrease refcount for buffer */
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_BUF_CHANGED
expr_stmt|;
name|j
operator|=
name|unlikely
argument_list|(
name|j
operator|==
name|lim
argument_list|)
condition|?
literal|0
else|:
name|j
operator|+
literal|1
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwavail
operator|-=
name|n
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|k
expr_stmt|;
block|}
comment|/* tell userspace that there are new packets */
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
operator|-
name|resvd
expr_stmt|;
if|if
condition|(
name|do_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_RX_UNLOCK
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bdg_netmap_attach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
name|na
decl_stmt|;
name|ND
argument_list|(
literal|"attaching virtual bridge"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|na
argument_list|,
sizeof|sizeof
argument_list|(
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|na
operator|.
name|ifp
operator|=
name|ifp
expr_stmt|;
name|na
operator|.
name|separate_locks
operator|=
literal|1
expr_stmt|;
name|na
operator|.
name|num_tx_desc
operator|=
name|NM_BRIDGE_RINGSIZE
expr_stmt|;
name|na
operator|.
name|num_rx_desc
operator|=
name|NM_BRIDGE_RINGSIZE
expr_stmt|;
name|na
operator|.
name|nm_txsync
operator|=
name|bdg_netmap_txsync
expr_stmt|;
name|na
operator|.
name|nm_rxsync
operator|=
name|bdg_netmap_rxsync
expr_stmt|;
name|na
operator|.
name|nm_register
operator|=
name|bdg_netmap_reg
expr_stmt|;
name|netmap_attach
argument_list|(
operator|&
name|na
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NM_BRIDGE */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|netmap_dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* /dev/netmap character device. */
end_comment

begin_comment
comment|/*  * Module loader.  *  * Create the /dev/netmap device and initialize all global  * variables.  *  * Return 0 on success, errno on failure.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|netmap_memory_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"netmap: unable to initialize the memory allocator.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"netmap: loaded module\n"
argument_list|)
expr_stmt|;
name|netmap_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|netmap_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0660
argument_list|,
literal|"netmap"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NM_BRIDGE
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BRIDGES
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|nm_bridges
index|[
name|i
index|]
operator|.
name|bdg_lock
argument_list|,
literal|"bdg lock"
argument_list|,
literal|"bdg_lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Module unloader.  *  * Free all the memory, and destroy the ``/dev/netmap`` device.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|destroy_dev
argument_list|(
name|netmap_dev
argument_list|)
expr_stmt|;
name|netmap_memory_fini
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"netmap: unloaded module.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_comment
comment|/*  * Kernel entry point.  *  * Initialize/finalize the module and return.  *  * Return 0 on success, errno on failure.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_loader
parameter_list|(
name|__unused
name|struct
name|module
modifier|*
name|module
parameter_list|,
name|int
name|event
parameter_list|,
name|__unused
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
name|netmap_init
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|netmap_fini
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|netmap
argument_list|,
name|netmap_loader
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

end_unit

