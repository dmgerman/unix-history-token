begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011-2014 Matteo Landi  * Copyright (C) 2011-2016 Luigi Rizzo  * Copyright (C) 2011-2016 Giuseppe Lettieri  * Copyright (C) 2011-2016 Vincenzo Maffione  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  *  * This module supports memory mapped access to network devices,  * see netmap(4).  *  * The module uses a large, memory pool allocated by the kernel  * and accessible as mmapped memory by multiple userspace threads/processes.  * The memory pool contains packet buffers and "netmap rings",  * i.e. user-accessible copies of the interface's queues.  *  * Access to the network card works like this:  * 1. a process/thread issues one or more open() on /dev/netmap, to create  *    select()able file descriptor on which events are reported.  * 2. on each descriptor, the process issues an ioctl() to identify  *    the interface that should report events to the file descriptor.  * 3. on each descriptor, the process issues an mmap() request to  *    map the shared memory region within the process' address space.  *    The list of interesting queues is indicated by a location in  *    the shared memory region.  * 4. using the functions in the netmap(4) userspace API, a process  *    can look up the occupation state of a queue, access memory buffers,  *    and retrieve received packets or enqueue packets to transmit.  * 5. using some ioctl()s the process can synchronize the userspace view  *    of the queue with the actual status in the kernel. This includes both  *    receiving the notification of new packets, and transmitting new  *    packets on the output interface.  * 6. select() or poll() can be used to wait for events on individual  *    transmit or receive queues (or all queues for a given interface).  *  		SYNCHRONIZATION (USER)  The netmap rings and data structures may be shared among multiple user threads or even independent processes. Any synchronization among those threads/processes is delegated to the threads themselves. Only one thread at a time can be in a system call on the same netmap ring. The OS does not enforce this and only guarantees against system crashes in case of invalid usage.  		LOCKING (INTERNAL)  Within the kernel, access to the netmap rings is protected as follows:  - a spinlock on each ring, to handle producer/consumer races on   RX rings attached to the host stack (against multiple host   threads writing from the host stack to the same ring),   and on 'destination' rings attached to a VALE switch   (i.e. RX rings in VALE ports, and TX rings in NIC/host ports)   protecting multiple active senders for the same destination)  - an atomic variable to guarantee that there is at most one   instance of *_*xsync() on the ring at any time.   For rings connected to user file   descriptors, an atomic_test_and_set() protects this, and the   lock on the ring is not actually used.   For NIC RX rings connected to a VALE switch, an atomic_test_and_set()   is also used to prevent multiple executions (the driver might indeed   already guarantee this).   For NIC TX rings connected to a VALE switch, the lock arbitrates   access to the queue (both when allocating buffers and when pushing   them out).  - *xsync() should be protected against initializations of the card.   On FreeBSD most devices have the reset routine protected by   a RING lock (ixgbe, igb, em) or core lock (re). lem is missing   the RING protection on rx_reset(), this should be added.    On linux there is an external lock on the tx path, which probably   also arbitrates access to the reset routine. XXX to be revised  - a per-interface core_lock protecting access from the host stack   while interfaces may be detached from netmap mode.   XXX there should be no need for this lock if we detach the interfaces   only while they are down.   --- VALE SWITCH ---  NMG_LOCK() serializes all modifications to switches and ports. A switch cannot be deleted until all ports are gone.  For each switch, an SX lock (RWlock on linux) protects deletion of ports. When configuring or deleting a new port, the lock is acquired in exclusive mode (after holding NMG_LOCK). When forwarding, the lock is acquired in shared mode (without NMG_LOCK). The lock is held throughout the entire forwarding cycle, during which the thread may incur in a page fault. Hence it is important that sleepable shared locks are used.  On the rx ring, the per-port lock is grabbed initially to reserve a number of slot in the ring, then the lock is released, packets are copied from source to destination, and then the lock is acquired again and the receive ring is updated. (A similar thing is done on the tx ring for NIC and host stack ports attached to the switch)   */
end_comment

begin_comment
comment|/* --- internals ----  *  * Roadmap to the code that implements the above.  *  *> 1. a process/thread issues one or more open() on /dev/netmap, to create  *>    select()able file descriptor on which events are reported.  *  *  	Internally, we allocate a netmap_priv_d structure, that will be  *  	initialized on ioctl(NIOCREGIF). There is one netmap_priv_d  *  	structure for each open().  *  *      os-specific:  *  	    FreeBSD: see netmap_open() (netmap_freebsd.c)  *  	    linux:   see linux_netmap_open() (netmap_linux.c)  *  *> 2. on each descriptor, the process issues an ioctl() to identify  *>    the interface that should report events to the file descriptor.  *  * 	Implemented by netmap_ioctl(), NIOCREGIF case, with nmr->nr_cmd==0.  * 	Most important things happen in netmap_get_na() and  * 	netmap_do_regif(), called from there. Additional details can be  * 	found in the comments above those functions.  *  * 	In all cases, this action creates/takes-a-reference-to a  * 	netmap_*_adapter describing the port, and allocates a netmap_if  * 	and all necessary netmap rings, filling them with netmap buffers.  *  *      In this phase, the sync callbacks for each ring are set (these are used  *      in steps 5 and 6 below).  The callbacks depend on the type of adapter.  *      The adapter creation/initialization code puts them in the  * 	netmap_adapter (fields na->nm_txsync and na->nm_rxsync).  Then, they  * 	are copied from there to the netmap_kring's during netmap_do_regif(), by  * 	the nm_krings_create() callback.  All the nm_krings_create callbacks  * 	actually call netmap_krings_create() to perform this and the other  * 	common stuff. netmap_krings_create() also takes care of the host rings,  * 	if needed, by setting their sync callbacks appropriately.  *  * 	Additional actions depend on the kind of netmap_adapter that has been  * 	registered:  *  * 	- netmap_hw_adapter:  	     [netmap.c]  * 	     This is a system netdev/ifp with native netmap support.  * 	     The ifp is detached from the host stack by redirecting:  * 	       - transmissions (from the network stack) to netmap_transmit()  * 	       - receive notifications to the nm_notify() callback for  * 	         this adapter. The callback is normally netmap_notify(), unless  * 	         the ifp is attached to a bridge using bwrap, in which case it  * 	         is netmap_bwrap_intr_notify().  *  * 	- netmap_generic_adapter:      [netmap_generic.c]  * 	      A system netdev/ifp without native netmap support.  *  * 	(the decision about native/non native support is taken in  * 	 netmap_get_hw_na(), called by netmap_get_na())  *  * 	- netmap_vp_adapter 		[netmap_vale.c]  * 	      Returned by netmap_get_bdg_na().  * 	      This is a persistent or ephemeral VALE port. Ephemeral ports  * 	      are created on the fly if they don't already exist, and are  * 	      always attached to a bridge.  * 	      Persistent VALE ports must must be created separately, and i  * 	      then attached like normal NICs. The NIOCREGIF we are examining  * 	      will find them only if they had previosly been created and  * 	      attached (see VALE_CTL below).  *  * 	- netmap_pipe_adapter 	      [netmap_pipe.c]  * 	      Returned by netmap_get_pipe_na().  * 	      Both pipe ends are created, if they didn't already exist.  *  * 	- netmap_monitor_adapter      [netmap_monitor.c]  * 	      Returned by netmap_get_monitor_na().  * 	      If successful, the nm_sync callbacks of the monitored adapter  * 	      will be intercepted by the returned monitor.  *  * 	- netmap_bwrap_adapter	      [netmap_vale.c]  * 	      Cannot be obtained in this way, see VALE_CTL below  *  *  * 	os-specific:  * 	    linux: we first go through linux_netmap_ioctl() to  * 	           adapt the FreeBSD interface to the linux one.  *  *  *> 3. on each descriptor, the process issues an mmap() request to  *>    map the shared memory region within the process' address space.  *>    The list of interesting queues is indicated by a location in  *>    the shared memory region.  *  *      os-specific:  *  	    FreeBSD: netmap_mmap_single (netmap_freebsd.c).  *  	    linux:   linux_netmap_mmap (netmap_linux.c).  *  *> 4. using the functions in the netmap(4) userspace API, a process  *>    can look up the occupation state of a queue, access memory buffers,  *>    and retrieve received packets or enqueue packets to transmit.  *  * 	these actions do not involve the kernel.  *  *> 5. using some ioctl()s the process can synchronize the userspace view  *>    of the queue with the actual status in the kernel. This includes both  *>    receiving the notification of new packets, and transmitting new  *>    packets on the output interface.  *  * 	These are implemented in netmap_ioctl(), NIOCTXSYNC and NIOCRXSYNC  * 	cases. They invoke the nm_sync callbacks on the netmap_kring  * 	structures, as initialized in step 2 and maybe later modified  * 	by a monitor. Monitors, however, will always call the original  * 	callback before doing anything else.  *  *  *> 6. select() or poll() can be used to wait for events on individual  *>    transmit or receive queues (or all queues for a given interface).  *  * 	Implemented in netmap_poll(). This will call the same nm_sync()  * 	callbacks as in step 5 above.  *  * 	os-specific:  * 		linux: we first go through linux_netmap_poll() to adapt  * 		       the FreeBSD interface to the linux one.  *  *  *  ----  VALE_CTL -----  *  *  VALE switches are controlled by issuing a NIOCREGIF with a non-null  *  nr_cmd in the nmreq structure. These subcommands are handled by  *  netmap_bdg_ctl() in netmap_vale.c. Persistent VALE ports are created  *  and destroyed by issuing the NETMAP_BDG_NEWIF and NETMAP_BDG_DELIF  *  subcommands, respectively.  *  *  Any network interface known to the system (including a persistent VALE  *  port) can be attached to a VALE switch by issuing the  *  NETMAP_BDG_ATTACH subcommand. After the attachment, persistent VALE ports  *  look exactly like ephemeral VALE ports (as created in step 2 above).  The  *  attachment of other interfaces, instead, requires the creation of a  *  netmap_bwrap_adapter.  Moreover, the attached interface must be put in  *  netmap mode. This may require the creation of a netmap_generic_adapter if  *  we have no native support for the interface, or if generic adapters have  *  been forced by sysctl.  *  *  Both persistent VALE ports and bwraps are handled by netmap_get_bdg_na(),  *  called by nm_bdg_ctl_attach(), and discriminated by the nm_bdg_attach()  *  callback.  In the case of the bwrap, the callback creates the  *  netmap_bwrap_adapter.  The initialization of the bwrap is then  *  completed by calling netmap_do_regif() on it, in the nm_bdg_ctl()  *  callback (netmap_bwrap_bdg_ctl in netmap_vale.c).  *  A generic adapter for the wrapped ifp will be created if needed, when  *  netmap_get_bdg_na() calls netmap_get_hw_na().  *  *  *  ---- DATAPATHS -----  *  *              -= SYSTEM DEVICE WITH NATIVE SUPPORT =-  *  *    na == NA(ifp) == netmap_hw_adapter created in DEVICE_netmap_attach()  *  *    - tx from netmap userspace:  *	 concurrently:  *           1) ioctl(NIOCTXSYNC)/netmap_poll() in process context  *                kring->nm_sync() == DEVICE_netmap_txsync()  *           2) device interrupt handler  *                na->nm_notify()  == netmap_notify()  *    - rx from netmap userspace:  *       concurrently:  *           1) ioctl(NIOCRXSYNC)/netmap_poll() in process context  *                kring->nm_sync() == DEVICE_netmap_rxsync()  *           2) device interrupt handler  *                na->nm_notify()  == netmap_notify()  *    - rx from host stack  *       concurrently:  *           1) host stack  *                netmap_transmit()  *                  na->nm_notify  == netmap_notify()  *           2) ioctl(NIOCRXSYNC)/netmap_poll() in process context  *                kring->nm_sync() == netmap_rxsync_from_host  *                  netmap_rxsync_from_host(na, NULL, NULL)  *    - tx to host stack  *           ioctl(NIOCTXSYNC)/netmap_poll() in process context  *             kring->nm_sync() == netmap_txsync_to_host  *               netmap_txsync_to_host(na)  *                 nm_os_send_up()  *                   FreeBSD: na->if_input() == ether_input()  *                   linux: netif_rx() with NM_MAGIC_PRIORITY_RX  *  *  *               -= SYSTEM DEVICE WITH GENERIC SUPPORT =-  *  *    na == NA(ifp) == generic_netmap_adapter created in generic_netmap_attach()  *  *    - tx from netmap userspace:  *       concurrently:  *           1) ioctl(NIOCTXSYNC)/netmap_poll() in process context  *               kring->nm_sync() == generic_netmap_txsync()  *                   nm_os_generic_xmit_frame()  *                       linux:   dev_queue_xmit() with NM_MAGIC_PRIORITY_TX  *                           ifp->ndo_start_xmit == generic_ndo_start_xmit()  *                               gna->save_start_xmit == orig. dev. start_xmit  *                       FreeBSD: na->if_transmit() == orig. dev if_transmit  *           2) generic_mbuf_destructor()  *                   na->nm_notify() == netmap_notify()  *    - rx from netmap userspace:  *           1) ioctl(NIOCRXSYNC)/netmap_poll() in process context  *               kring->nm_sync() == generic_netmap_rxsync()  *                   mbq_safe_dequeue()  *           2) device driver  *               generic_rx_handler()  *                   mbq_safe_enqueue()  *                   na->nm_notify() == netmap_notify()  *    - rx from host stack  *        FreeBSD: same as native  *        Linux: same as native except:  *           1) host stack  *               dev_queue_xmit() without NM_MAGIC_PRIORITY_TX  *                   ifp->ndo_start_xmit == generic_ndo_start_xmit()  *                       netmap_transmit()  *                           na->nm_notify() == netmap_notify()  *    - tx to host stack (same as native):  *  *  *                           -= VALE =-  *  *   INCOMING:  *  *      - VALE ports:  *          ioctl(NIOCTXSYNC)/netmap_poll() in process context  *              kring->nm_sync() == netmap_vp_txsync()  *  *      - system device with native support:  *         from cable:  *             interrupt  *                na->nm_notify() == netmap_bwrap_intr_notify(ring_nr != host ring)  *                     kring->nm_sync() == DEVICE_netmap_rxsync()  *                     netmap_vp_txsync()  *                     kring->nm_sync() == DEVICE_netmap_rxsync()  *         from host stack:  *             netmap_transmit()  *                na->nm_notify() == netmap_bwrap_intr_notify(ring_nr == host ring)  *                     kring->nm_sync() == netmap_rxsync_from_host()  *                     netmap_vp_txsync()  *  *      - system device with generic support:  *         from device driver:  *            generic_rx_handler()  *                na->nm_notify() == netmap_bwrap_intr_notify(ring_nr != host ring)  *                     kring->nm_sync() == generic_netmap_rxsync()  *                     netmap_vp_txsync()  *                     kring->nm_sync() == generic_netmap_rxsync()  *         from host stack:  *            netmap_transmit()  *                na->nm_notify() == netmap_bwrap_intr_notify(ring_nr == host ring)  *                     kring->nm_sync() == netmap_rxsync_from_host()  *                     netmap_vp_txsync()  *  *   (all cases) --> nm_bdg_flush()  *                      dest_na->nm_notify() == (see below)  *  *   OUTGOING:  *  *      - VALE ports:  *         concurrently:  *             1) ioctlNIOCRXSYNC)/netmap_poll() in process context  *                    kring->nm_sync() == netmap_vp_rxsync()  *             2) from nm_bdg_flush()  *                    na->nm_notify() == netmap_notify()  *  *      - system device with native support:  *          to cable:  *             na->nm_notify() == netmap_bwrap_notify()  *                 netmap_vp_rxsync()  *                 kring->nm_sync() == DEVICE_netmap_txsync()  *                 netmap_vp_rxsync()  *          to host stack:  *                 netmap_vp_rxsync()  *                 kring->nm_sync() == netmap_txsync_to_host  *                 netmap_vp_rxsync_locked()  *  *      - system device with generic adapter:  *          to device driver:  *             na->nm_notify() == netmap_bwrap_notify()  *                 netmap_vp_rxsync()  *                 kring->nm_sync() == generic_netmap_txsync()  *                 netmap_vp_rxsync()  *          to host stack:  *                 netmap_vp_rxsync()  *                 kring->nm_sync() == netmap_txsync_to_host  *                 netmap_vp_rxsync()  *  */
end_comment

begin_comment
comment|/*  * OS-specific code that is used only within this file.  * Other OS-specific code that must be accessed by drivers  * is present in netmap_kern.h  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* defines used in kernel.h */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* types used in module initialization */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_comment
comment|/* cdevsw struct, UID, GID */
end_comment

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_comment
comment|/* FIONBIO */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_comment
comment|/* struct socket */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/* BIOCIMMEDIATE */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* */
end_comment

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|linux
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"bsd_glue.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_elif

begin_warning
warning|#
directive|warning
warning|OSX support is only partial
end_warning

begin_include
include|#
directive|include
file|"osx_glue.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"win_glue.h"
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|Unsupported platform
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unsupported */
end_comment

begin_comment
comment|/*  * common headers  */
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_mem2.h>
end_include

begin_comment
comment|/* user-controlled variables */
end_comment

begin_decl_stmt
name|int
name|netmap_verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|netmap_no_timestamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't timestamp on rxsync */
end_comment

begin_decl_stmt
name|int
name|netmap_mitigate
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|netmap_no_pendintr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|netmap_txsync_retry
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|netmap_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flags */
end_comment

begin_decl_stmt
specifier|static
name|int
name|netmap_fwd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* force transparent mode */
end_comment

begin_comment
comment|/*  * netmap_admode selects the netmap mode to use.  * Invalid values are reset to NETMAP_ADMODE_BEST  */
end_comment

begin_enum
enum|enum
block|{
name|NETMAP_ADMODE_BEST
init|=
literal|0
block|,
comment|/* use native, fallback to generic */
name|NETMAP_ADMODE_NATIVE
block|,
comment|/* either native or none */
name|NETMAP_ADMODE_GENERIC
block|,
comment|/* force generic */
name|NETMAP_ADMODE_LAST
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|netmap_admode
init|=
name|NETMAP_ADMODE_BEST
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* netmap_generic_mit controls mitigation of RX notifications for  * the generic netmap adapter. The value is a time interval in  * nanoseconds. */
end_comment

begin_decl_stmt
name|int
name|netmap_generic_mit
init|=
literal|100
operator|*
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We use by default netmap-aware qdiscs with generic netmap adapters,  * even if there can be a little performance hit with hardware NICs.  * However, using the qdisc is the safer approach, for two reasons:  * 1) it prevents non-fifo qdiscs to break the TX notification  *    scheme, which is based on mbuf destructors when txqdisc is  *    not used.  * 2) it makes it possible to transmit over software devices that  *    change skb->dev, like bridge, veth, ...  *  * Anyway users looking for the best performance should  * use native adapters.  */
end_comment

begin_decl_stmt
name|int
name|netmap_generic_txqdisc
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default number of slots and queues for generic adapters. */
end_comment

begin_decl_stmt
name|int
name|netmap_generic_ringsize
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|netmap_generic_rings
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if ptnet devices are allowed to use virtio-net headers. */
end_comment

begin_decl_stmt
name|int
name|ptnet_vnet_hdr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * SYSCTL calls are grouped between SYSBEGIN and SYSEND to be emulated  * in some other operating systems  */
end_comment

begin_expr_stmt
name|SYSBEGIN
argument_list|(
name|main_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_dev_netmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_dev
argument_list|,
name|OID_AUTO
argument_list|,
name|netmap
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Netmap args"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_verbose
argument_list|,
literal|0
argument_list|,
literal|"Verbose mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_timestamp
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_no_timestamp
argument_list|,
literal|0
argument_list|,
literal|"no_timestamp"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|mitigate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_mitigate
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_pendintr
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_no_pendintr
argument_list|,
literal|0
argument_list|,
literal|"Always look for new received packets."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|txsync_retry
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_txsync_retry
argument_list|,
literal|0
argument_list|,
literal|"Number of txsync loops in bridge's flush."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|flags
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_flags
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|fwd
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_fwd
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|admode
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_admode
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|generic_mit
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_generic_mit
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|generic_ringsize
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_generic_ringsize
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|generic_rings
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_generic_rings
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|generic_txqdisc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_generic_txqdisc
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|ptnet_vnet_hdr
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ptnet_vnet_hdr
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSEND
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|NMG_LOCK_T
name|netmap_global_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * mark the ring as stopped, and run through the locks  * to make sure other users get to see it.  * stopped must be either NR_KR_STOPPED (for unbounded stop)  * of NR_KR_LOCKED (brief stop for mutual exclusion purposes)  */
end_comment

begin_function
specifier|static
name|void
name|netmap_disable_ring
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kr
parameter_list|,
name|int
name|stopped
parameter_list|)
block|{
name|nm_kr_stop
argument_list|(
name|kr
argument_list|,
name|stopped
argument_list|)
expr_stmt|;
comment|// XXX check if nm_kr_stop is sufficient
name|mtx_lock
argument_list|(
operator|&
name|kr
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|kr
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|nm_kr_put
argument_list|(
name|kr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* stop or enable a single ring */
end_comment

begin_function
name|void
name|netmap_set_ring
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_id
parameter_list|,
name|enum
name|txrx
name|t
parameter_list|,
name|int
name|stopped
parameter_list|)
block|{
if|if
condition|(
name|stopped
condition|)
name|netmap_disable_ring
argument_list|(
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
operator|+
name|ring_id
argument_list|,
name|stopped
argument_list|)
expr_stmt|;
else|else
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|ring_id
index|]
operator|.
name|nkr_stopped
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* stop or enable all the rings of na */
end_comment

begin_function
name|void
name|netmap_set_all_rings
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|stopped
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|nm_netmap_on
argument_list|(
name|na
argument_list|)
condition|)
return|return;
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|netmap_real_rings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|netmap_set_ring
argument_list|(
name|na
argument_list|,
name|i
argument_list|,
name|t
argument_list|,
name|stopped
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Convenience function used in drivers.  Waits for current txsync()s/rxsync()s  * to finish and prevents any new one from starting.  Call this before turning  * netmap mode off, or before removing the hardware rings (e.g., on module  * onload).  */
end_comment

begin_function
name|void
name|netmap_disable_all_rings
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
if|if
condition|(
name|NM_NA_VALID
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|netmap_set_all_rings
argument_list|(
name|NA
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|NM_KR_STOPPED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convenience function used in drivers.  Re-enables rxsync and txsync on the  * adapter's rings In linux drivers, this should be placed near each  * napi_enable().  */
end_comment

begin_function
name|void
name|netmap_enable_all_rings
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
if|if
condition|(
name|NM_NA_VALID
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|netmap_set_all_rings
argument_list|(
name|NA
argument_list|(
name|ifp
argument_list|)
argument_list|,
literal|0
comment|/* enabled */
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|netmap_make_zombie
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
if|if
condition|(
name|NM_NA_VALID
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|netmap_set_all_rings
argument_list|(
name|na
argument_list|,
name|NM_KR_LOCKED
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_flags
operator||=
name|NAF_ZOMBIE
expr_stmt|;
name|netmap_set_all_rings
argument_list|(
name|na
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|netmap_undo_zombie
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
if|if
condition|(
name|NM_NA_VALID
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_ZOMBIE
condition|)
block|{
name|netmap_set_all_rings
argument_list|(
name|na
argument_list|,
name|NM_KR_LOCKED
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_flags
operator|&=
operator|~
name|NAF_ZOMBIE
expr_stmt|;
name|netmap_set_all_rings
argument_list|(
name|na
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * generic bound_checking function  */
end_comment

begin_function
name|u_int
name|nm_bound_var
parameter_list|(
name|u_int
modifier|*
name|v
parameter_list|,
name|u_int
name|dflt
parameter_list|,
name|u_int
name|lo
parameter_list|,
name|u_int
name|hi
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|u_int
name|oldv
init|=
operator|*
name|v
decl_stmt|;
specifier|const
name|char
modifier|*
name|op
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dflt
operator|<
name|lo
condition|)
name|dflt
operator|=
name|lo
expr_stmt|;
if|if
condition|(
name|dflt
operator|>
name|hi
condition|)
name|dflt
operator|=
name|hi
expr_stmt|;
if|if
condition|(
name|oldv
operator|<
name|lo
condition|)
block|{
operator|*
name|v
operator|=
name|dflt
expr_stmt|;
name|op
operator|=
literal|"Bump"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldv
operator|>
name|hi
condition|)
block|{
operator|*
name|v
operator|=
name|hi
expr_stmt|;
name|op
operator|=
literal|"Clamp"
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&&
name|msg
condition|)
name|printf
argument_list|(
literal|"%s %s to %d (was %d)\n"
argument_list|,
name|op
argument_list|,
name|msg
argument_list|,
operator|*
name|v
argument_list|,
name|oldv
argument_list|)
expr_stmt|;
return|return
operator|*
name|v
return|;
block|}
end_function

begin_comment
comment|/*  * packet-dump function, user-supplied or static buffer.  * The destination buffer must be at least 30+4*len  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|nm_dump_buf
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|lim
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|)
block|{
specifier|static
name|char
name|_dst
index|[
literal|8192
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|i0
decl_stmt|;
specifier|static
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|char
modifier|*
name|o
decl_stmt|;
comment|/* output position */
define|#
directive|define
name|P_HI
parameter_list|(
name|x
parameter_list|)
value|hex[((x)& 0xf0)>>4]
define|#
directive|define
name|P_LO
parameter_list|(
name|x
parameter_list|)
value|hex[((x)& 0xf)]
define|#
directive|define
name|P_C
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0x20&& (x)<= 0x7e ? (x) : '.')
if|if
condition|(
operator|!
name|dst
condition|)
name|dst
operator|=
name|_dst
expr_stmt|;
if|if
condition|(
name|lim
operator|<=
literal|0
operator|||
name|lim
operator|>
name|len
condition|)
name|lim
operator|=
name|len
expr_stmt|;
name|o
operator|=
name|dst
expr_stmt|;
name|sprintf
argument_list|(
name|o
argument_list|,
literal|"buf 0x%p len %d lim %d\n"
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|o
operator|+=
name|strlen
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* hexdump routine */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
control|)
block|{
name|sprintf
argument_list|(
name|o
argument_list|,
literal|"%5d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|o
operator|+=
name|strlen
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|o
argument_list|,
literal|' '
argument_list|,
literal|48
argument_list|)
expr_stmt|;
name|i0
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|<
name|lim
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|o
index|[
name|j
operator|*
literal|3
index|]
operator|=
name|P_HI
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|o
index|[
name|j
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|P_LO
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|i0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|<
name|lim
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|o
index|[
name|j
operator|+
literal|48
index|]
operator|=
name|P_C
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|o
index|[
name|j
operator|+
literal|48
index|]
operator|=
literal|'\n'
expr_stmt|;
name|o
operator|+=
name|j
operator|+
literal|49
expr_stmt|;
block|}
operator|*
name|o
operator|=
literal|'\0'
expr_stmt|;
undef|#
directive|undef
name|P_HI
undef|#
directive|undef
name|P_LO
undef|#
directive|undef
name|P_C
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch configuration from the device, to cope with dynamic  * reconfigurations after loading the module.  */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
name|int
name|netmap_update_config
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|u_int
name|txr
decl_stmt|,
name|txd
decl_stmt|,
name|rxr
decl_stmt|,
name|rxd
decl_stmt|;
name|txr
operator|=
name|txd
operator|=
name|rxr
operator|=
name|rxd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_config
operator|==
name|NULL
operator|||
name|na
operator|->
name|nm_config
argument_list|(
name|na
argument_list|,
operator|&
name|txr
argument_list|,
operator|&
name|txd
argument_list|,
operator|&
name|rxr
argument_list|,
operator|&
name|rxd
argument_list|)
condition|)
block|{
comment|/* take whatever we had at init time */
name|txr
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|txd
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|rxr
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|rxd
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|==
name|txr
operator|&&
name|na
operator|->
name|num_tx_desc
operator|==
name|txd
operator|&&
name|na
operator|->
name|num_rx_rings
operator|==
name|rxr
operator|&&
name|na
operator|->
name|num_rx_desc
operator|==
name|rxd
condition|)
return|return
literal|0
return|;
comment|/* nothing changed */
if|if
condition|(
name|netmap_verbose
operator|||
name|na
operator|->
name|active_fds
operator|>
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"stored config %s: txring %d x %d, rxring %d x %d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|na
operator|->
name|num_tx_rings
argument_list|,
name|na
operator|->
name|num_tx_desc
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|,
name|na
operator|->
name|num_rx_desc
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"new config %s: txring %d x %d, rxring %d x %d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|txr
argument_list|,
name|txd
argument_list|,
name|rxr
argument_list|,
name|rxd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"configuration changed (but fine)"
argument_list|)
expr_stmt|;
name|na
operator|->
name|num_tx_rings
operator|=
name|txr
expr_stmt|;
name|na
operator|->
name|num_tx_desc
operator|=
name|txd
expr_stmt|;
name|na
operator|->
name|num_rx_rings
operator|=
name|rxr
expr_stmt|;
name|na
operator|->
name|num_rx_desc
operator|=
name|rxd
expr_stmt|;
return|return
literal|0
return|;
block|}
name|D
argument_list|(
literal|"configuration changed while active, this is bad..."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* nm_sync callbacks for the host rings */
end_comment

begin_function_decl
specifier|static
name|int
name|netmap_txsync_to_host
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|netmap_rxsync_from_host
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* create the krings array and initialize the fields common to all adapters.  * The array layout is this:  *  *                    +----------+  * na->tx_rings ----->|          | \  *                    |          |  } na->num_tx_ring  *                    |          | /  *                    +----------+  *                    |          |    host tx kring  * na->rx_rings ----> +----------+  *                    |          | \  *                    |          |  } na->num_rx_rings  *                    |          | /  *                    +----------+  *                    |          |    host rx kring  *                    +----------+  * na->tailroom ----->|          | \  *                    |          |  } tailroom bytes  *                    |          | /  *                    +----------+  *  * Note: for compatibility, host krings are created even when not needed.  * The tailroom space is currently used by vale ports for allocating leases.  */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
name|int
name|netmap_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|tailroom
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|ndesc
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|u_int
name|n
index|[
name|NR_TXRX
index|]
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
comment|/* account for the (possibly fake) host rings */
name|n
index|[
name|NR_TX
index|]
operator|=
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
expr_stmt|;
name|n
index|[
name|NR_RX
index|]
operator|=
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
expr_stmt|;
name|len
operator|=
operator|(
name|n
index|[
name|NR_TX
index|]
operator|+
name|n
index|[
name|NR_RX
index|]
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_kring
argument_list|)
operator|+
name|tailroom
expr_stmt|;
name|na
operator|->
name|tx_rings
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|tx_rings
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"Cannot allocate krings"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|na
operator|->
name|rx_rings
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|n
index|[
name|NR_TX
index|]
expr_stmt|;
comment|/* 	 * All fields in krings are 0 except the one initialized below. 	 * but better be explicit on important kring fields. 	 */
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
name|ndesc
operator|=
name|nma_get_ndesc
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
index|[
name|t
index|]
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
name|bzero
argument_list|(
name|kring
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kring
argument_list|)
argument_list|)
expr_stmt|;
name|kring
operator|->
name|na
operator|=
name|na
expr_stmt|;
name|kring
operator|->
name|ring_id
operator|=
name|i
expr_stmt|;
name|kring
operator|->
name|tx
operator|=
name|t
expr_stmt|;
name|kring
operator|->
name|nkr_num_slots
operator|=
name|ndesc
expr_stmt|;
name|kring
operator|->
name|nr_mode
operator|=
name|NKR_NETMAP_OFF
expr_stmt|;
name|kring
operator|->
name|nr_pending_mode
operator|=
name|NKR_NETMAP_OFF
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|kring
operator|->
name|nm_sync
operator|=
operator|(
name|t
operator|==
name|NR_TX
condition|?
name|na
operator|->
name|nm_txsync
else|:
name|na
operator|->
name|nm_rxsync
operator|)
expr_stmt|;
block|}
else|else
block|{
name|kring
operator|->
name|nm_sync
operator|=
operator|(
name|t
operator|==
name|NR_TX
condition|?
name|netmap_txsync_to_host
else|:
name|netmap_rxsync_from_host
operator|)
expr_stmt|;
block|}
name|kring
operator|->
name|nm_notify
operator|=
name|na
operator|->
name|nm_notify
expr_stmt|;
name|kring
operator|->
name|rhead
operator|=
name|kring
operator|->
name|rcur
operator|=
name|kring
operator|->
name|nr_hwcur
operator|=
literal|0
expr_stmt|;
comment|/* 			 * IMPORTANT: Always keep one slot empty. 			 */
name|kring
operator|->
name|rtail
operator|=
name|kring
operator|->
name|nr_hwtail
operator|=
operator|(
name|t
operator|==
name|NR_TX
condition|?
name|ndesc
operator|-
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|snprintf
argument_list|(
name|kring
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|kring
operator|->
name|name
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%s %s%d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|nm_txrx2str
argument_list|(
name|t
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"ktx %s h %d c %d t %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|rhead
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|,
operator|(
name|t
operator|==
name|NR_TX
condition|?
literal|"nm_txq_lock"
else|:
literal|"nm_rxq_lock"
operator|)
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|nm_os_selinfo_init
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
block|}
name|nm_os_selinfo_init
argument_list|(
operator|&
name|na
operator|->
name|si
index|[
name|t
index|]
argument_list|)
expr_stmt|;
block|}
name|na
operator|->
name|tailroom
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|n
index|[
name|NR_RX
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* undo the actions performed by netmap_krings_create */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
name|void
name|netmap_krings_delete
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
name|na
operator|->
name|tx_rings
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
name|nm_os_selinfo_uninit
argument_list|(
operator|&
name|na
operator|->
name|si
index|[
name|t
index|]
argument_list|)
expr_stmt|;
comment|/* we rely on the krings layout described above */
for|for
control|(
init|;
name|kring
operator|!=
name|na
operator|->
name|tailroom
condition|;
name|kring
operator|++
control|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|nm_os_selinfo_uninit
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|na
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|na
operator|->
name|tx_rings
operator|=
name|na
operator|->
name|rx_rings
operator|=
name|na
operator|->
name|tailroom
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Destructor for NIC ports. They also have an mbuf queue  * on the rings connected to the host so we need to purge  * them first.  */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
name|void
name|netmap_hw_krings_delete
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|mbq
modifier|*
name|q
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
operator|.
name|rx_queue
decl_stmt|;
name|ND
argument_list|(
literal|"destroy sw mbq with len %d"
argument_list|,
name|mbq_len
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|mbq_purge
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|mbq_safe_fini
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|netmap_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Undo everything that was done in netmap_do_regif(). In particular,  * call nm_register(ifp,0) to stop netmap mode on the interface and  * revert to normal operation.  */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function_decl
specifier|static
name|void
name|netmap_unset_ringid
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|netmap_krings_put
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|netmap_do_unregif
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|na
operator|->
name|active_fds
operator|--
expr_stmt|;
comment|/* unset nr_pending_mode and possibly release exclusive mode */
name|netmap_krings_put
argument_list|(
name|priv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WITH_MONITOR
comment|/* XXX check whether we have to do something with monitor 	 * when rings change nr_mode. */
if|if
condition|(
name|na
operator|->
name|active_fds
operator|<=
literal|0
condition|)
block|{
comment|/* walk through all the rings and tell any monitor 		 * that the port is going to exit netmap mode 		 */
name|netmap_monitor_stop
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|na
operator|->
name|active_fds
operator|<=
literal|0
operator|||
name|nm_kring_pending
argument_list|(
name|priv
argument_list|)
condition|)
block|{
name|na
operator|->
name|nm_register
argument_list|(
name|na
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* delete rings and buffers that are no longer needed */
name|netmap_mem_rings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|active_fds
operator|<=
literal|0
condition|)
block|{
comment|/* last instance */
comment|/* 		 * (TO CHECK) We enter here 		 * when the last reference to this file descriptor goes 		 * away. This means we cannot have any pending poll() 		 * or interrupt routine operating on the structure. 		 * XXX The file may be closed in a thread while 		 * another thread is using it. 		 * Linux keeps the file opened until the last reference 		 * by any outstanding ioctl/poll or mmap is gone. 		 * FreeBSD does not track mmap()s (but we do) and 		 * wakes up any sleeping poll(). Need to check what 		 * happens if the close() occurs while a concurrent 		 * syscall is running. 		 */
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"deleting last instance for %s"
argument_list|,
name|na
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_netmap_on
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"BUG: netmap on while going to delete the krings"
argument_list|)
expr_stmt|;
block|}
name|na
operator|->
name|nm_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
comment|/* possibily decrement counter of tx_si/rx_si users */
name|netmap_unset_ringid
argument_list|(
name|priv
argument_list|)
expr_stmt|;
comment|/* delete the nifp */
name|netmap_mem_if_delete
argument_list|(
name|na
argument_list|,
name|priv
operator|->
name|np_nifp
argument_list|)
expr_stmt|;
comment|/* drop the allocator */
name|netmap_mem_deref
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
name|na
argument_list|)
expr_stmt|;
comment|/* mark the priv as unregistered */
name|priv
operator|->
name|np_na
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|np_nifp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|nm_si_user
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|enum
name|txrx
name|t
parameter_list|)
block|{
return|return
operator|(
name|priv
operator|->
name|np_na
operator|!=
name|NULL
operator|&&
operator|(
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
operator|-
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
operator|>
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|netmap_priv_d
modifier|*
name|netmap_priv_new
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
decl_stmt|;
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_priv_d
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|priv
operator|->
name|np_refs
operator|=
literal|1
expr_stmt|;
name|nm_os_get_module
argument_list|()
expr_stmt|;
return|return
name|priv
return|;
block|}
end_function

begin_comment
comment|/*  * Destructor of the netmap_priv_d, called when the fd is closed  * Action: undo all the things done by NIOCREGIF,  * On FreeBSD we need to track whether there are active mmap()s,  * and we use np_active_mmaps for that. On linux, the field is always 0.  * Return: 1 if we can free priv, 0 otherwise.  *  */
end_comment

begin_comment
comment|/* call with NMG_LOCK held */
end_comment

begin_function
name|void
name|netmap_priv_delete
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
comment|/* number of active references to this fd */
if|if
condition|(
operator|--
name|priv
operator|->
name|np_refs
operator|>
literal|0
condition|)
block|{
return|return;
block|}
name|nm_os_put_module
argument_list|()
expr_stmt|;
if|if
condition|(
name|na
condition|)
block|{
name|netmap_do_unregif
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
name|netmap_unget_na
argument_list|(
name|na
argument_list|,
name|priv
operator|->
name|np_ifp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for safety */
name|free
argument_list|(
name|priv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* call with NMG_LOCK *not* held */
end_comment

begin_function
name|void
name|netmap_dtor
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|data
decl_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|netmap_priv_delete
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handlers for synchronization of the queues from/to the host.  * Netmap has two operating modes:  * - in the default mode, the rings connected to the host stack are  *   just another ring pair managed by userspace;  * - in transparent mode (XXX to be defined) incoming packets  *   (from the host or the NIC) are marked as NS_FORWARD upon  *   arrival, and the user application has a chance to reset the  *   flag for packets that should be dropped.  *   On the RXSYNC or poll(), packets in RX rings between  *   kring->nr_kcur and ring->cur with NS_FORWARD still set are moved  *   to the other side.  * The transfer NIC --> host is relatively easy, just encapsulate  * into mbufs and we are done. The host --> NIC side is slightly  * harder because there might not be room in the tx ring so it  * might take a while before releasing the buffer.  */
end_comment

begin_comment
comment|/*  * pass a chain of buffers to the host stack as coming from 'dst'  * We do not need to lock because the queue is private.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_send_up
parameter_list|(
name|struct
name|ifnet
modifier|*
name|dst
parameter_list|,
name|struct
name|mbq
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|head
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
comment|/* send packets up, outside the lock */
while|while
condition|(
operator|(
name|m
operator|=
name|mbq_dequeue
argument_list|(
name|q
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"sending up pkt %p size %d"
argument_list|,
name|m
argument_list|,
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|nm_os_send_up
argument_list|(
name|dst
argument_list|,
name|m
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|head
operator|=
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|head
condition|)
name|nm_os_send_up
argument_list|(
name|dst
argument_list|,
name|NULL
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|mbq_fini
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * put a copy of the buffers marked NS_FORWARD into an mbuf chain.  * Take packets from hwcur to ring->head marked NS_FORWARD (or forced)  * and pass them up. Drop remaining packets in the unlikely event  * of an mbuf shortage.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_grab_packets
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|struct
name|mbq
modifier|*
name|q
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
for|for
control|(
name|n
operator|=
name|kring
operator|->
name|nr_hwcur
init|;
name|n
operator|!=
name|head
condition|;
name|n
operator|=
name|nm_next
argument_list|(
name|n
argument_list|,
name|lim
argument_list|)
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_FORWARD
operator|)
operator|==
literal|0
operator|&&
operator|!
name|force
condition|)
continue|continue;
if|if
condition|(
name|slot
operator|->
name|len
operator|<
literal|14
operator|||
name|slot
operator|->
name|len
operator|>
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"bad pkt at %d len %d"
argument_list|,
name|n
argument_list|,
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_FORWARD
expr_stmt|;
comment|// XXX needed ?
comment|/* XXX TODO: adapt to the case of a multisegment packet */
name|m
operator|=
name|m_devget
argument_list|(
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
argument_list|,
name|slot
operator|->
name|len
argument_list|,
literal|0
argument_list|,
name|na
operator|->
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|mbq_enqueue
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|_nm_may_forward
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
return|return
operator|(
operator|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
operator|)
operator|&&
name|kring
operator|->
name|na
operator|->
name|na_flags
operator|&
name|NAF_HOST_RINGS
operator|&&
name|kring
operator|->
name|tx
operator|==
name|NR_RX
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|nm_may_forward_up
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
return|return
name|_nm_may_forward
argument_list|(
name|kring
argument_list|)
operator|&&
name|kring
operator|->
name|ring_id
operator|!=
name|kring
operator|->
name|na
operator|->
name|num_rx_rings
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|nm_may_forward_down
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
return|return
name|_nm_may_forward
argument_list|(
name|kring
argument_list|)
operator|&&
name|kring
operator|->
name|ring_id
operator|==
name|kring
operator|->
name|na
operator|->
name|num_rx_rings
return|;
block|}
end_function

begin_comment
comment|/*  * Send to the NIC rings packets marked NS_FORWARD between  * kring->nr_hwcur and kring->rhead  * Called under kring->rx_queue.lock on the sw rx ring,  */
end_comment

begin_function
specifier|static
name|u_int
name|netmap_sw_to_nic
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|rxslot
init|=
name|kring
operator|->
name|ring
operator|->
name|slot
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|rxcur
init|=
name|kring
operator|->
name|nr_hwcur
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|u_int
specifier|const
name|src_lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
name|sent
init|=
literal|0
decl_stmt|;
comment|/* scan rings to find space, then fill as much as possible */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kdst
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|rdst
init|=
name|kdst
operator|->
name|ring
decl_stmt|;
name|u_int
specifier|const
name|dst_lim
init|=
name|kdst
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
comment|/* XXX do we trust ring or kring->rcur,rtail ? */
for|for
control|(
init|;
name|rxcur
operator|!=
name|head
operator|&&
operator|!
name|nm_ring_empty
argument_list|(
name|rdst
argument_list|)
condition|;
name|rxcur
operator|=
name|nm_next
argument_list|(
name|rxcur
argument_list|,
name|src_lim
argument_list|)
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
name|tmp
decl_stmt|;
name|u_int
name|dst_head
init|=
name|rdst
operator|->
name|head
decl_stmt|;
name|src
operator|=
operator|&
name|rxslot
index|[
name|rxcur
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|src
operator|->
name|flags
operator|&
name|NS_FORWARD
operator|)
operator|==
literal|0
operator|&&
operator|!
name|netmap_fwd
condition|)
continue|continue;
name|sent
operator|++
expr_stmt|;
name|dst
operator|=
operator|&
name|rdst
operator|->
name|slot
index|[
name|dst_head
index|]
expr_stmt|;
name|tmp
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|->
name|buf_idx
operator|=
name|dst
operator|->
name|buf_idx
expr_stmt|;
name|src
operator|->
name|flags
operator|=
name|NS_BUF_CHANGED
expr_stmt|;
name|dst
operator|->
name|buf_idx
operator|=
name|tmp
operator|.
name|buf_idx
expr_stmt|;
name|dst
operator|->
name|len
operator|=
name|tmp
operator|.
name|len
expr_stmt|;
name|dst
operator|->
name|flags
operator|=
name|NS_BUF_CHANGED
expr_stmt|;
name|rdst
operator|->
name|head
operator|=
name|rdst
operator|->
name|cur
operator|=
name|nm_next
argument_list|(
name|dst_head
argument_list|,
name|dst_lim
argument_list|)
expr_stmt|;
block|}
comment|/* if (sent) XXX txsync ? */
block|}
return|return
name|sent
return|;
block|}
end_function

begin_comment
comment|/*  * netmap_txsync_to_host() passes packets up. We are called from a  * system call in user process context, and the only contention  * can be among multiple user threads erroneously calling  * this routine concurrently.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_txsync_to_host
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|struct
name|mbq
name|q
decl_stmt|;
comment|/* Take packets from hwcur to head and pass them up. 	 * force head = cur since netmap_grab_packets() stops at head 	 * In case of no buffers we give up. At the end of the loop, 	 * the queue is drained in all cases. 	 */
name|mbq_init
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
name|netmap_grab_packets
argument_list|(
name|kring
argument_list|,
operator|&
name|q
argument_list|,
literal|1
comment|/* force */
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"have %d pkts in queue"
argument_list|,
name|mbq_len
argument_list|(
operator|&
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|head
expr_stmt|;
name|kring
operator|->
name|nr_hwtail
operator|=
name|head
operator|+
name|lim
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwtail
operator|>
name|lim
condition|)
name|kring
operator|->
name|nr_hwtail
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
name|netmap_send_up
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
operator|&
name|q
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * rxsync backend for packets coming from the host stack.  * They have been put in kring->rx_queue by netmap_transmit().  * We protect access to the kring using kring->rx_queue.lock  *  * This routine also does the selrecord if called from the poll handler  * (we know because sr != NULL).  *  * returns the number of packets delivered to tx queues in  * transparent mode, or a negative value if error  */
end_comment

begin_function
specifier|static
name|int
name|netmap_rxsync_from_host
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|nm_i
decl_stmt|,
name|n
decl_stmt|;
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|mbq
modifier|*
name|q
init|=
operator|&
name|kring
operator|->
name|rx_queue
decl_stmt|,
name|fq
decl_stmt|;
name|mbq_init
argument_list|(
operator|&
name|fq
argument_list|)
expr_stmt|;
comment|/* fq holds packets to be freed */
name|mbq_lock
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* First part: import newly received packets */
name|n
operator|=
name|mbq_len
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|/* grab packets from the queue */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|stop_i
decl_stmt|;
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
name|stop_i
operator|=
name|nm_prev
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
while|while
condition|(
name|nm_i
operator|!=
name|stop_i
operator|&&
operator|(
name|m
operator|=
name|mbq_dequeue
argument_list|(
name|q
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
init|=
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
decl_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"nm %d len %d"
argument_list|,
name|nm_i
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s"
argument_list|,
name|nm_dump_buf
argument_list|(
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
argument_list|,
name|len
argument_list|,
literal|128
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
name|kring
operator|->
name|nkr_slot_flags
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|mbq_enqueue
argument_list|(
operator|&
name|fq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwtail
operator|=
name|nm_i
expr_stmt|;
block|}
comment|/* 	 * Second part: skip past packets that userspace has released. 	 */
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|nm_i
operator|!=
name|head
condition|)
block|{
comment|/* something was released */
if|if
condition|(
name|nm_may_forward_down
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|ret
operator|=
name|netmap_sw_to_nic
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|kring
operator|->
name|nr_kflags
operator||=
name|NR_FORWARD
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|kring
operator|->
name|nr_hwcur
operator|=
name|head
expr_stmt|;
block|}
name|mbq_unlock
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|mbq_purge
argument_list|(
operator|&
name|fq
argument_list|)
expr_stmt|;
name|mbq_fini
argument_list|(
operator|&
name|fq
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Get a netmap adapter for the port.  *  * If it is possible to satisfy the request, return 0  * with *na containing the netmap adapter found.  * Otherwise return an error code, with *na containing NULL.  *  * When the port is attached to a bridge, we always return  * EBUSY.  * Otherwise, if the port is already bound to a file descriptor,  * then we unconditionally return the existing adapter into *na.  * In all the other cases, we return (into *na) either native,  * generic or NULL, according to the following table:  *  *					native_support  * active_fds   dev.netmap.admode         YES     NO  * -------------------------------------------------------  *>0              *                 NA(ifp) NA(ifp)  *  *     0        NETMAP_ADMODE_BEST      NATIVE  GENERIC  *     0        NETMAP_ADMODE_NATIVE    NATIVE   NULL  *     0        NETMAP_ADMODE_GENERIC   GENERIC GENERIC  *  */
end_comment

begin_function_decl
specifier|static
name|void
name|netmap_hw_dtor
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* needed by NM_IS_NATIVE() */
end_comment

begin_function
name|int
name|netmap_get_hw_na
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
modifier|*
name|na
parameter_list|)
block|{
comment|/* generic support */
name|int
name|i
init|=
name|netmap_admode
decl_stmt|;
comment|/* Take a snapshot. */
name|struct
name|netmap_adapter
modifier|*
name|prev_na
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
operator|*
name|na
operator|=
name|NULL
expr_stmt|;
comment|/* default */
comment|/* reset in case of invalid value */
if|if
condition|(
name|i
operator|<
name|NETMAP_ADMODE_BEST
operator|||
name|i
operator|>=
name|NETMAP_ADMODE_LAST
condition|)
name|i
operator|=
name|netmap_admode
operator|=
name|NETMAP_ADMODE_BEST
expr_stmt|;
if|if
condition|(
name|NM_NA_VALID
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|prev_na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* If an adapter already exists, return it if 		 * there are active file descriptors or if 		 * netmap is not forced to use generic 		 * adapters. 		 */
if|if
condition|(
name|NETMAP_OWNED_BY_ANY
argument_list|(
name|prev_na
argument_list|)
operator|||
name|i
operator|!=
name|NETMAP_ADMODE_GENERIC
operator|||
name|prev_na
operator|->
name|na_flags
operator|&
name|NAF_FORCE_NATIVE
ifdef|#
directive|ifdef
name|WITH_PIPES
comment|/* ugly, but we cannot allow an adapter switch 			 * if some pipe is referring to this one 			 */
operator|||
name|prev_na
operator|->
name|na_next_pipe
operator|>
literal|0
endif|#
directive|endif
condition|)
block|{
operator|*
name|na
operator|=
name|prev_na
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* If there isn't native support and netmap is not allowed 	 * to use generic adapters, we cannot satisfy the request. 	 */
if|if
condition|(
operator|!
name|NM_IS_NATIVE
argument_list|(
name|ifp
argument_list|)
operator|&&
name|i
operator|==
name|NETMAP_ADMODE_NATIVE
condition|)
return|return
name|EOPNOTSUPP
return|;
comment|/* Otherwise, create a generic adapter and return it, 	 * saving the previously used netmap adapter, if any. 	 * 	 * Note that here 'prev_na', if not NULL, MUST be a 	 * native adapter, and CANNOT be a generic one. This is 	 * true because generic adapters are created on demand, and 	 * destroyed when not used anymore. Therefore, if the adapter 	 * currently attached to an interface 'ifp' is generic, it 	 * must be that 	 * (NA(ifp)->active_fds> 0 || NETMAP_OWNED_BY_KERN(NA(ifp))). 	 * Consequently, if NA(ifp) is generic, we will enter one of 	 * the branches above. This ensures that we never override 	 * a generic adapter with another generic adapter. 	 */
name|error
operator|=
name|generic_netmap_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|*
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * MUST BE CALLED UNDER NMG_LOCK()  *  * Get a refcounted reference to a netmap adapter attached  * to the interface specified by nmr.  * This is always called in the execution of an ioctl().  *  * Return ENXIO if the interface specified by the request does  * not exist, ENOTSUP if netmap is not supported by the interface,  * EBUSY if the interface is already attached to a bridge,  * EINVAL if parameters are invalid, ENOMEM if needed resources  * could not be allocated.  * If successful, hold a reference to the netmap adapter.  *  * If the interface specified by nmr is a system one, also keep  * a reference to it and return a valid *ifp.  */
end_comment

begin_function
name|int
name|netmap_get_na
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
modifier|*
name|na
parameter_list|,
name|struct
name|ifnet
modifier|*
modifier|*
name|ifp
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
operator|*
name|na
operator|=
name|NULL
expr_stmt|;
comment|/* default return value */
operator|*
name|ifp
operator|=
name|NULL
expr_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* We cascade through all possible types of netmap adapter. 	 * All netmap_get_*_na() functions return an error and an na, 	 * with the following combinations: 	 * 	 * error    na 	 *   0	   NULL		type doesn't match 	 *  !0	   NULL		type matches, but na creation/lookup failed 	 *   0	  !NULL		type matches and na created/found 	 *  !0    !NULL		impossible 	 */
comment|/* try to see if this is a ptnetmap port */
name|error
operator|=
name|netmap_get_pt_host_na
argument_list|(
name|nmr
argument_list|,
name|na
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|*
name|na
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
comment|/* try to see if this is a monitor port */
name|error
operator|=
name|netmap_get_monitor_na
argument_list|(
name|nmr
argument_list|,
name|na
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|*
name|na
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
comment|/* try to see if this is a pipe port */
name|error
operator|=
name|netmap_get_pipe_na
argument_list|(
name|nmr
argument_list|,
name|na
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|*
name|na
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
comment|/* try to see if this is a bridge port */
name|error
operator|=
name|netmap_get_bdg_na
argument_list|(
name|nmr
argument_list|,
name|na
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|*
name|na
operator|!=
name|NULL
condition|)
comment|/* valid match in netmap_get_bdg_na() */
goto|goto
name|out
goto|;
comment|/* 	 * This must be a hardware na, lookup the name in the system. 	 * Note that by hardware we actually mean "it shows up in ifconfig". 	 * This may still be a tap, a veth/epair, or even a 	 * persistent VALE port. 	 */
operator|*
name|ifp
operator|=
name|ifunit_ref
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ifp
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|error
operator|=
name|netmap_get_hw_na
argument_list|(
operator|*
name|ifp
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
operator|*
name|na
operator|=
name|ret
expr_stmt|;
name|netmap_adapter_get
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|ret
condition|)
name|netmap_adapter_put
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ifp
condition|)
block|{
name|if_rele
argument_list|(
operator|*
name|ifp
argument_list|)
expr_stmt|;
operator|*
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* undo netmap_get_na() */
end_comment

begin_function
name|void
name|netmap_unget_na
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
if|if
condition|(
name|ifp
condition|)
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
condition|)
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NM_FAIL_ON
parameter_list|(
name|t
parameter_list|)
value|do {						\ 	if (unlikely(t)) {						\ 		RD(5, "%s: fail '" #t "' "				\ 			"h %d c %d t %d "				\ 			"rh %d rc %d rt %d "				\ 			"hc %d ht %d",					\ 			kring->name,					\ 			head, cur, ring->tail,				\ 			kring->rhead, kring->rcur, kring->rtail,	\ 			kring->nr_hwcur, kring->nr_hwtail);		\ 		return kring->nkr_num_slots;				\ 	}								\ } while (0)
end_define

begin_comment
comment|/*  * validate parameters on entry for *_txsync()  * Returns ring->cur if ok, or something>= kring->nkr_num_slots  * in case of error.  *  * rhead, rcur and rtail=hwtail are stored from previous round.  * hwcur is the next packet to send to the ring.  *  * We want  *    hwcur<= *rhead<= head<= cur<= tail = *rtail<= hwtail  *  * hwcur, rhead, rtail and hwtail are reliable  */
end_comment

begin_function
name|u_int
name|nm_txsync_prologue
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|struct
name|netmap_ring
modifier|*
name|ring
parameter_list|)
block|{
name|u_int
name|head
init|=
name|ring
operator|->
name|head
decl_stmt|;
comment|/* read only once */
name|u_int
name|cur
init|=
name|ring
operator|->
name|cur
decl_stmt|;
comment|/* read only once */
name|u_int
name|n
init|=
name|kring
operator|->
name|nkr_num_slots
decl_stmt|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"%s kcur %d ktail %d head %d cur %d tail %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|ring
operator|->
name|head
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|ring
operator|->
name|tail
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* kernel sanity checks; but we can trust the kring. */
name|NM_FAIL_ON
argument_list|(
name|kring
operator|->
name|nr_hwcur
operator|>=
name|n
operator|||
name|kring
operator|->
name|rhead
operator|>=
name|n
operator|||
name|kring
operator|->
name|rtail
operator|>=
name|n
operator|||
name|kring
operator|->
name|nr_hwtail
operator|>=
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* kernel sanity checks */
comment|/* 	 * user sanity checks. We only use head, 	 * A, B, ... are possible positions for head: 	 * 	 *  0    A  rhead   B  rtail   C  n-1 	 *  0    D  rtail   E  rhead   F  n-1 	 * 	 * B, F, D are valid. A, C, E are wrong 	 */
if|if
condition|(
name|kring
operator|->
name|rtail
operator|>=
name|kring
operator|->
name|rhead
condition|)
block|{
comment|/* want rhead<= head<= rtail */
name|NM_FAIL_ON
argument_list|(
name|head
operator|<
name|kring
operator|->
name|rhead
operator|||
name|head
operator|>
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
comment|/* and also head<= cur<= rtail */
name|NM_FAIL_ON
argument_list|(
name|cur
operator|<
name|head
operator|||
name|cur
operator|>
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* here rtail< rhead */
comment|/* we need head outside rtail .. rhead */
name|NM_FAIL_ON
argument_list|(
name|head
operator|>
name|kring
operator|->
name|rtail
operator|&&
name|head
operator|<
name|kring
operator|->
name|rhead
argument_list|)
expr_stmt|;
comment|/* two cases now: head<= rtail or head>= rhead  */
if|if
condition|(
name|head
operator|<=
name|kring
operator|->
name|rtail
condition|)
block|{
comment|/* want head<= cur<= rtail */
name|NM_FAIL_ON
argument_list|(
name|cur
operator|<
name|head
operator|||
name|cur
operator|>
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* head>= rhead */
comment|/* cur must be outside rtail..head */
name|NM_FAIL_ON
argument_list|(
name|cur
operator|>
name|kring
operator|->
name|rtail
operator|&&
name|cur
operator|<
name|head
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ring
operator|->
name|tail
operator|!=
name|kring
operator|->
name|rtail
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"%s tail overwritten was %d need %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|tail
operator|=
name|kring
operator|->
name|rtail
expr_stmt|;
block|}
name|kring
operator|->
name|rhead
operator|=
name|head
expr_stmt|;
name|kring
operator|->
name|rcur
operator|=
name|cur
expr_stmt|;
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/*  * validate parameters on entry for *_rxsync()  * Returns ring->head if ok, kring->nkr_num_slots on error.  *  * For a valid configuration,  * hwcur<= head<= cur<= tail<= hwtail  *  * We only consider head and cur.  * hwcur and hwtail are reliable.  *  */
end_comment

begin_function
name|u_int
name|nm_rxsync_prologue
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|struct
name|netmap_ring
modifier|*
name|ring
parameter_list|)
block|{
name|uint32_t
specifier|const
name|n
init|=
name|kring
operator|->
name|nkr_num_slots
decl_stmt|;
name|uint32_t
name|head
decl_stmt|,
name|cur
decl_stmt|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"%s kc %d kt %d h %d c %d t %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|ring
operator|->
name|head
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|ring
operator|->
name|tail
argument_list|)
expr_stmt|;
comment|/* 	 * Before storing the new values, we should check they do not 	 * move backwards. However: 	 * - head is not an issue because the previous value is hwcur; 	 * - cur could in principle go back, however it does not matter 	 *   because we are processing a brand new rxsync() 	 */
name|cur
operator|=
name|kring
operator|->
name|rcur
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
comment|/* read only once */
name|head
operator|=
name|kring
operator|->
name|rhead
operator|=
name|ring
operator|->
name|head
expr_stmt|;
comment|/* read only once */
if|#
directive|if
literal|1
comment|/* kernel sanity checks */
name|NM_FAIL_ON
argument_list|(
name|kring
operator|->
name|nr_hwcur
operator|>=
name|n
operator|||
name|kring
operator|->
name|nr_hwtail
operator|>=
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* kernel sanity checks */
comment|/* user sanity checks */
if|if
condition|(
name|kring
operator|->
name|nr_hwtail
operator|>=
name|kring
operator|->
name|nr_hwcur
condition|)
block|{
comment|/* want hwcur<= rhead<= hwtail */
name|NM_FAIL_ON
argument_list|(
name|head
operator|<
name|kring
operator|->
name|nr_hwcur
operator|||
name|head
operator|>
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
comment|/* and also rhead<= rcur<= hwtail */
name|NM_FAIL_ON
argument_list|(
name|cur
operator|<
name|head
operator|||
name|cur
operator|>
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we need rhead outside hwtail..hwcur */
name|NM_FAIL_ON
argument_list|(
name|head
operator|<
name|kring
operator|->
name|nr_hwcur
operator|&&
name|head
operator|>
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
comment|/* two cases now: head<= hwtail or head>= hwcur  */
if|if
condition|(
name|head
operator|<=
name|kring
operator|->
name|nr_hwtail
condition|)
block|{
comment|/* want head<= cur<= hwtail */
name|NM_FAIL_ON
argument_list|(
name|cur
operator|<
name|head
operator|||
name|cur
operator|>
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* cur must be outside hwtail..head */
name|NM_FAIL_ON
argument_list|(
name|cur
operator|<
name|head
operator|&&
name|cur
operator|>
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ring
operator|->
name|tail
operator|!=
name|kring
operator|->
name|rtail
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"%s tail overwritten was %d need %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|tail
operator|=
name|kring
operator|->
name|rtail
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/*  * Error routine called when txsync/rxsync detects an error.  * Can't do much more than resetting head =cur = hwcur, tail = hwtail  * Return 1 on reinit.  *  * This routine is only called by the upper half of the kernel.  * It only reads hwcur (which is changed only by the upper half, too)  * and hwtail (which may be changed by the lower half, but only on  * a tx ring and only to increase it, so any error will be recovered  * on the next call). For the above, we don't strictly need to call  * it under lock.  */
end_comment

begin_function
name|int
name|netmap_ring_reinit
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
comment|// XXX KASSERT nm_kr_tryget
name|RD
argument_list|(
literal|10
argument_list|,
literal|"called for %s"
argument_list|,
name|kring
operator|->
name|name
argument_list|)
expr_stmt|;
comment|// XXX probably wrong to trust userspace
name|kring
operator|->
name|rhead
operator|=
name|ring
operator|->
name|head
expr_stmt|;
name|kring
operator|->
name|rcur
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|kring
operator|->
name|rtail
operator|=
name|ring
operator|->
name|tail
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|cur
operator|>
name|lim
condition|)
name|errors
operator|++
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|head
operator|>
name|lim
condition|)
name|errors
operator|++
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|tail
operator|>
name|lim
condition|)
name|errors
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|idx
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
decl_stmt|;
name|u_int
name|len
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|2
operator|||
name|idx
operator|>=
name|kring
operator|->
name|na
operator|->
name|na_lut
operator|.
name|objtotal
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"bad index at slot %d idx %d len %d "
argument_list|,
name|i
argument_list|,
name|idx
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
name|NETMAP_BUF_SIZE
argument_list|(
name|kring
operator|->
name|na
argument_list|)
condition|)
block|{
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|RD
argument_list|(
literal|5
argument_list|,
literal|"bad len at slot %d idx %d len %d"
argument_list|,
name|i
argument_list|,
name|idx
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errors
condition|)
block|{
name|RD
argument_list|(
literal|10
argument_list|,
literal|"total %d errors"
argument_list|,
name|errors
argument_list|)
expr_stmt|;
name|RD
argument_list|(
literal|10
argument_list|,
literal|"%s reinit, cur %d -> %d tail %d -> %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|head
operator|=
name|kring
operator|->
name|rhead
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|rcur
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|ring
operator|->
name|tail
operator|=
name|kring
operator|->
name|rtail
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
block|}
return|return
operator|(
name|errors
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* interpret the ringid and flags fields of an nmreq, by translating them  * into a pair of intervals of ring indices:  *  * [priv->np_txqfirst, priv->np_txqlast) and  * [priv->np_rxqfirst, priv->np_rxqlast)  *  */
end_comment

begin_function
name|int
name|netmap_interp_ringid
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|uint16_t
name|ringid
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|u_int
name|j
decl_stmt|,
name|i
init|=
name|ringid
operator|&
name|NETMAP_RING_MASK
decl_stmt|;
name|u_int
name|reg
init|=
name|flags
operator|&
name|NR_REG_MASK
decl_stmt|;
name|int
name|excluded_direction
index|[]
init|=
block|{
name|NR_TX_RINGS_ONLY
block|,
name|NR_RX_RINGS_ONLY
block|}
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|NR_REG_DEFAULT
condition|)
block|{
comment|/* convert from old ringid to flags */
if|if
condition|(
name|ringid
operator|&
name|NETMAP_SW_RING
condition|)
block|{
name|reg
operator|=
name|NR_REG_SW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ringid
operator|&
name|NETMAP_HW_RING
condition|)
block|{
name|reg
operator|=
name|NR_REG_ONE_NIC
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|NR_REG_ALL_NIC
expr_stmt|;
block|}
name|D
argument_list|(
literal|"deprecated API, old ringid 0x%x -> ringid %x reg %d"
argument_list|,
name|ringid
argument_list|,
name|i
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|NR_PTNETMAP_HOST
operator|)
operator|&&
operator|(
name|reg
operator|!=
name|NR_REG_ALL_NIC
operator|||
name|flags
operator|&
operator|(
name|NR_RX_RINGS_ONLY
operator||
name|NR_TX_RINGS_ONLY
operator|)
operator|)
condition|)
block|{
name|D
argument_list|(
literal|"Error: only NR_REG_ALL_NIC supported with netmap passthrough"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|excluded_direction
index|[
name|t
index|]
condition|)
block|{
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
operator|=
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|NR_REG_ALL_NIC
case|:
case|case
name|NR_REG_PIPE_MASTER
case|:
case|case
name|NR_REG_PIPE_SLAVE
case|:
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
operator|=
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"ALL/PIPE: %s %d %d"
argument_list|,
name|nm_txrx2str
argument_list|(
name|t
argument_list|)
argument_list|,
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
argument_list|,
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|NR_REG_SW
case|:
case|case
name|NR_REG_NIC_SW
case|:
if|if
condition|(
operator|!
operator|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_HOST_RINGS
operator|)
condition|)
block|{
name|D
argument_list|(
literal|"host rings not supported"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
operator|=
operator|(
name|reg
operator|==
name|NR_REG_SW
condition|?
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
operator|=
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ND
argument_list|(
literal|"%s: %s %d %d"
argument_list|,
name|reg
operator|==
name|NR_REG_SW
condition|?
literal|"SW"
else|:
literal|"NIC+SW"
argument_list|,
name|nm_txrx2str
argument_list|(
name|t
argument_list|)
argument_list|,
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
argument_list|,
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|NR_REG_ONE_NIC
case|:
if|if
condition|(
name|i
operator|>=
name|na
operator|->
name|num_tx_rings
operator|&&
name|i
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
block|{
name|D
argument_list|(
literal|"invalid ring id %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* if not enough rings, use the first one */
name|j
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
condition|)
name|j
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
operator|=
name|j
expr_stmt|;
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
operator|=
name|j
operator|+
literal|1
expr_stmt|;
name|ND
argument_list|(
literal|"ONE_NIC: %s %d %d"
argument_list|,
name|nm_txrx2str
argument_list|(
name|t
argument_list|)
argument_list|,
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
argument_list|,
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|D
argument_list|(
literal|"invalid regif type %d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
name|priv
operator|->
name|np_flags
operator|=
operator|(
name|flags
operator|&
operator|~
name|NR_REG_MASK
operator|)
operator||
name|reg
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
block|{
name|D
argument_list|(
literal|"%s: tx [%d,%d) rx [%d,%d) id %d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|priv
operator|->
name|np_qfirst
index|[
name|NR_TX
index|]
argument_list|,
name|priv
operator|->
name|np_qlast
index|[
name|NR_TX
index|]
argument_list|,
name|priv
operator|->
name|np_qfirst
index|[
name|NR_RX
index|]
argument_list|,
name|priv
operator|->
name|np_qlast
index|[
name|NR_RX
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Set the ring ID. For devices with a single queue, a request  * for all rings is the same as a single ring.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_set_ringid
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|uint16_t
name|ringid
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|int
name|error
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
name|error
operator|=
name|netmap_interp_ringid
argument_list|(
name|priv
argument_list|,
name|ringid
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|priv
operator|->
name|np_txpoll
operator|=
operator|(
name|ringid
operator|&
name|NETMAP_NO_TX_POLL
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/* optimization: count the users registered for more than 	 * one ring, which are the ones sleeping on the global queue. 	 * The default netmap_notify() callback will then 	 * avoid signaling the global queue if nobody is using it 	 */
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
if|if
condition|(
name|nm_si_user
argument_list|(
name|priv
argument_list|,
name|t
argument_list|)
condition|)
name|na
operator|->
name|si_users
index|[
name|t
index|]
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_unset_ringid
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
if|if
condition|(
name|nm_si_user
argument_list|(
name|priv
argument_list|,
name|t
argument_list|)
condition|)
name|na
operator|->
name|si_users
index|[
name|t
index|]
operator|--
expr_stmt|;
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
operator|=
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|priv
operator|->
name|np_flags
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|np_txpoll
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the nr_pending_mode for the requested rings.  * If requested, also try to get exclusive access to the rings, provided  * the rings we want to bind are not exclusively owned by a previous bind.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_krings_get
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|int
name|excl
init|=
operator|(
name|priv
operator|->
name|np_flags
operator|&
name|NR_EXCLUSIVE
operator|)
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
name|ND
argument_list|(
literal|"%s: grabbing tx [%d, %d) rx [%d, %d)"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|priv
operator|->
name|np_qfirst
index|[
name|NR_TX
index|]
argument_list|,
name|priv
operator|->
name|np_qlast
index|[
name|NR_TX
index|]
argument_list|,
name|priv
operator|->
name|np_qfirst
index|[
name|NR_RX
index|]
argument_list|,
name|priv
operator|->
name|np_qlast
index|[
name|NR_RX
index|]
argument_list|)
expr_stmt|;
comment|/* first round: check that all the requested rings 	 * are neither alread exclusively owned, nor we 	 * want exclusive ownership when they are already in use 	 */
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
init|;
name|i
operator|<
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|kring
operator|->
name|nr_kflags
operator|&
name|NKR_EXCLUSIVE
operator|)
operator|||
operator|(
name|kring
operator|->
name|users
operator|&&
name|excl
operator|)
condition|)
block|{
name|ND
argument_list|(
literal|"ring %s busy"
argument_list|,
name|kring
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
block|}
block|}
comment|/* second round: increment usage count (possibly marking them 	 * as exclusive) and set the nr_pending_mode 	 */
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
init|;
name|i
operator|<
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
name|kring
operator|->
name|users
operator|++
expr_stmt|;
if|if
condition|(
name|excl
condition|)
name|kring
operator|->
name|nr_kflags
operator||=
name|NKR_EXCLUSIVE
expr_stmt|;
name|kring
operator|->
name|nr_pending_mode
operator|=
name|NKR_NETMAP_ON
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Undo netmap_krings_get(). This is done by clearing the exclusive mode  * if was asked on regif, and unset the nr_pending_mode if we are the  * last users of the involved rings. */
end_comment

begin_function
specifier|static
name|void
name|netmap_krings_put
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|priv
operator|->
name|np_na
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|int
name|excl
init|=
operator|(
name|priv
operator|->
name|np_flags
operator|&
name|NR_EXCLUSIVE
operator|)
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
name|ND
argument_list|(
literal|"%s: releasing tx [%d, %d) rx [%d, %d)"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|priv
operator|->
name|np_qfirst
index|[
name|NR_TX
index|]
argument_list|,
name|priv
operator|->
name|np_qlast
index|[
name|NR_TX
index|]
argument_list|,
name|priv
operator|->
name|np_qfirst
index|[
name|NR_RX
index|]
argument_list|,
name|priv
operator|->
name|np_qlast
index|[
name|MR_RX
index|]
argument_list|)
expr_stmt|;
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
init|;
name|i
operator|<
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|excl
condition|)
name|kring
operator|->
name|nr_kflags
operator|&=
operator|~
name|NKR_EXCLUSIVE
expr_stmt|;
name|kring
operator|->
name|users
operator|--
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|users
operator|==
literal|0
condition|)
name|kring
operator|->
name|nr_pending_mode
operator|=
name|NKR_NETMAP_OFF
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * possibly move the interface to netmap-mode.  * If success it returns a pointer to netmap_if, otherwise NULL.  * This must be called with NMG_LOCK held.  *  * The following na callbacks are called in the process:  *  * na->nm_config()			[by netmap_update_config]  * (get current number and size of rings)  *  *  	We have a generic one for linux (netmap_linux_config).  *  	The bwrap has to override this, since it has to forward  *  	the request to the wrapped adapter (netmap_bwrap_config).  *  *  * na->nm_krings_create()  * (create and init the krings array)  *  * 	One of the following:  *  *	* netmap_hw_krings_create, 			(hw ports)  *		creates the standard layout for the krings  * 		and adds the mbq (used for the host rings).  *  * 	* netmap_vp_krings_create			(VALE ports)  * 		add leases and scratchpads  *  * 	* netmap_pipe_krings_create			(pipes)  * 		create the krings and rings of both ends and  * 		cross-link them  *  *      * netmap_monitor_krings_create 			(monitors)  *      	avoid allocating the mbq  *  *      * netmap_bwrap_krings_create			(bwraps)  *      	create both the brap krings array,  *      	the krings array of the wrapped adapter, and  *      	(if needed) the fake array for the host adapter  *  * na->nm_register(, 1)  * (put the adapter in netmap mode)  *  * 	This may be one of the following:  *  * 	* netmap_hw_reg				        (hw ports)  * 		checks that the ifp is still there, then calls  * 		the hardware specific callback;  *  * 	* netmap_vp_reg					(VALE ports)  *		If the port is connected to a bridge,  *		set the NAF_NETMAP_ON flag under the  *		bridge write lock.  *  *	* netmap_pipe_reg				(pipes)  *		inform the other pipe end that it is no  *		longer responsible for the lifetime of this  *		pipe end  *  *	* netmap_monitor_reg				(monitors)  *		intercept the sync callbacks of the monitored  *		rings  *  *	* netmap_bwrap_reg				(bwraps)  *		cross-link the bwrap and hwna rings,  *		forward the request to the hwna, override  *		the hwna notify callback (to get the frames  *		coming from outside go through the bridge).  *  *  */
end_comment

begin_function
name|int
name|netmap_do_regif
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|uint16_t
name|ringid
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* ring configuration may have changed, fetch from the card */
name|netmap_update_config
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_na
operator|=
name|na
expr_stmt|;
comment|/* store the reference */
name|error
operator|=
name|netmap_set_ringid
argument_list|(
name|priv
argument_list|,
name|ringid
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err
goto|;
name|error
operator|=
name|netmap_mem_finalize
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If this is the first registration of the adapter, 		 * create the  in-kernel view of the netmap rings, 		 * the netmap krings. 		 */
comment|/* 		 * Depending on the adapter, this may also create 		 * the netmap rings themselves 		 */
name|error
operator|=
name|na
operator|->
name|nm_krings_create
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_drop_mem
goto|;
block|}
comment|/* now the krings must exist and we can check whether some 	 * previous bind has exclusive ownership on them, and set 	 * nr_pending_mode 	 */
name|error
operator|=
name|netmap_krings_get
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_del_krings
goto|;
comment|/* create all needed missing netmap rings */
name|error
operator|=
name|netmap_mem_rings_create
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_rel_excl
goto|;
comment|/* in all cases, create a new netmap if */
name|nifp
operator|=
name|netmap_mem_if_new
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_del_rings
goto|;
block|}
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
block|{
comment|/* cache the allocator info in the na */
name|error
operator|=
name|netmap_mem_get_lut
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
operator|&
name|na
operator|->
name|na_lut
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_del_if
goto|;
name|ND
argument_list|(
literal|"lut %p bufs %u size %u"
argument_list|,
name|na
operator|->
name|na_lut
operator|.
name|lut
argument_list|,
name|na
operator|->
name|na_lut
operator|.
name|objtotal
argument_list|,
name|na
operator|->
name|na_lut
operator|.
name|objsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nm_kring_pending
argument_list|(
name|priv
argument_list|)
condition|)
block|{
comment|/* Some kring is switching mode, tell the adapter to 		 * react on this. */
name|error
operator|=
name|na
operator|->
name|nm_register
argument_list|(
name|na
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_put_lut
goto|;
block|}
comment|/* Commit the reference. */
name|na
operator|->
name|active_fds
operator|++
expr_stmt|;
comment|/* 	 * advertise that the interface is ready by setting np_nifp. 	 * The barrier is needed because readers (poll, *SYNC and mmap) 	 * check for priv->np_nifp != NULL without locking 	 */
name|mb
argument_list|()
expr_stmt|;
comment|/* make sure previous writes are visible to all CPUs */
name|priv
operator|->
name|np_nifp
operator|=
name|nifp
expr_stmt|;
return|return
literal|0
return|;
name|err_put_lut
label|:
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
name|memset
argument_list|(
operator|&
name|na
operator|->
name|na_lut
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|na
operator|->
name|na_lut
argument_list|)
argument_list|)
expr_stmt|;
name|err_del_if
label|:
name|netmap_mem_if_delete
argument_list|(
name|na
argument_list|,
name|nifp
argument_list|)
expr_stmt|;
name|err_rel_excl
label|:
name|netmap_krings_put
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|err_del_rings
label|:
name|netmap_mem_rings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|err_del_krings
label|:
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
name|na
operator|->
name|nm_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|err_drop_mem
label|:
name|netmap_mem_deref
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|err
label|:
name|priv
operator|->
name|np_na
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * update kring and ring at the end of rxsync/txsync.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|nm_sync_finalize
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
comment|/* 	 * Update ring tail to what the kernel knows 	 * After txsync: head/rhead/hwcur might be behind cur/rcur 	 * if no carrier. 	 */
name|kring
operator|->
name|ring
operator|->
name|tail
operator|=
name|kring
operator|->
name|rtail
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"%s now hwcur %d hwtail %d head %d cur %d tail %d"
argument_list|,
name|kring
operator|->
name|name
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|kring
operator|->
name|rhead
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ioctl(2) support for the "netmap" device.  *  * Following a list of accepted commands:  * - NIOCGINFO  * - SIOCGIFADDR	just for convenience  * - NIOCREGIF  * - NIOCTXSYNC  * - NIOCRXSYNC  *  * Return 0 on success, errno otherwise.  */
end_comment

begin_function
name|int
name|netmap_ioctl
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|nmreq
modifier|*
name|nmr
init|=
operator|(
expr|struct
name|nmreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|qfirst
decl_stmt|,
name|qlast
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|krings
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NIOCGINFO
operator|||
name|cmd
operator|==
name|NIOCREGIF
condition|)
block|{
comment|/* truncate name */
name|nmr
operator|->
name|nr_name
index|[
sizeof|sizeof
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|!=
name|NETMAP_API
condition|)
block|{
name|D
argument_list|(
literal|"API mismatch for %s got %d need %d"
argument_list|,
name|nmr
operator|->
name|nr_name
argument_list|,
name|nmr
operator|->
name|nr_version
argument_list|,
name|NETMAP_API
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
block|}
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|<
name|NETMAP_MIN_API
operator|||
name|nmr
operator|->
name|nr_version
operator|>
name|NETMAP_MAX_API
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NIOCGINFO
case|:
comment|/* return capabilities etc */
if|if
condition|(
name|nmr
operator|->
name|nr_cmd
operator|==
name|NETMAP_BDG_LIST
condition|)
block|{
name|error
operator|=
name|netmap_bdg_ctl
argument_list|(
name|nmr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|NMG_LOCK
argument_list|()
expr_stmt|;
do|do
block|{
comment|/* memsize is always valid */
name|struct
name|netmap_mem_d
modifier|*
name|nmd
init|=
operator|&
name|nm_mem
decl_stmt|;
name|u_int
name|memflags
decl_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* get a refcount */
name|error
operator|=
name|netmap_get_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
operator|&
name|ifp
argument_list|,
literal|1
comment|/* create */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|na
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|nmd
operator|=
name|na
operator|->
name|nm_mem
expr_stmt|;
comment|/* get memory allocator */
block|}
name|error
operator|=
name|netmap_mem_get_info
argument_list|(
name|nmd
argument_list|,
operator|&
name|nmr
operator|->
name|nr_memsize
argument_list|,
operator|&
name|memflags
argument_list|,
operator|&
name|nmr
operator|->
name|nr_arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
comment|/* only memory info */
break|break;
name|nmr
operator|->
name|nr_offset
operator|=
literal|0
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|nmr
operator|->
name|nr_tx_slots
operator|=
literal|0
expr_stmt|;
name|netmap_update_config
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|netmap_unget_na
argument_list|(
name|na
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|NIOCREGIF
case|:
comment|/* 		 * If nmr->nr_cmd is not zero, this NIOCREGIF is not really 		 * a regif operation, but a different one, specified by the 		 * value of nmr->nr_cmd. 		 */
name|i
operator|=
name|nmr
operator|->
name|nr_cmd
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NETMAP_BDG_ATTACH
operator|||
name|i
operator|==
name|NETMAP_BDG_DETACH
operator|||
name|i
operator|==
name|NETMAP_BDG_VNET_HDR
operator|||
name|i
operator|==
name|NETMAP_BDG_NEWIF
operator|||
name|i
operator|==
name|NETMAP_BDG_DELIF
operator|||
name|i
operator|==
name|NETMAP_BDG_POLLING_ON
operator|||
name|i
operator|==
name|NETMAP_BDG_POLLING_OFF
condition|)
block|{
comment|/* possibly attach/detach NIC and VALE switch */
name|error
operator|=
name|netmap_bdg_ctl
argument_list|(
name|nmr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|NETMAP_PT_HOST_CREATE
operator|||
name|i
operator|==
name|NETMAP_PT_HOST_DELETE
condition|)
block|{
comment|/* forward the command to the ptnetmap subsystem */
name|error
operator|=
name|ptnetmap_ctl
argument_list|(
name|nmr
argument_list|,
name|priv
operator|->
name|np_na
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|NETMAP_VNET_HDR_GET
condition|)
block|{
comment|/* get vnet-header length for this netmap port */
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_get_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
operator|&
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|&&
operator|!
name|error
condition|)
block|{
name|nmr
operator|->
name|nr_arg1
operator|=
name|na
operator|->
name|virt_hdr_len
expr_stmt|;
block|}
name|netmap_unget_na
argument_list|(
name|na
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|NETMAP_POOLS_INFO_GET
condition|)
block|{
comment|/* get information from the memory allocator */
name|error
operator|=
name|netmap_mem_pools_info_get
argument_list|(
name|nmr
argument_list|,
name|priv
operator|->
name|np_na
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"nr_cmd must be 0 not %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* protect access to priv from concurrent NIOCREGIF */
name|NMG_LOCK
argument_list|()
expr_stmt|;
do|do
block|{
name|u_int
name|memflags
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_nifp
operator|!=
name|NULL
condition|)
block|{
comment|/* thread already registered */
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* find the interface and a reference */
name|error
operator|=
name|netmap_get_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
operator|&
name|ifp
argument_list|,
literal|1
comment|/* create */
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|NETMAP_OWNED_BY_KERN
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|netmap_unget_na
argument_list|(
name|na
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|na
operator|->
name|virt_hdr_len
operator|&&
operator|!
operator|(
name|nmr
operator|->
name|nr_flags
operator|&
name|NR_ACCEPT_VNET_HDR
operator|)
condition|)
block|{
name|netmap_unget_na
argument_list|(
name|na
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|netmap_do_regif
argument_list|(
name|priv
argument_list|,
name|na
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|,
name|nmr
operator|->
name|nr_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* reg. failed, release priv and ref */
name|netmap_unget_na
argument_list|(
name|na
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
name|nifp
operator|=
name|priv
operator|->
name|np_nifp
expr_stmt|;
name|priv
operator|->
name|np_td
operator|=
name|td
expr_stmt|;
comment|// XXX kqueue, debugging only
comment|/* return the offset of the netmap_if object */
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|error
operator|=
name|netmap_mem_get_info
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
operator|&
name|nmr
operator|->
name|nr_memsize
argument_list|,
operator|&
name|memflags
argument_list|,
operator|&
name|nmr
operator|->
name|nr_arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|netmap_do_unregif
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|netmap_unget_na
argument_list|(
name|na
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|memflags
operator|&
name|NETMAP_MEM_PRIVATE
condition|)
block|{
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|nifp
operator|->
name|ni_flags
operator||=
name|NI_PRIV_MEM
expr_stmt|;
block|}
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
name|priv
operator|->
name|np_si
index|[
name|t
index|]
operator|=
name|nm_si_user
argument_list|(
name|priv
argument_list|,
name|t
argument_list|)
condition|?
operator|&
name|na
operator|->
name|si
index|[
name|t
index|]
else|:
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
index|]
operator|.
name|si
expr_stmt|;
block|}
if|if
condition|(
name|nmr
operator|->
name|nr_arg3
condition|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"requested %d extra buffers"
argument_list|,
name|nmr
operator|->
name|nr_arg3
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_arg3
operator|=
name|netmap_extra_alloc
argument_list|(
name|na
argument_list|,
operator|&
name|nifp
operator|->
name|ni_bufs_head
argument_list|,
name|nmr
operator|->
name|nr_arg3
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"got %d extra buffers"
argument_list|,
name|nmr
operator|->
name|nr_arg3
argument_list|)
expr_stmt|;
block|}
name|nmr
operator|->
name|nr_offset
operator|=
name|netmap_mem_if_offset
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|,
name|nifp
argument_list|)
expr_stmt|;
comment|/* store ifp reference so that priv destructor may release it */
name|priv
operator|->
name|np_ifp
operator|=
name|ifp
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|NIOCTXSYNC
case|:
case|case
name|NIOCRXSYNC
case|:
name|nifp
operator|=
name|priv
operator|->
name|np_nifp
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|mb
argument_list|()
expr_stmt|;
comment|/* make sure following reads are not from cache */
name|na
operator|=
name|priv
operator|->
name|np_na
expr_stmt|;
comment|/* we have a reference */
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"Internal error: nifp != NULL&& na == NULL"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|t
operator|=
operator|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|?
name|NR_TX
else|:
name|NR_RX
operator|)
expr_stmt|;
name|krings
operator|=
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|qfirst
operator|=
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
expr_stmt|;
name|qlast
operator|=
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|qfirst
init|;
name|i
operator|<
name|qlast
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
name|krings
operator|+
name|i
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|,
literal|1
argument_list|,
operator|&
name|error
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
operator|(
name|error
condition|?
name|EIO
else|:
literal|0
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
block|{
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"pre txsync ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_txsync_prologue
argument_list|(
name|kring
argument_list|,
name|ring
argument_list|)
operator|>=
name|kring
operator|->
name|nkr_num_slots
condition|)
block|{
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kring
operator|->
name|nm_sync
argument_list|(
name|kring
argument_list|,
name|NAF_FORCE_RECLAIM
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nm_sync_finalize
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"post txsync ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nm_rxsync_prologue
argument_list|(
name|kring
argument_list|,
name|ring
argument_list|)
operator|>=
name|kring
operator|->
name|nkr_num_slots
condition|)
block|{
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kring
operator|->
name|nm_sync
argument_list|(
name|kring
argument_list|,
name|NAF_FORCE_READ
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nm_sync_finalize
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
name|microtime
argument_list|(
operator|&
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|WITH_VALE
case|case
name|NIOCCONFIG
case|:
name|error
operator|=
name|netmap_bdg_config
argument_list|(
name|nmr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__FreeBSD__
case|case
name|FIONBIO
case|:
case|case
name|FIOASYNC
case|:
name|ND
argument_list|(
literal|"FIONBIO/FIOASYNC are no-ops"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOCIMMEDIATE
case|:
case|case
name|BIOCGHDRCMPLT
case|:
case|case
name|BIOCSHDRCMPLT
case|:
case|case
name|BIOCSSEESENT
case|:
name|D
argument_list|(
literal|"ignore BIOCIMMEDIATE/BIOCSHDRCMPLT/BIOCSHDRCMPLT/BIOCSSEESENT"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* allow device-specific ioctls */
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ifunit_ref
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
else|else
block|{
name|struct
name|socket
name|so
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|so
argument_list|,
sizeof|sizeof
argument_list|(
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|so
operator|.
name|so_vnet
operator|=
name|ifp
operator|->
name|if_vnet
expr_stmt|;
comment|// so->so_proto not null.
name|error
operator|=
name|ifioctl
argument_list|(
operator|&
name|so
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|#
directive|else
comment|/* linux */
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
comment|/* linux */
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * select(2) and poll(2) handlers for the "netmap" device.  *  * Can be called for one or more queues.  * Return true the event mask corresponding to ready events.  * If there are no ready events, do a selrecord on either individual  * selinfo or on the global one.  * Device-dependent parts (locking and sync of tx/rx rings)  * are done through callbacks.  *  * On linux, arguments are really pwait, the poll table, and 'td' is struct file *  * The first one is remapped to pwait as selrecord() uses the name as an  * hidden argument.  */
end_comment

begin_function
name|int
name|netmap_poll
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|int
name|events
parameter_list|,
name|NM_SELRECORD_T
modifier|*
name|sr
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|check_all_tx
decl_stmt|,
name|check_all_rx
decl_stmt|,
name|want
index|[
name|NR_TXRX
index|]
decl_stmt|,
name|revents
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|want_tx
value|want[NR_TX]
define|#
directive|define
name|want_rx
value|want[NR_RX]
name|struct
name|mbq
name|q
decl_stmt|;
comment|/* packets from hw queues to host stack */
name|enum
name|txrx
name|t
decl_stmt|;
comment|/* 	 * In order to avoid nested locks, we need to "double check" 	 * txsync and rxsync if we decide to do a selrecord(). 	 * retry_tx (and retry_rx, later) prevent looping forever. 	 */
name|int
name|retry_tx
init|=
literal|1
decl_stmt|,
name|retry_rx
init|=
literal|1
decl_stmt|;
comment|/* transparent mode: send_down is 1 if we have found some 	 * packets to forward during the rx scan and we have not 	 * sent them down to the nic yet 	 */
name|int
name|send_down
init|=
literal|0
decl_stmt|;
name|mbq_init
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_nifp
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"No if registered"
argument_list|)
expr_stmt|;
return|return
name|POLLERR
return|;
block|}
name|mb
argument_list|()
expr_stmt|;
comment|/* make sure following reads are not from cache */
name|na
operator|=
name|priv
operator|->
name|np_na
expr_stmt|;
if|if
condition|(
operator|!
name|nm_netmap_on
argument_list|(
name|na
argument_list|)
condition|)
return|return
name|POLLERR
return|;
if|if
condition|(
name|netmap_verbose
operator|&
literal|0x8000
condition|)
name|D
argument_list|(
literal|"device %s events 0x%x"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|events
argument_list|)
expr_stmt|;
name|want_tx
operator|=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
name|want_rx
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
comment|/* 	 * check_all_{tx|rx} are set if the card has more than one queue AND 	 * the file descriptor is bound to all of them. If so, we sleep on 	 * the "global" selinfo, otherwise we sleep on individual selinfo 	 * (FreeBSD only allows two selinfo's per file descriptor). 	 * The interrupt routine in the driver wake one or the other 	 * (or both) depending on which clients are active. 	 * 	 * rxsync() is only called if we run out of buffers on a POLLIN. 	 * txsync() is called if we run out of buffers on POLLOUT, or 	 * there are pending packets to send. The latter can be disabled 	 * passing NETMAP_NO_TX_POLL in the NIOCREG call. 	 */
name|check_all_tx
operator|=
name|nm_si_user
argument_list|(
name|priv
argument_list|,
name|NR_TX
argument_list|)
expr_stmt|;
name|check_all_rx
operator|=
name|nm_si_user
argument_list|(
name|priv
argument_list|,
name|NR_RX
argument_list|)
expr_stmt|;
comment|/* 	 * We start with a lock free round which is cheap if we have 	 * slots available. If this fails, then lock and call the sync 	 * routines. 	 */
if|#
directive|if
literal|1
comment|/* new code- call rx if any of the ring needs to release or read buffers */
if|if
condition|(
name|want_tx
condition|)
block|{
name|t
operator|=
name|NR_TX
expr_stmt|;
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
init|;
name|want
index|[
name|t
index|]
operator|&&
name|i
operator|<
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
comment|/* XXX compare ring->cur and kring->tail */
if|if
condition|(
operator|!
name|nm_ring_empty
argument_list|(
name|kring
operator|->
name|ring
argument_list|)
condition|)
block|{
name|revents
operator||=
name|want
index|[
name|t
index|]
expr_stmt|;
name|want
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
block|}
if|if
condition|(
name|want_rx
condition|)
block|{
name|want_rx
operator|=
literal|0
expr_stmt|;
comment|/* look for a reason to run the handlers */
name|t
operator|=
name|NR_RX
expr_stmt|;
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
init|;
name|i
operator|<
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|cur
operator|==
name|kring
operator|->
name|ring
operator|->
name|tail
comment|/* try fetch new buffers */
operator|||
name|kring
operator|->
name|rhead
operator|!=
name|kring
operator|->
name|ring
operator|->
name|head
comment|/* release buffers */
condition|)
block|{
name|want_rx
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|want_rx
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
comment|/* we have data */
block|}
else|#
directive|else
comment|/* old code */
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
index|[
name|t
index|]
init|;
name|want
index|[
name|t
index|]
operator|&&
name|i
operator|<
name|priv
operator|->
name|np_qlast
index|[
name|t
index|]
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
comment|/* XXX compare ring->cur and kring->tail */
if|if
condition|(
operator|!
name|nm_ring_empty
argument_list|(
name|kring
operator|->
name|ring
argument_list|)
condition|)
block|{
name|revents
operator||=
name|want
index|[
name|t
index|]
expr_stmt|;
name|want
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
block|}
endif|#
directive|endif
comment|/* old code */
comment|/* 	 * If we want to push packets out (priv->np_txpoll) or 	 * want_tx is still set, we must issue txsync calls 	 * (on all rings, to avoid that the tx rings stall). 	 * XXX should also check cur != hwcur on the tx rings. 	 * Fortunately, normal tx mode has np_txpoll set. 	 */
if|if
condition|(
name|priv
operator|->
name|np_txpoll
operator|||
name|want_tx
condition|)
block|{
comment|/* 		 * The first round checks if anyone is ready, if not 		 * do a selrecord and another round to handle races. 		 * want_tx goes to 0 if any space is found, and is 		 * used to skip rings with no pending transmissions. 		 */
name|flush_tx
label|:
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
index|[
name|NR_TX
index|]
init|;
name|i
operator|<
name|priv
operator|->
name|np_qlast
index|[
name|NR_TX
index|]
condition|;
name|i
operator|++
control|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|ring
operator|=
name|kring
operator|->
name|ring
expr_stmt|;
if|if
condition|(
operator|!
name|send_down
operator|&&
operator|!
name|want_tx
operator|&&
name|ring
operator|->
name|cur
operator|==
name|kring
operator|->
name|nr_hwcur
condition|)
continue|continue;
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|,
literal|1
argument_list|,
operator|&
name|revents
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nm_txsync_prologue
argument_list|(
name|kring
argument_list|,
name|ring
argument_list|)
operator|>=
name|kring
operator|->
name|nkr_num_slots
condition|)
block|{
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|revents
operator||=
name|POLLERR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|kring
operator|->
name|nm_sync
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
else|else
name|nm_sync_finalize
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If we found new slots, notify potential 			 * listeners on the same ring. 			 * Since we just did a txsync, look at the copies 			 * of cur,tail in the kring. 			 */
name|found
operator|=
name|kring
operator|->
name|rcur
operator|!=
name|kring
operator|->
name|rtail
expr_stmt|;
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
comment|/* notify other listeners */
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
name|kring
operator|->
name|nm_notify
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if there were any packet to forward we must have handled them by now */
name|send_down
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|want_tx
operator|&&
name|retry_tx
operator|&&
name|sr
condition|)
block|{
name|nm_os_selrecord
argument_list|(
name|sr
argument_list|,
name|check_all_tx
condition|?
operator|&
name|na
operator|->
name|si
index|[
name|NR_TX
index|]
else|:
operator|&
name|na
operator|->
name|tx_rings
index|[
name|priv
operator|->
name|np_qfirst
index|[
name|NR_TX
index|]
index|]
operator|.
name|si
argument_list|)
expr_stmt|;
name|retry_tx
operator|=
literal|0
expr_stmt|;
goto|goto
name|flush_tx
goto|;
block|}
block|}
comment|/* 	 * If want_rx is still set scan receive rings. 	 * Do it on all rings because otherwise we starve. 	 */
if|if
condition|(
name|want_rx
condition|)
block|{
comment|/* two rounds here for race avoidance */
name|do_retry_rx
label|:
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
index|[
name|NR_RX
index|]
init|;
name|i
operator|<
name|priv
operator|->
name|np_qlast
index|[
name|NR_RX
index|]
condition|;
name|i
operator|++
control|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|ring
operator|=
name|kring
operator|->
name|ring
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|,
literal|1
argument_list|,
operator|&
name|revents
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nm_rxsync_prologue
argument_list|(
name|kring
argument_list|,
name|ring
argument_list|)
operator|>=
name|kring
operator|->
name|nkr_num_slots
condition|)
block|{
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|revents
operator||=
name|POLLERR
expr_stmt|;
block|}
comment|/* now we can use kring->rcur, rtail */
comment|/* 			 * transparent mode support: collect packets 			 * from the rxring(s). 			 */
if|if
condition|(
name|nm_may_forward_up
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|ND
argument_list|(
literal|10
argument_list|,
literal|"forwarding some buffers up %d to %d"
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|netmap_grab_packets
argument_list|(
name|kring
argument_list|,
operator|&
name|q
argument_list|,
name|netmap_fwd
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|nr_kflags
operator|&=
operator|~
name|NR_FORWARD
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nm_sync
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
else|else
name|nm_sync_finalize
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|send_down
operator||=
operator|(
name|kring
operator|->
name|nr_kflags
operator|&
name|NR_FORWARD
operator|)
expr_stmt|;
comment|/* host ring only */
if|if
condition|(
name|netmap_no_timestamp
operator|==
literal|0
operator|||
name|ring
operator|->
name|flags
operator|&
name|NR_TIMESTAMP
condition|)
block|{
name|microtime
argument_list|(
operator|&
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
name|found
operator|=
name|kring
operator|->
name|rcur
operator|!=
name|kring
operator|->
name|rtail
expr_stmt|;
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
name|retry_rx
operator|=
literal|0
expr_stmt|;
name|kring
operator|->
name|nm_notify
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|retry_rx
operator|&&
name|sr
condition|)
block|{
name|nm_os_selrecord
argument_list|(
name|sr
argument_list|,
name|check_all_rx
condition|?
operator|&
name|na
operator|->
name|si
index|[
name|NR_RX
index|]
else|:
operator|&
name|na
operator|->
name|rx_rings
index|[
name|priv
operator|->
name|np_qfirst
index|[
name|NR_RX
index|]
index|]
operator|.
name|si
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|send_down
operator|>
literal|0
operator|||
name|retry_rx
condition|)
block|{
name|retry_rx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|send_down
condition|)
goto|goto
name|flush_tx
goto|;
comment|/* and retry_rx */
else|else
goto|goto
name|do_retry_rx
goto|;
block|}
block|}
comment|/* 	 * Transparent mode: marked bufs on rx rings between 	 * kring->nr_hwcur and ring->head 	 * are passed to the other endpoint. 	 * 	 * Transparent mode requires to bind all  	 * rings to a single file descriptor. 	 */
if|if
condition|(
name|q
operator|.
name|head
operator|&&
operator|!
name|nm_kr_tryget
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|na
operator|->
name|num_tx_rings
index|]
argument_list|,
literal|1
argument_list|,
operator|&
name|revents
argument_list|)
condition|)
block|{
name|netmap_send_up
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
operator|&
name|q
argument_list|)
expr_stmt|;
name|nm_kr_put
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|na
operator|->
name|num_tx_rings
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|revents
operator|)
return|;
undef|#
directive|undef
name|want_tx
undef|#
directive|undef
name|want_rx
block|}
end_function

begin_comment
comment|/*-------------------- driver support routines -------------------*/
end_comment

begin_comment
comment|/* default notify callback */
end_comment

begin_function
specifier|static
name|int
name|netmap_notify
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|enum
name|txrx
name|t
init|=
name|kring
operator|->
name|tx
decl_stmt|;
name|nm_os_selwakeup
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
comment|/* optimization: avoid a wake up on the global 	 * queue if nobody has registered for more 	 * than one ring 	 */
if|if
condition|(
name|na
operator|->
name|si_users
index|[
name|t
index|]
operator|>
literal|0
condition|)
name|nm_os_selwakeup
argument_list|(
operator|&
name|na
operator|->
name|si
index|[
name|t
index|]
argument_list|)
expr_stmt|;
return|return
name|NM_IRQ_COMPLETED
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int netmap_notify(struct netmap_adapter *na, u_int n_ring, enum txrx tx, int flags) { 	if (tx == NR_TX) { 		KeSetEvent(notes->TX_EVENT, 0, FALSE); 	} 	else 	{ 		KeSetEvent(notes->RX_EVENT, 0, FALSE); 	} 	return 0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* called by all routines that create netmap_adapters.  * provide some defaults and get a reference to the  * memory allocator  */
end_comment

begin_function
name|int
name|netmap_attach_common
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|==
literal|0
operator|||
name|na
operator|->
name|num_rx_rings
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"%s: invalid rings tx %d rx %d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|na
operator|->
name|num_tx_rings
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_HOST_RINGS
operator|&&
name|na
operator|->
name|ifp
condition|)
block|{
name|na
operator|->
name|if_input
operator|=
name|na
operator|->
name|ifp
operator|->
name|if_input
expr_stmt|;
comment|/* for netmap_send_up */
block|}
endif|#
directive|endif
comment|/* __FreeBSD__ */
if|if
condition|(
name|na
operator|->
name|nm_krings_create
operator|==
name|NULL
condition|)
block|{
comment|/* we assume that we have been called by a driver, 		 * since other port types all provide their own 		 * nm_krings_create 		 */
name|na
operator|->
name|nm_krings_create
operator|=
name|netmap_hw_krings_create
expr_stmt|;
name|na
operator|->
name|nm_krings_delete
operator|=
name|netmap_hw_krings_delete
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|nm_notify
operator|==
name|NULL
condition|)
name|na
operator|->
name|nm_notify
operator|=
name|netmap_notify
expr_stmt|;
name|na
operator|->
name|active_fds
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_mem
operator|==
name|NULL
condition|)
comment|/* use the global allocator */
name|na
operator|->
name|nm_mem
operator|=
operator|&
name|nm_mem
expr_stmt|;
name|netmap_mem_get
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WITH_VALE
if|if
condition|(
name|na
operator|->
name|nm_bdg_attach
operator|==
name|NULL
condition|)
comment|/* no special nm_bdg_attach callback. On VALE 		 * attach, we need to interpose a bwrap 		 */
name|na
operator|->
name|nm_bdg_attach
operator|=
name|netmap_bwrap_attach
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* standard cleanup, called by all destructors */
end_comment

begin_function
name|void
name|netmap_detach_common
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
if|if
condition|(
name|na
operator|->
name|tx_rings
condition|)
block|{
comment|/* XXX should not happen */
name|D
argument_list|(
literal|"freeing leftover tx_rings"
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
name|netmap_pipe_dealloc
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_mem
condition|)
name|netmap_mem_put
argument_list|(
name|na
operator|->
name|nm_mem
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|na
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|na
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper for the register callback provided netmap-enabled  * hardware drivers.  * nm_iszombie(na) means that the driver module has been  * unloaded, so we cannot call into it.  * nm_os_ifnet_lock() must guarantee mutual exclusion with  * module unloading.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_hw_reg
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|netmap_hw_adapter
modifier|*
name|hwna
init|=
operator|(
expr|struct
name|netmap_hw_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|nm_os_ifnet_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|nm_iszombie
argument_list|(
name|na
argument_list|)
condition|)
block|{
if|if
condition|(
name|onoff
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|na
operator|!=
name|NULL
condition|)
block|{
name|na
operator|->
name|na_flags
operator|&=
operator|~
name|NAF_NETMAP_ON
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|hwna
operator|->
name|nm_hw_register
argument_list|(
name|na
argument_list|,
name|onoff
argument_list|)
expr_stmt|;
name|out
label|:
name|nm_os_ifnet_unlock
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_hw_dtor
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
if|if
condition|(
name|nm_iszombie
argument_list|(
name|na
argument_list|)
operator|||
name|na
operator|->
name|ifp
operator|==
name|NULL
condition|)
return|return;
name|WNA
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a ``netmap_adapter`` object, and initialize it from the  * 'arg' passed by the driver on attach.  * We allocate a block of memory with room for a struct netmap_adapter  * plus two sets of N+2 struct netmap_kring (where N is the number  * of hardware rings):  * krings	0..N-1	are for the hardware queues.  * kring	N	is for the host stack queue  * kring	N+1	is only used for the selinfo for all queues. // XXX still true ?  * Return 0 on success, ENOMEM otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|_netmap_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|arg
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|netmap_hw_adapter
modifier|*
name|hwna
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
name|arg
operator|->
name|ifp
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|ifp
operator|=
name|arg
operator|->
name|ifp
expr_stmt|;
name|hwna
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwna
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|hwna
operator|->
name|up
operator|=
operator|*
name|arg
expr_stmt|;
name|hwna
operator|->
name|up
operator|.
name|na_flags
operator||=
name|NAF_HOST_RINGS
operator||
name|NAF_NATIVE
expr_stmt|;
name|strncpy
argument_list|(
name|hwna
operator|->
name|up
operator|.
name|name
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|hwna
operator|->
name|up
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|hwna
operator|->
name|nm_hw_register
operator|=
name|hwna
operator|->
name|up
operator|.
name|nm_register
expr_stmt|;
name|hwna
operator|->
name|up
operator|.
name|nm_register
operator|=
name|netmap_hw_reg
expr_stmt|;
if|if
condition|(
name|netmap_attach_common
argument_list|(
operator|&
name|hwna
operator|->
name|up
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|hwna
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|netmap_adapter_get
argument_list|(
operator|&
name|hwna
operator|->
name|up
argument_list|)
expr_stmt|;
name|NM_ATTACH_NA
argument_list|(
name|ifp
argument_list|,
operator|&
name|hwna
operator|->
name|up
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|linux
if|if
condition|(
name|ifp
operator|->
name|netdev_ops
condition|)
block|{
comment|/* prepare a clone of the netdev ops */
ifndef|#
directive|ifndef
name|NETMAP_LINUX_HAVE_NETDEV_OPS
name|hwna
operator|->
name|nm_ndo
operator|.
name|ndo_start_xmit
operator|=
name|ifp
operator|->
name|netdev_ops
expr_stmt|;
else|#
directive|else
name|hwna
operator|->
name|nm_ndo
operator|=
operator|*
name|ifp
operator|->
name|netdev_ops
expr_stmt|;
endif|#
directive|endif
comment|/* NETMAP_LINUX_HAVE_NETDEV_OPS */
block|}
name|hwna
operator|->
name|nm_ndo
operator|.
name|ndo_start_xmit
operator|=
name|linux_netmap_start_xmit
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|ethtool_ops
condition|)
block|{
name|hwna
operator|->
name|nm_eto
operator|=
operator|*
name|ifp
operator|->
name|ethtool_ops
expr_stmt|;
block|}
name|hwna
operator|->
name|nm_eto
operator|.
name|set_ringparam
operator|=
name|linux_netmap_set_ringparam
expr_stmt|;
ifdef|#
directive|ifdef
name|NETMAP_LINUX_HAVE_SET_CHANNELS
name|hwna
operator|->
name|nm_eto
operator|.
name|set_channels
operator|=
name|linux_netmap_set_channels
expr_stmt|;
endif|#
directive|endif
comment|/* NETMAP_LINUX_HAVE_SET_CHANNELS */
if|if
condition|(
name|arg
operator|->
name|nm_config
operator|==
name|NULL
condition|)
block|{
name|hwna
operator|->
name|up
operator|.
name|nm_config
operator|=
name|netmap_linux_config
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* linux */
if|if
condition|(
name|arg
operator|->
name|nm_dtor
operator|==
name|NULL
condition|)
block|{
name|hwna
operator|->
name|up
operator|.
name|nm_dtor
operator|=
name|netmap_hw_dtor
expr_stmt|;
block|}
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"netmap queues/slots: TX %d/%d, RX %d/%d\n"
argument_list|,
name|hwna
operator|->
name|up
operator|.
name|num_tx_rings
argument_list|,
name|hwna
operator|->
name|up
operator|.
name|num_tx_desc
argument_list|,
name|hwna
operator|->
name|up
operator|.
name|num_rx_rings
argument_list|,
name|hwna
operator|->
name|up
operator|.
name|num_rx_desc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|D
argument_list|(
literal|"fail, arg %p ifp %p na %p"
argument_list|,
name|arg
argument_list|,
name|ifp
argument_list|,
name|hwna
argument_list|)
expr_stmt|;
return|return
operator|(
name|hwna
condition|?
name|EINVAL
else|:
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
name|int
name|netmap_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|_netmap_attach
argument_list|(
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_hw_adapter
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_PTNETMAP_GUEST
end_ifdef

begin_function
name|int
name|netmap_pt_guest_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|csb
parameter_list|,
name|unsigned
name|int
name|nifp_offset
parameter_list|,
name|unsigned
name|int
name|memid
parameter_list|)
block|{
name|struct
name|netmap_pt_guest_adapter
modifier|*
name|ptna
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|arg
condition|?
name|arg
operator|->
name|ifp
else|:
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* get allocator */
name|arg
operator|->
name|nm_mem
operator|=
name|netmap_mem_pt_guest_new
argument_list|(
name|ifp
argument_list|,
name|nifp_offset
argument_list|,
name|memid
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|nm_mem
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|arg
operator|->
name|na_flags
operator||=
name|NAF_MEM_OWNER
expr_stmt|;
name|error
operator|=
name|_netmap_attach
argument_list|(
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_pt_guest_adapter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* get the netmap_pt_guest_adapter */
name|ptna
operator|=
operator|(
expr|struct
name|netmap_pt_guest_adapter
operator|*
operator|)
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ptna
operator|->
name|csb
operator|=
name|csb
expr_stmt|;
comment|/* Initialize a separate pass-through netmap adapter that is going to 	 * be used by the ptnet driver only, and so never exposed to netmap          * applications. We only need a subset of the available fields. */
name|memset
argument_list|(
operator|&
name|ptna
operator|->
name|dr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ptna
operator|->
name|dr
argument_list|)
argument_list|)
expr_stmt|;
name|ptna
operator|->
name|dr
operator|.
name|up
operator|.
name|ifp
operator|=
name|ifp
expr_stmt|;
name|ptna
operator|->
name|dr
operator|.
name|up
operator|.
name|nm_mem
operator|=
name|ptna
operator|->
name|hwup
operator|.
name|up
operator|.
name|nm_mem
expr_stmt|;
name|netmap_mem_get
argument_list|(
name|ptna
operator|->
name|dr
operator|.
name|up
operator|.
name|nm_mem
argument_list|)
expr_stmt|;
name|ptna
operator|->
name|dr
operator|.
name|up
operator|.
name|nm_config
operator|=
name|ptna
operator|->
name|hwup
operator|.
name|up
operator|.
name|nm_config
expr_stmt|;
name|ptna
operator|->
name|backend_regifs
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_PTNETMAP_GUEST */
end_comment

begin_function
name|void
name|NM_DBG
function|(
name|netmap_adapter_get
function|)
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
if|if
condition|(
operator|!
name|na
condition|)
block|{
return|return;
block|}
name|refcount_acquire
argument_list|(
operator|&
name|na
operator|->
name|na_refcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* returns 1 iff the netmap_adapter is destroyed */
end_comment

begin_function
name|int
name|NM_DBG
function|(
name|netmap_adapter_put
function|)
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
if|if
condition|(
operator|!
name|na
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|refcount_release
argument_list|(
operator|&
name|na
operator|->
name|na_refcount
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|na
operator|->
name|nm_dtor
condition|)
name|na
operator|->
name|nm_dtor
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|netmap_detach_common
argument_list|(
name|na
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* nm_krings_create callback for all hardware native adapters */
end_comment

begin_function
name|int
name|netmap_hw_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|int
name|ret
init|=
name|netmap_krings_create
argument_list|(
name|na
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* initialize the mbq for the sw rx ring */
name|mbq_safe_init
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
operator|.
name|rx_queue
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"initialized sw rx queue %d"
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Called on module unload by the netmap-enabled drivers  */
end_comment

begin_function
name|void
name|netmap_detach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|na
condition|)
return|return;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|netmap_set_all_rings
argument_list|(
name|na
argument_list|,
name|NM_KR_LOCKED
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_flags
operator||=
name|NAF_ZOMBIE
expr_stmt|;
comment|/* 	 * if the netmap adapter is not native, somebody 	 * changed it, so we can not release it here. 	 * The NAF_ZOMBIE flag will notify the new owner that 	 * the driver is gone. 	 */
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_NATIVE
condition|)
block|{
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
comment|/* give active users a chance to notice that NAF_ZOMBIE has been 	 * turned on, so that they can stop and return an error to userspace. 	 * Note that this becomes a NOP if there are no active users and, 	 * therefore, the put() above has deleted the na, since now NA(ifp) is 	 * NULL. 	 */
name|netmap_enable_all_rings
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Intercept packets from the network stack and pass them  * to netmap as incoming packets on the 'software' ring.  *  * We only store packets in a bounded mbq and then copy them  * in the relevant rxsync routine.  *  * We rely on the OS to make sure that the ifp and na do not go  * away (typically the caller checks for IFF_DRV_RUNNING or the like).  * In nm_register() or whenever there is a reinitialization,  * we make sure to make the mode change visible here.  */
end_comment

begin_function
name|int
name|netmap_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|,
modifier|*
name|tx_kring
decl_stmt|;
name|u_int
name|len
init|=
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|u_int
name|error
init|=
name|ENOBUFS
decl_stmt|;
name|unsigned
name|int
name|txr
decl_stmt|;
name|struct
name|mbq
modifier|*
name|q
decl_stmt|;
name|int
name|space
decl_stmt|;
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
expr_stmt|;
comment|// XXX [Linux] we do not need this lock
comment|// if we follow the down/configure/up protocol -gl
comment|// mtx_lock(&na->core_lock);
if|if
condition|(
operator|!
name|nm_netmap_on
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"%s not in netmap mode anymore"
argument_list|,
name|na
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|txr
operator|=
name|MBUF_TXQ
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|>=
name|na
operator|->
name|num_tx_rings
condition|)
block|{
name|txr
operator|%=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
block|}
name|tx_kring
operator|=
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|NR_TX
argument_list|)
index|[
name|txr
index|]
expr_stmt|;
if|if
condition|(
name|tx_kring
operator|->
name|nr_mode
operator|==
name|NKR_NETMAP_OFF
condition|)
block|{
return|return
name|MBUF_TRANSMIT
argument_list|(
name|na
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
return|;
block|}
name|q
operator|=
operator|&
name|kring
operator|->
name|rx_queue
expr_stmt|;
comment|// XXX reconsider long packets if we handle fragments
if|if
condition|(
name|len
operator|>
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
condition|)
block|{
comment|/* too long for us */
name|D
argument_list|(
literal|"%s from_host, drop packet size %d> %d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|len
argument_list|,
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|nm_os_mbuf_has_offld
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|RD
argument_list|(
literal|1
argument_list|,
literal|"%s drop mbuf requiring offloadings"
argument_list|,
name|na
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* protect against rxsync_from_host(), netmap_sw_to_nic() 	 * and maybe other instances of netmap_transmit (the latter 	 * not possible on Linux). 	 * Also avoid overflowing the queue. 	 */
name|mbq_lock
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|space
operator|=
name|kring
operator|->
name|nr_hwtail
operator|-
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|space
operator|<
literal|0
condition|)
name|space
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
if|if
condition|(
name|space
operator|+
name|mbq_len
argument_list|(
name|q
argument_list|)
operator|>=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
condition|)
block|{
comment|// XXX
name|RD
argument_list|(
literal|10
argument_list|,
literal|"%s full hwcur %d hwtail %d qlen %d len %d m %p"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|mbq_len
argument_list|(
name|q
argument_list|)
argument_list|,
name|len
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mbq_enqueue
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|10
argument_list|,
literal|"%s %d bufs in queue len %d m %p"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|mbq_len
argument_list|(
name|q
argument_list|)
argument_list|,
name|len
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* notify outside the lock */
name|m
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|mbq_unlock
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* unconditionally wake up listeners */
name|kring
operator|->
name|nm_notify
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* this is normally netmap_notify(), but for nics 	 * connected to a bridge it is netmap_bwrap_intr_notify(), 	 * that possibly forwards the frames through the switch 	 */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * netmap_reset() is called by the driver routines when reinitializing  * a ring. The driver is in charge of locking to protect the kring.  * If native netmap mode is not set just return NULL.  * If native netmap mode is set, in particular, we have to set nr_mode to  * NKR_NETMAP_ON.  */
end_comment

begin_function
name|struct
name|netmap_slot
modifier|*
name|netmap_reset
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|enum
name|txrx
name|tx
parameter_list|,
name|u_int
name|n
parameter_list|,
name|u_int
name|new_cur
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|int
name|new_hwofs
decl_stmt|,
name|lim
decl_stmt|;
if|if
condition|(
operator|!
name|nm_native_on
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|ND
argument_list|(
literal|"interface not in native netmap mode"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* nothing to reinitialize */
block|}
comment|/* XXX note- in the new scheme, we are not guaranteed to be 	 * under lock (e.g. when called on a device reset). 	 * In this case, we should set a flag and do not trust too 	 * much the values. In practice: TODO 	 * - set a RESET flag somewhere in the kring 	 * - do the processing in a conservative way 	 * - let the *sync() fixup at the end. 	 */
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|na
operator|->
name|num_tx_rings
condition|)
return|return
name|NULL
return|;
name|kring
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|n
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_pending_mode
operator|==
name|NKR_NETMAP_OFF
condition|)
block|{
name|kring
operator|->
name|nr_mode
operator|=
name|NKR_NETMAP_OFF
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|// XXX check whether we should use hwcur or rcur
name|new_hwofs
operator|=
name|kring
operator|->
name|nr_hwcur
operator|-
name|new_cur
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|n
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
return|return
name|NULL
return|;
name|kring
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|n
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_pending_mode
operator|==
name|NKR_NETMAP_OFF
condition|)
block|{
name|kring
operator|->
name|nr_mode
operator|=
name|NKR_NETMAP_OFF
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|new_hwofs
operator|=
name|kring
operator|->
name|nr_hwtail
operator|-
name|new_cur
expr_stmt|;
block|}
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new_hwofs
operator|>
name|lim
condition|)
name|new_hwofs
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
comment|/* Always set the new offset value and realign the ring. */
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s %s%d hwofs %d -> %d, hwtail %d -> %d"
argument_list|,
name|na
operator|->
name|name
argument_list|,
name|tx
operator|==
name|NR_TX
condition|?
literal|"TX"
else|:
literal|"RX"
argument_list|,
name|n
argument_list|,
name|kring
operator|->
name|nkr_hwofs
argument_list|,
name|new_hwofs
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|tx
operator|==
name|NR_TX
condition|?
name|lim
else|:
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nkr_hwofs
operator|=
name|new_hwofs
expr_stmt|;
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
block|{
name|kring
operator|->
name|nr_hwtail
operator|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|lim
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwtail
operator|>
name|lim
condition|)
name|kring
operator|->
name|nr_hwtail
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|// def linux
comment|/* XXX check that the mappings are correct */
comment|/* need ring_nr, adapter->pdev, direction */
block|buffer_info->dma = dma_map_single(&pdev->dev, addr, adapter->rx_buffer_len, DMA_FROM_DEVICE); 	if (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)) { 		D("error mapping rx netmap buffer %d", i);
comment|// XXX fix error handling
block|}
endif|#
directive|endif
comment|/* linux */
comment|/* 	 * Wakeup on the individual and global selwait 	 * We do the wakeup here, but the ring is not yet reconfigured. 	 * However, we are under lock so there are no races. 	 */
name|kring
operator|->
name|nr_mode
operator|=
name|NKR_NETMAP_ON
expr_stmt|;
name|kring
operator|->
name|nm_notify
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|kring
operator|->
name|ring
operator|->
name|slot
return|;
block|}
end_function

begin_comment
comment|/*  * Dispatch rx/tx interrupts to the netmap rings.  *  * "work_done" is non-null on the RX path, NULL for the TX path.  * We rely on the OS to make sure that there is only one active  * instance per queue, and that there is appropriate locking.  *  * The 'notify' routine depends on what the ring is attached to.  * - for a netmap file descriptor, do a selwakeup on the individual  *   waitqueue, plus one on the global one if needed  *   (see netmap_notify)  * - for a nic connected to a switch, call the proper forwarding routine  *   (see netmap_bwrap_intr_notify)  */
end_comment

begin_function
name|int
name|netmap_common_irq
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|q
parameter_list|,
name|u_int
modifier|*
name|work_done
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|enum
name|txrx
name|t
init|=
operator|(
name|work_done
condition|?
name|NR_RX
else|:
name|NR_TX
operator|)
decl_stmt|;
name|q
operator|&=
name|NETMAP_RING_MASK
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"received %s queue %d"
argument_list|,
name|work_done
condition|?
literal|"RX"
else|:
literal|"TX"
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|>=
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|NM_IRQ_PASS
return|;
comment|// not a physical queue
name|kring
operator|=
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
operator|+
name|q
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_mode
operator|==
name|NKR_NETMAP_OFF
condition|)
block|{
return|return
name|NM_IRQ_PASS
return|;
block|}
if|if
condition|(
name|t
operator|==
name|NR_RX
condition|)
block|{
name|kring
operator|->
name|nr_kflags
operator||=
name|NKR_PENDINTR
expr_stmt|;
comment|// XXX atomic ?
operator|*
name|work_done
operator|=
literal|1
expr_stmt|;
comment|/* do not fire napi again */
block|}
return|return
name|kring
operator|->
name|nm_notify
argument_list|(
name|kring
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Default functions to handle rx/tx interrupts from a physical device.  * "work_done" is non-null on the RX path, NULL for the TX path.  *  * If the card is not in netmap mode, simply return NM_IRQ_PASS,  * so that the caller proceeds with regular processing.  * Otherwise call netmap_common_irq().  *  * If the card is connected to a netmap file descriptor,  * do a selwakeup on the individual queue, plus one on the global one  * if needed (multiqueue card _and_ there are multiqueue listeners),  * and return NR_IRQ_COMPLETED.  *  * Finally, if called on rx from an interface connected to a switch,  * calls the proper forwarding routine.  */
end_comment

begin_function
name|int
name|netmap_rx_irq
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|q
parameter_list|,
name|u_int
modifier|*
name|work_done
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
comment|/* 	 * XXX emulated netmap mode sets NAF_SKIP_INTR so 	 * we still use the regular driver even though the previous 	 * check fails. It is unclear whether we should use 	 * nm_native_on() here. 	 */
if|if
condition|(
operator|!
name|nm_netmap_on
argument_list|(
name|na
argument_list|)
condition|)
return|return
name|NM_IRQ_PASS
return|;
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_SKIP_INTR
condition|)
block|{
name|ND
argument_list|(
literal|"use regular interrupt"
argument_list|)
expr_stmt|;
return|return
name|NM_IRQ_PASS
return|;
block|}
return|return
name|netmap_common_irq
argument_list|(
name|na
argument_list|,
name|q
argument_list|,
name|work_done
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Module loader and unloader  *  * netmap_init() creates the /dev/netmap device and initializes  * all global variables. Returns 0 on success, errno on failure  * (but there is no chance)  *  * netmap_fini() destroys everything.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|netmap_dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* /dev/netmap character device. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|cdevsw
name|netmap_cdevsw
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|netmap_fini
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|netmap_dev
condition|)
name|destroy_dev
argument_list|(
name|netmap_dev
argument_list|)
expr_stmt|;
comment|/* we assume that there are no longer netmap users */
name|nm_os_ifnet_fini
argument_list|()
expr_stmt|;
name|netmap_uninit_bridges
argument_list|()
expr_stmt|;
name|netmap_mem_fini
argument_list|()
expr_stmt|;
name|NMG_LOCK_DESTROY
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"netmap: unloaded module.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|netmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|NMG_LOCK_INIT
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_mem_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * MAKEDEV_ETERNAL_KLD avoids an expensive check on syscalls 	 * when the module is compiled in. 	 * XXX could use make_dev_credv() to get error number 	 */
name|netmap_dev
operator|=
name|make_dev_credf
argument_list|(
name|MAKEDEV_ETERNAL_KLD
argument_list|,
operator|&
name|netmap_cdevsw
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"netmap"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netmap_dev
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|netmap_init_bridges
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|nm_os_vi_init_index
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|nm_os_ifnet_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|printf
argument_list|(
literal|"netmap: loaded module\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|netmap_fini
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* may be incorrect */
block|}
end_function

end_unit

