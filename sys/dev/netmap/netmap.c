begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011-2013 Matteo Landi, Luigi Rizzo. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_define
define|#
directive|define
name|NM_BRIDGE
end_define

begin_comment
comment|/*  * This module supports memory mapped access to network devices,  * see netmap(4).  *  * The module uses a large, memory pool allocated by the kernel  * and accessible as mmapped memory by multiple userspace threads/processes.  * The memory pool contains packet buffers and "netmap rings",  * i.e. user-accessible copies of the interface's queues.  *  * Access to the network card works like this:  * 1. a process/thread issues one or more open() on /dev/netmap, to create  *    select()able file descriptor on which events are reported.  * 2. on each descriptor, the process issues an ioctl() to identify  *    the interface that should report events to the file descriptor.  * 3. on each descriptor, the process issues an mmap() request to  *    map the shared memory region within the process' address space.  *    The list of interesting queues is indicated by a location in  *    the shared memory region.  * 4. using the functions in the netmap(4) userspace API, a process  *    can look up the occupation state of a queue, access memory buffers,  *    and retrieve received packets or enqueue packets to transmit.  * 5. using some ioctl()s the process can synchronize the userspace view  *    of the queue with the actual status in the kernel. This includes both  *    receiving the notification of new packets, and transmitting new  *    packets on the output interface.  * 6. select() or poll() can be used to wait for events on individual  *    transmit or receive queues (or all queues for a given interface).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_include
include|#
directive|include
file|"bsd_glue.h"
end_include

begin_function_decl
specifier|static
name|netdev_tx_t
name|linux_netmap_start
parameter_list|(
name|struct
name|sk_buff
modifier|*
name|skb
parameter_list|,
name|struct
name|net_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* linux */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__APPLE__
end_ifdef

begin_include
include|#
directive|include
file|"osx_glue.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __APPLE__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* defines used in kernel.h */
end_comment

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* types used in module initialization */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_comment
comment|/* cdevsw struct */
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_comment
comment|/* uio struct */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_comment
comment|/* struct socket */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_comment
comment|/* PROT_EXEC */
end_comment

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* vtophys */
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* vtophys */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/* BIOCIMMEDIATE */
end_comment

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETMAP
argument_list|,
literal|"netmap"
argument_list|,
literal|"Network memory map"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_comment
comment|/* XXX the following variables must be deprecated and included in nm_mem */
end_comment

begin_decl_stmt
name|u_int
name|netmap_total_buffers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|netmap_buf_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|netmap_buffer_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address of an invalid buffer */
end_comment

begin_comment
comment|/* user-controlled variables */
end_comment

begin_decl_stmt
name|int
name|netmap_verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|netmap_no_timestamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't timestamp on rxsync */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_dev
argument_list|,
name|OID_AUTO
argument_list|,
name|netmap
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Netmap args"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_verbose
argument_list|,
literal|0
argument_list|,
literal|"Verbose mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_timestamp
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_no_timestamp
argument_list|,
literal|0
argument_list|,
literal|"no_timestamp"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_mitigate
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|mitigate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_mitigate
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_no_pendintr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|no_pendintr
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_no_pendintr
argument_list|,
literal|0
argument_list|,
literal|"Always look for new received packets."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_txsync_retry
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|txsync_retry
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_txsync_retry
argument_list|,
literal|0
argument_list|,
literal|"Number of txsync loops in bridge's flush."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|netmap_drop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debugging */
end_comment

begin_decl_stmt
name|int
name|netmap_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flags */
end_comment

begin_decl_stmt
name|int
name|netmap_fwd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* force transparent mode */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|drop
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_drop
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|flags
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_flags
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|fwd
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_fwd
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NM_BRIDGE
end_ifdef

begin_comment
comment|/* support for netmap virtual switch, called VALE */
end_comment

begin_comment
comment|/*  * system parameters (most of them in netmap_kern.h)  * NM_NAME	prefix for switch port names, default "vale"  * NM_MAXPORTS	number of ports  * NM_BRIDGES	max number of switches in the system.  *	XXX should become a sysctl or tunable  *  * Switch ports are named valeX:Y where X is the switch name and Y  * is the port. If Y matches a physical interface name, the port is  * connected to a physical device.  *  * Unlike physical interfaces, switch ports use their own memory region  * for rings and buffers.  * The virtual interfaces use per-queue lock instead of core lock.  * In the tx loop, we aggregate traffic in batches to make all operations  * faster. The batch size is NM_BDG_BATCH  */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_MAXRINGS
value|16
end_define

begin_comment
comment|/* XXX unclear how many. */
end_comment

begin_define
define|#
directive|define
name|NM_BRIDGE_RINGSIZE
value|1024
end_define

begin_comment
comment|/* in the device */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_HASH
value|1024
end_define

begin_comment
comment|/* forwarding table entries */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_BATCH
value|1024
end_define

begin_comment
comment|/* entries in the forwarding buffer */
end_comment

begin_define
define|#
directive|define
name|NM_BRIDGES
value|8
end_define

begin_comment
comment|/* number of bridges */
end_comment

begin_decl_stmt
name|int
name|netmap_bridge
init|=
name|NM_BDG_BATCH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bridge batch size */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|bridge
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netmap_bridge
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_define
define|#
directive|define
name|refcount_acquire
parameter_list|(
name|_a
parameter_list|)
value|atomic_add(1, (atomic_t *)_a)
end_define

begin_define
define|#
directive|define
name|refcount_release
parameter_list|(
name|_a
parameter_list|)
value|atomic_dec_and_test((atomic_t *)_a)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !linux */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_define
define|#
directive|define
name|prefetch
parameter_list|(
name|x
parameter_list|)
value|__builtin_prefetch(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !linux */
end_comment

begin_comment
comment|/*  * These are used to handle reference counters for bridge ports.  */
end_comment

begin_define
define|#
directive|define
name|ADD_BDG_REF
parameter_list|(
name|ifp
parameter_list|)
value|refcount_acquire(&NA(ifp)->na_bdg_refcount)
end_define

begin_define
define|#
directive|define
name|DROP_BDG_REF
parameter_list|(
name|ifp
parameter_list|)
value|refcount_release(&NA(ifp)->na_bdg_refcount)
end_define

begin_function_decl
specifier|static
name|void
name|bdg_netmap_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bdg_netmap_reg
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|onoff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kern_netmap_regif
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* per-tx-queue entry */
end_comment

begin_struct
struct|struct
name|nm_bdg_fwd
block|{
comment|/* forwarding entry for a bridge */
name|void
modifier|*
name|ft_buf
decl_stmt|;
name|uint16_t
name|_ft_dst
decl_stmt|;
comment|/* dst port, unused */
name|uint16_t
name|ft_flags
decl_stmt|;
comment|/* flags, e.g. indirect */
name|uint16_t
name|ft_len
decl_stmt|;
comment|/* src len */
name|uint16_t
name|ft_next
decl_stmt|;
comment|/* next packet to same destination */
block|}
struct|;
end_struct

begin_comment
comment|/* We need to build a list of buffers going to each destination.  * Each buffer is in one entry of struct nm_bdg_fwd, we use ft_next  * to build the list, and struct nm_bdg_q below for the queue.  * The structure should compact because potentially we have a lot  * of destinations.  */
end_comment

begin_struct
struct|struct
name|nm_bdg_q
block|{
name|uint16_t
name|bq_head
decl_stmt|;
name|uint16_t
name|bq_tail
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nm_hash_ent
block|{
name|uint64_t
name|mac
decl_stmt|;
comment|/* the top 2 bytes are the epoch */
name|uint64_t
name|ports
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Interfaces for a bridge are all in bdg_ports[].  * The array has fixed size, an empty entry does not terminate  * the search. But lookups only occur on attach/detach so we  * don't mind if they are slow.  *  * The bridge is non blocking on the transmit ports.  *  * bdg_lock protects accesses to the bdg_ports array.  * This is a rw lock (or equivalent).  */
end_comment

begin_struct
struct|struct
name|nm_bridge
block|{
name|int
name|namelen
decl_stmt|;
comment|/* 0 means free */
comment|/* XXX what is the proper alignment/layout ? */
name|NM_RWLOCK_T
name|bdg_lock
decl_stmt|;
comment|/* protects bdg_ports */
name|struct
name|netmap_adapter
modifier|*
name|bdg_ports
index|[
name|NM_BDG_MAXPORTS
index|]
decl_stmt|;
name|char
name|basename
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
comment|/* 	 * The function to decide the destination port. 	 * It returns either of an index of the destination port, 	 * NM_BDG_BROADCAST to broadcast this packet, or NM_BDG_NOPORT not to 	 * forward this packet.  ring_nr is the source ring index, and the 	 * function may overwrite this value to forward this packet to a 	 * different ring index. 	 * This function must be set by netmap_bdgctl(). 	 */
name|bdg_lookup_fn_t
name|nm_bdg_lookup
decl_stmt|;
comment|/* the forwarding table, MAC+ports */
name|struct
name|nm_hash_ent
name|ht
index|[
name|NM_BDG_HASH
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|nm_bridge
name|nm_bridges
index|[
name|NM_BRIDGES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NM_LOCK_T
name|netmap_bridge_mutex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* other OS will have these macros defined in their own glue code. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|BDG_LOCK
parameter_list|()
value|mtx_lock(&netmap_bridge_mutex)
end_define

begin_define
define|#
directive|define
name|BDG_UNLOCK
parameter_list|()
value|mtx_unlock(&netmap_bridge_mutex)
end_define

begin_define
define|#
directive|define
name|BDG_WLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_wlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_WUNLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_wunlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_RLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_rlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_RUNLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_runlock(&(b)->bdg_lock)
end_define

begin_comment
comment|/* set/get variables. OS-specific macros may wrap these  * assignments into read/write lock or similar  */
end_comment

begin_define
define|#
directive|define
name|BDG_SET_VAR
parameter_list|(
name|lval
parameter_list|,
name|p
parameter_list|)
value|(lval = p)
end_define

begin_define
define|#
directive|define
name|BDG_GET_VAR
parameter_list|(
name|lval
parameter_list|)
value|(lval)
end_define

begin_define
define|#
directive|define
name|BDG_FREE
parameter_list|(
name|p
parameter_list|)
value|free(p, M_DEVBUF)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|nma_is_vp
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
return|return
name|na
operator|->
name|nm_register
operator|==
name|bdg_netmap_reg
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|nma_is_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
return|return
name|na
operator|->
name|nm_register
operator|==
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|nma_is_hw
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
comment|/* In case of sw adapter, nm_register is NULL */
return|return
operator|!
name|nma_is_vp
argument_list|(
name|na
argument_list|)
operator|&&
operator|!
name|nma_is_host
argument_list|(
name|na
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Regarding holding a NIC, if the NIC is owned by the kernel  * (i.e., bridge), neither another bridge nor user can use it;  * if the NIC is owned by a user, only users can share it.  * Evaluation must be done under NMA_LOCK().  */
end_comment

begin_define
define|#
directive|define
name|NETMAP_OWNED_BY_KERN
parameter_list|(
name|ifp
parameter_list|)
value|(!nma_is_vp(NA(ifp))&& NA(ifp)->na_bdg)
end_define

begin_define
define|#
directive|define
name|NETMAP_OWNED_BY_ANY
parameter_list|(
name|ifp
parameter_list|)
define|\
value|(NETMAP_OWNED_BY_KERN(ifp) || (NA(ifp)->refcount> 0))
end_define

begin_comment
comment|/*  * NA(ifp)->bdg_port	port index  */
end_comment

begin_comment
comment|// XXX only for multiples of 64 bytes, non overlapped.
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pkt_copy
parameter_list|(
name|void
modifier|*
name|_src
parameter_list|,
name|void
modifier|*
name|_dst
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|uint64_t
modifier|*
name|src
init|=
name|_src
decl_stmt|;
name|uint64_t
modifier|*
name|dst
init|=
name|_dst
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|l
operator|>=
literal|1024
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
name|likely
argument_list|(
name|l
operator|>
literal|0
argument_list|)
condition|;
name|l
operator|-=
literal|64
control|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * locate a bridge among the existing ones.  * a ':' in the name terminates the bridge name. Otherwise, just NM_NAME.  * We assume that this is called with a name of at least NM_NAME chars.  */
end_comment

begin_function
specifier|static
name|struct
name|nm_bridge
modifier|*
name|nm_find_bridge
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|namelen
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|NM_NAME
argument_list|)
expr_stmt|;
comment|/* base length */
name|l
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* actual length */
for|for
control|(
name|i
operator|=
name|namelen
operator|+
literal|1
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|':'
condition|)
block|{
name|namelen
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|namelen
operator|>=
name|IFNAMSIZ
condition|)
name|namelen
operator|=
name|IFNAMSIZ
expr_stmt|;
name|ND
argument_list|(
literal|"--- prefix is '%.*s' ---"
argument_list|,
name|namelen
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BDG_LOCK
argument_list|()
expr_stmt|;
comment|/* lookup the name, remember empty slot if there is one */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BRIDGES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nm_bridge
modifier|*
name|x
init|=
name|nm_bridges
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|namelen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|create
operator|&&
name|b
operator|==
name|NULL
condition|)
name|b
operator|=
name|x
expr_stmt|;
comment|/* record empty slot */
block|}
elseif|else
if|if
condition|(
name|x
operator|->
name|namelen
operator|!=
name|namelen
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|x
operator|->
name|basename
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ND
argument_list|(
literal|"found '%.*s' at %d"
argument_list|,
name|namelen
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|b
operator|=
name|x
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|NM_BRIDGES
operator|&&
name|b
condition|)
block|{
comment|/* name not found, can create entry */
name|strncpy
argument_list|(
name|b
operator|->
name|basename
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|b
operator|->
name|namelen
operator|=
name|namelen
expr_stmt|;
comment|/* set the default function */
name|b
operator|->
name|nm_bdg_lookup
operator|=
name|netmap_bdg_learning
expr_stmt|;
comment|/* reset the MAC address table */
name|bzero
argument_list|(
name|b
operator|->
name|ht
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nm_hash_ent
argument_list|)
operator|*
name|NM_BDG_HASH
argument_list|)
expr_stmt|;
block|}
name|BDG_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Free the forwarding tables for rings attached to switch ports.  */
end_comment

begin_function
specifier|static
name|void
name|nm_free_bdgfwd
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|int
name|nrings
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|nrings
operator|=
name|nma_is_vp
argument_list|(
name|na
argument_list|)
condition|?
name|na
operator|->
name|num_tx_rings
else|:
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|kring
operator|=
name|nma_is_vp
argument_list|(
name|na
argument_list|)
condition|?
name|na
operator|->
name|tx_rings
else|:
name|na
operator|->
name|rx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrings
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
condition|)
block|{
name|free
argument_list|(
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
operator|=
name|NULL
expr_stmt|;
comment|/* protect from freeing twice */
block|}
block|}
if|if
condition|(
name|nma_is_hw
argument_list|(
name|na
argument_list|)
condition|)
name|nm_free_bdgfwd
argument_list|(
name|SWNA
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate the forwarding tables for the rings attached to the bridge ports.  */
end_comment

begin_function
specifier|static
name|int
name|nm_alloc_bdgfwd
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|int
name|nrings
decl_stmt|,
name|l
decl_stmt|,
name|i
decl_stmt|,
name|num_dstq
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
comment|/* all port:rings + broadcast */
name|num_dstq
operator|=
name|NM_BDG_MAXPORTS
operator|*
name|NM_BDG_MAXRINGS
operator|+
literal|1
expr_stmt|;
name|l
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nm_bdg_fwd
argument_list|)
operator|*
name|NM_BDG_BATCH
expr_stmt|;
name|l
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|nm_bdg_q
argument_list|)
operator|*
name|num_dstq
expr_stmt|;
name|l
operator|+=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|NM_BDG_BATCH
expr_stmt|;
name|nrings
operator|=
name|nma_is_vp
argument_list|(
name|na
argument_list|)
condition|?
name|na
operator|->
name|num_tx_rings
else|:
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|kring
operator|=
name|nma_is_vp
argument_list|(
name|na
argument_list|)
condition|?
name|na
operator|->
name|tx_rings
else|:
name|na
operator|->
name|rx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
decl_stmt|;
name|struct
name|nm_bdg_q
modifier|*
name|dstq
decl_stmt|;
name|int
name|j
decl_stmt|;
name|ft
operator|=
name|malloc
argument_list|(
name|l
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ft
condition|)
block|{
name|nm_free_bdgfwd
argument_list|(
name|na
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|dstq
operator|=
operator|(
expr|struct
name|nm_bdg_q
operator|*
operator|)
operator|(
name|ft
operator|+
name|NM_BDG_BATCH
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_dstq
condition|;
name|j
operator|++
control|)
name|dstq
index|[
name|j
index|]
operator|.
name|bq_head
operator|=
name|dstq
index|[
name|j
index|]
operator|.
name|bq_tail
operator|=
name|NM_BDG_BATCH
expr_stmt|;
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
operator|=
name|ft
expr_stmt|;
block|}
if|if
condition|(
name|nma_is_hw
argument_list|(
name|na
argument_list|)
condition|)
name|nm_alloc_bdgfwd
argument_list|(
name|SWNA
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NM_BRIDGE */
end_comment

begin_comment
comment|/*  * Fetch configuration from the device, to cope with dynamic  * reconfigurations after loading the module.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_update_config
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|u_int
name|txr
decl_stmt|,
name|txd
decl_stmt|,
name|rxr
decl_stmt|,
name|rxd
decl_stmt|;
name|txr
operator|=
name|txd
operator|=
name|rxr
operator|=
name|rxd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_config
condition|)
block|{
name|na
operator|->
name|nm_config
argument_list|(
name|ifp
argument_list|,
operator|&
name|txr
argument_list|,
operator|&
name|txd
argument_list|,
operator|&
name|rxr
argument_list|,
operator|&
name|rxd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* take whatever we had at init time */
name|txr
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|txd
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|rxr
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|rxd
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|==
name|txr
operator|&&
name|na
operator|->
name|num_tx_desc
operator|==
name|txd
operator|&&
name|na
operator|->
name|num_rx_rings
operator|==
name|rxr
operator|&&
name|na
operator|->
name|num_rx_desc
operator|==
name|rxd
condition|)
return|return
literal|0
return|;
comment|/* nothing changed */
if|if
condition|(
name|netmap_verbose
operator|||
name|na
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"stored config %s: txring %d x %d, rxring %d x %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|na
operator|->
name|num_tx_rings
argument_list|,
name|na
operator|->
name|num_tx_desc
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|,
name|na
operator|->
name|num_rx_desc
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"new config %s: txring %d x %d, rxring %d x %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|txr
argument_list|,
name|txd
argument_list|,
name|rxr
argument_list|,
name|rxd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"configuration changed (but fine)"
argument_list|)
expr_stmt|;
name|na
operator|->
name|num_tx_rings
operator|=
name|txr
expr_stmt|;
name|na
operator|->
name|num_tx_desc
operator|=
name|txd
expr_stmt|;
name|na
operator|->
name|num_rx_rings
operator|=
name|rxr
expr_stmt|;
name|na
operator|->
name|num_rx_desc
operator|=
name|rxd
expr_stmt|;
return|return
literal|0
return|;
block|}
name|D
argument_list|(
literal|"configuration changed while active, this is bad..."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*------------- memory allocator -----------------*/
end_comment

begin_include
include|#
directive|include
file|"netmap_mem2.c"
end_include

begin_comment
comment|/*------------ end of memory allocator ----------*/
end_comment

begin_comment
comment|/* Structure associated to each thread which registered an interface.  *  * The first 4 fields of this structure are written by NIOCREGIF and  * read by poll() and NIOC?XSYNC.  * There is low contention among writers (actually, a correct user program  * should have no contention among writers) and among writers and readers,  * so we use a single global lock to protect the structure initialization.  * Since initialization involves the allocation of memory, we reuse the memory  * allocator lock.  * Read access to the structure is lock free. Readers must check that  * np_nifp is not NULL before using the other fields.  * If np_nifp is NULL initialization has not been performed, so they should  * return an error to userlevel.  *  * The ref_done field is used to regulate access to the refcount in the  * memory allocator. The refcount must be incremented at most once for  * each open("/dev/netmap"). The increment is performed by the first  * function that calls netmap_get_memory() (currently called by  * mmap(), NIOCGINFO and NIOCREGIF).  * If the refcount is incremented, it is then decremented when the  * private structure is destroyed.  */
end_comment

begin_struct
struct|struct
name|netmap_priv_d
block|{
name|struct
name|netmap_if
modifier|*
specifier|volatile
name|np_nifp
decl_stmt|;
comment|/* netmap interface descriptor. */
name|struct
name|ifnet
modifier|*
name|np_ifp
decl_stmt|;
comment|/* device for which we hold a reference */
name|int
name|np_ringid
decl_stmt|;
comment|/* from the ioctl */
name|u_int
name|np_qfirst
decl_stmt|,
name|np_qlast
decl_stmt|;
comment|/* range of rings to scan */
name|uint16_t
name|np_txpoll
decl_stmt|;
name|unsigned
name|long
name|ref_done
decl_stmt|;
comment|/* use with NMA_LOCK held */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|netmap_get_memory
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|NMA_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|ref_done
condition|)
block|{
name|error
operator|=
name|netmap_memory_finalize
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|p
operator|->
name|ref_done
operator|=
literal|1
expr_stmt|;
block|}
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * File descriptor's private data destructor.  *  * Call nm_register(ifp,0) to stop netmap mode on the interface and  * revert to normal operation. We expect that np_ifp has not gone.  */
end_comment

begin_comment
comment|/* call with NMA_LOCK held */
end_comment

begin_function
specifier|static
name|void
name|netmap_dtor_locked
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|np_ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|priv
operator|->
name|np_nifp
decl_stmt|;
name|na
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|refcount
operator|<=
literal|0
condition|)
block|{
comment|/* last instance */
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|lim
decl_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"deleting last instance for %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* 		 * (TO CHECK) This function is only called 		 * when the last reference to this file descriptor goes 		 * away. This means we cannot have any pending poll() 		 * or interrupt routine operating on the structure. 		 */
name|na
operator|->
name|nm_register
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* off, clear IFCAP_NETMAP */
comment|/* Wake up any sleeping threads. netmap_poll will 		 * then return POLLERR 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|tx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|na
operator|->
name|rx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NM_BRIDGE
name|nm_free_bdgfwd
argument_list|(
name|na
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NM_BRIDGE */
comment|/* release all buffers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|ring
decl_stmt|;
name|lim
operator|=
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|nkr_num_slots
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lim
condition|;
name|j
operator|++
control|)
name|netmap_free_buf
argument_list|(
name|nifp
argument_list|,
name|ring
operator|->
name|slot
index|[
name|j
index|]
operator|.
name|buf_idx
argument_list|)
expr_stmt|;
comment|/* knlist_destroy(&na->tx_rings[i].si.si_note); */
name|mtx_destroy
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
decl_stmt|;
name|lim
operator|=
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nkr_num_slots
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lim
condition|;
name|j
operator|++
control|)
name|netmap_free_buf
argument_list|(
name|nifp
argument_list|,
name|ring
operator|->
name|slot
index|[
name|j
index|]
operator|.
name|buf_idx
argument_list|)
expr_stmt|;
comment|/* knlist_destroy(&na->rx_rings[i].si.si_note); */
name|mtx_destroy
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
block|}
comment|/* XXX kqueue(9) needed; these will mirror knlist_init. */
comment|/* knlist_destroy(&na->tx_si.si_note); */
comment|/* knlist_destroy(&na->rx_si.si_note); */
name|netmap_free_rings
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|nma_is_hw
argument_list|(
name|na
argument_list|)
condition|)
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|tx_rings
operator|=
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|rx_rings
operator|=
name|NULL
expr_stmt|;
block|}
name|netmap_if_free
argument_list|(
name|nifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* we assume netmap adapter exists */
end_comment

begin_function
specifier|static
name|void
name|nm_if_rele
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NM_BRIDGE
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NM_BRIDGE */
name|int
name|i
decl_stmt|,
name|full
init|=
literal|0
decl_stmt|,
name|is_hw
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
comment|/* I can be called not only for get_ifp()-ed references where netmap's 	 * capability is guaranteed, but also for non-netmap-capable NICs. 	 */
if|if
condition|(
operator|!
name|NETMAP_CAPABLE
argument_list|(
name|ifp
argument_list|)
operator|||
operator|!
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_bdg
condition|)
block|{
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|DROP_BDG_REF
argument_list|(
name|ifp
argument_list|)
condition|)
return|return;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|b
operator|=
name|na
operator|->
name|na_bdg
expr_stmt|;
name|is_hw
operator|=
name|nma_is_hw
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|BDG_WLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"want to disconnect %s from the bridge"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|full
operator|=
literal|0
expr_stmt|;
comment|/* remove the entry from the bridge, also check 	 * if there are any leftover interfaces 	 * XXX we should optimize this code, e.g. going directly 	 * to na->bdg_port, and having a counter of ports that 	 * are connected. But it is not in a critical path. 	 * In NIC's case, index of sw na is always higher than hw na 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BDG_MAXPORTS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|tmp
init|=
name|BDG_GET_VAR
argument_list|(
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|na
condition|)
block|{
comment|/* disconnect from bridge */
name|BDG_SET_VAR
argument_list|(
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_bdg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|is_hw
operator|&&
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_bdg
condition|)
block|{
comment|/* disconnect sw adapter too */
name|int
name|j
init|=
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|bdg_port
decl_stmt|;
name|BDG_SET_VAR
argument_list|(
name|b
operator|->
name|bdg_ports
index|[
name|j
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_bdg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|full
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|BDG_WUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|full
operator|==
literal|0
condition|)
block|{
name|ND
argument_list|(
literal|"marking bridge %d as free"
argument_list|,
name|b
operator|-
name|nm_bridges
argument_list|)
expr_stmt|;
name|b
operator|->
name|namelen
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|nm_bdg_lookup
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|na_bdg
condition|)
block|{
comment|/* still attached to the bridge */
name|D
argument_list|(
literal|"ouch, cannot find ifp to remove"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_hw
condition|)
block|{
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|na
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|na
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ifp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ifp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NM_BRIDGE */
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_dtor
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|np_ifp
decl_stmt|;
name|NMA_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|ifp
condition|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
name|na
operator|->
name|na_bdg
condition|)
name|BDG_WLOCK
argument_list|(
name|na
operator|->
name|na_bdg
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|netmap_dtor_locked
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|na_bdg
condition|)
name|BDG_WUNLOCK
argument_list|(
name|na
operator|->
name|na_bdg
argument_list|)
expr_stmt|;
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* might also destroy *na */
block|}
if|if
condition|(
name|priv
operator|->
name|ref_done
condition|)
block|{
name|netmap_memory_deref
argument_list|()
expr_stmt|;
block|}
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX for safety */
name|free
argument_list|(
name|priv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_comment
comment|/*  * In order to track whether pages are still mapped, we hook into  * the standard cdev_pager and intercept the constructor and  * destructor.  * XXX but then ? Do we really use the information ?  * Need to investigate.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdev_pager_ops
name|saved_cdev_pager_ops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|netmap_dev_pager_ctor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_ooffset_t
name|foff
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|u_short
modifier|*
name|color
parameter_list|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"first mmap for %p"
argument_list|,
name|handle
argument_list|)
expr_stmt|;
return|return
name|saved_cdev_pager_ops
operator|.
name|cdev_pg_ctor
argument_list|(
name|handle
argument_list|,
name|size
argument_list|,
name|prot
argument_list|,
name|foff
argument_list|,
name|cred
argument_list|,
name|color
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_dev_pager_dtor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|saved_cdev_pager_ops
operator|.
name|cdev_pg_dtor
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"ready to release memory for %p"
argument_list|,
name|handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdev_pager_ops
name|netmap_cdev_pager_ops
init|=
block|{
operator|.
name|cdev_pg_ctor
operator|=
name|netmap_dev_pager_ctor
block|,
operator|.
name|cdev_pg_dtor
operator|=
name|netmap_dev_pager_dtor
block|,
operator|.
name|cdev_pg_fault
operator|=
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|// XXX check whether we need netmap_mmap_single _and_ netmap_mmap
end_comment

begin_function
specifier|static
name|int
name|netmap_mmap_single
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|vm_ooffset_t
modifier|*
name|foff
parameter_list|,
name|vm_size_t
name|objsize
parameter_list|,
name|vm_object_t
modifier|*
name|objp
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|ND
argument_list|(
literal|"cdev %p foff %jd size %jd objp %p prot %d"
argument_list|,
name|cdev
argument_list|,
operator|(
name|intmax_t
operator|)
operator|*
name|foff
argument_list|,
operator|(
name|intmax_t
operator|)
name|objsize
argument_list|,
name|objp
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|obj
operator|=
name|vm_pager_allocate
argument_list|(
name|OBJT_DEVICE
argument_list|,
name|cdev
argument_list|,
name|objsize
argument_list|,
name|prot
argument_list|,
operator|*
name|foff
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"returns obj %p"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|saved_cdev_pager_ops
operator|.
name|cdev_pg_fault
operator|==
name|NULL
condition|)
block|{
name|ND
argument_list|(
literal|"initialize cdev_pager_ops"
argument_list|)
expr_stmt|;
name|saved_cdev_pager_ops
operator|=
operator|*
operator|(
name|obj
operator|->
name|un_pager
operator|.
name|devp
operator|.
name|ops
operator|)
expr_stmt|;
name|netmap_cdev_pager_ops
operator|.
name|cdev_pg_fault
operator|=
name|saved_cdev_pager_ops
operator|.
name|cdev_pg_fault
expr_stmt|;
block|}
empty_stmt|;
name|obj
operator|->
name|un_pager
operator|.
name|devp
operator|.
name|ops
operator|=
operator|&
name|netmap_cdev_pager_ops
expr_stmt|;
operator|*
name|objp
operator|=
name|obj
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/*  * mmap(2) support for the "netmap" device.  *  * Expose all the memory previously allocated by our custom memory  * allocator: this way the user has only to issue a single mmap(2), and  * can work on all the data structures flawlessly.  *  * Return 0 on success, -1 otherwise.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
specifier|static
name|int
name|netmap_mmap
parameter_list|(
name|__unused
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|900000
name|vm_offset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
else|#
directive|else
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|,
name|__unused
name|vm_memattr_t
modifier|*
name|memattr
endif|#
directive|endif
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|priv
decl_stmt|;
if|if
condition|(
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|// XXX -1 or EINVAL ?
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EBADF
condition|)
block|{
comment|/* called on fault, memory is initialized */
name|ND
argument_list|(
literal|5
argument_list|,
literal|"handling fault at ofs 0x%x"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
literal|0
condition|)
comment|/* make sure memory is set */
name|error
operator|=
name|netmap_get_memory
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ND
argument_list|(
literal|"request for offset 0x%x"
argument_list|,
operator|(
name|uint32_t
operator|)
name|offset
argument_list|)
expr_stmt|;
operator|*
name|paddr
operator|=
name|netmap_ofstophys
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|paddr
condition|?
literal|0
else|:
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"dev %p fflag 0x%x devtype %d td %p"
argument_list|,
name|dev
argument_list|,
name|fflag
argument_list|,
name|devtype
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
decl_stmt|;
name|int
name|error
decl_stmt|;
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_priv_d
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|error
operator|=
name|devfs_set_cdevpriv
argument_list|(
name|priv
argument_list|,
name|netmap_dtor
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/*  * Handlers for synchronization of the queues from/to the host.  * Netmap has two operating modes:  * - in the default mode, the rings connected to the host stack are  *   just another ring pair managed by userspace;  * - in transparent mode (XXX to be defined) incoming packets  *   (from the host or the NIC) are marked as NS_FORWARD upon  *   arrival, and the user application has a chance to reset the  *   flag for packets that should be dropped.  *   On the RXSYNC or poll(), packets in RX rings between  *   kring->nr_kcur and ring->cur with NS_FORWARD still set are moved  *   to the other side.  * The transfer NIC --> host is relatively easy, just encapsulate  * into mbufs and we are done. The host --> NIC side is slightly  * harder because there might not be room in the tx ring so it  * might take a while before releasing the buffer.  */
end_comment

begin_comment
comment|/*  * pass a chain of buffers to the host stack as coming from 'dst'  */
end_comment

begin_function
specifier|static
name|void
name|netmap_send_up
parameter_list|(
name|struct
name|ifnet
modifier|*
name|dst
parameter_list|,
name|struct
name|mbuf
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* send packets up, outside the lock */
while|while
condition|(
operator|(
name|m
operator|=
name|head
operator|)
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
name|head
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"sending up pkt %p size %d"
argument_list|,
name|m
argument_list|,
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|NM_SEND_UP
argument_list|(
name|dst
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|mbq
block|{
name|struct
name|mbuf
modifier|*
name|head
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|tail
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * put a copy of the buffers marked NS_FORWARD into an mbuf chain.  * Run from hwcur to cur - reserved  */
end_comment

begin_function
specifier|static
name|void
name|netmap_grab_packets
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|struct
name|mbq
modifier|*
name|q
parameter_list|,
name|int
name|force
parameter_list|)
block|{
comment|/* Take packets from hwcur to cur-reserved and pass them up. 	 * In case of no buffers we give up. At the end of the loop, 	 * the queue is drained in all cases. 	 * XXX handle reserved 	 */
name|int
name|k
init|=
name|kring
operator|->
name|ring
operator|->
name|cur
operator|-
name|kring
operator|->
name|ring
operator|->
name|reserved
decl_stmt|;
name|u_int
name|n
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|tail
init|=
name|q
operator|->
name|tail
decl_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
name|k
operator|=
name|k
operator|+
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
for|for
control|(
name|n
operator|=
name|kring
operator|->
name|nr_hwcur
init|;
name|n
operator|!=
name|k
condition|;
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|n
index|]
decl_stmt|;
name|n
operator|=
operator|(
name|n
operator|==
name|lim
operator|)
condition|?
literal|0
else|:
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_FORWARD
operator|)
operator|==
literal|0
operator|&&
operator|!
name|force
condition|)
continue|continue;
if|if
condition|(
name|slot
operator|->
name|len
operator|<
literal|14
operator|||
name|slot
operator|->
name|len
operator|>
name|NETMAP_BUF_SIZE
condition|)
block|{
name|D
argument_list|(
literal|"bad pkt at %d len %d"
argument_list|,
name|n
argument_list|,
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_FORWARD
expr_stmt|;
comment|// XXX needed ?
name|m
operator|=
name|m_devget
argument_list|(
name|NMB
argument_list|(
name|slot
argument_list|)
argument_list|,
name|slot
operator|->
name|len
argument_list|,
literal|0
argument_list|,
name|kring
operator|->
name|na
operator|->
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|tail
condition|)
name|tail
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
else|else
name|q
operator|->
name|head
operator|=
name|m
expr_stmt|;
name|tail
operator|=
name|m
expr_stmt|;
name|q
operator|->
name|count
operator|++
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
block|}
name|q
operator|->
name|tail
operator|=
name|tail
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * called under main lock to send packets from the host to the NIC  * The host ring has packets from nr_hwcur to (cur - reserved)  * to be sent down. We scan the tx rings, which have just been  * flushed so nr_hwcur == cur. Pushing packets down means  * increment cur and decrement avail.  * XXX to be verified  */
end_comment

begin_function
specifier|static
name|void
name|netmap_sw_to_nic
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|k1
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
literal|0
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|howmany
decl_stmt|,
name|src_lim
decl_stmt|,
name|dst_lim
decl_stmt|;
name|howmany
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
comment|/* XXX otherwise cur - reserved - nr_hwcur */
name|src_lim
operator|=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|howmany
operator|>
literal|0
operator|&&
name|i
operator|<
name|na
operator|->
name|num_tx_rings
condition|;
name|i
operator|++
operator|,
name|k1
operator|++
control|)
block|{
name|ND
argument_list|(
literal|"%d packets left to ring %d (space %d)"
argument_list|,
name|howmany
argument_list|,
name|i
argument_list|,
name|k1
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
name|dst_lim
operator|=
name|k1
operator|->
name|nkr_num_slots
expr_stmt|;
while|while
condition|(
name|howmany
operator|>
literal|0
operator|&&
name|k1
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|struct
name|netmap_slot
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
name|tmp
decl_stmt|;
name|src
operator|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|kring
operator|->
name|nr_hwcur
index|]
expr_stmt|;
name|dst
operator|=
operator|&
name|k1
operator|->
name|ring
operator|->
name|slot
index|[
name|k1
operator|->
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|tmp
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|->
name|buf_idx
operator|=
name|dst
operator|->
name|buf_idx
expr_stmt|;
name|src
operator|->
name|flags
operator|=
name|NS_BUF_CHANGED
expr_stmt|;
name|dst
operator|->
name|buf_idx
operator|=
name|tmp
operator|.
name|buf_idx
expr_stmt|;
name|dst
operator|->
name|len
operator|=
name|tmp
operator|.
name|len
expr_stmt|;
name|dst
operator|->
name|flags
operator|=
name|NS_BUF_CHANGED
expr_stmt|;
name|ND
argument_list|(
literal|"out len %d buf %d from %d to %d"
argument_list|,
name|dst
operator|->
name|len
argument_list|,
name|dst
operator|->
name|buf_idx
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|k1
operator|->
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|kring
operator|->
name|nr_hwcur
operator|>=
name|src_lim
condition|)
name|kring
operator|->
name|nr_hwcur
operator|=
literal|0
expr_stmt|;
name|howmany
operator|--
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|--
expr_stmt|;
if|if
condition|(
operator|++
name|k1
operator|->
name|ring
operator|->
name|cur
operator|>=
name|dst_lim
condition|)
name|k1
operator|->
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|k1
operator|->
name|ring
operator|->
name|avail
operator|--
expr_stmt|;
block|}
name|kring
operator|->
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
comment|// XXX
name|k1
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * netmap_sync_to_host() passes packets up. We are called from a  * system call in user process context, and the only contention  * can be among multiple user threads erroneously calling  * this routine concurrently.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_sync_to_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|na
operator|->
name|num_tx_rings
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|k
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|mbq
name|q
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|k
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|lim
condition|)
block|{
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// na->nm_lock(na->ifp, NETMAP_CORE_LOCK, 0);
comment|/* Take packets from hwcur to cur and pass them up. 	 * In case of no buffers we give up. At the end of the loop, 	 * the queue is drained in all cases. 	 */
name|netmap_grab_packets
argument_list|(
name|kring
argument_list|,
operator|&
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|k
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|=
name|ring
operator|->
name|avail
operator|=
name|lim
expr_stmt|;
comment|// na->nm_lock(na->ifp, NETMAP_CORE_UNLOCK, 0);
name|netmap_send_up
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|q
operator|.
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SWNA(ifp)->txrings[0] is always NA(ifp)->txrings[NA(ifp)->num_txrings] */
end_comment

begin_function
specifier|static
name|int
name|netmap_bdg_to_host
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|int
name|do_lock
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ring_nr
expr_stmt|;
operator|(
name|void
operator|)
name|do_lock
expr_stmt|;
name|netmap_sync_to_host
argument_list|(
name|NA
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * rxsync backend for packets coming from the host stack.  * They have been put in the queue by netmap_start() so we  * need to protect access to the kring using a lock.  *  * This routine also does the selrecord if called from the poll handler  * (we know because td != NULL).  *  * NOTE: on linux, selrecord() is defined as a macro and uses pwait  *     as an additional hidden argument.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_sync_from_host
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|pwait
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|j
decl_stmt|,
name|n
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
decl_stmt|;
name|u_int
name|k
init|=
name|ring
operator|->
name|cur
decl_stmt|,
name|resvd
init|=
name|ring
operator|->
name|reserved
decl_stmt|;
operator|(
name|void
operator|)
name|pwait
expr_stmt|;
comment|/* disable unused warnings */
name|na
operator|->
name|nm_lock
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|lim
condition|)
block|{
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* new packets are already set in nr_hwavail */
comment|/* skip past packets that userspace has released */
name|j
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|resvd
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|resvd
operator|+
name|ring
operator|->
name|avail
operator|>=
name|lim
operator|+
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"XXX invalid reserve/avail %d %d"
argument_list|,
name|resvd
argument_list|,
name|ring
operator|->
name|avail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|reserved
operator|=
name|resvd
operator|=
literal|0
expr_stmt|;
comment|// XXX panic...
block|}
name|k
operator|=
operator|(
name|k
operator|>=
name|resvd
operator|)
condition|?
name|k
operator|-
name|resvd
else|:
name|k
operator|+
name|lim
operator|-
name|resvd
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
name|k
condition|)
block|{
name|n
operator|=
name|k
operator|>=
name|j
condition|?
name|k
operator|-
name|j
else|:
name|k
operator|+
name|lim
operator|-
name|j
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|-=
name|n
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|k
expr_stmt|;
block|}
name|k
operator|=
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
operator|-
name|resvd
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
operator|&&
name|td
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|&&
operator|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
operator|)
condition|)
name|D
argument_list|(
literal|"%d pkts from stack"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a refcounted reference to an interface.  * Return ENXIO if the interface does not exist, EINVAL if netmap  * is not supported by the interface.  * If successful, hold a reference.  *  * During the NIC is attached to a bridge, reference is managed  * at na->na_bdg_refcount using ADD/DROP_BDG_REF() as well as  * virtual ports.  Hence, on the final DROP_BDG_REF(), the NIC  * is detached from the bridge, then ifp's refcount is dropped (this  * is equivalent to that ifp is destroyed in case of virtual ports.  *  * This function uses if_rele() when we want to prevent the NIC from  * being detached from the bridge in error handling.  But once refcount  * is acquired by this function, it must be released using nm_if_rele().  */
end_comment

begin_function
specifier|static
name|int
name|get_ifp
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|ifnet
modifier|*
modifier|*
name|ifp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|nmr
operator|->
name|nr_name
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|NM_BRIDGE
name|struct
name|ifnet
modifier|*
name|iter
init|=
name|NULL
decl_stmt|;
name|int
name|no_prefix
init|=
literal|0
decl_stmt|;
do|do
block|{
name|struct
name|nm_bridge
modifier|*
name|b
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cand
init|=
operator|-
literal|1
decl_stmt|,
name|cand2
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|NM_NAME
argument_list|,
sizeof|sizeof
argument_list|(
name|NM_NAME
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|no_prefix
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|b
operator|=
name|nm_find_bridge
argument_list|(
name|name
argument_list|,
literal|1
comment|/* create a new one if no exist */
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"no bridges available for '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Now we are sure that name starts with the bridge's name */
name|BDG_WLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* lookup in the local list of ports */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BDG_MAXPORTS
condition|;
name|i
operator|++
control|)
block|{
name|na
operator|=
name|BDG_GET_VAR
argument_list|(
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|cand
operator|==
operator|-
literal|1
condition|)
name|cand
operator|=
name|i
expr_stmt|;
comment|/* potential insert point */
elseif|else
if|if
condition|(
name|cand2
operator|==
operator|-
literal|1
condition|)
name|cand2
operator|=
name|i
expr_stmt|;
comment|/* for host stack */
continue|continue;
block|}
name|iter
operator|=
name|na
operator|->
name|ifp
expr_stmt|;
comment|/* XXX make sure the name only contains one : */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|iter
operator|->
name|if_xname
argument_list|,
name|name
argument_list|)
comment|/* virtual port */
operator|||
operator|(
name|namelen
operator|>
name|b
operator|->
name|namelen
operator|&&
operator|!
name|strcmp
argument_list|(
name|iter
operator|->
name|if_xname
argument_list|,
name|name
operator|+
name|b
operator|->
name|namelen
operator|+
literal|1
argument_list|)
operator|)
comment|/* NIC */
condition|)
block|{
name|ADD_BDG_REF
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"found existing interface"
argument_list|)
expr_stmt|;
name|BDG_WUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|NM_BDG_MAXPORTS
condition|)
comment|/* already unlocked */
break|break;
if|if
condition|(
name|cand
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"bridge full, cannot create new port"
argument_list|)
expr_stmt|;
name|no_port
label|:
name|BDG_WUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
operator|*
name|ifp
operator|=
name|NULL
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|ND
argument_list|(
literal|"create new bridge port %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * create a struct ifnet for the new port. 		 * The forwarding table is attached to the kring(s). 		 */
comment|/* 		 * try see if there is a matching NIC with this name 		 * (after the bridge's name) 		 */
name|iter
operator|=
name|ifunit_ref
argument_list|(
name|name
operator|+
name|b
operator|->
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iter
condition|)
block|{
comment|/* this is a virtual port */
comment|/* Create a temporary NA with arguments, then 			 * bdg_netmap_attach() will allocate the real one 			 * and attach it to the ifp 			 */
name|struct
name|netmap_adapter
name|tmp_na
decl_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_cmd
condition|)
comment|/* nr_cmd must be for a NIC */
goto|goto
name|no_port
goto|;
name|bzero
argument_list|(
operator|&
name|tmp_na
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_na
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bound checking */
if|if
condition|(
name|nmr
operator|->
name|nr_tx_rings
operator|<
literal|1
condition|)
name|nmr
operator|->
name|nr_tx_rings
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_tx_rings
operator|>
name|NM_BDG_MAXRINGS
condition|)
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|NM_BDG_MAXRINGS
expr_stmt|;
name|tmp_na
operator|.
name|num_tx_rings
operator|=
name|nmr
operator|->
name|nr_tx_rings
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_rx_rings
operator|<
literal|1
condition|)
name|nmr
operator|->
name|nr_rx_rings
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_rx_rings
operator|>
name|NM_BDG_MAXRINGS
condition|)
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|NM_BDG_MAXRINGS
expr_stmt|;
name|tmp_na
operator|.
name|num_rx_rings
operator|=
name|nmr
operator|->
name|nr_rx_rings
expr_stmt|;
name|iter
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|iter
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iter
condition|)
goto|goto
name|no_port
goto|;
name|strcpy
argument_list|(
name|iter
operator|->
name|if_xname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|tmp_na
operator|.
name|ifp
operator|=
name|iter
expr_stmt|;
comment|/* bdg_netmap_attach creates a struct netmap_adapter */
name|bdg_netmap_attach
argument_list|(
operator|&
name|tmp_na
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NETMAP_CAPABLE
argument_list|(
name|iter
argument_list|)
condition|)
block|{
comment|/* this is a NIC */
comment|/* cannot attach the NIC that any user or another 			 * bridge already holds. 			 */
if|if
condition|(
name|NETMAP_OWNED_BY_ANY
argument_list|(
name|iter
argument_list|)
operator|||
name|cand2
operator|==
operator|-
literal|1
condition|)
block|{
name|ifunit_rele
label|:
name|if_rele
argument_list|(
name|iter
argument_list|)
expr_stmt|;
comment|/* don't detach from bridge */
goto|goto
name|no_port
goto|;
block|}
comment|/* bind the host stack to the bridge */
if|if
condition|(
name|nmr
operator|->
name|nr_arg1
operator|==
name|NETMAP_BDG_HOST
condition|)
block|{
name|BDG_SET_VAR
argument_list|(
name|b
operator|->
name|bdg_ports
index|[
name|cand2
index|]
argument_list|,
name|SWNA
argument_list|(
name|iter
argument_list|)
argument_list|)
expr_stmt|;
name|SWNA
argument_list|(
name|iter
argument_list|)
operator|->
name|bdg_port
operator|=
name|cand2
expr_stmt|;
name|SWNA
argument_list|(
name|iter
argument_list|)
operator|->
name|na_bdg
operator|=
name|b
expr_stmt|;
block|}
block|}
else|else
comment|/* not a netmap-capable NIC */
goto|goto
name|ifunit_rele
goto|;
name|na
operator|=
name|NA
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|na
operator|->
name|bdg_port
operator|=
name|cand
expr_stmt|;
comment|/* bind the port to the bridge (virtual ports are not active) */
name|BDG_SET_VAR
argument_list|(
name|b
operator|->
name|bdg_ports
index|[
name|cand
index|]
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_bdg
operator|=
name|b
expr_stmt|;
name|ADD_BDG_REF
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|BDG_WUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"attaching virtual bridge %p"
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
operator|*
name|ifp
operator|=
name|iter
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ifp
condition|)
endif|#
directive|endif
comment|/* NM_BRIDGE */
operator|*
name|ifp
operator|=
name|ifunit_ref
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* can do this if the capability exists and if_pspare[0] 	 * points to the netmap descriptor. 	 */
if|if
condition|(
name|NETMAP_CAPABLE
argument_list|(
operator|*
name|ifp
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|NM_BRIDGE
comment|/* Users cannot use the NIC attached to a bridge directly */
if|if
condition|(
name|no_prefix
operator|&&
name|NETMAP_OWNED_BY_KERN
argument_list|(
operator|*
name|ifp
argument_list|)
condition|)
block|{
name|if_rele
argument_list|(
operator|*
name|ifp
argument_list|)
expr_stmt|;
comment|/* don't detach from bridge */
return|return
name|EINVAL
return|;
block|}
else|else
endif|#
directive|endif
comment|/* NM_BRIDGE */
return|return
literal|0
return|;
comment|/* valid pointer, we hold the refcount */
block|}
name|nm_if_rele
argument_list|(
operator|*
name|ifp
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
comment|// not NETMAP capable
block|}
end_function

begin_comment
comment|/*  * Error routine called when txsync/rxsync detects an error.  * Can't do much more than resetting cur = hwcur, avail = hwavail.  * Return 1 on reinit.  *  * This routine is only called by the upper half of the kernel.  * It only reads hwcur (which is changed only by the upper half, too)  * and hwavail (which may be changed by the lower half, but only on  * a tx ring and only to increase it, so any error will be recovered  * on the next call). For the above, we don't strictly need to call  * it under lock.  */
end_comment

begin_function
name|int
name|netmap_ring_reinit
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|RD
argument_list|(
literal|10
argument_list|,
literal|"called for %s"
argument_list|,
name|kring
operator|->
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|cur
operator|>
name|lim
condition|)
name|errors
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|idx
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
decl_stmt|;
name|u_int
name|len
init|=
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|2
operator|||
name|idx
operator|>=
name|netmap_total_buffers
condition|)
block|{
if|if
condition|(
operator|!
name|errors
operator|++
condition|)
name|D
argument_list|(
literal|"bad buffer at slot %d idx %d len %d "
argument_list|,
name|i
argument_list|,
name|idx
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|buf_idx
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
name|NETMAP_BUF_SIZE
condition|)
block|{
name|ring
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|errors
operator|++
condition|)
name|D
argument_list|(
literal|"bad len %d at slot %d idx %d"
argument_list|,
name|len
argument_list|,
name|i
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errors
condition|)
block|{
name|int
name|pos
init|=
name|kring
operator|-
name|kring
operator|->
name|na
operator|->
name|tx_rings
decl_stmt|;
name|int
name|n
init|=
name|kring
operator|->
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
decl_stmt|;
name|RD
argument_list|(
literal|10
argument_list|,
literal|"total %d errors"
argument_list|,
name|errors
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|RD
argument_list|(
literal|10
argument_list|,
literal|"%s %s[%d] reinit, cur %d -> %d avail %d -> %d"
argument_list|,
name|kring
operator|->
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|pos
operator|<
name|n
condition|?
literal|"TX"
else|:
literal|"RX"
argument_list|,
name|pos
operator|<
name|n
condition|?
name|pos
else|:
name|pos
operator|-
name|n
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|ring
operator|->
name|avail
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
block|}
return|return
operator|(
name|errors
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the ring ID. For devices with a single queue, a request  * for all rings is the same as a single ring.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_set_ringid
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|u_int
name|ringid
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|np_ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|u_int
name|i
init|=
name|ringid
operator|&
name|NETMAP_RING_MASK
decl_stmt|;
comment|/* initially (np_qfirst == np_qlast) we don't want to lock */
name|int
name|need_lock
init|=
operator|(
name|priv
operator|->
name|np_qfirst
operator|!=
name|priv
operator|->
name|np_qlast
operator|)
decl_stmt|;
name|int
name|lim
init|=
name|na
operator|->
name|num_rx_rings
decl_stmt|;
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|>
name|lim
condition|)
name|lim
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
if|if
condition|(
operator|(
name|ringid
operator|&
name|NETMAP_HW_RING
operator|)
operator|&&
name|i
operator|>=
name|lim
condition|)
block|{
name|D
argument_list|(
literal|"invalid ring id %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|need_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_ringid
operator|=
name|ringid
expr_stmt|;
if|if
condition|(
name|ringid
operator|&
name|NETMAP_SW_RING
condition|)
block|{
name|priv
operator|->
name|np_qfirst
operator|=
name|NETMAP_SW_RING
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ringid
operator|&
name|NETMAP_HW_RING
condition|)
block|{
name|priv
operator|->
name|np_qfirst
operator|=
name|i
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|->
name|np_qfirst
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|np_qlast
operator|=
name|NETMAP_HW_RING
expr_stmt|;
block|}
name|priv
operator|->
name|np_txpoll
operator|=
operator|(
name|ringid
operator|&
name|NETMAP_NO_TX_POLL
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|need_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
block|{
if|if
condition|(
name|ringid
operator|&
name|NETMAP_SW_RING
condition|)
name|D
argument_list|(
literal|"ringid %s set to SW RING"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ringid
operator|&
name|NETMAP_HW_RING
condition|)
name|D
argument_list|(
literal|"ringid %s set to HW RING %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|priv
operator|->
name|np_qfirst
argument_list|)
expr_stmt|;
else|else
name|D
argument_list|(
literal|"ringid %s set to all %d HW RINGS"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * possibly move the interface to netmap-mode.  * If success it returns a pointer to netmap_if, otherwise NULL.  * This must be called with NMA_LOCK held.  */
end_comment

begin_function
specifier|static
name|struct
name|netmap_if
modifier|*
name|netmap_do_regif
parameter_list|(
name|struct
name|netmap_priv_d
modifier|*
name|priv
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint16_t
name|ringid
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|na
operator|->
name|na_bdg
condition|)
name|BDG_WLOCK
argument_list|(
name|na
operator|->
name|na_bdg
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ring configuration may have changed, fetch from the card */
name|netmap_update_config
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|priv
operator|->
name|np_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* store the reference */
name|error
operator|=
name|netmap_set_ringid
argument_list|(
name|priv
argument_list|,
name|ringid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|nifp
operator|=
name|netmap_if_new
argument_list|(
name|ifp
operator|->
name|if_xname
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
block|{
comment|/* allocation failed */
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
comment|/* was already set */
block|}
else|else
block|{
comment|/* Otherwise set the card in netmap mode 		 * and make it use the shared buffers. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|,
literal|"nm_txq_lock"
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|mtx_init
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|q_lock
argument_list|,
literal|"nm_rxq_lock"
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nma_is_hw
argument_list|(
name|na
argument_list|)
condition|)
block|{
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|tx_rings
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|na
operator|->
name|num_tx_rings
index|]
expr_stmt|;
name|SWNA
argument_list|(
name|ifp
argument_list|)
operator|->
name|rx_rings
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
expr_stmt|;
block|}
name|error
operator|=
name|na
operator|->
name|nm_register
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* mode on */
ifdef|#
directive|ifdef
name|NM_BRIDGE
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nm_alloc_bdgfwd
argument_list|(
name|na
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NM_BRIDGE */
if|if
condition|(
name|error
condition|)
block|{
name|netmap_dtor_locked
argument_list|(
name|priv
argument_list|)
expr_stmt|;
comment|/* nifp is not yet in priv, so free it separately */
name|netmap_if_free
argument_list|(
name|nifp
argument_list|)
expr_stmt|;
name|nifp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|out
label|:
operator|*
name|err
operator|=
name|error
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_REG_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|na_bdg
condition|)
name|BDG_WUNLOCK
argument_list|(
name|na
operator|->
name|na_bdg
argument_list|)
expr_stmt|;
return|return
name|nifp
return|;
block|}
end_function

begin_comment
comment|/* Process NETMAP_BDG_ATTACH and NETMAP_BDG_DETACH */
end_comment

begin_function
specifier|static
name|int
name|kern_netmap_regif
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|npriv
decl_stmt|;
name|int
name|error
decl_stmt|;
name|npriv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|npriv
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|npriv
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|error
operator|=
name|netmap_get_memory
argument_list|(
name|npriv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free_exit
label|:
name|bzero
argument_list|(
name|npriv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|npriv
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|npriv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|NMA_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* no device, or another bridge or user owns the device */
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
goto|goto
name|free_exit
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|NETMAP_OWNED_BY_KERN
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
comment|/* got reference to a virtual port or direct access to a NIC. 		 * perhaps specified no bridge's prefix or wrong NIC's name 		 */
name|error
operator|=
name|EINVAL
expr_stmt|;
name|unref_exit
label|:
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
goto|goto
name|free_exit
goto|;
block|}
if|if
condition|(
name|nmr
operator|->
name|nr_cmd
operator|==
name|NETMAP_BDG_DETACH
condition|)
block|{
if|if
condition|(
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
comment|/* not registered */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|unref_exit
goto|;
block|}
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
name|netmap_dtor
argument_list|(
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_kpriv
argument_list|)
expr_stmt|;
comment|/* unregister */
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_kpriv
operator|=
name|NULL
expr_stmt|;
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* detach from the bridge */
goto|goto
name|free_exit
goto|;
block|}
elseif|else
if|if
condition|(
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* already registered */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|unref_exit
goto|;
block|}
name|nifp
operator|=
name|netmap_do_regif
argument_list|(
name|npriv
argument_list|,
name|ifp
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nifp
condition|)
goto|goto
name|unref_exit
goto|;
name|wmb
argument_list|()
expr_stmt|;
comment|// XXX do we need it ?
name|npriv
operator|->
name|np_nifp
operator|=
name|nifp
expr_stmt|;
name|NA
argument_list|(
name|ifp
argument_list|)
operator|->
name|na_kpriv
operator|=
name|npriv
expr_stmt|;
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
name|D
argument_list|(
literal|"registered %s to netmap-mode"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* CORE_LOCK is not necessary */
end_comment

begin_function
specifier|static
name|void
name|netmap_swlock_wrapper
parameter_list|(
name|struct
name|ifnet
modifier|*
name|dev
parameter_list|,
name|int
name|what
parameter_list|,
name|u_int
name|queueid
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|SWNA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|NETMAP_TX_LOCK
case|:
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_TX_UNLOCK
case|:
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_RX_LOCK
case|:
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_RX_UNLOCK
case|:
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Initialize necessary fields of sw adapter located in right after hw's  * one.  sw adapter attaches a pair of sw rings of the netmap-mode NIC.  * It is always activated and deactivated at the same tie with the hw's one.  * Thus we don't need refcounting on the sw adapter.  * Regardless of NIC's feature we use separate lock so that anybody can lock  * me independently from the hw adapter.  * Make sure nm_register is NULL to be handled as FALSE in nma_is_hw  */
end_comment

begin_function
specifier|static
name|void
name|netmap_attach_sw
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|hw_na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|SWNA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|na
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|na
operator|->
name|separate_locks
operator|=
literal|1
expr_stmt|;
name|na
operator|->
name|nm_lock
operator|=
name|netmap_swlock_wrapper
expr_stmt|;
name|na
operator|->
name|num_rx_rings
operator|=
name|na
operator|->
name|num_tx_rings
operator|=
literal|1
expr_stmt|;
name|na
operator|->
name|num_tx_desc
operator|=
name|hw_na
operator|->
name|num_tx_desc
expr_stmt|;
name|na
operator|->
name|num_rx_desc
operator|=
name|hw_na
operator|->
name|num_rx_desc
expr_stmt|;
name|na
operator|->
name|nm_txsync
operator|=
name|netmap_bdg_to_host
expr_stmt|;
block|}
end_function

begin_comment
comment|/* exported to kernel callers */
end_comment

begin_function
name|int
name|netmap_bdg_ctl
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|bdg_lookup_fn_t
name|func
parameter_list|)
block|{
name|struct
name|nm_bridge
modifier|*
name|b
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|iter
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|nmr
operator|->
name|nr_name
decl_stmt|;
name|int
name|cmd
init|=
name|nmr
operator|->
name|nr_cmd
decl_stmt|,
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NETMAP_BDG_ATTACH
case|:
case|case
name|NETMAP_BDG_DETACH
case|:
name|error
operator|=
name|kern_netmap_regif
argument_list|(
name|nmr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_BDG_LIST
case|:
comment|/* this is used to enumerate bridges and ports */
if|if
condition|(
name|namelen
condition|)
block|{
comment|/* look up indexes of bridge and port */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|NM_NAME
argument_list|,
name|strlen
argument_list|(
name|NM_NAME
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|b
operator|=
name|nm_find_bridge
argument_list|(
name|name
argument_list|,
literal|0
comment|/* don't create */
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|BDG_RLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BDG_MAXPORTS
condition|;
name|i
operator|++
control|)
block|{
name|na
operator|=
name|BDG_GET_VAR
argument_list|(
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
continue|continue;
name|iter
operator|=
name|na
operator|->
name|ifp
expr_stmt|;
comment|/* the former and the latter identify a 				 * virtual port and a NIC, respectively 				 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|iter
operator|->
name|if_xname
argument_list|,
name|name
argument_list|)
operator|||
operator|(
name|namelen
operator|>
name|b
operator|->
name|namelen
operator|&&
operator|!
name|strcmp
argument_list|(
name|iter
operator|->
name|if_xname
argument_list|,
name|name
operator|+
name|b
operator|->
name|namelen
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
comment|/* bridge index */
name|nmr
operator|->
name|nr_arg1
operator|=
name|b
operator|-
name|nm_bridges
expr_stmt|;
name|nmr
operator|->
name|nr_arg2
operator|=
name|i
expr_stmt|;
comment|/* port index */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|BDG_RUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the first non-empty entry starting from 			 * bridge nr_arg1 and port nr_arg2. 			 * 			 * Users can detect the end of the same bridge by 			 * seeing the new and old value of nr_arg1, and can 			 * detect the end of all the bridge by error != 0 			 */
name|i
operator|=
name|nmr
operator|->
name|nr_arg1
expr_stmt|;
name|j
operator|=
name|nmr
operator|->
name|nr_arg2
expr_stmt|;
for|for
control|(
name|error
operator|=
name|ENOENT
init|;
name|error
operator|&&
name|i
operator|<
name|NM_BRIDGES
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|nm_bridges
operator|+
name|i
expr_stmt|;
name|BDG_RLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|NM_BDG_MAXPORTS
condition|;
name|j
operator|++
control|)
block|{
name|na
operator|=
name|BDG_GET_VAR
argument_list|(
name|b
operator|->
name|bdg_ports
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
continue|continue;
name|iter
operator|=
name|na
operator|->
name|ifp
expr_stmt|;
name|nmr
operator|->
name|nr_arg1
operator|=
name|i
expr_stmt|;
name|nmr
operator|->
name|nr_arg2
operator|=
name|j
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|iter
operator|->
name|if_xname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|BDG_RUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
comment|/* following bridges scan from 0 */
block|}
block|}
break|break;
case|case
name|NETMAP_BDG_LOOKUP_REG
case|:
comment|/* register a lookup function to the given bridge. 		 * nmr->nr_name may be just bridge's name (including ':' 		 * if it is not just NM_NAME). 		 */
if|if
condition|(
operator|!
name|func
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|b
operator|=
name|nm_find_bridge
argument_list|(
name|name
argument_list|,
literal|0
comment|/* don't create */
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|BDG_WLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|nm_bdg_lookup
operator|=
name|func
expr_stmt|;
name|BDG_WUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
default|default:
name|D
argument_list|(
literal|"invalid cmd (nmr->nr_cmd) (0x%x)"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * ioctl(2) support for the "netmap" device.  *  * Following a list of accepted commands:  * - NIOCGINFO  * - SIOCGIFADDR	just for convenience  * - NIOCREGIF  * - NIOCUNREGIF  * - NIOCTXSYNC  * - NIOCRXSYNC  *  * Return 0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|nmreq
modifier|*
name|nmr
init|=
operator|(
expr|struct
name|nmreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|lim
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
operator|(
name|void
operator|)
name|dev
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|fflag
expr_stmt|;
comment|/* UNUSED */
ifdef|#
directive|ifdef
name|linux
define|#
directive|define
name|devfs_get_cdevpriv
parameter_list|(
name|pp
parameter_list|)
define|\
value|({ *(struct netmap_priv_d **)pp = ((struct file *)td)->private_data; 	\ 		(*pp ? 0 : ENOENT); })
comment|/* devfs_set_cdevpriv cannot fail on linux */
define|#
directive|define
name|devfs_set_cdevpriv
parameter_list|(
name|p
parameter_list|,
name|fn
parameter_list|)
define|\
value|({ ((struct file *)td)->private_data = p; (p ? 0 : EINVAL); })
define|#
directive|define
name|devfs_clear_cdevpriv
parameter_list|()
value|do {				\ 		netmap_dtor(priv); ((struct file *)td)->private_data = 0;	\ 	} while (0)
endif|#
directive|endif
comment|/* linux */
name|CURVNET_SET
argument_list|(
name|TD_TO_VNET
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
comment|/* XXX ENOENT should be impossible, since the priv 		 * is now created in the open */
return|return
operator|(
name|error
operator|==
name|ENOENT
condition|?
name|ENXIO
else|:
name|error
operator|)
return|;
block|}
name|nmr
operator|->
name|nr_name
index|[
sizeof|sizeof
argument_list|(
name|nmr
operator|->
name|nr_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* truncate name */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NIOCGINFO
case|:
comment|/* return capabilities etc */
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|!=
name|NETMAP_API
condition|)
block|{
name|D
argument_list|(
literal|"API mismatch got %d have %d"
argument_list|,
name|nmr
operator|->
name|nr_version
argument_list|,
name|NETMAP_API
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nmr
operator|->
name|nr_cmd
operator|==
name|NETMAP_BDG_LIST
condition|)
block|{
name|error
operator|=
name|netmap_bdg_ctl
argument_list|(
name|nmr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* update configuration */
name|error
operator|=
name|netmap_get_memory
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"get_memory returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* memsize is always valid */
name|nmr
operator|->
name|nr_memsize
operator|=
name|nm_mem
operator|.
name|nm_totalsize
expr_stmt|;
name|nmr
operator|->
name|nr_offset
operator|=
literal|0
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|nmr
operator|->
name|nr_tx_slots
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* just get memory info */
break|break;
comment|/* lock because get_ifp and update_config see na->refcount */
name|NMA_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
comment|/* get a refcount */
if|if
condition|(
name|error
condition|)
block|{
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap_adapter */
name|netmap_update_config
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
break|break;
case|case
name|NIOCREGIF
case|:
if|if
condition|(
name|nmr
operator|->
name|nr_version
operator|!=
name|NETMAP_API
condition|)
block|{
name|nmr
operator|->
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* possibly attach/detach NIC and VALE switch */
name|i
operator|=
name|nmr
operator|->
name|nr_cmd
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NETMAP_BDG_ATTACH
operator|||
name|i
operator|==
name|NETMAP_BDG_DETACH
condition|)
block|{
name|error
operator|=
name|netmap_bdg_ctl
argument_list|(
name|nmr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"nr_cmd must be 0 not %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* ensure allocators are ready */
name|error
operator|=
name|netmap_get_memory
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"get_memory returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* protect access to priv from concurrent NIOCREGIF */
name|NMA_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|np_ifp
operator|!=
name|NULL
condition|)
block|{
comment|/* thread already registered */
name|error
operator|=
name|netmap_set_ringid
argument_list|(
name|priv
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|)
expr_stmt|;
name|unlock_out
label|:
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* find the interface and a reference */
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
goto|goto
name|unlock_out
goto|;
elseif|else
if|if
condition|(
name|NETMAP_OWNED_BY_KERN
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|unlock_out
goto|;
block|}
name|nifp
operator|=
name|netmap_do_regif
argument_list|(
name|priv
argument_list|,
name|ifp
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nifp
condition|)
block|{
comment|/* reg. failed, release priv and ref */
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* return the refcount */
name|priv
operator|->
name|np_ifp
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|np_nifp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|unlock_out
goto|;
block|}
comment|/* the following assignment is a commitment. 		 * Readers (i.e., poll and *SYNC) check for 		 * np_nifp != NULL without locking 		 */
name|wmb
argument_list|()
expr_stmt|;
comment|/* make sure previous writes are visible to all CPUs */
name|priv
operator|->
name|np_nifp
operator|=
name|nifp
expr_stmt|;
name|NMA_UNLOCK
argument_list|()
expr_stmt|;
comment|/* return the offset of the netmap_if object */
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|na
operator|->
name|num_tx_desc
expr_stmt|;
name|nmr
operator|->
name|nr_memsize
operator|=
name|nm_mem
operator|.
name|nm_totalsize
expr_stmt|;
name|nmr
operator|->
name|nr_offset
operator|=
name|netmap_if_offset
argument_list|(
name|nifp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIOCUNREGIF
case|:
comment|// XXX we have no data here ?
name|D
argument_list|(
literal|"deprecated, data is %p"
argument_list|,
name|nmr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NIOCTXSYNC
case|:
case|case
name|NIOCRXSYNC
case|:
name|nifp
operator|=
name|priv
operator|->
name|np_nifp
expr_stmt|;
if|if
condition|(
name|nifp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|rmb
argument_list|()
expr_stmt|;
comment|/* make sure following reads are not from cache */
name|ifp
operator|=
name|priv
operator|->
name|np_ifp
expr_stmt|;
comment|/* we have a reference */
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"Internal error: nifp != NULL&& ifp == NULL"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
if|if
condition|(
name|priv
operator|->
name|np_qfirst
operator|==
name|NETMAP_SW_RING
condition|)
block|{
comment|/* host rings */
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
name|netmap_sync_to_host
argument_list|(
name|na
argument_list|)
expr_stmt|;
else|else
name|netmap_sync_from_host
argument_list|(
name|na
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* find the last ring to scan */
name|lim
operator|=
name|priv
operator|->
name|np_qlast
expr_stmt|;
if|if
condition|(
name|lim
operator|==
name|NETMAP_HW_RING
condition|)
name|lim
operator|=
operator|(
name|cmd
operator|==
name|NIOCTXSYNC
operator|)
condition|?
name|na
operator|->
name|num_tx_rings
else|:
name|na
operator|->
name|num_rx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmd
operator|==
name|NIOCTXSYNC
condition|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"pre txsync ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_txsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
literal|1
comment|/* do lock */
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"post txsync ring %d cur %d hwcur %d"
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|na
operator|->
name|nm_rxsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
literal|1
comment|/* do lock */
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|__FreeBSD__
case|case
name|BIOCIMMEDIATE
case|:
case|case
name|BIOCGHDRCMPLT
case|:
case|case
name|BIOCSHDRCMPLT
case|:
case|case
name|BIOCSSEESENT
case|:
name|D
argument_list|(
literal|"ignore BIOCIMMEDIATE/BIOCSHDRCMPLT/BIOCSHDRCMPLT/BIOCSSEESENT"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* allow device-specific ioctls */
block|{
name|struct
name|socket
name|so
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|so
argument_list|,
sizeof|sizeof
argument_list|(
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|get_ifp
argument_list|(
name|nmr
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
comment|/* keep reference */
if|if
condition|(
name|error
condition|)
break|break;
name|so
operator|.
name|so_vnet
operator|=
name|ifp
operator|->
name|if_vnet
expr_stmt|;
comment|// so->so_proto not null.
name|error
operator|=
name|ifioctl
argument_list|(
operator|&
name|so
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|nm_if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
comment|/* linux */
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
comment|/* linux */
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * select(2) and poll(2) handlers for the "netmap" device.  *  * Can be called for one or more queues.  * Return true the event mask corresponding to ready events.  * If there are no ready events, do a selrecord on either individual  * selfd or on the global one.  * Device-dependent parts (locking and sync of tx/rx rings)  * are done through callbacks.  *  * On linux, arguments are really pwait, the poll table, and 'td' is struct file *  * The first one is remapped to pwait as selrecord() uses the name as an  * hidden argument.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|u_int
name|core_lock
decl_stmt|,
name|i
decl_stmt|,
name|check_all
decl_stmt|,
name|want_tx
decl_stmt|,
name|want_rx
decl_stmt|,
name|revents
init|=
literal|0
decl_stmt|;
name|u_int
name|lim_tx
decl_stmt|,
name|lim_rx
decl_stmt|,
name|host_forwarded
init|=
literal|0
decl_stmt|;
name|struct
name|mbq
name|q
init|=
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
enum|enum
block|{
name|NO_CL
block|,
name|NEED_CL
block|,
name|LOCKED_CL
block|}
enum|;
comment|/* see below */
name|void
modifier|*
name|pwait
init|=
name|dev
decl_stmt|;
comment|/* linux compatibility */
operator|(
name|void
operator|)
name|pwait
expr_stmt|;
if|if
condition|(
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv
argument_list|)
operator|!=
literal|0
operator|||
name|priv
operator|==
name|NULL
condition|)
return|return
name|POLLERR
return|;
if|if
condition|(
name|priv
operator|->
name|np_nifp
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"No if registered"
argument_list|)
expr_stmt|;
return|return
name|POLLERR
return|;
block|}
name|rmb
argument_list|()
expr_stmt|;
comment|/* make sure following reads are not from cache */
name|ifp
operator|=
name|priv
operator|->
name|np_ifp
expr_stmt|;
comment|// XXX check for deleting() ?
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
operator|==
literal|0
condition|)
return|return
name|POLLERR
return|;
if|if
condition|(
name|netmap_verbose
operator|&
literal|0x8000
condition|)
name|D
argument_list|(
literal|"device %s events 0x%x"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|events
argument_list|)
expr_stmt|;
name|want_tx
operator|=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
name|want_rx
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* retrieve netmap adapter */
name|lim_tx
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|lim_rx
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
comment|/* how many queues we are scanning */
if|if
condition|(
name|priv
operator|->
name|np_qfirst
operator|==
name|NETMAP_SW_RING
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|np_txpoll
operator|||
name|want_tx
condition|)
block|{
comment|/* push any packets up, then we are always ready */
name|netmap_sync_to_host
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|revents
operator||=
name|want_tx
expr_stmt|;
block|}
if|if
condition|(
name|want_rx
condition|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|lim_rx
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|==
literal|0
condition|)
name|netmap_sync_from_host
argument_list|(
name|na
argument_list|,
name|td
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
block|}
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
comment|/* if we are in transparent mode, check also the host rx ring */
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|lim_rx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|np_qlast
operator|==
name|NETMAP_HW_RING
operator|)
comment|// XXX check_all
operator|&&
name|want_rx
operator|&&
operator|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
operator|)
condition|)
block|{
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|==
literal|0
condition|)
name|netmap_sync_from_host
argument_list|(
name|na
argument_list|,
name|td
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
name|revents
operator||=
name|want_rx
expr_stmt|;
block|}
comment|/* 	 * check_all is set if the card has more than one queue and 	 * the client is polling all of them. If true, we sleep on 	 * the "global" selfd, otherwise we sleep on individual selfd 	 * (we can only sleep on one of them per direction). 	 * The interrupt routine in the driver should always wake on 	 * the individual selfd, and also on the global one if the card 	 * has more than one ring. 	 * 	 * If the card has only one lock, we just use that. 	 * If the card has separate ring locks, we just use those 	 * unless we are doing check_all, in which case the whole 	 * loop is wrapped by the global lock. 	 * We acquire locks only when necessary: if poll is called 	 * when buffers are available, we can just return without locks. 	 * 	 * rxsync() is only called if we run out of buffers on a POLLIN. 	 * txsync() is called if we run out of buffers on POLLOUT, or 	 * there are pending packets to send. The latter can be disabled 	 * passing NETMAP_NO_TX_POLL in the NIOCREG call. 	 */
name|check_all
operator|=
operator|(
name|priv
operator|->
name|np_qlast
operator|==
name|NETMAP_HW_RING
operator|)
operator|&&
operator|(
name|lim_tx
operator|>
literal|1
operator|||
name|lim_rx
operator|>
literal|1
operator|)
expr_stmt|;
comment|/* 	 * core_lock indicates what to do with the core lock. 	 * The core lock is used when either the card has no individual 	 * locks, or it has individual locks but we are cheking all 	 * rings so we need the core lock to avoid missing wakeup events. 	 * 	 * It has three possible states: 	 * NO_CL	we don't need to use the core lock, e.g. 	 *		because we are protected by individual locks. 	 * NEED_CL	we need the core lock. In this case, when we 	 *		call the lock routine, move to LOCKED_CL 	 *		to remember to release the lock once done. 	 * LOCKED_CL	core lock is set, so we need to release it. 	 */
name|core_lock
operator|=
operator|(
name|check_all
operator|||
operator|!
name|na
operator|->
name|separate_locks
operator|)
condition|?
name|NEED_CL
else|:
name|NO_CL
expr_stmt|;
ifdef|#
directive|ifdef
name|NM_BRIDGE
comment|/* the bridge uses separate locks */
if|if
condition|(
name|na
operator|->
name|nm_register
operator|==
name|bdg_netmap_reg
condition|)
block|{
name|ND
argument_list|(
literal|"not using core lock for %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|core_lock
operator|=
name|NO_CL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NM_BRIDGE */
if|if
condition|(
name|priv
operator|->
name|np_qlast
operator|!=
name|NETMAP_HW_RING
condition|)
block|{
name|lim_tx
operator|=
name|lim_rx
operator|=
name|priv
operator|->
name|np_qlast
expr_stmt|;
block|}
comment|/* 	 * We start with a lock free round which is good if we have 	 * data available. If this fails, then lock and call the sync 	 * routines. 	 */
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|want_rx
operator|&&
name|i
operator|<
name|lim_rx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_rx
expr_stmt|;
name|want_rx
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|want_tx
operator|&&
name|i
operator|<
name|lim_tx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
comment|/* also breaks the loop */
block|}
block|}
comment|/* 	 * If we to push packets out (priv->np_txpoll) or want_tx is 	 * still set, we do need to run the txsync calls (on all rings, 	 * to avoid that the tx rings stall). 	 */
if|if
condition|(
name|priv
operator|->
name|np_txpoll
operator|||
name|want_tx
condition|)
block|{
name|flush_tx
label|:
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim_tx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
comment|/* 			 * Skip the current ring if want_tx == 0 			 * (we have already done a successful sync on 			 * a previous ring) AND kring->cur == kring->hwcur 			 * (there are no pending transmissions for this ring). 			 */
if|if
condition|(
operator|!
name|want_tx
operator|&&
name|kring
operator|->
name|ring
operator|->
name|cur
operator|==
name|kring
operator|->
name|nr_hwcur
condition|)
continue|continue;
if|if
condition|(
name|core_lock
operator|==
name|NEED_CL
condition|)
block|{
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|core_lock
operator|=
name|LOCKED_CL
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_TX_LOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_TXSYNC
condition|)
name|D
argument_list|(
literal|"send %d on %s %d"
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_txsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
literal|0
comment|/* no lock */
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
comment|/* Check avail/call selrecord only if called with POLLOUT */
if|if
condition|(
name|want_tx
condition|)
block|{
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
comment|/* stop at the first ring. We don't risk 					 * starvation. 					 */
name|revents
operator||=
name|want_tx
expr_stmt|;
name|want_tx
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|check_all
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_TX_UNLOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * now if want_rx is still set we need to lock and rxsync. 	 * Do it on all rings because otherwise we starve. 	 */
if|if
condition|(
name|want_rx
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|np_qfirst
init|;
name|i
operator|<
name|lim_rx
condition|;
name|i
operator|++
control|)
block|{
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|core_lock
operator|==
name|NEED_CL
condition|)
block|{
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|core_lock
operator|=
name|LOCKED_CL
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_RX_LOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
condition|)
block|{
name|ND
argument_list|(
literal|10
argument_list|,
literal|"forwarding some buffers up %d to %d"
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|netmap_grab_packets
argument_list|(
name|kring
argument_list|,
operator|&
name|q
argument_list|,
name|netmap_fwd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|nm_rxsync
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|,
literal|0
comment|/* no lock */
argument_list|)
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
if|if
condition|(
name|netmap_no_timestamp
operator|==
literal|0
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_TIMESTAMP
condition|)
block|{
name|microtime
argument_list|(
operator|&
name|kring
operator|->
name|ring
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kring
operator|->
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
name|revents
operator||=
name|want_rx
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|check_all
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kring
operator|->
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_RX_UNLOCK
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|check_all
operator|&&
name|revents
operator|==
literal|0
condition|)
block|{
comment|/* signal on the global queue */
if|if
condition|(
name|want_tx
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|na
operator|->
name|tx_si
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_rx
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|na
operator|->
name|rx_si
argument_list|)
expr_stmt|;
block|}
comment|/* forward host to the netmap ring */
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|lim_rx
index|]
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwavail
operator|>
literal|0
condition|)
name|ND
argument_list|(
literal|"host rx %d has %d packets"
argument_list|,
name|lim_rx
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|np_qlast
operator|==
name|NETMAP_HW_RING
operator|)
comment|// XXX check_all
operator|&&
operator|(
name|netmap_fwd
operator|||
name|kring
operator|->
name|ring
operator|->
name|flags
operator|&
name|NR_FORWARD
operator|)
operator|&&
name|kring
operator|->
name|nr_hwavail
operator|>
literal|0
operator|&&
operator|!
name|host_forwarded
condition|)
block|{
if|if
condition|(
name|core_lock
operator|==
name|NEED_CL
condition|)
block|{
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|core_lock
operator|=
name|LOCKED_CL
expr_stmt|;
block|}
name|netmap_sw_to_nic
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|host_forwarded
operator|=
literal|1
expr_stmt|;
comment|/* prevent another pass */
name|want_rx
operator|=
literal|0
expr_stmt|;
goto|goto
name|flush_tx
goto|;
block|}
if|if
condition|(
name|core_lock
operator|==
name|LOCKED_CL
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|.
name|head
condition|)
name|netmap_send_up
argument_list|(
name|na
operator|->
name|ifp
argument_list|,
name|q
operator|.
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------- driver support routines ------*/
end_comment

begin_comment
comment|/*  * default lock wrapper.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_lock_wrapper
parameter_list|(
name|struct
name|ifnet
modifier|*
name|dev
parameter_list|,
name|int
name|what
parameter_list|,
name|u_int
name|queueid
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
ifdef|#
directive|ifdef
name|linux
comment|/* some system do not need lock on register */
case|case
name|NETMAP_REG_LOCK
case|:
case|case
name|NETMAP_REG_UNLOCK
case|:
break|break;
endif|#
directive|endif
comment|/* linux */
case|case
name|NETMAP_CORE_LOCK
case|:
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_CORE_UNLOCK
case|:
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_TX_LOCK
case|:
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_TX_UNLOCK
case|:
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_RX_LOCK
case|:
name|mtx_lock
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_RX_UNLOCK
case|:
name|mtx_unlock
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|queueid
index|]
operator|.
name|q_lock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize a ``netmap_adapter`` object created by driver on attach.  * We allocate a block of memory with room for a struct netmap_adapter  * plus two sets of N+2 struct netmap_kring (where N is the number  * of hardware rings):  * krings	0..N-1	are for the hardware queues.  * kring	N	is for the host stack queue  * kring	N+1	is only used for the selinfo for all queues.  * Return 0 on success, ENOMEM otherwise.  *  * By default the receive and transmit adapter ring counts are both initialized  * to num_queues.  na->num_tx_rings can be set for cards with different tx/rx  * setups.  */
end_comment

begin_function
name|int
name|netmap_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|arg
parameter_list|,
name|int
name|num_queues
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|arg
condition|?
name|arg
operator|->
name|ifp
else|:
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
name|ifp
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|len
operator|=
name|nma_is_vp
argument_list|(
name|arg
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
else|:
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
operator|*
literal|2
expr_stmt|;
name|na
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|WNA
argument_list|(
name|ifp
argument_list|)
operator|=
name|na
expr_stmt|;
operator|*
name|na
operator|=
operator|*
name|arg
expr_stmt|;
comment|/* copy everything, trust the driver to not pass junk */
name|NETMAP_SET_CAPABLE
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|num_tx_rings
operator|==
literal|0
condition|)
name|na
operator|->
name|num_tx_rings
operator|=
name|num_queues
expr_stmt|;
name|na
operator|->
name|num_rx_rings
operator|=
name|num_queues
expr_stmt|;
name|na
operator|->
name|refcount
operator|=
name|na
operator|->
name|na_single
operator|=
name|na
operator|->
name|na_multi
operator|=
literal|0
expr_stmt|;
comment|/* Core lock initialized here, others after netmap_if_new. */
name|mtx_init
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|,
literal|"netmap core lock"
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|nm_lock
operator|==
name|NULL
condition|)
block|{
name|ND
argument_list|(
literal|"using default locks for %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
operator|=
name|netmap_lock_wrapper
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|linux
if|if
condition|(
name|ifp
operator|->
name|netdev_ops
condition|)
block|{
name|ND
argument_list|(
literal|"netdev_ops %p"
argument_list|,
name|ifp
operator|->
name|netdev_ops
argument_list|)
expr_stmt|;
comment|/* prepare a clone of the netdev ops */
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|28
argument_list|)
name|na
operator|->
name|nm_ndo
operator|.
name|ndo_start_xmit
operator|=
name|ifp
operator|->
name|netdev_ops
expr_stmt|;
else|#
directive|else
name|na
operator|->
name|nm_ndo
operator|=
operator|*
name|ifp
operator|->
name|netdev_ops
expr_stmt|;
endif|#
directive|endif
block|}
name|na
operator|->
name|nm_ndo
operator|.
name|ndo_start_xmit
operator|=
name|linux_netmap_start
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|nma_is_vp
argument_list|(
name|arg
argument_list|)
condition|)
name|netmap_attach_sw
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"success for %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|D
argument_list|(
literal|"fail, arg %p ifp %p na %p"
argument_list|,
name|arg
argument_list|,
name|ifp
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|netmap_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|na
condition|?
name|EINVAL
else|:
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the allocated memory linked to the given ``netmap_adapter``  * object.  */
end_comment

begin_function
name|void
name|netmap_detach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|na
condition|)
return|return;
name|mtx_destroy
argument_list|(
operator|&
name|na
operator|->
name|core_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|tx_rings
condition|)
block|{
comment|/* XXX should not happen */
name|D
argument_list|(
literal|"freeing leftover tx_rings"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|na
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|na
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|WNA
argument_list|(
name|ifp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|na
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|int
name|nm_bdg_flush
parameter_list|(
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* we don't need to lock myself */
end_comment

begin_function
specifier|static
name|int
name|bdg_netmap_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|SWNA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
init|=
name|na
operator|->
name|rx_rings
index|[
literal|0
index|]
operator|.
name|nkr_ft
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NMB
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
literal|0
index|]
operator|.
name|ring
operator|->
name|slot
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|u_int
name|len
init|=
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|na
operator|->
name|na_bdg
condition|)
comment|/* SWNA is not configured to be attached */
return|return
name|EBUSY
return|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ft
operator|->
name|ft_flags
operator|=
literal|0
expr_stmt|;
comment|// XXX could be indirect ?
name|ft
operator|->
name|ft_len
operator|=
name|len
expr_stmt|;
name|ft
operator|->
name|ft_buf
operator|=
name|buf
expr_stmt|;
name|ft
operator|->
name|ft_next
operator|=
name|NM_BDG_BATCH
expr_stmt|;
comment|// XXX is it needed ?
name|nm_bdg_flush
argument_list|(
name|ft
argument_list|,
literal|1
argument_list|,
name|na
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* release the mbuf in either cases of success or failure. As an 	 * alternative, put the mbuf in a free list and free the list 	 * only when really necessary. 	 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Intercept packets from the network stack and pass them  * to netmap as incoming packets on the 'software' ring.  * We are not locked when called.  */
end_comment

begin_function
name|int
name|netmap_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|na
operator|->
name|num_rx_rings
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|len
init|=
name|MBUF_LEN
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|u_int
name|error
init|=
name|EBUSY
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"%s packet %d len %d from the stack"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|NETMAP_BUF_SIZE
condition|)
block|{
comment|/* too long for us */
name|D
argument_list|(
literal|"%s from_host, drop packet size %d> %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|len
argument_list|,
name|NETMAP_BUF_SIZE
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|na
operator|->
name|na_bdg
condition|)
return|return
name|bdg_netmap_start
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
return|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nr_hwavail
operator|>=
name|lim
condition|)
block|{
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"stack ring %s full\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* no space */
block|}
comment|/* compute the insert position */
name|i
operator|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|lim
condition|)
name|i
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
name|slot
operator|=
operator|&
name|kring
operator|->
name|ring
operator|->
name|slot
index|[
name|i
index|]
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|NMB
argument_list|(
name|slot
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
name|kring
operator|->
name|nkr_slot_flags
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|++
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&
name|NM_VERB_HOST
condition|)
name|D
argument_list|(
literal|"wake up host ring %s %d"
argument_list|,
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* release the mbuf in either cases of success or failure. As an 	 * alternative, put the mbuf in a free list and free the list 	 * only when really necessary. 	 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * netmap_reset() is called by the driver routines when reinitializing  * a ring. The driver is in charge of locking to protect the kring.  * If netmap mode is not set just return NULL.  */
end_comment

begin_function
name|struct
name|netmap_slot
modifier|*
name|netmap_reset
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|enum
name|txrx
name|tx
parameter_list|,
name|int
name|n
parameter_list|,
name|u_int
name|new_cur
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|int
name|new_hwofs
decl_stmt|,
name|lim
decl_stmt|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* no netmap support here */
if|if
condition|(
operator|!
operator|(
name|na
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* nothing to reinitialize */
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|na
operator|->
name|num_tx_rings
condition|)
return|return
name|NULL
return|;
name|kring
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|n
expr_stmt|;
name|new_hwofs
operator|=
name|kring
operator|->
name|nr_hwcur
operator|-
name|new_cur
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|n
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
return|return
name|NULL
return|;
name|kring
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|n
expr_stmt|;
name|new_hwofs
operator|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
operator|-
name|new_cur
expr_stmt|;
block|}
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new_hwofs
operator|>
name|lim
condition|)
name|new_hwofs
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
comment|/* Alwayws set the new offset value and realign the ring. */
name|kring
operator|->
name|nkr_hwofs
operator|=
name|new_hwofs
expr_stmt|;
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
name|kring
operator|->
name|nr_hwavail
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
name|ND
argument_list|(
literal|10
argument_list|,
literal|"new hwofs %d on %s %s[%d]"
argument_list|,
name|kring
operator|->
name|nkr_hwofs
argument_list|,
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|tx
operator|==
name|NR_TX
condition|?
literal|"TX"
else|:
literal|"RX"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|// def linux
comment|/* XXX check that the mappings are correct */
comment|/* need ring_nr, adapter->pdev, direction */
block|buffer_info->dma = dma_map_single(&pdev->dev, addr, adapter->rx_buffer_len, DMA_FROM_DEVICE); 	if (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)) { 		D("error mapping rx netmap buffer %d", i);
comment|// XXX fix error handling
block|}
endif|#
directive|endif
comment|/* linux */
comment|/* 	 * Wakeup on the individual and global lock 	 * We do the wakeup here, but the ring is not yet reconfigured. 	 * However, we are under lock so there are no races. 	 */
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
name|tx
operator|==
name|NR_TX
condition|?
operator|&
name|na
operator|->
name|tx_si
else|:
operator|&
name|na
operator|->
name|rx_si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
return|return
name|kring
operator|->
name|ring
operator|->
name|slot
return|;
block|}
end_function

begin_comment
comment|/* returns the next position in the ring */
end_comment

begin_function
specifier|static
name|int
name|nm_bdg_preflush
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|u_int
name|end
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
init|=
name|kring
operator|->
name|nkr_ft
decl_stmt|;
name|u_int
name|j
init|=
name|kring
operator|->
name|nr_hwcur
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
name|ft_i
init|=
literal|0
decl_stmt|;
comment|/* start from 0 */
for|for
control|(
init|;
name|likely
argument_list|(
name|j
operator|!=
name|end
argument_list|)
condition|;
name|j
operator|=
name|unlikely
argument_list|(
name|j
operator|==
name|lim
argument_list|)
condition|?
literal|0
else|:
name|j
operator|+
literal|1
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|j
index|]
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NMB
argument_list|(
name|slot
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_len
operator|=
name|slot
operator|->
name|len
decl_stmt|;
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_flags
operator|=
name|slot
operator|->
name|flags
expr_stmt|;
name|ND
argument_list|(
literal|"flags is 0x%x"
argument_list|,
name|slot
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* this slot goes into a list so initialize the link field */
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_next
operator|=
name|NM_BDG_BATCH
expr_stmt|;
comment|/* equivalent to NULL */
if|if
condition|(
name|unlikely
argument_list|(
name|len
operator|<
literal|14
argument_list|)
condition|)
continue|continue;
name|buf
operator|=
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_buf
operator|=
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_INDIRECT
operator|)
condition|?
operator|*
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|buf
operator|)
else|:
name|buf
expr_stmt|;
name|prefetch
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|++
name|ft_i
operator|==
name|netmap_bridge
argument_list|)
condition|)
name|ft_i
operator|=
name|nm_bdg_flush
argument_list|(
name|ft
argument_list|,
name|ft_i
argument_list|,
name|na
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ft_i
condition|)
name|ft_i
operator|=
name|nm_bdg_flush
argument_list|(
name|ft
argument_list|,
name|ft_i
argument_list|,
name|na
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
return|return
name|j
return|;
block|}
end_function

begin_comment
comment|/*  * Pass packets from nic to the bridge. Must be called with  * proper locks on the source interface.  * Note, no user process can access this NIC so we can ignore  * the info in the 'ring'.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_nic_to_bdg
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|ring_nr
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|ring_nr
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
comment|/* fetch packets that have arrived */
name|na
operator|->
name|nm_rxsync
argument_list|(
name|ifp
argument_list|,
name|ring_nr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX we don't count reserved, but it should be 0 */
name|j
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|k
operator|=
name|j
operator|+
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|lim
condition|)
name|k
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|j
operator|&&
name|netmap_verbose
condition|)
block|{
name|D
argument_list|(
literal|"how strange, interrupt with no packets on %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return;
block|}
name|j
operator|=
name|nm_bdg_preflush
argument_list|(
name|na
argument_list|,
name|ring_nr
argument_list|,
name|kring
argument_list|,
name|k
argument_list|)
expr_stmt|;
comment|/* we consume everything, but we cannot update kring directly 	 * because the nic may have destroyed the info in the NIC ring. 	 * So we need to call rxsync again to restore it. 	 */
name|ring
operator|->
name|cur
operator|=
name|j
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
literal|0
expr_stmt|;
name|na
operator|->
name|nm_rxsync
argument_list|(
name|ifp
argument_list|,
name|ring_nr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Default functions to handle rx/tx interrupts  * we have 4 cases:  * 1 ring, single lock:  *	lock(core); wake(i=0); unlock(core)  * N rings, single lock:  *	lock(core); wake(i); wake(N+1) unlock(core)  * 1 ring, separate locks: (i=0)  *	lock(i); wake(i); unlock(i)  * N rings, separate locks:  *	lock(i); wake(i); unlock(i); lock(core) wake(N+1) unlock(core)  * work_done is non-null on the RX path.  *  * The 'q' argument also includes flag to tell whether the queue is  * already locked on enter, and whether it should remain locked on exit.  * This helps adapting to different defaults in drivers and OSes.  */
end_comment

begin_function
name|int
name|netmap_rx_irq
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|q
parameter_list|,
name|int
modifier|*
name|work_done
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|r
decl_stmt|;
name|NM_SELINFO_T
modifier|*
name|main_wq
decl_stmt|;
name|int
name|locktype
decl_stmt|,
name|unlocktype
decl_stmt|,
name|nic_to_bridge
decl_stmt|,
name|lock
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
return|return
literal|0
return|;
name|lock
operator|=
name|q
operator|&
operator|(
name|NETMAP_LOCKED_ENTER
operator||
name|NETMAP_LOCKED_EXIT
operator|)
expr_stmt|;
name|q
operator|=
name|q
operator|&
name|NETMAP_RING_MASK
expr_stmt|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"received %s queue %d"
argument_list|,
name|work_done
condition|?
literal|"RX"
else|:
literal|"TX"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|na
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|na_flags
operator|&
name|NAF_SKIP_INTR
condition|)
block|{
name|ND
argument_list|(
literal|"use regular interrupt"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|work_done
condition|)
block|{
comment|/* RX path */
if|if
condition|(
name|q
operator|>=
name|na
operator|->
name|num_rx_rings
condition|)
return|return
literal|0
return|;
comment|// not a physical queue
name|r
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|q
expr_stmt|;
name|r
operator|->
name|nr_kflags
operator||=
name|NKR_PENDINTR
expr_stmt|;
name|main_wq
operator|=
operator|(
name|na
operator|->
name|num_rx_rings
operator|>
literal|1
operator|)
condition|?
operator|&
name|na
operator|->
name|rx_si
else|:
name|NULL
expr_stmt|;
comment|/* set a flag if the NIC is attached to a VALE switch */
name|nic_to_bridge
operator|=
operator|(
name|na
operator|->
name|na_bdg
operator|!=
name|NULL
operator|)
expr_stmt|;
name|locktype
operator|=
name|NETMAP_RX_LOCK
expr_stmt|;
name|unlocktype
operator|=
name|NETMAP_RX_UNLOCK
expr_stmt|;
block|}
else|else
block|{
comment|/* TX path */
if|if
condition|(
name|q
operator|>=
name|na
operator|->
name|num_tx_rings
condition|)
return|return
literal|0
return|;
comment|// not a physical queue
name|r
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|q
expr_stmt|;
name|main_wq
operator|=
operator|(
name|na
operator|->
name|num_tx_rings
operator|>
literal|1
operator|)
condition|?
operator|&
name|na
operator|->
name|tx_si
else|:
name|NULL
expr_stmt|;
name|work_done
operator|=
operator|&
name|q
expr_stmt|;
comment|/* dummy */
name|nic_to_bridge
operator|=
literal|0
expr_stmt|;
name|locktype
operator|=
name|NETMAP_TX_LOCK
expr_stmt|;
name|unlocktype
operator|=
name|NETMAP_TX_UNLOCK
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|->
name|separate_locks
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|lock
operator|&
name|NETMAP_LOCKED_ENTER
operator|)
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|locktype
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* If a NIC is attached to a bridge, flush packets 		 * (and no need to wakeup anyone). Otherwise, wakeup 		 * possible processes waiting for packets. 		 */
if|if
condition|(
name|nic_to_bridge
condition|)
name|netmap_nic_to_bdg
argument_list|(
name|ifp
argument_list|,
name|q
argument_list|)
expr_stmt|;
else|else
name|selwakeuppri
argument_list|(
operator|&
name|r
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|unlocktype
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_wq
operator|&&
operator|!
name|nic_to_bridge
condition|)
block|{
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
name|main_wq
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* lock the queue again if requested */
if|if
condition|(
name|lock
operator|&
name|NETMAP_LOCKED_EXIT
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|locktype
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|lock
operator|&
name|NETMAP_LOCKED_ENTER
operator|)
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic_to_bridge
condition|)
name|netmap_nic_to_bdg
argument_list|(
name|ifp
argument_list|,
name|q
argument_list|)
expr_stmt|;
else|else
block|{
name|selwakeuppri
argument_list|(
operator|&
name|r
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_wq
condition|)
name|selwakeuppri
argument_list|(
name|main_wq
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|lock
operator|&
name|NETMAP_LOCKED_EXIT
operator|)
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_CORE_UNLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|work_done
operator|=
literal|1
expr_stmt|;
comment|/* do not fire napi again */
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_comment
comment|/* linux-specific routines */
end_comment

begin_comment
comment|/*  * Remap linux arguments into the FreeBSD call.  * - pwait is the poll table, passed as 'dev';  *   If pwait == NULL someone else already woke up before. We can report  *   events but they are filtered upstream.  *   If pwait != NULL, then pwait->key contains the list of events.  * - events is computed from pwait as above.  * - file is passed as 'td';  */
end_comment

begin_function
specifier|static
name|u_int
name|linux_netmap_poll
parameter_list|(
name|struct
name|file
modifier|*
name|file
parameter_list|,
name|struct
name|poll_table_struct
modifier|*
name|pwait
parameter_list|)
block|{
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|28
argument_list|)
name|int
name|events
init|=
name|POLLIN
operator||
name|POLLOUT
decl_stmt|;
comment|/* XXX maybe... */
elif|#
directive|elif
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|3
operator|,
literal|4
operator|,
literal|0
argument_list|)
name|int
name|events
init|=
name|pwait
condition|?
name|pwait
operator|->
name|key
else|:
name|POLLIN
operator||
name|POLLOUT
decl_stmt|;
else|#
directive|else
comment|/* in 3.4.0 field 'key' was renamed to '_key' */
name|int
name|events
init|=
name|pwait
condition|?
name|pwait
operator|->
name|_key
else|:
name|POLLIN
operator||
name|POLLOUT
decl_stmt|;
endif|#
directive|endif
return|return
name|netmap_poll
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pwait
argument_list|,
name|events
argument_list|,
operator|(
name|void
operator|*
operator|)
name|file
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|linux_netmap_mmap
parameter_list|(
name|struct
name|file
modifier|*
name|f
parameter_list|,
name|struct
name|vm_area_struct
modifier|*
name|vma
parameter_list|)
block|{
name|int
name|lut_skip
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|user_skip
init|=
literal|0
decl_stmt|;
name|struct
name|lut_entry
modifier|*
name|l_entry
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|off
decl_stmt|,
name|tomap
decl_stmt|;
comment|/* 	 * vma->vm_start: start of mapping user address space 	 * vma->vm_end: end of the mapping user address space 	 * vma->vm_pfoff: offset of first page in the device 	 */
comment|// XXX security checks
name|error
operator|=
name|netmap_get_memory
argument_list|(
name|f
operator|->
name|private_data
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"get_memory returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
name|off
operator|=
name|vma
operator|->
name|vm_pgoff
operator|<<
name|PAGE_SHIFT
expr_stmt|;
comment|/* offset in bytes */
name|tomap
operator|=
name|vma
operator|->
name|vm_end
operator|-
name|vma
operator|->
name|vm_start
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NETMAP_POOLS_NR
condition|;
name|i
operator|++
control|)
block|{
comment|/* loop through obj_pools */
specifier|const
name|struct
name|netmap_obj_pool
modifier|*
name|p
init|=
operator|&
name|nm_mem
operator|.
name|pools
index|[
name|i
index|]
decl_stmt|;
comment|/* 		 * In each pool memory is allocated in clusters 		 * of size _clustsize, each containing clustentries 		 * entries. For each object k we already store the 		 * vtophys mapping in lut[k] so we use that, scanning 		 * the lut[] array in steps of clustentries, 		 * and we map each cluster (not individual pages, 		 * it would be overkill -- XXX slow ? 20130415). 		 */
comment|/* 		 * We interpret vm_pgoff as an offset into the whole 		 * netmap memory, as if all clusters where contiguous. 		 */
for|for
control|(
name|lut_skip
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p
operator|->
name|_numclusters
condition|;
name|j
operator|++
operator|,
name|lut_skip
operator|+=
name|p
operator|->
name|clustentries
control|)
block|{
name|unsigned
name|long
name|paddr
decl_stmt|,
name|mapsize
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|_clustsize
operator|<=
name|off
condition|)
block|{
name|off
operator|-=
name|p
operator|->
name|_clustsize
expr_stmt|;
continue|continue;
block|}
name|l_entry
operator|=
operator|&
name|p
operator|->
name|lut
index|[
name|lut_skip
index|]
expr_stmt|;
comment|/* first obj in the cluster */
name|paddr
operator|=
name|l_entry
operator|->
name|paddr
operator|+
name|off
expr_stmt|;
name|mapsize
operator|=
name|p
operator|->
name|_clustsize
operator|-
name|off
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mapsize
operator|>
name|tomap
condition|)
name|mapsize
operator|=
name|tomap
expr_stmt|;
name|ND
argument_list|(
literal|"remap_pfn_range(%lx, %lx, %lx)"
argument_list|,
name|vma
operator|->
name|vm_start
operator|+
name|user_skip
argument_list|,
name|paddr
operator|>>
name|PAGE_SHIFT
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|remap_pfn_range
argument_list|(
name|vma
argument_list|,
name|vma
operator|->
name|vm_start
operator|+
name|user_skip
argument_list|,
name|paddr
operator|>>
name|PAGE_SHIFT
argument_list|,
name|mapsize
argument_list|,
name|vma
operator|->
name|vm_page_prot
argument_list|)
condition|)
return|return
operator|-
name|EAGAIN
return|;
comment|// XXX check return value
name|user_skip
operator|+=
name|mapsize
expr_stmt|;
name|tomap
operator|-=
name|mapsize
expr_stmt|;
if|if
condition|(
name|tomap
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|netdev_tx_t
name|linux_netmap_start
parameter_list|(
name|struct
name|sk_buff
modifier|*
name|skb
parameter_list|,
name|struct
name|net_device
modifier|*
name|dev
parameter_list|)
block|{
name|netmap_start
argument_list|(
name|dev
argument_list|,
name|skb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NETDEV_TX_OK
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|37
argument_list|)
end_if

begin_comment
comment|// XXX was 38
end_comment

begin_define
define|#
directive|define
name|LIN_IOCTL_NAME
value|.ioctl
end_define

begin_decl_stmt
name|int
name|linux_netmap_ioctl
argument_list|(
expr|struct
name|inode
operator|*
name|inode
argument_list|,
expr|struct
name|file
operator|*
name|file
argument_list|,
name|u_int
name|cmd
argument_list|,
name|u_long
name|data
comment|/* arg */
argument_list|)
else|#
directive|else
define|#
directive|define
name|LIN_IOCTL_NAME
value|.unlocked_ioctl
name|long
name|linux_netmap_ioctl
argument_list|(
expr|struct
name|file
operator|*
name|file
argument_list|,
name|u_int
name|cmd
argument_list|,
name|u_long
name|data
comment|/* arg */
argument_list|)
endif|#
directive|endif
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|nmreq
name|nmr
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|nmr
argument_list|,
sizeof|sizeof
argument_list|(
name|nmr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&&
name|copy_from_user
argument_list|(
operator|&
name|nmr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|nmr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
name|EFAULT
return|;
name|ret
operator|=
name|netmap_ioctl
argument_list|(
name|NULL
argument_list|,
name|cmd
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nmr
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&&
name|copy_to_user
argument_list|(
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
operator|&
name|nmr
argument_list|,
sizeof|sizeof
argument_list|(
name|nmr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
name|EFAULT
return|;
return|return
operator|-
name|ret
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|netmap_release
parameter_list|(
name|struct
name|inode
modifier|*
name|inode
parameter_list|,
name|struct
name|file
modifier|*
name|file
parameter_list|)
block|{
operator|(
name|void
operator|)
name|inode
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
name|file
operator|->
name|private_data
condition|)
name|netmap_dtor
argument_list|(
name|file
operator|->
name|private_data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|linux_netmap_open
parameter_list|(
name|struct
name|inode
modifier|*
name|inode
parameter_list|,
name|struct
name|file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|netmap_priv_d
modifier|*
name|priv
decl_stmt|;
operator|(
name|void
operator|)
name|inode
expr_stmt|;
comment|/* UNUSED */
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netmap_priv_d
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|file
operator|->
name|private_data
operator|=
name|priv
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|file_operations
name|netmap_fops
init|=
block|{
operator|.
name|owner
operator|=
name|THIS_MODULE
block|,
operator|.
name|open
operator|=
name|linux_netmap_open
block|,
operator|.
name|mmap
operator|=
name|linux_netmap_mmap
block|,
name|LIN_IOCTL_NAME
operator|=
name|linux_netmap_ioctl
block|,
operator|.
name|poll
operator|=
name|linux_netmap_poll
block|,
operator|.
name|release
operator|=
name|netmap_release
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|miscdevice
name|netmap_cdevsw
init|=
block|{
comment|/* same name as FreeBSD */
name|MISC_DYNAMIC_MINOR
block|,
literal|"netmap"
block|,
operator|&
name|netmap_fops
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|netmap_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|netmap_fini
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Errors have negative values on linux */
end_comment

begin_function
specifier|static
name|int
name|linux_netmap_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|-
name|netmap_init
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|module_init
argument_list|(
name|linux_netmap_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|netmap_fini
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* export certain symbols to other modules */
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_attach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// driver attach routines
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_detach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// driver detach routines
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_ring_reinit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// ring init on error
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_buffer_lut
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_total_buffers
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// index check
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_buffer_base
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_reset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// ring init routines
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_buf_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_rx_irq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// default irq handler
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_no_pendintr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// XXX mitigation - should go away
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_bdg_ctl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// bridge configuration routine
end_comment

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|netmap_bdg_learning
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// the default lookup function
end_comment

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"http://info.iet.unipi.it/~luigi/netmap/"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"The netmap packet I/O framework"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"Dual BSD/GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* the code here is all BSD. */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|netmap_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_name
operator|=
literal|"netmap"
block|,
operator|.
name|d_open
operator|=
name|netmap_open
block|,
operator|.
name|d_mmap
operator|=
name|netmap_mmap
block|,
operator|.
name|d_mmap_single
operator|=
name|netmap_mmap_single
block|,
operator|.
name|d_ioctl
operator|=
name|netmap_ioctl
block|,
operator|.
name|d_poll
operator|=
name|netmap_poll
block|,
operator|.
name|d_close
operator|=
name|netmap_close
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NM_BRIDGE
end_ifdef

begin_comment
comment|/*  *---- support for virtual bridge -----  */
end_comment

begin_comment
comment|/* ----- FreeBSD if_bridge hash function ------- */
end_comment

begin_comment
comment|/*  * The following hash function is adapted from "Hash Functions" by Bob Jenkins  * ("Algorithm Alley", Dr. Dobbs Journal, September 1997).  *  * http://www.burtleburtle.net/bob/hash/spooky.html  */
end_comment

begin_define
define|#
directive|define
name|mix
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|do {                                                                    \         a -= b; a -= c; a ^= (c>> 13);                                 \         b -= c; b -= a; b ^= (a<< 8);                                  \         c -= a; c -= b; c ^= (b>> 13);                                 \         a -= b; a -= c; a ^= (c>> 12);                                 \         b -= c; b -= a; b ^= (a<< 16);                                 \         c -= a; c -= b; c ^= (b>> 5);                                  \         a -= b; a -= c; a ^= (c>> 3);                                  \         b -= c; b -= a; b ^= (a<< 10);                                 \         c -= a; c -= b; c ^= (b>> 15);                                 \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_function
specifier|static
name|__inline
name|uint32_t
name|nm_bridge_rthash
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint32_t
name|a
init|=
literal|0x9e3779b9
decl_stmt|,
name|b
init|=
literal|0x9e3779b9
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
comment|// hask key
name|b
operator|+=
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
name|b
operator|+=
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
define|#
directive|define
name|BRIDGE_RTHASH_MASK
value|(NM_BDG_HASH-1)
return|return
operator|(
name|c
operator|&
name|BRIDGE_RTHASH_MASK
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|mix
end_undef

begin_function
specifier|static
name|int
name|bdg_netmap_reg
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
comment|// struct nm_bridge *b = NA(ifp)->na_bdg;
comment|/* the interface is already attached to the bridge, 	 * so we only need to toggle IFCAP_NETMAP. 	 * Locking is not necessary (we are already under 	 * NMA_LOCK, and the port is not in use during this call). 	 */
comment|/* BDG_WLOCK(b); */
if|if
condition|(
name|onoff
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_NETMAP
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_NETMAP
expr_stmt|;
block|}
comment|/* BDG_WUNLOCK(b); */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup function for a learning bridge.  * Update the hash table with the source address,  * and then returns the destination port index, and the  * ring in *dst_ring (at the moment, always use ring 0)  */
end_comment

begin_function
name|u_int
name|netmap_bdg_learning
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|,
name|uint8_t
modifier|*
name|dst_ring
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|nm_hash_ent
modifier|*
name|ht
init|=
name|na
operator|->
name|na_bdg
operator|->
name|ht
decl_stmt|;
name|uint32_t
name|sh
decl_stmt|,
name|dh
decl_stmt|;
name|u_int
name|dst
decl_stmt|,
name|mysrc
init|=
name|na
operator|->
name|bdg_port
decl_stmt|;
name|uint64_t
name|smac
decl_stmt|,
name|dmac
decl_stmt|;
name|dmac
operator|=
name|le64toh
argument_list|(
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|buf
operator|)
argument_list|)
operator|&
literal|0xffffffffffff
expr_stmt|;
name|smac
operator|=
name|le64toh
argument_list|(
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|buf
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
name|smac
operator|>>=
literal|16
expr_stmt|;
comment|/* 	 * The hash is somewhat expensive, there might be some 	 * worthwhile optimizations here. 	 */
if|if
condition|(
operator|(
name|buf
index|[
literal|6
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* valid src */
name|uint8_t
modifier|*
name|s
init|=
name|buf
operator|+
literal|6
decl_stmt|;
name|sh
operator|=
name|nm_bridge_rthash
argument_list|(
name|buf
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|// XXX hash of source
comment|/* update source port forwarding entry */
name|ht
index|[
name|sh
index|]
operator|.
name|mac
operator|=
name|smac
expr_stmt|;
comment|/* XXX expire ? */
name|ht
index|[
name|sh
index|]
operator|.
name|ports
operator|=
name|mysrc
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"src %02x:%02x:%02x:%02x:%02x:%02x on port %d"
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|,
name|s
index|[
literal|4
index|]
argument_list|,
name|s
index|[
literal|5
index|]
argument_list|,
name|mysrc
argument_list|)
expr_stmt|;
block|}
name|dst
operator|=
name|NM_BDG_BROADCAST
expr_stmt|;
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* unicast */
name|dh
operator|=
name|nm_bridge_rthash
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// XXX hash of dst
if|if
condition|(
name|ht
index|[
name|dh
index|]
operator|.
name|mac
operator|==
name|dmac
condition|)
block|{
comment|/* found dst */
name|dst
operator|=
name|ht
index|[
name|dh
index|]
operator|.
name|ports
expr_stmt|;
block|}
comment|/* XXX otherwise return NM_BDG_UNKNOWN ? */
block|}
operator|*
name|dst_ring
operator|=
literal|0
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/*  * This flush routine supports only unicast and broadcast but a large  * number of ports, and lets us replace the learn and dispatch functions.  */
end_comment

begin_function
name|int
name|nm_bdg_flush
parameter_list|(
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|)
block|{
name|struct
name|nm_bdg_q
modifier|*
name|dst_ents
decl_stmt|,
modifier|*
name|brddst
decl_stmt|;
name|uint16_t
name|num_dsts
init|=
literal|0
decl_stmt|,
modifier|*
name|dsts
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|na
operator|->
name|na_bdg
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|me
init|=
name|na
operator|->
name|bdg_port
decl_stmt|;
name|dst_ents
operator|=
operator|(
expr|struct
name|nm_bdg_q
operator|*
operator|)
operator|(
name|ft
operator|+
name|NM_BDG_BATCH
operator|)
expr_stmt|;
name|dsts
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|dst_ents
operator|+
name|NM_BDG_MAXPORTS
operator|*
name|NM_BDG_MAXRINGS
operator|+
literal|1
operator|)
expr_stmt|;
name|BDG_RLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* first pass: find a destination */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|likely
argument_list|(
name|i
operator|<
name|n
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
modifier|*
name|buf
init|=
name|ft
index|[
name|i
index|]
operator|.
name|ft_buf
decl_stmt|;
name|uint8_t
name|dst_ring
init|=
name|ring_nr
decl_stmt|;
name|uint16_t
name|dst_port
decl_stmt|,
name|d_i
decl_stmt|;
name|struct
name|nm_bdg_q
modifier|*
name|d
decl_stmt|;
name|dst_port
operator|=
name|b
operator|->
name|nm_bdg_lookup
argument_list|(
name|buf
argument_list|,
name|ft
index|[
name|i
index|]
operator|.
name|ft_len
argument_list|,
operator|&
name|dst_ring
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_port
operator|==
name|NM_BDG_NOPORT
condition|)
block|{
continue|continue;
comment|/* this packet is identified to be dropped */
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|dst_port
operator|>
name|NM_BDG_MAXPORTS
argument_list|)
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|dst_port
operator|==
name|NM_BDG_BROADCAST
condition|)
block|{
name|dst_ring
operator|=
literal|0
expr_stmt|;
comment|/* broadcasts always go to ring 0 */
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|dst_port
operator|==
name|me
operator|||
operator|!
name|BDG_GET_VAR
argument_list|(
name|b
operator|->
name|bdg_ports
index|[
name|dst_port
index|]
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|/* get a position in the scratch pad */
name|d_i
operator|=
name|dst_port
operator|*
name|NM_BDG_MAXRINGS
operator|+
name|dst_ring
expr_stmt|;
name|d
operator|=
name|dst_ents
operator|+
name|d_i
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bq_head
operator|==
name|NM_BDG_BATCH
condition|)
block|{
comment|/* new destination */
name|d
operator|->
name|bq_head
operator|=
name|d
operator|->
name|bq_tail
operator|=
name|i
expr_stmt|;
comment|/* remember this position to be scanned later */
if|if
condition|(
name|dst_port
operator|!=
name|NM_BDG_BROADCAST
condition|)
name|dsts
index|[
name|num_dsts
operator|++
index|]
operator|=
name|d_i
expr_stmt|;
block|}
else|else
block|{
name|ft
index|[
name|d
operator|->
name|bq_tail
index|]
operator|.
name|ft_next
operator|=
name|i
expr_stmt|;
name|d
operator|->
name|bq_tail
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* if there is a broadcast, set ring 0 of all ports to be scanned 	 * XXX This would be optimized by recording the highest index of active 	 * ports. 	 */
name|brddst
operator|=
name|dst_ents
operator|+
name|NM_BDG_BROADCAST
operator|*
name|NM_BDG_MAXRINGS
expr_stmt|;
if|if
condition|(
name|brddst
operator|->
name|bq_head
operator|!=
name|NM_BDG_BATCH
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|likely
argument_list|(
name|i
operator|<
name|NM_BDG_MAXPORTS
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|uint16_t
name|d_i
init|=
name|i
operator|*
name|NM_BDG_MAXRINGS
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|i
operator|==
name|me
argument_list|)
operator|||
operator|!
name|BDG_GET_VAR
argument_list|(
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|dst_ents
index|[
name|d_i
index|]
operator|.
name|bq_head
operator|==
name|NM_BDG_BATCH
condition|)
name|dsts
index|[
name|num_dsts
operator|++
index|]
operator|=
name|d_i
expr_stmt|;
block|}
block|}
comment|/* second pass: scan destinations (XXX will be modular somehow) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_dsts
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ifnet
modifier|*
name|dst_ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|dst_na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
decl_stmt|;
name|u_int
name|dst_nr
decl_stmt|,
name|is_vp
decl_stmt|,
name|lim
decl_stmt|,
name|j
decl_stmt|,
name|sent
init|=
literal|0
decl_stmt|,
name|d_i
decl_stmt|,
name|next
decl_stmt|,
name|brd_next
decl_stmt|;
name|int
name|howmany
decl_stmt|,
name|retry
init|=
name|netmap_txsync_retry
decl_stmt|;
name|struct
name|nm_bdg_q
modifier|*
name|d
decl_stmt|;
name|d_i
operator|=
name|dsts
index|[
name|i
index|]
expr_stmt|;
name|d
operator|=
name|dst_ents
operator|+
name|d_i
expr_stmt|;
name|dst_na
operator|=
name|BDG_GET_VAR
argument_list|(
name|b
operator|->
name|bdg_ports
index|[
name|d_i
operator|/
name|NM_BDG_MAXRINGS
index|]
argument_list|)
expr_stmt|;
comment|/* protect from the lookup function returning an inactive 		 * destination port 		 */
if|if
condition|(
name|unlikely
argument_list|(
name|dst_na
operator|==
name|NULL
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|dst_na
operator|->
name|na_flags
operator|&
name|NAF_SW_ONLY
condition|)
continue|continue;
name|dst_ifp
operator|=
name|dst_na
operator|->
name|ifp
expr_stmt|;
comment|/* 		 * The interface may be in !netmap mode in two cases: 		 * - when na is attached but not activated yet; 		 * - when na is being deactivated but is still attached. 		 */
if|if
condition|(
name|unlikely
argument_list|(
operator|!
operator|(
name|dst_ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
argument_list|)
condition|)
continue|continue;
comment|/* there is at least one either unicast or broadcast packet */
name|brd_next
operator|=
name|brddst
operator|->
name|bq_head
expr_stmt|;
name|next
operator|=
name|d
operator|->
name|bq_head
expr_stmt|;
name|is_vp
operator|=
name|nma_is_vp
argument_list|(
name|dst_na
argument_list|)
expr_stmt|;
name|dst_nr
operator|=
name|d_i
operator|&
operator|(
name|NM_BDG_MAXRINGS
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|is_vp
condition|)
block|{
comment|/* virtual port */
if|if
condition|(
name|dst_nr
operator|>=
name|dst_na
operator|->
name|num_rx_rings
condition|)
name|dst_nr
operator|=
name|dst_nr
operator|%
name|dst_na
operator|->
name|num_rx_rings
expr_stmt|;
name|kring
operator|=
operator|&
name|dst_na
operator|->
name|rx_rings
index|[
name|dst_nr
index|]
expr_stmt|;
name|ring
operator|=
name|kring
operator|->
name|ring
expr_stmt|;
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
name|dst_na
operator|->
name|nm_lock
argument_list|(
name|dst_ifp
argument_list|,
name|NETMAP_RX_LOCK
argument_list|,
name|dst_nr
argument_list|)
expr_stmt|;
name|j
operator|=
name|kring
operator|->
name|nr_hwcur
operator|+
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|lim
condition|)
name|j
operator|-=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|howmany
operator|=
name|lim
operator|-
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
block|}
else|else
block|{
comment|/* hw or sw adapter */
if|if
condition|(
name|dst_nr
operator|>=
name|dst_na
operator|->
name|num_tx_rings
condition|)
name|dst_nr
operator|=
name|dst_nr
operator|%
name|dst_na
operator|->
name|num_tx_rings
expr_stmt|;
name|kring
operator|=
operator|&
name|dst_na
operator|->
name|tx_rings
index|[
name|dst_nr
index|]
expr_stmt|;
name|ring
operator|=
name|kring
operator|->
name|ring
expr_stmt|;
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
name|dst_na
operator|->
name|nm_lock
argument_list|(
name|dst_ifp
argument_list|,
name|NETMAP_TX_LOCK
argument_list|,
name|dst_nr
argument_list|)
expr_stmt|;
name|retry
label|:
name|dst_na
operator|->
name|nm_txsync
argument_list|(
name|dst_ifp
argument_list|,
name|dst_nr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* see nm_bdg_flush() */
name|j
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|howmany
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
block|}
while|while
condition|(
name|howmany
operator|--
operator|>
literal|0
condition|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|nm_bdg_fwd
modifier|*
name|ft_p
decl_stmt|;
comment|/* our 'NULL' is always higher than valid indexes 			 * so we never dereference it if the other list 			 * has packets (and if both are NULL we never 			 * get here). 			 */
if|if
condition|(
name|next
operator|<
name|brd_next
condition|)
block|{
name|ft_p
operator|=
name|ft
operator|+
name|next
expr_stmt|;
name|next
operator|=
name|ft_p
operator|->
name|ft_next
expr_stmt|;
name|ND
argument_list|(
literal|"j %d uni %d next %d %d"
argument_list|,
name|j
argument_list|,
name|ft_p
operator|-
name|ft
argument_list|,
name|next
argument_list|,
name|brd_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* insert broadcast */
name|ft_p
operator|=
name|ft
operator|+
name|brd_next
expr_stmt|;
name|brd_next
operator|=
name|ft_p
operator|->
name|ft_next
expr_stmt|;
name|ND
argument_list|(
literal|"j %d brd %d next %d %d"
argument_list|,
name|j
argument_list|,
name|ft_p
operator|-
name|ft
argument_list|,
name|next
argument_list|,
name|brd_next
argument_list|)
expr_stmt|;
block|}
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
name|j
index|]
expr_stmt|;
name|ND
argument_list|(
literal|"send %d %d bytes at %s:%d"
argument_list|,
name|i
argument_list|,
name|ft_p
operator|->
name|ft_len
argument_list|,
name|dst_ifp
operator|->
name|if_xname
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|ft_p
operator|->
name|ft_flags
operator|&
name|NS_INDIRECT
condition|)
block|{
name|ND
argument_list|(
literal|"copying from INDIRECT source"
argument_list|)
expr_stmt|;
name|copyin
argument_list|(
name|ft_p
operator|->
name|ft_buf
argument_list|,
name|NMB
argument_list|(
name|slot
argument_list|)
argument_list|,
operator|(
name|ft_p
operator|->
name|ft_len
operator|+
literal|63
operator|)
operator|&
operator|~
literal|63
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkt_copy
argument_list|(
name|ft_p
operator|->
name|ft_buf
argument_list|,
name|NMB
argument_list|(
name|slot
argument_list|)
argument_list|,
name|ft_p
operator|->
name|ft_len
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|len
operator|=
name|ft_p
operator|->
name|ft_len
expr_stmt|;
name|j
operator|=
name|unlikely
argument_list|(
name|j
operator|==
name|lim
argument_list|)
condition|?
literal|0
else|:
name|j
operator|+
literal|1
expr_stmt|;
comment|/* XXX to be macro-ed */
name|sent
operator|++
expr_stmt|;
comment|/* are we done ? */
if|if
condition|(
name|next
operator|==
name|NM_BDG_BATCH
operator|&&
name|brd_next
operator|==
name|NM_BDG_BATCH
condition|)
break|break;
block|}
if|if
condition|(
name|netmap_verbose
operator|&&
operator|(
name|howmany
operator|<
literal|0
operator|)
condition|)
name|D
argument_list|(
literal|"rx ring full on %s"
argument_list|,
name|dst_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_vp
condition|)
block|{
if|if
condition|(
name|sent
condition|)
block|{
name|kring
operator|->
name|nr_hwavail
operator|+=
name|sent
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|kring
operator|->
name|si
argument_list|,
name|PI_NET
argument_list|)
expr_stmt|;
block|}
name|dst_na
operator|->
name|nm_lock
argument_list|(
name|dst_ifp
argument_list|,
name|NETMAP_RX_UNLOCK
argument_list|,
name|dst_nr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sent
condition|)
block|{
name|ring
operator|->
name|avail
operator|-=
name|sent
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|j
expr_stmt|;
name|dst_na
operator|->
name|nm_txsync
argument_list|(
name|dst_ifp
argument_list|,
name|dst_nr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* retry to send more packets */
if|if
condition|(
name|nma_is_hw
argument_list|(
name|dst_na
argument_list|)
operator|&&
name|howmany
operator|<
literal|0
operator|&&
name|retry
operator|--
condition|)
goto|goto
name|retry
goto|;
name|dst_na
operator|->
name|nm_lock
argument_list|(
name|dst_ifp
argument_list|,
name|NETMAP_TX_UNLOCK
argument_list|,
name|dst_nr
argument_list|)
expr_stmt|;
block|}
comment|/* NM_BDG_BATCH means 'no packet' */
name|d
operator|->
name|bq_head
operator|=
name|d
operator|->
name|bq_tail
operator|=
name|NM_BDG_BATCH
expr_stmt|;
comment|/* cleanup */
block|}
name|brddst
operator|->
name|bq_head
operator|=
name|brddst
operator|->
name|bq_tail
operator|=
name|NM_BDG_BATCH
expr_stmt|;
comment|/* cleanup */
name|BDG_RUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * main dispatch routine  */
end_comment

begin_function
specifier|static
name|int
name|bdg_netmap_txsync
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|int
name|do_lock
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|ring_nr
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|k
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|lim
condition|)
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
if|if
condition|(
name|do_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_TX_LOCK
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_bridge
operator|<=
literal|0
condition|)
block|{
comment|/* testing only */
name|j
operator|=
name|k
expr_stmt|;
comment|// used all
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|netmap_bridge
operator|>
name|NM_BDG_BATCH
condition|)
name|netmap_bridge
operator|=
name|NM_BDG_BATCH
expr_stmt|;
name|j
operator|=
name|nm_bdg_preflush
argument_list|(
name|na
argument_list|,
name|ring_nr
argument_list|,
name|kring
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|i
operator|=
name|k
operator|-
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|kring
operator|->
name|nr_hwavail
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|k
condition|)
name|D
argument_list|(
literal|"early break at %d/ %d, avail %d"
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
name|done
label|:
name|kring
operator|->
name|nr_hwcur
operator|=
name|j
expr_stmt|;
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
expr_stmt|;
if|if
condition|(
name|do_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_TX_UNLOCK
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s ring %d lock %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|ring_nr
argument_list|,
name|do_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bdg_netmap_rxsync
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|int
name|do_lock
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|ring_nr
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|j
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
name|k
init|=
name|ring
operator|->
name|cur
decl_stmt|,
name|resvd
init|=
name|ring
operator|->
name|reserved
decl_stmt|;
name|int
name|n
decl_stmt|;
name|ND
argument_list|(
literal|"%s ring %d lock %d avail %d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|ring_nr
argument_list|,
name|do_lock
argument_list|,
name|kring
operator|->
name|nr_hwavail
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|lim
condition|)
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
if|if
condition|(
name|do_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_RX_LOCK
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
comment|/* skip past packets that userspace has released */
name|j
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
comment|/* netmap ring index */
if|if
condition|(
name|resvd
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|resvd
operator|+
name|ring
operator|->
name|avail
operator|>=
name|lim
operator|+
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"XXX invalid reserve/avail %d %d"
argument_list|,
name|resvd
argument_list|,
name|ring
operator|->
name|avail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|reserved
operator|=
name|resvd
operator|=
literal|0
expr_stmt|;
comment|// XXX panic...
block|}
name|k
operator|=
operator|(
name|k
operator|>=
name|resvd
operator|)
condition|?
name|k
operator|-
name|resvd
else|:
name|k
operator|+
name|lim
operator|+
literal|1
operator|-
name|resvd
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
name|k
condition|)
block|{
comment|/* userspace has released some packets. */
name|n
operator|=
name|k
operator|-
name|j
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|+=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
name|ND
argument_list|(
literal|"userspace releases %d packets"
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|likely
argument_list|(
name|j
operator|!=
name|k
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|j
index|]
decl_stmt|;
name|void
modifier|*
name|addr
init|=
name|NMB
argument_list|(
name|slot
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|netmap_buffer_base
condition|)
block|{
comment|/* bad buf */
if|if
condition|(
name|do_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_RX_UNLOCK
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
block|}
comment|/* decrease refcount for buffer */
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_BUF_CHANGED
expr_stmt|;
name|j
operator|=
name|unlikely
argument_list|(
name|j
operator|==
name|lim
argument_list|)
condition|?
literal|0
else|:
name|j
operator|+
literal|1
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwavail
operator|-=
name|n
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|k
expr_stmt|;
block|}
comment|/* tell userspace that there are new packets */
name|ring
operator|->
name|avail
operator|=
name|kring
operator|->
name|nr_hwavail
operator|-
name|resvd
expr_stmt|;
if|if
condition|(
name|do_lock
condition|)
name|na
operator|->
name|nm_lock
argument_list|(
name|ifp
argument_list|,
name|NETMAP_RX_UNLOCK
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bdg_netmap_attach
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|netmap_adapter
name|na
decl_stmt|;
name|ND
argument_list|(
literal|"attaching virtual bridge"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|na
argument_list|,
sizeof|sizeof
argument_list|(
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|na
operator|.
name|ifp
operator|=
name|arg
operator|->
name|ifp
expr_stmt|;
name|na
operator|.
name|separate_locks
operator|=
literal|1
expr_stmt|;
name|na
operator|.
name|num_tx_rings
operator|=
name|arg
operator|->
name|num_tx_rings
expr_stmt|;
name|na
operator|.
name|num_rx_rings
operator|=
name|arg
operator|->
name|num_rx_rings
expr_stmt|;
name|na
operator|.
name|num_tx_desc
operator|=
name|NM_BRIDGE_RINGSIZE
expr_stmt|;
name|na
operator|.
name|num_rx_desc
operator|=
name|NM_BRIDGE_RINGSIZE
expr_stmt|;
name|na
operator|.
name|nm_txsync
operator|=
name|bdg_netmap_txsync
expr_stmt|;
name|na
operator|.
name|nm_rxsync
operator|=
name|bdg_netmap_rxsync
expr_stmt|;
name|na
operator|.
name|nm_register
operator|=
name|bdg_netmap_reg
expr_stmt|;
name|netmap_attach
argument_list|(
operator|&
name|na
argument_list|,
name|na
operator|.
name|num_tx_rings
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NM_BRIDGE */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|netmap_dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* /dev/netmap character device. */
end_comment

begin_comment
comment|/*  * Module loader.  *  * Create the /dev/netmap device and initialize all global  * variables.  *  * Return 0 on success, errno on failure.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|netmap_memory_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"netmap: unable to initialize the memory allocator.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"netmap: loaded module\n"
argument_list|)
expr_stmt|;
name|netmap_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|netmap_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0660
argument_list|,
literal|"netmap"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NM_BRIDGE
block|{
name|int
name|i
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|netmap_bridge_mutex
argument_list|,
literal|"netmap_bridge_mutex"
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|nm_bridges
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nm_bridge
argument_list|)
operator|*
name|NM_BRIDGES
argument_list|)
expr_stmt|;
comment|/* safety */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BRIDGES
condition|;
name|i
operator|++
control|)
name|rw_init
argument_list|(
operator|&
name|nm_bridges
index|[
name|i
index|]
operator|.
name|bdg_lock
argument_list|,
literal|"bdg lock"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Module unloader.  *  * Free all the memory, and destroy the ``/dev/netmap`` device.  */
end_comment

begin_function
specifier|static
name|void
name|netmap_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|destroy_dev
argument_list|(
name|netmap_dev
argument_list|)
expr_stmt|;
name|netmap_memory_fini
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"netmap: unloaded module.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_comment
comment|/*  * Kernel entry point.  *  * Initialize/finalize the module and return.  *  * Return 0 on success, errno on failure.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_loader
parameter_list|(
name|__unused
name|struct
name|module
modifier|*
name|module
parameter_list|,
name|int
name|event
parameter_list|,
name|__unused
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
name|netmap_init
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|netmap_fini
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|netmap
argument_list|,
name|netmap_loader
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

end_unit

