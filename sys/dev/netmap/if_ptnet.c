begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016, Vincenzo Maffione  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/* Driver for ptnet paravirtualized network device. */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<net/netmap_virt.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_mem2.h>
end_include

begin_include
include|#
directive|include
file|<dev/virtio/network/virtio_net.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PTNET_CSB_ALLOC
end_ifndef

begin_error
error|#
directive|error
literal|"No support for on-device CSB"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INET
end_ifndef

begin_error
error|#
directive|error
literal|"INET not defined, cannot support offloadings"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100000
end_if

begin_function_decl
specifier|static
name|uint64_t
name|ptnet_get_counter
parameter_list|(
name|if_t
parameter_list|,
name|ift_counter
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|struct
name|ifnet
modifier|*
name|if_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|if_getsoftc
parameter_list|(
name|_ifp
parameter_list|)
value|(_ifp)->if_softc
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//#define PTNETMAP_STATS
end_comment

begin_comment
comment|//#define DEBUG
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !DEBUG */
end_comment

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DEBUG */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|ptnet_vnet_hdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tunable parameter */
end_comment

begin_struct_decl
struct_decl|struct
name|ptnet_softc
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|ptnet_queue_stats
block|{
name|uint64_t
name|packets
decl_stmt|;
comment|/* if_[io]packets */
name|uint64_t
name|bytes
decl_stmt|;
comment|/* if_[io]bytes */
name|uint64_t
name|errors
decl_stmt|;
comment|/* if_[io]errors */
name|uint64_t
name|iqdrops
decl_stmt|;
comment|/* if_iqdrops */
name|uint64_t
name|mcasts
decl_stmt|;
comment|/* if_[io]mcasts */
ifdef|#
directive|ifdef
name|PTNETMAP_STATS
name|uint64_t
name|intrs
decl_stmt|;
name|uint64_t
name|kicks
decl_stmt|;
endif|#
directive|endif
comment|/* PTNETMAP_STATS */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ptnet_queue
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|int
name|kring_id
decl_stmt|;
name|struct
name|ptnet_ring
modifier|*
name|ptring
decl_stmt|;
name|unsigned
name|int
name|kick
decl_stmt|;
name|struct
name|mtx
name|lock
decl_stmt|;
name|struct
name|buf_ring
modifier|*
name|bufring
decl_stmt|;
comment|/* for TX queues */
name|struct
name|ptnet_queue_stats
name|stats
decl_stmt|;
ifdef|#
directive|ifdef
name|PTNETMAP_STATS
name|struct
name|ptnet_queue_stats
name|last_stats
decl_stmt|;
endif|#
directive|endif
comment|/* PTNETMAP_STATS */
name|struct
name|taskqueue
modifier|*
name|taskq
decl_stmt|;
name|struct
name|task
name|task
decl_stmt|;
name|char
name|lock_name
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PTNET_Q_LOCK
parameter_list|(
name|_pq
parameter_list|)
value|mtx_lock(&(_pq)->lock)
end_define

begin_define
define|#
directive|define
name|PTNET_Q_TRYLOCK
parameter_list|(
name|_pq
parameter_list|)
value|mtx_trylock(&(_pq)->lock)
end_define

begin_define
define|#
directive|define
name|PTNET_Q_UNLOCK
parameter_list|(
name|_pq
parameter_list|)
value|mtx_unlock(&(_pq)->lock)
end_define

begin_struct
struct|struct
name|ptnet_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|if_t
name|ifp
decl_stmt|;
name|struct
name|ifmedia
name|media
decl_stmt|;
name|struct
name|mtx
name|lock
decl_stmt|;
name|char
name|lock_name
index|[
literal|16
index|]
decl_stmt|;
name|char
name|hwaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
comment|/* Mirror of PTFEAT register. */
name|uint32_t
name|ptfeatures
decl_stmt|;
name|unsigned
name|int
name|vnet_hdr_len
decl_stmt|;
comment|/* PCI BARs support. */
name|struct
name|resource
modifier|*
name|iomem
decl_stmt|;
name|struct
name|resource
modifier|*
name|msix_mem
decl_stmt|;
name|unsigned
name|int
name|num_rings
decl_stmt|;
name|unsigned
name|int
name|num_tx_rings
decl_stmt|;
name|struct
name|ptnet_queue
modifier|*
name|queues
decl_stmt|;
name|struct
name|ptnet_queue
modifier|*
name|rxqueues
decl_stmt|;
name|struct
name|ptnet_csb
modifier|*
name|csb
decl_stmt|;
name|unsigned
name|int
name|min_tx_space
decl_stmt|;
name|struct
name|netmap_pt_guest_adapter
modifier|*
name|ptna
decl_stmt|;
name|struct
name|callout
name|tick
decl_stmt|;
ifdef|#
directive|ifdef
name|PTNETMAP_STATS
name|struct
name|timeval
name|last_ts
decl_stmt|;
endif|#
directive|endif
comment|/* PTNETMAP_STATS */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PTNET_CORE_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->lock)
end_define

begin_define
define|#
directive|define
name|PTNET_CORE_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->lock)
end_define

begin_function_decl
specifier|static
name|int
name|ptnet_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptnet_init
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_ioctl
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_init_locked
parameter_list|(
name|struct
name|ptnet_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_stop
parameter_list|(
name|struct
name|ptnet_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_transmit
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_drain_transmit_queue
parameter_list|(
name|struct
name|ptnet_queue
modifier|*
name|pq
parameter_list|,
name|unsigned
name|int
name|budget
parameter_list|,
name|bool
name|may_resched
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptnet_qflush
parameter_list|(
name|if_t
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptnet_tx_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_media_change
parameter_list|(
name|if_t
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptnet_media_status
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|PTNETMAP_STATS
end_ifdef

begin_function_decl
specifier|static
name|void
name|ptnet_tick
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ptnet_irqs_init
parameter_list|(
name|struct
name|ptnet_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptnet_irqs_fini
parameter_list|(
name|struct
name|ptnet_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|ptnet_nm_ptctl
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|uint32_t
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_nm_config
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|unsigned
modifier|*
name|txr
parameter_list|,
name|unsigned
modifier|*
name|txd
parameter_list|,
name|unsigned
modifier|*
name|rxr
parameter_list|,
name|unsigned
modifier|*
name|rxd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptnet_update_vnet_hdr
parameter_list|(
name|struct
name|ptnet_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_nm_register
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_nm_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_nm_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptnet_tx_intr
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptnet_rx_intr
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|ptnet_rx_discard
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|unsigned
name|int
name|head
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptnet_rx_eof
parameter_list|(
name|struct
name|ptnet_queue
modifier|*
name|pq
parameter_list|,
name|unsigned
name|int
name|budget
parameter_list|,
name|bool
name|may_resched
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptnet_rx_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_decl_stmt
specifier|static
name|poll_handler_t
name|ptnet_poll
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|device_method_t
name|ptnet_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ptnet_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ptnet_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ptnet_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|ptnet_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ptnet_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ptnet_shutdown
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ptnet_driver
init|=
block|{
literal|"ptnet"
block|,
name|ptnet_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ptnet_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We use (SI_ORDER_MIDDLE+2) here, see DEV_MODULE_ORDERED() invocation. */
end_comment

begin_decl_stmt
specifier|static
name|devclass_t
name|ptnet_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE_ORDERED
argument_list|(
name|ptnet
argument_list|,
name|pci
argument_list|,
name|ptnet_driver
argument_list|,
name|ptnet_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SI_ORDER_MIDDLE
operator|+
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|ptnet_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|!=
name|PTNETMAP_PCI_VENDOR_ID
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|!=
name|PTNETMAP_PCI_NETIF_ID
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ptnet network adapter"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ptnet_kick
parameter_list|(
name|struct
name|ptnet_queue
modifier|*
name|pq
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PTNETMAP_STATS
name|pq
operator|->
name|stats
operator|.
name|kicks
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* PTNETMAP_STATS */
name|bus_write_4
argument_list|(
name|pq
operator|->
name|sc
operator|->
name|iomem
argument_list|,
name|pq
operator|->
name|kick
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PTNET_BUF_RING_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|PTNET_RX_BUDGET
value|512
end_define

begin_define
define|#
directive|define
name|PTNET_RX_BATCH
value|1
end_define

begin_define
define|#
directive|define
name|PTNET_TX_BUDGET
value|512
end_define

begin_define
define|#
directive|define
name|PTNET_TX_BATCH
value|64
end_define

begin_define
define|#
directive|define
name|PTNET_HDR_SIZE
value|sizeof(struct virtio_net_hdr_mrg_rxbuf)
end_define

begin_define
define|#
directive|define
name|PTNET_MAX_PKT_SIZE
value|65536
end_define

begin_define
define|#
directive|define
name|PTNET_CSUM_OFFLOAD
value|(CSUM_TCP | CSUM_UDP | CSUM_SCTP)
end_define

begin_define
define|#
directive|define
name|PTNET_CSUM_OFFLOAD_IPV6
value|(CSUM_TCP_IPV6 | CSUM_UDP_IPV6 |\ 				 CSUM_SCTP_IPV6)
end_define

begin_define
define|#
directive|define
name|PTNET_ALL_OFFLOAD
value|(CSUM_TSO | PTNET_CSUM_OFFLOAD |\ 				 PTNET_CSUM_OFFLOAD_IPV6)
end_define

begin_function
specifier|static
name|int
name|ptnet_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint32_t
name|ptfeatures
init|=
name|PTNETMAP_F_BASE
decl_stmt|;
name|unsigned
name|int
name|num_rx_rings
decl_stmt|,
name|num_tx_rings
decl_stmt|;
name|struct
name|netmap_adapter
name|na_arg
decl_stmt|;
name|unsigned
name|int
name|nifp_offset
decl_stmt|;
name|struct
name|ptnet_softc
modifier|*
name|sc
decl_stmt|;
name|if_t
name|ifp
decl_stmt|;
name|uint32_t
name|macreg
decl_stmt|;
name|int
name|err
decl_stmt|,
name|rid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* Setup PCI resources. */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
name|PTNETMAP_IO_PCI_BAR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|iomem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|iomem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to map I/O BAR\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Check if we are supported by the hypervisor. If not, 	 * bail out immediately. */
if|if
condition|(
name|ptnet_vnet_hdr
condition|)
block|{
name|ptfeatures
operator||=
name|PTNETMAP_F_VNET_HDR
expr_stmt|;
block|}
name|bus_write_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_PTFEAT
argument_list|,
name|ptfeatures
argument_list|)
expr_stmt|;
comment|/* wanted */
name|ptfeatures
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_PTFEAT
argument_list|)
expr_stmt|;
comment|/* acked */
if|if
condition|(
operator|!
operator|(
name|ptfeatures
operator|&
name|PTNETMAP_F_BASE
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hypervisor does not support netmap "
literal|"passthorugh\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_path
goto|;
block|}
name|sc
operator|->
name|ptfeatures
operator|=
name|ptfeatures
expr_stmt|;
comment|/* Allocate CSB and carry out CSB allocation protocol (CSBBAH first, 	 * then CSBBAL). */
name|sc
operator|->
name|csb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ptnet_csb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|csb
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate CSB\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_path
goto|;
block|}
block|{
comment|/* 		 * We use uint64_t rather than vm_paddr_t since we 		 * need 64 bit addresses even on 32 bit platforms. 		 */
name|uint64_t
name|paddr
init|=
name|vtophys
argument_list|(
name|sc
operator|->
name|csb
argument_list|)
decl_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_CSBBAH
argument_list|,
operator|(
name|paddr
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_CSBBAL
argument_list|,
name|paddr
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
name|num_tx_rings
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_NUM_TX_RINGS
argument_list|)
expr_stmt|;
name|num_rx_rings
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_NUM_RX_RINGS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_rings
operator|=
name|num_tx_rings
operator|+
name|num_rx_rings
expr_stmt|;
name|sc
operator|->
name|num_tx_rings
operator|=
name|num_tx_rings
expr_stmt|;
comment|/* Allocate and initialize per-queue data structures. */
name|sc
operator|->
name|queues
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ptnet_queue
argument_list|)
operator|*
name|sc
operator|->
name|num_rings
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|queues
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_path
goto|;
block|}
name|sc
operator|->
name|rxqueues
operator|=
name|sc
operator|->
name|queues
operator|+
name|num_tx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|sc
operator|->
name|queues
operator|+
name|i
decl_stmt|;
name|pq
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|pq
operator|->
name|kring_id
operator|=
name|i
expr_stmt|;
name|pq
operator|->
name|kick
operator|=
name|PTNET_IO_KICK_BASE
operator|+
literal|4
operator|*
name|i
expr_stmt|;
name|pq
operator|->
name|ptring
operator|=
name|sc
operator|->
name|csb
operator|->
name|rings
operator|+
name|i
expr_stmt|;
name|snprintf
argument_list|(
name|pq
operator|->
name|lock_name
argument_list|,
sizeof|sizeof
argument_list|(
name|pq
operator|->
name|lock_name
argument_list|)
argument_list|,
literal|"%s-%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pq
operator|->
name|lock
argument_list|,
name|pq
operator|->
name|lock_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|num_tx_rings
condition|)
block|{
comment|/* RX queue: fix kring_id. */
name|pq
operator|->
name|kring_id
operator|-=
name|num_tx_rings
expr_stmt|;
block|}
else|else
block|{
comment|/* TX queue: allocate buf_ring. */
name|pq
operator|->
name|bufring
operator|=
name|buf_ring_alloc
argument_list|(
name|PTNET_BUF_RING_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
operator|&
name|pq
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pq
operator|->
name|bufring
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_path
goto|;
block|}
block|}
block|}
name|sc
operator|->
name|min_tx_space
operator|=
literal|64
expr_stmt|;
comment|/* Safe initial value. */
name|err
operator|=
name|ptnet_irqs_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|err_path
goto|;
block|}
comment|/* Setup Ethernet interface. */
name|sc
operator|->
name|ifp
operator|=
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate ifnet\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_path
goto|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Gbps
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ptnet_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ptnet_ioctl
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100000
name|ifp
operator|->
name|if_get_counter
operator|=
name|ptnet_get_counter
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_transmit
operator|=
name|ptnet_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|ptnet_qflush
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|ptnet_media_change
argument_list|,
name|ptnet_media_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_T
operator||
name|IFM_FDX
argument_list|)
expr_stmt|;
name|macreg
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_MAC_HI
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hwaddr
index|[
literal|0
index|]
operator|=
operator|(
name|macreg
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|hwaddr
index|[
literal|1
index|]
operator|=
name|macreg
operator|&
literal|0xff
expr_stmt|;
name|macreg
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_MAC_LO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hwaddr
index|[
literal|2
index|]
operator|=
operator|(
name|macreg
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|hwaddr
index|[
literal|3
index|]
operator|=
operator|(
name|macreg
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|hwaddr
index|[
literal|4
index|]
operator|=
operator|(
name|macreg
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|hwaddr
index|[
literal|5
index|]
operator|=
name|macreg
operator|&
literal|0xff
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|hwaddr
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_JUMBO_MTU
operator||
name|IFCAP_VLAN_MTU
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ptfeatures
operator|&
name|PTNETMAP_F_VNET_HDR
condition|)
block|{
comment|/* Similarly to what the vtnet driver does, we can emulate 		 * VLAN offloadings by inserting and removing the 802.1Q 		 * header during transmit and receive. We are then able 		 * to do checksum offloading of VLAN frames. */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
operator||
name|IFCAP_HWCSUM_IPV6
operator||
name|IFCAP_VLAN_HWCSUM
operator||
name|IFCAP_TSO
operator||
name|IFCAP_LRO
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
block|}
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* Don't enable polling by default. */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_POLLING
expr_stmt|;
endif|#
directive|endif
name|snprintf
argument_list|(
name|sc
operator|->
name|lock_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|lock_name
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|,
name|sc
operator|->
name|lock_name
argument_list|,
literal|"ptnet core lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|tick
argument_list|,
operator|&
name|sc
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Prepare a netmap_adapter struct instance to do netmap_attach(). */
name|nifp_offset
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_NIFP_OFS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|na_arg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|na_arg
argument_list|)
argument_list|)
expr_stmt|;
name|na_arg
operator|.
name|ifp
operator|=
name|ifp
expr_stmt|;
name|na_arg
operator|.
name|num_tx_desc
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_NUM_TX_SLOTS
argument_list|)
expr_stmt|;
name|na_arg
operator|.
name|num_rx_desc
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_NUM_RX_SLOTS
argument_list|)
expr_stmt|;
name|na_arg
operator|.
name|num_tx_rings
operator|=
name|num_tx_rings
expr_stmt|;
name|na_arg
operator|.
name|num_rx_rings
operator|=
name|num_rx_rings
expr_stmt|;
name|na_arg
operator|.
name|nm_config
operator|=
name|ptnet_nm_config
expr_stmt|;
name|na_arg
operator|.
name|nm_krings_create
operator|=
name|ptnet_nm_krings_create
expr_stmt|;
name|na_arg
operator|.
name|nm_krings_delete
operator|=
name|ptnet_nm_krings_delete
expr_stmt|;
name|na_arg
operator|.
name|nm_dtor
operator|=
name|ptnet_nm_dtor
expr_stmt|;
name|na_arg
operator|.
name|nm_register
operator|=
name|ptnet_nm_register
expr_stmt|;
name|na_arg
operator|.
name|nm_txsync
operator|=
name|ptnet_nm_txsync
expr_stmt|;
name|na_arg
operator|.
name|nm_rxsync
operator|=
name|ptnet_nm_rxsync
expr_stmt|;
name|netmap_pt_guest_attach
argument_list|(
operator|&
name|na_arg
argument_list|,
name|sc
operator|->
name|csb
argument_list|,
name|nifp_offset
argument_list|,
name|ptnet_nm_ptctl
argument_list|)
expr_stmt|;
comment|/* Now a netmap adapter for this ifp has been allocated, and it 	 * can be accessed through NA(ifp). We also have to initialize the CSB 	 * pointer. */
name|sc
operator|->
name|ptna
operator|=
operator|(
expr|struct
name|netmap_pt_guest_adapter
operator|*
operator|)
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* If virtio-net header was negotiated, set the virt_hdr_len field in 	 * the netmap adapter, to inform users that this netmap adapter requires 	 * the application to deal with the headers. */
name|ptnet_update_vnet_hdr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s() completed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_path
label|:
name|ptnet_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|ether_poll_deregister
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|tick
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|queues
condition|)
block|{
comment|/* Drain taskqueues before calling if_detach. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|sc
operator|->
name|queues
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|pq
operator|->
name|taskq
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|pq
operator|->
name|taskq
argument_list|,
operator|&
name|pq
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|ifp
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* Uninitialize netmap adapters for this device. */
name|netmap_detach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
name|ptnet_irqs_fini
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|csb
condition|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_CSBBAH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_CSBBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|csb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|csb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|queues
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|sc
operator|->
name|queues
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|pq
operator|->
name|lock
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|pq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pq
operator|->
name|bufring
operator|!=
name|NULL
condition|)
block|{
name|buf_ring_free
argument_list|(
name|pq
operator|->
name|bufring
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sc
operator|->
name|queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|queues
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|iomem
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|PCIR_BAR
argument_list|(
name|PTNETMAP_IO_PCI_BAR
argument_list|)
argument_list|,
name|sc
operator|->
name|iomem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|iomem
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s() completed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * Suspend already does all of what we need to 	 * do here; we just never expect to be resumed. 	 */
return|return
operator|(
name|ptnet_suspend
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_irqs_init
parameter_list|(
name|struct
name|ptnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rid
init|=
name|PCIR_BAR
argument_list|(
name|PTNETMAP_MSIX_PCI_BAR
argument_list|)
decl_stmt|;
name|int
name|nvecs
init|=
name|sc
operator|->
name|num_rings
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|int
name|err
init|=
name|ENOSPC
decl_stmt|;
name|int
name|cpu_cur
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_MSIX
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not find MSI-X capability\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|msix_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate MSIX PCI BAR\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
operator|<
name|nvecs
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Not enough MSI-X vectors\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_path
goto|;
block|}
name|err
operator|=
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|nvecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate MSI-X vectors\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_path
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvecs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|sc
operator|->
name|queues
operator|+
name|i
decl_stmt|;
name|rid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|pq
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pq
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate interrupt "
literal|"for queue #%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|err_path
goto|;
block|}
block|}
name|cpu_cur
operator|=
name|CPU_FIRST
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvecs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|sc
operator|->
name|queues
operator|+
name|i
decl_stmt|;
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
init|=
name|ptnet_tx_intr
function_decl|;
if|if
condition|(
name|i
operator|>=
name|sc
operator|->
name|num_tx_rings
condition|)
block|{
name|handler
operator|=
name|ptnet_rx_intr
expr_stmt|;
block|}
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|pq
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
comment|/* intr_filter */
argument_list|,
name|handler
argument_list|,
name|pq
argument_list|,
operator|&
name|pq
operator|->
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register intr handler "
literal|"for queue #%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|err_path
goto|;
block|}
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|pq
operator|->
name|irq
argument_list|,
name|pq
operator|->
name|cookie
argument_list|,
literal|"q%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bus_bind_intr(sc->dev, pq->irq, cpu_cur);
endif|#
directive|endif
name|cpu_cur
operator|=
name|CPU_NEXT
argument_list|(
name|cpu_cur
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Allocated %d MSI-X vectors\n"
argument_list|,
name|nvecs
argument_list|)
expr_stmt|;
name|cpu_cur
operator|=
name|CPU_FIRST
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvecs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|sc
operator|->
name|queues
operator|+
name|i
decl_stmt|;
specifier|static
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
name|handler
operator|=
operator|(
name|i
operator|<
name|sc
operator|->
name|num_tx_rings
operator|)
condition|?
name|ptnet_tx_task
else|:
name|ptnet_rx_task
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|pq
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|handler
argument_list|,
name|pq
argument_list|)
expr_stmt|;
name|pq
operator|->
name|taskq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ptnet_queue"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|pq
operator|->
name|taskq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|pq
operator|->
name|taskq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s-pq-%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|cpu_cur
argument_list|)
expr_stmt|;
name|cpu_cur
operator|=
name|CPU_NEXT
argument_list|(
name|cpu_cur
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|err_path
label|:
name|ptnet_irqs_fini
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptnet_irqs_fini
parameter_list|(
name|struct
name|ptnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|sc
operator|->
name|queues
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|pq
operator|->
name|taskq
condition|)
block|{
name|taskqueue_free
argument_list|(
name|pq
operator|->
name|taskq
argument_list|)
expr_stmt|;
name|pq
operator|->
name|taskq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pq
operator|->
name|cookie
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|pq
operator|->
name|irq
argument_list|,
name|pq
operator|->
name|cookie
argument_list|)
expr_stmt|;
name|pq
operator|->
name|cookie
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pq
operator|->
name|irq
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|pq
operator|->
name|irq
argument_list|)
expr_stmt|;
name|pq
operator|->
name|irq
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|msix_mem
condition|)
block|{
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
name|PTNETMAP_MSIX_PCI_BAR
argument_list|)
argument_list|,
name|sc
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_mem
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ptnet_init
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|opaque
decl_stmt|;
name|PTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ptnet_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|PTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_ioctl
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SIOCSIFFLAGS %x\n"
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|PTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* Network stack wants the iff to be up. */
name|err
operator|=
name|ptnet_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Network stack wants the iff to be down. */
name|err
operator|=
name|ptnet_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* We don't need to do nothing to support IFF_PROMISC, 		 * since that is managed by the backend port. */
name|PTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SIOCSIFCAP %x %x\n"
argument_list|,
name|ifr
operator|->
name|ifr_reqcap
argument_list|,
name|ifp
operator|->
name|if_capenable
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|mask
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|err
operator|=
name|ether_poll_register
argument_list|(
name|ptnet_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
break|break;
block|}
comment|/* Stop queues and sync with taskqueues. */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|pq
operator|=
name|sc
operator|->
name|queues
operator|+
name|i
expr_stmt|;
comment|/* Make sure the worker sees the 					 * IFF_DRV_RUNNING down. */
name|PTNET_Q_LOCK
argument_list|(
name|pq
argument_list|)
expr_stmt|;
name|pq
operator|->
name|ptring
operator|->
name|guest_need_kick
operator|=
literal|0
expr_stmt|;
name|PTNET_Q_UNLOCK
argument_list|(
name|pq
argument_list|)
expr_stmt|;
comment|/* Wait for rescheduling to finish. */
if|if
condition|(
name|pq
operator|->
name|taskq
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|pq
operator|->
name|taskq
argument_list|,
operator|&
name|pq
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|pq
operator|=
name|sc
operator|->
name|queues
operator|+
name|i
expr_stmt|;
name|PTNET_Q_LOCK
argument_list|(
name|pq
argument_list|)
expr_stmt|;
name|pq
operator|->
name|ptring
operator|->
name|guest_need_kick
operator|=
literal|1
expr_stmt|;
name|PTNET_Q_UNLOCK
argument_list|(
name|pq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* DEVICE_POLLING */
name|ifp
operator|->
name|if_capenable
operator|=
name|ifr
operator|->
name|ifr_reqcap
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* We support any reasonable MTU. */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|<
name|ETHERMIN
operator|||
name|ifr
operator|->
name|ifr_mtu
operator|>
name|PTNET_MAX_PKT_SIZE
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|PTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|PTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|err
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_init_locked
parameter_list|(
name|struct
name|ptnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na_dr
init|=
operator|&
name|sc
operator|->
name|ptna
operator|->
name|dr
operator|.
name|up
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na_nm
init|=
operator|&
name|sc
operator|->
name|ptna
operator|->
name|hwup
operator|.
name|up
decl_stmt|;
name|unsigned
name|int
name|nm_buf_size
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
return|return
literal|0
return|;
comment|/* nothing to do */
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Translate offload capabilities according to if_capenable. */
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|PTNET_CSUM_OFFLOAD
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|PTNET_CSUM_OFFLOAD_IPV6
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_IP_TSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_IP6_TSO
expr_stmt|;
comment|/* 	 * Prepare the interface for netmap mode access. 	 */
name|netmap_update_config
argument_list|(
name|na_dr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|netmap_mem_finalize
argument_list|(
name|na_dr
operator|->
name|nm_mem
argument_list|,
name|na_dr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"netmap_mem_finalize() failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|ptna
operator|->
name|backend_regifs
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|ptnet_nm_krings_create
argument_list|(
name|na_nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"ptnet_nm_krings_create() "
literal|"failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_mem_finalize
goto|;
block|}
name|ret
operator|=
name|netmap_mem_rings_create
argument_list|(
name|na_dr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"netmap_mem_rings_create() "
literal|"failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_rings_create
goto|;
block|}
name|ret
operator|=
name|netmap_mem_get_lut
argument_list|(
name|na_dr
operator|->
name|nm_mem
argument_list|,
operator|&
name|na_dr
operator|->
name|na_lut
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"netmap_mem_get_lut() "
literal|"failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_get_lut
goto|;
block|}
block|}
name|ret
operator|=
name|ptnet_nm_register
argument_list|(
name|na_dr
argument_list|,
literal|1
comment|/* on */
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
goto|goto
name|err_register
goto|;
block|}
name|nm_buf_size
operator|=
name|NETMAP_BUF_SIZE
argument_list|(
name|na_dr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nm_buf_size
operator|>
literal|0
argument_list|,
operator|(
literal|"Invalid netmap buffer size"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|min_tx_space
operator|=
name|PTNET_MAX_PKT_SIZE
operator|/
name|nm_buf_size
operator|+
literal|2
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: min_tx_space = %u\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|min_tx_space
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PTNETMAP_STATS
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|tick
argument_list|,
name|hz
argument_list|,
name|ptnet_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
return|return
literal|0
return|;
name|err_register
label|:
name|memset
argument_list|(
operator|&
name|na_dr
operator|->
name|na_lut
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|na_dr
operator|->
name|na_lut
argument_list|)
argument_list|)
expr_stmt|;
name|err_get_lut
label|:
name|netmap_mem_rings_delete
argument_list|(
name|na_dr
argument_list|)
expr_stmt|;
name|err_rings_create
label|:
name|ptnet_nm_krings_delete
argument_list|(
name|na_nm
argument_list|)
expr_stmt|;
name|err_mem_finalize
label|:
name|netmap_mem_deref
argument_list|(
name|na_dr
operator|->
name|nm_mem
argument_list|,
name|na_dr
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* To be called under core lock. */
end_comment

begin_function
specifier|static
name|int
name|ptnet_stop
parameter_list|(
name|struct
name|ptnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na_dr
init|=
operator|&
name|sc
operator|->
name|ptna
operator|->
name|dr
operator|.
name|up
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na_nm
init|=
operator|&
name|sc
operator|->
name|ptna
operator|->
name|hwup
operator|.
name|up
decl_stmt|;
name|int
name|i
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
return|return
literal|0
return|;
comment|/* nothing to do */
block|}
comment|/* Clear the driver-ready flag, and synchronize with all the queues, 	 * so that after this loop we are sure nobody is working anymore with 	 * the device. This scheme is taken from the vtnet driver. */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|tick
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|PTNET_Q_LOCK
argument_list|(
name|sc
operator|->
name|queues
operator|+
name|i
argument_list|)
expr_stmt|;
name|PTNET_Q_UNLOCK
argument_list|(
name|sc
operator|->
name|queues
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|ptnet_nm_register
argument_list|(
name|na_dr
argument_list|,
literal|0
comment|/* off */
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ptna
operator|->
name|backend_regifs
operator|==
literal|0
condition|)
block|{
name|netmap_mem_rings_delete
argument_list|(
name|na_dr
argument_list|)
expr_stmt|;
name|ptnet_nm_krings_delete
argument_list|(
name|na_nm
argument_list|)
expr_stmt|;
block|}
name|netmap_mem_deref
argument_list|(
name|na_dr
operator|->
name|nm_mem
argument_list|,
name|na_dr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptnet_qflush
parameter_list|(
name|if_t
name|ifp
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Flush all the bufrings and do the interface flush. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|sc
operator|->
name|queues
operator|+
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|PTNET_Q_LOCK
argument_list|(
name|pq
argument_list|)
expr_stmt|;
if|if
condition|(
name|pq
operator|->
name|bufring
condition|)
block|{
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|pq
operator|->
name|bufring
argument_list|)
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|PTNET_Q_UNLOCK
argument_list|(
name|pq
argument_list|)
expr_stmt|;
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_media_change
parameter_list|(
name|if_t
name|ifp
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|sc
operator|->
name|media
decl_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100000
end_if

begin_function
specifier|static
name|uint64_t
name|ptnet_get_counter
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ptnet_queue_stats
name|stats
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Accumulate statistics over the queues. */
name|memset
argument_list|(
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|sc
operator|->
name|queues
operator|+
name|i
decl_stmt|;
name|int
name|idx
init|=
operator|(
name|i
operator|<
name|sc
operator|->
name|num_tx_rings
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|stats
index|[
name|idx
index|]
operator|.
name|packets
operator|+=
name|pq
operator|->
name|stats
operator|.
name|packets
expr_stmt|;
name|stats
index|[
name|idx
index|]
operator|.
name|bytes
operator|+=
name|pq
operator|->
name|stats
operator|.
name|bytes
expr_stmt|;
name|stats
index|[
name|idx
index|]
operator|.
name|errors
operator|+=
name|pq
operator|->
name|stats
operator|.
name|errors
expr_stmt|;
name|stats
index|[
name|idx
index|]
operator|.
name|iqdrops
operator|+=
name|pq
operator|->
name|stats
operator|.
name|iqdrops
expr_stmt|;
name|stats
index|[
name|idx
index|]
operator|.
name|mcasts
operator|+=
name|pq
operator|->
name|stats
operator|.
name|mcasts
expr_stmt|;
block|}
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
name|IFCOUNTER_IPACKETS
case|:
return|return
operator|(
name|stats
index|[
literal|1
index|]
operator|.
name|packets
operator|)
return|;
case|case
name|IFCOUNTER_IQDROPS
case|:
return|return
operator|(
name|stats
index|[
literal|1
index|]
operator|.
name|iqdrops
operator|)
return|;
case|case
name|IFCOUNTER_IERRORS
case|:
return|return
operator|(
name|stats
index|[
literal|1
index|]
operator|.
name|errors
operator|)
return|;
case|case
name|IFCOUNTER_OPACKETS
case|:
return|return
operator|(
name|stats
index|[
literal|0
index|]
operator|.
name|packets
operator|)
return|;
case|case
name|IFCOUNTER_OBYTES
case|:
return|return
operator|(
name|stats
index|[
literal|0
index|]
operator|.
name|bytes
operator|)
return|;
case|case
name|IFCOUNTER_OMCASTS
case|:
return|return
operator|(
name|stats
index|[
literal|0
index|]
operator|.
name|mcasts
operator|)
return|;
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PTNETMAP_STATS
end_ifdef

begin_comment
comment|/* Called under core lock. */
end_comment

begin_function
specifier|static
name|void
name|ptnet_tick
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|opaque
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|sc
operator|->
name|queues
operator|+
name|i
decl_stmt|;
name|struct
name|ptnet_queue_stats
name|cur
init|=
name|pq
operator|->
name|stats
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|unsigned
name|int
name|delta
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|delta
operator|=
name|now
operator|.
name|tv_usec
operator|-
name|sc
operator|->
name|last_ts
operator|.
name|tv_usec
operator|+
operator|(
name|now
operator|.
name|tv_sec
operator|-
name|sc
operator|->
name|last_ts
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
expr_stmt|;
name|delta
operator|/=
literal|1000
expr_stmt|;
comment|/* in milliseconds */
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
continue|continue;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"#%d[%u ms]:pkts %lu, kicks %lu, "
literal|"intr %lu\n"
argument_list|,
name|i
argument_list|,
name|delta
argument_list|,
operator|(
name|cur
operator|.
name|packets
operator|-
name|pq
operator|->
name|last_stats
operator|.
name|packets
operator|)
argument_list|,
operator|(
name|cur
operator|.
name|kicks
operator|-
name|pq
operator|->
name|last_stats
operator|.
name|kicks
operator|)
argument_list|,
operator|(
name|cur
operator|.
name|intrs
operator|-
name|pq
operator|->
name|last_stats
operator|.
name|intrs
operator|)
argument_list|)
expr_stmt|;
name|pq
operator|->
name|last_stats
operator|=
name|cur
expr_stmt|;
block|}
name|microtime
argument_list|(
operator|&
name|sc
operator|->
name|last_ts
argument_list|)
expr_stmt|;
name|callout_schedule
argument_list|(
operator|&
name|sc
operator|->
name|tick
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PTNETMAP_STATS */
end_comment

begin_function
specifier|static
name|void
name|ptnet_media_status
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
comment|/* We are always active, as the backend netmap port is 	 * always open in netmap mode. */
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
operator||
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_10G_T
operator||
name|IFM_FDX
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|ptnet_nm_ptctl
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|uint32_t
name|cmd
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_PTCTL
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_PTSTS
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"PTCTL %u, ret %u\n"
argument_list|,
name|cmd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_nm_config
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|unsigned
modifier|*
name|txr
parameter_list|,
name|unsigned
modifier|*
name|txd
parameter_list|,
name|unsigned
modifier|*
name|rxr
parameter_list|,
name|unsigned
modifier|*
name|rxd
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
decl_stmt|;
operator|*
name|txr
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_NUM_TX_RINGS
argument_list|)
expr_stmt|;
operator|*
name|rxr
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_NUM_RX_RINGS
argument_list|)
expr_stmt|;
operator|*
name|txd
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_NUM_TX_SLOTS
argument_list|)
expr_stmt|;
operator|*
name|rxd
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_NUM_RX_SLOTS
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"txr %u, rxr %u, txd %u, rxd %u\n"
argument_list|,
operator|*
name|txr
argument_list|,
operator|*
name|rxr
argument_list|,
operator|*
name|txd
argument_list|,
operator|*
name|rxd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptnet_sync_from_csb
parameter_list|(
name|struct
name|ptnet_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Sync krings from the host, reading from 	 * CSB. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptnet_ring
modifier|*
name|ptring
init|=
name|sc
operator|->
name|queues
index|[
name|i
index|]
operator|.
name|ptring
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|na
operator|->
name|num_tx_rings
condition|)
block|{
name|kring
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|i
expr_stmt|;
block|}
else|else
block|{
name|kring
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|i
operator|-
name|na
operator|->
name|num_tx_rings
expr_stmt|;
block|}
name|kring
operator|->
name|rhead
operator|=
name|kring
operator|->
name|ring
operator|->
name|head
operator|=
name|ptring
operator|->
name|head
expr_stmt|;
name|kring
operator|->
name|rcur
operator|=
name|kring
operator|->
name|ring
operator|->
name|cur
operator|=
name|ptring
operator|->
name|cur
expr_stmt|;
name|kring
operator|->
name|nr_hwcur
operator|=
name|ptring
operator|->
name|hwcur
expr_stmt|;
name|kring
operator|->
name|nr_hwtail
operator|=
name|kring
operator|->
name|rtail
operator|=
name|kring
operator|->
name|ring
operator|->
name|tail
operator|=
name|ptring
operator|->
name|hwtail
expr_stmt|;
name|ND
argument_list|(
literal|"%d,%d: csb {hc %u h %u c %u ht %u}"
argument_list|,
name|t
argument_list|,
name|i
argument_list|,
name|ptring
operator|->
name|hwcur
argument_list|,
name|ptring
operator|->
name|head
argument_list|,
name|ptring
operator|->
name|cur
argument_list|,
name|ptring
operator|->
name|hwtail
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"%d,%d: kring {hc %u rh %u rc %u h %u c %u ht %u rt %u t %u}"
argument_list|,
name|t
argument_list|,
name|i
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|rhead
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|head
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|kring
operator|->
name|rtail
argument_list|,
name|kring
operator|->
name|ring
operator|->
name|tail
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ptnet_update_vnet_hdr
parameter_list|(
name|struct
name|ptnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|int
name|wanted_hdr_len
init|=
name|ptnet_vnet_hdr
condition|?
name|PTNET_HDR_SIZE
else|:
literal|0
decl_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_VNET_HDR_LEN
argument_list|,
name|wanted_hdr_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vnet_hdr_len
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|iomem
argument_list|,
name|PTNET_IO_VNET_HDR_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ptna
operator|->
name|hwup
operator|.
name|up
operator|.
name|virt_hdr_len
operator|=
name|sc
operator|->
name|vnet_hdr_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_nm_register
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
comment|/* device-specific */
name|if_t
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|int
name|native
init|=
operator|(
name|na
operator|==
operator|&
name|sc
operator|->
name|ptna
operator|->
name|hwup
operator|.
name|up
operator|)
decl_stmt|;
name|struct
name|ptnet_queue
modifier|*
name|pq
decl_stmt|;
name|enum
name|txrx
name|t
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|onoff
condition|)
block|{
name|sc
operator|->
name|ptna
operator|->
name|backend_regifs
operator|--
expr_stmt|;
block|}
comment|/* If this is the last netmap client, guest interrupt enable flags may 	 * be in arbitrary state. Since these flags are going to be used also 	 * by the netdevice driver, we have to make sure to start with 	 * notifications enabled. Also, schedule NAPI to flush pending packets 	 * in the RX rings, since we will not receive further interrupts 	 * until these will be processed. */
if|if
condition|(
name|native
operator|&&
operator|!
name|onoff
operator|&&
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"Exit netmap mode, re-enable interrupts"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|pq
operator|=
name|sc
operator|->
name|queues
operator|+
name|i
expr_stmt|;
name|pq
operator|->
name|ptring
operator|->
name|guest_need_kick
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|onoff
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ptna
operator|->
name|backend_regifs
operator|==
literal|0
condition|)
block|{
comment|/* Initialize notification enable fields in the CSB. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|pq
operator|=
name|sc
operator|->
name|queues
operator|+
name|i
expr_stmt|;
name|pq
operator|->
name|ptring
operator|->
name|host_need_kick
operator|=
literal|1
expr_stmt|;
name|pq
operator|->
name|ptring
operator|->
name|guest_need_kick
operator|=
operator|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
operator|&&
name|i
operator|>=
name|sc
operator|->
name|num_tx_rings
operator|)
expr_stmt|;
block|}
comment|/* Set the virtio-net header length. */
name|ptnet_update_vnet_hdr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Make sure the host adapter passed through is ready 			 * for txsync/rxsync. */
name|ret
operator|=
name|ptnet_nm_ptctl
argument_list|(
name|ifp
argument_list|,
name|PTNETMAP_PTCTL_REGIF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
return|return
name|ret
return|;
block|}
block|}
comment|/* Sync from CSB must be done after REGIF PTCTL. Skip this 		 * step only if this is a netmap client and it is not the 		 * first one. */
if|if
condition|(
operator|(
operator|!
name|native
operator|&&
name|sc
operator|->
name|ptna
operator|->
name|backend_regifs
operator|==
literal|0
operator|)
operator|||
operator|(
name|native
operator|&&
name|na
operator|->
name|active_fds
operator|==
literal|0
operator|)
condition|)
block|{
name|ptnet_sync_from_csb
argument_list|(
name|sc
argument_list|,
name|na
argument_list|)
expr_stmt|;
block|}
comment|/* If not native, don't call nm_set_native_flags, since we don't want 		 * to replace if_transmit method, nor set NAF_NETMAP_ON */
if|if
condition|(
name|native
condition|)
block|{
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|nm_kring_pending_on
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|kring
operator|->
name|nr_mode
operator|=
name|NKR_NETMAP_ON
expr_stmt|;
block|}
block|}
block|}
name|nm_set_native_flags
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|native
condition|)
block|{
name|nm_clear_native_flags
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|for_rx_tx
argument_list|(
argument|t
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nma_get_nrings
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|NMR
argument_list|(
name|na
argument_list|,
name|t
argument_list|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|nm_kring_pending_off
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|kring
operator|->
name|nr_mode
operator|=
name|NKR_NETMAP_OFF
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Sync from CSB must be done before UNREGIF PTCTL, on the last 		 * netmap client. */
if|if
condition|(
name|native
operator|&&
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
block|{
name|ptnet_sync_from_csb
argument_list|(
name|sc
argument_list|,
name|na
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ptna
operator|->
name|backend_regifs
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|ptnet_nm_ptctl
argument_list|(
name|ifp
argument_list|,
name|PTNETMAP_PTCTL_UNREGIF
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|onoff
condition|)
block|{
name|sc
operator|->
name|ptna
operator|->
name|backend_regifs
operator|++
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_nm_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|kring
operator|->
name|na
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|sc
operator|->
name|queues
operator|+
name|kring
operator|->
name|ring_id
decl_stmt|;
name|bool
name|notify
decl_stmt|;
name|notify
operator|=
name|netmap_pt_guest_txsync
argument_list|(
name|pq
operator|->
name|ptring
argument_list|,
name|kring
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
condition|)
block|{
name|ptnet_kick
argument_list|(
name|pq
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_nm_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|kring
operator|->
name|na
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|sc
operator|->
name|rxqueues
operator|+
name|kring
operator|->
name|ring_id
decl_stmt|;
name|bool
name|notify
decl_stmt|;
name|notify
operator|=
name|netmap_pt_guest_rxsync
argument_list|(
name|pq
operator|->
name|ptring
argument_list|,
name|kring
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
condition|)
block|{
name|ptnet_kick
argument_list|(
name|pq
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptnet_tx_intr
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|opaque
decl_stmt|;
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|pq
operator|->
name|sc
decl_stmt|;
name|DBG
argument_list|(
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Tx interrupt #%d\n"
argument_list|,
name|pq
operator|->
name|kring_id
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PTNETMAP_STATS
name|pq
operator|->
name|stats
operator|.
name|intrs
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* PTNETMAP_STATS */
if|if
condition|(
name|netmap_tx_irq
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|pq
operator|->
name|kring_id
argument_list|)
operator|!=
name|NM_IRQ_PASS
condition|)
block|{
return|return;
block|}
comment|/* Schedule the tasqueue to flush process transmissions requests. 	 * However, vtnet, if_em and if_igb just call ptnet_transmit() here, 	 * at least when using MSI-X interrupts. The if_em driver, instead 	 * schedule taskqueue when using legacy interrupts. */
name|taskqueue_enqueue
argument_list|(
name|pq
operator|->
name|taskq
argument_list|,
operator|&
name|pq
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptnet_rx_intr
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|opaque
decl_stmt|;
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|pq
operator|->
name|sc
decl_stmt|;
name|unsigned
name|int
name|unused
decl_stmt|;
name|DBG
argument_list|(
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Rx interrupt #%d\n"
argument_list|,
name|pq
operator|->
name|kring_id
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PTNETMAP_STATS
name|pq
operator|->
name|stats
operator|.
name|intrs
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* PTNETMAP_STATS */
if|if
condition|(
name|netmap_rx_irq
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|pq
operator|->
name|kring_id
argument_list|,
operator|&
name|unused
argument_list|)
operator|!=
name|NM_IRQ_PASS
condition|)
block|{
return|return;
block|}
comment|/* Like vtnet, if_igb and if_em drivers when using MSI-X interrupts, 	 * receive-side processing is executed directly in the interrupt 	 * service routine. Alternatively, we may schedule the taskqueue. */
name|ptnet_rx_eof
argument_list|(
name|pq
argument_list|,
name|PTNET_RX_BUDGET
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following offloadings-related functions are taken from the vtnet  * driver, but the same functionality is required for the ptnet driver.  * As a temporary solution, I copied this code from vtnet and I started  * to generalize it (taking away driver-specific statistic accounting),  * making as little modifications as possible.  * In the future we need to share these functions between vtnet and ptnet.  */
end_comment

begin_function
specifier|static
name|int
name|ptnet_tx_offload_ctx
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|etype
parameter_list|,
name|int
modifier|*
name|proto
parameter_list|,
name|int
modifier|*
name|start
parameter_list|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|evh
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|evh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|evh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
comment|/* BMV: We should handle nested VLAN tags too. */
operator|*
name|etype
operator|=
name|ntohs
argument_list|(
name|evh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|etype
operator|=
name|ntohs
argument_list|(
name|evh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|etype
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
case|case
name|ETHERTYPE_IP
case|:
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|,
name|iphdr
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
condition|)
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iphdr
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|&
name|iphdr
expr_stmt|;
block|}
else|else
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|offset
operator|)
expr_stmt|;
operator|*
name|proto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
operator|*
name|start
operator|=
name|offset
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
case|case
name|ETHERTYPE_IPV6
case|:
operator|*
name|proto
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|start
operator|=
name|ip6_lasthdr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|proto
argument_list|)
expr_stmt|;
comment|/* Assert the network stack sent us a valid packet. */
name|KASSERT
argument_list|(
operator|*
name|start
operator|>
name|offset
argument_list|,
operator|(
literal|"%s: mbuf %p start %d offset %d proto %d"
operator|,
name|__func__
operator|,
name|m
operator|,
operator|*
name|start
operator|,
name|offset
operator|,
operator|*
name|proto
operator|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* Here we should increment the tx_csum_bad_ethtype counter. */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_tx_offload_tso
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|eth_type
parameter_list|,
name|int
name|offset
parameter_list|,
name|bool
name|allow_ecn
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
parameter_list|)
block|{
specifier|static
name|struct
name|timeval
name|lastecn
decl_stmt|;
specifier|static
name|int
name|curecn
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|,
name|tcphdr
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
condition|)
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tcphdr
argument_list|)
expr_stmt|;
name|tcp
operator|=
operator|&
name|tcphdr
expr_stmt|;
block|}
else|else
name|tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|offset
operator|)
expr_stmt|;
name|hdr
operator|->
name|hdr_len
operator|=
name|offset
operator|+
operator|(
name|tcp
operator|->
name|th_off
operator|<<
literal|2
operator|)
expr_stmt|;
name|hdr
operator|->
name|gso_size
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
name|hdr
operator|->
name|gso_type
operator|=
name|eth_type
operator|==
name|ETHERTYPE_IP
condition|?
name|VIRTIO_NET_HDR_GSO_TCPV4
else|:
name|VIRTIO_NET_HDR_GSO_TCPV6
expr_stmt|;
if|if
condition|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_CWR
condition|)
block|{
comment|/* 		 * Drop if VIRTIO_NET_F_HOST_ECN was not negotiated. In FreeBSD, 		 * ECN support is not on a per-interface basis, but globally via 		 * the net.inet.tcp.ecn.enable sysctl knob. The default is off. 		 */
if|if
condition|(
operator|!
name|allow_ecn
condition|)
block|{
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|lastecn
argument_list|,
operator|&
name|curecn
argument_list|,
literal|1
argument_list|)
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TSO with ECN not negotiated with host\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|hdr
operator|->
name|gso_type
operator||=
name|VIRTIO_NET_HDR_GSO_ECN
expr_stmt|;
block|}
comment|/* Here we should increment tx_tso counter. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ptnet_tx_offload
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|bool
name|allow_ecn
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|int
name|flags
decl_stmt|,
name|etype
decl_stmt|,
name|csum_start
decl_stmt|,
name|proto
decl_stmt|,
name|error
decl_stmt|;
name|flags
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
expr_stmt|;
name|error
operator|=
name|ptnet_tx_offload_ctx
argument_list|(
name|m
argument_list|,
operator|&
name|etype
argument_list|,
operator|&
name|proto
argument_list|,
operator|&
name|csum_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
operator|(
name|etype
operator|==
name|ETHERTYPE_IP
operator|&&
name|flags
operator|&
name|PTNET_CSUM_OFFLOAD
operator|)
operator|||
operator|(
name|etype
operator|==
name|ETHERTYPE_IPV6
operator|&&
name|flags
operator|&
name|PTNET_CSUM_OFFLOAD_IPV6
operator|)
condition|)
block|{
comment|/* 		 * We could compare the IP protocol vs the CSUM_ flag too, 		 * but that really should not be necessary. 		 */
name|hdr
operator|->
name|flags
operator||=
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
expr_stmt|;
name|hdr
operator|->
name|csum_start
operator|=
name|csum_start
expr_stmt|;
name|hdr
operator|->
name|csum_offset
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
comment|/* Here we should increment the tx_csum counter. */
block|}
if|if
condition|(
name|flags
operator|&
name|CSUM_TSO
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|proto
operator|!=
name|IPPROTO_TCP
argument_list|)
condition|)
block|{
comment|/* Likely failed to correctly parse the mbuf. 			 * Here we should increment the tx_tso_not_tcp 			 * counter. */
goto|goto
name|drop
goto|;
block|}
name|KASSERT
argument_list|(
name|hdr
operator|->
name|flags
operator|&
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
argument_list|,
operator|(
literal|"%s: mbuf %p TSO without checksum offload %#x"
operator|,
name|__func__
operator|,
name|m
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ptnet_tx_offload_tso
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|etype
argument_list|,
name|csum_start
argument_list|,
name|allow_ecn
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|drop
goto|;
block|}
return|return
operator|(
name|m
operator|)
return|;
name|drop
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptnet_vlan_tag_remove
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|evh
decl_stmt|;
name|evh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|ntohs
argument_list|(
name|evh
operator|->
name|evl_tag
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
comment|/* Strip the 802.1Q header. */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|evh
argument_list|,
operator|(
name|char
operator|*
operator|)
name|evh
operator|+
name|ETHER_VLAN_ENCAP_LEN
argument_list|,
name|ETHER_HDR_LEN
operator|-
name|ETHER_TYPE_LEN
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_VLAN_ENCAP_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Use the checksum offset in the VirtIO header to set the  * correct CSUM_* flags.  */
end_comment

begin_function
specifier|static
name|int
name|ptnet_rx_csum_by_offset
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint16_t
name|eth_type
parameter_list|,
name|int
name|ip_start
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|int
name|offset
init|=
name|hdr
operator|->
name|csum_start
operator|+
name|hdr
operator|->
name|csum_offset
decl_stmt|;
endif|#
directive|endif
comment|/* Only do a basic sanity check on the offset. */
switch|switch
condition|(
name|eth_type
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
case|case
name|ETHERTYPE_IP
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|offset
operator|<
name|ip_start
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
case|case
name|ETHERTYPE_IPV6
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|offset
operator|<
name|ip_start
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
endif|#
directive|endif
default|default:
comment|/* Here we should increment the rx_csum_bad_ethtype counter. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Use the offset to determine the appropriate CSUM_* flags. This is 	 * a bit dirty, but we can get by with it since the checksum offsets 	 * happen to be different. We assume the host host does not do IPv4 	 * header checksum offloading. 	 */
switch|switch
condition|(
name|hdr
operator|->
name|csum_offset
condition|)
block|{
case|case
name|offsetof
argument_list|(
expr|struct
name|udphdr
argument_list|,
name|uh_sum
argument_list|)
case|:
case|case
name|offsetof
argument_list|(
expr|struct
name|tcphdr
argument_list|,
name|th_sum
argument_list|)
case|:
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xFFFF
expr_stmt|;
break|break;
case|case
name|offsetof
argument_list|(
expr|struct
name|sctphdr
argument_list|,
name|checksum
argument_list|)
case|:
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_SCTP_VALID
expr_stmt|;
break|break;
default|default:
comment|/* Here we should increment the rx_csum_bad_offset counter. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_rx_csum_by_parse
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint16_t
name|eth_type
parameter_list|,
name|int
name|ip_start
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|int
name|offset
decl_stmt|,
name|proto
decl_stmt|;
switch|switch
condition|(
name|eth_type
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
case|case
name|ETHERTYPE_IP
case|:
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|ip_start
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|ip_start
operator|)
expr_stmt|;
name|proto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|offset
operator|=
name|ip_start
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
case|case
name|ETHERTYPE_IPV6
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|ip_start
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|offset
operator|=
name|ip6_lasthdr
argument_list|(
name|m
argument_list|,
name|ip_start
argument_list|,
name|IPPROTO_IPV6
argument_list|,
operator|&
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|offset
operator|<
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
endif|#
directive|endif
default|default:
comment|/* Here we should increment the rx_csum_bad_ethtype counter. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xFFFF
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xFFFF
expr_stmt|;
break|break;
case|case
name|IPPROTO_SCTP
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_SCTP_VALID
expr_stmt|;
break|break;
default|default:
comment|/* 		 * For the remaining protocols, FreeBSD does not support 		 * checksum offloading, so the checksum will be recomputed. 		 */
if|#
directive|if
literal|0
block|if_printf(ifp, "cksum offload of unsupported " 		    "protocol eth_type=%#x proto=%d csum_start=%d " 		    "csum_offset=%d\n", __func__, eth_type, proto, 		    hdr->csum_start, hdr->csum_offset);
endif|#
directive|endif
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the appropriate CSUM_* flags. Unfortunately, the information  * provided is not directly useful to us. The VirtIO header gives the  * offset of the checksum, which is all Linux needs, but this is not  * how FreeBSD does things. We are forced to peek inside the packet  * a bit.  *  * It would be nice if VirtIO gave us the L4 protocol or if FreeBSD  * could accept the offsets and let the stack figure it out.  */
end_comment

begin_function
specifier|static
name|int
name|ptnet_rx_csum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|evh
decl_stmt|;
name|uint16_t
name|eth_type
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|error
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|eth_type
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth_type
operator|==
name|ETHERTYPE_VLAN
condition|)
block|{
comment|/* BMV: We should handle nested VLAN tags too. */
name|evh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|eth_type
operator|=
name|ntohs
argument_list|(
name|evh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|flags
operator|&
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
condition|)
name|error
operator|=
name|ptnet_rx_csum_by_offset
argument_list|(
name|m
argument_list|,
name|eth_type
argument_list|,
name|offset
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ptnet_rx_csum_by_parse
argument_list|(
name|m
argument_list|,
name|eth_type
argument_list|,
name|offset
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* End of offloading-related functions to be shared with vtnet. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ptnet_sync_tail
parameter_list|(
name|struct
name|ptnet_ring
modifier|*
name|ptring
parameter_list|,
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
comment|/* Update hwcur and hwtail as known by the host. */
name|ptnetmap_guest_read_kring_csb
argument_list|(
name|ptring
argument_list|,
name|kring
argument_list|)
expr_stmt|;
comment|/* nm_sync_finalize */
name|ring
operator|->
name|tail
operator|=
name|kring
operator|->
name|rtail
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptnet_ring_update
parameter_list|(
name|struct
name|ptnet_queue
modifier|*
name|pq
parameter_list|,
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|unsigned
name|int
name|head
parameter_list|,
name|unsigned
name|int
name|sync_flags
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|ptnet_ring
modifier|*
name|ptring
init|=
name|pq
operator|->
name|ptring
decl_stmt|;
comment|/* Some packets have been pushed to the netmap ring. We have 	 * to tell the host to process the new packets, updating cur 	 * and head in the CSB. */
name|ring
operator|->
name|head
operator|=
name|ring
operator|->
name|cur
operator|=
name|head
expr_stmt|;
comment|/* Mimic nm_txsync_prologue/nm_rxsync_prologue. */
name|kring
operator|->
name|rcur
operator|=
name|kring
operator|->
name|rhead
operator|=
name|head
expr_stmt|;
name|ptnetmap_guest_write_kring_csb
argument_list|(
name|ptring
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|rhead
argument_list|)
expr_stmt|;
comment|/* Kick the host if needed. */
if|if
condition|(
name|NM_ACCESS_ONCE
argument_list|(
name|ptring
operator|->
name|host_need_kick
argument_list|)
condition|)
block|{
name|ptring
operator|->
name|sync_flags
operator|=
name|sync_flags
expr_stmt|;
name|ptnet_kick
argument_list|(
name|pq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|PTNET_TX_NOSPACE
parameter_list|(
name|_h
parameter_list|,
name|_k
parameter_list|,
name|_min
parameter_list|)
define|\
value|((((_h)< (_k)->rtail) ? 0 : (_k)->nkr_num_slots) + \ 		(_k)->rtail - (_h))< (_min)
end_define

begin_comment
comment|/* This function may be called by the network stack, or by  * by the taskqueue thread. */
end_comment

begin_function
specifier|static
name|int
name|ptnet_drain_transmit_queue
parameter_list|(
name|struct
name|ptnet_queue
modifier|*
name|pq
parameter_list|,
name|unsigned
name|int
name|budget
parameter_list|,
name|bool
name|may_resched
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|pq
operator|->
name|sc
decl_stmt|;
name|bool
name|have_vnet_hdr
init|=
name|sc
operator|->
name|vnet_hdr_len
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
operator|&
name|sc
operator|->
name|ptna
operator|->
name|dr
operator|.
name|up
decl_stmt|;
name|if_t
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|unsigned
name|int
name|batch_count
init|=
literal|0
decl_stmt|;
name|struct
name|ptnet_ring
modifier|*
name|ptring
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|minspace
decl_stmt|;
name|unsigned
name|int
name|head
decl_stmt|;
name|unsigned
name|int
name|lim
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mhead
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mf
decl_stmt|;
name|int
name|nmbuf_bytes
decl_stmt|;
name|uint8_t
modifier|*
name|nmbuf
decl_stmt|;
if|if
condition|(
operator|!
name|PTNET_Q_TRYLOCK
argument_list|(
name|pq
argument_list|)
condition|)
block|{
comment|/* We failed to acquire the lock, schedule the taskqueue. */
name|RD
argument_list|(
literal|1
argument_list|,
literal|"Deferring TX work"
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_resched
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|pq
operator|->
name|taskq
argument_list|,
operator|&
name|pq
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
argument_list|)
condition|)
block|{
name|PTNET_Q_UNLOCK
argument_list|(
name|pq
argument_list|)
expr_stmt|;
name|RD
argument_list|(
literal|1
argument_list|,
literal|"Interface is down"
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
name|ptring
operator|=
name|pq
operator|->
name|ptring
expr_stmt|;
name|kring
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|pq
operator|->
name|kring_id
expr_stmt|;
name|ring
operator|=
name|kring
operator|->
name|ring
expr_stmt|;
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
name|head
operator|=
name|ring
operator|->
name|head
expr_stmt|;
name|minspace
operator|=
name|sc
operator|->
name|min_tx_space
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|budget
condition|)
block|{
if|if
condition|(
name|PTNET_TX_NOSPACE
argument_list|(
name|head
argument_list|,
name|kring
argument_list|,
name|minspace
argument_list|)
condition|)
block|{
comment|/* We ran out of slot, let's see if the host has 			 * freed up some, by reading hwcur and hwtail from 			 * the CSB. */
name|ptnet_sync_tail
argument_list|(
name|ptring
argument_list|,
name|kring
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTNET_TX_NOSPACE
argument_list|(
name|head
argument_list|,
name|kring
argument_list|,
name|minspace
argument_list|)
condition|)
block|{
comment|/* Still no slots available. Reactivate the 				 * interrupts so that we can be notified 				 * when some free slots are made available by 				 * the host. */
name|ptring
operator|->
name|guest_need_kick
operator|=
literal|1
expr_stmt|;
comment|/* Double-check. */
name|ptnet_sync_tail
argument_list|(
name|ptring
argument_list|,
name|kring
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|PTNET_TX_NOSPACE
argument_list|(
name|head
argument_list|,
name|kring
argument_list|,
name|minspace
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
name|RD
argument_list|(
literal|1
argument_list|,
literal|"Found more slots by doublecheck"
argument_list|)
expr_stmt|;
comment|/* More slots were freed before reactivating 				 * the interrupts. */
name|ptring
operator|->
name|guest_need_kick
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|mhead
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|pq
operator|->
name|bufring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mhead
condition|)
block|{
break|break;
block|}
comment|/* Initialize transmission state variables. */
name|slot
operator|=
name|ring
operator|->
name|slot
operator|+
name|head
expr_stmt|;
name|nmbuf
operator|=
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|nmbuf_bytes
operator|=
literal|0
expr_stmt|;
comment|/* If needed, prepare the virtio-net header at the beginning 		 * of the first slot. */
if|if
condition|(
name|have_vnet_hdr
condition|)
block|{
name|struct
name|virtio_net_hdr
modifier|*
name|vh
init|=
operator|(
expr|struct
name|virtio_net_hdr
operator|*
operator|)
name|nmbuf
decl_stmt|;
comment|/* For performance, we could replace this memset() with 			 * two 8-bytes-wide writes. */
name|memset
argument_list|(
name|nmbuf
argument_list|,
literal|0
argument_list|,
name|PTNET_HDR_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhead
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|PTNET_ALL_OFFLOAD
condition|)
block|{
name|mhead
operator|=
name|ptnet_tx_offload
argument_list|(
name|ifp
argument_list|,
name|mhead
argument_list|,
name|false
argument_list|,
name|vh
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|mhead
argument_list|)
condition|)
block|{
comment|/* Packet dropped because errors 					 * occurred while preparing the vnet 					 * header. Let's go ahead with the next 					 * packet. */
name|pq
operator|->
name|stats
operator|.
name|errors
operator|++
expr_stmt|;
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|pq
operator|->
name|bufring
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|ND
argument_list|(
literal|1
argument_list|,
literal|"%s: [csum_flags %lX] vnet hdr: flags %x "
literal|"csum_start %u csum_ofs %u hdr_len = %u "
literal|"gso_size %u gso_type %x"
argument_list|,
name|__func__
argument_list|,
name|mhead
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|,
name|vh
operator|->
name|flags
argument_list|,
name|vh
operator|->
name|csum_start
argument_list|,
name|vh
operator|->
name|csum_offset
argument_list|,
name|vh
operator|->
name|hdr_len
argument_list|,
name|vh
operator|->
name|gso_size
argument_list|,
name|vh
operator|->
name|gso_type
argument_list|)
expr_stmt|;
name|nmbuf
operator|+=
name|PTNET_HDR_SIZE
expr_stmt|;
name|nmbuf_bytes
operator|+=
name|PTNET_HDR_SIZE
expr_stmt|;
block|}
for|for
control|(
name|mf
operator|=
name|mhead
init|;
name|mf
condition|;
name|mf
operator|=
name|mf
operator|->
name|m_next
control|)
block|{
name|uint8_t
modifier|*
name|mdata
init|=
name|mf
operator|->
name|m_data
decl_stmt|;
name|int
name|mlen
init|=
name|mf
operator|->
name|m_len
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|copy
init|=
name|NETMAP_BUF_SIZE
argument_list|(
name|na
argument_list|)
operator|-
name|nmbuf_bytes
decl_stmt|;
if|if
condition|(
name|mlen
operator|<
name|copy
condition|)
block|{
name|copy
operator|=
name|mlen
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|nmbuf
argument_list|,
name|mdata
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|mdata
operator|+=
name|copy
expr_stmt|;
name|mlen
operator|-=
name|copy
expr_stmt|;
name|nmbuf
operator|+=
name|copy
expr_stmt|;
name|nmbuf_bytes
operator|+=
name|copy
expr_stmt|;
if|if
condition|(
operator|!
name|mlen
condition|)
block|{
break|break;
block|}
name|slot
operator|->
name|len
operator|=
name|nmbuf_bytes
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
name|NS_MOREFRAG
expr_stmt|;
name|head
operator|=
name|nm_next
argument_list|(
name|head
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|head
operator|!=
name|ring
operator|->
name|tail
argument_list|,
operator|(
literal|"Unexpectedly run out of TX space"
operator|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|ring
operator|->
name|slot
operator|+
name|head
expr_stmt|;
name|nmbuf
operator|=
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|nmbuf_bytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Complete last slot and update head. */
name|slot
operator|->
name|len
operator|=
name|nmbuf_bytes
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|head
operator|=
name|nm_next
argument_list|(
name|head
argument_list|,
name|lim
argument_list|)
expr_stmt|;
comment|/* Consume the packet just processed. */
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|pq
operator|->
name|bufring
argument_list|)
expr_stmt|;
comment|/* Copy the packet to listeners. */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|mhead
argument_list|)
expr_stmt|;
name|pq
operator|->
name|stats
operator|.
name|packets
operator|++
expr_stmt|;
name|pq
operator|->
name|stats
operator|.
name|bytes
operator|+=
name|mhead
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|mhead
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
block|{
name|pq
operator|->
name|stats
operator|.
name|mcasts
operator|++
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|mhead
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|batch_count
operator|==
name|PTNET_TX_BATCH
condition|)
block|{
name|ptnet_ring_update
argument_list|(
name|pq
argument_list|,
name|kring
argument_list|,
name|head
argument_list|,
name|NAF_FORCE_RECLAIM
argument_list|)
expr_stmt|;
name|batch_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|batch_count
condition|)
block|{
name|ptnet_ring_update
argument_list|(
name|pq
argument_list|,
name|kring
argument_list|,
name|head
argument_list|,
name|NAF_FORCE_RECLAIM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>=
name|budget
operator|&&
name|may_resched
condition|)
block|{
name|DBG
argument_list|(
name|RD
argument_list|(
literal|1
argument_list|,
literal|"out of budget: resched, %d mbufs pending\n"
argument_list|,
name|drbr_inuse
argument_list|(
name|ifp
argument_list|,
name|pq
operator|->
name|bufring
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|pq
operator|->
name|taskq
argument_list|,
operator|&
name|pq
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
name|PTNET_Q_UNLOCK
argument_list|(
name|pq
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_transmit
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ptnet_queue
modifier|*
name|pq
decl_stmt|;
name|unsigned
name|int
name|queue_idx
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DBG
argument_list|(
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"transmit %p\n"
argument_list|,
name|m
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert 802.1Q header if needed. */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|m
operator|=
name|ether_vlanencap
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOBUFS
return|;
block|}
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_VLANTAG
expr_stmt|;
block|}
comment|/* Get the flow-id if available. */
name|queue_idx
operator|=
operator|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
operator|)
condition|?
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
else|:
name|curcpu
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|queue_idx
operator|>=
name|sc
operator|->
name|num_tx_rings
argument_list|)
condition|)
block|{
name|queue_idx
operator|%=
name|sc
operator|->
name|num_tx_rings
expr_stmt|;
block|}
name|pq
operator|=
name|sc
operator|->
name|queues
operator|+
name|queue_idx
expr_stmt|;
name|err
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|pq
operator|->
name|bufring
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* ENOBUFS when the bufring is full */
name|RD
argument_list|(
literal|1
argument_list|,
literal|"%s: drbr_enqueue() failed %d\n"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|pq
operator|->
name|stats
operator|.
name|errors
operator|++
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
comment|/* If polling is on, the transmit queues will be 		 * drained by the poller. */
return|return
literal|0
return|;
block|}
name|err
operator|=
name|ptnet_drain_transmit_queue
argument_list|(
name|pq
argument_list|,
name|PTNET_TX_BUDGET
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|<
literal|0
operator|)
condition|?
name|err
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|ptnet_rx_discard
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|unsigned
name|int
name|head
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
name|ring
operator|->
name|slot
operator|+
name|head
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|head
operator|=
name|nm_next
argument_list|(
name|head
argument_list|,
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_MOREFRAG
operator|)
operator|||
name|head
operator|==
name|ring
operator|->
name|tail
condition|)
block|{
break|break;
block|}
name|slot
operator|=
name|ring
operator|->
name|slot
operator|+
name|head
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|mbuf
modifier|*
name|ptnet_rx_slot
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mtail
parameter_list|,
name|uint8_t
modifier|*
name|nmbuf
parameter_list|,
name|unsigned
name|int
name|nmbuf_len
parameter_list|)
block|{
name|uint8_t
modifier|*
name|mdata
init|=
name|mtod
argument_list|(
name|mtail
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|mtail
operator|->
name|m_len
decl_stmt|;
do|do
block|{
name|unsigned
name|int
name|copy
decl_stmt|;
if|if
condition|(
name|mtail
operator|->
name|m_len
operator|==
name|MCLBYTES
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mf
decl_stmt|;
name|mf
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|mf
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|mtail
operator|->
name|m_next
operator|=
name|mf
expr_stmt|;
name|mtail
operator|=
name|mf
expr_stmt|;
name|mdata
operator|=
name|mtod
argument_list|(
name|mtail
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|mtail
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
block|}
name|copy
operator|=
name|MCLBYTES
operator|-
name|mtail
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|nmbuf_len
operator|<
name|copy
condition|)
block|{
name|copy
operator|=
name|nmbuf_len
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|mdata
argument_list|,
name|nmbuf
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|nmbuf
operator|+=
name|copy
expr_stmt|;
name|nmbuf_len
operator|-=
name|copy
expr_stmt|;
name|mdata
operator|+=
name|copy
expr_stmt|;
name|mtail
operator|->
name|m_len
operator|+=
name|copy
expr_stmt|;
block|}
do|while
condition|(
name|nmbuf_len
condition|)
do|;
return|return
name|mtail
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptnet_rx_eof
parameter_list|(
name|struct
name|ptnet_queue
modifier|*
name|pq
parameter_list|,
name|unsigned
name|int
name|budget
parameter_list|,
name|bool
name|may_resched
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|pq
operator|->
name|sc
decl_stmt|;
name|bool
name|have_vnet_hdr
init|=
name|sc
operator|->
name|vnet_hdr_len
decl_stmt|;
name|struct
name|ptnet_ring
modifier|*
name|ptring
init|=
name|pq
operator|->
name|ptring
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
operator|&
name|sc
operator|->
name|ptna
operator|->
name|dr
operator|.
name|up
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
name|na
operator|->
name|rx_rings
operator|+
name|pq
operator|->
name|kring_id
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|unsigned
name|int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|head
init|=
name|ring
operator|->
name|head
decl_stmt|;
name|unsigned
name|int
name|batch_count
init|=
literal|0
decl_stmt|;
name|if_t
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|PTNET_Q_LOCK
argument_list|(
name|pq
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
argument_list|)
condition|)
block|{
goto|goto
name|unlock
goto|;
block|}
name|kring
operator|->
name|nr_kflags
operator|&=
operator|~
name|NKR_PENDINTR
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|budget
condition|)
block|{
name|unsigned
name|int
name|prev_head
init|=
name|head
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mhead
decl_stmt|,
modifier|*
name|mtail
decl_stmt|;
name|struct
name|virtio_net_hdr
modifier|*
name|vh
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|unsigned
name|int
name|nmbuf_len
decl_stmt|;
name|uint8_t
modifier|*
name|nmbuf
decl_stmt|;
name|host_sync
label|:
if|if
condition|(
name|head
operator|==
name|ring
operator|->
name|tail
condition|)
block|{
comment|/* We ran out of slot, let's see if the host has 			 * added some, by reading hwcur and hwtail from 			 * the CSB. */
name|ptnet_sync_tail
argument_list|(
name|ptring
argument_list|,
name|kring
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|ring
operator|->
name|tail
condition|)
block|{
comment|/* Still no slots available. Reactivate 				 * interrupts as they were disabled by the 				 * host thread right before issuing the 				 * last interrupt. */
name|ptring
operator|->
name|guest_need_kick
operator|=
literal|1
expr_stmt|;
comment|/* Double-check. */
name|ptnet_sync_tail
argument_list|(
name|ptring
argument_list|,
name|kring
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|head
operator|==
name|ring
operator|->
name|tail
argument_list|)
condition|)
block|{
break|break;
block|}
name|ptring
operator|->
name|guest_need_kick
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Initialize ring state variables, possibly grabbing the 		 * virtio-net header. */
name|slot
operator|=
name|ring
operator|->
name|slot
operator|+
name|head
expr_stmt|;
name|nmbuf
operator|=
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|nmbuf_len
operator|=
name|slot
operator|->
name|len
expr_stmt|;
name|vh
operator|=
operator|(
expr|struct
name|virtio_net_hdr
operator|*
operator|)
name|nmbuf
expr_stmt|;
if|if
condition|(
name|have_vnet_hdr
condition|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|nmbuf_len
operator|<
name|PTNET_HDR_SIZE
argument_list|)
condition|)
block|{
comment|/* There is no good reason why host should 				 * put the header in multiple netmap slots. 				 * If this is the case, discard. */
name|RD
argument_list|(
literal|1
argument_list|,
literal|"Fragmented vnet-hdr: dropping"
argument_list|)
expr_stmt|;
name|head
operator|=
name|ptnet_rx_discard
argument_list|(
name|kring
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|pq
operator|->
name|stats
operator|.
name|iqdrops
operator|++
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|ND
argument_list|(
literal|1
argument_list|,
literal|"%s: vnet hdr: flags %x csum_start %u "
literal|"csum_ofs %u hdr_len = %u gso_size %u "
literal|"gso_type %x"
argument_list|,
name|__func__
argument_list|,
name|vh
operator|->
name|flags
argument_list|,
name|vh
operator|->
name|csum_start
argument_list|,
name|vh
operator|->
name|csum_offset
argument_list|,
name|vh
operator|->
name|hdr_len
argument_list|,
name|vh
operator|->
name|gso_size
argument_list|,
name|vh
operator|->
name|gso_type
argument_list|)
expr_stmt|;
name|nmbuf
operator|+=
name|PTNET_HDR_SIZE
expr_stmt|;
name|nmbuf_len
operator|-=
name|PTNET_HDR_SIZE
expr_stmt|;
block|}
comment|/* Allocate the head of a new mbuf chain. 		 * We use m_getcl() to allocate an mbuf with standard cluster 		 * size (MCLBYTES). In the future we could use m_getjcl() 		 * to choose different sizes. */
name|mhead
operator|=
name|mtail
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|mhead
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: failed to allocate mbuf "
literal|"head\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|pq
operator|->
name|stats
operator|.
name|errors
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Initialize the mbuf state variables. */
name|mhead
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|nmbuf_len
expr_stmt|;
name|mtail
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
comment|/* Scan all the netmap slots containing the current packet. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|DBG
argument_list|(
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: h %u t %u rcv frag "
literal|"len %u, flags %u\n"
argument_list|,
name|__func__
argument_list|,
name|head
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|slot
operator|->
name|len
argument_list|,
name|slot
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|mtail
operator|=
name|ptnet_rx_slot
argument_list|(
name|mtail
argument_list|,
name|nmbuf
argument_list|,
name|nmbuf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|mtail
argument_list|)
condition|)
block|{
comment|/* Ouch. We ran out of memory while processing 				 * a packet. We have to restore the previous 				 * head position, free the mbuf chain, and 				 * schedule the taskqueue to give the packet 				 * another chance. */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: failed to allocate"
literal|" mbuf frag, reset head %u --> %u\n"
argument_list|,
name|__func__
argument_list|,
name|head
argument_list|,
name|prev_head
argument_list|)
expr_stmt|;
name|head
operator|=
name|prev_head
expr_stmt|;
name|m_freem
argument_list|(
name|mhead
argument_list|)
expr_stmt|;
name|pq
operator|->
name|stats
operator|.
name|errors
operator|++
expr_stmt|;
if|if
condition|(
name|may_resched
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|pq
operator|->
name|taskq
argument_list|,
operator|&
name|pq
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
goto|goto
name|escape
goto|;
block|}
comment|/* We have to increment head irrespective of the 			 * NS_MOREFRAG being set or not. */
name|head
operator|=
name|nm_next
argument_list|(
name|head
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_MOREFRAG
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|head
operator|==
name|ring
operator|->
name|tail
argument_list|)
condition|)
block|{
comment|/* The very last slot prepared by the host has 				 * the NS_MOREFRAG set. Drop it and continue 				 * the outer cycle (to do the double-check). */
name|RD
argument_list|(
literal|1
argument_list|,
literal|"Incomplete packet: dropping"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mhead
argument_list|)
expr_stmt|;
name|pq
operator|->
name|stats
operator|.
name|iqdrops
operator|++
expr_stmt|;
goto|goto
name|host_sync
goto|;
block|}
name|slot
operator|=
name|ring
operator|->
name|slot
operator|+
name|head
expr_stmt|;
name|nmbuf
operator|=
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|nmbuf_len
operator|=
name|slot
operator|->
name|len
expr_stmt|;
name|mhead
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|nmbuf_len
expr_stmt|;
block|}
name|mhead
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|mhead
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
comment|/* Store the queue idx in the packet header. */
name|mhead
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|pq
operator|->
name|kring_id
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|mhead
argument_list|,
name|M_HASHTYPE_OPAQUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|mhead
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|ptnet_vlan_tag_remove
argument_list|(
name|mhead
argument_list|)
expr_stmt|;
comment|/* 				 * With the 802.1Q header removed, update the 				 * checksum starting location accordingly. 				 */
if|if
condition|(
name|vh
operator|->
name|flags
operator|&
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
condition|)
name|vh
operator|->
name|csum_start
operator|-=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
block|}
if|if
condition|(
name|have_vnet_hdr
operator|&&
operator|(
name|vh
operator|->
name|flags
operator|&
operator|(
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
operator||
name|VIRTIO_NET_HDR_F_DATA_VALID
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|ptnet_rx_csum
argument_list|(
name|mhead
argument_list|,
name|vh
argument_list|)
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|mhead
argument_list|)
expr_stmt|;
name|RD
argument_list|(
literal|1
argument_list|,
literal|"Csum offload error: dropping"
argument_list|)
expr_stmt|;
name|pq
operator|->
name|stats
operator|.
name|iqdrops
operator|++
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
block|}
name|pq
operator|->
name|stats
operator|.
name|packets
operator|++
expr_stmt|;
name|pq
operator|->
name|stats
operator|.
name|bytes
operator|+=
name|mhead
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|PTNET_Q_UNLOCK
argument_list|(
name|pq
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|mhead
argument_list|)
expr_stmt|;
name|PTNET_Q_LOCK
argument_list|(
name|pq
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
argument_list|)
condition|)
block|{
comment|/* The interface has gone down while we didn't 			 * have the lock. Stop any processing and exit. */
goto|goto
name|unlock
goto|;
block|}
name|skip
label|:
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|batch_count
operator|==
name|PTNET_RX_BATCH
condition|)
block|{
comment|/* Some packets have been pushed to the network stack. 			 * We need to update the CSB to tell the host about the new 			 * ring->cur and ring->head (RX buffer refill). */
name|ptnet_ring_update
argument_list|(
name|pq
argument_list|,
name|kring
argument_list|,
name|head
argument_list|,
name|NAF_FORCE_READ
argument_list|)
expr_stmt|;
name|batch_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|escape
label|:
if|if
condition|(
name|batch_count
condition|)
block|{
name|ptnet_ring_update
argument_list|(
name|pq
argument_list|,
name|kring
argument_list|,
name|head
argument_list|,
name|NAF_FORCE_READ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>=
name|budget
operator|&&
name|may_resched
condition|)
block|{
comment|/* If we ran out of budget or the double-check found new 		 * slots to process, schedule the taskqueue. */
name|DBG
argument_list|(
name|RD
argument_list|(
literal|1
argument_list|,
literal|"out of budget: resched h %u t %u\n"
argument_list|,
name|head
argument_list|,
name|ring
operator|->
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|pq
operator|->
name|taskq
argument_list|,
operator|&
name|pq
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
name|unlock
label|:
name|PTNET_Q_UNLOCK
argument_list|(
name|pq
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptnet_rx_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|context
decl_stmt|;
name|DBG
argument_list|(
name|RD
argument_list|(
literal|1
argument_list|,
literal|"%s: pq #%u\n"
argument_list|,
name|__func__
argument_list|,
name|pq
operator|->
name|kring_id
argument_list|)
argument_list|)
expr_stmt|;
name|ptnet_rx_eof
argument_list|(
name|pq
argument_list|,
name|PTNET_RX_BUDGET
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptnet_tx_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|context
decl_stmt|;
name|DBG
argument_list|(
name|RD
argument_list|(
literal|1
argument_list|,
literal|"%s: pq #%u\n"
argument_list|,
name|__func__
argument_list|,
name|pq
operator|->
name|kring_id
argument_list|)
argument_list|)
expr_stmt|;
name|ptnet_drain_transmit_queue
argument_list|(
name|pq
argument_list|,
name|PTNET_TX_BUDGET
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_comment
comment|/* We don't need to handle differently POLL_AND_CHECK_STATUS and  * POLL_ONLY, since we don't have an Interrupt Status Register. */
end_comment

begin_function
specifier|static
name|int
name|ptnet_poll
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|budget
parameter_list|)
block|{
name|struct
name|ptnet_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|queue_budget
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|bool
name|borrow
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|num_rings
operator|>
literal|0
argument_list|,
operator|(
literal|"Found no queues in while polling ptnet"
operator|)
argument_list|)
expr_stmt|;
name|queue_budget
operator|=
name|MAX
argument_list|(
name|budget
operator|/
name|sc
operator|->
name|num_rings
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RD
argument_list|(
literal|1
argument_list|,
literal|"Per-queue budget is %d"
argument_list|,
name|queue_budget
argument_list|)
expr_stmt|;
while|while
condition|(
name|budget
condition|)
block|{
name|unsigned
name|int
name|rcnt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_rings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptnet_queue
modifier|*
name|pq
init|=
name|sc
operator|->
name|queues
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|borrow
condition|)
block|{
name|queue_budget
operator|=
name|MIN
argument_list|(
name|queue_budget
argument_list|,
name|budget
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue_budget
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|sc
operator|->
name|num_tx_rings
condition|)
block|{
name|rcnt
operator|+=
name|ptnet_drain_transmit_queue
argument_list|(
name|pq
argument_list|,
name|queue_budget
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rcnt
operator|+=
name|ptnet_rx_eof
argument_list|(
name|pq
argument_list|,
name|queue_budget
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|rcnt
condition|)
block|{
comment|/* A scan of the queues gave no result, we can 			 * stop here. */
break|break;
block|}
if|if
condition|(
name|rcnt
operator|>
name|budget
condition|)
block|{
comment|/* This may happen when initial budget< sc->num_rings, 			 * since one packet budget is given to each queue 			 * anyway. Just pretend we didn't eat "so much". */
name|rcnt
operator|=
name|budget
expr_stmt|;
block|}
name|count
operator|+=
name|rcnt
expr_stmt|;
name|budget
operator|-=
name|rcnt
expr_stmt|;
name|borrow
operator|=
name|true
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

end_unit

