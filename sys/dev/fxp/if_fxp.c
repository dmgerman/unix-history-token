begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1995, David Greenman  * Copyright (c) 2001 Jonathan Lemon<jlemon@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Intel EtherExpress Pro/100B PCI Fast Ethernet driver  */
end_comment

begin_include
include|#
directive|include
file|"vlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_comment
comment|/* #include<sys/mutex.h> */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* for vtophys */
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* for vtophys */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_if
if|#
directive|if
name|NVLAN
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_comment
comment|/* for PCIM_CMD_xxx */
end_comment

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/fxp/if_fxpreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fxp/if_fxpvar.h>
end_include

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fxp
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_comment
comment|/*  * NOTE!  On the Alpha, we have an alignment constraint.  The  * card DMAs the packet immediately following the RFA.  However,  * the first thing in the packet is a 14-byte Ethernet header.  * This means that the packet is misaligned.  To compensate,  * we actually offset the RFA 2 bytes into the cluster.  This  * alignes the packet after the Ethernet header at a 32-bit  * boundary.  HOWEVER!  This means that the RFA is misaligned!  */
end_comment

begin_define
define|#
directive|define
name|RFA_ALIGNMENT_FUDGE
value|2
end_define

begin_comment
comment|/*  * Set initial transmit threshold at 64 (512 bytes). This is  * increased by 64 (512 bytes) at a time, to maximum of 192  * (1536 bytes), if an underrun occurs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tx_threshold
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The configuration byte map has several undefined fields which  * must be one or must be zero.  Set up a template for these bits  * only, (assuming a 82557 chip) leaving the actual configuration  * to fxp_init.  *  * See struct fxp_cb_config for the bit definitions.  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|fxp_cb_config_template
index|[]
init|=
block|{
literal|0x0
block|,
literal|0x0
block|,
comment|/* cb_status */
literal|0x0
block|,
literal|0x0
block|,
comment|/* cb_command */
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
comment|/* link_addr */
literal|0x0
block|,
comment|/*  0 */
literal|0x0
block|,
comment|/*  1 */
literal|0x0
block|,
comment|/*  2 */
literal|0x0
block|,
comment|/*  3 */
literal|0x0
block|,
comment|/*  4 */
literal|0x0
block|,
comment|/*  5 */
literal|0x32
block|,
comment|/*  6 */
literal|0x0
block|,
comment|/*  7 */
literal|0x0
block|,
comment|/*  8 */
literal|0x0
block|,
comment|/*  9 */
literal|0x6
block|,
comment|/* 10 */
literal|0x0
block|,
comment|/* 11 */
literal|0x0
block|,
comment|/* 12 */
literal|0x0
block|,
comment|/* 13 */
literal|0xf2
block|,
comment|/* 14 */
literal|0x48
block|,
comment|/* 15 */
literal|0x0
block|,
comment|/* 16 */
literal|0x40
block|,
comment|/* 17 */
literal|0xf0
block|,
comment|/* 18 */
literal|0x0
block|,
comment|/* 19 */
literal|0x3f
block|,
comment|/* 20 */
literal|0x5
comment|/* 21 */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|fxp_ident
block|{
name|u_int16_t
name|devid
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Claim various Intel PCI device identifiers for this driver.  The  * sub-vendor and sub-device field are extensively used to identify  * particular variants, but we don't currently differentiate between  * them.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fxp_ident
name|fxp_ident_table
index|[]
init|=
block|{
block|{
literal|0x1229
block|,
literal|"Intel Pro 10/100B/100+ Ethernet"
block|}
block|,
block|{
literal|0x2449
block|,
literal|"Intel Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1209
block|,
literal|"Intel Embedded 10/100 Ethernet"
block|}
block|,
block|{
literal|0x1029
block|,
literal|"Intel Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1030
block|,
literal|"Intel Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1031
block|,
literal|"Intel Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1032
block|,
literal|"Intel Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1033
block|,
literal|"Intel Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1034
block|,
literal|"Intel Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1035
block|,
literal|"Intel Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1036
block|,
literal|"Intel Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1037
block|,
literal|"Intel Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1038
block|,
literal|"Intel Pro/100 Ethernet"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|fxp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_powerstate_d0
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_stop
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_release
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_add_rfabuf
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|oldm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_mc_setup
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|fxp_eeprom_getword
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|autosize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_autosize_eeprom
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_read_eeprom
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|u_short
modifier|*
name|data
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|words
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_serial_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_serial_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|volatile
name|int
name|fxp_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|fxp_lwcopy
parameter_list|(
specifier|volatile
name|u_int32_t
modifier|*
name|src
parameter_list|,
specifier|volatile
name|u_int32_t
modifier|*
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|fxp_scb_wait
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|fxp_scb_cmd
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|fxp_dma_wait
parameter_list|(
specifier|volatile
name|u_int16_t
modifier|*
name|status
parameter_list|,
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|fxp_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fxp_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fxp_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fxp_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|fxp_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|fxp_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|fxp_resume
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|fxp_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|fxp_miibus_writereg
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fxp_driver
init|=
block|{
literal|"fxp"
block|,
name|fxp_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|fxp_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_fxp
argument_list|,
name|pci
argument_list|,
name|fxp_driver
argument_list|,
name|fxp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_fxp
argument_list|,
name|cardbus
argument_list|,
name|fxp_driver
argument_list|,
name|fxp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|fxp
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Inline function to copy a 16-bit aligned 32-bit quantity.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|fxp_lwcopy
parameter_list|(
specifier|volatile
name|u_int32_t
modifier|*
name|src
parameter_list|,
specifier|volatile
name|u_int32_t
modifier|*
name|dst
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__i386__
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
else|#
directive|else
specifier|volatile
name|u_int16_t
modifier|*
name|a
init|=
operator|(
specifier|volatile
name|u_int16_t
operator|*
operator|)
name|src
decl_stmt|;
specifier|volatile
name|u_int16_t
modifier|*
name|b
init|=
operator|(
specifier|volatile
name|u_int16_t
operator|*
operator|)
name|dst
decl_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|a
index|[
literal|0
index|]
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
name|a
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Wait for the previous command to be accepted (but not necessarily  * completed).  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|fxp_scb_wait
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
init|=
literal|10000
decl_stmt|;
while|while
condition|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|)
operator|&&
operator|--
name|i
condition|)
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"SCB timeout: 0x%x, 0x%x, 0x%x 0x%x\n"
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|)
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_STATACK
argument_list|)
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_RUSCUS
argument_list|)
argument_list|,
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_FLOWCONTROL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|fxp_scb_cmd
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|==
name|FXP_SCB_COMMAND_CU_RESUME
operator|&&
name|sc
operator|->
name|cu_resume_bug
condition|)
block|{
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|FXP_CB_COMMAND_NOP
argument_list|)
expr_stmt|;
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|fxp_dma_wait
parameter_list|(
specifier|volatile
name|u_int16_t
modifier|*
name|status
parameter_list|,
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
init|=
literal|10000
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|*
name|status
operator|&
name|FXP_CB_STATUS_C
operator|)
operator|&&
operator|--
name|i
condition|)
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"DMA timeout\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return identification string if this is device is ours.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int16_t
name|devid
decl_stmt|;
name|struct
name|fxp_ident
modifier|*
name|ident
decl_stmt|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|FXP_VENDORID_INTEL
condition|)
block|{
name|devid
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|ident
operator|=
name|fxp_ident_table
init|;
name|ident
operator|->
name|name
operator|!=
name|NULL
condition|;
name|ident
operator|++
control|)
block|{
if|if
condition|(
name|ident
operator|->
name|devid
operator|==
name|devid
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|ident
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_powerstate_d0
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|430002
name|u_int32_t
name|iobase
decl_stmt|,
name|membase
decl_stmt|,
name|irq
decl_stmt|;
if|if
condition|(
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_POWERSTATE_D0
condition|)
block|{
comment|/* Save important PCI config data. */
name|iobase
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|FXP_PCI_IOBA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|membase
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|FXP_PCI_MMBA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|irq
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Reset the power state. */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"chip is in D%d power mode "
literal|"-- setting to D0\n"
argument_list|,
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
comment|/* Restore PCI config data. */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|FXP_PCI_IOBA
argument_list|,
name|iobase
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|FXP_PCI_MMBA
argument_list|,
name|membase
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
name|irq
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|fxp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|;
name|u_int16_t
name|data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rid
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|prefer_iomap
decl_stmt|;
name|int
name|s
decl_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Enable bus mastering. Enable memory space too, in case 	 * BIOS/Prom forgot about it. 	 */
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fxp_powerstate_d0
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out which we should try first - memory mapping or i/o mapping? 	 * We default to memory mapping. Then we accept an override from the 	 * command line. Then we check to see which one is enabled. 	 */
name|m1
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|m2
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
name|prefer_iomap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"prefer_iomap"
argument_list|,
operator|&
name|prefer_iomap
argument_list|)
operator|==
literal|0
operator|&&
name|prefer_iomap
operator|!=
literal|0
condition|)
block|{
name|m1
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
name|m2
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|m1
condition|)
block|{
name|sc
operator|->
name|rtp
operator|=
operator|(
name|m1
operator|==
name|PCIM_CMD_MEMEN
operator|)
condition|?
name|SYS_RES_MEMORY
else|:
name|SYS_RES_IOPORT
expr_stmt|;
name|sc
operator|->
name|rgd
operator|=
operator|(
name|m1
operator|==
name|PCIM_CMD_MEMEN
operator|)
condition|?
name|FXP_PCI_MMBA
else|:
name|FXP_PCI_IOBA
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|rtp
argument_list|,
operator|&
name|sc
operator|->
name|rgd
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mem
operator|==
name|NULL
operator|&&
operator|(
name|val
operator|&
name|m2
operator|)
condition|)
block|{
name|sc
operator|->
name|rtp
operator|=
operator|(
name|m2
operator|==
name|PCIM_CMD_MEMEN
operator|)
condition|?
name|SYS_RES_MEMORY
else|:
name|SYS_RES_IOPORT
expr_stmt|;
name|sc
operator|->
name|rgd
operator|=
operator|(
name|m2
operator|==
name|PCIM_CMD_MEMEN
operator|)
condition|?
name|FXP_PCI_MMBA
else|:
name|FXP_PCI_IOBA
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|rtp
argument_list|,
operator|&
name|sc
operator|->
name|rgd
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|mem
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map device registers\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using %s space register mapping\n"
argument_list|,
name|sc
operator|->
name|rtp
operator|==
name|SYS_RES_MEMORY
condition|?
literal|"memory"
else|:
literal|"I/O"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate our interrupt. 	 */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|fxp_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup irq\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Reset to a stable state. 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_PORT
argument_list|,
name|FXP_PORT_SELECTIVE_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cbl_base
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_cb_tx
argument_list|)
operator|*
name|FXP_NTXCB
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cbl_base
operator|==
name|NULL
condition|)
goto|goto
name|failmem
goto|;
name|sc
operator|->
name|fxp_stats
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_stats
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fxp_stats
operator|==
name|NULL
condition|)
goto|goto
name|failmem
goto|;
name|sc
operator|->
name|mcsp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_cb_mcs
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mcsp
operator|==
name|NULL
condition|)
goto|goto
name|failmem
goto|;
comment|/* 	 * Pre-allocate our receive buffers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NRFABUFS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fxp_add_rfabuf
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|failmem
goto|;
block|}
block|}
comment|/* 	 * Find out how large of an SEEPROM we have. 	 */
name|fxp_autosize_eeprom
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Determine whether we must use the 503 serial interface. 	 */
name|fxp_read_eeprom
argument_list|(
name|sc
argument_list|,
operator|&
name|data
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|FXP_PHY_DEVICE_MASK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|data
operator|&
name|FXP_PHY_SERIAL_ONLY
operator|)
condition|)
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_SERIAL_MEDIA
expr_stmt|;
comment|/* 	 * Find out the basic controller type; we currently only 	 * differentiate between a 82557 and greater. 	 */
name|fxp_read_eeprom
argument_list|(
name|sc
argument_list|,
operator|&
name|data
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|==
literal|1
condition|)
name|sc
operator|->
name|chip
operator|=
name|FXP_CHIP_82557
expr_stmt|;
comment|/* 	 * Enable workarounds for certain chip revision deficiencies. 	 */
name|i
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0x2449
operator|||
operator|(
name|i
operator|>
literal|0x1030
operator|&&
name|i
operator|<
literal|0x1039
operator|)
condition|)
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_CU_RESUME_BUG
expr_stmt|;
comment|/* 	 * If we are not a 82557 chip, we can enable extended features. 	 */
if|if
condition|(
name|sc
operator|->
name|chip
operator|!=
name|FXP_CHIP_82557
condition|)
block|{
comment|/* 		 * If MWI is enabled in the PCI configuration, and there 		 * is a valid cacheline size (8 or 16 dwords), then tell 		 * the board to turn on MWI. 		 */
if|if
condition|(
name|val
operator|&
name|PCIM_CMD_MWRICEN
operator|&&
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_MWI_ENABLE
expr_stmt|;
comment|/* turn on the extended TxCB feature */
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_EXT_TXCB
expr_stmt|;
if|#
directive|if
name|NVLAN
operator|>
literal|0
comment|/* enable reception of long frames for VLAN */
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_LONG_PKT_EN
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Read MAC address. 	 */
name|fxp_read_eeprom
argument_list|(
name|sc
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Ethernet address %6D%s\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_SERIAL_MEDIA
condition|?
literal|", 10Mbps"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI IDs: %04x %04x %04x %04x %04x\n"
argument_list|,
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_device
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Chip Type: %d\n"
argument_list|,
name|sc
operator|->
name|chip
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this is only a 10Mbps device, then there is no MII, and 	 * the PHY will use a serial interface instead. 	 * 	 * The Seeq 80c24 AutoDUPLEX(tm) Ethernet Interface Adapter 	 * doesn't have a programming interface of any sort.  The 	 * media is sensed automatically based on how the link partner 	 * is configured.  This is, in essence, manual configuration. 	 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_SERIAL_MEDIA
condition|)
block|{
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
literal|0
argument_list|,
name|fxp_serial_ifmedia_upd
argument_list|,
name|fxp_serial_ifmedia_sts
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mii_phy_probe
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|miibus
argument_list|,
name|fxp_ifmedia_upd
argument_list|,
name|fxp_ifmedia_sts
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MII without any PHY!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"fxp"
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|fxp_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|fxp_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|fxp_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|fxp_watchdog
expr_stmt|;
comment|/* 	 * Attach the interface. 	 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
if|#
directive|if
name|NVLAN
operator|>
literal|0
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Let the system queue as many packets as we have available 	 * TX descriptors. 	 */
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|FXP_NTXCB
operator|-
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failmem
label|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to malloc memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|fail
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fxp_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * release all resources  */
end_comment

begin_function
specifier|static
name|void
name|fxp_release
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_generic_detach
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|miibus
condition|)
name|device_delete_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cbl_base
condition|)
name|free
argument_list|(
name|sc
operator|->
name|cbl_base
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fxp_stats
condition|)
name|free
argument_list|(
name|sc
operator|->
name|fxp_stats
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mcsp
condition|)
name|free
argument_list|(
name|sc
operator|->
name|mcsp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rfa_headm
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|rfa_headm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ih
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|rtp
argument_list|,
name|sc
operator|->
name|rgd
argument_list|,
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Detach interface.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* disable interrupts */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_INTRCNTL
argument_list|,
name|FXP_SCB_INTR_DISABLE
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Stop DMA and drop transmit queue. 	 */
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Close down routes etc. 	 */
name|ether_ifdetach
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
comment|/* 	 * Free all media structures. 	 */
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Release our allocated resources. */
name|fxp_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device shutdown routine. Called at system shutdown after sync. The  * main purpose of this routine is to shut off receiver DMA so that  * kernel memory doesn't get clobbered during warmboot.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * Make sure that DMA is disabled prior to reboot. Not doing 	 * do could allow DMA to corrupt kernel memory during the 	 * reboot before the driver initializes. 	 */
name|fxp_stop
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device suspend routine.  Stop the interface and save some PCI  * settings in case the BIOS doesn't restore them properly on  * resume.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|saved_maps
index|[
name|i
index|]
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MAPS
operator|+
name|i
operator|*
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|saved_biosaddr
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BIOS
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|saved_intline
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|saved_cachelnsz
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|saved_lattimer
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_LATTIMER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|suspended
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device resume routine.  Restore some PCI settings in case the BIOS  * doesn't, re-enable busmastering, and restart the interface if  * appropriate.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|u_int16_t
name|pci_command
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|fxp_powerstate_d0
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* better way to do this? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MAPS
operator|+
name|i
operator|*
literal|4
argument_list|,
name|sc
operator|->
name|saved_maps
index|[
name|i
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BIOS
argument_list|,
name|sc
operator|->
name|saved_biosaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
name|sc
operator|->
name|saved_intline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
name|sc
operator|->
name|saved_cachelnsz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_LATTIMER
argument_list|,
name|sc
operator|->
name|saved_lattimer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* reenable busmastering */
name|pci_command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_command
operator||=
operator|(
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|pci_command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_PORT
argument_list|,
name|FXP_PORT_SELECTIVE_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* reinitialize interface if necessary */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|fxp_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|suspended
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read from the serial EEPROM. Basically, you manually shift in  * the read opcode (one bit at a time) and then shift in the address,  * and then you shift out the data (all of this one bit at a time).  * The word size is 16 bits, so you have to provide the address for  * every 16 bits of data.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|fxp_eeprom_getword
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|autosize
parameter_list|)
block|{
name|u_int16_t
name|reg
decl_stmt|,
name|data
decl_stmt|;
name|int
name|x
decl_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|FXP_EEPROM_EECS
argument_list|)
expr_stmt|;
comment|/* 	 * Shift in read opcode. 	 */
for|for
control|(
name|x
operator|=
literal|1
operator|<<
literal|2
init|;
name|x
condition|;
name|x
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|FXP_EEPROM_OPC_READ
operator|&
name|x
condition|)
name|reg
operator|=
name|FXP_EEPROM_EECS
operator||
name|FXP_EEPROM_EEDI
expr_stmt|;
else|else
name|reg
operator|=
name|FXP_EEPROM_EECS
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
operator||
name|FXP_EEPROM_EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Shift in address. 	 */
name|data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
operator|<<
operator|(
name|sc
operator|->
name|eeprom_size
operator|-
literal|1
operator|)
init|;
name|x
condition|;
name|x
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|offset
operator|&
name|x
condition|)
name|reg
operator|=
name|FXP_EEPROM_EECS
operator||
name|FXP_EEPROM_EEDI
expr_stmt|;
else|else
name|reg
operator|=
name|FXP_EEPROM_EECS
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
operator||
name|FXP_EEPROM_EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|reg
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|)
operator|&
name|FXP_EEPROM_EEDO
expr_stmt|;
name|data
operator|++
expr_stmt|;
if|if
condition|(
name|autosize
operator|&&
name|reg
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|eeprom_size
operator|=
name|data
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Shift out data. 	 */
name|data
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|FXP_EEPROM_EECS
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
operator|<<
literal|15
init|;
name|x
condition|;
name|x
operator|>>=
literal|1
control|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
operator||
name|FXP_EEPROM_EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|)
operator|&
name|FXP_EEPROM_EEDO
condition|)
name|data
operator||=
name|x
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * From NetBSD:  *  * Figure out EEPROM size.  *  * 559's can have either 64-word or 256-word EEPROMs, the 558  * datasheet only talks about 64-word EEPROMs, and the 557 datasheet  * talks about the existance of 16 to 256 word EEPROMs.  *  * The only known sizes are 64 and 256, where the 256 version is used  * by CardBus cards to store CIS information.  *  * The address is shifted in msb-to-lsb, and after the last  * address-bit the EEPROM is supposed to output a `dummy zero' bit,  * after which follows the actual data. We try to detect this zero, by  * probing the data-out bit in the EEPROM control register just after  * having shifted in a bit. If the bit is zero, we assume we've  * shifted enough address bits. The data-out should be tri-state,  * before this, which should translate to a logical one.  *  * Other ways to do this would be to try to read a register with known  * contents with a varying number of address bits, but no such  * register seem to be available. The high bits of register 10 are 01  * on the 558 and 559, but apparently not on the 557.  *   * The Linux driver computes a checksum on the EEPROM data, but the  * value of this checksum is not very well documented.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_autosize_eeprom
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* guess maximum size of 256 words */
name|sc
operator|->
name|eeprom_size
operator|=
literal|8
expr_stmt|;
comment|/* autosize */
operator|(
name|void
operator|)
name|fxp_eeprom_getword
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_read_eeprom
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|u_short
modifier|*
name|data
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|words
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
name|data
index|[
name|i
index|]
operator|=
name|fxp_eeprom_getword
argument_list|(
name|sc
argument_list|,
name|offset
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start packet transmission on the interface.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
comment|/* 	 * See if we need to suspend xmit until the multicast filter 	 * has been reprogrammed (which can only be done at the head 	 * of the command chain). 	 */
if|if
condition|(
name|sc
operator|->
name|need_mcsetup
condition|)
block|{
return|return;
block|}
name|txp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We're finished if there is nothing more to add to the list or if 	 * we're all filled up with buffers to transmit. 	 * NOTE: One TxCB is reserved to guarantee that fxp_mc_setup() can add 	 *       a NOP command when needed. 	 */
while|while
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|tx_queued
operator|<
name|FXP_NTXCB
operator|-
literal|1
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mb_head
decl_stmt|;
name|int
name|segment
decl_stmt|;
comment|/* 		 * Grab a packet to transmit. 		 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mb_head
argument_list|)
expr_stmt|;
comment|/* 		 * Get pointer to next available tx desc. 		 */
name|txp
operator|=
name|sc
operator|->
name|cbl_last
operator|->
name|next
expr_stmt|;
comment|/* 		 * Go through each of the mbufs in the chain and initialize 		 * the transmit buffer descriptors with the physical address 		 * and size of the mbuf. 		 */
name|tbdinit
label|:
for|for
control|(
name|m
operator|=
name|mb_head
operator|,
name|segment
operator|=
literal|0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|segment
operator|==
name|FXP_NTXSEG
condition|)
break|break;
name|txp
operator|->
name|tbd
index|[
name|segment
index|]
operator|.
name|tb_addr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
expr_stmt|;
name|txp
operator|->
name|tbd
index|[
name|segment
index|]
operator|.
name|tb_size
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|segment
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mn
decl_stmt|;
comment|/* 			 * We ran out of segments. We have to recopy this 			 * mbuf chain first. Bail out if we can't get the 			 * new buffers. 			 */
name|MGETHDR
argument_list|(
name|mn
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mn
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb_head
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|mn
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mn
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|mn
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb_head
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|m_copydata
argument_list|(
name|mb_head
argument_list|,
literal|0
argument_list|,
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|mn
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|mn
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mn
operator|->
name|m_len
operator|=
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|mb_head
argument_list|)
expr_stmt|;
name|mb_head
operator|=
name|mn
expr_stmt|;
goto|goto
name|tbdinit
goto|;
block|}
name|txp
operator|->
name|tbd_number
operator|=
name|segment
expr_stmt|;
name|txp
operator|->
name|mb_head
operator|=
name|mb_head
expr_stmt|;
name|txp
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_queued
operator|!=
name|FXP_CXINT_THRESH
operator|-
literal|1
condition|)
block|{
name|txp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_XMIT
operator||
name|FXP_CB_COMMAND_SF
operator||
name|FXP_CB_COMMAND_S
expr_stmt|;
block|}
else|else
block|{
name|txp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_XMIT
operator||
name|FXP_CB_COMMAND_SF
operator||
name|FXP_CB_COMMAND_S
operator||
name|FXP_CB_COMMAND_I
expr_stmt|;
comment|/* 			 * Set a 5 second timer just in case we don't hear 			 * from the card again. 			 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
block|}
name|txp
operator|->
name|tx_threshold
operator|=
name|tx_threshold
expr_stmt|;
comment|/* 		 * Advance the end of list forward. 		 */
ifdef|#
directive|ifdef
name|__alpha__
comment|/* 		 * On platforms which can't access memory in 16-bit 		 * granularities, we must prevent the card from DMA'ing 		 * up the status while we update the command field. 		 * This could cause us to overwrite the completion status. 		 */
name|atomic_clear_short
argument_list|(
operator|&
name|sc
operator|->
name|cbl_last
operator|->
name|cb_command
argument_list|,
name|FXP_CB_COMMAND_S
argument_list|)
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|cbl_last
operator|->
name|cb_command
operator|&=
operator|~
name|FXP_CB_COMMAND_S
expr_stmt|;
endif|#
directive|endif
comment|/*__alpha__*/
name|sc
operator|->
name|cbl_last
operator|=
name|txp
expr_stmt|;
comment|/* 		 * Advance the beginning of the list forward if there are 		 * no other packets queued (when nothing is queued, cbl_first 		 * sits on the last TxCB that was sent out). 		 */
if|if
condition|(
name|sc
operator|->
name|tx_queued
operator|==
literal|0
condition|)
name|sc
operator|->
name|cbl_first
operator|=
name|txp
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|++
expr_stmt|;
comment|/* 		 * Pass packet to bpf if there is a listener. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|mb_head
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We're finished. If we added to the list, issue a RESUME to get DMA 	 * going again if suspended. 	 */
if|if
condition|(
name|txp
operator|!=
name|NULL
condition|)
block|{
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_RESUME
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process interface interrupts.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|u_int8_t
name|statack
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|suspended
condition|)
block|{
return|return;
block|}
while|while
condition|(
operator|(
name|statack
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_STATACK
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * It should not be possible to have all bits set; the 		 * FXP_SCB_INTR_SWI bit always returns 0 on a read.  If  		 * all bits are set, this may indicate that the card has 		 * been physically ejected, so ignore it. 		 */
if|if
condition|(
name|statack
operator|==
literal|0xff
condition|)
return|return;
comment|/* 		 * First ACK all the interrupts in this pass. 		 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_STATACK
argument_list|,
name|statack
argument_list|)
expr_stmt|;
comment|/* 		 * Free any finished transmit mbuf chains. 		 * 		 * Handle the CNA event likt a CXTNO event. It used to 		 * be that this event (control unit not ready) was not 		 * encountered, but it is now with the SMPng modifications. 		 * The exact sequence of events that occur when the interface 		 * is brought up are different now, and if this event 		 * goes unhandled, the configuration/rxfilter setup sequence 		 * can stall for several seconds. The result is that no 		 * packets go out onto the wire for about 5 to 10 seconds 		 * after the interface is ifconfig'ed for the first time. 		 */
if|if
condition|(
name|statack
operator|&
operator|(
name|FXP_SCB_STATACK_CXTNO
operator||
name|FXP_SCB_STATACK_CNA
operator|)
condition|)
block|{
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
for|for
control|(
name|txp
operator|=
name|sc
operator|->
name|cbl_first
init|;
name|sc
operator|->
name|tx_queued
operator|&&
operator|(
name|txp
operator|->
name|cb_status
operator|&
name|FXP_CB_STATUS_C
operator|)
operator|!=
literal|0
condition|;
name|txp
operator|=
name|txp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|txp
operator|->
name|mb_head
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txp
operator|->
name|mb_head
argument_list|)
expr_stmt|;
name|txp
operator|->
name|mb_head
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|tx_queued
operator|--
expr_stmt|;
block|}
name|sc
operator|->
name|cbl_first
operator|=
name|txp
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_queued
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|need_mcsetup
condition|)
name|fxp_mc_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Try to start more packets transmitting. 			 */
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|fxp_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Process receiver interrupts. If a no-resource (RNR) 		 * condition exists, get whatever packets we can and 		 * re-start the receiver. 		 */
if|if
condition|(
name|statack
operator|&
operator|(
name|FXP_SCB_STATACK_FR
operator||
name|FXP_SCB_STATACK_RNR
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|fxp_rfa
modifier|*
name|rfa
decl_stmt|;
name|rcvloop
label|:
name|m
operator|=
name|sc
operator|->
name|rfa_headm
expr_stmt|;
name|rfa
operator|=
operator|(
expr|struct
name|fxp_rfa
operator|*
operator|)
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|+
name|RFA_ALIGNMENT_FUDGE
operator|)
expr_stmt|;
if|if
condition|(
name|rfa
operator|->
name|rfa_status
operator|&
name|FXP_RFA_STATUS_C
condition|)
block|{
comment|/* 				 * Remove first packet from the chain. 				 */
name|sc
operator|->
name|rfa_headm
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * Add a new buffer to the receive chain. 				 * If this fails, the old buffer is recycled 				 * instead. 				 */
if|if
condition|(
name|fxp_add_rfabuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|total_len
decl_stmt|;
name|total_len
operator|=
name|rfa
operator|->
name|actual_size
operator|&
operator|(
name|MCLBYTES
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|total_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|rcvloop
goto|;
block|}
if|#
directive|if
name|NVLAN
operator|>
literal|0
comment|/* 					 * Drop the packet if it has CRC 					 * errors.  This test is only needed 					 * when doing 802.1q VLAN on the 82557 					 * chip. 					 */
if|if
condition|(
name|rfa
operator|->
name|rfa_status
operator|&
name|FXP_RFA_STATUS_CRC
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|rcvloop
goto|;
block|}
endif|#
directive|endif
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|total_len
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
goto|goto
name|rcvloop
goto|;
block|}
if|if
condition|(
name|statack
operator|&
name|FXP_SCB_STATACK_RNR
condition|)
block|{
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|rfa_headm
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
operator|+
name|RFA_ALIGNMENT_FUDGE
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_RU_START
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Update packet in/out/collision statistics. The i82557 doesn't  * allow you to access these counters without doing a fairly  * expensive DMA to get _all_ of the statistics it maintains, so  * we do this operation here only once per second. The statistics  * counters in the kernel are updated from the previous dump-stats  * DMA and then a new dump-stats DMA is started. The on-chip  * counters are zeroed when the DMA completes. If we can't start  * the DMA immediately, we don't wait - we just prepare to read  * them again next time.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|struct
name|fxp_stats
modifier|*
name|sp
init|=
name|sc
operator|->
name|fxp_stats
decl_stmt|;
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ifp
operator|->
name|if_opackets
operator|+=
name|sp
operator|->
name|tx_good
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
name|sp
operator|->
name|tx_total_collisions
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|rx_good
condition|)
block|{
name|ifp
operator|->
name|if_ipackets
operator|+=
name|sp
operator|->
name|rx_good
expr_stmt|;
name|sc
operator|->
name|rx_idle_secs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Receiver's been idle for another second. 		 */
name|sc
operator|->
name|rx_idle_secs
operator|++
expr_stmt|;
block|}
name|ifp
operator|->
name|if_ierrors
operator|+=
name|sp
operator|->
name|rx_crc_errors
operator|+
name|sp
operator|->
name|rx_alignment_errors
operator|+
name|sp
operator|->
name|rx_rnr_errors
operator|+
name|sp
operator|->
name|rx_overrun_errors
expr_stmt|;
comment|/* 	 * If any transmit underruns occured, bump up the transmit 	 * threshold by another 512 bytes (64 * 8). 	 */
if|if
condition|(
name|sp
operator|->
name|tx_underruns
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|+=
name|sp
operator|->
name|tx_underruns
expr_stmt|;
if|if
condition|(
name|tx_threshold
operator|<
literal|192
condition|)
name|tx_threshold
operator|+=
literal|64
expr_stmt|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Release any xmit buffers that have completed DMA. This isn't 	 * strictly necessary to do here, but it's advantagous for mbufs 	 * with external storage to be released in a timely manner rather 	 * than being defered for a potentially long time. This limits 	 * the delay to a maximum of one second. 	 */
for|for
control|(
name|txp
operator|=
name|sc
operator|->
name|cbl_first
init|;
name|sc
operator|->
name|tx_queued
operator|&&
operator|(
name|txp
operator|->
name|cb_status
operator|&
name|FXP_CB_STATUS_C
operator|)
operator|!=
literal|0
condition|;
name|txp
operator|=
name|txp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|txp
operator|->
name|mb_head
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txp
operator|->
name|mb_head
argument_list|)
expr_stmt|;
name|txp
operator|->
name|mb_head
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|tx_queued
operator|--
expr_stmt|;
block|}
name|sc
operator|->
name|cbl_first
operator|=
name|txp
expr_stmt|;
comment|/* 	 * If we haven't received any packets in FXP_MAC_RX_IDLE seconds, 	 * then assume the receiver has locked up and attempt to clear 	 * the condition by reprogramming the multicast filter. This is 	 * a work-around for a bug in the 82557 where the receiver locks 	 * up if it gets certain types of garbage in the syncronization 	 * bits prior to the packet header. This bug is supposed to only 	 * occur in 10Mbps mode, but has been seen to occur in 100Mbps 	 * mode as well (perhaps due to a 10/100 speed transition). 	 */
if|if
condition|(
name|sc
operator|->
name|rx_idle_secs
operator|>
name|FXP_MAX_RX_IDLE
condition|)
block|{
name|sc
operator|->
name|rx_idle_secs
operator|=
literal|0
expr_stmt|;
name|fxp_mc_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there is no pending command, start another stats 	 * dump. Otherwise punt for now. 	 */
if|if
condition|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Start another stats dump. 		 */
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_DUMPRESET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * A previous command is still waiting to be accepted. 		 * Just zero our copy of the stats and wait for the 		 * next timer event to update them. 		 */
name|sp
operator|->
name|tx_good
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|tx_underruns
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|tx_total_collisions
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_good
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_crc_errors
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_alignment_errors
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_rnr_errors
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_overrun_errors
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|miibus
operator|!=
name|NULL
condition|)
name|mii_tick
argument_list|(
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule another timeout one second from now. 	 */
name|sc
operator|->
name|stat_ch
operator|=
name|timeout
argument_list|(
name|fxp_tick
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop the interface. Cancels the statistics updater and resets  * the interface.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_stop
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Cancel stats updater. 	 */
name|untimeout
argument_list|(
name|fxp_tick
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|stat_ch
argument_list|)
expr_stmt|;
comment|/* 	 * Issue software reset 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_PORT
argument_list|,
name|FXP_PORT_SELECTIVE_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* 	 * Release any xmit buffers. 	 */
name|txp
operator|=
name|sc
operator|->
name|cbl_base
expr_stmt|;
if|if
condition|(
name|txp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NTXCB
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|txp
index|[
name|i
index|]
operator|.
name|mb_head
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txp
index|[
name|i
index|]
operator|.
name|mb_head
argument_list|)
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|mb_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|sc
operator|->
name|tx_queued
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Free all the receive buffers then reallocate/reinitialize 	 */
if|if
condition|(
name|sc
operator|->
name|rfa_headm
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|rfa_headm
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rfa_headm
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|rfa_tailm
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NRFABUFS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fxp_add_rfabuf
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * This "can't happen" - we're at splimp() 			 * and we just freed all the buffers we need 			 * above. 			 */
name|panic
argument_list|(
literal|"fxp_stop: no buffers!"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Watchdog/transmission transmit timeout handler. Called when a  * transmission is started on the interface, but no interrupt is  * received before the timeout. This usually indicates that the  * card has wedged for some reason.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|fxp_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|struct
name|fxp_cb_config
modifier|*
name|cbp
decl_stmt|;
name|struct
name|fxp_cb_ias
modifier|*
name|cb_ias
decl_stmt|;
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|prm
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Cancel any pending I/O 	 */
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|prm
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 	 * Initialize base of CBL and RFA memory. Loading with zero 	 * sets it up for regular linear addressing. 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_BASE
argument_list|)
expr_stmt|;
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_RU_BASE
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize base of dump-stats buffer. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|fxp_stats
argument_list|)
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_DUMP_ADR
argument_list|)
expr_stmt|;
comment|/* 	 * We temporarily use memory that contains the TxCB list to 	 * construct the config CB. The TxCB list memory is rebuilt 	 * later. 	 */
name|cbp
operator|=
operator|(
expr|struct
name|fxp_cb_config
operator|*
operator|)
name|sc
operator|->
name|cbl_base
expr_stmt|;
comment|/* 	 * This bcopy is kind of disgusting, but there are a bunch of must be 	 * zero and must be one bits in this structure and this is the easiest 	 * way to initialize them all to proper values. 	 */
name|bcopy
argument_list|(
name|fxp_cb_config_template
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
operator|&
name|cbp
operator|->
name|cb_status
argument_list|,
sizeof|sizeof
argument_list|(
name|fxp_cb_config_template
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_CONFIG
operator||
name|FXP_CB_COMMAND_EL
expr_stmt|;
name|cbp
operator|->
name|link_addr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* (no) next command */
name|cbp
operator|->
name|byte_count
operator|=
literal|22
expr_stmt|;
comment|/* (22) bytes to config */
name|cbp
operator|->
name|rx_fifo_limit
operator|=
literal|8
expr_stmt|;
comment|/* rx fifo threshold (32 bytes) */
name|cbp
operator|->
name|tx_fifo_limit
operator|=
literal|0
expr_stmt|;
comment|/* tx fifo threshold (0 bytes) */
name|cbp
operator|->
name|adaptive_ifs
operator|=
literal|0
expr_stmt|;
comment|/* (no) adaptive interframe spacing */
name|cbp
operator|->
name|mwi_enable
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_MWI_ENABLE
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cbp
operator|->
name|type_enable
operator|=
literal|0
expr_stmt|;
comment|/* actually reserved */
name|cbp
operator|->
name|read_align_en
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_READ_ALIGN
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cbp
operator|->
name|end_wr_on_cl
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_WRITE_ALIGN
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cbp
operator|->
name|rx_dma_bytecount
operator|=
literal|0
expr_stmt|;
comment|/* (no) rx DMA max */
name|cbp
operator|->
name|tx_dma_bytecount
operator|=
literal|0
expr_stmt|;
comment|/* (no) tx DMA max */
name|cbp
operator|->
name|dma_mbce
operator|=
literal|0
expr_stmt|;
comment|/* (disable) dma max counters */
name|cbp
operator|->
name|late_scb
operator|=
literal|0
expr_stmt|;
comment|/* (don't) defer SCB update */
name|cbp
operator|->
name|direct_dma_dis
operator|=
literal|1
expr_stmt|;
comment|/* disable direct rcv dma mode */
name|cbp
operator|->
name|tno_int_or_tco_en
operator|=
literal|0
expr_stmt|;
comment|/* (disable) tx not okay interrupt */
name|cbp
operator|->
name|ci_int
operator|=
literal|1
expr_stmt|;
comment|/* interrupt on CU idle */
name|cbp
operator|->
name|ext_txcb_dis
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_EXT_TXCB
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|cbp
operator|->
name|ext_stats_dis
operator|=
literal|1
expr_stmt|;
comment|/* disable extended counters */
name|cbp
operator|->
name|keep_overrun_rx
operator|=
literal|0
expr_stmt|;
comment|/* don't pass overrun frames to host */
if|#
directive|if
name|NVLAN
operator|>
literal|0
name|cbp
operator|->
name|save_bf
operator|=
name|sc
operator|->
name|chip
operator|==
name|FXP_CHIP_82557
condition|?
literal|1
else|:
name|prm
expr_stmt|;
else|#
directive|else
name|cbp
operator|->
name|save_bf
operator|=
name|prm
expr_stmt|;
comment|/* save bad frames */
endif|#
directive|endif
name|cbp
operator|->
name|disc_short_rx
operator|=
operator|!
name|prm
expr_stmt|;
comment|/* discard short packets */
name|cbp
operator|->
name|underrun_retry
operator|=
literal|1
expr_stmt|;
comment|/* retry mode (once) on DMA underrun */
name|cbp
operator|->
name|two_frames
operator|=
literal|0
expr_stmt|;
comment|/* do not limit FIFO to 2 frames */
name|cbp
operator|->
name|dyn_tbd
operator|=
literal|0
expr_stmt|;
comment|/* (no) dynamic TBD mode */
name|cbp
operator|->
name|mediatype
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_SERIAL_MEDIA
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|cbp
operator|->
name|csma_dis
operator|=
literal|0
expr_stmt|;
comment|/* (don't) disable link */
name|cbp
operator|->
name|tcp_udp_cksum
operator|=
literal|0
expr_stmt|;
comment|/* (don't) enable checksum */
name|cbp
operator|->
name|vlan_tco
operator|=
literal|0
expr_stmt|;
comment|/* (don't) enable vlan wakeup */
name|cbp
operator|->
name|link_wake_en
operator|=
literal|0
expr_stmt|;
comment|/* (don't) assert PME# on link change */
name|cbp
operator|->
name|arp_wake_en
operator|=
literal|0
expr_stmt|;
comment|/* (don't) assert PME# on arp */
name|cbp
operator|->
name|mc_wake_en
operator|=
literal|0
expr_stmt|;
comment|/* (don't) enable PME# on mcmatch */
name|cbp
operator|->
name|nsai
operator|=
literal|1
expr_stmt|;
comment|/* (don't) disable source addr insert */
name|cbp
operator|->
name|preamble_length
operator|=
literal|2
expr_stmt|;
comment|/* (7 byte) preamble */
name|cbp
operator|->
name|loopback
operator|=
literal|0
expr_stmt|;
comment|/* (don't) loopback */
name|cbp
operator|->
name|linear_priority
operator|=
literal|0
expr_stmt|;
comment|/* (normal CSMA/CD operation) */
name|cbp
operator|->
name|linear_pri_mode
operator|=
literal|0
expr_stmt|;
comment|/* (wait after xmit only) */
name|cbp
operator|->
name|interfrm_spacing
operator|=
literal|6
expr_stmt|;
comment|/* (96 bits of) interframe spacing */
name|cbp
operator|->
name|promiscuous
operator|=
name|prm
expr_stmt|;
comment|/* promiscuous mode */
name|cbp
operator|->
name|bcast_disable
operator|=
literal|0
expr_stmt|;
comment|/* (don't) disable broadcasts */
name|cbp
operator|->
name|wait_after_win
operator|=
literal|0
expr_stmt|;
comment|/* (don't) enable modified backoff alg*/
name|cbp
operator|->
name|ignore_ul
operator|=
literal|0
expr_stmt|;
comment|/* consider U/L bit in IA matching */
name|cbp
operator|->
name|crc16_en
operator|=
literal|0
expr_stmt|;
comment|/* (don't) enable crc-16 algorithm */
name|cbp
operator|->
name|crscdt
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_SERIAL_MEDIA
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cbp
operator|->
name|stripping
operator|=
operator|!
name|prm
expr_stmt|;
comment|/* truncate rx packet to byte count */
name|cbp
operator|->
name|padding
operator|=
literal|1
expr_stmt|;
comment|/* (do) pad short tx packets */
name|cbp
operator|->
name|rcv_crc_xfer
operator|=
literal|0
expr_stmt|;
comment|/* (don't) xfer CRC to host */
name|cbp
operator|->
name|long_rx_en
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_LONG_PKT_EN
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cbp
operator|->
name|ia_wake_en
operator|=
literal|0
expr_stmt|;
comment|/* (don't) wake up on address match */
name|cbp
operator|->
name|magic_pkt_dis
operator|=
literal|0
expr_stmt|;
comment|/* (don't) disable magic packet */
comment|/* must set wake_en in PMCSR also */
name|cbp
operator|->
name|force_fdx
operator|=
literal|0
expr_stmt|;
comment|/* (don't) force full duplex */
name|cbp
operator|->
name|fdx_pin_en
operator|=
literal|1
expr_stmt|;
comment|/* (enable) FDX# pin */
name|cbp
operator|->
name|multi_ia
operator|=
literal|0
expr_stmt|;
comment|/* (don't) accept multiple IAs */
name|cbp
operator|->
name|mc_all
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_ALL_MCAST
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chip
operator|==
name|FXP_CHIP_82557
condition|)
block|{
comment|/* 		 * The 82557 has no hardware flow control, the values 		 * below are the defaults for the chip. 		 */
name|cbp
operator|->
name|fc_delay_lsb
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|fc_delay_msb
operator|=
literal|0x40
expr_stmt|;
name|cbp
operator|->
name|pri_fc_thresh
operator|=
literal|3
expr_stmt|;
name|cbp
operator|->
name|tx_fc_dis
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|rx_fc_restop
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|rx_fc_restart
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|fc_filter
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|pri_fc_loc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cbp
operator|->
name|fc_delay_lsb
operator|=
literal|0x1f
expr_stmt|;
name|cbp
operator|->
name|fc_delay_msb
operator|=
literal|0x01
expr_stmt|;
name|cbp
operator|->
name|pri_fc_thresh
operator|=
literal|3
expr_stmt|;
name|cbp
operator|->
name|tx_fc_dis
operator|=
literal|0
expr_stmt|;
comment|/* enable transmit FC */
name|cbp
operator|->
name|rx_fc_restop
operator|=
literal|1
expr_stmt|;
comment|/* enable FC restop frames */
name|cbp
operator|->
name|rx_fc_restart
operator|=
literal|1
expr_stmt|;
comment|/* enable FC restart frames */
name|cbp
operator|->
name|fc_filter
operator|=
operator|!
name|prm
expr_stmt|;
comment|/* drop FC frames to host */
name|cbp
operator|->
name|pri_fc_loc
operator|=
literal|1
expr_stmt|;
comment|/* FC pri location (byte31) */
block|}
comment|/* 	 * Start the config command/DMA. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|vtophys
argument_list|(
operator|&
name|cbp
operator|->
name|cb_status
argument_list|)
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_START
argument_list|)
expr_stmt|;
comment|/* ...and wait for it to complete. */
name|fxp_dma_wait
argument_list|(
operator|&
name|cbp
operator|->
name|cb_status
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Now initialize the station address. Temporarily use the TxCB 	 * memory area like we did above for the config CB. 	 */
name|cb_ias
operator|=
operator|(
expr|struct
name|fxp_cb_ias
operator|*
operator|)
name|sc
operator|->
name|cbl_base
expr_stmt|;
name|cb_ias
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|cb_ias
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_IAS
operator||
name|FXP_CB_COMMAND_EL
expr_stmt|;
name|cb_ias
operator|->
name|link_addr
operator|=
operator|-
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|cb_ias
operator|->
name|macaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Start the IAS (Individual Address Setup) command/DMA. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_START
argument_list|)
expr_stmt|;
comment|/* ...and wait for it to complete. */
name|fxp_dma_wait
argument_list|(
operator|&
name|cb_ias
operator|->
name|cb_status
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize transmit control block (TxCB) list. 	 */
name|txp
operator|=
name|sc
operator|->
name|cbl_base
expr_stmt|;
name|bzero
argument_list|(
name|txp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_cb_tx
argument_list|)
operator|*
name|FXP_NTXCB
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NTXCB
condition|;
name|i
operator|++
control|)
block|{
name|txp
index|[
name|i
index|]
operator|.
name|cb_status
operator|=
name|FXP_CB_STATUS_C
operator||
name|FXP_CB_STATUS_OK
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|cb_command
operator|=
name|FXP_CB_COMMAND_NOP
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|link_addr
operator|=
name|vtophys
argument_list|(
operator|&
name|txp
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|FXP_TXCB_MASK
index|]
operator|.
name|cb_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_EXT_TXCB
condition|)
name|txp
index|[
name|i
index|]
operator|.
name|tbd_array_addr
operator|=
name|vtophys
argument_list|(
operator|&
name|txp
index|[
name|i
index|]
operator|.
name|tbd
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|txp
index|[
name|i
index|]
operator|.
name|tbd_array_addr
operator|=
name|vtophys
argument_list|(
operator|&
name|txp
index|[
name|i
index|]
operator|.
name|tbd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|&
name|txp
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|FXP_TXCB_MASK
index|]
expr_stmt|;
block|}
comment|/* 	 * Set the suspend flag on the first TxCB and start the control 	 * unit. It will execute the NOP and then suspend. 	 */
name|txp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_NOP
operator||
name|FXP_CB_COMMAND_S
expr_stmt|;
name|sc
operator|->
name|cbl_first
operator|=
name|sc
operator|->
name|cbl_last
operator|=
name|txp
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|=
literal|1
expr_stmt|;
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_START
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize receiver buffer area - RFA. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|rfa_headm
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
operator|+
name|RFA_ALIGNMENT_FUDGE
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_RU_START
argument_list|)
expr_stmt|;
comment|/* 	 * Set current media. 	 */
if|if
condition|(
name|sc
operator|->
name|miibus
operator|!=
name|NULL
condition|)
name|mii_mediachg
argument_list|(
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* 	 * Enable interrupts. 	 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_INTRCNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Start stats updater. 	 */
name|sc
operator|->
name|stat_ch
operator|=
name|timeout
argument_list|(
name|fxp_tick
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fxp_serial_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_serial_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_MANUAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change media according to request.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Notify the world which media we're using.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
if|if
condition|(
name|ifmr
operator|->
name|ifm_status
operator|&
name|IFM_10_T
operator|&&
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_CU_RESUME_BUG
condition|)
name|sc
operator|->
name|cu_resume_bug
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|cu_resume_bug
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a buffer to the end of the RFA buffer list.  * Return 0 if successful, 1 for failure. A failure results in  * adding the 'oldm' (if non-NULL) on to the end of the list -  * tossing out its old contents and recycling it.  * The RFA struct is stuck at the beginning of mbuf cluster and the  * data pointer is fixed up to point just past it.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_add_rfabuf
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|oldm
parameter_list|)
block|{
name|u_int32_t
name|v
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|fxp_rfa
modifier|*
name|rfa
decl_stmt|,
modifier|*
name|p_rfa
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldm
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|m
operator|=
name|oldm
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|oldm
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|m
operator|=
name|oldm
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
block|}
comment|/* 	 * Move the data pointer up so that the incoming data packet 	 * will be 32-bit aligned. 	 */
name|m
operator|->
name|m_data
operator|+=
name|RFA_ALIGNMENT_FUDGE
expr_stmt|;
comment|/* 	 * Get a pointer to the base of the mbuf cluster and move 	 * data start past it. 	 */
name|rfa
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|fxp_rfa
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_rfa
argument_list|)
expr_stmt|;
name|rfa
operator|->
name|size
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|MCLBYTES
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_rfa
argument_list|)
operator|-
name|RFA_ALIGNMENT_FUDGE
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the rest of the RFA.  Note that since the RFA 	 * is misaligned, we cannot store values directly.  Instead, 	 * we use an optimized, inline copy. 	 */
name|rfa
operator|->
name|rfa_status
operator|=
literal|0
expr_stmt|;
name|rfa
operator|->
name|rfa_control
operator|=
name|FXP_RFA_CONTROL_EL
expr_stmt|;
name|rfa
operator|->
name|actual_size
operator|=
literal|0
expr_stmt|;
name|v
operator|=
operator|-
literal|1
expr_stmt|;
name|fxp_lwcopy
argument_list|(
operator|&
name|v
argument_list|,
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|rfa
operator|->
name|link_addr
argument_list|)
expr_stmt|;
name|fxp_lwcopy
argument_list|(
operator|&
name|v
argument_list|,
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|rfa
operator|->
name|rbd_addr
argument_list|)
expr_stmt|;
comment|/* 	 * If there are other buffers already on the list, attach this 	 * one to the end by fixing up the tail to point to this one. 	 */
if|if
condition|(
name|sc
operator|->
name|rfa_headm
operator|!=
name|NULL
condition|)
block|{
name|p_rfa
operator|=
operator|(
expr|struct
name|fxp_rfa
operator|*
operator|)
operator|(
name|sc
operator|->
name|rfa_tailm
operator|->
name|m_ext
operator|.
name|ext_buf
operator|+
name|RFA_ALIGNMENT_FUDGE
operator|)
expr_stmt|;
name|sc
operator|->
name|rfa_tailm
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|v
operator|=
name|vtophys
argument_list|(
name|rfa
argument_list|)
expr_stmt|;
name|fxp_lwcopy
argument_list|(
operator|&
name|v
argument_list|,
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|p_rfa
operator|->
name|link_addr
argument_list|)
expr_stmt|;
name|p_rfa
operator|->
name|rfa_control
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|rfa_headm
operator|=
name|m
expr_stmt|;
block|}
name|sc
operator|->
name|rfa_tailm
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|m
operator|==
name|oldm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|volatile
name|int
name|fxp_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|10000
decl_stmt|;
name|int
name|value
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_MDICONTROL
argument_list|,
operator|(
name|FXP_MDI_READ
operator|<<
literal|26
operator|)
operator||
operator|(
name|reg
operator|<<
literal|16
operator|)
operator||
operator|(
name|phy
operator|<<
literal|21
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|value
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_MDICONTROL
argument_list|)
operator|)
operator|&
literal|0x10000000
operator|)
operator|==
literal|0
operator|&&
name|count
operator|--
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"fxp_miibus_readreg: timed out\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|&
literal|0xffff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|10000
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_MDICONTROL
argument_list|,
operator|(
name|FXP_MDI_WRITE
operator|<<
literal|26
operator|)
operator||
operator|(
name|reg
operator|<<
literal|16
operator|)
operator||
operator|(
name|phy
operator|<<
literal|21
operator|)
operator||
operator|(
name|value
operator|&
literal|0xffff
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_MDICONTROL
argument_list|)
operator|&
literal|0x10000000
operator|)
operator|==
literal|0
operator|&&
name|count
operator|--
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"fxp_miibus_writereg: timed out\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fxp_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_ALL_MCAST
expr_stmt|;
else|else
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FXP_FLAG_ALL_MCAST
expr_stmt|;
comment|/* 		 * If interface is marked up and not running, then start it. 		 * If it is marked down and running, stop it. 		 * XXX If it's up then re-initialize it. This is so flags 		 * such as IFF_PROMISC are handled. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|fxp_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_ALL_MCAST
expr_stmt|;
else|else
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FXP_FLAG_ALL_MCAST
expr_stmt|;
comment|/* 		 * Multicast list has changed; set the hardware filter 		 * accordingly. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_ALL_MCAST
operator|)
operator|==
literal|0
condition|)
name|fxp_mc_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * fxp_mc_setup() can set FXP_FLAG_ALL_MCAST, so check it 		 * again rather than else {}. 		 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_ALL_MCAST
condition|)
name|fxp_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
if|if
condition|(
name|sc
operator|->
name|miibus
operator|!=
name|NULL
condition|)
block|{
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Program the multicast filter.  *  * We have an artificial restriction that the multicast setup command  * must be the first command in the chain, so we take steps to ensure  * this. By requiring this, it allows us to keep up the performance of  * the pre-initialized command ring (esp. link pointers) by not actually  * inserting the mcsetup command in the ring - i.e. its link pointer  * points to the TxCB ring, but the mcsetup descriptor itself is not part  * of it. We then can do 'CU_START' on the mcsetup descriptor and have it  * lead into the regular TxCB ring when it completes.  *  * This function must be called at splimp.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_mc_setup
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|fxp_cb_mcs
modifier|*
name|mcsp
init|=
name|sc
operator|->
name|mcsp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|int
name|nmcasts
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* 	 * If there are queued commands, we must wait until they are all 	 * completed. If we are already waiting, then add a NOP command 	 * with interrupt option so that we're notified when all commands 	 * have been completed - fxp_start() ensures that no additional 	 * TX commands will be added when need_mcsetup is true. 	 */
if|if
condition|(
name|sc
operator|->
name|tx_queued
condition|)
block|{
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
comment|/* 		 * need_mcsetup will be true if we are already waiting for the 		 * NOP command to be completed (see below). In this case, bail. 		 */
if|if
condition|(
name|sc
operator|->
name|need_mcsetup
condition|)
return|return;
name|sc
operator|->
name|need_mcsetup
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Add a NOP command with interrupt so that we are notified when all 		 * TX commands have been processed. 		 */
name|txp
operator|=
name|sc
operator|->
name|cbl_last
operator|->
name|next
expr_stmt|;
name|txp
operator|->
name|mb_head
operator|=
name|NULL
expr_stmt|;
name|txp
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|txp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_NOP
operator||
name|FXP_CB_COMMAND_S
operator||
name|FXP_CB_COMMAND_I
expr_stmt|;
comment|/* 		 * Advance the end of list forward. 		 */
name|sc
operator|->
name|cbl_last
operator|->
name|cb_command
operator|&=
operator|~
name|FXP_CB_COMMAND_S
expr_stmt|;
name|sc
operator|->
name|cbl_last
operator|=
name|txp
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|++
expr_stmt|;
comment|/* 		 * Issue a resume in case the CU has just suspended. 		 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_RESUME
argument_list|)
expr_stmt|;
comment|/* 		 * Set a 5 second timer just in case we don't hear from the 		 * card again. 		 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|need_mcsetup
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize multicast setup descriptor. 	 */
name|mcsp
operator|->
name|next
operator|=
name|sc
operator|->
name|cbl_base
expr_stmt|;
name|mcsp
operator|->
name|mb_head
operator|=
name|NULL
expr_stmt|;
name|mcsp
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|mcsp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_MCAS
operator||
name|FXP_CB_COMMAND_S
operator||
name|FXP_CB_COMMAND_I
expr_stmt|;
name|mcsp
operator|->
name|link_addr
operator|=
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|cbl_base
operator|->
name|cb_status
argument_list|)
expr_stmt|;
name|nmcasts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_ALL_MCAST
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|LIST_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
else|#
directive|else
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
endif|#
directive|endif
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|nmcasts
operator|>=
name|MAXMCADDR
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_ALL_MCAST
expr_stmt|;
name|nmcasts
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
operator|&
name|sc
operator|->
name|mcsp
operator|->
name|mc_addr
index|[
name|nmcasts
index|]
index|[
literal|0
index|]
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|nmcasts
operator|++
expr_stmt|;
block|}
block|}
name|mcsp
operator|->
name|mc_cnt
operator|=
name|nmcasts
operator|*
literal|6
expr_stmt|;
name|sc
operator|->
name|cbl_first
operator|=
name|sc
operator|->
name|cbl_last
operator|=
operator|(
expr|struct
name|fxp_cb_tx
operator|*
operator|)
name|mcsp
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Wait until command unit is not active. This should never 	 * be the case when nothing is queued, but make sure anyway. 	 */
name|count
operator|=
literal|100
expr_stmt|;
while|while
condition|(
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_RUSCUS
argument_list|)
operator|>>
literal|6
operator|)
operator|==
name|FXP_SCB_CUS_ACTIVE
operator|&&
operator|--
name|count
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"command queue timeout\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Start the multicast setup command. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|vtophys
argument_list|(
operator|&
name|mcsp
operator|->
name|cb_status
argument_list|)
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_START
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
return|return;
block|}
end_function

end_unit

