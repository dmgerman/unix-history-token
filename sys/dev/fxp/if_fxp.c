begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995, David Greenman  * All rights reserved.  *  * Modifications to support NetBSD and media selection:  * Copyright (c) 1997 Jason R. Thorpe.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Intel EtherExpress Pro/100B PCI Fast Ethernet driver  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_inarp.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/if_fxpreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/if_fxpvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcidevs.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* for vtophys */
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* for vtophys */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_comment
comment|/* for PCIM_CMD_xxx */
end_comment

begin_include
include|#
directive|include
file|<pci/if_fxpreg.h>
end_include

begin_include
include|#
directive|include
file|<pci/if_fxpvar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/* XXX XXX NEED REAL DMA MAPPING SUPPORT XXX XXX */
end_comment

begin_undef
undef|#
directive|undef
name|vtophys
end_undef

begin_define
define|#
directive|define
name|vtophys
parameter_list|(
name|va
parameter_list|)
value|alpha_XXX_dmamap((vm_offset_t)(va))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __alpha__ */
end_comment

begin_include
include|#
directive|include
file|"opt_bdg.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/bridge.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * NOTE!  On the Alpha, we have an alignment constraint.  The  * card DMAs the packet immediately following the RFA.  However,  * the first thing in the packet is a 14-byte Ethernet header.  * This means that the packet is misaligned.  To compensate,  * we actually offset the RFA 2 bytes into the cluster.  This  * alignes the packet after the Ethernet header at a 32-bit  * boundary.  HOWEVER!  This means that the RFA is misaligned!  */
end_comment

begin_define
define|#
directive|define
name|RFA_ALIGNMENT_FUDGE
value|2
end_define

begin_comment
comment|/*  * Inline function to copy a 16-bit aligned 32-bit quantity.  */
end_comment

begin_decl_stmt
specifier|static
name|__inline
name|void
name|fxp_lwcopy
name|__P
argument_list|(
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|,
specifier|volatile
name|u_int32_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
name|void
name|fxp_lwcopy
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
specifier|volatile
name|u_int32_t
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_block
block|{
specifier|volatile
name|u_int16_t
modifier|*
name|a
init|=
operator|(
specifier|volatile
name|u_int16_t
operator|*
operator|)
name|src
decl_stmt|;
specifier|volatile
name|u_int16_t
modifier|*
name|b
init|=
operator|(
specifier|volatile
name|u_int16_t
operator|*
operator|)
name|dst
decl_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|a
index|[
literal|0
index|]
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
name|a
index|[
literal|1
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Template for default configuration parameters.  * See struct fxp_cb_config for the bit definitions.  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|fxp_cb_config_template
index|[]
init|=
block|{
literal|0x0
block|,
literal|0x0
block|,
comment|/* cb_status */
literal|0x80
block|,
literal|0x2
block|,
comment|/* cb_command */
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* link_addr */
literal|0x16
block|,
comment|/*  0 */
literal|0x8
block|,
comment|/*  1 */
literal|0x0
block|,
comment|/*  2 */
literal|0x0
block|,
comment|/*  3 */
literal|0x0
block|,
comment|/*  4 */
literal|0x80
block|,
comment|/*  5 */
literal|0xb2
block|,
comment|/*  6 */
literal|0x3
block|,
comment|/*  7 */
literal|0x1
block|,
comment|/*  8 */
literal|0x0
block|,
comment|/*  9 */
literal|0x26
block|,
comment|/* 10 */
literal|0x0
block|,
comment|/* 11 */
literal|0x60
block|,
comment|/* 12 */
literal|0x0
block|,
comment|/* 13 */
literal|0xf2
block|,
comment|/* 14 */
literal|0x48
block|,
comment|/* 15 */
literal|0x0
block|,
comment|/* 16 */
literal|0x40
block|,
comment|/* 17 */
literal|0xf3
block|,
comment|/* 18 */
literal|0x0
block|,
comment|/* 19 */
literal|0x3f
block|,
comment|/* 20 */
literal|0x5
comment|/* 21 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Supported media types. */
end_comment

begin_struct
struct|struct
name|fxp_supported_media
block|{
specifier|const
name|int
name|fsm_phy
decl_stmt|;
comment|/* PHY type */
specifier|const
name|int
modifier|*
name|fsm_media
decl_stmt|;
comment|/* the media array */
specifier|const
name|int
name|fsm_nmedia
decl_stmt|;
comment|/* the number of supported media */
specifier|const
name|int
name|fsm_defmedia
decl_stmt|;
comment|/* default media for this PHY */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|int
name|fxp_media_standard
index|[]
init|=
block|{
name|IFM_ETHER
operator||
name|IFM_10_T
block|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
block|,
name|IFM_ETHER
operator||
name|IFM_100_TX
block|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
block|,
name|IFM_ETHER
operator||
name|IFM_AUTO
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FXP_MEDIA_STANDARD_DEFMEDIA
value|(IFM_ETHER|IFM_AUTO)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|fxp_media_default
index|[]
init|=
block|{
name|IFM_ETHER
operator||
name|IFM_MANUAL
block|,
comment|/* XXX IFM_AUTO ? */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FXP_MEDIA_DEFAULT_DEFMEDIA
value|(IFM_ETHER|IFM_MANUAL)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|fxp_supported_media
name|fxp_media
index|[]
init|=
block|{
block|{
name|FXP_PHY_DP83840
block|,
name|fxp_media_standard
block|,
sizeof|sizeof
argument_list|(
name|fxp_media_standard
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fxp_media_standard
index|[
literal|0
index|]
argument_list|)
block|,
name|FXP_MEDIA_STANDARD_DEFMEDIA
block|}
block|,
block|{
name|FXP_PHY_DP83840A
block|,
name|fxp_media_standard
block|,
sizeof|sizeof
argument_list|(
name|fxp_media_standard
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fxp_media_standard
index|[
literal|0
index|]
argument_list|)
block|,
name|FXP_MEDIA_STANDARD_DEFMEDIA
block|}
block|,
block|{
name|FXP_PHY_82553A
block|,
name|fxp_media_standard
block|,
sizeof|sizeof
argument_list|(
name|fxp_media_standard
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fxp_media_standard
index|[
literal|0
index|]
argument_list|)
block|,
name|FXP_MEDIA_STANDARD_DEFMEDIA
block|}
block|,
block|{
name|FXP_PHY_82553C
block|,
name|fxp_media_standard
block|,
sizeof|sizeof
argument_list|(
name|fxp_media_standard
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fxp_media_standard
index|[
literal|0
index|]
argument_list|)
block|,
name|FXP_MEDIA_STANDARD_DEFMEDIA
block|}
block|,
block|{
name|FXP_PHY_82555
block|,
name|fxp_media_standard
block|,
sizeof|sizeof
argument_list|(
name|fxp_media_standard
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fxp_media_standard
index|[
literal|0
index|]
argument_list|)
block|,
name|FXP_MEDIA_STANDARD_DEFMEDIA
block|}
block|,
block|{
name|FXP_PHY_82555B
block|,
name|fxp_media_standard
block|,
sizeof|sizeof
argument_list|(
name|fxp_media_standard
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fxp_media_standard
index|[
literal|0
index|]
argument_list|)
block|,
name|FXP_MEDIA_STANDARD_DEFMEDIA
block|}
block|,
block|{
name|FXP_PHY_80C24
block|,
name|fxp_media_default
block|,
sizeof|sizeof
argument_list|(
name|fxp_media_default
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fxp_media_default
index|[
literal|0
index|]
argument_list|)
block|,
name|FXP_MEDIA_DEFAULT_DEFMEDIA
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NFXPMEDIA
value|(sizeof(fxp_media) / sizeof(fxp_media[0]))
end_define

begin_decl_stmt
specifier|static
name|int
name|fxp_mediachange
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_mediastatus
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|ifmediareq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_set_media
name|__P
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|fxp_scb_wait
name|__P
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FXP_INTR_TYPE
name|fxp_intr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fxp_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|FXP_IOCTLCMD_TYPE
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_init
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_stop
name|__P
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fxp_add_rfabuf
name|__P
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fxp_mdi_read
name|__P
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_mdi_write
name|__P
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_autosize_eeprom
name|__P
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_read_eeprom
name|__P
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|,
name|u_int16_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fxp_attach_common
name|__P
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|,
name|u_int8_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_stats_update
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_mc_setup
name|__P
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set initial transmit threshold at 64 (512 bytes). This is  * increased by 64 (512 bytes) at a time, to maximum of 192  * (1536 bytes), if an underrun occurs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tx_threshold
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Number of transmit control blocks. This determines the number  * of transmit buffers that can be chained in the CB list.  * This must be a power of two.  */
end_comment

begin_define
define|#
directive|define
name|FXP_NTXCB
value|128
end_define

begin_comment
comment|/*  * Number of completed TX commands at which point an interrupt  * will be generated to garbage collect the attached buffers.  * Must be at least one less than FXP_NTXCB, and should be  * enough less so that the transmitter doesn't becomes idle  * during the buffer rundown (which would reduce performance).  */
end_comment

begin_define
define|#
directive|define
name|FXP_CXINT_THRESH
value|120
end_define

begin_comment
comment|/*  * TxCB list index mask. This is used to do list wrap-around.  */
end_comment

begin_define
define|#
directive|define
name|FXP_TXCB_MASK
value|(FXP_NTXCB - 1)
end_define

begin_comment
comment|/*  * Number of receive frame area buffers. These are large so chose  * wisely.  */
end_comment

begin_define
define|#
directive|define
name|FXP_NRFABUFS
value|64
end_define

begin_comment
comment|/*  * Maximum number of seconds that the receiver can be idle before we  * assume it's dead and attempt to reset it by reprogramming the  * multicast filter. This is part of a work-around for a bug in the  * NIC. See fxp_stats_update().  */
end_comment

begin_define
define|#
directive|define
name|FXP_MAX_RX_IDLE
value|15
end_define

begin_comment
comment|/*  * Wait for the previous command to be accepted (but not necessarily  * completed).  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|fxp_scb_wait
parameter_list|(
name|sc
parameter_list|)
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
init|=
literal|10000
decl_stmt|;
while|while
condition|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|)
operator|&&
operator|--
name|i
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*************************************************************  * Operating system-specific autoconfiguration glue  *************************************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__BROKEN_INDIRECT_CONFIG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|fxp_match
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|fxp_match
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|cfdata
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|fxp_attach
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_shutdown
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compensate for lack of a generic ether_ioctl() */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fxp_ether_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|FXP_IOCTLCMD_TYPE
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ether_ioctl
value|fxp_ether_ioctl
end_define

begin_decl_stmt
name|struct
name|cfattach
name|fxp_ca
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_softc
argument_list|)
block|,
name|fxp_match
block|,
name|fxp_attach
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cfdriver
name|fxp_cd
init|=
block|{
name|NULL
block|,
literal|"fxp"
block|,
name|DV_IFNET
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check if a device is an 82557.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_match
parameter_list|(
name|parent
parameter_list|,
name|match
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
ifdef|#
directive|ifdef
name|__BROKEN_INDIRECT_CONFIG
name|void
modifier|*
name|match
decl_stmt|;
else|#
directive|else
name|struct
name|cfdata
modifier|*
name|match
decl_stmt|;
endif|#
directive|endif
name|void
modifier|*
name|aux
decl_stmt|;
block|{
name|struct
name|pci_attach_args
modifier|*
name|pa
init|=
name|aux
decl_stmt|;
if|if
condition|(
name|PCI_VENDOR
argument_list|(
name|pa
operator|->
name|pa_id
argument_list|)
operator|!=
name|PCI_VENDOR_INTEL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|PCI_PRODUCT
argument_list|(
name|pa
operator|->
name|pa_id
argument_list|)
condition|)
block|{
case|case
name|PCI_PRODUCT_INTEL_82557
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_attach
parameter_list|(
name|parent
parameter_list|,
name|self
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|,
decl|*
name|self
decl_stmt|;
end_function

begin_decl_stmt
name|void
modifier|*
name|aux
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fxp_softc
operator|*
operator|)
name|self
decl_stmt|;
name|struct
name|pci_attach_args
modifier|*
name|pa
init|=
name|aux
decl_stmt|;
name|pci_chipset_tag_t
name|pc
init|=
name|pa
operator|->
name|pa_pc
decl_stmt|;
name|pci_intr_handle_t
name|ih
decl_stmt|;
specifier|const
name|char
modifier|*
name|intrstr
init|=
name|NULL
decl_stmt|;
name|u_int8_t
name|enaddr
index|[
literal|6
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* 	 * Map control/status registers. 	 */
if|if
condition|(
name|pci_mapreg_map
argument_list|(
name|pa
argument_list|,
name|FXP_PCI_MMBA
argument_list|,
name|PCI_MAPREG_TYPE_MEM
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_st
argument_list|,
operator|&
name|sc
operator|->
name|sc_sh
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": can't map registers\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|": Intel EtherExpress Pro 10/100B Ethernet\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate our interrupt. 	 */
if|if
condition|(
name|pci_intr_map
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_intrtag
argument_list|,
name|pa
operator|->
name|pa_intrpin
argument_list|,
name|pa
operator|->
name|pa_intrline
argument_list|,
operator|&
name|ih
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: couldn't map interrupt\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return;
block|}
name|intrstr
operator|=
name|pci_intr_string
argument_list|(
name|pc
argument_list|,
name|ih
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ih
operator|=
name|pci_intr_establish
argument_list|(
name|pc
argument_list|,
name|ih
argument_list|,
name|IPL_NET
argument_list|,
name|fxp_intr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ih
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: couldn't establish interrupt"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|intrstr
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|" at %s"
argument_list|,
name|intrstr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%s: interrupting at %s\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|intrstr
argument_list|)
expr_stmt|;
comment|/* Do generic parts of attach. */
if|if
condition|(
name|fxp_attach_common
argument_list|(
name|sc
argument_list|,
name|enaddr
argument_list|)
condition|)
block|{
comment|/* Failed! */
return|return;
block|}
name|printf
argument_list|(
literal|"%s: Ethernet address %s%s\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|ether_sprintf
argument_list|(
name|enaddr
argument_list|)
argument_list|,
name|sc
operator|->
name|phy_10Mbps_only
condition|?
literal|", 10Mbps"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|sc_ethercom
operator|.
name|ec_if
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|fxp_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|fxp_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|fxp_watchdog
expr_stmt|;
comment|/* 	 * Attach the interface. 	 */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Let the system queue as many packets as we have available 	 * TX descriptors. 	 */
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|FXP_NTXCB
operator|-
literal|1
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|enaddr
argument_list|)
expr_stmt|;
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|sc_ethercom
operator|.
name|ec_if
operator|.
name|if_bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Add shutdown hook so that DMA is disabled prior to reboot. Not 	 * doing do could allow DMA to corrupt kernel memory during the 	 * reboot before the driver initializes. 	 */
name|shutdownhook_establish
argument_list|(
name|fxp_shutdown
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Device shutdown routine. Called at system shutdown after sync. The  * main purpose of this routine is to shut off receiver DMA so that  * kernel memory doesn't get clobbered during warmboot.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_shutdown
parameter_list|(
name|sc
parameter_list|)
name|void
modifier|*
name|sc
decl_stmt|;
block|{
name|fxp_stop
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fxp_ether_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|FXP_IOCTLCMD_TYPE
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|fxp_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
name|LLADDR
argument_list|(
name|ifp
operator|->
name|if_sadl
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
name|LLADDR
argument_list|(
name|ifp
operator|->
name|if_sadl
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
comment|/* Set new address. */
name|fxp_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|fxp_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/*  * Return identification string if this is device is ours.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|FXP_VENDORID_INTEL
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|FXP_DEVICEID_i82557
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Intel EtherExpress Pro 10/100B Ethernet"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|FXP_VENDORID_INTEL
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|FXP_DEVICEID_i82559
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Intel InBusiness 10/100 Ethernet"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fxp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_long
name|val
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Enable bus mastering. 	 */
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Map control/status registers. 	 */
name|rid
operator|=
name|FXP_PCI_MMBA
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mem
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate our interrupt. 	 */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|fxp_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup irq\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Do generic parts of attach. */
if|if
condition|(
name|fxp_attach_common
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
condition|)
block|{
comment|/* Failed! */
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|FXP_PCI_MMBA
argument_list|,
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Ethernet address %6D%s\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|phy_10Mbps_only
condition|?
literal|", 10Mbps"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"fxp"
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|fxp_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|fxp_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|fxp_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|fxp_watchdog
expr_stmt|;
comment|/* 	 * Attach the interface. 	 */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Let the system queue as many packets as we have available 	 * TX descriptors. 	 */
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|FXP_NTXCB
operator|-
literal|1
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Detach interface.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Close down routes etc. 	 */
name|if_detach
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
comment|/* 	 * Stop DMA and drop transmit queue. 	 */
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Deallocate resources. 	 */
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|FXP_PCI_MMBA
argument_list|,
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
comment|/* 	 * Free all the receive buffers. 	 */
if|if
condition|(
name|sc
operator|->
name|rfa_headm
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|rfa_headm
argument_list|)
expr_stmt|;
comment|/* 	 * Free all media structures. 	 */
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|)
expr_stmt|;
comment|/* 	 * Free anciliary structures. 	 */
name|free
argument_list|(
name|sc
operator|->
name|cbl_base
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|fxp_stats
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|mcsp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Device shutdown routine. Called at system shutdown after sync. The  * main purpose of this routine is to shut off receiver DMA so that  * kernel memory doesn't get clobbered during warmboot.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * Make sure that DMA is disabled prior to reboot. Not doing 	 * do could allow DMA to corrupt kernel memory during the 	 * reboot before the driver initializes. 	 */
name|fxp_stop
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|fxp_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fxp_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fxp_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fxp_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|fxp_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fxp_driver
init|=
block|{
literal|"fxp"
block|,
name|fxp_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|fxp_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_fxp
argument_list|,
name|pci
argument_list|,
name|fxp_driver
argument_list|,
name|fxp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_comment
comment|/*************************************************************  * End of operating system-specific autoconfiguration glue  *************************************************************/
end_comment

begin_comment
comment|/*  * Do generic parts of attach.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_attach_common
parameter_list|(
name|sc
parameter_list|,
name|enaddr
parameter_list|)
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
name|u_int8_t
modifier|*
name|enaddr
decl_stmt|;
block|{
name|u_int16_t
name|data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nmedia
decl_stmt|,
name|defmedia
decl_stmt|;
specifier|const
name|int
modifier|*
name|media
decl_stmt|;
comment|/* 	 * Reset to a stable state. 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_PORT
argument_list|,
name|FXP_PORT_SELECTIVE_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cbl_base
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_cb_tx
argument_list|)
operator|*
name|FXP_NTXCB
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cbl_base
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|bzero
argument_list|(
name|sc
operator|->
name|cbl_base
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_cb_tx
argument_list|)
operator|*
name|FXP_NTXCB
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fxp_stats
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_stats
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fxp_stats
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|bzero
argument_list|(
name|sc
operator|->
name|fxp_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_stats
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mcsp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_cb_mcs
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mcsp
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Pre-allocate our receive buffers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NRFABUFS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fxp_add_rfabuf
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* 	 * Find out how large of an SEEPROM we have. 	 */
name|fxp_autosize_eeprom
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Get info about the primary PHY 	 */
name|fxp_read_eeprom
argument_list|(
name|sc
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|data
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|phy_primary_addr
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|phy_primary_device
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|sc
operator|->
name|phy_10Mbps_only
operator|=
name|data
operator|>>
literal|15
expr_stmt|;
comment|/* 	 * Read MAC address. 	 */
name|fxp_read_eeprom
argument_list|(
name|sc
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|enaddr
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the media structures. 	 */
name|media
operator|=
name|fxp_media_default
expr_stmt|;
name|nmedia
operator|=
sizeof|sizeof
argument_list|(
name|fxp_media_default
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fxp_media_default
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|defmedia
operator|=
name|FXP_MEDIA_DEFAULT_DEFMEDIA
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFXPMEDIA
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|phy_primary_device
operator|==
name|fxp_media
index|[
name|i
index|]
operator|.
name|fsm_phy
condition|)
block|{
name|media
operator|=
name|fxp_media
index|[
name|i
index|]
operator|.
name|fsm_media
expr_stmt|;
name|nmedia
operator|=
name|fxp_media
index|[
name|i
index|]
operator|.
name|fsm_nmedia
expr_stmt|;
name|defmedia
operator|=
name|fxp_media
index|[
name|i
index|]
operator|.
name|fsm_defmedia
expr_stmt|;
block|}
block|}
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
literal|0
argument_list|,
name|fxp_mediachange
argument_list|,
name|fxp_mediastatus
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmedia
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|media
index|[
name|i
index|]
argument_list|)
operator|==
name|IFM_100_TX
operator|&&
name|sc
operator|->
name|phy_10Mbps_only
condition|)
continue|continue;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|media
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|defmedia
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|printf
argument_list|(
name|FXP_FORMAT
literal|": Failed to malloc memory\n"
argument_list|,
name|FXP_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cbl_base
condition|)
name|free
argument_list|(
name|sc
operator|->
name|cbl_base
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fxp_stats
condition|)
name|free
argument_list|(
name|sc
operator|->
name|fxp_stats
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mcsp
condition|)
name|free
argument_list|(
name|sc
operator|->
name|mcsp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* frees entire chain */
if|if
condition|(
name|sc
operator|->
name|rfa_headm
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|rfa_headm
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * From NetBSD:  *  * Figure out EEPROM size.  *  * 559's can have either 64-word or 256-word EEPROMs, the 558  * datasheet only talks about 64-word EEPROMs, and the 557 datasheet  * talks about the existance of 16 to 256 word EEPROMs.  *  * The only known sizes are 64 and 256, where the 256 version is used  * by CardBus cards to store CIS information.  *  * The address is shifted in msb-to-lsb, and after the last  * address-bit the EEPROM is supposed to output a `dummy zero' bit,  * after which follows the actual data. We try to detect this zero, by  * probing the data-out bit in the EEPROM control register just after  * having shifted in a bit. If the bit is zero, we assume we've  * shifted enough address bits. The data-out should be tri-state,  * before this, which should translate to a logical one.  *  * Other ways to do this would be to try to read a register with known  * contents with a varying number of address bits, but no such  * register seem to be available. The high bits of register 10 are 01  * on the 558 and 559, but apparently not on the 557.  *   * The Linux driver computes a checksum on the EEPROM data, but the  * value of this checksum is not very well documented.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_autosize_eeprom
parameter_list|(
name|sc
parameter_list|)
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|u_int16_t
name|reg
decl_stmt|;
name|int
name|x
decl_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|FXP_EEPROM_EECS
argument_list|)
expr_stmt|;
comment|/* 	 * Shift in read opcode. 	 */
for|for
control|(
name|x
operator|=
literal|3
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
control|)
block|{
if|if
condition|(
name|FXP_EEPROM_OPC_READ
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|reg
operator|=
name|FXP_EEPROM_EECS
operator||
name|FXP_EEPROM_EEDI
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|FXP_EEPROM_EECS
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
operator||
name|FXP_EEPROM_EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Shift in address. 	 * Wait for the dummy zero following a correct address shift. 	 */
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<=
literal|8
condition|;
name|x
operator|++
control|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|FXP_EEPROM_EECS
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|FXP_EEPROM_EECS
operator||
name|FXP_EEPROM_EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|)
operator|&
name|FXP_EEPROM_EEDO
operator|)
operator|==
literal|0
condition|)
break|break;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|FXP_EEPROM_EECS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eeprom_size
operator|=
name|x
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read from the serial EEPROM. Basically, you manually shift in  * the read opcode (one bit at a time) and then shift in the address,  * and then you shift out the data (all of this one bit at a time).  * The word size is 16 bits, so you have to provide the address for  * every 16 bits of data.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_read_eeprom
parameter_list|(
name|sc
parameter_list|,
name|data
parameter_list|,
name|offset
parameter_list|,
name|words
parameter_list|)
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
name|u_short
modifier|*
name|data
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|words
decl_stmt|;
block|{
name|u_int16_t
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|FXP_EEPROM_EECS
argument_list|)
expr_stmt|;
comment|/* 		 * Shift in read opcode. 		 */
for|for
control|(
name|x
operator|=
literal|3
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
control|)
block|{
if|if
condition|(
name|FXP_EEPROM_OPC_READ
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|reg
operator|=
name|FXP_EEPROM_EECS
operator||
name|FXP_EEPROM_EEDI
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|FXP_EEPROM_EECS
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
operator||
name|FXP_EEPROM_EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Shift in address. 		 */
for|for
control|(
name|x
operator|=
name|sc
operator|->
name|eeprom_size
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
name|offset
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|reg
operator|=
name|FXP_EEPROM_EECS
operator||
name|FXP_EEPROM_EEDI
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|FXP_EEPROM_EECS
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
operator||
name|FXP_EEPROM_EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|FXP_EEPROM_EECS
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Shift out data. 		 */
for|for
control|(
name|x
operator|=
literal|16
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
control|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
operator||
name|FXP_EEPROM_EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|)
operator|&
name|FXP_EEPROM_EEDO
condition|)
name|data
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start packet transmission on the interface.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
comment|/* 	 * See if we need to suspend xmit until the multicast filter 	 * has been reprogrammed (which can only be done at the head 	 * of the command chain). 	 */
if|if
condition|(
name|sc
operator|->
name|need_mcsetup
condition|)
return|return;
name|txp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We're finished if there is nothing more to add to the list or if 	 * we're all filled up with buffers to transmit. 	 * NOTE: One TxCB is reserved to guarantee that fxp_mc_setup() can add 	 *       a NOP command when needed. 	 */
while|while
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|tx_queued
operator|<
name|FXP_NTXCB
operator|-
literal|1
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mb_head
decl_stmt|;
name|int
name|segment
decl_stmt|;
comment|/* 		 * Grab a packet to transmit. 		 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mb_head
argument_list|)
expr_stmt|;
comment|/* 		 * Get pointer to next available tx desc. 		 */
name|txp
operator|=
name|sc
operator|->
name|cbl_last
operator|->
name|next
expr_stmt|;
comment|/* 		 * Go through each of the mbufs in the chain and initialize 		 * the transmit buffer descriptors with the physical address 		 * and size of the mbuf. 		 */
name|tbdinit
label|:
for|for
control|(
name|m
operator|=
name|mb_head
operator|,
name|segment
operator|=
literal|0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|segment
operator|==
name|FXP_NTXSEG
condition|)
break|break;
name|txp
operator|->
name|tbd
index|[
name|segment
index|]
operator|.
name|tb_addr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
expr_stmt|;
name|txp
operator|->
name|tbd
index|[
name|segment
index|]
operator|.
name|tb_size
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|segment
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mn
decl_stmt|;
comment|/* 			 * We ran out of segments. We have to recopy this mbuf 			 * chain first. Bail out if we can't get the new buffers. 			 */
name|MGETHDR
argument_list|(
name|mn
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mn
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb_head
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|mn
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mn
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|mn
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb_head
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|m_copydata
argument_list|(
name|mb_head
argument_list|,
literal|0
argument_list|,
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|mn
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|mn
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mn
operator|->
name|m_len
operator|=
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|mb_head
argument_list|)
expr_stmt|;
name|mb_head
operator|=
name|mn
expr_stmt|;
goto|goto
name|tbdinit
goto|;
block|}
name|txp
operator|->
name|tbd_number
operator|=
name|segment
expr_stmt|;
name|txp
operator|->
name|mb_head
operator|=
name|mb_head
expr_stmt|;
name|txp
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_queued
operator|!=
name|FXP_CXINT_THRESH
operator|-
literal|1
condition|)
block|{
name|txp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_XMIT
operator||
name|FXP_CB_COMMAND_SF
operator||
name|FXP_CB_COMMAND_S
expr_stmt|;
block|}
else|else
block|{
name|txp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_XMIT
operator||
name|FXP_CB_COMMAND_SF
operator||
name|FXP_CB_COMMAND_S
operator||
name|FXP_CB_COMMAND_I
expr_stmt|;
comment|/* 			 * Set a 5 second timer just in case we don't hear from the 			 * card again. 			 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
block|}
name|txp
operator|->
name|tx_threshold
operator|=
name|tx_threshold
expr_stmt|;
comment|/* 		 * Advance the end of list forward. 		 */
name|sc
operator|->
name|cbl_last
operator|->
name|cb_command
operator|&=
operator|~
name|FXP_CB_COMMAND_S
expr_stmt|;
name|sc
operator|->
name|cbl_last
operator|=
name|txp
expr_stmt|;
comment|/* 		 * Advance the beginning of the list forward if there are 		 * no other packets queued (when nothing is queued, cbl_first 		 * sits on the last TxCB that was sent out). 		 */
if|if
condition|(
name|sc
operator|->
name|tx_queued
operator|==
literal|0
condition|)
name|sc
operator|->
name|cbl_first
operator|=
name|txp
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|++
expr_stmt|;
comment|/* 		 * Pass packet to bpf if there is a listener. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|FXP_BPFTAP_ARG
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|mb_head
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We're finished. If we added to the list, issue a RESUME to get DMA 	 * going again if suspended. 	 */
if|if
condition|(
name|txp
operator|!=
name|NULL
condition|)
block|{
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|FXP_SCB_COMMAND_CU_RESUME
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process interface interrupts.  */
end_comment

begin_function
specifier|static
name|FXP_INTR_TYPE
name|fxp_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|u_int8_t
name|statack
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|int
name|claimed
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|statack
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_STATACK
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|claimed
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * First ACK all the interrupts in this pass. 		 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_STATACK
argument_list|,
name|statack
argument_list|)
expr_stmt|;
comment|/* 		 * Free any finished transmit mbuf chains. 		 */
if|if
condition|(
name|statack
operator|&
name|FXP_SCB_STATACK_CXTNO
condition|)
block|{
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
for|for
control|(
name|txp
operator|=
name|sc
operator|->
name|cbl_first
init|;
name|sc
operator|->
name|tx_queued
operator|&&
operator|(
name|txp
operator|->
name|cb_status
operator|&
name|FXP_CB_STATUS_C
operator|)
operator|!=
literal|0
condition|;
name|txp
operator|=
name|txp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|txp
operator|->
name|mb_head
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txp
operator|->
name|mb_head
argument_list|)
expr_stmt|;
name|txp
operator|->
name|mb_head
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|tx_queued
operator|--
expr_stmt|;
block|}
name|sc
operator|->
name|cbl_first
operator|=
name|txp
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_queued
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|need_mcsetup
condition|)
name|fxp_mc_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Try to start more packets transmitting. 			 */
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|fxp_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Process receiver interrupts. If a no-resource (RNR) 		 * condition exists, get whatever packets we can and 		 * re-start the receiver. 		 */
if|if
condition|(
name|statack
operator|&
operator|(
name|FXP_SCB_STATACK_FR
operator||
name|FXP_SCB_STATACK_RNR
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|fxp_rfa
modifier|*
name|rfa
decl_stmt|;
name|rcvloop
label|:
name|m
operator|=
name|sc
operator|->
name|rfa_headm
expr_stmt|;
name|rfa
operator|=
operator|(
expr|struct
name|fxp_rfa
operator|*
operator|)
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|+
name|RFA_ALIGNMENT_FUDGE
operator|)
expr_stmt|;
if|if
condition|(
name|rfa
operator|->
name|rfa_status
operator|&
name|FXP_RFA_STATUS_C
condition|)
block|{
comment|/* 				 * Remove first packet from the chain. 				 */
name|sc
operator|->
name|rfa_headm
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * Add a new buffer to the receive chain. 				 * If this fails, the old buffer is recycled 				 * instead. 				 */
if|if
condition|(
name|fxp_add_rfabuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|u_int16_t
name|total_len
decl_stmt|;
name|total_len
operator|=
name|rfa
operator|->
name|actual_size
operator|&
operator|(
name|MCLBYTES
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|total_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|rcvloop
goto|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|total_len
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_tap
argument_list|(
name|FXP_BPFTAP_ARG
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|do_bridge
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|bdg_ifp
decl_stmt|;
name|bdg_ifp
operator|=
name|bridge_in
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdg_ifp
operator|==
name|BDG_DROP
condition|)
goto|goto
name|dropit
goto|;
if|if
condition|(
name|bdg_ifp
operator|!=
name|BDG_LOCAL
condition|)
name|bdg_forward
argument_list|(
operator|&
name|m
argument_list|,
name|bdg_ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdg_ifp
operator|!=
name|BDG_LOCAL
operator|&&
name|bdg_ifp
operator|!=
name|BDG_BCAST
operator|&&
name|bdg_ifp
operator|!=
name|BDG_MCAST
condition|)
goto|goto
name|dropit
goto|;
goto|goto
name|getit
goto|;
block|}
endif|#
directive|endif
comment|/* 					 * Only pass this packet up 					 * if it is for us. 					 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|rfa
operator|->
name|rfa_status
operator|&
name|FXP_RFA_STATUS_IAMATCH
operator|)
operator|&&
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
name|dropit
label|:
endif|#
directive|endif
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|rcvloop
goto|;
block|}
ifdef|#
directive|ifdef
name|BRIDGE
name|getit
label|:
endif|#
directive|endif
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
goto|goto
name|rcvloop
goto|;
block|}
if|if
condition|(
name|statack
operator|&
name|FXP_SCB_STATACK_RNR
condition|)
block|{
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|rfa_headm
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
operator|+
name|RFA_ALIGNMENT_FUDGE
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|FXP_SCB_COMMAND_RU_START
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
return|return
operator|(
name|claimed
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Update packet in/out/collision statistics. The i82557 doesn't  * allow you to access these counters without doing a fairly  * expensive DMA to get _all_ of the statistics it maintains, so  * we do this operation here only once per second. The statistics  * counters in the kernel are updated from the previous dump-stats  * DMA and then a new dump-stats DMA is started. The on-chip  * counters are zeroed when the DMA completes. If we can't start  * the DMA immediately, we don't wait - we just prepare to read  * them again next time.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_stats_update
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|struct
name|fxp_stats
modifier|*
name|sp
init|=
name|sc
operator|->
name|fxp_stats
decl_stmt|;
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ifp
operator|->
name|if_opackets
operator|+=
name|sp
operator|->
name|tx_good
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
name|sp
operator|->
name|tx_total_collisions
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|rx_good
condition|)
block|{
name|ifp
operator|->
name|if_ipackets
operator|+=
name|sp
operator|->
name|rx_good
expr_stmt|;
name|sc
operator|->
name|rx_idle_secs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Receiver's been idle for another second. 		 */
name|sc
operator|->
name|rx_idle_secs
operator|++
expr_stmt|;
block|}
name|ifp
operator|->
name|if_ierrors
operator|+=
name|sp
operator|->
name|rx_crc_errors
operator|+
name|sp
operator|->
name|rx_alignment_errors
operator|+
name|sp
operator|->
name|rx_rnr_errors
operator|+
name|sp
operator|->
name|rx_overrun_errors
expr_stmt|;
comment|/* 	 * If any transmit underruns occured, bump up the transmit 	 * threshold by another 512 bytes (64 * 8). 	 */
if|if
condition|(
name|sp
operator|->
name|tx_underruns
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|+=
name|sp
operator|->
name|tx_underruns
expr_stmt|;
if|if
condition|(
name|tx_threshold
operator|<
literal|192
condition|)
name|tx_threshold
operator|+=
literal|64
expr_stmt|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Release any xmit buffers that have completed DMA. This isn't 	 * strictly necessary to do here, but it's advantagous for mbufs 	 * with external storage to be released in a timely manner rather 	 * than being defered for a potentially long time. This limits 	 * the delay to a maximum of one second. 	 */
for|for
control|(
name|txp
operator|=
name|sc
operator|->
name|cbl_first
init|;
name|sc
operator|->
name|tx_queued
operator|&&
operator|(
name|txp
operator|->
name|cb_status
operator|&
name|FXP_CB_STATUS_C
operator|)
operator|!=
literal|0
condition|;
name|txp
operator|=
name|txp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|txp
operator|->
name|mb_head
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txp
operator|->
name|mb_head
argument_list|)
expr_stmt|;
name|txp
operator|->
name|mb_head
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|tx_queued
operator|--
expr_stmt|;
block|}
name|sc
operator|->
name|cbl_first
operator|=
name|txp
expr_stmt|;
comment|/* 	 * If we haven't received any packets in FXP_MAC_RX_IDLE seconds, 	 * then assume the receiver has locked up and attempt to clear 	 * the condition by reprogramming the multicast filter. This is 	 * a work-around for a bug in the 82557 where the receiver locks 	 * up if it gets certain types of garbage in the syncronization 	 * bits prior to the packet header. This bug is supposed to only 	 * occur in 10Mbps mode, but has been seen to occur in 100Mbps 	 * mode as well (perhaps due to a 10/100 speed transition). 	 */
if|if
condition|(
name|sc
operator|->
name|rx_idle_secs
operator|>
name|FXP_MAX_RX_IDLE
condition|)
block|{
name|sc
operator|->
name|rx_idle_secs
operator|=
literal|0
expr_stmt|;
name|fxp_mc_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there is no pending command, start another stats 	 * dump. Otherwise punt for now. 	 */
if|if
condition|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Start another stats dump. 		 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|FXP_SCB_COMMAND_CU_DUMPRESET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * A previous command is still waiting to be accepted. 		 * Just zero our copy of the stats and wait for the 		 * next timer event to update them. 		 */
name|sp
operator|->
name|tx_good
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|tx_underruns
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|tx_total_collisions
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_good
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_crc_errors
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_alignment_errors
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_rnr_errors
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_overrun_errors
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule another timeout one second from now. 	 */
name|sc
operator|->
name|stat_ch
operator|=
name|timeout
argument_list|(
name|fxp_stats_update
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop the interface. Cancels the statistics updater and resets  * the interface.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Cancel stats updater. 	 */
name|untimeout
argument_list|(
name|fxp_stats_update
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|stat_ch
argument_list|)
expr_stmt|;
comment|/* 	 * Issue software reset 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_PORT
argument_list|,
name|FXP_PORT_SELECTIVE_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* 	 * Release any xmit buffers. 	 */
name|txp
operator|=
name|sc
operator|->
name|cbl_base
expr_stmt|;
if|if
condition|(
name|txp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NTXCB
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|txp
index|[
name|i
index|]
operator|.
name|mb_head
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txp
index|[
name|i
index|]
operator|.
name|mb_head
argument_list|)
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|mb_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|sc
operator|->
name|tx_queued
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Free all the receive buffers then reallocate/reinitialize 	 */
if|if
condition|(
name|sc
operator|->
name|rfa_headm
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|rfa_headm
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rfa_headm
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|rfa_tailm
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NRFABUFS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fxp_add_rfabuf
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * This "can't happen" - we're at splimp() 			 * and we just freed all the buffers we need 			 * above. 			 */
name|panic
argument_list|(
literal|"fxp_stop: no buffers!"
argument_list|)
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Watchdog/transmission transmit timeout handler. Called when a  * transmission is started on the interface, but no interrupt is  * received before the timeout. This usually indicates that the  * card has wedged for some reason.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_watchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|printf
argument_list|(
name|FXP_FORMAT
literal|": device timeout\n"
argument_list|,
name|FXP_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|fxp_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|struct
name|fxp_cb_config
modifier|*
name|cbp
decl_stmt|;
name|struct
name|fxp_cb_ias
modifier|*
name|cb_ias
decl_stmt|;
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|prm
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Cancel any pending I/O 	 */
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|prm
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 	 * Initialize base of CBL and RFA memory. Loading with zero 	 * sets it up for regular linear addressing. 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|FXP_SCB_COMMAND_CU_BASE
argument_list|)
expr_stmt|;
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|FXP_SCB_COMMAND_RU_BASE
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize base of dump-stats buffer. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|fxp_stats
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|FXP_SCB_COMMAND_CU_DUMP_ADR
argument_list|)
expr_stmt|;
comment|/* 	 * We temporarily use memory that contains the TxCB list to 	 * construct the config CB. The TxCB list memory is rebuilt 	 * later. 	 */
name|cbp
operator|=
operator|(
expr|struct
name|fxp_cb_config
operator|*
operator|)
name|sc
operator|->
name|cbl_base
expr_stmt|;
comment|/* 	 * This bcopy is kind of disgusting, but there are a bunch of must be 	 * zero and must be one bits in this structure and this is the easiest 	 * way to initialize them all to proper values. 	 */
name|bcopy
argument_list|(
name|fxp_cb_config_template
argument_list|,
operator|(
specifier|volatile
name|void
operator|*
operator|)
operator|&
name|cbp
operator|->
name|cb_status
argument_list|,
sizeof|sizeof
argument_list|(
name|fxp_cb_config_template
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_CONFIG
operator||
name|FXP_CB_COMMAND_EL
expr_stmt|;
name|cbp
operator|->
name|link_addr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* (no) next command */
name|cbp
operator|->
name|byte_count
operator|=
literal|22
expr_stmt|;
comment|/* (22) bytes to config */
name|cbp
operator|->
name|rx_fifo_limit
operator|=
literal|8
expr_stmt|;
comment|/* rx fifo threshold (32 bytes) */
name|cbp
operator|->
name|tx_fifo_limit
operator|=
literal|0
expr_stmt|;
comment|/* tx fifo threshold (0 bytes) */
name|cbp
operator|->
name|adaptive_ifs
operator|=
literal|0
expr_stmt|;
comment|/* (no) adaptive interframe spacing */
name|cbp
operator|->
name|rx_dma_bytecount
operator|=
literal|0
expr_stmt|;
comment|/* (no) rx DMA max */
name|cbp
operator|->
name|tx_dma_bytecount
operator|=
literal|0
expr_stmt|;
comment|/* (no) tx DMA max */
name|cbp
operator|->
name|dma_bce
operator|=
literal|0
expr_stmt|;
comment|/* (disable) dma max counters */
name|cbp
operator|->
name|late_scb
operator|=
literal|0
expr_stmt|;
comment|/* (don't) defer SCB update */
name|cbp
operator|->
name|tno_int
operator|=
literal|0
expr_stmt|;
comment|/* (disable) tx not okay interrupt */
name|cbp
operator|->
name|ci_int
operator|=
literal|1
expr_stmt|;
comment|/* interrupt on CU idle */
name|cbp
operator|->
name|save_bf
operator|=
name|prm
expr_stmt|;
comment|/* save bad frames */
name|cbp
operator|->
name|disc_short_rx
operator|=
operator|!
name|prm
expr_stmt|;
comment|/* discard short packets */
name|cbp
operator|->
name|underrun_retry
operator|=
literal|1
expr_stmt|;
comment|/* retry mode (1) on DMA underrun */
name|cbp
operator|->
name|mediatype
operator|=
operator|!
name|sc
operator|->
name|phy_10Mbps_only
expr_stmt|;
comment|/* interface mode */
name|cbp
operator|->
name|nsai
operator|=
literal|1
expr_stmt|;
comment|/* (don't) disable source addr insert */
name|cbp
operator|->
name|preamble_length
operator|=
literal|2
expr_stmt|;
comment|/* (7 byte) preamble */
name|cbp
operator|->
name|loopback
operator|=
literal|0
expr_stmt|;
comment|/* (don't) loopback */
name|cbp
operator|->
name|linear_priority
operator|=
literal|0
expr_stmt|;
comment|/* (normal CSMA/CD operation) */
name|cbp
operator|->
name|linear_pri_mode
operator|=
literal|0
expr_stmt|;
comment|/* (wait after xmit only) */
name|cbp
operator|->
name|interfrm_spacing
operator|=
literal|6
expr_stmt|;
comment|/* (96 bits of) interframe spacing */
name|cbp
operator|->
name|promiscuous
operator|=
name|prm
expr_stmt|;
comment|/* promiscuous mode */
name|cbp
operator|->
name|bcast_disable
operator|=
literal|0
expr_stmt|;
comment|/* (don't) disable broadcasts */
name|cbp
operator|->
name|crscdt
operator|=
literal|0
expr_stmt|;
comment|/* (CRS only) */
name|cbp
operator|->
name|stripping
operator|=
operator|!
name|prm
expr_stmt|;
comment|/* truncate rx packet to byte count */
name|cbp
operator|->
name|padding
operator|=
literal|1
expr_stmt|;
comment|/* (do) pad short tx packets */
name|cbp
operator|->
name|rcv_crc_xfer
operator|=
literal|0
expr_stmt|;
comment|/* (don't) xfer CRC to host */
name|cbp
operator|->
name|force_fdx
operator|=
literal|0
expr_stmt|;
comment|/* (don't) force full duplex */
name|cbp
operator|->
name|fdx_pin_en
operator|=
literal|1
expr_stmt|;
comment|/* (enable) FDX# pin */
name|cbp
operator|->
name|multi_ia
operator|=
literal|0
expr_stmt|;
comment|/* (don't) accept multiple IAs */
name|cbp
operator|->
name|mc_all
operator|=
name|sc
operator|->
name|all_mcasts
expr_stmt|;
comment|/* accept all multicasts */
comment|/* 	 * Start the config command/DMA. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|vtophys
argument_list|(
operator|&
name|cbp
operator|->
name|cb_status
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|FXP_SCB_COMMAND_CU_START
argument_list|)
expr_stmt|;
comment|/* ...and wait for it to complete. */
while|while
condition|(
operator|!
operator|(
name|cbp
operator|->
name|cb_status
operator|&
name|FXP_CB_STATUS_C
operator|)
condition|)
empty_stmt|;
comment|/* 	 * Now initialize the station address. Temporarily use the TxCB 	 * memory area like we did above for the config CB. 	 */
name|cb_ias
operator|=
operator|(
expr|struct
name|fxp_cb_ias
operator|*
operator|)
name|sc
operator|->
name|cbl_base
expr_stmt|;
name|cb_ias
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|cb_ias
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_IAS
operator||
name|FXP_CB_COMMAND_EL
expr_stmt|;
name|cb_ias
operator|->
name|link_addr
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
name|ifp
operator|->
name|if_sadl
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cb_ias
operator|->
name|macaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|#
directive|else
name|bcopy
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|cb_ias
operator|->
name|macaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __NetBSD__ */
comment|/* 	 * Start the IAS (Individual Address Setup) command/DMA. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|FXP_SCB_COMMAND_CU_START
argument_list|)
expr_stmt|;
comment|/* ...and wait for it to complete. */
while|while
condition|(
operator|!
operator|(
name|cb_ias
operator|->
name|cb_status
operator|&
name|FXP_CB_STATUS_C
operator|)
condition|)
empty_stmt|;
comment|/* 	 * Initialize transmit control block (TxCB) list. 	 */
name|txp
operator|=
name|sc
operator|->
name|cbl_base
expr_stmt|;
name|bzero
argument_list|(
name|txp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_cb_tx
argument_list|)
operator|*
name|FXP_NTXCB
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NTXCB
condition|;
name|i
operator|++
control|)
block|{
name|txp
index|[
name|i
index|]
operator|.
name|cb_status
operator|=
name|FXP_CB_STATUS_C
operator||
name|FXP_CB_STATUS_OK
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|cb_command
operator|=
name|FXP_CB_COMMAND_NOP
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|link_addr
operator|=
name|vtophys
argument_list|(
operator|&
name|txp
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|FXP_TXCB_MASK
index|]
operator|.
name|cb_status
argument_list|)
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|tbd_array_addr
operator|=
name|vtophys
argument_list|(
operator|&
name|txp
index|[
name|i
index|]
operator|.
name|tbd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|&
name|txp
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|FXP_TXCB_MASK
index|]
expr_stmt|;
block|}
comment|/* 	 * Set the suspend flag on the first TxCB and start the control 	 * unit. It will execute the NOP and then suspend. 	 */
name|txp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_NOP
operator||
name|FXP_CB_COMMAND_S
expr_stmt|;
name|sc
operator|->
name|cbl_first
operator|=
name|sc
operator|->
name|cbl_last
operator|=
name|txp
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|=
literal|1
expr_stmt|;
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|FXP_SCB_COMMAND_CU_START
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize receiver buffer area - RFA. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|rfa_headm
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
operator|+
name|RFA_ALIGNMENT_FUDGE
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|FXP_SCB_COMMAND_RU_START
argument_list|)
expr_stmt|;
comment|/* 	 * Set current media. 	 */
name|fxp_set_media
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Start stats updater. 	 */
name|sc
operator|->
name|stat_ch
operator|=
name|timeout
argument_list|(
name|fxp_stats_update
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_set_media
parameter_list|(
name|sc
parameter_list|,
name|media
parameter_list|)
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|media
decl_stmt|;
block|{
switch|switch
condition|(
name|sc
operator|->
name|phy_primary_device
condition|)
block|{
case|case
name|FXP_PHY_DP83840
case|:
case|case
name|FXP_PHY_DP83840A
case|:
name|fxp_mdi_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|phy_primary_addr
argument_list|,
name|FXP_DP83840_PCR
argument_list|,
name|fxp_mdi_read
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|phy_primary_addr
argument_list|,
name|FXP_DP83840_PCR
argument_list|)
operator||
name|FXP_DP83840_PCR_LED4_MODE
operator||
comment|/* LED4 always indicates duplex */
name|FXP_DP83840_PCR_F_CONNECT
operator||
comment|/* force link disconnect bypass */
name|FXP_DP83840_PCR_BIT10
argument_list|)
expr_stmt|;
comment|/* XXX I have no idea */
comment|/* fall through */
case|case
name|FXP_PHY_82553A
case|:
case|case
name|FXP_PHY_82553C
case|:
comment|/* untested */
case|case
name|FXP_PHY_82555
case|:
case|case
name|FXP_PHY_82555B
case|:
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|!=
name|IFM_AUTO
condition|)
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
operator|(
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|==
name|IFM_100_TX
operator|)
condition|?
name|FXP_PHY_BMCR_SPEED_100M
else|:
literal|0
expr_stmt|;
name|flags
operator||=
operator|(
name|media
operator|&
name|IFM_FDX
operator|)
condition|?
name|FXP_PHY_BMCR_FULLDUPLEX
else|:
literal|0
expr_stmt|;
name|fxp_mdi_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|phy_primary_addr
argument_list|,
name|FXP_PHY_BMCR
argument_list|,
operator|(
name|fxp_mdi_read
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|phy_primary_addr
argument_list|,
name|FXP_PHY_BMCR
argument_list|)
operator|&
operator|~
operator|(
name|FXP_PHY_BMCR_AUTOEN
operator||
name|FXP_PHY_BMCR_SPEED_100M
operator||
name|FXP_PHY_BMCR_FULLDUPLEX
operator|)
operator|)
operator||
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fxp_mdi_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|phy_primary_addr
argument_list|,
name|FXP_PHY_BMCR
argument_list|,
operator|(
name|fxp_mdi_read
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|phy_primary_addr
argument_list|,
name|FXP_PHY_BMCR
argument_list|)
operator||
name|FXP_PHY_BMCR_AUTOEN
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * The Seeq 80c24 doesn't have a PHY programming interface, so do 	 * nothing. 	 */
case|case
name|FXP_PHY_80C24
case|:
break|break;
default|default:
name|printf
argument_list|(
name|FXP_FORMAT
literal|": warning: unsupported PHY, type = %d, addr = %d\n"
argument_list|,
name|FXP_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sc
operator|->
name|phy_primary_device
argument_list|,
name|sc
operator|->
name|phy_primary_addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Change media according to request.  */
end_comment

begin_function
name|int
name|fxp_mediachange
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|sc
operator|->
name|sc_media
decl_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|fxp_set_media
argument_list|(
name|sc
argument_list|,
name|ifm
operator|->
name|ifm_media
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Notify the world which media we're using.  */
end_comment

begin_function
name|void
name|fxp_mediastatus
parameter_list|(
name|ifp
parameter_list|,
name|ifmr
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmediareq
modifier|*
name|ifmr
decl_stmt|;
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|stsflags
decl_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|phy_primary_device
condition|)
block|{
case|case
name|FXP_PHY_82555
case|:
case|case
name|FXP_PHY_82555B
case|:
case|case
name|FXP_PHY_DP83840
case|:
case|case
name|FXP_PHY_DP83840A
case|:
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
comment|/* IFM_ACTIVE will be valid */
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
comment|/* 		 * the following is not an error. 		 * You need to read this register twice to get current 		 * status. This is correct documented behaviour, the 		 * first read gets latched values. 		 */
name|stsflags
operator|=
name|fxp_mdi_read
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|phy_primary_addr
argument_list|,
name|FXP_PHY_STS
argument_list|)
expr_stmt|;
name|stsflags
operator|=
name|fxp_mdi_read
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|phy_primary_addr
argument_list|,
name|FXP_PHY_STS
argument_list|)
expr_stmt|;
if|if
condition|(
name|stsflags
operator|&
name|FXP_PHY_STS_LINK_STS
condition|)
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
comment|/*  		 * If we are in auto mode, then try report the result. 		 */
name|flags
operator|=
name|fxp_mdi_read
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|phy_primary_addr
argument_list|,
name|FXP_PHY_BMCR
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FXP_PHY_BMCR_AUTOEN
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_AUTO
expr_stmt|;
comment|/* XXX presently 0 */
if|if
condition|(
name|stsflags
operator|&
name|FXP_PHY_STS_AUTO_DONE
condition|)
block|{
comment|/* 				 * Intel and National parts report 				 * differently on what they found. 				 */
if|if
condition|(
operator|(
name|sc
operator|->
name|phy_primary_device
operator|==
name|FXP_PHY_82555
operator|)
operator|||
operator|(
name|sc
operator|->
name|phy_primary_device
operator|==
name|FXP_PHY_82555B
operator|)
condition|)
block|{
name|flags
operator|=
name|fxp_mdi_read
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|phy_primary_addr
argument_list|,
name|FXP_PHY_USC
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FXP_PHY_USC_SPEED
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FXP_PHY_USC_DUPLEX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
block|}
else|else
block|{
comment|/* it's National. only know speed  */
name|flags
operator|=
name|fxp_mdi_read
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|phy_primary_addr
argument_list|,
name|FXP_DP83840_PAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FXP_DP83840_PAR_SPEED_10
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* in manual mode.. just report what we were set to */
if|if
condition|(
name|flags
operator|&
name|FXP_PHY_BMCR_SPEED_100M
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FXP_PHY_BMCR_FULLDUPLEX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
block|}
break|break;
case|case
name|FXP_PHY_80C24
case|:
default|default:
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_MANUAL
expr_stmt|;
comment|/* XXX IFM_AUTO ? */
block|}
block|}
end_function

begin_comment
comment|/*  * Add a buffer to the end of the RFA buffer list.  * Return 0 if successful, 1 for failure. A failure results in  * adding the 'oldm' (if non-NULL) on to the end of the list -  * tossing out its old contents and recycling it.  * The RFA struct is stuck at the beginning of mbuf cluster and the  * data pointer is fixed up to point just past it.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_add_rfabuf
parameter_list|(
name|sc
parameter_list|,
name|oldm
parameter_list|)
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|oldm
decl_stmt|;
block|{
name|u_int32_t
name|v
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|fxp_rfa
modifier|*
name|rfa
decl_stmt|,
modifier|*
name|p_rfa
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldm
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|m
operator|=
name|oldm
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|oldm
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|m
operator|=
name|oldm
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
block|}
comment|/* 	 * Move the data pointer up so that the incoming data packet 	 * will be 32-bit aligned. 	 */
name|m
operator|->
name|m_data
operator|+=
name|RFA_ALIGNMENT_FUDGE
expr_stmt|;
comment|/* 	 * Get a pointer to the base of the mbuf cluster and move 	 * data start past it. 	 */
name|rfa
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|fxp_rfa
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_rfa
argument_list|)
expr_stmt|;
name|rfa
operator|->
name|size
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|MCLBYTES
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_rfa
argument_list|)
operator|-
name|RFA_ALIGNMENT_FUDGE
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the rest of the RFA.  Note that since the RFA 	 * is misaligned, we cannot store values directly.  Instead, 	 * we use an optimized, inline copy. 	 */
name|rfa
operator|->
name|rfa_status
operator|=
literal|0
expr_stmt|;
name|rfa
operator|->
name|rfa_control
operator|=
name|FXP_RFA_CONTROL_EL
expr_stmt|;
name|rfa
operator|->
name|actual_size
operator|=
literal|0
expr_stmt|;
name|v
operator|=
operator|-
literal|1
expr_stmt|;
name|fxp_lwcopy
argument_list|(
operator|&
name|v
argument_list|,
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|rfa
operator|->
name|link_addr
argument_list|)
expr_stmt|;
name|fxp_lwcopy
argument_list|(
operator|&
name|v
argument_list|,
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|rfa
operator|->
name|rbd_addr
argument_list|)
expr_stmt|;
comment|/* 	 * If there are other buffers already on the list, attach this 	 * one to the end by fixing up the tail to point to this one. 	 */
if|if
condition|(
name|sc
operator|->
name|rfa_headm
operator|!=
name|NULL
condition|)
block|{
name|p_rfa
operator|=
operator|(
expr|struct
name|fxp_rfa
operator|*
operator|)
operator|(
name|sc
operator|->
name|rfa_tailm
operator|->
name|m_ext
operator|.
name|ext_buf
operator|+
name|RFA_ALIGNMENT_FUDGE
operator|)
expr_stmt|;
name|sc
operator|->
name|rfa_tailm
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|v
operator|=
name|vtophys
argument_list|(
name|rfa
argument_list|)
expr_stmt|;
name|fxp_lwcopy
argument_list|(
operator|&
name|v
argument_list|,
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|p_rfa
operator|->
name|link_addr
argument_list|)
expr_stmt|;
name|p_rfa
operator|->
name|rfa_control
operator|&=
operator|~
name|FXP_RFA_CONTROL_EL
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|rfa_headm
operator|=
name|m
expr_stmt|;
block|}
name|sc
operator|->
name|rfa_tailm
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|m
operator|==
name|oldm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|volatile
name|int
name|fxp_mdi_read
parameter_list|(
name|sc
parameter_list|,
name|phy
parameter_list|,
name|reg
parameter_list|)
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|phy
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
name|int
name|count
init|=
literal|10000
decl_stmt|;
name|int
name|value
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_MDICONTROL
argument_list|,
operator|(
name|FXP_MDI_READ
operator|<<
literal|26
operator|)
operator||
operator|(
name|reg
operator|<<
literal|16
operator|)
operator||
operator|(
name|phy
operator|<<
literal|21
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|value
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_MDICONTROL
argument_list|)
operator|)
operator|&
literal|0x10000000
operator|)
operator|==
literal|0
operator|&&
name|count
operator|--
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|printf
argument_list|(
name|FXP_FORMAT
literal|": fxp_mdi_read: timed out\n"
argument_list|,
name|FXP_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|&
literal|0xffff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_mdi_write
parameter_list|(
name|sc
parameter_list|,
name|phy
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|)
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|phy
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
name|int
name|count
init|=
literal|10000
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_MDICONTROL
argument_list|,
operator|(
name|FXP_MDI_WRITE
operator|<<
literal|26
operator|)
operator||
operator|(
name|reg
operator|<<
literal|16
operator|)
operator||
operator|(
name|phy
operator|<<
literal|21
operator|)
operator||
operator|(
name|value
operator|&
literal|0xffff
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_MDICONTROL
argument_list|)
operator|&
literal|0x10000000
operator|)
operator|==
literal|0
operator|&&
name|count
operator|--
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|printf
argument_list|(
name|FXP_FORMAT
literal|": fxp_mdi_write: timed out\n"
argument_list|,
name|FXP_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fxp_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|FXP_IOCTLCMD_TYPE
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
endif|#
directive|endif
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|sc
operator|->
name|all_mcasts
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 		 * If interface is marked up and not running, then start it. 		 * If it is marked down and running, stop it. 		 * XXX If it's up then re-initialize it. This is so flags 		 * such as IFF_PROMISC are handled. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|fxp_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|sc
operator|->
name|all_mcasts
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|error
operator|=
operator|(
name|command
operator|==
name|SIOCADDMULTI
operator|)
condition|?
name|ether_addmulti
argument_list|(
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_ethercom
argument_list|)
else|:
name|ether_delmulti
argument_list|(
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_ethercom
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
comment|/* 			 * Multicast list has changed; set the hardware 			 * filter accordingly. 			 */
if|if
condition|(
operator|!
name|sc
operator|->
name|all_mcasts
condition|)
name|fxp_mc_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 			 * fxp_mc_setup() can turn on all_mcasts if we run 			 * out of space, so check it again rather than else {}. 			 */
if|if
condition|(
name|sc
operator|->
name|all_mcasts
condition|)
name|fxp_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* __FreeBSD__ */
comment|/* 		 * Multicast list has changed; set the hardware filter 		 * accordingly. 		 */
if|if
condition|(
operator|!
name|sc
operator|->
name|all_mcasts
condition|)
name|fxp_mc_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * fxp_mc_setup() can turn on sc->all_mcasts, so check it 		 * again rather than else {}. 		 */
if|if
condition|(
name|sc
operator|->
name|all_mcasts
condition|)
name|fxp_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* __NetBSD__ */
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Program the multicast filter.  *  * We have an artificial restriction that the multicast setup command  * must be the first command in the chain, so we take steps to ensure  * this. By requiring this, it allows us to keep up the performance of  * the pre-initialized command ring (esp. link pointers) by not actually  * inserting the mcsetup command in the ring - i.e. its link pointer  * points to the TxCB ring, but the mcsetup descriptor itself is not part  * of it. We then can do 'CU_START' on the mcsetup descriptor and have it  * lead into the regular TxCB ring when it completes.  *  * This function must be called at splimp.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_mc_setup
parameter_list|(
name|sc
parameter_list|)
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|fxp_cb_mcs
modifier|*
name|mcsp
init|=
name|sc
operator|->
name|mcsp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|int
name|nmcasts
decl_stmt|;
comment|/* 	 * If there are queued commands, we must wait until they are all 	 * completed. If we are already waiting, then add a NOP command 	 * with interrupt option so that we're notified when all commands 	 * have been completed - fxp_start() ensures that no additional 	 * TX commands will be added when need_mcsetup is true. 	 */
if|if
condition|(
name|sc
operator|->
name|tx_queued
condition|)
block|{
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
comment|/* 		 * need_mcsetup will be true if we are already waiting for the 		 * NOP command to be completed (see below). In this case, bail. 		 */
if|if
condition|(
name|sc
operator|->
name|need_mcsetup
condition|)
return|return;
name|sc
operator|->
name|need_mcsetup
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Add a NOP command with interrupt so that we are notified when all 		 * TX commands have been processed. 		 */
name|txp
operator|=
name|sc
operator|->
name|cbl_last
operator|->
name|next
expr_stmt|;
name|txp
operator|->
name|mb_head
operator|=
name|NULL
expr_stmt|;
name|txp
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|txp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_NOP
operator||
name|FXP_CB_COMMAND_S
operator||
name|FXP_CB_COMMAND_I
expr_stmt|;
comment|/* 		 * Advance the end of list forward. 		 */
name|sc
operator|->
name|cbl_last
operator|->
name|cb_command
operator|&=
operator|~
name|FXP_CB_COMMAND_S
expr_stmt|;
name|sc
operator|->
name|cbl_last
operator|=
name|txp
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|++
expr_stmt|;
comment|/* 		 * Issue a resume in case the CU has just suspended. 		 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|FXP_SCB_COMMAND_CU_RESUME
argument_list|)
expr_stmt|;
comment|/* 		 * Set a 5 second timer just in case we don't hear from the 		 * card again. 		 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|need_mcsetup
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize multicast setup descriptor. 	 */
name|mcsp
operator|->
name|next
operator|=
name|sc
operator|->
name|cbl_base
expr_stmt|;
name|mcsp
operator|->
name|mb_head
operator|=
name|NULL
expr_stmt|;
name|mcsp
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|mcsp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_MCAS
operator||
name|FXP_CB_COMMAND_S
operator||
name|FXP_CB_COMMAND_I
expr_stmt|;
name|mcsp
operator|->
name|link_addr
operator|=
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|cbl_base
operator|->
name|cb_status
argument_list|)
expr_stmt|;
name|nmcasts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|all_mcasts
condition|)
block|{
for|for
control|(
name|ifma
operator|=
name|ifp
operator|->
name|if_multiaddrs
operator|.
name|lh_first
init|;
name|ifma
operator|!=
name|NULL
condition|;
name|ifma
operator|=
name|ifma
operator|->
name|ifma_link
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|nmcasts
operator|>=
name|MAXMCADDR
condition|)
block|{
name|sc
operator|->
name|all_mcasts
operator|=
literal|1
expr_stmt|;
name|nmcasts
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|(
specifier|volatile
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|mcsp
operator|->
name|mc_addr
index|[
name|nmcasts
index|]
index|[
literal|0
index|]
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|nmcasts
operator|++
expr_stmt|;
block|}
block|}
name|mcsp
operator|->
name|mc_cnt
operator|=
name|nmcasts
operator|*
literal|6
expr_stmt|;
name|sc
operator|->
name|cbl_first
operator|=
name|sc
operator|->
name|cbl_last
operator|=
operator|(
expr|struct
name|fxp_cb_tx
operator|*
operator|)
name|mcsp
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Wait until command unit is not active. This should never 	 * be the case when nothing is queued, but make sure anyway. 	 */
while|while
condition|(
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_RUSCUS
argument_list|)
operator|>>
literal|6
operator|)
operator|==
name|FXP_SCB_CUS_ACTIVE
condition|)
empty_stmt|;
comment|/* 	 * Start the multicast setup command. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|vtophys
argument_list|(
operator|&
name|mcsp
operator|->
name|cb_status
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|FXP_SCB_COMMAND_CU_START
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
return|return;
block|}
end_function

end_unit

