begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1995, David Greenman  * Copyright (c) 2001 Jonathan Lemon<jlemon@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Intel EtherExpress Pro/100B PCI Fast Ethernet driver  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_comment
comment|/* #include<sys/mutex.h> */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FXP_IP_CSUM_WAR
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_comment
comment|/* for PCIM_CMD_xxx */
end_comment

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/fxp/if_fxpreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fxp/if_fxpvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/fxp/rcvbundl.h>
end_include

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fxp
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fxp
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fxp
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_comment
comment|/*  * NOTE!  On the Alpha, we have an alignment constraint.  The  * card DMAs the packet immediately following the RFA.  However,  * the first thing in the packet is a 14-byte Ethernet header.  * This means that the packet is misaligned.  To compensate,  * we actually offset the RFA 2 bytes into the cluster.  This  * alignes the packet after the Ethernet header at a 32-bit  * boundary.  HOWEVER!  This means that the RFA is misaligned!  */
end_comment

begin_define
define|#
directive|define
name|RFA_ALIGNMENT_FUDGE
value|2
end_define

begin_comment
comment|/*  * Set initial transmit threshold at 64 (512 bytes). This is  * increased by 64 (512 bytes) at a time, to maximum of 192  * (1536 bytes), if an underrun occurs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tx_threshold
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The configuration byte map has several undefined fields which  * must be one or must be zero.  Set up a template for these bits  * only, (assuming a 82557 chip) leaving the actual configuration  * to fxp_init.  *  * See struct fxp_cb_config for the bit definitions.  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|fxp_cb_config_template
index|[]
init|=
block|{
literal|0x0
block|,
literal|0x0
block|,
comment|/* cb_status */
literal|0x0
block|,
literal|0x0
block|,
comment|/* cb_command */
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
comment|/* link_addr */
literal|0x0
block|,
comment|/*  0 */
literal|0x0
block|,
comment|/*  1 */
literal|0x0
block|,
comment|/*  2 */
literal|0x0
block|,
comment|/*  3 */
literal|0x0
block|,
comment|/*  4 */
literal|0x0
block|,
comment|/*  5 */
literal|0x32
block|,
comment|/*  6 */
literal|0x0
block|,
comment|/*  7 */
literal|0x0
block|,
comment|/*  8 */
literal|0x0
block|,
comment|/*  9 */
literal|0x6
block|,
comment|/* 10 */
literal|0x0
block|,
comment|/* 11 */
literal|0x0
block|,
comment|/* 12 */
literal|0x0
block|,
comment|/* 13 */
literal|0xf2
block|,
comment|/* 14 */
literal|0x48
block|,
comment|/* 15 */
literal|0x0
block|,
comment|/* 16 */
literal|0x40
block|,
comment|/* 17 */
literal|0xf0
block|,
comment|/* 18 */
literal|0x0
block|,
comment|/* 19 */
literal|0x3f
block|,
comment|/* 20 */
literal|0x5
comment|/* 21 */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|fxp_ident
block|{
name|uint16_t
name|devid
decl_stmt|;
name|int16_t
name|revid
decl_stmt|;
comment|/* -1 matches anything */
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Claim various Intel PCI device identifiers for this driver.  The  * sub-vendor and sub-device field are extensively used to identify  * particular variants, but we don't currently differentiate between  * them.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fxp_ident
name|fxp_ident_table
index|[]
init|=
block|{
block|{
literal|0x1029
block|,
operator|-
literal|1
block|,
literal|"Intel 82559 PCI/CardBus Pro/100"
block|}
block|,
block|{
literal|0x1030
block|,
operator|-
literal|1
block|,
literal|"Intel 82559 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1031
block|,
operator|-
literal|1
block|,
literal|"Intel 82801CAM (ICH3) Pro/100 VE Ethernet"
block|}
block|,
block|{
literal|0x1032
block|,
operator|-
literal|1
block|,
literal|"Intel 82801CAM (ICH3) Pro/100 VE Ethernet"
block|}
block|,
block|{
literal|0x1033
block|,
operator|-
literal|1
block|,
literal|"Intel 82801CAM (ICH3) Pro/100 VM Ethernet"
block|}
block|,
block|{
literal|0x1034
block|,
operator|-
literal|1
block|,
literal|"Intel 82801CAM (ICH3) Pro/100 VM Ethernet"
block|}
block|,
block|{
literal|0x1035
block|,
operator|-
literal|1
block|,
literal|"Intel 82801CAM (ICH3) Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1036
block|,
operator|-
literal|1
block|,
literal|"Intel 82801CAM (ICH3) Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1037
block|,
operator|-
literal|1
block|,
literal|"Intel 82801CAM (ICH3) Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1038
block|,
operator|-
literal|1
block|,
literal|"Intel 82801CAM (ICH3) Pro/100 VM Ethernet"
block|}
block|,
block|{
literal|0x1039
block|,
operator|-
literal|1
block|,
literal|"Intel 82801DB (ICH4) Pro/100 VE Ethernet"
block|}
block|,
block|{
literal|0x103A
block|,
operator|-
literal|1
block|,
literal|"Intel 82801DB (ICH4) Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x103B
block|,
operator|-
literal|1
block|,
literal|"Intel 82801DB (ICH4) Pro/100 VM Ethernet"
block|}
block|,
block|{
literal|0x103C
block|,
operator|-
literal|1
block|,
literal|"Intel 82801DB (ICH4) Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x103D
block|,
operator|-
literal|1
block|,
literal|"Intel 82801DB (ICH4) Pro/100 VE Ethernet"
block|}
block|,
block|{
literal|0x103E
block|,
operator|-
literal|1
block|,
literal|"Intel 82801DB (ICH4) Pro/100 VM Ethernet"
block|}
block|,
block|{
literal|0x1050
block|,
operator|-
literal|1
block|,
literal|"Intel 82801BA (D865) Pro/100 VE Ethernet"
block|}
block|,
block|{
literal|0x1051
block|,
operator|-
literal|1
block|,
literal|"Intel 82562ET (ICH5/ICH5R) Pro/100 VE Ethernet"
block|}
block|,
block|{
literal|0x1059
block|,
operator|-
literal|1
block|,
literal|"Intel 82551QM Pro/100 M Mobile Connection"
block|}
block|,
block|{
literal|0x1064
block|,
operator|-
literal|1
block|,
literal|"Intel 82562EZ (ICH6)"
block|}
block|,
block|{
literal|0x1065
block|,
operator|-
literal|1
block|,
literal|"Intel 82562ET/EZ/GT/GZ PRO/100 VE Ethernet"
block|}
block|,
block|{
literal|0x1068
block|,
operator|-
literal|1
block|,
literal|"Intel 82801FBM (ICH6-M) Pro/100 VE Ethernet"
block|}
block|,
block|{
literal|0x1069
block|,
operator|-
literal|1
block|,
literal|"Intel 82562EM/EX/GX Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1092
block|,
operator|-
literal|1
block|,
literal|"Intel Pro/100 VE Network Connection"
block|}
block|,
block|{
literal|0x1094
block|,
operator|-
literal|1
block|,
literal|"Intel Pro/100 946GZ (ICH7) Network Connection"
block|}
block|,
block|{
literal|0x1209
block|,
operator|-
literal|1
block|,
literal|"Intel 82559ER Embedded 10/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
literal|0x01
block|,
literal|"Intel 82557 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
literal|0x02
block|,
literal|"Intel 82557 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
literal|0x03
block|,
literal|"Intel 82557 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
literal|0x04
block|,
literal|"Intel 82558 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
literal|0x05
block|,
literal|"Intel 82558 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
literal|0x06
block|,
literal|"Intel 82559 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
literal|0x07
block|,
literal|"Intel 82559 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
literal|0x08
block|,
literal|"Intel 82559 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
literal|0x09
block|,
literal|"Intel 82559ER Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
literal|0x0c
block|,
literal|"Intel 82550 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
literal|0x0d
block|,
literal|"Intel 82550 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
literal|0x0e
block|,
literal|"Intel 82550 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
literal|0x0f
block|,
literal|"Intel 82551 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
literal|0x10
block|,
literal|"Intel 82551 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x1229
block|,
operator|-
literal|1
block|,
literal|"Intel 82557/8/9 Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x2449
block|,
operator|-
literal|1
block|,
literal|"Intel 82801BA/CAM (ICH2/3) Pro/100 Ethernet"
block|}
block|,
block|{
literal|0x27dc
block|,
operator|-
literal|1
block|,
literal|"Intel 82801GB (ICH7) 10/100 Ethernet"
block|}
block|,
block|{
literal|0
block|,
operator|-
literal|1
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FXP_IP_CSUM_WAR
end_ifdef

begin_define
define|#
directive|define
name|FXP_CSUM_FEATURES
value|(CSUM_IP | CSUM_TCP | CSUM_UDP)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FXP_CSUM_FEATURES
value|(CSUM_TCP | CSUM_UDP)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|fxp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_intr_body
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint8_t
name|statack
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_init_body
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_start_body
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_encap
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_stop
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_release
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_add_rfabuf
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|fxp_rx
modifier|*
name|rxp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_mc_addrs
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_mc_setup
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|fxp_eeprom_getword
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|autosize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_eeprom_putword
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|uint16_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_autosize_eeprom
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_read_eeprom
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|u_short
modifier|*
name|data
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|words
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_write_eeprom
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|u_short
modifier|*
name|data
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|words
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fxp_serial_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_serial_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|volatile
name|int
name|fxp_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_load_ucode
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_int_range
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|,
name|int
name|low
parameter_list|,
name|int
name|high
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_fxp_bundle_max
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_fxp_int_delay
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_scb_wait
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_scb_cmd
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxp_dma_wait
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
specifier|volatile
name|uint16_t
modifier|*
name|status
parameter_list|,
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|fxp_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fxp_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fxp_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fxp_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|fxp_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|fxp_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|fxp_resume
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|fxp_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|fxp_miibus_writereg
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fxp_driver
init|=
block|{
literal|"fxp"
block|,
name|fxp_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|fxp_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|fxp
argument_list|,
name|pci
argument_list|,
name|fxp_driver
argument_list|,
name|fxp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|fxp
argument_list|,
name|cardbus
argument_list|,
name|fxp_driver
argument_list|,
name|fxp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|fxp
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Wait for the previous command to be accepted (but not necessarily  * completed).  */
end_comment

begin_function
specifier|static
name|void
name|fxp_scb_wait
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
union|union
block|{
name|uint16_t
name|w
decl_stmt|;
name|uint8_t
name|b
index|[
literal|2
index|]
decl_stmt|;
block|}
name|flowctl
union|;
name|int
name|i
init|=
literal|10000
decl_stmt|;
while|while
condition|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|)
operator|&&
operator|--
name|i
condition|)
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|flowctl
operator|.
name|b
index|[
literal|0
index|]
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_FLOWCONTROL
argument_list|)
expr_stmt|;
name|flowctl
operator|.
name|b
index|[
literal|1
index|]
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_FLOWCONTROL
operator|+
literal|1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"SCB timeout: 0x%x 0x%x 0x%x 0x%x\n"
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|)
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_STATACK
argument_list|)
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_RUSCUS
argument_list|)
argument_list|,
name|flowctl
operator|.
name|w
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_scb_cmd
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|==
name|FXP_SCB_COMMAND_CU_RESUME
operator|&&
name|sc
operator|->
name|cu_resume_bug
condition|)
block|{
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|FXP_CB_COMMAND_NOP
argument_list|)
expr_stmt|;
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_dma_wait
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
specifier|volatile
name|uint16_t
modifier|*
name|status
parameter_list|,
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|)
block|{
name|int
name|i
init|=
literal|10000
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|le16toh
argument_list|(
operator|*
name|status
argument_list|)
operator|&
name|FXP_CB_STATUS_C
operator|)
operator|&&
operator|--
name|i
condition|)
block|{
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"DMA timeout\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return identification string if this device is ours.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint16_t
name|devid
decl_stmt|;
name|uint8_t
name|revid
decl_stmt|;
name|struct
name|fxp_ident
modifier|*
name|ident
decl_stmt|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|FXP_VENDORID_INTEL
condition|)
block|{
name|devid
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|revid
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|ident
operator|=
name|fxp_ident_table
init|;
name|ident
operator|->
name|name
operator|!=
name|NULL
condition|;
name|ident
operator|++
control|)
block|{
if|if
condition|(
name|ident
operator|->
name|devid
operator|==
name|devid
operator|&&
operator|(
name|ident
operator|->
name|revid
operator|==
name|revid
operator|||
name|ident
operator|->
name|revid
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|ident
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_dma_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|uint32_t
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"too many DMA segments, %d should be 1"
operator|,
name|nseg
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fxp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|fxp_cb_tx
modifier|*
name|tcbp
decl_stmt|;
name|struct
name|fxp_tx
modifier|*
name|txp
decl_stmt|;
name|struct
name|fxp_rx
modifier|*
name|rxp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|uint16_t
name|data
decl_stmt|,
name|myea
index|[
name|ETHER_ADDR_LEN
operator|/
literal|2
index|]
decl_stmt|;
name|u_char
name|eaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rid
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|prefer_iomap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
literal|0
argument_list|,
name|fxp_serial_ifmedia_upd
argument_list|,
name|fxp_serial_ifmedia_sts
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Enable bus mastering. 	 */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out which we should try first - memory mapping or i/o mapping? 	 * We default to memory mapping. Then we accept an override from the 	 * command line. Then we check to see which one is enabled. 	 */
name|m1
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|m2
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
name|prefer_iomap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"prefer_iomap"
argument_list|,
operator|&
name|prefer_iomap
argument_list|)
operator|==
literal|0
operator|&&
name|prefer_iomap
operator|!=
literal|0
condition|)
block|{
name|m1
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
name|m2
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
block|}
name|sc
operator|->
name|rtp
operator|=
operator|(
name|m1
operator|==
name|PCIM_CMD_MEMEN
operator|)
condition|?
name|SYS_RES_MEMORY
else|:
name|SYS_RES_IOPORT
expr_stmt|;
name|sc
operator|->
name|rgd
operator|=
operator|(
name|m1
operator|==
name|PCIM_CMD_MEMEN
operator|)
condition|?
name|FXP_PCI_MMBA
else|:
name|FXP_PCI_IOBA
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|rtp
argument_list|,
operator|&
name|sc
operator|->
name|rgd
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|rtp
operator|=
operator|(
name|m2
operator|==
name|PCIM_CMD_MEMEN
operator|)
condition|?
name|SYS_RES_MEMORY
else|:
name|SYS_RES_IOPORT
expr_stmt|;
name|sc
operator|->
name|rgd
operator|=
operator|(
name|m2
operator|==
name|PCIM_CMD_MEMEN
operator|)
condition|?
name|FXP_PCI_MMBA
else|:
name|FXP_PCI_IOBA
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|rtp
argument_list|,
operator|&
name|sc
operator|->
name|rgd
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|mem
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using %s space register mapping\n"
argument_list|,
name|sc
operator|->
name|rtp
operator|==
name|SYS_RES_MEMORY
condition|?
literal|"memory"
else|:
literal|"I/O"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate our interrupt. 	 */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Reset to a stable state. 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_PORT
argument_list|,
name|FXP_PORT_SELECTIVE_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* 	 * Find out how large of an SEEPROM we have. 	 */
name|fxp_autosize_eeprom
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Find out the chip revision; lump all 82557 revs together. 	 */
name|fxp_read_eeprom
argument_list|(
name|sc
argument_list|,
operator|&
name|data
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|==
literal|1
condition|)
name|sc
operator|->
name|revision
operator|=
name|FXP_REV_82557
expr_stmt|;
else|else
name|sc
operator|->
name|revision
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Determine whether we must use the 503 serial interface. 	 */
name|fxp_read_eeprom
argument_list|(
name|sc
argument_list|,
operator|&
name|data
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|revision
operator|==
name|FXP_REV_82557
operator|&&
operator|(
name|data
operator|&
name|FXP_PHY_DEVICE_MASK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|data
operator|&
name|FXP_PHY_SERIAL_ONLY
operator|)
condition|)
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_SERIAL_MEDIA
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"int_delay"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tunable_int_delay
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_fxp_int_delay
argument_list|,
literal|"I"
argument_list|,
literal|"FXP driver receive interrupt microcode bundling delay"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bundle_max"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tunable_bundle_max
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_fxp_bundle_max
argument_list|,
literal|"I"
argument_list|,
literal|"FXP driver receive interrupt microcode bundle size limit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rnr"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|rnr
argument_list|,
literal|0
argument_list|,
literal|"FXP RNR events"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"noflow"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tunable_noflow
argument_list|,
literal|0
argument_list|,
literal|"FXP flow control disabled"
argument_list|)
expr_stmt|;
comment|/* 	 * Pull in device tunables. 	 */
name|sc
operator|->
name|tunable_int_delay
operator|=
name|TUNABLE_INT_DELAY
expr_stmt|;
name|sc
operator|->
name|tunable_bundle_max
operator|=
name|TUNABLE_BUNDLE_MAX
expr_stmt|;
name|sc
operator|->
name|tunable_noflow
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"int_delay"
argument_list|,
operator|&
name|sc
operator|->
name|tunable_int_delay
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"bundle_max"
argument_list|,
operator|&
name|sc
operator|->
name|tunable_bundle_max
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"noflow"
argument_list|,
operator|&
name|sc
operator|->
name|tunable_noflow
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rnr
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Enable workarounds for certain chip revision deficiencies. 	 * 	 * Systems based on the ICH2/ICH2-M chip from Intel, and possibly 	 * some systems based a normal 82559 design, have a defect where 	 * the chip can cause a PCI protocol violation if it receives 	 * a CU_RESUME command when it is entering the IDLE state.  The  	 * workaround is to disable Dynamic Standby Mode, so the chip never 	 * deasserts CLKRUN#, and always remains in an active state. 	 * 	 * See Intel 82801BA/82801BAM Specification Update, Errata #30. 	 */
name|i
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0x2449
operator|||
operator|(
name|i
operator|>
literal|0x1030
operator|&&
name|i
operator|<
literal|0x1039
operator|)
operator|||
name|sc
operator|->
name|revision
operator|>=
name|FXP_REV_82559_A0
condition|)
block|{
name|fxp_read_eeprom
argument_list|(
name|sc
argument_list|,
operator|&
name|data
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&
literal|0x02
condition|)
block|{
comment|/* STB enable */
name|uint16_t
name|cksum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Disabling dynamic standby mode in EEPROM\n"
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
literal|0x02
expr_stmt|;
name|fxp_write_eeprom
argument_list|(
name|sc
argument_list|,
operator|&
name|data
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"New EEPROM ID: 0x%x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|cksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|sc
operator|->
name|eeprom_size
operator|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|fxp_read_eeprom
argument_list|(
name|sc
argument_list|,
operator|&
name|data
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cksum
operator|+=
name|data
expr_stmt|;
block|}
name|i
operator|=
operator|(
literal|1
operator|<<
name|sc
operator|->
name|eeprom_size
operator|)
operator|-
literal|1
expr_stmt|;
name|cksum
operator|=
literal|0xBABA
operator|-
name|cksum
expr_stmt|;
name|fxp_read_eeprom
argument_list|(
name|sc
argument_list|,
operator|&
name|data
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fxp_write_eeprom
argument_list|(
name|sc
argument_list|,
operator|&
name|cksum
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"EEPROM checksum @ 0x%x: 0x%x -> 0x%x\n"
argument_list|,
name|i
argument_list|,
name|data
argument_list|,
name|cksum
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* 			 * If the user elects to continue, try the software 			 * workaround, as it is better than nothing. 			 */
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_CU_RESUME_BUG
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* 	 * If we are not a 82557 chip, we can enable extended features. 	 */
if|if
condition|(
name|sc
operator|->
name|revision
operator|!=
name|FXP_REV_82557
condition|)
block|{
comment|/* 		 * If MWI is enabled in the PCI configuration, and there 		 * is a valid cacheline size (8 or 16 dwords), then tell 		 * the board to turn on MWI. 		 */
if|if
condition|(
name|val
operator|&
name|PCIM_CMD_MWRICEN
operator|&&
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_MWI_ENABLE
expr_stmt|;
comment|/* turn on the extended TxCB feature */
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_EXT_TXCB
expr_stmt|;
comment|/* enable reception of long frames for VLAN */
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_LONG_PKT_EN
expr_stmt|;
block|}
else|else
block|{
comment|/* a hack to get long VLAN frames on a 82557 */
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_SAVE_BAD
expr_stmt|;
block|}
comment|/* 	 * Enable use of extended RFDs and TCBs for 82550 	 * and later chips. Note: we need extended TXCB support 	 * too, but that's already enabled by the code above. 	 * Be careful to do this only on the right devices. 	 */
if|if
condition|(
name|sc
operator|->
name|revision
operator|==
name|FXP_REV_82550
operator|||
name|sc
operator|->
name|revision
operator|==
name|FXP_REV_82550_C
operator|||
name|sc
operator|->
name|revision
operator|==
name|FXP_REV_82551_E
operator|||
name|sc
operator|->
name|revision
operator|==
name|FXP_REV_82551_F
operator|||
name|sc
operator|->
name|revision
operator|==
name|FXP_REV_82551_10
condition|)
block|{
name|sc
operator|->
name|rfa_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_rfa
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_cmd
operator|=
name|FXP_CB_COMMAND_IPCBXMIT
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_EXT_RFA
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|rfa_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_rfa
argument_list|)
operator|-
name|FXP_RFAX_LEN
expr_stmt|;
name|sc
operator|->
name|tx_cmd
operator|=
name|FXP_CB_COMMAND_XMIT
expr_stmt|;
block|}
comment|/* 	 * Allocate DMA tags and DMA safe memory. 	 */
name|sc
operator|->
name|maxtxseg
operator|=
name|FXP_NTXSEG
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_EXT_RFA
condition|)
name|sc
operator|->
name|maxtxseg
operator|--
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
operator|*
name|sc
operator|->
name|maxtxseg
argument_list|,
name|sc
operator|->
name|maxtxseg
argument_list|,
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|sc
operator|->
name|fxp_mtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate dma tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_stats
argument_list|)
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_stats
argument_list|)
argument_list|,
literal|0
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|sc
operator|->
name|fxp_stag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate dma tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|fxp_stag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|fxp_stats
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc
operator|->
name|fxp_smap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|fxp_stag
argument_list|,
name|sc
operator|->
name|fxp_smap
argument_list|,
name|sc
operator|->
name|fxp_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_stats
argument_list|)
argument_list|,
name|fxp_dma_map_addr
argument_list|,
operator|&
name|sc
operator|->
name|stats_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map the stats buffer\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FXP_TXCB_SZ
argument_list|,
literal|1
argument_list|,
name|FXP_TXCB_SZ
argument_list|,
literal|0
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|sc
operator|->
name|cbl_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate dma tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|fxp_desc
operator|.
name|cbl_list
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc
operator|->
name|cbl_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|,
name|sc
operator|->
name|fxp_desc
operator|.
name|cbl_list
argument_list|,
name|FXP_TXCB_SZ
argument_list|,
name|fxp_dma_map_addr
argument_list|,
operator|&
name|sc
operator|->
name|fxp_desc
operator|.
name|cbl_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map DMA memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_cb_mcs
argument_list|)
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_cb_mcs
argument_list|)
argument_list|,
literal|0
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|sc
operator|->
name|mcs_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate dma tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mcs_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|mcsp
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|mcs_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mcs_tag
argument_list|,
name|sc
operator|->
name|mcs_map
argument_list|,
name|sc
operator|->
name|mcsp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_cb_mcs
argument_list|)
argument_list|,
name|fxp_dma_map_addr
argument_list|,
operator|&
name|sc
operator|->
name|mcs_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't map the multicast setup command\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Pre-allocate the TX DMA maps and setup the pointers to 	 * the TX command blocks. 	 */
name|txp
operator|=
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_list
expr_stmt|;
name|tcbp
operator|=
name|sc
operator|->
name|fxp_desc
operator|.
name|cbl_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NTXCB
condition|;
name|i
operator|++
control|)
block|{
name|txp
index|[
name|i
index|]
operator|.
name|tx_cb
operator|=
name|tcbp
operator|+
name|i
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
literal|0
argument_list|,
operator|&
name|txp
index|[
name|i
index|]
operator|.
name|tx_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't create DMA map for TX\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|spare_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't create spare DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Pre-allocate our receive buffers. 	 */
name|sc
operator|->
name|fxp_desc
operator|.
name|rx_head
operator|=
name|sc
operator|->
name|fxp_desc
operator|.
name|rx_tail
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NRFABUFS
condition|;
name|i
operator|++
control|)
block|{
name|rxp
operator|=
operator|&
name|sc
operator|->
name|fxp_desc
operator|.
name|rx_list
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
literal|0
argument_list|,
operator|&
name|rxp
operator|->
name|rx_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't create DMA map for RX\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|fxp_add_rfabuf
argument_list|(
name|sc
argument_list|,
name|rxp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* 	 * Read MAC address. 	 */
name|fxp_read_eeprom
argument_list|(
name|sc
argument_list|,
name|myea
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|0
index|]
operator|=
name|myea
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|1
index|]
operator|=
name|myea
index|[
literal|0
index|]
operator|>>
literal|8
expr_stmt|;
name|eaddr
index|[
literal|2
index|]
operator|=
name|myea
index|[
literal|1
index|]
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|3
index|]
operator|=
name|myea
index|[
literal|1
index|]
operator|>>
literal|8
expr_stmt|;
name|eaddr
index|[
literal|4
index|]
operator|=
name|myea
index|[
literal|2
index|]
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|5
index|]
operator|=
name|myea
index|[
literal|2
index|]
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI IDs: %04x %04x %04x %04x %04x\n"
argument_list|,
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_device
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|fxp_read_eeprom
argument_list|(
name|sc
argument_list|,
operator|&
name|data
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Dynamic Standby mode is %s\n"
argument_list|,
name|data
operator|&
literal|0x02
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this is only a 10Mbps device, then there is no MII, and 	 * the PHY will use a serial interface instead. 	 * 	 * The Seeq 80c24 AutoDUPLEX(tm) Ethernet Interface Adapter 	 * doesn't have a programming interface of any sort.  The 	 * media is sensed automatically based on how the link partner 	 * is configured.  This is, in essence, manual configuration. 	 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_SERIAL_MEDIA
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mii_phy_probe
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|miibus
argument_list|,
name|fxp_ifmedia_upd
argument_list|,
name|fxp_ifmedia_sts
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MII without any PHY!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|fxp_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|fxp_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|fxp_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|fxp_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|ifp
operator|->
name|if_capenable
operator|=
literal|0
expr_stmt|;
comment|/* Enable checksum offload for 82550 or better chips */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_EXT_RFA
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator|=
name|FXP_CSUM_FEATURES
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_HWCSUM
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* Inform the world we support polling. */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_POLLING
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Attach the interface. 	 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 * Must appear after the call to ether_ifattach() because 	 * ether_ifattach() sets ifi_hdrlen to the default value. 	 */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_VLAN_MTU
expr_stmt|;
comment|/* the hw bits already set */
comment|/* 	 * Let the system queue as many packets as we have available 	 * TX descriptors. 	 */
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|FXP_NTXCB
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|FXP_NTXCB
operator|-
literal|1
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/*  	 * Hook our interrupt after all initialization is complete. 	 */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|fxp_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup irq\n"
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fail
label|:
if|if
condition|(
name|error
condition|)
name|fxp_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release all resources.  The softc lock should not be held and the  * interrupt should already be torn down.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_release
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|fxp_rx
modifier|*
name|rxp
decl_stmt|;
name|struct
name|fxp_tx
modifier|*
name|txp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FXP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|ih
operator|==
name|NULL
argument_list|,
operator|(
literal|"fxp_release() called with intr handle still active"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|miibus
condition|)
name|device_delete_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fxp_desc
operator|.
name|cbl_list
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|fxp_desc
operator|.
name|cbl_list
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|fxp_stats
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|fxp_stag
argument_list|,
name|sc
operator|->
name|fxp_smap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|fxp_stag
argument_list|,
name|sc
operator|->
name|fxp_stats
argument_list|,
name|sc
operator|->
name|fxp_smap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mcsp
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mcs_tag
argument_list|,
name|sc
operator|->
name|mcs_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mcs_tag
argument_list|,
name|sc
operator|->
name|mcsp
argument_list|,
name|sc
operator|->
name|mcs_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|rtp
argument_list|,
name|sc
operator|->
name|rgd
argument_list|,
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fxp_mtag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NRFABUFS
condition|;
name|i
operator|++
control|)
block|{
name|rxp
operator|=
operator|&
name|sc
operator|->
name|fxp_desc
operator|.
name|rx_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxp
operator|->
name|rx_mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|rxp
operator|->
name|rx_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|rxp
operator|->
name|rx_map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxp
operator|->
name|rx_mbuf
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|rxp
operator|->
name|rx_map
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|sc
operator|->
name|spare_map
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NTXCB
condition|;
name|i
operator|++
control|)
block|{
name|txp
operator|=
operator|&
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txp
operator|->
name|tx_mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|txp
operator|->
name|tx_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|txp
operator|->
name|tx_map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txp
operator|->
name|tx_mbuf
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|txp
operator|->
name|tx_map
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|fxp_stag
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|fxp_stag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cbl_tag
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mcs_tag
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mcs_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
condition|)
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Detach interface.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|ether_poll_deregister
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|suspended
operator|=
literal|1
expr_stmt|;
comment|/* Do same thing as we do for suspend */
comment|/* 	 * Stop DMA and drop transmit queue, but disable interrupts first. 	 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_INTRCNTL
argument_list|,
name|FXP_SCB_INTR_DISABLE
argument_list|)
expr_stmt|;
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|)
expr_stmt|;
comment|/* 	 * Close down routes etc. 	 */
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Unhook interrupt before dropping lock. This is to prevent 	 * races with fxp_intr(). 	 */
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ih
operator|=
name|NULL
expr_stmt|;
comment|/* Release our allocated resources. */
name|fxp_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device shutdown routine. Called at system shutdown after sync. The  * main purpose of this routine is to shut off receiver DMA so that  * kernel memory doesn't get clobbered during warmboot.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* 	 * Make sure that DMA is disabled prior to reboot. Not doing 	 * do could allow DMA to corrupt kernel memory during the 	 * reboot before the driver initializes. 	 */
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device suspend routine.  Stop the interface and save some PCI  * settings in case the BIOS doesn't restore them properly on  * resume.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|suspended
operator|=
literal|1
expr_stmt|;
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device resume routine. re-enable busmastering, and restart the interface if  * appropriate.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_PORT
argument_list|,
name|FXP_PORT_SELECTIVE_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* reinitialize interface if necessary */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|fxp_init_body
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|suspended
operator|=
literal|0
expr_stmt|;
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_eeprom_shiftin
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|data
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|uint16_t
name|reg
decl_stmt|;
name|int
name|x
decl_stmt|;
comment|/* 	 * Shift in data. 	 */
for|for
control|(
name|x
operator|=
literal|1
operator|<<
operator|(
name|length
operator|-
literal|1
operator|)
init|;
name|x
condition|;
name|x
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|data
operator|&
name|x
condition|)
name|reg
operator|=
name|FXP_EEPROM_EECS
operator||
name|FXP_EEPROM_EEDI
expr_stmt|;
else|else
name|reg
operator|=
name|FXP_EEPROM_EECS
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
operator||
name|FXP_EEPROM_EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read from the serial EEPROM. Basically, you manually shift in  * the read opcode (one bit at a time) and then shift in the address,  * and then you shift out the data (all of this one bit at a time).  * The word size is 16 bits, so you have to provide the address for  * every 16 bits of data.  */
end_comment

begin_function
specifier|static
name|uint16_t
name|fxp_eeprom_getword
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|autosize
parameter_list|)
block|{
name|uint16_t
name|reg
decl_stmt|,
name|data
decl_stmt|;
name|int
name|x
decl_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|FXP_EEPROM_EECS
argument_list|)
expr_stmt|;
comment|/* 	 * Shift in read opcode. 	 */
name|fxp_eeprom_shiftin
argument_list|(
name|sc
argument_list|,
name|FXP_EEPROM_OPC_READ
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* 	 * Shift in address. 	 */
name|data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
operator|<<
operator|(
name|sc
operator|->
name|eeprom_size
operator|-
literal|1
operator|)
init|;
name|x
condition|;
name|x
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|offset
operator|&
name|x
condition|)
name|reg
operator|=
name|FXP_EEPROM_EECS
operator||
name|FXP_EEPROM_EEDI
expr_stmt|;
else|else
name|reg
operator|=
name|FXP_EEPROM_EECS
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
operator||
name|FXP_EEPROM_EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|reg
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|)
operator|&
name|FXP_EEPROM_EEDO
expr_stmt|;
name|data
operator|++
expr_stmt|;
if|if
condition|(
name|autosize
operator|&&
name|reg
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|eeprom_size
operator|=
name|data
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Shift out data. 	 */
name|data
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|FXP_EEPROM_EECS
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
operator|<<
literal|15
init|;
name|x
condition|;
name|x
operator|>>=
literal|1
control|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
operator||
name|FXP_EEPROM_EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|)
operator|&
name|FXP_EEPROM_EEDO
condition|)
name|data
operator||=
name|x
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_eeprom_putword
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * Erase/write enable. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|FXP_EEPROM_EECS
argument_list|)
expr_stmt|;
name|fxp_eeprom_shiftin
argument_list|(
name|sc
argument_list|,
literal|0x4
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|fxp_eeprom_shiftin
argument_list|(
name|sc
argument_list|,
literal|0x03
operator|<<
operator|(
name|sc
operator|->
name|eeprom_size
operator|-
literal|2
operator|)
argument_list|,
name|sc
operator|->
name|eeprom_size
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Shift in write opcode, address, data. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|FXP_EEPROM_EECS
argument_list|)
expr_stmt|;
name|fxp_eeprom_shiftin
argument_list|(
name|sc
argument_list|,
name|FXP_EEPROM_OPC_WRITE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|fxp_eeprom_shiftin
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|sc
operator|->
name|eeprom_size
argument_list|)
expr_stmt|;
name|fxp_eeprom_shiftin
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for EEPROM to finish up. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|FXP_EEPROM_EECS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|)
operator|&
name|FXP_EEPROM_EEDO
condition|)
break|break;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Erase/write disable. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
name|FXP_EEPROM_EECS
argument_list|)
expr_stmt|;
name|fxp_eeprom_shiftin
argument_list|(
name|sc
argument_list|,
literal|0x4
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|fxp_eeprom_shiftin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|eeprom_size
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_EEPROMCONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * From NetBSD:  *  * Figure out EEPROM size.  *  * 559's can have either 64-word or 256-word EEPROMs, the 558  * datasheet only talks about 64-word EEPROMs, and the 557 datasheet  * talks about the existance of 16 to 256 word EEPROMs.  *  * The only known sizes are 64 and 256, where the 256 version is used  * by CardBus cards to store CIS information.  *  * The address is shifted in msb-to-lsb, and after the last  * address-bit the EEPROM is supposed to output a `dummy zero' bit,  * after which follows the actual data. We try to detect this zero, by  * probing the data-out bit in the EEPROM control register just after  * having shifted in a bit. If the bit is zero, we assume we've  * shifted enough address bits. The data-out should be tri-state,  * before this, which should translate to a logical one.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_autosize_eeprom
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* guess maximum size of 256 words */
name|sc
operator|->
name|eeprom_size
operator|=
literal|8
expr_stmt|;
comment|/* autosize */
operator|(
name|void
operator|)
name|fxp_eeprom_getword
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_read_eeprom
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|u_short
modifier|*
name|data
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|words
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
name|data
index|[
name|i
index|]
operator|=
name|fxp_eeprom_getword
argument_list|(
name|sc
argument_list|,
name|offset
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_write_eeprom
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|u_short
modifier|*
name|data
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|words
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
name|fxp_eeprom_putword
argument_list|(
name|sc
argument_list|,
name|offset
operator|+
name|i
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grab the softc lock and call the real fxp_start_body() routine  */
end_comment

begin_function
specifier|static
name|void
name|fxp_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fxp_start_body
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start packet transmission on the interface.    * This routine must be called with the softc lock held, and is an  * internal entry point only.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_start_body
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb_head
decl_stmt|;
name|int
name|error
decl_stmt|,
name|txqueued
decl_stmt|;
name|FXP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * See if we need to suspend xmit until the multicast filter 	 * has been reprogrammed (which can only be done at the head 	 * of the command chain). 	 */
if|if
condition|(
name|sc
operator|->
name|need_mcsetup
condition|)
return|return;
comment|/* 	 * We're finished if there is nothing more to add to the list or if 	 * we're all filled up with buffers to transmit. 	 * NOTE: One TxCB is reserved to guarantee that fxp_mc_setup() can add 	 *       a NOP command when needed. 	 */
name|txqueued
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
operator|&&
name|sc
operator|->
name|tx_queued
operator|<
name|FXP_NTXCB
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Grab a packet to transmit. 		 */
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mb_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_head
operator|==
name|NULL
condition|)
break|break;
name|error
operator|=
name|fxp_encap
argument_list|(
name|sc
argument_list|,
name|mb_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|txqueued
operator|=
literal|1
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * We're finished. If we added to the list, issue a RESUME to get DMA 	 * going again if suspended. 	 */
if|if
condition|(
name|txqueued
condition|)
block|{
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_RESUME
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fxp_encap
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|fxp_tx
modifier|*
name|txp
decl_stmt|;
name|struct
name|fxp_cb_tx
modifier|*
name|cbp
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|FXP_NTXSEG
index|]
decl_stmt|;
name|int
name|chainlen
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|nseg
decl_stmt|;
name|FXP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
comment|/* 	 * Get pointer to next available tx desc. 	 */
name|txp
operator|=
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_last
operator|->
name|tx_next
expr_stmt|;
comment|/* 	 * A note in Appendix B of the Intel 8255x 10/100 Mbps 	 * Ethernet Controller Family Open Source Software 	 * Developer Manual says: 	 *   Using software parsing is only allowed with legal 	 *   TCP/IP or UDP/IP packets. 	 *   ... 	 *   For all other datagrams, hardware parsing must 	 *   be used. 	 * Software parsing appears to truncate ICMP and 	 * fragmented UDP packets that contain one to three 	 * bytes in the second (and final) mbuf of the packet. 	 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_EXT_RFA
condition|)
name|txp
operator|->
name|tx_cb
operator|->
name|ipcb_ip_activation_high
operator|=
name|FXP_IPCB_HARDWAREPARSING_ENABLE
expr_stmt|;
comment|/* 	 * Deal with TCP/IP checksum offload. Note that 	 * in order for TCP checksum offload to work, 	 * the pseudo header checksum must have already 	 * been computed and stored in the checksum field 	 * in the TCP header. The stack should have 	 * already done this for us. 	 */
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
condition|)
block|{
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA
condition|)
block|{
name|txp
operator|->
name|tx_cb
operator|->
name|ipcb_ip_schedule
operator|=
name|FXP_IPCB_TCPUDP_CHECKSUM_ENABLE
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
condition|)
name|txp
operator|->
name|tx_cb
operator|->
name|ipcb_ip_schedule
operator||=
name|FXP_IPCB_TCP_PACKET
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FXP_IP_CSUM_WAR
comment|/* 		 * XXX The 82550 chip appears to have trouble 		 * dealing with IP header checksums in very small 		 * datagrams, namely fragments from 1 to 3 bytes 		 * in size. For example, say you want to transmit 		 * a UDP packet of 1473 bytes. The packet will be 		 * fragmented over two IP datagrams, the latter 		 * containing only one byte of data. The 82550 will 		 * botch the header checksum on the 1-byte fragment. 		 * As long as the datagram contains 4 or more bytes 		 * of data, you're ok. 		 *                  * The following code attempts to work around this 		 * problem: if the datagram is less than 38 bytes 		 * in size (14 bytes ether header, 20 bytes IP header, 		 * plus 4 bytes of data), we punt and compute the IP 		 * header checksum by hand. This workaround doesn't 		 * work very well, however, since it can be fooled 		 * by things like VLAN tags and IP options that make 		 * the header sizes/offsets vary. 		 */
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
condition|)
block|{
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|38
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|m_head
operator|->
name|m_data
operator|+=
name|ETHER_HDR_LEN
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|mb_head
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum
argument_list|(
name|mb_head
argument_list|,
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|m_head
operator|->
name|m_data
operator|-=
name|ETHER_HDR_LEN
expr_stmt|;
block|}
else|else
block|{
name|txp
operator|->
name|tx_cb
operator|->
name|ipcb_ip_activation_high
operator|=
name|FXP_IPCB_HARDWAREPARSING_ENABLE
expr_stmt|;
name|txp
operator|->
name|tx_cb
operator|->
name|ipcb_ip_schedule
operator||=
name|FXP_IPCB_IP_CHECKSUM_ENABLE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
name|chainlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m_head
init|;
name|m
operator|!=
name|NULL
operator|&&
name|chainlen
operator|<=
name|sc
operator|->
name|maxtxseg
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|chainlen
operator|++
expr_stmt|;
if|if
condition|(
name|chainlen
operator|>
name|sc
operator|->
name|maxtxseg
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mn
decl_stmt|;
comment|/* 		 * We ran out of segments. We have to recopy this 		 * mbuf chain first. Bail out if we can't get the 		 * new buffers. 		 */
name|mn
operator|=
name|m_defrag
argument_list|(
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mn
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|m_head
operator|=
name|mn
expr_stmt|;
block|}
block|}
comment|/* 	 * Go through each of the mbufs in the chain and initialize 	 * the transmit buffer descriptors with the physical address 	 * and size of the mbuf. 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|txp
operator|->
name|tx_map
argument_list|,
name|m_head
argument_list|,
name|segs
argument_list|,
operator|&
name|nseg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"can't map mbuf (error %d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|nseg
operator|<=
name|sc
operator|->
name|maxtxseg
argument_list|,
operator|(
literal|"too many DMA segments"
operator|)
argument_list|)
expr_stmt|;
name|cbp
operator|=
name|txp
operator|->
name|tx_cb
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|<=
name|MCLBYTES
argument_list|,
operator|(
literal|"segment size too large"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * If this is an 82550/82551, then we're using extended 		 * TxCBs _and_ we're using checksum offload. This means 		 * that the TxCB is really an IPCB. One major difference 		 * between the two is that with plain extended TxCBs, 		 * the bottom half of the TxCB contains two entries from 		 * the TBD array, whereas IPCBs contain just one entry: 		 * one entry (8 bytes) has been sacrificed for the TCP/IP 		 * checksum offload control bits. So to make things work 		 * right, we have to start filling in the TBD array 		 * starting from a different place depending on whether 		 * the chip is an 82550/82551 or not. 		 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_EXT_RFA
condition|)
block|{
name|cbp
operator|->
name|tbd
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tb_addr
operator|=
name|htole32
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|tbd
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tb_size
operator|=
name|htole32
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cbp
operator|->
name|tbd
index|[
name|i
index|]
operator|.
name|tb_addr
operator|=
name|htole32
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|tbd
index|[
name|i
index|]
operator|.
name|tb_size
operator|=
name|htole32
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
block|}
block|}
name|cbp
operator|->
name|tbd_number
operator|=
name|nseg
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|txp
operator|->
name|tx_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|txp
operator|->
name|tx_mbuf
operator|=
name|m_head
expr_stmt|;
name|txp
operator|->
name|tx_cb
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|txp
operator|->
name|tx_cb
operator|->
name|byte_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_queued
operator|!=
name|FXP_CXINT_THRESH
operator|-
literal|1
condition|)
block|{
name|txp
operator|->
name|tx_cb
operator|->
name|cb_command
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|tx_cmd
operator||
name|FXP_CB_COMMAND_SF
operator||
name|FXP_CB_COMMAND_S
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|txp
operator|->
name|tx_cb
operator|->
name|cb_command
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|tx_cmd
operator||
name|FXP_CB_COMMAND_SF
operator||
name|FXP_CB_COMMAND_S
operator||
name|FXP_CB_COMMAND_I
argument_list|)
expr_stmt|;
comment|/* 		 * Set a 5 second timer just in case we don't hear 		 * from the card again. 		 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
block|}
name|txp
operator|->
name|tx_cb
operator|->
name|tx_threshold
operator|=
name|tx_threshold
expr_stmt|;
comment|/* 	 * Advance the end of list forward. 	 */
ifdef|#
directive|ifdef
name|__alpha__
comment|/* 	 * On platforms which can't access memory in 16-bit 	 * granularities, we must prevent the card from DMA'ing 	 * up the status while we update the command field. 	 * This could cause us to overwrite the completion status. 	 * XXX This is probably bogus and we're _not_ looking 	 * for atomicity here. 	 */
name|atomic_clear_16
argument_list|(
operator|&
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_last
operator|->
name|tx_cb
operator|->
name|cb_command
argument_list|,
name|htole16
argument_list|(
name|FXP_CB_COMMAND_S
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_last
operator|->
name|tx_cb
operator|->
name|cb_command
operator|&=
name|htole16
argument_list|(
operator|~
name|FXP_CB_COMMAND_S
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*__alpha__*/
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_last
operator|=
name|txp
expr_stmt|;
comment|/* 	 * Advance the beginning of the list forward if there are 	 * no other packets queued (when nothing is queued, tx_first 	 * sits on the last TxCB that was sent out). 	 */
if|if
condition|(
name|sc
operator|->
name|tx_queued
operator|==
literal|0
condition|)
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_first
operator|=
name|txp
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|++
expr_stmt|;
comment|/* 	 * Pass packet to bpf if there is a listener. 	 */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_decl_stmt
specifier|static
name|poll_handler_t
name|fxp_poll
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|fxp_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|uint8_t
name|statack
decl_stmt|;
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|statack
operator|=
name|FXP_SCB_STATACK_CXTNO
operator||
name|FXP_SCB_STATACK_CNA
operator||
name|FXP_SCB_STATACK_FR
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
condition|)
block|{
name|uint8_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_STATACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0xff
operator|||
name|tmp
operator|==
literal|0
condition|)
block|{
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
comment|/* nothing to do */
block|}
name|tmp
operator|&=
operator|~
name|statack
expr_stmt|;
comment|/* ack what we can */
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_STATACK
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|statack
operator||=
name|tmp
expr_stmt|;
block|}
name|fxp_intr_body
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
name|statack
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_comment
comment|/*  * Process interface interrupts.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|uint8_t
name|statack
decl_stmt|;
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|suspended
condition|)
block|{
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
while|while
condition|(
operator|(
name|statack
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_STATACK
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * It should not be possible to have all bits set; the 		 * FXP_SCB_INTR_SWI bit always returns 0 on a read.  If  		 * all bits are set, this may indicate that the card has 		 * been physically ejected, so ignore it. 		 */
if|if
condition|(
name|statack
operator|==
literal|0xff
condition|)
block|{
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * First ACK all the interrupts in this pass. 		 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_STATACK
argument_list|,
name|statack
argument_list|)
expr_stmt|;
name|fxp_intr_body
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
name|statack
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_txeof
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|fxp_tx
modifier|*
name|txp
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
for|for
control|(
name|txp
operator|=
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_first
init|;
name|sc
operator|->
name|tx_queued
operator|&&
operator|(
name|le16toh
argument_list|(
name|txp
operator|->
name|tx_cb
operator|->
name|cb_status
argument_list|)
operator|&
name|FXP_CB_STATUS_C
operator|)
operator|!=
literal|0
condition|;
name|txp
operator|=
name|txp
operator|->
name|tx_next
control|)
block|{
if|if
condition|(
name|txp
operator|->
name|tx_mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|txp
operator|->
name|tx_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|txp
operator|->
name|tx_map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txp
operator|->
name|tx_mbuf
argument_list|)
expr_stmt|;
name|txp
operator|->
name|tx_mbuf
operator|=
name|NULL
expr_stmt|;
comment|/* clear this to reset csum offload bits */
name|txp
operator|->
name|tx_cb
operator|->
name|tbd
index|[
literal|0
index|]
operator|.
name|tb_addr
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|tx_queued
operator|--
expr_stmt|;
block|}
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_first
operator|=
name|txp
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_intr_body
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint8_t
name|statack
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|fxp_rx
modifier|*
name|rxp
decl_stmt|;
name|struct
name|fxp_rfa
modifier|*
name|rfa
decl_stmt|;
name|int
name|rnr
init|=
operator|(
name|statack
operator|&
name|FXP_SCB_STATACK_RNR
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|fxp_rc
init|=
literal|0
decl_stmt|;
name|FXP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnr
condition|)
name|sc
operator|->
name|rnr
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* Pick up a deferred RNR condition if `count' ran out last time. */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_DEFERRED_RNR
condition|)
block|{
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FXP_FLAG_DEFERRED_RNR
expr_stmt|;
name|rnr
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Free any finished transmit mbuf chains. 	 * 	 * Handle the CNA event likt a CXTNO event. It used to 	 * be that this event (control unit not ready) was not 	 * encountered, but it is now with the SMPng modifications. 	 * The exact sequence of events that occur when the interface 	 * is brought up are different now, and if this event 	 * goes unhandled, the configuration/rxfilter setup sequence 	 * can stall for several seconds. The result is that no 	 * packets go out onto the wire for about 5 to 10 seconds 	 * after the interface is ifconfig'ed for the first time. 	 */
if|if
condition|(
name|statack
operator|&
operator|(
name|FXP_SCB_STATACK_CXTNO
operator||
name|FXP_SCB_STATACK_CNA
operator|)
condition|)
block|{
name|fxp_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_queued
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|need_mcsetup
condition|)
name|fxp_mc_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Try to start more packets transmitting. 		 */
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|fxp_start_body
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Just return if nothing happened on the receive side. 	 */
if|if
condition|(
operator|!
name|rnr
operator|&&
operator|(
name|statack
operator|&
name|FXP_SCB_STATACK_FR
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Process receiver interrupts. If a no-resource (RNR) 	 * condition exists, get whatever packets we can and 	 * re-start the receiver. 	 * 	 * When using polling, we do not process the list to completion, 	 * so when we get an RNR interrupt we must defer the restart 	 * until we hit the last buffer with the C bit set. 	 * If we run out of cycles and rfa_headm has the C bit set, 	 * record the pending RNR in the FXP_FLAG_DEFERRED_RNR flag so 	 * that the info will be used in the subsequent polling cycle. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|rxp
operator|=
name|sc
operator|->
name|fxp_desc
operator|.
name|rx_head
expr_stmt|;
name|m
operator|=
name|rxp
operator|->
name|rx_mbuf
expr_stmt|;
name|rfa
operator|=
operator|(
expr|struct
name|fxp_rfa
operator|*
operator|)
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|+
name|RFA_ALIGNMENT_FUDGE
operator|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|rxp
operator|->
name|rx_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* loop at most count times if count>=0 */
if|if
condition|(
name|count
operator|>=
literal|0
operator|&&
name|count
operator|--
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rnr
condition|)
block|{
comment|/* Defer RNR processing until the next time. */
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_DEFERRED_RNR
expr_stmt|;
name|rnr
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* DEVICE_POLLING */
if|if
condition|(
operator|(
name|le16toh
argument_list|(
name|rfa
operator|->
name|rfa_status
argument_list|)
operator|&
name|FXP_RFA_STATUS_C
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Advance head forward. 		 */
name|sc
operator|->
name|fxp_desc
operator|.
name|rx_head
operator|=
name|rxp
operator|->
name|rx_next
expr_stmt|;
comment|/* 		 * Add a new buffer to the receive chain. 		 * If this fails, the old buffer is recycled 		 * instead. 		 */
name|fxp_rc
operator|=
name|fxp_add_rfabuf
argument_list|(
name|sc
argument_list|,
name|rxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fxp_rc
operator|==
literal|0
condition|)
block|{
name|int
name|total_len
decl_stmt|;
comment|/* 			 * Fetch packet length (the top 2 bits of 			 * actual_size are flags set by the controller 			 * upon completion), and drop the packet in case 			 * of bogus length or CRC errors. 			 */
name|total_len
operator|=
name|le16toh
argument_list|(
name|rfa
operator|->
name|actual_size
argument_list|)
operator|&
literal|0x3fff
expr_stmt|;
if|if
condition|(
name|total_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|||
name|total_len
operator|>
name|MCLBYTES
operator|-
name|RFA_ALIGNMENT_FUDGE
operator|-
name|sc
operator|->
name|rfa_size
operator|||
name|le16toh
argument_list|(
name|rfa
operator|->
name|rfa_status
argument_list|)
operator|&
name|FXP_RFA_STATUS_CRC
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Do IP checksum checking. */
if|if
condition|(
name|le16toh
argument_list|(
name|rfa
operator|->
name|rfa_status
argument_list|)
operator|&
name|FXP_RFA_STATUS_PARSE
condition|)
block|{
if|if
condition|(
name|rfa
operator|->
name|rfax_csum_sts
operator|&
name|FXP_RFDX_CS_IP_CSUM_BIT_VALID
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_CHECKED
expr_stmt|;
if|if
condition|(
name|rfa
operator|->
name|rfax_csum_sts
operator|&
name|FXP_RFDX_CS_IP_CSUM_VALID
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
if|if
condition|(
operator|(
name|rfa
operator|->
name|rfax_csum_sts
operator|&
name|FXP_RFDX_CS_TCPUDP_CSUM_BIT_VALID
operator|)
operator|&&
operator|(
name|rfa
operator|->
name|rfax_csum_sts
operator|&
name|FXP_RFDX_CS_TCPUDP_CSUM_VALID
operator|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|total_len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
comment|/* 			 * Drop locks before calling if_input() since it 			 * may re-enter fxp_start() in the netisr case. 			 * This would result in a lock reversal.  Better 			 * performance might be obtained by chaining all 			 * packets received, dropping the lock, and then 			 * calling if_input() on each one. 			 */
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fxp_rc
operator|==
name|ENOBUFS
condition|)
block|{
name|rnr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rnr
condition|)
block|{
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|sc
operator|->
name|fxp_desc
operator|.
name|rx_head
operator|->
name|rx_addr
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_RU_START
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Update packet in/out/collision statistics. The i82557 doesn't  * allow you to access these counters without doing a fairly  * expensive DMA to get _all_ of the statistics it maintains, so  * we do this operation here only once per second. The statistics  * counters in the kernel are updated from the previous dump-stats  * DMA and then a new dump-stats DMA is started. The on-chip  * counters are zeroed when the DMA completes. If we can't start  * the DMA immediately, we don't wait - we just prepare to read  * them again next time.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|fxp_stats
modifier|*
name|sp
init|=
name|sc
operator|->
name|fxp_stats
decl_stmt|;
name|FXP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fxp_stag
argument_list|,
name|sc
operator|->
name|fxp_smap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|+=
name|le32toh
argument_list|(
name|sp
operator|->
name|tx_good
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
name|le32toh
argument_list|(
name|sp
operator|->
name|tx_total_collisions
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|rx_good
condition|)
block|{
name|ifp
operator|->
name|if_ipackets
operator|+=
name|le32toh
argument_list|(
name|sp
operator|->
name|rx_good
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_idle_secs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Receiver's been idle for another second. 		 */
name|sc
operator|->
name|rx_idle_secs
operator|++
expr_stmt|;
block|}
name|ifp
operator|->
name|if_ierrors
operator|+=
name|le32toh
argument_list|(
name|sp
operator|->
name|rx_crc_errors
argument_list|)
operator|+
name|le32toh
argument_list|(
name|sp
operator|->
name|rx_alignment_errors
argument_list|)
operator|+
name|le32toh
argument_list|(
name|sp
operator|->
name|rx_rnr_errors
argument_list|)
operator|+
name|le32toh
argument_list|(
name|sp
operator|->
name|rx_overrun_errors
argument_list|)
expr_stmt|;
comment|/* 	 * If any transmit underruns occured, bump up the transmit 	 * threshold by another 512 bytes (64 * 8). 	 */
if|if
condition|(
name|sp
operator|->
name|tx_underruns
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|+=
name|le32toh
argument_list|(
name|sp
operator|->
name|tx_underruns
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_threshold
operator|<
literal|192
condition|)
name|tx_threshold
operator|+=
literal|64
expr_stmt|;
block|}
comment|/* 	 * Release any xmit buffers that have completed DMA. This isn't 	 * strictly necessary to do here, but it's advantagous for mbufs 	 * with external storage to be released in a timely manner rather 	 * than being defered for a potentially long time. This limits 	 * the delay to a maximum of one second. 	 */
name|fxp_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If we haven't received any packets in FXP_MAC_RX_IDLE seconds, 	 * then assume the receiver has locked up and attempt to clear 	 * the condition by reprogramming the multicast filter. This is 	 * a work-around for a bug in the 82557 where the receiver locks 	 * up if it gets certain types of garbage in the syncronization 	 * bits prior to the packet header. This bug is supposed to only 	 * occur in 10Mbps mode, but has been seen to occur in 100Mbps 	 * mode as well (perhaps due to a 10/100 speed transition). 	 */
if|if
condition|(
name|sc
operator|->
name|rx_idle_secs
operator|>
name|FXP_MAX_RX_IDLE
condition|)
block|{
name|sc
operator|->
name|rx_idle_secs
operator|=
literal|0
expr_stmt|;
name|fxp_mc_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there is no pending command, start another stats 	 * dump. Otherwise punt for now. 	 */
if|if
condition|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_COMMAND
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Start another stats dump. 		 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fxp_stag
argument_list|,
name|sc
operator|->
name|fxp_smap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_DUMPRESET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * A previous command is still waiting to be accepted. 		 * Just zero our copy of the stats and wait for the 		 * next timer event to update them. 		 */
name|sp
operator|->
name|tx_good
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|tx_underruns
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|tx_total_collisions
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_good
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_crc_errors
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_alignment_errors
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_rnr_errors
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_overrun_errors
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|miibus
operator|!=
name|NULL
condition|)
name|mii_tick
argument_list|(
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule another timeout one second from now. 	 */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|,
name|hz
argument_list|,
name|fxp_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop the interface. Cancels the statistics updater and resets  * the interface.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_stop
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|fxp_tx
modifier|*
name|txp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Cancel stats updater. 	 */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|)
expr_stmt|;
comment|/* 	 * Issue software reset, which also unloads the microcode. 	 */
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FXP_FLAG_UCODE
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_PORT
argument_list|,
name|FXP_PORT_SOFTWARE_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* 	 * Release any xmit buffers. 	 */
name|txp
operator|=
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_list
expr_stmt|;
if|if
condition|(
name|txp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NTXCB
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|txp
index|[
name|i
index|]
operator|.
name|tx_mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|txp
index|[
name|i
index|]
operator|.
name|tx_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|txp
index|[
name|i
index|]
operator|.
name|tx_map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txp
index|[
name|i
index|]
operator|.
name|tx_mbuf
argument_list|)
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|tx_mbuf
operator|=
name|NULL
expr_stmt|;
comment|/* clear this to reset csum offload bits */
name|txp
index|[
name|i
index|]
operator|.
name|tx_cb
operator|->
name|tbd
index|[
literal|0
index|]
operator|.
name|tb_addr
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Watchdog/transmission transmit timeout handler. Called when a  * transmission is started on the interface, but no interrupt is  * received before the timeout. This usually indicates that the  * card has wedged for some reason.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|fxp_init_body
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Acquire locks and then call the real initialization function.  This  * is necessary because ether_ioctl() calls if_init() and this would  * result in mutex recursion if the mutex was held.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fxp_init_body
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform device initialization. This routine must be called with the  * softc lock held.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_init_body
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|fxp_cb_config
modifier|*
name|cbp
decl_stmt|;
name|struct
name|fxp_cb_ias
modifier|*
name|cb_ias
decl_stmt|;
name|struct
name|fxp_cb_tx
modifier|*
name|tcbp
decl_stmt|;
name|struct
name|fxp_tx
modifier|*
name|txp
decl_stmt|;
name|struct
name|fxp_cb_mcs
modifier|*
name|mcsp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|prm
decl_stmt|;
name|FXP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Cancel any pending I/O 	 */
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|prm
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 	 * Initialize base of CBL and RFA memory. Loading with zero 	 * sets it up for regular linear addressing. 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_BASE
argument_list|)
expr_stmt|;
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_RU_BASE
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize base of dump-stats buffer. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fxp_stag
argument_list|,
name|sc
operator|->
name|fxp_smap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|sc
operator|->
name|stats_addr
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_DUMP_ADR
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to load microcode if requested. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|&&
operator|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_UCODE
operator|)
operator|==
literal|0
condition|)
name|fxp_load_ucode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the multicast address list. 	 */
if|if
condition|(
name|fxp_mc_addrs
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mcsp
operator|=
name|sc
operator|->
name|mcsp
expr_stmt|;
name|mcsp
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|mcsp
operator|->
name|cb_command
operator|=
name|htole16
argument_list|(
name|FXP_CB_COMMAND_MCAS
operator||
name|FXP_CB_COMMAND_EL
argument_list|)
expr_stmt|;
name|mcsp
operator|->
name|link_addr
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* 	 	 * Start the multicast setup command. 		 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mcs_tag
argument_list|,
name|sc
operator|->
name|mcs_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|sc
operator|->
name|mcs_addr
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_START
argument_list|)
expr_stmt|;
comment|/* ...and wait for it to complete. */
name|fxp_dma_wait
argument_list|(
name|sc
argument_list|,
operator|&
name|mcsp
operator|->
name|cb_status
argument_list|,
name|sc
operator|->
name|mcs_tag
argument_list|,
name|sc
operator|->
name|mcs_map
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mcs_tag
argument_list|,
name|sc
operator|->
name|mcs_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We temporarily use memory that contains the TxCB list to 	 * construct the config CB. The TxCB list memory is rebuilt 	 * later. 	 */
name|cbp
operator|=
operator|(
expr|struct
name|fxp_cb_config
operator|*
operator|)
name|sc
operator|->
name|fxp_desc
operator|.
name|cbl_list
expr_stmt|;
comment|/* 	 * This bcopy is kind of disgusting, but there are a bunch of must be 	 * zero and must be one bits in this structure and this is the easiest 	 * way to initialize them all to proper values. 	 */
name|bcopy
argument_list|(
name|fxp_cb_config_template
argument_list|,
name|cbp
argument_list|,
sizeof|sizeof
argument_list|(
name|fxp_cb_config_template
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|cb_command
operator|=
name|htole16
argument_list|(
name|FXP_CB_COMMAND_CONFIG
operator||
name|FXP_CB_COMMAND_EL
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|link_addr
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* (no) next command */
name|cbp
operator|->
name|byte_count
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_EXT_RFA
condition|?
literal|32
else|:
literal|22
expr_stmt|;
name|cbp
operator|->
name|rx_fifo_limit
operator|=
literal|8
expr_stmt|;
comment|/* rx fifo threshold (32 bytes) */
name|cbp
operator|->
name|tx_fifo_limit
operator|=
literal|0
expr_stmt|;
comment|/* tx fifo threshold (0 bytes) */
name|cbp
operator|->
name|adaptive_ifs
operator|=
literal|0
expr_stmt|;
comment|/* (no) adaptive interframe spacing */
name|cbp
operator|->
name|mwi_enable
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_MWI_ENABLE
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cbp
operator|->
name|type_enable
operator|=
literal|0
expr_stmt|;
comment|/* actually reserved */
name|cbp
operator|->
name|read_align_en
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_READ_ALIGN
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cbp
operator|->
name|end_wr_on_cl
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_WRITE_ALIGN
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cbp
operator|->
name|rx_dma_bytecount
operator|=
literal|0
expr_stmt|;
comment|/* (no) rx DMA max */
name|cbp
operator|->
name|tx_dma_bytecount
operator|=
literal|0
expr_stmt|;
comment|/* (no) tx DMA max */
name|cbp
operator|->
name|dma_mbce
operator|=
literal|0
expr_stmt|;
comment|/* (disable) dma max counters */
name|cbp
operator|->
name|late_scb
operator|=
literal|0
expr_stmt|;
comment|/* (don't) defer SCB update */
name|cbp
operator|->
name|direct_dma_dis
operator|=
literal|1
expr_stmt|;
comment|/* disable direct rcv dma mode */
name|cbp
operator|->
name|tno_int_or_tco_en
operator|=
literal|0
expr_stmt|;
comment|/* (disable) tx not okay interrupt */
name|cbp
operator|->
name|ci_int
operator|=
literal|1
expr_stmt|;
comment|/* interrupt on CU idle */
name|cbp
operator|->
name|ext_txcb_dis
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_EXT_TXCB
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|cbp
operator|->
name|ext_stats_dis
operator|=
literal|1
expr_stmt|;
comment|/* disable extended counters */
name|cbp
operator|->
name|keep_overrun_rx
operator|=
literal|0
expr_stmt|;
comment|/* don't pass overrun frames to host */
name|cbp
operator|->
name|save_bf
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_SAVE_BAD
condition|?
literal|1
else|:
name|prm
expr_stmt|;
name|cbp
operator|->
name|disc_short_rx
operator|=
operator|!
name|prm
expr_stmt|;
comment|/* discard short packets */
name|cbp
operator|->
name|underrun_retry
operator|=
literal|1
expr_stmt|;
comment|/* retry mode (once) on DMA underrun */
name|cbp
operator|->
name|two_frames
operator|=
literal|0
expr_stmt|;
comment|/* do not limit FIFO to 2 frames */
name|cbp
operator|->
name|dyn_tbd
operator|=
literal|0
expr_stmt|;
comment|/* (no) dynamic TBD mode */
name|cbp
operator|->
name|ext_rfa
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_EXT_RFA
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cbp
operator|->
name|mediatype
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_SERIAL_MEDIA
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|cbp
operator|->
name|csma_dis
operator|=
literal|0
expr_stmt|;
comment|/* (don't) disable link */
name|cbp
operator|->
name|tcp_udp_cksum
operator|=
literal|0
expr_stmt|;
comment|/* (don't) enable checksum */
name|cbp
operator|->
name|vlan_tco
operator|=
literal|0
expr_stmt|;
comment|/* (don't) enable vlan wakeup */
name|cbp
operator|->
name|link_wake_en
operator|=
literal|0
expr_stmt|;
comment|/* (don't) assert PME# on link change */
name|cbp
operator|->
name|arp_wake_en
operator|=
literal|0
expr_stmt|;
comment|/* (don't) assert PME# on arp */
name|cbp
operator|->
name|mc_wake_en
operator|=
literal|0
expr_stmt|;
comment|/* (don't) enable PME# on mcmatch */
name|cbp
operator|->
name|nsai
operator|=
literal|1
expr_stmt|;
comment|/* (don't) disable source addr insert */
name|cbp
operator|->
name|preamble_length
operator|=
literal|2
expr_stmt|;
comment|/* (7 byte) preamble */
name|cbp
operator|->
name|loopback
operator|=
literal|0
expr_stmt|;
comment|/* (don't) loopback */
name|cbp
operator|->
name|linear_priority
operator|=
literal|0
expr_stmt|;
comment|/* (normal CSMA/CD operation) */
name|cbp
operator|->
name|linear_pri_mode
operator|=
literal|0
expr_stmt|;
comment|/* (wait after xmit only) */
name|cbp
operator|->
name|interfrm_spacing
operator|=
literal|6
expr_stmt|;
comment|/* (96 bits of) interframe spacing */
name|cbp
operator|->
name|promiscuous
operator|=
name|prm
expr_stmt|;
comment|/* promiscuous mode */
name|cbp
operator|->
name|bcast_disable
operator|=
literal|0
expr_stmt|;
comment|/* (don't) disable broadcasts */
name|cbp
operator|->
name|wait_after_win
operator|=
literal|0
expr_stmt|;
comment|/* (don't) enable modified backoff alg*/
name|cbp
operator|->
name|ignore_ul
operator|=
literal|0
expr_stmt|;
comment|/* consider U/L bit in IA matching */
name|cbp
operator|->
name|crc16_en
operator|=
literal|0
expr_stmt|;
comment|/* (don't) enable crc-16 algorithm */
name|cbp
operator|->
name|crscdt
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_SERIAL_MEDIA
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cbp
operator|->
name|stripping
operator|=
operator|!
name|prm
expr_stmt|;
comment|/* truncate rx packet to byte count */
name|cbp
operator|->
name|padding
operator|=
literal|1
expr_stmt|;
comment|/* (do) pad short tx packets */
name|cbp
operator|->
name|rcv_crc_xfer
operator|=
literal|0
expr_stmt|;
comment|/* (don't) xfer CRC to host */
name|cbp
operator|->
name|long_rx_en
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_LONG_PKT_EN
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cbp
operator|->
name|ia_wake_en
operator|=
literal|0
expr_stmt|;
comment|/* (don't) wake up on address match */
name|cbp
operator|->
name|magic_pkt_dis
operator|=
literal|0
expr_stmt|;
comment|/* (don't) disable magic packet */
comment|/* must set wake_en in PMCSR also */
name|cbp
operator|->
name|force_fdx
operator|=
literal|0
expr_stmt|;
comment|/* (don't) force full duplex */
name|cbp
operator|->
name|fdx_pin_en
operator|=
literal|1
expr_stmt|;
comment|/* (enable) FDX# pin */
name|cbp
operator|->
name|multi_ia
operator|=
literal|0
expr_stmt|;
comment|/* (don't) accept multiple IAs */
name|cbp
operator|->
name|mc_all
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_ALL_MCAST
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cbp
operator|->
name|gamla_rx
operator|=
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_EXT_RFA
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tunable_noflow
operator|||
name|sc
operator|->
name|revision
operator|==
name|FXP_REV_82557
condition|)
block|{
comment|/* 		 * The 82557 has no hardware flow control, the values 		 * below are the defaults for the chip. 		 */
name|cbp
operator|->
name|fc_delay_lsb
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|fc_delay_msb
operator|=
literal|0x40
expr_stmt|;
name|cbp
operator|->
name|pri_fc_thresh
operator|=
literal|3
expr_stmt|;
name|cbp
operator|->
name|tx_fc_dis
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|rx_fc_restop
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|rx_fc_restart
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|fc_filter
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|pri_fc_loc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cbp
operator|->
name|fc_delay_lsb
operator|=
literal|0x1f
expr_stmt|;
name|cbp
operator|->
name|fc_delay_msb
operator|=
literal|0x01
expr_stmt|;
name|cbp
operator|->
name|pri_fc_thresh
operator|=
literal|3
expr_stmt|;
name|cbp
operator|->
name|tx_fc_dis
operator|=
literal|0
expr_stmt|;
comment|/* enable transmit FC */
name|cbp
operator|->
name|rx_fc_restop
operator|=
literal|1
expr_stmt|;
comment|/* enable FC restop frames */
name|cbp
operator|->
name|rx_fc_restart
operator|=
literal|1
expr_stmt|;
comment|/* enable FC restart frames */
name|cbp
operator|->
name|fc_filter
operator|=
operator|!
name|prm
expr_stmt|;
comment|/* drop FC frames to host */
name|cbp
operator|->
name|pri_fc_loc
operator|=
literal|1
expr_stmt|;
comment|/* FC pri location (byte31) */
block|}
comment|/* 	 * Start the config command/DMA. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|sc
operator|->
name|fxp_desc
operator|.
name|cbl_addr
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_START
argument_list|)
expr_stmt|;
comment|/* ...and wait for it to complete. */
name|fxp_dma_wait
argument_list|(
name|sc
argument_list|,
operator|&
name|cbp
operator|->
name|cb_status
argument_list|,
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Now initialize the station address. Temporarily use the TxCB 	 * memory area like we did above for the config CB. 	 */
name|cb_ias
operator|=
operator|(
expr|struct
name|fxp_cb_ias
operator|*
operator|)
name|sc
operator|->
name|fxp_desc
operator|.
name|cbl_list
expr_stmt|;
name|cb_ias
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|cb_ias
operator|->
name|cb_command
operator|=
name|htole16
argument_list|(
name|FXP_CB_COMMAND_IAS
operator||
name|FXP_CB_COMMAND_EL
argument_list|)
expr_stmt|;
name|cb_ias
operator|->
name|link_addr
operator|=
literal|0xffffffff
expr_stmt|;
name|bcopy
argument_list|(
name|IFP2ENADDR
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
name|cb_ias
operator|->
name|macaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|IFP2ENADDR
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Start the IAS (Individual Address Setup) command/DMA. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_START
argument_list|)
expr_stmt|;
comment|/* ...and wait for it to complete. */
name|fxp_dma_wait
argument_list|(
name|sc
argument_list|,
operator|&
name|cb_ias
operator|->
name|cb_status
argument_list|,
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize transmit control block (TxCB) list. 	 */
name|txp
operator|=
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_list
expr_stmt|;
name|tcbp
operator|=
name|sc
operator|->
name|fxp_desc
operator|.
name|cbl_list
expr_stmt|;
name|bzero
argument_list|(
name|tcbp
argument_list|,
name|FXP_TXCB_SZ
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NTXCB
condition|;
name|i
operator|++
control|)
block|{
name|txp
index|[
name|i
index|]
operator|.
name|tx_mbuf
operator|=
name|NULL
expr_stmt|;
name|tcbp
index|[
name|i
index|]
operator|.
name|cb_status
operator|=
name|htole16
argument_list|(
name|FXP_CB_STATUS_C
operator||
name|FXP_CB_STATUS_OK
argument_list|)
expr_stmt|;
name|tcbp
index|[
name|i
index|]
operator|.
name|cb_command
operator|=
name|htole16
argument_list|(
name|FXP_CB_COMMAND_NOP
argument_list|)
expr_stmt|;
name|tcbp
index|[
name|i
index|]
operator|.
name|link_addr
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|fxp_desc
operator|.
name|cbl_addr
operator|+
operator|(
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|FXP_TXCB_MASK
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_cb_tx
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_EXT_TXCB
condition|)
name|tcbp
index|[
name|i
index|]
operator|.
name|tbd_array_addr
operator|=
name|htole32
argument_list|(
name|FXP_TXCB_DMA_ADDR
argument_list|(
name|sc
argument_list|,
operator|&
name|tcbp
index|[
name|i
index|]
operator|.
name|tbd
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tcbp
index|[
name|i
index|]
operator|.
name|tbd_array_addr
operator|=
name|htole32
argument_list|(
name|FXP_TXCB_DMA_ADDR
argument_list|(
name|sc
argument_list|,
operator|&
name|tcbp
index|[
name|i
index|]
operator|.
name|tbd
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|tx_next
operator|=
operator|&
name|txp
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|FXP_TXCB_MASK
index|]
expr_stmt|;
block|}
comment|/* 	 * Set the suspend flag on the first TxCB and start the control 	 * unit. It will execute the NOP and then suspend. 	 */
name|tcbp
operator|->
name|cb_command
operator|=
name|htole16
argument_list|(
name|FXP_CB_COMMAND_NOP
operator||
name|FXP_CB_COMMAND_S
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_first
operator|=
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_last
operator|=
name|txp
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|=
literal|1
expr_stmt|;
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_START
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize receiver buffer area - RFA. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|sc
operator|->
name|fxp_desc
operator|.
name|rx_head
operator|->
name|rx_addr
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_RU_START
argument_list|)
expr_stmt|;
comment|/* 	 * Set current media. 	 */
if|if
condition|(
name|sc
operator|->
name|miibus
operator|!=
name|NULL
condition|)
name|mii_mediachg
argument_list|(
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
comment|/* 	 * Enable interrupts. 	 */
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* 	 * ... but only do that if we are not polling. And because (presumably) 	 * the default is interrupts on, we need to disable them explicitly! 	 */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_INTRCNTL
argument_list|,
name|FXP_SCB_INTR_DISABLE
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* DEVICE_POLLING */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_INTRCNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Start stats updater. 	 */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|,
name|hz
argument_list|,
name|fxp_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fxp_serial_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_serial_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_MANUAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change media according to request.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Notify the world which media we're using.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
if|if
condition|(
name|ifmr
operator|->
name|ifm_status
operator|&
name|IFM_10_T
operator|&&
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_CU_RESUME_BUG
condition|)
name|sc
operator|->
name|cu_resume_bug
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|cu_resume_bug
operator|=
literal|0
expr_stmt|;
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a buffer to the end of the RFA buffer list.  * Return 0 if successful, 1 for failure. A failure results in  * adding the 'oldm' (if non-NULL) on to the end of the list -  * tossing out its old contents and recycling it.  * The RFA struct is stuck at the beginning of mbuf cluster and the  * data pointer is fixed up to point just past it.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_add_rfabuf
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|fxp_rx
modifier|*
name|rxp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|fxp_rfa
modifier|*
name|rfa
decl_stmt|,
modifier|*
name|p_rfa
decl_stmt|;
name|struct
name|fxp_rx
modifier|*
name|p_rx
decl_stmt|;
name|bus_dmamap_t
name|tmp_map
decl_stmt|;
name|int
name|error
decl_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* 	 * Move the data pointer up so that the incoming data packet 	 * will be 32-bit aligned. 	 */
name|m
operator|->
name|m_data
operator|+=
name|RFA_ALIGNMENT_FUDGE
expr_stmt|;
comment|/* 	 * Get a pointer to the base of the mbuf cluster and move 	 * data start past it. 	 */
name|rfa
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|fxp_rfa
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|sc
operator|->
name|rfa_size
expr_stmt|;
name|rfa
operator|->
name|size
operator|=
name|htole16
argument_list|(
name|MCLBYTES
operator|-
name|sc
operator|->
name|rfa_size
operator|-
name|RFA_ALIGNMENT_FUDGE
argument_list|)
expr_stmt|;
name|rfa
operator|->
name|rfa_status
operator|=
literal|0
expr_stmt|;
name|rfa
operator|->
name|rfa_control
operator|=
name|htole16
argument_list|(
name|FXP_RFA_CONTROL_EL
argument_list|)
expr_stmt|;
name|rfa
operator|->
name|actual_size
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize the rest of the RFA.  Note that since the RFA 	 * is misaligned, we cannot store values directly.  We're thus 	 * using the le32enc() function which handles endianness and 	 * is also alignment-safe. 	 */
name|le32enc
argument_list|(
operator|&
name|rfa
operator|->
name|link_addr
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
operator|&
name|rfa
operator|->
name|rbd_addr
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Map the RFA into DMA memory. */
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|sc
operator|->
name|spare_map
argument_list|,
name|rfa
argument_list|,
name|MCLBYTES
operator|-
name|RFA_ALIGNMENT_FUDGE
argument_list|,
name|fxp_dma_map_addr
argument_list|,
operator|&
name|rxp
operator|->
name|rx_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|rxp
operator|->
name|rx_map
argument_list|)
expr_stmt|;
name|tmp_map
operator|=
name|sc
operator|->
name|spare_map
expr_stmt|;
name|sc
operator|->
name|spare_map
operator|=
name|rxp
operator|->
name|rx_map
expr_stmt|;
name|rxp
operator|->
name|rx_map
operator|=
name|tmp_map
expr_stmt|;
name|rxp
operator|->
name|rx_mbuf
operator|=
name|m
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|rxp
operator|->
name|rx_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * If there are other buffers already on the list, attach this 	 * one to the end by fixing up the tail to point to this one. 	 */
if|if
condition|(
name|sc
operator|->
name|fxp_desc
operator|.
name|rx_head
operator|!=
name|NULL
condition|)
block|{
name|p_rx
operator|=
name|sc
operator|->
name|fxp_desc
operator|.
name|rx_tail
expr_stmt|;
name|p_rfa
operator|=
operator|(
expr|struct
name|fxp_rfa
operator|*
operator|)
operator|(
name|p_rx
operator|->
name|rx_mbuf
operator|->
name|m_ext
operator|.
name|ext_buf
operator|+
name|RFA_ALIGNMENT_FUDGE
operator|)
expr_stmt|;
name|p_rx
operator|->
name|rx_next
operator|=
name|rxp
expr_stmt|;
name|le32enc
argument_list|(
operator|&
name|p_rfa
operator|->
name|link_addr
argument_list|,
name|rxp
operator|->
name|rx_addr
argument_list|)
expr_stmt|;
name|p_rfa
operator|->
name|rfa_control
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fxp_mtag
argument_list|,
name|p_rx
operator|->
name|rx_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rxp
operator|->
name|rx_next
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|fxp_desc
operator|.
name|rx_head
operator|=
name|rxp
expr_stmt|;
block|}
name|sc
operator|->
name|fxp_desc
operator|.
name|rx_tail
operator|=
name|rxp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|volatile
name|int
name|fxp_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|10000
decl_stmt|;
name|int
name|value
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_MDICONTROL
argument_list|,
operator|(
name|FXP_MDI_READ
operator|<<
literal|26
operator|)
operator||
operator|(
name|reg
operator|<<
literal|16
operator|)
operator||
operator|(
name|phy
operator|<<
literal|21
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|value
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_MDICONTROL
argument_list|)
operator|)
operator|&
literal|0x10000000
operator|)
operator|==
literal|0
operator|&&
name|count
operator|--
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"fxp_miibus_readreg: timed out\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|&
literal|0xffff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|10000
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_MDICONTROL
argument_list|,
operator|(
name|FXP_MDI_WRITE
operator|<<
literal|26
operator|)
operator||
operator|(
name|reg
operator|<<
literal|16
operator|)
operator||
operator|(
name|phy
operator|<<
literal|21
operator|)
operator||
operator|(
name|value
operator|&
literal|0xffff
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_MDICONTROL
argument_list|)
operator|&
literal|0x10000000
operator|)
operator|==
literal|0
operator|&&
name|count
operator|--
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"fxp_miibus_writereg: timed out\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fxp_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_ALL_MCAST
expr_stmt|;
else|else
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FXP_FLAG_ALL_MCAST
expr_stmt|;
comment|/* 		 * If interface is marked up and not running, then start it. 		 * If it is marked down and running, stop it. 		 * XXX If it's up then re-initialize it. This is so flags 		 * such as IFF_PROMISC are handled. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|fxp_init_body
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_ALL_MCAST
expr_stmt|;
else|else
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FXP_FLAG_ALL_MCAST
expr_stmt|;
comment|/* 		 * Multicast list has changed; set the hardware filter 		 * accordingly. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_ALL_MCAST
operator|)
operator|==
literal|0
condition|)
name|fxp_mc_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * fxp_mc_setup() can set FXP_FLAG_ALL_MCAST, so check it 		 * again rather than else {}. 		 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_ALL_MCAST
condition|)
name|fxp_init_body
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
if|if
condition|(
name|sc
operator|->
name|miibus
operator|!=
name|NULL
condition|)
block|{
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifp
operator|->
name|if_capenable
operator|^
name|ifr
operator|->
name|ifr_reqcap
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|mask
operator|&
name|IFCAP_POLLING
condition|)
block|{
if|if
condition|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|error
operator|=
name|ether_poll_register
argument_list|(
name|fxp_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_INTRCNTL
argument_list|,
name|FXP_SCB_INTR_DISABLE
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING
expr_stmt|;
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Enable interrupts in any case */
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_INTRCNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_POLLING
expr_stmt|;
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_MTU
condition|)
block|{
name|FXP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_MTU
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|revision
operator|!=
name|FXP_REV_82557
condition|)
name|flag
operator|=
name|FXP_FLAG_LONG_PKT_EN
expr_stmt|;
else|else
comment|/* a hack to get long frames on the old chip */
name|flag
operator|=
name|FXP_FLAG_SAVE_BAD
expr_stmt|;
name|sc
operator|->
name|flags
operator|^=
name|flag
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|fxp_init_body
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|FXP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in the multicast address list and return number of entries.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_mc_addrs
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|fxp_cb_mcs
modifier|*
name|mcsp
init|=
name|sc
operator|->
name|mcsp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|int
name|nmcasts
decl_stmt|;
name|nmcasts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FXP_FLAG_ALL_MCAST
operator|)
operator|==
literal|0
condition|)
block|{
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|nmcasts
operator|>=
name|MAXMCADDR
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_ALL_MCAST
expr_stmt|;
name|nmcasts
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|mcsp
operator|->
name|mc_addr
index|[
name|nmcasts
index|]
index|[
literal|0
index|]
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|nmcasts
operator|++
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|mcsp
operator|->
name|mc_cnt
operator|=
name|htole16
argument_list|(
name|nmcasts
operator|*
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|nmcasts
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Program the multicast filter.  *  * We have an artificial restriction that the multicast setup command  * must be the first command in the chain, so we take steps to ensure  * this. By requiring this, it allows us to keep up the performance of  * the pre-initialized command ring (esp. link pointers) by not actually  * inserting the mcsetup command in the ring - i.e. its link pointer  * points to the TxCB ring, but the mcsetup descriptor itself is not part  * of it. We then can do 'CU_START' on the mcsetup descriptor and have it  * lead into the regular TxCB ring when it completes.  *  * This function must be called at splimp.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_mc_setup
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|fxp_cb_mcs
modifier|*
name|mcsp
init|=
name|sc
operator|->
name|mcsp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|fxp_tx
modifier|*
name|txp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|FXP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * If there are queued commands, we must wait until they are all 	 * completed. If we are already waiting, then add a NOP command 	 * with interrupt option so that we're notified when all commands 	 * have been completed - fxp_start() ensures that no additional 	 * TX commands will be added when need_mcsetup is true. 	 */
if|if
condition|(
name|sc
operator|->
name|tx_queued
condition|)
block|{
comment|/* 		 * need_mcsetup will be true if we are already waiting for the 		 * NOP command to be completed (see below). In this case, bail. 		 */
if|if
condition|(
name|sc
operator|->
name|need_mcsetup
condition|)
return|return;
name|sc
operator|->
name|need_mcsetup
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Add a NOP command with interrupt so that we are notified 		 * when all TX commands have been processed. 		 */
name|txp
operator|=
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_last
operator|->
name|tx_next
expr_stmt|;
name|txp
operator|->
name|tx_mbuf
operator|=
name|NULL
expr_stmt|;
name|txp
operator|->
name|tx_cb
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|txp
operator|->
name|tx_cb
operator|->
name|cb_command
operator|=
name|htole16
argument_list|(
name|FXP_CB_COMMAND_NOP
operator||
name|FXP_CB_COMMAND_S
operator||
name|FXP_CB_COMMAND_I
argument_list|)
expr_stmt|;
comment|/* 		 * Advance the end of list forward. 		 */
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_last
operator|->
name|tx_cb
operator|->
name|cb_command
operator|&=
name|htole16
argument_list|(
operator|~
name|FXP_CB_COMMAND_S
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_last
operator|=
name|txp
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|++
expr_stmt|;
comment|/* 		 * Issue a resume in case the CU has just suspended. 		 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_RESUME
argument_list|)
expr_stmt|;
comment|/* 		 * Set a 5 second timer just in case we don't hear from the 		 * card again. 		 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|need_mcsetup
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize multicast setup descriptor. 	 */
name|mcsp
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|mcsp
operator|->
name|cb_command
operator|=
name|htole16
argument_list|(
name|FXP_CB_COMMAND_MCAS
operator||
name|FXP_CB_COMMAND_S
operator||
name|FXP_CB_COMMAND_I
argument_list|)
expr_stmt|;
name|mcsp
operator|->
name|link_addr
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|fxp_desc
operator|.
name|cbl_addr
argument_list|)
expr_stmt|;
name|txp
operator|=
operator|&
name|sc
operator|->
name|fxp_desc
operator|.
name|mcs_tx
expr_stmt|;
name|txp
operator|->
name|tx_mbuf
operator|=
name|NULL
expr_stmt|;
name|txp
operator|->
name|tx_cb
operator|=
operator|(
expr|struct
name|fxp_cb_tx
operator|*
operator|)
name|sc
operator|->
name|mcsp
expr_stmt|;
name|txp
operator|->
name|tx_next
operator|=
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_list
expr_stmt|;
operator|(
name|void
operator|)
name|fxp_mc_addrs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_first
operator|=
name|sc
operator|->
name|fxp_desc
operator|.
name|tx_last
operator|=
name|txp
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Wait until command unit is not active. This should never 	 * be the case when nothing is queued, but make sure anyway. 	 */
name|count
operator|=
literal|100
expr_stmt|;
while|while
condition|(
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_RUSCUS
argument_list|)
operator|>>
literal|6
operator|)
operator|==
name|FXP_SCB_CUS_ACTIVE
operator|&&
operator|--
name|count
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"command queue timeout\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Start the multicast setup command. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mcs_tag
argument_list|,
name|sc
operator|->
name|mcs_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|sc
operator|->
name|mcs_addr
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_START
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|uint32_t
name|fxp_ucode_d101a
index|[]
init|=
name|D101_A_RCVBUNDLE_UCODE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|fxp_ucode_d101b0
index|[]
init|=
name|D101_B0_RCVBUNDLE_UCODE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|fxp_ucode_d101ma
index|[]
init|=
name|D101M_B_RCVBUNDLE_UCODE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|fxp_ucode_d101s
index|[]
init|=
name|D101S_RCVBUNDLE_UCODE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|fxp_ucode_d102
index|[]
init|=
name|D102_B_RCVBUNDLE_UCODE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|fxp_ucode_d102c
index|[]
init|=
name|D102_C_RCVBUNDLE_UCODE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|fxp_ucode_d102e
index|[]
init|=
name|D102_E_RCVBUNDLE_UCODE
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UCODE
parameter_list|(
name|x
parameter_list|)
value|x, sizeof(x)/sizeof(uint32_t)
end_define

begin_struct
struct|struct
name|ucode
block|{
name|uint32_t
name|revision
decl_stmt|;
name|uint32_t
modifier|*
name|ucode
decl_stmt|;
name|int
name|length
decl_stmt|;
name|u_short
name|int_delay_offset
decl_stmt|;
name|u_short
name|bundle_max_offset
decl_stmt|;
block|}
name|ucode_table
index|[]
init|=
block|{
block|{
name|FXP_REV_82558_A4
block|,
name|UCODE
argument_list|(
name|fxp_ucode_d101a
argument_list|)
block|,
name|D101_CPUSAVER_DWORD
block|,
literal|0
block|}
block|,
block|{
name|FXP_REV_82558_B0
block|,
name|UCODE
argument_list|(
name|fxp_ucode_d101b0
argument_list|)
block|,
name|D101_CPUSAVER_DWORD
block|,
literal|0
block|}
block|,
block|{
name|FXP_REV_82559_A0
block|,
name|UCODE
argument_list|(
name|fxp_ucode_d101ma
argument_list|)
block|,
name|D101M_CPUSAVER_DWORD
block|,
name|D101M_CPUSAVER_BUNDLE_MAX_DWORD
block|}
block|,
block|{
name|FXP_REV_82559S_A
block|,
name|UCODE
argument_list|(
name|fxp_ucode_d101s
argument_list|)
block|,
name|D101S_CPUSAVER_DWORD
block|,
name|D101S_CPUSAVER_BUNDLE_MAX_DWORD
block|}
block|,
block|{
name|FXP_REV_82550
block|,
name|UCODE
argument_list|(
name|fxp_ucode_d102
argument_list|)
block|,
name|D102_B_CPUSAVER_DWORD
block|,
name|D102_B_CPUSAVER_BUNDLE_MAX_DWORD
block|}
block|,
block|{
name|FXP_REV_82550_C
block|,
name|UCODE
argument_list|(
name|fxp_ucode_d102c
argument_list|)
block|,
name|D102_C_CPUSAVER_DWORD
block|,
name|D102_C_CPUSAVER_BUNDLE_MAX_DWORD
block|}
block|,
block|{
name|FXP_REV_82551_F
block|,
name|UCODE
argument_list|(
name|fxp_ucode_d102e
argument_list|)
block|,
name|D102_E_CPUSAVER_DWORD
block|,
name|D102_E_CPUSAVER_BUNDLE_MAX_DWORD
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|fxp_load_ucode
parameter_list|(
name|struct
name|fxp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ucode
modifier|*
name|uc
decl_stmt|;
name|struct
name|fxp_cb_ucode
modifier|*
name|cbp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|uc
operator|=
name|ucode_table
init|;
name|uc
operator|->
name|ucode
operator|!=
name|NULL
condition|;
name|uc
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|revision
operator|==
name|uc
operator|->
name|revision
condition|)
break|break;
if|if
condition|(
name|uc
operator|->
name|ucode
operator|==
name|NULL
condition|)
return|return;
name|cbp
operator|=
operator|(
expr|struct
name|fxp_cb_ucode
operator|*
operator|)
name|sc
operator|->
name|fxp_desc
operator|.
name|cbl_list
expr_stmt|;
name|cbp
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|cb_command
operator|=
name|htole16
argument_list|(
name|FXP_CB_COMMAND_UCODE
operator||
name|FXP_CB_COMMAND_EL
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|link_addr
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* (no) next command */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uc
operator|->
name|length
condition|;
name|i
operator|++
control|)
name|cbp
operator|->
name|ucode
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|uc
operator|->
name|ucode
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|->
name|int_delay_offset
condition|)
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|cbp
operator|->
name|ucode
index|[
name|uc
operator|->
name|int_delay_offset
index|]
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|tunable_int_delay
operator|+
name|sc
operator|->
name|tunable_int_delay
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|->
name|bundle_max_offset
condition|)
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|cbp
operator|->
name|ucode
index|[
name|uc
operator|->
name|bundle_max_offset
index|]
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|tunable_bundle_max
argument_list|)
expr_stmt|;
comment|/* 	 * Download the ucode to the chip. 	 */
name|fxp_scb_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|FXP_CSR_SCB_GENERAL
argument_list|,
name|sc
operator|->
name|fxp_desc
operator|.
name|cbl_addr
argument_list|)
expr_stmt|;
name|fxp_scb_cmd
argument_list|(
name|sc
argument_list|,
name|FXP_SCB_COMMAND_CU_START
argument_list|)
expr_stmt|;
comment|/* ...and wait for it to complete. */
name|fxp_dma_wait
argument_list|(
name|sc
argument_list|,
operator|&
name|cbp
operator|->
name|cb_status
argument_list|,
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cbl_tag
argument_list|,
name|sc
operator|->
name|cbl_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Microcode loaded, int_delay: %d usec  bundle_max: %d\n"
argument_list|,
name|sc
operator|->
name|tunable_int_delay
argument_list|,
name|uc
operator|->
name|bundle_max_offset
operator|==
literal|0
condition|?
literal|0
else|:
name|sc
operator|->
name|tunable_bundle_max
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|FXP_FLAG_UCODE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_int_range
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|,
name|int
name|low
parameter_list|,
name|int
name|high
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|value
decl_stmt|;
name|value
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|value
operator|<
name|low
operator|||
name|value
operator|>
name|high
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt delay is expressed in microseconds, a multiplier is used  * to convert this to the appropriate clock ticks before using.   */
end_comment

begin_function
specifier|static
name|int
name|sysctl_hw_fxp_int_delay
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_int_range
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
literal|300
argument_list|,
literal|3000
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_fxp_bundle_max
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_int_range
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
literal|1
argument_list|,
literal|0xffff
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

