begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Â© 2006 Intel Corporation  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  * Authors:  *    Eric Anholt<eric@anholt.net>  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_dp_helper.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_bios.h>
end_include

begin_define
define|#
directive|define
name|SLAVE_ADDR1
value|0x70
end_define

begin_define
define|#
directive|define
name|SLAVE_ADDR2
value|0x72
end_define

begin_decl_stmt
specifier|static
name|int
name|panel_type
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|find_section
parameter_list|(
name|struct
name|bdb_header
modifier|*
name|bdb
parameter_list|,
name|int
name|section_id
parameter_list|)
block|{
name|u8
modifier|*
name|base
init|=
operator|(
name|u8
operator|*
operator|)
name|bdb
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|u16
name|total
decl_stmt|,
name|current_size
decl_stmt|;
name|u8
name|current_id
decl_stmt|;
comment|/* skip to first section */
name|index
operator|+=
name|bdb
operator|->
name|header_size
expr_stmt|;
name|total
operator|=
name|bdb
operator|->
name|bdb_size
expr_stmt|;
comment|/* walk the sections looking for section_id */
while|while
condition|(
name|index
operator|<
name|total
condition|)
block|{
name|current_id
operator|=
operator|*
operator|(
name|base
operator|+
name|index
operator|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
name|current_size
operator|=
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|(
name|base
operator|+
name|index
operator|)
operator|)
expr_stmt|;
name|index
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|current_id
operator|==
name|section_id
condition|)
return|return
name|base
operator|+
name|index
return|;
name|index
operator|+=
name|current_size
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|u16
name|get_blocksize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|u16
modifier|*
name|block_ptr
decl_stmt|,
name|block_size
decl_stmt|;
name|block_ptr
operator|=
operator|(
name|u16
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|-
literal|2
operator|)
expr_stmt|;
name|block_size
operator|=
operator|*
name|block_ptr
expr_stmt|;
return|return
name|block_size
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fill_detail_timing_data
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|panel_fixed_mode
parameter_list|,
specifier|const
name|struct
name|lvds_dvo_timing
modifier|*
name|dvo_timing
parameter_list|)
block|{
name|panel_fixed_mode
operator|->
name|hdisplay
operator|=
operator|(
name|dvo_timing
operator|->
name|hactive_hi
operator|<<
literal|8
operator|)
operator||
name|dvo_timing
operator|->
name|hactive_lo
expr_stmt|;
name|panel_fixed_mode
operator|->
name|hsync_start
operator|=
name|panel_fixed_mode
operator|->
name|hdisplay
operator|+
operator|(
operator|(
name|dvo_timing
operator|->
name|hsync_off_hi
operator|<<
literal|8
operator|)
operator||
name|dvo_timing
operator|->
name|hsync_off_lo
operator|)
expr_stmt|;
name|panel_fixed_mode
operator|->
name|hsync_end
operator|=
name|panel_fixed_mode
operator|->
name|hsync_start
operator|+
name|dvo_timing
operator|->
name|hsync_pulse_width
expr_stmt|;
name|panel_fixed_mode
operator|->
name|htotal
operator|=
name|panel_fixed_mode
operator|->
name|hdisplay
operator|+
operator|(
operator|(
name|dvo_timing
operator|->
name|hblank_hi
operator|<<
literal|8
operator|)
operator||
name|dvo_timing
operator|->
name|hblank_lo
operator|)
expr_stmt|;
name|panel_fixed_mode
operator|->
name|vdisplay
operator|=
operator|(
name|dvo_timing
operator|->
name|vactive_hi
operator|<<
literal|8
operator|)
operator||
name|dvo_timing
operator|->
name|vactive_lo
expr_stmt|;
name|panel_fixed_mode
operator|->
name|vsync_start
operator|=
name|panel_fixed_mode
operator|->
name|vdisplay
operator|+
name|dvo_timing
operator|->
name|vsync_off
expr_stmt|;
name|panel_fixed_mode
operator|->
name|vsync_end
operator|=
name|panel_fixed_mode
operator|->
name|vsync_start
operator|+
name|dvo_timing
operator|->
name|vsync_pulse_width
expr_stmt|;
name|panel_fixed_mode
operator|->
name|vtotal
operator|=
name|panel_fixed_mode
operator|->
name|vdisplay
operator|+
operator|(
operator|(
name|dvo_timing
operator|->
name|vblank_hi
operator|<<
literal|8
operator|)
operator||
name|dvo_timing
operator|->
name|vblank_lo
operator|)
expr_stmt|;
name|panel_fixed_mode
operator|->
name|clock
operator|=
name|dvo_timing
operator|->
name|clock
operator|*
literal|10
expr_stmt|;
name|panel_fixed_mode
operator|->
name|type
operator|=
name|DRM_MODE_TYPE_PREFERRED
expr_stmt|;
if|if
condition|(
name|dvo_timing
operator|->
name|hsync_positive
condition|)
name|panel_fixed_mode
operator|->
name|flags
operator||=
name|DRM_MODE_FLAG_PHSYNC
expr_stmt|;
else|else
name|panel_fixed_mode
operator|->
name|flags
operator||=
name|DRM_MODE_FLAG_NHSYNC
expr_stmt|;
if|if
condition|(
name|dvo_timing
operator|->
name|vsync_positive
condition|)
name|panel_fixed_mode
operator|->
name|flags
operator||=
name|DRM_MODE_FLAG_PVSYNC
expr_stmt|;
else|else
name|panel_fixed_mode
operator|->
name|flags
operator||=
name|DRM_MODE_FLAG_NVSYNC
expr_stmt|;
comment|/* Some VBTs have bogus h/vtotal values */
if|if
condition|(
name|panel_fixed_mode
operator|->
name|hsync_end
operator|>
name|panel_fixed_mode
operator|->
name|htotal
condition|)
name|panel_fixed_mode
operator|->
name|htotal
operator|=
name|panel_fixed_mode
operator|->
name|hsync_end
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|panel_fixed_mode
operator|->
name|vsync_end
operator|>
name|panel_fixed_mode
operator|->
name|vtotal
condition|)
name|panel_fixed_mode
operator|->
name|vtotal
operator|=
name|panel_fixed_mode
operator|->
name|vsync_end
operator|+
literal|1
expr_stmt|;
name|drm_mode_set_name
argument_list|(
name|panel_fixed_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|lvds_dvo_timing_equal_size
parameter_list|(
specifier|const
name|struct
name|lvds_dvo_timing
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|lvds_dvo_timing
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|hactive_hi
operator|!=
name|b
operator|->
name|hactive_hi
operator|||
name|a
operator|->
name|hactive_lo
operator|!=
name|b
operator|->
name|hactive_lo
condition|)
return|return
name|false
return|;
if|if
condition|(
name|a
operator|->
name|hsync_off_hi
operator|!=
name|b
operator|->
name|hsync_off_hi
operator|||
name|a
operator|->
name|hsync_off_lo
operator|!=
name|b
operator|->
name|hsync_off_lo
condition|)
return|return
name|false
return|;
if|if
condition|(
name|a
operator|->
name|hsync_pulse_width
operator|!=
name|b
operator|->
name|hsync_pulse_width
condition|)
return|return
name|false
return|;
if|if
condition|(
name|a
operator|->
name|hblank_hi
operator|!=
name|b
operator|->
name|hblank_hi
operator|||
name|a
operator|->
name|hblank_lo
operator|!=
name|b
operator|->
name|hblank_lo
condition|)
return|return
name|false
return|;
if|if
condition|(
name|a
operator|->
name|vactive_hi
operator|!=
name|b
operator|->
name|vactive_hi
operator|||
name|a
operator|->
name|vactive_lo
operator|!=
name|b
operator|->
name|vactive_lo
condition|)
return|return
name|false
return|;
if|if
condition|(
name|a
operator|->
name|vsync_off
operator|!=
name|b
operator|->
name|vsync_off
condition|)
return|return
name|false
return|;
if|if
condition|(
name|a
operator|->
name|vsync_pulse_width
operator|!=
name|b
operator|->
name|vsync_pulse_width
condition|)
return|return
name|false
return|;
if|if
condition|(
name|a
operator|->
name|vblank_hi
operator|!=
name|b
operator|->
name|vblank_hi
operator|||
name|a
operator|->
name|vblank_lo
operator|!=
name|b
operator|->
name|vblank_lo
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|lvds_dvo_timing
modifier|*
name|get_lvds_dvo_timing
parameter_list|(
specifier|const
name|struct
name|bdb_lvds_lfp_data
modifier|*
name|lvds_lfp_data
parameter_list|,
specifier|const
name|struct
name|bdb_lvds_lfp_data_ptrs
modifier|*
name|lvds_lfp_data_ptrs
parameter_list|,
name|int
name|index
parameter_list|)
block|{
comment|/* 	 * the size of fp_timing varies on the different platform. 	 * So calculate the DVO timing relative offset in LVDS data 	 * entry to get the DVO timing entry 	 */
name|int
name|lfp_data_size
init|=
name|lvds_lfp_data_ptrs
operator|->
name|ptr
index|[
literal|1
index|]
operator|.
name|dvo_timing_offset
operator|-
name|lvds_lfp_data_ptrs
operator|->
name|ptr
index|[
literal|0
index|]
operator|.
name|dvo_timing_offset
decl_stmt|;
name|int
name|dvo_timing_offset
init|=
name|lvds_lfp_data_ptrs
operator|->
name|ptr
index|[
literal|0
index|]
operator|.
name|dvo_timing_offset
operator|-
name|lvds_lfp_data_ptrs
operator|->
name|ptr
index|[
literal|0
index|]
operator|.
name|fp_timing_offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|lvds_lfp_data
operator|->
name|data
operator|+
name|lfp_data_size
operator|*
name|index
decl_stmt|;
return|return
operator|(
specifier|const
expr|struct
name|lvds_dvo_timing
operator|*
operator|)
operator|(
name|entry
operator|+
name|dvo_timing_offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get lvds_fp_timing entry  * this function may return NULL if the corresponding entry is invalid  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|lvds_fp_timing
modifier|*
name|get_lvds_fp_timing
parameter_list|(
specifier|const
name|struct
name|bdb_header
modifier|*
name|bdb
parameter_list|,
specifier|const
name|struct
name|bdb_lvds_lfp_data
modifier|*
name|data
parameter_list|,
specifier|const
name|struct
name|bdb_lvds_lfp_data_ptrs
modifier|*
name|ptrs
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|size_t
name|data_ofs
init|=
operator|(
specifier|const
name|u8
operator|*
operator|)
name|data
operator|-
operator|(
specifier|const
name|u8
operator|*
operator|)
name|bdb
decl_stmt|;
name|u16
name|data_size
init|=
operator|(
operator|(
specifier|const
name|u16
operator|*
operator|)
name|data
operator|)
index|[
operator|-
literal|1
index|]
decl_stmt|;
comment|/* stored in header */
name|size_t
name|ofs
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|DRM_ARRAY_SIZE
argument_list|(
name|ptrs
operator|->
name|ptr
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ofs
operator|=
name|ptrs
operator|->
name|ptr
index|[
name|index
index|]
operator|.
name|fp_timing_offset
expr_stmt|;
if|if
condition|(
name|ofs
operator|<
name|data_ofs
operator|||
name|ofs
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|lvds_fp_timing
argument_list|)
operator|>
name|data_ofs
operator|+
name|data_size
condition|)
return|return
name|NULL
return|;
return|return
operator|(
specifier|const
expr|struct
name|lvds_fp_timing
operator|*
operator|)
operator|(
operator|(
specifier|const
name|u8
operator|*
operator|)
name|bdb
operator|+
name|ofs
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Try to find integrated panel data */
end_comment

begin_function
specifier|static
name|void
name|parse_lfp_panel_data
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|bdb_header
modifier|*
name|bdb
parameter_list|)
block|{
specifier|const
name|struct
name|bdb_lvds_options
modifier|*
name|lvds_options
decl_stmt|;
specifier|const
name|struct
name|bdb_lvds_lfp_data
modifier|*
name|lvds_lfp_data
decl_stmt|;
specifier|const
name|struct
name|bdb_lvds_lfp_data_ptrs
modifier|*
name|lvds_lfp_data_ptrs
decl_stmt|;
specifier|const
name|struct
name|lvds_dvo_timing
modifier|*
name|panel_dvo_timing
decl_stmt|;
specifier|const
name|struct
name|lvds_fp_timing
modifier|*
name|fp_timing
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|panel_fixed_mode
decl_stmt|;
name|int
name|i
decl_stmt|,
name|downclock
decl_stmt|;
name|lvds_options
operator|=
name|find_section
argument_list|(
name|bdb
argument_list|,
name|BDB_LVDS_OPTIONS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lvds_options
condition|)
return|return;
name|dev_priv
operator|->
name|lvds_dither
operator|=
name|lvds_options
operator|->
name|pixel_dither
expr_stmt|;
if|if
condition|(
name|lvds_options
operator|->
name|panel_type
operator|==
literal|0xff
condition|)
return|return;
name|panel_type
operator|=
name|lvds_options
operator|->
name|panel_type
expr_stmt|;
name|lvds_lfp_data
operator|=
name|find_section
argument_list|(
name|bdb
argument_list|,
name|BDB_LVDS_LFP_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lvds_lfp_data
condition|)
return|return;
name|lvds_lfp_data_ptrs
operator|=
name|find_section
argument_list|(
name|bdb
argument_list|,
name|BDB_LVDS_LFP_DATA_PTRS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lvds_lfp_data_ptrs
condition|)
return|return;
name|dev_priv
operator|->
name|lvds_vbt
operator|=
literal|1
expr_stmt|;
name|panel_dvo_timing
operator|=
name|get_lvds_dvo_timing
argument_list|(
name|lvds_lfp_data
argument_list|,
name|lvds_lfp_data_ptrs
argument_list|,
name|lvds_options
operator|->
name|panel_type
argument_list|)
expr_stmt|;
name|panel_fixed_mode
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|panel_fixed_mode
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|fill_detail_timing_data
argument_list|(
name|panel_fixed_mode
argument_list|,
name|panel_dvo_timing
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|lfp_lvds_vbt_mode
operator|=
name|panel_fixed_mode
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Found panel mode in BIOS VBT tables:\n"
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|panel_fixed_mode
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over the LVDS panel timing info to find the lowest clock 	 * for the native resolution. 	 */
name|downclock
operator|=
name|panel_dvo_timing
operator|->
name|clock
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|lvds_dvo_timing
modifier|*
name|dvo_timing
decl_stmt|;
name|dvo_timing
operator|=
name|get_lvds_dvo_timing
argument_list|(
name|lvds_lfp_data
argument_list|,
name|lvds_lfp_data_ptrs
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvds_dvo_timing_equal_size
argument_list|(
name|dvo_timing
argument_list|,
name|panel_dvo_timing
argument_list|)
operator|&&
name|dvo_timing
operator|->
name|clock
operator|<
name|downclock
condition|)
name|downclock
operator|=
name|dvo_timing
operator|->
name|clock
expr_stmt|;
block|}
if|if
condition|(
name|downclock
operator|<
name|panel_dvo_timing
operator|->
name|clock
operator|&&
name|i915_lvds_downclock
condition|)
block|{
name|dev_priv
operator|->
name|lvds_downclock_avail
operator|=
literal|1
expr_stmt|;
name|dev_priv
operator|->
name|lvds_downclock
operator|=
name|downclock
operator|*
literal|10
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"LVDS downclock is found in VBT. "
literal|"Normal Clock %dKHz, downclock %dKHz\n"
argument_list|,
name|panel_fixed_mode
operator|->
name|clock
argument_list|,
literal|10
operator|*
name|downclock
argument_list|)
expr_stmt|;
block|}
name|fp_timing
operator|=
name|get_lvds_fp_timing
argument_list|(
name|bdb
argument_list|,
name|lvds_lfp_data
argument_list|,
name|lvds_lfp_data_ptrs
argument_list|,
name|lvds_options
operator|->
name|panel_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_timing
condition|)
block|{
comment|/* check the resolution, just to be sure */
if|if
condition|(
name|fp_timing
operator|->
name|x_res
operator|==
name|panel_fixed_mode
operator|->
name|hdisplay
operator|&&
name|fp_timing
operator|->
name|y_res
operator|==
name|panel_fixed_mode
operator|->
name|vdisplay
condition|)
block|{
name|dev_priv
operator|->
name|bios_lvds_val
operator|=
name|fp_timing
operator|->
name|lvds_reg_val
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"VBT initial LVDS value %x\n"
argument_list|,
name|dev_priv
operator|->
name|bios_lvds_val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Try to find sdvo panel data */
end_comment

begin_function
specifier|static
name|void
name|parse_sdvo_panel_data
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|bdb_header
modifier|*
name|bdb
parameter_list|)
block|{
name|struct
name|lvds_dvo_timing
modifier|*
name|dvo_timing
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|panel_fixed_mode
decl_stmt|;
name|int
name|index
decl_stmt|;
name|index
operator|=
name|i915_vbt_sdvo_panel_type
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|2
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Ignore SDVO panel mode from BIOS VBT tables.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|bdb_sdvo_lvds_options
modifier|*
name|sdvo_lvds_options
decl_stmt|;
name|sdvo_lvds_options
operator|=
name|find_section
argument_list|(
name|bdb
argument_list|,
name|BDB_SDVO_LVDS_OPTIONS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sdvo_lvds_options
condition|)
return|return;
name|index
operator|=
name|sdvo_lvds_options
operator|->
name|panel_type
expr_stmt|;
block|}
name|dvo_timing
operator|=
name|find_section
argument_list|(
name|bdb
argument_list|,
name|BDB_SDVO_PANEL_DTDS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dvo_timing
condition|)
return|return;
name|panel_fixed_mode
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|panel_fixed_mode
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|fill_detail_timing_data
argument_list|(
name|panel_fixed_mode
argument_list|,
name|dvo_timing
operator|+
name|index
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|sdvo_lvds_vbt_mode
operator|=
name|panel_fixed_mode
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Found SDVO panel mode in BIOS VBT tables:\n"
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|panel_fixed_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_bios_ssc_frequency
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|bool
name|alternate
parameter_list|)
block|{
switch|switch
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
condition|)
block|{
case|case
literal|2
case|:
return|return
name|alternate
condition|?
literal|66
else|:
literal|48
return|;
case|case
literal|3
case|:
case|case
literal|4
case|:
return|return
name|alternate
condition|?
literal|100
else|:
literal|96
return|;
default|default:
return|return
name|alternate
condition|?
literal|100
else|:
literal|120
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_general_features
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|bdb_header
modifier|*
name|bdb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|dev_priv
operator|->
name|dev
decl_stmt|;
name|struct
name|bdb_general_features
modifier|*
name|general
decl_stmt|;
name|general
operator|=
name|find_section
argument_list|(
name|bdb
argument_list|,
name|BDB_GENERAL_FEATURES
argument_list|)
expr_stmt|;
if|if
condition|(
name|general
condition|)
block|{
name|dev_priv
operator|->
name|int_tv_support
operator|=
name|general
operator|->
name|int_tv_support
expr_stmt|;
name|dev_priv
operator|->
name|int_crt_support
operator|=
name|general
operator|->
name|int_crt_support
expr_stmt|;
name|dev_priv
operator|->
name|lvds_use_ssc
operator|=
name|general
operator|->
name|enable_ssc
expr_stmt|;
name|dev_priv
operator|->
name|lvds_ssc_freq
operator|=
name|intel_bios_ssc_frequency
argument_list|(
name|dev
argument_list|,
name|general
operator|->
name|ssc_freq
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|display_clock_mode
operator|=
name|general
operator|->
name|display_clock_mode
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"BDB_GENERAL_FEATURES int_tv_support %d int_crt_support %d lvds_use_ssc %d lvds_ssc_freq %d display_clock_mode %d\n"
argument_list|,
name|dev_priv
operator|->
name|int_tv_support
argument_list|,
name|dev_priv
operator|->
name|int_crt_support
argument_list|,
name|dev_priv
operator|->
name|lvds_use_ssc
argument_list|,
name|dev_priv
operator|->
name|lvds_ssc_freq
argument_list|,
name|dev_priv
operator|->
name|display_clock_mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_general_definitions
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|bdb_header
modifier|*
name|bdb
parameter_list|)
block|{
name|struct
name|bdb_general_definitions
modifier|*
name|general
decl_stmt|;
name|general
operator|=
name|find_section
argument_list|(
name|bdb
argument_list|,
name|BDB_GENERAL_DEFINITIONS
argument_list|)
expr_stmt|;
if|if
condition|(
name|general
condition|)
block|{
name|u16
name|block_size
init|=
name|get_blocksize
argument_list|(
name|general
argument_list|)
decl_stmt|;
if|if
condition|(
name|block_size
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|general
argument_list|)
condition|)
block|{
name|int
name|bus_pin
init|=
name|general
operator|->
name|crt_ddc_gmbus_pin
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"crt_ddc_bus_pin: %d\n"
argument_list|,
name|bus_pin
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_gmbus_is_port_valid
argument_list|(
name|bus_pin
argument_list|)
condition|)
name|dev_priv
operator|->
name|crt_ddc_pin
operator|=
name|bus_pin
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"BDB_GD too small (%d). Invalid.\n"
argument_list|,
name|block_size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_sdvo_device_mapping
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|bdb_header
modifier|*
name|bdb
parameter_list|)
block|{
name|struct
name|sdvo_device_mapping
modifier|*
name|p_mapping
decl_stmt|;
name|struct
name|bdb_general_definitions
modifier|*
name|p_defs
decl_stmt|;
name|struct
name|child_device_config
modifier|*
name|p_child
decl_stmt|;
name|int
name|i
decl_stmt|,
name|child_device_num
decl_stmt|,
name|count
decl_stmt|;
name|u16
name|block_size
decl_stmt|;
name|p_defs
operator|=
name|find_section
argument_list|(
name|bdb
argument_list|,
name|BDB_GENERAL_DEFINITIONS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_defs
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"No general definition block is found, unable to construct sdvo mapping.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* judge whether the size of child device meets the requirements. 	 * If the child device size obtained from general definition block 	 * is different with sizeof(struct child_device_config), skip the 	 * parsing of sdvo device info 	 */
if|if
condition|(
name|p_defs
operator|->
name|child_dev_size
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|p_child
argument_list|)
condition|)
block|{
comment|/* different child dev size . Ignore it */
name|DRM_DEBUG_KMS
argument_list|(
literal|"different child size is found. Invalid.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get the block size of general definitions */
name|block_size
operator|=
name|get_blocksize
argument_list|(
name|p_defs
argument_list|)
expr_stmt|;
comment|/* get the number of child device */
name|child_device_num
operator|=
operator|(
name|block_size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|p_defs
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|p_child
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|child_device_num
condition|;
name|i
operator|++
control|)
block|{
name|p_child
operator|=
operator|&
operator|(
name|p_defs
operator|->
name|devices
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_child
operator|->
name|device_type
condition|)
block|{
comment|/* skip the device block if device type is invalid */
continue|continue;
block|}
if|if
condition|(
name|p_child
operator|->
name|slave_addr
operator|!=
name|SLAVE_ADDR1
operator|&&
name|p_child
operator|->
name|slave_addr
operator|!=
name|SLAVE_ADDR2
condition|)
block|{
comment|/* 			 * If the slave address is neither 0x70 nor 0x72, 			 * it is not a SDVO device. Skip it. 			 */
continue|continue;
block|}
if|if
condition|(
name|p_child
operator|->
name|dvo_port
operator|!=
name|DEVICE_PORT_DVOB
operator|&&
name|p_child
operator|->
name|dvo_port
operator|!=
name|DEVICE_PORT_DVOC
condition|)
block|{
comment|/* skip the incorrect SDVO port */
name|DRM_DEBUG_KMS
argument_list|(
literal|"Incorrect SDVO port. Skip it\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"the SDVO device with slave addr %2x is found on"
literal|" %s port\n"
argument_list|,
name|p_child
operator|->
name|slave_addr
argument_list|,
operator|(
name|p_child
operator|->
name|dvo_port
operator|==
name|DEVICE_PORT_DVOB
operator|)
condition|?
literal|"SDVOB"
else|:
literal|"SDVOC"
argument_list|)
expr_stmt|;
name|p_mapping
operator|=
operator|&
operator|(
name|dev_priv
operator|->
name|sdvo_mappings
index|[
name|p_child
operator|->
name|dvo_port
operator|-
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mapping
operator|->
name|initialized
condition|)
block|{
name|p_mapping
operator|->
name|dvo_port
operator|=
name|p_child
operator|->
name|dvo_port
expr_stmt|;
name|p_mapping
operator|->
name|slave_addr
operator|=
name|p_child
operator|->
name|slave_addr
expr_stmt|;
name|p_mapping
operator|->
name|dvo_wiring
operator|=
name|p_child
operator|->
name|dvo_wiring
expr_stmt|;
name|p_mapping
operator|->
name|ddc_pin
operator|=
name|p_child
operator|->
name|ddc_pin
expr_stmt|;
name|p_mapping
operator|->
name|i2c_pin
operator|=
name|p_child
operator|->
name|i2c_pin
expr_stmt|;
name|p_mapping
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"SDVO device: dvo=%x, addr=%x, wiring=%d, ddc_pin=%d, i2c_pin=%d\n"
argument_list|,
name|p_mapping
operator|->
name|dvo_port
argument_list|,
name|p_mapping
operator|->
name|slave_addr
argument_list|,
name|p_mapping
operator|->
name|dvo_wiring
argument_list|,
name|p_mapping
operator|->
name|ddc_pin
argument_list|,
name|p_mapping
operator|->
name|i2c_pin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Maybe one SDVO port is shared by "
literal|"two SDVO device.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_child
operator|->
name|slave2_addr
condition|)
block|{
comment|/* Maybe this is a SDVO device with multiple inputs */
comment|/* And the mapping info is not added */
name|DRM_DEBUG_KMS
argument_list|(
literal|"there exists the slave2_addr. Maybe this"
literal|" is a SDVO device with multiple inputs.\n"
argument_list|)
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|count
condition|)
block|{
comment|/* No SDVO device info is found */
name|DRM_DEBUG_KMS
argument_list|(
literal|"No SDVO device info is found in VBT\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_driver_features
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|bdb_header
modifier|*
name|bdb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|dev_priv
operator|->
name|dev
decl_stmt|;
name|struct
name|bdb_driver_features
modifier|*
name|driver
decl_stmt|;
name|driver
operator|=
name|find_section
argument_list|(
name|bdb
argument_list|,
name|BDB_DRIVER_FEATURES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|driver
condition|)
return|return;
if|if
condition|(
name|SUPPORTS_EDP
argument_list|(
name|dev
argument_list|)
operator|&&
name|driver
operator|->
name|lvds_config
operator|==
name|BDB_DRIVER_FEATURE_EDP
condition|)
name|dev_priv
operator|->
name|edp
operator|.
name|support
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|driver
operator|->
name|dual_frequency
condition|)
name|dev_priv
operator|->
name|render_reclock_avail
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_edp
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|bdb_header
modifier|*
name|bdb
parameter_list|)
block|{
name|struct
name|bdb_edp
modifier|*
name|edp
decl_stmt|;
name|struct
name|edp_power_seq
modifier|*
name|edp_pps
decl_stmt|;
name|struct
name|edp_link_params
modifier|*
name|edp_link_params
decl_stmt|;
name|edp
operator|=
name|find_section
argument_list|(
name|bdb
argument_list|,
name|BDB_EDP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edp
condition|)
block|{
if|if
condition|(
name|SUPPORTS_EDP
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
operator|&&
name|dev_priv
operator|->
name|edp
operator|.
name|support
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"No eDP BDB found but eDP panel "
literal|"supported, assume %dbpp panel color "
literal|"depth.\n"
argument_list|,
name|dev_priv
operator|->
name|edp
operator|.
name|bpp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
switch|switch
condition|(
operator|(
name|edp
operator|->
name|color_depth
operator|>>
operator|(
name|panel_type
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
condition|)
block|{
case|case
name|EDP_18BPP
case|:
name|dev_priv
operator|->
name|edp
operator|.
name|bpp
operator|=
literal|18
expr_stmt|;
break|break;
case|case
name|EDP_24BPP
case|:
name|dev_priv
operator|->
name|edp
operator|.
name|bpp
operator|=
literal|24
expr_stmt|;
break|break;
case|case
name|EDP_30BPP
case|:
name|dev_priv
operator|->
name|edp
operator|.
name|bpp
operator|=
literal|30
expr_stmt|;
break|break;
block|}
comment|/* Get the eDP sequencing and link info */
name|edp_pps
operator|=
operator|&
name|edp
operator|->
name|power_seqs
index|[
name|panel_type
index|]
expr_stmt|;
name|edp_link_params
operator|=
operator|&
name|edp
operator|->
name|link_params
index|[
name|panel_type
index|]
expr_stmt|;
name|dev_priv
operator|->
name|edp
operator|.
name|pps
operator|=
operator|*
name|edp_pps
expr_stmt|;
name|dev_priv
operator|->
name|edp
operator|.
name|rate
operator|=
name|edp_link_params
operator|->
name|rate
condition|?
name|DP_LINK_BW_2_7
else|:
name|DP_LINK_BW_1_62
expr_stmt|;
switch|switch
condition|(
name|edp_link_params
operator|->
name|lanes
condition|)
block|{
case|case
literal|0
case|:
name|dev_priv
operator|->
name|edp
operator|.
name|lanes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|dev_priv
operator|->
name|edp
operator|.
name|lanes
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
default|default:
name|dev_priv
operator|->
name|edp
operator|.
name|lanes
operator|=
literal|4
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|edp_link_params
operator|->
name|preemphasis
condition|)
block|{
case|case
literal|0
case|:
name|dev_priv
operator|->
name|edp
operator|.
name|preemphasis
operator|=
name|DP_TRAIN_PRE_EMPHASIS_0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|dev_priv
operator|->
name|edp
operator|.
name|preemphasis
operator|=
name|DP_TRAIN_PRE_EMPHASIS_3_5
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|dev_priv
operator|->
name|edp
operator|.
name|preemphasis
operator|=
name|DP_TRAIN_PRE_EMPHASIS_6
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|dev_priv
operator|->
name|edp
operator|.
name|preemphasis
operator|=
name|DP_TRAIN_PRE_EMPHASIS_9_5
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|edp_link_params
operator|->
name|vswing
condition|)
block|{
case|case
literal|0
case|:
name|dev_priv
operator|->
name|edp
operator|.
name|vswing
operator|=
name|DP_TRAIN_VOLTAGE_SWING_400
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|dev_priv
operator|->
name|edp
operator|.
name|vswing
operator|=
name|DP_TRAIN_VOLTAGE_SWING_600
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|dev_priv
operator|->
name|edp
operator|.
name|vswing
operator|=
name|DP_TRAIN_VOLTAGE_SWING_800
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|dev_priv
operator|->
name|edp
operator|.
name|vswing
operator|=
name|DP_TRAIN_VOLTAGE_SWING_1200
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_device_mapping
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|bdb_header
modifier|*
name|bdb
parameter_list|)
block|{
name|struct
name|bdb_general_definitions
modifier|*
name|p_defs
decl_stmt|;
name|struct
name|child_device_config
modifier|*
name|p_child
decl_stmt|,
modifier|*
name|child_dev_ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|child_device_num
decl_stmt|,
name|count
decl_stmt|;
name|u16
name|block_size
decl_stmt|;
name|p_defs
operator|=
name|find_section
argument_list|(
name|bdb
argument_list|,
name|BDB_GENERAL_DEFINITIONS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_defs
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"No general definition block is found, no devices defined.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* judge whether the size of child device meets the requirements. 	 * If the child device size obtained from general definition block 	 * is different with sizeof(struct child_device_config), skip the 	 * parsing of sdvo device info 	 */
if|if
condition|(
name|p_defs
operator|->
name|child_dev_size
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|p_child
argument_list|)
condition|)
block|{
comment|/* different child dev size . Ignore it */
name|DRM_DEBUG_KMS
argument_list|(
literal|"different child size is found. Invalid.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get the block size of general definitions */
name|block_size
operator|=
name|get_blocksize
argument_list|(
name|p_defs
argument_list|)
expr_stmt|;
comment|/* get the number of child device */
name|child_device_num
operator|=
operator|(
name|block_size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|p_defs
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|p_child
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* get the number of child device that is present */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|child_device_num
condition|;
name|i
operator|++
control|)
block|{
name|p_child
operator|=
operator|&
operator|(
name|p_defs
operator|->
name|devices
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_child
operator|->
name|device_type
condition|)
block|{
comment|/* skip the device block if device type is invalid */
continue|continue;
block|}
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|count
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"no child dev is parsed from VBT\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dev_priv
operator|->
name|child_dev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_child
argument_list|)
operator|*
name|count
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|child_dev_num
operator|=
name|count
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|child_device_num
condition|;
name|i
operator|++
control|)
block|{
name|p_child
operator|=
operator|&
operator|(
name|p_defs
operator|->
name|devices
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_child
operator|->
name|device_type
condition|)
block|{
comment|/* skip the device block if device type is invalid */
continue|continue;
block|}
name|child_dev_ptr
operator|=
name|dev_priv
operator|->
name|child_dev
operator|+
name|count
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|child_dev_ptr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p_child
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_child
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|init_vbt_defaults
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|dev_priv
operator|->
name|dev
decl_stmt|;
name|dev_priv
operator|->
name|crt_ddc_pin
operator|=
name|GMBUS_PORT_VGADDC
expr_stmt|;
comment|/* LFP panel data */
name|dev_priv
operator|->
name|lvds_dither
operator|=
literal|1
expr_stmt|;
name|dev_priv
operator|->
name|lvds_vbt
operator|=
literal|0
expr_stmt|;
comment|/* SDVO panel data */
name|dev_priv
operator|->
name|sdvo_lvds_vbt_mode
operator|=
name|NULL
expr_stmt|;
comment|/* general features */
name|dev_priv
operator|->
name|int_tv_support
operator|=
literal|1
expr_stmt|;
name|dev_priv
operator|->
name|int_crt_support
operator|=
literal|1
expr_stmt|;
comment|/* Default to using SSC */
name|dev_priv
operator|->
name|lvds_use_ssc
operator|=
literal|1
expr_stmt|;
name|dev_priv
operator|->
name|lvds_ssc_freq
operator|=
name|intel_bios_ssc_frequency
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Set default to SSC at %dMHz\n"
argument_list|,
name|dev_priv
operator|->
name|lvds_ssc_freq
argument_list|)
expr_stmt|;
comment|/* eDP data */
name|dev_priv
operator|->
name|edp
operator|.
name|bpp
operator|=
literal|18
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_no_opregion_vbt_callback
parameter_list|(
specifier|const
name|struct
name|dmi_system_id
modifier|*
name|id
parameter_list|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Falling back to manually reading VBT from "
literal|"VBIOS ROM for %s\n"
argument_list|,
name|id
operator|->
name|ident
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|dmi_system_id
name|intel_no_opregion_vbt
index|[]
init|=
block|{
block|{
operator|.
name|callback
operator|=
name|intel_no_opregion_vbt_callback
block|,
operator|.
name|ident
operator|=
literal|"ThinkCentre A57"
block|,
operator|.
name|matches
operator|=
block|{
name|DMI_MATCH
argument_list|(
name|DMI_SYS_VENDOR
argument_list|,
literal|"LENOVO"
argument_list|)
block|,
name|DMI_MATCH
argument_list|(
name|DMI_PRODUCT_NAME
argument_list|,
literal|"97027RG"
argument_list|)
block|, 		}
block|, 	}
block|,
block|{ }
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * intel_parse_bios - find VBT and initialize settings from the BIOS  * @dev: DRM device  *  * Loads the Video BIOS and checks that the VBT exists.  Sets scratch registers  * to appropriate values.  *  * Returns 0 on success, nonzero on failure.  */
end_comment

begin_function
name|bool
name|intel_parse_bios
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|bdb_header
modifier|*
name|bdb
init|=
name|NULL
decl_stmt|;
name|u8
modifier|*
name|bios
decl_stmt|;
name|init_vbt_defaults
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* XXX Should this validation be moved to intel_opregion.c? */
if|if
condition|(
operator|!
name|dmi_check_system
argument_list|(
name|intel_no_opregion_vbt
argument_list|)
operator|&&
name|dev_priv
operator|->
name|opregion
operator|.
name|vbt
condition|)
block|{
name|struct
name|vbt_header
modifier|*
name|vbt
init|=
name|dev_priv
operator|->
name|opregion
operator|.
name|vbt
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|vbt
operator|->
name|signature
argument_list|,
literal|"$VBT"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Using VBT from OpRegion: %20s\n"
argument_list|,
name|vbt
operator|->
name|signature
argument_list|)
expr_stmt|;
name|bdb
operator|=
operator|(
expr|struct
name|bdb_header
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|vbt
operator|+
name|vbt
operator|->
name|bdb_offset
operator|)
expr_stmt|;
block|}
else|else
name|dev_priv
operator|->
name|opregion
operator|.
name|vbt
operator|=
name|NULL
expr_stmt|;
block|}
name|bios
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|bdb
operator|==
name|NULL
condition|)
block|{
name|KIB_NOTYET
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
name|bdb
operator|==
name|NULL
condition|)
block|{
name|struct
name|vbt_header
modifier|*
name|vbt
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bios
operator|=
name|pci_map_rom
argument_list|(
name|pdev
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bios
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Scour memory looking for the VBT signature */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
literal|4
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|bios
operator|+
name|i
argument_list|,
literal|"$VBT"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|vbt
operator|=
operator|(
expr|struct
name|vbt_header
operator|*
operator|)
operator|(
name|bios
operator|+
name|i
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|vbt
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"VBT signature missing\n"
argument_list|)
expr_stmt|;
name|pci_unmap_rom
argument_list|(
name|pdev
argument_list|,
name|bios
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bdb
operator|=
operator|(
expr|struct
name|bdb_header
operator|*
operator|)
operator|(
name|bios
operator|+
name|i
operator|+
name|vbt
operator|->
name|bdb_offset
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Grab useful general definitions */
name|parse_general_features
argument_list|(
name|dev_priv
argument_list|,
name|bdb
argument_list|)
expr_stmt|;
name|parse_general_definitions
argument_list|(
name|dev_priv
argument_list|,
name|bdb
argument_list|)
expr_stmt|;
name|parse_lfp_panel_data
argument_list|(
name|dev_priv
argument_list|,
name|bdb
argument_list|)
expr_stmt|;
name|parse_sdvo_panel_data
argument_list|(
name|dev_priv
argument_list|,
name|bdb
argument_list|)
expr_stmt|;
name|parse_sdvo_device_mapping
argument_list|(
name|dev_priv
argument_list|,
name|bdb
argument_list|)
expr_stmt|;
name|parse_device_mapping
argument_list|(
name|dev_priv
argument_list|,
name|bdb
argument_list|)
expr_stmt|;
name|parse_driver_features
argument_list|(
name|dev_priv
argument_list|,
name|bdb
argument_list|)
expr_stmt|;
name|parse_edp
argument_list|(
name|dev_priv
argument_list|,
name|bdb
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (bios) 		pci_unmap_rom(pdev, bios);
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Ensure that vital registers have been initialised, even if the BIOS  * is absent or just failing to do its job.  */
end_comment

begin_function
name|void
name|intel_setup_bios
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* Set the Panel Power On/Off timings if uninitialized. */
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|PP_ON_DELAYS
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|I915_READ
argument_list|(
name|PP_OFF_DELAYS
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Set T2 to 40ms and T5 to 200ms */
name|I915_WRITE
argument_list|(
name|PP_ON_DELAYS
argument_list|,
literal|0x019007d0
argument_list|)
expr_stmt|;
comment|/* Set T3 to 35ms and Tx to 200ms */
name|I915_WRITE
argument_list|(
name|PP_OFF_DELAYS
argument_list|,
literal|0x015e07d0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

