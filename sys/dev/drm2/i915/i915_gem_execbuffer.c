begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Â© 2008,2010 Intel Corporation  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  *  * Authors:  *    Eric Anholt<eric@anholt.net>  *    Chris Wilson<chris@chris-wilson.co.uk>  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/sf_buf.h>
end_include

begin_struct
struct|struct
name|change_domains
block|{
name|uint32_t
name|invalidate_domains
decl_stmt|;
name|uint32_t
name|flush_domains
decl_stmt|;
name|uint32_t
name|flush_rings
decl_stmt|;
name|uint32_t
name|flips
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Set the next domain for the specified object. This  * may not actually perform the necessary flushing/invaliding though,  * as that may want to be batched with other set_domain operations  *  * This is (we hope) the only really tricky part of gem. The goal  * is fairly simple -- track which caches hold bits of the object  * and make sure they remain coherent. A few concrete examples may  * help to explain how it works. For shorthand, we use the notation  * (read_domains, write_domain), e.g. (CPU, CPU) to indicate the  * a pair of read and write domain masks.  *  * Case 1: the batch buffer  *  *	1. Allocated  *	2. Written by CPU  *	3. Mapped to GTT  *	4. Read by GPU  *	5. Unmapped from GTT  *	6. Freed  *  *	Let's take these a step at a time  *  *	1. Allocated  *		Pages allocated from the kernel may still have  *		cache contents, so we set them to (CPU, CPU) always.  *	2. Written by CPU (using pwrite)  *		The pwrite function calls set_domain (CPU, CPU) and  *		this function does nothing (as nothing changes)  *	3. Mapped by GTT  *		This function asserts that the object is not  *		currently in any GPU-based read or write domains  *	4. Read by GPU  *		i915_gem_execbuffer calls set_domain (COMMAND, 0).  *		As write_domain is zero, this function adds in the  *		current read domains (CPU+COMMAND, 0).  *		flush_domains is set to CPU.  *		invalidate_domains is set to COMMAND  *		clflush is run to get data out of the CPU caches  *		then i915_dev_set_domain calls i915_gem_flush to  *		emit an MI_FLUSH and drm_agp_chipset_flush  *	5. Unmapped from GTT  *		i915_gem_object_unbind calls set_domain (CPU, CPU)  *		flush_domains and invalidate_domains end up both zero  *		so no flushing/invalidating happens  *	6. Freed  *		yay, done  *  * Case 2: The shared render buffer  *  *	1. Allocated  *	2. Mapped to GTT  *	3. Read/written by GPU  *	4. set_domain to (CPU,CPU)  *	5. Read/written by CPU  *	6. Read/written by GPU  *  *	1. Allocated  *		Same as last example, (CPU, CPU)  *	2. Mapped to GTT  *		Nothing changes (assertions find that it is not in the GPU)  *	3. Read/written by GPU  *		execbuffer calls set_domain (RENDER, RENDER)  *		flush_domains gets CPU  *		invalidate_domains gets GPU  *		clflush (obj)  *		MI_FLUSH and drm_agp_chipset_flush  *	4. set_domain (CPU, CPU)  *		flush_domains gets GPU  *		invalidate_domains gets CPU  *		wait_rendering (obj) to make sure all drawing is complete.  *		This will include an MI_FLUSH to get the data from GPU  *		to memory  *		clflush (obj) to invalidate the CPU cache  *		Another MI_FLUSH in i915_gem_flush (eliminate this somehow?)  *	5. Read/written by CPU  *		cache lines are loaded and dirtied  *	6. Read written by GPU  *		Same as last GPU access  *  * Case 3: The constant buffer  *  *	1. Allocated  *	2. Written by CPU  *	3. Read by GPU  *	4. Updated (written) by CPU again  *	5. Read by GPU  *  *	1. Allocated  *		(CPU, CPU)  *	2. Written by CPU  *		(CPU, CPU)  *	3. Read by GPU  *		(CPU+RENDER, 0)  *		flush_domains = CPU  *		invalidate_domains = RENDER  *		clflush (obj)  *		MI_FLUSH  *		drm_agp_chipset_flush  *	4. Updated (written) by CPU again  *		(CPU, CPU)  *		flush_domains = 0 (no previous write domain)  *		invalidate_domains = 0 (no new read domains)  *	5. Read by GPU  *		(CPU+RENDER, 0)  *		flush_domains = CPU  *		invalidate_domains = RENDER  *		clflush (obj)  *		MI_FLUSH  *		drm_agp_chipset_flush  */
end_comment

begin_function
specifier|static
name|void
name|i915_gem_object_set_to_gpu_domain
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|struct
name|change_domains
modifier|*
name|cd
parameter_list|)
block|{
name|uint32_t
name|invalidate_domains
init|=
literal|0
decl_stmt|,
name|flush_domains
init|=
literal|0
decl_stmt|;
comment|/* 	 * If the object isn't moving to a new write domain, 	 * let the object stay in multiple read domains 	 */
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|pending_write_domain
operator|==
literal|0
condition|)
name|obj
operator|->
name|base
operator|.
name|pending_read_domains
operator||=
name|obj
operator|->
name|base
operator|.
name|read_domains
expr_stmt|;
comment|/* 	 * Flush the current write domain if 	 * the new read domains don't match. Invalidate 	 * any read domains which differ from the old 	 * write domain 	 */
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&&
operator|(
operator|(
operator|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|!=
name|obj
operator|->
name|base
operator|.
name|pending_read_domains
operator|||
name|obj
operator|->
name|ring
operator|!=
name|ring
operator|)
operator|)
operator|||
operator|(
name|obj
operator|->
name|fenced_gpu_access
operator|&&
operator|!
name|obj
operator|->
name|pending_fenced_gpu_access
operator|)
operator|)
condition|)
block|{
name|flush_domains
operator||=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|invalidate_domains
operator||=
name|obj
operator|->
name|base
operator|.
name|pending_read_domains
operator|&
operator|~
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
block|}
comment|/* 	 * Invalidate any read caches which may have 	 * stale data. That is, any new read domains. 	 */
name|invalidate_domains
operator||=
name|obj
operator|->
name|base
operator|.
name|pending_read_domains
operator|&
operator|~
name|obj
operator|->
name|base
operator|.
name|read_domains
expr_stmt|;
if|if
condition|(
operator|(
name|flush_domains
operator||
name|invalidate_domains
operator|)
operator|&
name|I915_GEM_DOMAIN_CPU
condition|)
name|i915_gem_clflush_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|pending_write_domain
condition|)
name|cd
operator|->
name|flips
operator||=
name|atomic_load_acq_int
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|)
expr_stmt|;
comment|/* The actual obj->write_domain will be updated with 	 * pending_write_domain after we emit the accumulated flush for all 	 * of our domain changes in execbuffers (which clears objects' 	 * write_domains).  So if we have a current write domain that we 	 * aren't changing, set pending_write_domain to that. 	 */
if|if
condition|(
name|flush_domains
operator|==
literal|0
operator|&&
name|obj
operator|->
name|base
operator|.
name|pending_write_domain
operator|==
literal|0
condition|)
name|obj
operator|->
name|base
operator|.
name|pending_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|cd
operator|->
name|invalidate_domains
operator||=
name|invalidate_domains
expr_stmt|;
name|cd
operator|->
name|flush_domains
operator||=
name|flush_domains
expr_stmt|;
if|if
condition|(
name|flush_domains
operator|&
name|I915_GEM_GPU_DOMAINS
condition|)
name|cd
operator|->
name|flush_rings
operator||=
name|intel_ring_flag
argument_list|(
name|obj
operator|->
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|invalidate_domains
operator|&
name|I915_GEM_GPU_DOMAINS
condition|)
name|cd
operator|->
name|flush_rings
operator||=
name|intel_ring_flag
argument_list|(
name|ring
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|eb_objects
block|{
name|u_long
name|hashmask
decl_stmt|;
name|LIST_HEAD
argument_list|(,
name|drm_i915_gem_object
argument_list|)
operator|*
name|buckets
expr_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|eb_objects
modifier|*
name|eb_create
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|struct
name|eb_objects
modifier|*
name|eb
decl_stmt|;
name|eb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|eb
operator|->
name|buckets
operator|=
name|hashinit
argument_list|(
name|size
argument_list|,
name|DRM_I915_GEM
argument_list|,
operator|&
name|eb
operator|->
name|hashmask
argument_list|)
expr_stmt|;
return|return
operator|(
name|eb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eb_reset
parameter_list|(
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|eb
operator|->
name|hashmask
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|eb
operator|->
name|buckets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eb_add_object
parameter_list|(
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|eb
operator|->
name|buckets
index|[
name|obj
operator|->
name|exec_handle
operator|&
name|eb
operator|->
name|hashmask
index|]
argument_list|,
name|obj
argument_list|,
name|exec_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_i915_gem_object
modifier|*
name|eb_get_object
parameter_list|(
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|,
name|unsigned
name|long
name|handle
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|obj
argument_list|,
argument|&eb->buckets[handle& eb->hashmask]
argument_list|,
argument|exec_node
argument_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|exec_handle
operator|==
name|handle
condition|)
return|return
operator|(
name|obj
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eb_destroy
parameter_list|(
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|)
block|{
name|free
argument_list|(
name|eb
operator|->
name|buckets
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|eb
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|use_cpu_reloc
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
return|return
operator|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|==
name|I915_GEM_DOMAIN_CPU
operator|||
name|obj
operator|->
name|cache_level
operator|!=
name|I915_CACHE_NONE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_relocate_entry
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|,
name|struct
name|drm_i915_gem_relocation_entry
modifier|*
name|reloc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_gem_object
modifier|*
name|target_obj
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|target_i915_obj
decl_stmt|;
name|uint32_t
name|target_offset
decl_stmt|;
name|int
name|ret
init|=
operator|-
name|EINVAL
decl_stmt|;
comment|/* we've already hold a reference to all valid objects */
name|target_obj
operator|=
operator|&
name|eb_get_object
argument_list|(
name|eb
argument_list|,
name|reloc
operator|->
name|target_handle
argument_list|)
operator|->
name|base
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|target_obj
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|-
name|ENOENT
return|;
name|target_i915_obj
operator|=
name|to_intel_bo
argument_list|(
name|target_obj
argument_list|)
expr_stmt|;
name|target_offset
operator|=
name|target_i915_obj
operator|->
name|gtt_offset
expr_stmt|;
if|#
directive|if
name|WATCH_RELOC
name|DRM_INFO
argument_list|(
literal|"%s: obj %p offset %08x target %d "
literal|"read %08x write %08x gtt %08x "
literal|"presumed %08x delta %08x\n"
argument_list|,
name|__func__
argument_list|,
name|obj
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|offset
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|target_handle
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|read_domains
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|write_domain
argument_list|,
operator|(
name|int
operator|)
name|target_offset
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|presumed_offset
argument_list|,
name|reloc
operator|->
name|delta
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The target buffer should have appeared before us in the 	 * exec_object list, so it should have a GTT space bound by now. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|target_offset
operator|==
literal|0
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"No GTT space found for object %d\n"
argument_list|,
name|reloc
operator|->
name|target_handle
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* Validate that the target is in a valid r/w GPU domain */
if|if
condition|(
name|unlikely
argument_list|(
name|reloc
operator|->
name|write_domain
operator|&
operator|(
name|reloc
operator|->
name|write_domain
operator|-
literal|1
operator|)
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"reloc with multiple write domains: "
literal|"obj %p target %d offset %d "
literal|"read %08x write %08x"
argument_list|,
name|obj
argument_list|,
name|reloc
operator|->
name|target_handle
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|offset
argument_list|,
name|reloc
operator|->
name|read_domains
argument_list|,
name|reloc
operator|->
name|write_domain
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|reloc
operator|->
name|write_domain
operator||
name|reloc
operator|->
name|read_domains
operator|)
operator|&
operator|~
name|I915_GEM_GPU_DOMAINS
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"reloc with read/write non-GPU domains: "
literal|"obj %p target %d offset %d "
literal|"read %08x write %08x"
argument_list|,
name|obj
argument_list|,
name|reloc
operator|->
name|target_handle
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|offset
argument_list|,
name|reloc
operator|->
name|read_domains
argument_list|,
name|reloc
operator|->
name|write_domain
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|reloc
operator|->
name|write_domain
operator|&&
name|target_obj
operator|->
name|pending_write_domain
operator|&&
name|reloc
operator|->
name|write_domain
operator|!=
name|target_obj
operator|->
name|pending_write_domain
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Write domain conflict: "
literal|"obj %p target %d offset %d "
literal|"new %08x old %08x\n"
argument_list|,
name|obj
argument_list|,
name|reloc
operator|->
name|target_handle
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|offset
argument_list|,
name|reloc
operator|->
name|write_domain
argument_list|,
name|target_obj
operator|->
name|pending_write_domain
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|target_obj
operator|->
name|pending_read_domains
operator||=
name|reloc
operator|->
name|read_domains
expr_stmt|;
name|target_obj
operator|->
name|pending_write_domain
operator||=
name|reloc
operator|->
name|write_domain
expr_stmt|;
comment|/* If the relocation already has the right value in it, no 	 * more work needs to be done. 	 */
if|if
condition|(
name|target_offset
operator|==
name|reloc
operator|->
name|presumed_offset
condition|)
return|return
literal|0
return|;
comment|/* Check that the relocation address is valid... */
if|if
condition|(
name|unlikely
argument_list|(
name|reloc
operator|->
name|offset
operator|>
name|obj
operator|->
name|base
operator|.
name|size
operator|-
literal|4
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Relocation beyond object bounds: "
literal|"obj %p target %d offset %d size %d.\n"
argument_list|,
name|obj
argument_list|,
name|reloc
operator|->
name|target_handle
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|offset
argument_list|,
operator|(
name|int
operator|)
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|reloc
operator|->
name|offset
operator|&
literal|3
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Relocation not 4-byte aligned: "
literal|"obj %p target %d offset %d.\n"
argument_list|,
name|obj
argument_list|,
name|reloc
operator|->
name|target_handle
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* We can't wait for rendering with pagefaults disabled */
if|if
condition|(
name|obj
operator|->
name|active
operator|&&
operator|(
name|curthread
operator|->
name|td_pflags
operator|&
name|TDP_NOFAULTING
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
name|EFAULT
operator|)
return|;
name|reloc
operator|->
name|delta
operator|+=
name|target_offset
expr_stmt|;
if|if
condition|(
name|use_cpu_reloc
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|uint32_t
name|page_offset
init|=
name|reloc
operator|->
name|offset
operator|&
name|PAGE_MASK
decl_stmt|;
name|char
modifier|*
name|vaddr
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|ret
operator|=
name|i915_gem_object_set_to_cpu_domain
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|obj
operator|->
name|pages
index|[
name|OFF_TO_IDX
argument_list|(
name|reloc
operator|->
name|offset
argument_list|)
index|]
argument_list|,
name|SFB_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|vaddr
operator|=
operator|(
name|void
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|vaddr
operator|+
name|page_offset
operator|)
operator|=
name|reloc
operator|->
name|delta
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
modifier|*
name|reloc_entry
decl_stmt|;
name|char
modifier|*
name|reloc_page
decl_stmt|;
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|obj
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|i915_gem_object_put_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* Map the page containing the relocation we're going to perform.  */
name|reloc
operator|->
name|offset
operator|+=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
name|reloc_page
operator|=
name|pmap_mapdev_attr
argument_list|(
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
operator|(
name|reloc
operator|->
name|offset
operator|&
operator|~
name|PAGE_MASK
operator|)
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
name|reloc_entry
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|reloc_page
operator|+
operator|(
name|reloc
operator|->
name|offset
operator|&
name|PAGE_MASK
operator|)
operator|)
expr_stmt|;
operator|*
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
name|reloc_entry
operator|=
name|reloc
operator|->
name|delta
expr_stmt|;
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|reloc_page
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
comment|/* Sandybridge PPGTT errata: We need a global gtt mapping for MI and 	 * pipe_control writes because the gpu doesn't properly redirect them 	 * through the ppgtt for non_secure batchbuffers. */
if|if
condition|(
name|unlikely
argument_list|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|&&
name|reloc
operator|->
name|write_domain
operator|==
name|I915_GEM_DOMAIN_INSTRUCTION
operator|&&
operator|!
name|target_i915_obj
operator|->
name|has_global_gtt_mapping
argument_list|)
condition|)
block|{
name|i915_gem_gtt_bind_object
argument_list|(
name|target_i915_obj
argument_list|,
name|target_i915_obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
block|}
comment|/* and update the user's relocation entry */
name|reloc
operator|->
name|presumed_offset
operator|=
name|target_offset
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_relocate_object
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|)
block|{
define|#
directive|define
name|N_RELOC
parameter_list|(
name|x
parameter_list|)
value|((x) / sizeof(struct drm_i915_gem_relocation_entry))
name|struct
name|drm_i915_gem_relocation_entry
name|stack_reloc
index|[
name|N_RELOC
argument_list|(
literal|512
argument_list|)
index|]
decl_stmt|;
name|struct
name|drm_i915_gem_relocation_entry
modifier|*
name|user_relocs
decl_stmt|;
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
init|=
name|obj
operator|->
name|exec_entry
decl_stmt|;
name|int
name|remain
decl_stmt|,
name|ret
decl_stmt|;
name|user_relocs
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|entry
operator|->
name|relocs_ptr
expr_stmt|;
name|remain
operator|=
name|entry
operator|->
name|relocation_count
expr_stmt|;
while|while
condition|(
name|remain
condition|)
block|{
name|struct
name|drm_i915_gem_relocation_entry
modifier|*
name|r
init|=
name|stack_reloc
decl_stmt|;
name|int
name|count
init|=
name|remain
decl_stmt|;
if|if
condition|(
name|count
operator|>
name|DRM_ARRAY_SIZE
argument_list|(
name|stack_reloc
argument_list|)
condition|)
name|count
operator|=
name|DRM_ARRAY_SIZE
argument_list|(
name|stack_reloc
argument_list|)
expr_stmt|;
name|remain
operator|-=
name|count
expr_stmt|;
name|ret
operator|=
operator|-
name|copyin_nofault
argument_list|(
name|user_relocs
argument_list|,
name|r
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|r
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
do|do
block|{
name|u64
name|offset
init|=
name|r
operator|->
name|presumed_offset
decl_stmt|;
name|ret
operator|=
name|i915_gem_execbuffer_relocate_entry
argument_list|(
name|obj
argument_list|,
name|eb
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|r
operator|->
name|presumed_offset
operator|!=
name|offset
operator|&&
name|copyout_nofault
argument_list|(
operator|&
name|r
operator|->
name|presumed_offset
argument_list|,
operator|&
name|user_relocs
operator|->
name|presumed_offset
argument_list|,
sizeof|sizeof
argument_list|(
name|r
operator|->
name|presumed_offset
argument_list|)
argument_list|)
condition|)
block|{
return|return
operator|-
name|EFAULT
return|;
block|}
name|user_relocs
operator|++
expr_stmt|;
name|r
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
condition|)
do|;
block|}
return|return
literal|0
return|;
undef|#
directive|undef
name|N_RELOC
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_relocate_object_slow
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|,
name|struct
name|drm_i915_gem_relocation_entry
modifier|*
name|relocs
parameter_list|)
block|{
specifier|const
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
init|=
name|obj
operator|->
name|exec_entry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|relocation_count
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|i915_gem_execbuffer_relocate_entry
argument_list|(
name|obj
argument_list|,
name|eb
argument_list|,
operator|&
name|relocs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_relocate
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|,
name|struct
name|list_head
modifier|*
name|objects
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|pflags
decl_stmt|;
comment|/* Try to move as many of the relocation targets off the active list 	 * to avoid unnecessary fallbacks to the slow path, as we cannot wait 	 * for the retirement with pagefaults disabled. 	 */
name|i915_gem_retire_requests
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|pflags
operator|=
name|vm_fault_disable_pagefaults
argument_list|()
expr_stmt|;
comment|/* This is the fast path and we cannot handle a pagefault whilst 	 * holding the device lock lest the user pass in the relocations 	 * contained within a mmaped bo. For in such a case we, the page 	 * fault handler would call i915_gem_fault() and we would try to 	 * acquire the device lock again. Obviously this is bad. 	 */
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
block|{
name|ret
operator|=
name|i915_gem_execbuffer_relocate_object
argument_list|(
name|obj
argument_list|,
name|eb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
block|}
name|vm_fault_enable_pagefaults
argument_list|(
name|pflags
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_define
define|#
directive|define
name|__EXEC_OBJECT_HAS_FENCE
value|(1<<31)
end_define

begin_function
specifier|static
name|int
name|need_reloc_mappable
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
init|=
name|obj
operator|->
name|exec_entry
decl_stmt|;
return|return
name|entry
operator|->
name|relocation_count
operator|&&
operator|!
name|use_cpu_reloc
argument_list|(
name|obj
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pin_and_fence_object
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
init|=
name|obj
operator|->
name|exec_entry
decl_stmt|;
name|bool
name|has_fenced_gpu_access
init|=
name|INTEL_INFO
argument_list|(
name|ring
operator|->
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
decl_stmt|;
name|bool
name|need_fence
decl_stmt|,
name|need_mappable
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|need_fence
operator|=
name|has_fenced_gpu_access
operator|&&
name|entry
operator|->
name|flags
operator|&
name|EXEC_OBJECT_NEEDS_FENCE
operator|&&
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
expr_stmt|;
name|need_mappable
operator|=
name|need_fence
operator|||
name|need_reloc_mappable
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_pin
argument_list|(
name|obj
argument_list|,
name|entry
operator|->
name|alignment
argument_list|,
name|need_mappable
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|has_fenced_gpu_access
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|EXEC_OBJECT_NEEDS_FENCE
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_get_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin
goto|;
if|if
condition|(
name|i915_gem_object_pin_fence
argument_list|(
name|obj
argument_list|)
condition|)
name|entry
operator|->
name|flags
operator||=
name|__EXEC_OBJECT_HAS_FENCE
expr_stmt|;
name|obj
operator|->
name|pending_fenced_gpu_access
operator|=
name|true
expr_stmt|;
block|}
block|}
name|entry
operator|->
name|offset
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin
label|:
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_reserve
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|list_head
modifier|*
name|objects
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|list_head
name|ordered_objects
decl_stmt|;
name|bool
name|has_fenced_gpu_access
init|=
name|INTEL_INFO
argument_list|(
name|ring
operator|->
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|retry
decl_stmt|;
name|dev_priv
operator|=
name|ring
operator|->
name|dev
operator|->
name|dev_private
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ordered_objects
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
name|objects
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
decl_stmt|;
name|bool
name|need_fence
decl_stmt|,
name|need_mappable
decl_stmt|;
name|obj
operator|=
name|list_first_entry
argument_list|(
name|objects
argument_list|,
expr|struct
name|drm_i915_gem_object
argument_list|,
name|exec_list
argument_list|)
expr_stmt|;
name|entry
operator|=
name|obj
operator|->
name|exec_entry
expr_stmt|;
name|need_fence
operator|=
name|has_fenced_gpu_access
operator|&&
name|entry
operator|->
name|flags
operator|&
name|EXEC_OBJECT_NEEDS_FENCE
operator|&&
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
expr_stmt|;
name|need_mappable
operator|=
name|need_fence
operator|||
name|need_reloc_mappable
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_mappable
condition|)
name|list_move
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|,
operator|&
name|ordered_objects
argument_list|)
expr_stmt|;
else|else
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|,
operator|&
name|ordered_objects
argument_list|)
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|pending_read_domains
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|pending_write_domain
operator|=
literal|0
expr_stmt|;
block|}
name|list_splice
argument_list|(
operator|&
name|ordered_objects
argument_list|,
name|objects
argument_list|)
expr_stmt|;
comment|/* Attempt to pin all of the buffers into the GTT. 	 * This is done in 3 phases: 	 * 	 * 1a. Unbind all objects that do not match the GTT constraints for 	 *     the execbuffer (fenceable, mappable, alignment etc). 	 * 1b. Increment pin count for already bound objects. 	 * 2.  Bind new objects. 	 * 3.  Decrement pin count. 	 * 	 * This avoid unnecessary unbinding of later objects in order to make 	 * room for the earlier objects *unless* we need to defragment. 	 */
name|retry
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* Unbind any ill-fitting objects or pin. */
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
block|{
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
init|=
name|obj
operator|->
name|exec_entry
decl_stmt|;
name|bool
name|need_fence
decl_stmt|,
name|need_mappable
decl_stmt|;
if|if
condition|(
operator|!
name|obj
operator|->
name|gtt_space
condition|)
continue|continue;
name|need_fence
operator|=
name|has_fenced_gpu_access
operator|&&
name|entry
operator|->
name|flags
operator|&
name|EXEC_OBJECT_NEEDS_FENCE
operator|&&
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
expr_stmt|;
name|need_mappable
operator|=
name|need_fence
operator|||
name|need_reloc_mappable
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|alignment
operator|&&
name|obj
operator|->
name|gtt_offset
operator|&
operator|(
name|entry
operator|->
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|need_mappable
operator|&&
operator|!
name|obj
operator|->
name|map_and_fenceable
operator|)
condition|)
name|ret
operator|=
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|pin_and_fence_object
argument_list|(
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* Bind fresh objects */
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|gtt_space
condition|)
continue|continue;
name|ret
operator|=
name|pin_and_fence_object
argument_list|(
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|int
name|ret_ignore
decl_stmt|;
comment|/* This can potentially raise a harmless 				 * -EINVAL if we failed to bind in the above 				 * call. It cannot raise -EINTR since we know 				 * that the bo is freshly bound and so will 				 * not need to be flushed or waited upon. 				 */
name|ret_ignore
operator|=
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ret_ignore
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|gtt_space
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: gtt_space\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Decrement pin count for bound objects */
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
block|{
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|obj
operator|->
name|gtt_space
condition|)
continue|continue;
name|entry
operator|=
name|obj
operator|->
name|exec_entry
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|__EXEC_OBJECT_HAS_FENCE
condition|)
block|{
name|i915_gem_object_unpin_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator|&=
operator|~
name|__EXEC_OBJECT_HAS_FENCE
expr_stmt|;
block|}
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|/* ... and ensure ppgtt mapping exist if needed. */
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
operator|&&
operator|!
name|obj
operator|->
name|has_aliasing_ppgtt_mapping
condition|)
block|{
name|i915_ppgtt_bind_object
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
argument_list|,
name|obj
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
name|obj
operator|->
name|has_aliasing_ppgtt_mapping
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
operator|-
name|ENOSPC
operator|||
name|retry
operator|>
literal|1
condition|)
return|return
name|ret
return|;
comment|/* First attempt, just clear anything that is purgeable. 		 * Second attempt, clear the entire GTT. 		 */
name|ret
operator|=
name|i915_gem_evict_everything
argument_list|(
name|ring
operator|->
name|dev
argument_list|,
name|retry
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|retry
operator|++
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|err
label|:
name|list_for_each_entry_continue_reverse
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
block|{
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|obj
operator|->
name|gtt_space
condition|)
continue|continue;
name|entry
operator|=
name|obj
operator|->
name|exec_entry
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|__EXEC_OBJECT_HAS_FENCE
condition|)
block|{
name|i915_gem_object_unpin_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator|&=
operator|~
name|__EXEC_OBJECT_HAS_FENCE
expr_stmt|;
block|}
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_relocate_slow
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|struct
name|list_head
modifier|*
name|objects
parameter_list|,
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|,
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|exec
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|drm_i915_gem_relocation_entry
modifier|*
name|reloc
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
modifier|*
name|reloc_offset
decl_stmt|;
name|int
name|i
decl_stmt|,
name|total
decl_stmt|,
name|ret
decl_stmt|;
comment|/* We may process another execbuffer during the unlock... */
while|while
condition|(
operator|!
name|list_empty
argument_list|(
name|objects
argument_list|)
condition|)
block|{
name|obj
operator|=
name|list_first_entry
argument_list|(
name|objects
argument_list|,
expr|struct
name|drm_i915_gem_object
argument_list|,
name|exec_list
argument_list|)
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|total
operator|+=
name|exec
index|[
name|i
index|]
operator|.
name|relocation_count
expr_stmt|;
name|reloc_offset
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|reloc_offset
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|malloc
argument_list|(
name|total
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_i915_gem_relocation_entry
modifier|*
name|user_relocs
decl_stmt|;
name|user_relocs
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|exec
index|[
name|i
index|]
operator|.
name|relocs_ptr
expr_stmt|;
name|ret
operator|=
operator|-
name|copyin
argument_list|(
name|user_relocs
argument_list|,
name|reloc
operator|+
name|total
argument_list|,
name|exec
index|[
name|i
index|]
operator|.
name|relocation_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|reloc_offset
index|[
name|i
index|]
operator|=
name|total
expr_stmt|;
name|total
operator|+=
name|exec
index|[
name|i
index|]
operator|.
name|relocation_count
expr_stmt|;
block|}
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* reacquire the objects */
name|eb_reset
argument_list|(
name|eb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|exec
index|[
name|i
index|]
operator|.
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Invalid object handle %d at index %d\n"
argument_list|,
name|exec
index|[
name|i
index|]
operator|.
name|handle
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|list_add_tail
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|,
name|objects
argument_list|)
expr_stmt|;
name|obj
operator|->
name|exec_handle
operator|=
name|exec
index|[
name|i
index|]
operator|.
name|handle
expr_stmt|;
name|obj
operator|->
name|exec_entry
operator|=
operator|&
name|exec
index|[
name|i
index|]
expr_stmt|;
name|eb_add_object
argument_list|(
name|eb
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|i915_gem_execbuffer_reserve
argument_list|(
name|ring
argument_list|,
name|file
argument_list|,
name|objects
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
block|{
name|int
name|offset
init|=
name|obj
operator|->
name|exec_entry
operator|-
name|exec
decl_stmt|;
name|ret
operator|=
name|i915_gem_execbuffer_relocate_object_slow
argument_list|(
name|obj
argument_list|,
name|eb
argument_list|,
name|reloc
operator|+
name|reloc_offset
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* Leave the user relocations as are, this is the painfully slow path, 	 * and we want to avoid the complication of dropping the lock whilst 	 * having buffers reserved in the aperture and so causing spurious 	 * ENOSPC for random operations. 	 */
name|err
label|:
name|free
argument_list|(
name|reloc
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reloc_offset
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_flush
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|invalidate_domains
parameter_list|,
name|uint32_t
name|flush_domains
parameter_list|,
name|uint32_t
name|flush_rings
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|flush_domains
operator|&
name|I915_GEM_DOMAIN_CPU
condition|)
name|intel_gtt_chipset_flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|flush_domains
operator|&
name|I915_GEM_DOMAIN_GTT
condition|)
name|wmb
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flush_domains
operator||
name|invalidate_domains
operator|)
operator|&
name|I915_GEM_GPU_DOMAINS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I915_NUM_RINGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|flush_rings
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|ret
operator|=
name|i915_gem_flush_ring
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|i
index|]
argument_list|,
name|invalidate_domains
argument_list|,
name|flush_domains
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_wait_for_flips
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|u32
name|flips
parameter_list|)
block|{
name|u32
name|plane
decl_stmt|,
name|flip_mask
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Check for any pending flips. As we only maintain a flip queue depth 	 * of 1, we can simply insert a WAIT for the next display flip prior 	 * to executing the batch and avoid stalling the CPU. 	 */
for|for
control|(
name|plane
operator|=
literal|0
init|;
name|flips
operator|>>
name|plane
condition|;
name|plane
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|flips
operator|>>
name|plane
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|plane
condition|)
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_B_FLIP
expr_stmt|;
else|else
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_A_FLIP
expr_stmt|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_WAIT_FOR_EVENT
operator||
name|flip_mask
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_NOOP
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_move_to_gpu
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|struct
name|list_head
modifier|*
name|objects
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|change_domains
name|cd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cd
argument_list|)
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
name|i915_gem_object_set_to_gpu_domain
argument_list|(
name|obj
argument_list|,
name|ring
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|.
name|invalidate_domains
operator||
name|cd
operator|.
name|flush_domains
condition|)
block|{
if|#
directive|if
name|WATCH_EXEC
name|DRM_INFO
argument_list|(
literal|"%s: invalidate_domains %08x flush_domains %08x\n"
argument_list|,
name|__func__
argument_list|,
name|cd
operator|.
name|invalidate_domains
argument_list|,
name|cd
operator|.
name|flush_domains
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|i915_gem_execbuffer_flush
argument_list|(
name|ring
operator|->
name|dev
argument_list|,
name|cd
operator|.
name|invalidate_domains
argument_list|,
name|cd
operator|.
name|flush_domains
argument_list|,
name|cd
operator|.
name|flush_rings
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
name|cd
operator|.
name|flips
condition|)
block|{
name|ret
operator|=
name|i915_gem_execbuffer_wait_for_flips
argument_list|(
name|ring
argument_list|,
name|cd
operator|.
name|flips
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
block|{
name|ret
operator|=
name|i915_gem_object_sync
argument_list|(
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|i915_gem_check_execbuffer
parameter_list|(
name|struct
name|drm_i915_gem_execbuffer2
modifier|*
name|exec
parameter_list|)
block|{
return|return
operator|(
operator|(
name|exec
operator|->
name|batch_start_offset
operator||
name|exec
operator|->
name|batch_len
operator|)
operator|&
literal|0x7
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|validate_exec_list
parameter_list|(
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|exec
parameter_list|,
name|int
name|count
parameter_list|,
name|vm_page_t
modifier|*
modifier|*
modifier|*
name|map
parameter_list|)
block|{
name|vm_page_t
modifier|*
name|ma
decl_stmt|;
name|int
name|i
decl_stmt|,
name|length
decl_stmt|,
name|page_count
decl_stmt|;
comment|/* XXXKIB various limits checking is missing there */
operator|*
name|map
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ma
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* First check for malicious input causing overflow */
if|if
condition|(
name|exec
index|[
name|i
index|]
operator|.
name|relocation_count
operator|>
name|INT_MAX
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|drm_i915_gem_relocation_entry
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|length
operator|=
name|exec
index|[
name|i
index|]
operator|.
name|relocation_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_i915_gem_relocation_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|map
operator|)
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Since both start and end of the relocation region 		 * may be not aligned on the page boundary, be 		 * conservative and request a page slot for each 		 * partial page.  Thus +2. 		 */
name|page_count
operator|=
name|howmany
argument_list|(
name|length
argument_list|,
name|PAGE_SIZE
argument_list|)
operator|+
literal|2
expr_stmt|;
name|ma
operator|=
operator|(
operator|*
name|map
operator|)
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|page_count
operator|*
sizeof|sizeof
argument_list|(
name|vm_page_t
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_fault_quick_hold_pages
argument_list|(
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|exec
index|[
name|i
index|]
operator|.
name|relocs_ptr
argument_list|,
name|length
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|ma
argument_list|,
name|page_count
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|ma
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
operator|(
operator|*
name|map
operator|)
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
name|EFAULT
operator|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_execbuffer_move_to_active
parameter_list|(
name|struct
name|list_head
modifier|*
name|objects
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|u32
name|seqno
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|uint32_t
name|old_read
decl_stmt|,
name|old_write
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
block|{
name|old_read
operator|=
name|obj
operator|->
name|base
operator|.
name|read_domains
expr_stmt|;
name|old_write
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|pending_read_domains
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|pending_write_domain
expr_stmt|;
name|obj
operator|->
name|fenced_gpu_access
operator|=
name|obj
operator|->
name|pending_fenced_gpu_access
expr_stmt|;
name|i915_gem_object_move_to_active
argument_list|(
name|obj
argument_list|,
name|ring
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
condition|)
block|{
name|obj
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|obj
operator|->
name|pending_gpu_write
operator|=
name|true
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|gpu_write_list
argument_list|,
operator|&
name|ring
operator|->
name|gpu_write_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|pin_count
condition|)
comment|/* check for potential scanout */
name|intel_mark_busy
argument_list|(
name|ring
operator|->
name|dev
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain move_to_active %p %x %x"
argument_list|,
name|obj
argument_list|,
name|old_read
argument_list|,
name|old_write
argument_list|)
expr_stmt|;
block|}
name|intel_mark_busy
argument_list|(
name|ring
operator|->
name|dev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|i915_gem_sync_exec_requests
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|i915_gem_execbuffer_retire_commands
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|u32
name|invalidate
decl_stmt|;
comment|/* 	 * Ensure that the commands in the batch buffer are 	 * finished before the interrupt fires. 	 * 	 * The sampler always gets flushed on i965 (sigh). 	 */
name|invalidate
operator|=
name|I915_GEM_DOMAIN_COMMAND
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
name|invalidate
operator||=
name|I915_GEM_DOMAIN_SAMPLER
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|flush
argument_list|(
name|ring
argument_list|,
name|invalidate
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|i915_gem_next_request_seqno
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Add a breadcrumb for the completion of the batch buffer */
name|request
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|==
name|NULL
operator|||
name|i915_add_request
argument_list|(
name|ring
argument_list|,
name|file
argument_list|,
name|request
argument_list|)
condition|)
block|{
name|i915_gem_next_request_seqno
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i915_gem_sync_exec_requests
condition|)
block|{
name|i915_wait_request
argument_list|(
name|ring
argument_list|,
name|request
operator|->
name|seqno
argument_list|)
expr_stmt|;
name|i915_gem_retire_requests
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_fix_mi_batchbuffer_end
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|batch_obj
parameter_list|,
name|uint32_t
name|batch_start_offset
parameter_list|,
name|uint32_t
name|batch_len
parameter_list|)
block|{
name|char
modifier|*
name|mkva
decl_stmt|;
name|uint64_t
name|po_r
decl_stmt|,
name|po_w
decl_stmt|;
name|uint32_t
name|cmd
decl_stmt|;
name|po_r
operator|=
name|batch_obj
operator|->
name|base
operator|.
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|batch_obj
operator|->
name|gtt_offset
operator|+
name|batch_start_offset
operator|+
name|batch_len
expr_stmt|;
if|if
condition|(
name|batch_len
operator|>
literal|0
condition|)
name|po_r
operator|-=
literal|4
expr_stmt|;
name|mkva
operator|=
name|pmap_mapdev_attr
argument_list|(
name|trunc_page
argument_list|(
name|po_r
argument_list|)
argument_list|,
literal|2
operator|*
name|PAGE_SIZE
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
name|po_r
operator|&=
name|PAGE_MASK
expr_stmt|;
name|cmd
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|mkva
operator|+
name|po_r
operator|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|MI_BATCH_BUFFER_END
condition|)
block|{
comment|/* 		 * batch_len != 0 due to the check at the start of 		 * i915_gem_do_execbuffer 		 */
if|if
condition|(
name|batch_obj
operator|->
name|base
operator|.
name|size
operator|>
name|batch_start_offset
operator|+
name|batch_len
condition|)
block|{
name|po_w
operator|=
name|po_r
operator|+
literal|4
expr_stmt|;
comment|/* DRM_DEBUG("batchbuffer does not end by MI_BATCH_BUFFER_END !\n"); */
block|}
else|else
block|{
name|po_w
operator|=
name|po_r
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"batchbuffer does not end by MI_BATCH_BUFFER_END, overwriting last bo cmd !\n"
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|mkva
operator|+
name|po_w
operator|)
operator|=
name|MI_BATCH_BUFFER_END
expr_stmt|;
block|}
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|mkva
argument_list|,
literal|2
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|i915_fix_mi_batchbuffer_end
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i915_reset_gen7_sol_offsets
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|||
name|ring
operator|!=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|4
operator|*
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_LOAD_REGISTER_IMM
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|GEN7_SO_WRITE_OFFSET
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_do_execbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|drm_i915_gem_execbuffer2
modifier|*
name|args
parameter_list|,
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|exec
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|list_head
name|objects
decl_stmt|;
name|struct
name|eb_objects
modifier|*
name|eb
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|batch_obj
decl_stmt|;
name|struct
name|drm_clip_rect
modifier|*
name|cliprects
init|=
name|NULL
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|vm_page_t
modifier|*
modifier|*
name|relocs_ma
decl_stmt|;
name|u32
name|ctx_id
init|=
name|i915_execbuffer2_get_context_id
argument_list|(
operator|*
name|args
argument_list|)
decl_stmt|;
name|u32
name|exec_start
decl_stmt|,
name|exec_len
decl_stmt|;
name|u32
name|seqno
decl_stmt|;
name|u32
name|mask
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|mode
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|i915_gem_check_execbuffer
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"execbuf with invalid offset/length\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|args
operator|->
name|batch_len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ret
operator|=
name|validate_exec_list
argument_list|(
name|exec
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|,
operator|&
name|relocs_ma
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|pre_struct_lock_err
goto|;
switch|switch
condition|(
name|args
operator|->
name|flags
operator|&
name|I915_EXEC_RING_MASK
condition|)
block|{
case|case
name|I915_EXEC_DEFAULT
case|:
case|case
name|I915_EXEC_RENDER
case|:
name|ring
operator|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
expr_stmt|;
break|break;
case|case
name|I915_EXEC_BSD
case|:
name|ring
operator|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|VCS
index|]
expr_stmt|;
if|if
condition|(
name|ctx_id
operator|!=
literal|0
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Ring %s doesn't support contexts\n"
argument_list|,
name|ring
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EPERM
expr_stmt|;
goto|goto
name|pre_struct_lock_err
goto|;
block|}
break|break;
case|case
name|I915_EXEC_BLT
case|:
name|ring
operator|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|BCS
index|]
expr_stmt|;
if|if
condition|(
name|ctx_id
operator|!=
literal|0
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Ring %s doesn't support contexts\n"
argument_list|,
name|ring
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EPERM
expr_stmt|;
goto|goto
name|pre_struct_lock_err
goto|;
block|}
break|break;
default|default:
name|DRM_DEBUG
argument_list|(
literal|"execbuf with unknown ring: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|args
operator|->
name|flags
operator|&
name|I915_EXEC_RING_MASK
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_struct_lock_err
goto|;
block|}
if|if
condition|(
operator|!
name|intel_ring_initialized
argument_list|(
name|ring
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"execbuf with invalid ring: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|args
operator|->
name|flags
operator|&
name|I915_EXEC_RING_MASK
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_struct_lock_err
goto|;
block|}
name|mode
operator|=
name|args
operator|->
name|flags
operator|&
name|I915_EXEC_CONSTANTS_MASK
expr_stmt|;
name|mask
operator|=
name|I915_EXEC_CONSTANTS_MASK
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|I915_EXEC_CONSTANTS_REL_GENERAL
case|:
case|case
name|I915_EXEC_CONSTANTS_ABSOLUTE
case|:
case|case
name|I915_EXEC_CONSTANTS_REL_SURFACE
case|:
if|if
condition|(
name|ring
operator|==
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
operator|&&
name|mode
operator|!=
name|dev_priv
operator|->
name|relative_constants_mode
condition|)
block|{
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_struct_lock_err
goto|;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>
literal|5
operator|&&
name|mode
operator|==
name|I915_EXEC_CONSTANTS_REL_SURFACE
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_struct_lock_err
goto|;
block|}
comment|/* The HW changed the meaning on this bit on gen6 */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|6
condition|)
name|mask
operator|&=
operator|~
name|I915_EXEC_CONSTANTS_REL_SURFACE
expr_stmt|;
block|}
break|break;
default|default:
name|DRM_DEBUG
argument_list|(
literal|"execbuf with unknown constants: %d\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_struct_lock_err
goto|;
block|}
if|if
condition|(
name|args
operator|->
name|buffer_count
operator|<
literal|1
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"execbuf with %d buffers\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_struct_lock_err
goto|;
block|}
if|if
condition|(
name|args
operator|->
name|num_cliprects
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ring
operator|!=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"clip rectangles are only valid with the render ring\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_struct_lock_err
goto|;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|5
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"clip rectangles are only valid on pre-gen5\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_struct_lock_err
goto|;
block|}
if|if
condition|(
name|args
operator|->
name|num_cliprects
operator|>
name|UINT_MAX
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|cliprects
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"execbuf with %u cliprects\n"
argument_list|,
name|args
operator|->
name|num_cliprects
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_struct_lock_err
goto|;
block|}
name|cliprects
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cliprects
argument_list|)
operator|*
name|args
operator|->
name|num_cliprects
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|cliprects_ptr
argument_list|,
name|cliprects
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cliprects
argument_list|)
operator|*
name|args
operator|->
name|num_cliprects
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|pre_struct_lock_err
goto|;
block|}
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|pre_struct_lock_err
goto|;
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EBUSY
expr_stmt|;
goto|goto
name|pre_struct_lock_err
goto|;
block|}
name|eb
operator|=
name|eb_create
argument_list|(
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|==
name|NULL
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|pre_struct_lock_err
goto|;
block|}
comment|/* Look up object handles */
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|objects
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|buffer_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|exec
index|[
name|i
index|]
operator|.
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Invalid object handle %d at index %d\n"
argument_list|,
name|exec
index|[
name|i
index|]
operator|.
name|handle
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* prevent error path from reading uninitialized data */
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Object %p [handle %d, index %d] appears more than once in object list\n"
argument_list|,
name|obj
argument_list|,
name|exec
index|[
name|i
index|]
operator|.
name|handle
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|list_add_tail
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|,
operator|&
name|objects
argument_list|)
expr_stmt|;
name|obj
operator|->
name|exec_handle
operator|=
name|exec
index|[
name|i
index|]
operator|.
name|handle
expr_stmt|;
name|obj
operator|->
name|exec_entry
operator|=
operator|&
name|exec
index|[
name|i
index|]
expr_stmt|;
name|eb_add_object
argument_list|(
name|eb
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
comment|/* take note of the batch buffer before we might reorder the lists */
name|batch_obj
operator|=
name|list_entry
argument_list|(
name|objects
operator|.
name|prev
argument_list|,
expr|struct
name|drm_i915_gem_object
argument_list|,
name|exec_list
argument_list|)
expr_stmt|;
comment|/* Move the objects en-masse into the GTT, evicting if necessary. */
name|ret
operator|=
name|i915_gem_execbuffer_reserve
argument_list|(
name|ring
argument_list|,
name|file
argument_list|,
operator|&
name|objects
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
comment|/* The objects are in their final locations, apply the relocations. */
name|ret
operator|=
name|i915_gem_execbuffer_relocate
argument_list|(
name|dev
argument_list|,
name|eb
argument_list|,
operator|&
name|objects
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|ret
operator|==
operator|-
name|EFAULT
condition|)
block|{
name|ret
operator|=
name|i915_gem_execbuffer_relocate_slow
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|ring
argument_list|,
operator|&
name|objects
argument_list|,
name|eb
argument_list|,
name|exec
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
name|DRM_LOCK_ASSERT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* Set the pending read domains for the batch buffer to COMMAND */
if|if
condition|(
name|batch_obj
operator|->
name|base
operator|.
name|pending_write_domain
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Attempting to use self-modifying batch buffer\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|batch_obj
operator|->
name|base
operator|.
name|pending_read_domains
operator||=
name|I915_GEM_DOMAIN_COMMAND
expr_stmt|;
name|ret
operator|=
name|i915_gem_execbuffer_move_to_gpu
argument_list|(
name|ring
argument_list|,
operator|&
name|objects
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|i915_switch_context
argument_list|(
name|ring
argument_list|,
name|file
argument_list|,
name|ctx_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|seqno
operator|=
name|i915_gem_next_request_seqno
argument_list|(
name|ring
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I915_NUM_RINGS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|seqno
operator|<
name|ring
operator|->
name|sync_seqno
index|[
name|i
index|]
condition|)
block|{
comment|/* The GPU can not handle its semaphore value wrapping, 			 * so every billion or so execbuffers, we need to stall 			 * the GPU in order to reset the counters. 			 */
name|ret
operator|=
name|i915_gpu_idle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|i915_gem_retire_requests
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ring
operator|->
name|sync_seqno
index|[
name|i
index|]
operator|==
literal|0
argument_list|,
operator|(
literal|"Non-zero sync_seqno"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ring
operator|==
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
operator|&&
name|mode
operator|!=
name|dev_priv
operator|->
name|relative_constants_mode
condition|)
block|{
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_NOOP
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_LOAD_REGISTER_IMM
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|INSTPM
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|mask
operator|<<
literal|16
operator||
name|mode
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|relative_constants_mode
operator|=
name|mode
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|I915_EXEC_GEN7_SOL_RESET
condition|)
block|{
name|ret
operator|=
name|i915_reset_gen7_sol_offsets
argument_list|(
name|dev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
block|}
name|exec_start
operator|=
name|batch_obj
operator|->
name|gtt_offset
operator|+
name|args
operator|->
name|batch_start_offset
expr_stmt|;
name|exec_len
operator|=
name|args
operator|->
name|batch_len
expr_stmt|;
if|if
condition|(
name|i915_fix_mi_batchbuffer_end
condition|)
block|{
name|i915_gem_fix_mi_batchbuffer_end
argument_list|(
name|batch_obj
argument_list|,
name|args
operator|->
name|batch_start_offset
argument_list|,
name|args
operator|->
name|batch_len
argument_list|)
expr_stmt|;
block|}
name|CTR4
argument_list|(
name|KTR_DRM
argument_list|,
literal|"ring_dispatch %s %d exec %x %x"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|seqno
argument_list|,
name|exec_start
argument_list|,
name|exec_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cliprects
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|num_cliprects
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|i915_emit_box
argument_list|(
name|dev
argument_list|,
operator|&
name|cliprects
index|[
name|i
index|]
argument_list|,
name|args
operator|->
name|DR1
argument_list|,
name|args
operator|->
name|DR4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|ring
operator|->
name|dispatch_execbuffer
argument_list|(
name|ring
argument_list|,
name|exec_start
argument_list|,
name|exec_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
name|ret
operator|=
name|ring
operator|->
name|dispatch_execbuffer
argument_list|(
name|ring
argument_list|,
name|exec_start
argument_list|,
name|exec_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
block|}
name|i915_gem_execbuffer_move_to_active
argument_list|(
operator|&
name|objects
argument_list|,
name|ring
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
name|i915_gem_execbuffer_retire_commands
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|err
label|:
name|eb_destroy
argument_list|(
name|eb
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|objects
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|list_first_entry
argument_list|(
operator|&
name|objects
argument_list|,
expr|struct
name|drm_i915_gem_object
argument_list|,
name|exec_list
argument_list|)
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pre_struct_lock_err
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|buffer_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|relocs_ma
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|vm_page_unhold_pages
argument_list|(
name|relocs_ma
index|[
name|i
index|]
argument_list|,
name|howmany
argument_list|(
name|exec
index|[
name|i
index|]
operator|.
name|relocation_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_i915_gem_relocation_entry
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|relocs_ma
index|[
name|i
index|]
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|relocs_ma
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cliprects
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Legacy execbuffer just creates an exec2 list from the original exec object  * list array and passes it to the real function.  */
end_comment

begin_function
name|int
name|i915_gem_execbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_execbuffer
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_execbuffer2
name|exec2
decl_stmt|;
name|struct
name|drm_i915_gem_exec_object
modifier|*
name|exec_list
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|exec2_list
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"buffers_ptr %d buffer_count %d len %08x\n"
argument_list|,
operator|(
name|int
operator|)
name|args
operator|->
name|buffers_ptr
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|,
name|args
operator|->
name|batch_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|buffer_count
operator|<
literal|1
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"execbuf with %d buffers\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Copy in the exec list from userland */
comment|/* XXXKIB user-controlled malloc size */
name|exec_list
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|exec_list
argument_list|)
operator|*
name|args
operator|->
name|buffer_count
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|exec2_list
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|exec2_list
argument_list|)
operator|*
name|args
operator|->
name|buffer_count
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|buffers_ptr
argument_list|,
name|exec_list
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|exec_list
argument_list|)
operator|*
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"copy %d exec entries failed %d\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|exec_list
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|exec2_list
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|buffer_count
condition|;
name|i
operator|++
control|)
block|{
name|exec2_list
index|[
name|i
index|]
operator|.
name|handle
operator|=
name|exec_list
index|[
name|i
index|]
operator|.
name|handle
expr_stmt|;
name|exec2_list
index|[
name|i
index|]
operator|.
name|relocation_count
operator|=
name|exec_list
index|[
name|i
index|]
operator|.
name|relocation_count
expr_stmt|;
name|exec2_list
index|[
name|i
index|]
operator|.
name|relocs_ptr
operator|=
name|exec_list
index|[
name|i
index|]
operator|.
name|relocs_ptr
expr_stmt|;
name|exec2_list
index|[
name|i
index|]
operator|.
name|alignment
operator|=
name|exec_list
index|[
name|i
index|]
operator|.
name|alignment
expr_stmt|;
name|exec2_list
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|exec_list
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
condition|)
name|exec2_list
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|EXEC_OBJECT_NEEDS_FENCE
expr_stmt|;
else|else
name|exec2_list
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|exec2
operator|.
name|buffers_ptr
operator|=
name|args
operator|->
name|buffers_ptr
expr_stmt|;
name|exec2
operator|.
name|buffer_count
operator|=
name|args
operator|->
name|buffer_count
expr_stmt|;
name|exec2
operator|.
name|batch_start_offset
operator|=
name|args
operator|->
name|batch_start_offset
expr_stmt|;
name|exec2
operator|.
name|batch_len
operator|=
name|args
operator|->
name|batch_len
expr_stmt|;
name|exec2
operator|.
name|DR1
operator|=
name|args
operator|->
name|DR1
expr_stmt|;
name|exec2
operator|.
name|DR4
operator|=
name|args
operator|->
name|DR4
expr_stmt|;
name|exec2
operator|.
name|num_cliprects
operator|=
name|args
operator|->
name|num_cliprects
expr_stmt|;
name|exec2
operator|.
name|cliprects_ptr
operator|=
name|args
operator|->
name|cliprects_ptr
expr_stmt|;
name|exec2
operator|.
name|flags
operator|=
name|I915_EXEC_RENDER
expr_stmt|;
name|i915_execbuffer2_set_context_id
argument_list|(
name|exec2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_do_execbuffer
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
name|file
argument_list|,
operator|&
name|exec2
argument_list|,
name|exec2_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
comment|/* Copy the new buffer offsets back to the user's exec list. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|buffer_count
condition|;
name|i
operator|++
control|)
name|exec_list
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|exec2_list
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
comment|/* ... and back out to userspace */
name|ret
operator|=
operator|-
name|copyout
argument_list|(
name|exec_list
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|buffers_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|exec_list
argument_list|)
operator|*
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"failed to copy %d exec entries "
literal|"back to user (%d)\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|exec_list
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|exec2_list
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_execbuffer2
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_execbuffer2
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|exec2_list
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"buffers_ptr %jx buffer_count %d len %08x\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|args
operator|->
name|buffers_ptr
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|,
name|args
operator|->
name|batch_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|buffer_count
operator|<
literal|1
operator|||
name|args
operator|->
name|buffer_count
operator|>
name|UINT_MAX
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|exec2_list
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"execbuf2 with %d buffers\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* XXXKIB user-controllable malloc size */
name|exec2_list
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|exec2_list
argument_list|)
operator|*
name|args
operator|->
name|buffer_count
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|buffers_ptr
argument_list|,
name|exec2_list
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|exec2_list
argument_list|)
operator|*
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"copy %d exec entries failed %d\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|exec2_list
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
name|ret
operator|=
name|i915_gem_do_execbuffer
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
name|file
argument_list|,
name|args
argument_list|,
name|exec2_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
comment|/* Copy the new buffer offsets back to the user's exec list. */
name|ret
operator|=
operator|-
name|copyout
argument_list|(
name|exec2_list
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|buffers_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|exec2_list
argument_list|)
operator|*
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"failed to copy %d exec entries "
literal|"back to user (%d)\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|exec2_list
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

