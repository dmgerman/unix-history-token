begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Â© 2008,2010 Intel Corporation  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  *  * Authors:  *    Eric Anholt<eric@anholt.net>  *    Chris Wilson<chris@chris-wilson.co.uk>  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/sf_buf.h>
end_include

begin_struct
struct|struct
name|eb_objects
block|{
name|int
name|and
decl_stmt|;
name|struct
name|hlist_head
name|buckets
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|eb_objects
modifier|*
name|eb_create
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|struct
name|eb_objects
modifier|*
name|eb
decl_stmt|;
name|int
name|count
init|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|hlist_head
argument_list|)
operator|/
literal|2
decl_stmt|;
name|BUILD_BUG_ON_NOT_POWER_OF_2
argument_list|(
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|hlist_head
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>
name|size
condition|)
name|count
operator|>>=
literal|1
expr_stmt|;
name|eb
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hlist_head
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|eb_objects
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|==
name|NULL
condition|)
return|return
name|eb
return|;
name|eb
operator|->
name|and
operator|=
name|count
operator|-
literal|1
expr_stmt|;
return|return
name|eb
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eb_reset
parameter_list|(
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|)
block|{
name|memset
argument_list|(
name|eb
operator|->
name|buckets
argument_list|,
literal|0
argument_list|,
operator|(
name|eb
operator|->
name|and
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hlist_head
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eb_add_object
parameter_list|(
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|hlist_add_head
argument_list|(
operator|&
name|obj
operator|->
name|exec_node
argument_list|,
operator|&
name|eb
operator|->
name|buckets
index|[
name|obj
operator|->
name|exec_handle
operator|&
name|eb
operator|->
name|and
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_i915_gem_object
modifier|*
name|eb_get_object
parameter_list|(
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|,
name|unsigned
name|long
name|handle
parameter_list|)
block|{
name|struct
name|hlist_head
modifier|*
name|head
decl_stmt|;
name|struct
name|hlist_node
modifier|*
name|node
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|head
operator|=
operator|&
name|eb
operator|->
name|buckets
index|[
name|handle
operator|&
name|eb
operator|->
name|and
index|]
expr_stmt|;
name|hlist_for_each
argument_list|(
argument|node
argument_list|,
argument|head
argument_list|)
block|{
name|obj
operator|=
name|hlist_entry
argument_list|(
name|node
argument_list|,
expr|struct
name|drm_i915_gem_object
argument_list|,
name|exec_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|exec_handle
operator|==
name|handle
condition|)
return|return
name|obj
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eb_destroy
parameter_list|(
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|)
block|{
name|free
argument_list|(
name|eb
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|use_cpu_reloc
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
return|return
operator|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|==
name|I915_GEM_DOMAIN_CPU
operator|||
operator|!
name|obj
operator|->
name|map_and_fenceable
operator|||
name|obj
operator|->
name|cache_level
operator|!=
name|I915_CACHE_NONE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_relocate_entry
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|,
name|struct
name|drm_i915_gem_relocation_entry
modifier|*
name|reloc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_gem_object
modifier|*
name|target_obj
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|target_i915_obj
decl_stmt|;
name|uint32_t
name|target_offset
decl_stmt|;
name|int
name|ret
init|=
operator|-
name|EINVAL
decl_stmt|;
comment|/* we've already hold a reference to all valid objects */
name|target_obj
operator|=
operator|&
name|eb_get_object
argument_list|(
name|eb
argument_list|,
name|reloc
operator|->
name|target_handle
argument_list|)
operator|->
name|base
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|target_obj
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|-
name|ENOENT
return|;
name|target_i915_obj
operator|=
name|to_intel_bo
argument_list|(
name|target_obj
argument_list|)
expr_stmt|;
name|target_offset
operator|=
name|target_i915_obj
operator|->
name|gtt_offset
expr_stmt|;
comment|/* Sandybridge PPGTT errata: We need a global gtt mapping for MI and 	 * pipe_control writes because the gpu doesn't properly redirect them 	 * through the ppgtt for non_secure batchbuffers. */
if|if
condition|(
name|unlikely
argument_list|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|&&
name|reloc
operator|->
name|write_domain
operator|==
name|I915_GEM_DOMAIN_INSTRUCTION
operator|&&
operator|!
name|target_i915_obj
operator|->
name|has_global_gtt_mapping
argument_list|)
condition|)
block|{
name|i915_gem_gtt_bind_object
argument_list|(
name|target_i915_obj
argument_list|,
name|target_i915_obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
block|}
comment|/* Validate that the target is in a valid r/w GPU domain */
if|if
condition|(
name|unlikely
argument_list|(
name|reloc
operator|->
name|write_domain
operator|&
operator|(
name|reloc
operator|->
name|write_domain
operator|-
literal|1
operator|)
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"reloc with multiple write domains: "
literal|"obj %p target %d offset %d "
literal|"read %08x write %08x"
argument_list|,
name|obj
argument_list|,
name|reloc
operator|->
name|target_handle
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|offset
argument_list|,
name|reloc
operator|->
name|read_domains
argument_list|,
name|reloc
operator|->
name|write_domain
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|reloc
operator|->
name|write_domain
operator||
name|reloc
operator|->
name|read_domains
operator|)
operator|&
operator|~
name|I915_GEM_GPU_DOMAINS
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"reloc with read/write non-GPU domains: "
literal|"obj %p target %d offset %d "
literal|"read %08x write %08x"
argument_list|,
name|obj
argument_list|,
name|reloc
operator|->
name|target_handle
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|offset
argument_list|,
name|reloc
operator|->
name|read_domains
argument_list|,
name|reloc
operator|->
name|write_domain
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|reloc
operator|->
name|write_domain
operator|&&
name|target_obj
operator|->
name|pending_write_domain
operator|&&
name|reloc
operator|->
name|write_domain
operator|!=
name|target_obj
operator|->
name|pending_write_domain
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Write domain conflict: "
literal|"obj %p target %d offset %d "
literal|"new %08x old %08x\n"
argument_list|,
name|obj
argument_list|,
name|reloc
operator|->
name|target_handle
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|offset
argument_list|,
name|reloc
operator|->
name|write_domain
argument_list|,
name|target_obj
operator|->
name|pending_write_domain
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|target_obj
operator|->
name|pending_read_domains
operator||=
name|reloc
operator|->
name|read_domains
expr_stmt|;
name|target_obj
operator|->
name|pending_write_domain
operator||=
name|reloc
operator|->
name|write_domain
expr_stmt|;
comment|/* If the relocation already has the right value in it, no 	 * more work needs to be done. 	 */
if|if
condition|(
name|target_offset
operator|==
name|reloc
operator|->
name|presumed_offset
condition|)
return|return
literal|0
return|;
comment|/* Check that the relocation address is valid... */
if|if
condition|(
name|unlikely
argument_list|(
name|reloc
operator|->
name|offset
operator|>
name|obj
operator|->
name|base
operator|.
name|size
operator|-
literal|4
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Relocation beyond object bounds: "
literal|"obj %p target %d offset %d size %d.\n"
argument_list|,
name|obj
argument_list|,
name|reloc
operator|->
name|target_handle
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|offset
argument_list|,
operator|(
name|int
operator|)
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|reloc
operator|->
name|offset
operator|&
literal|3
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Relocation not 4-byte aligned: "
literal|"obj %p target %d offset %d.\n"
argument_list|,
name|obj
argument_list|,
name|reloc
operator|->
name|target_handle
argument_list|,
operator|(
name|int
operator|)
name|reloc
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* We can't wait for rendering with pagefaults disabled */
if|if
condition|(
name|obj
operator|->
name|active
operator|&&
operator|(
name|curthread
operator|->
name|td_pflags
operator|&
name|TDP_NOFAULTING
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
name|EFAULT
return|;
name|reloc
operator|->
name|delta
operator|+=
name|target_offset
expr_stmt|;
if|if
condition|(
name|use_cpu_reloc
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|uint32_t
name|page_offset
init|=
name|reloc
operator|->
name|offset
operator|&
name|PAGE_MASK
decl_stmt|;
name|char
modifier|*
name|vaddr
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|ret
operator|=
name|i915_gem_object_set_to_cpu_domain
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|obj
operator|->
name|pages
index|[
name|OFF_TO_IDX
argument_list|(
name|reloc
operator|->
name|offset
argument_list|)
index|]
argument_list|,
name|SFB_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|vaddr
operator|=
operator|(
name|void
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|vaddr
operator|+
name|page_offset
operator|)
operator|=
name|reloc
operator|->
name|delta
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|__iomem
modifier|*
name|reloc_entry
decl_stmt|;
name|char
name|__iomem
modifier|*
name|reloc_page
decl_stmt|;
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|obj
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|i915_gem_object_put_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* Map the page containing the relocation we're going to perform.  */
name|reloc
operator|->
name|offset
operator|+=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
name|reloc_page
operator|=
name|pmap_mapdev_attr
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
operator|+
operator|(
name|reloc
operator|->
name|offset
operator|&
operator|~
name|PAGE_MASK
operator|)
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
name|reloc_entry
operator|=
operator|(
name|uint32_t
name|__iomem
operator|*
operator|)
operator|(
name|reloc_page
operator|+
operator|(
name|reloc
operator|->
name|offset
operator|&
name|PAGE_MASK
operator|)
operator|)
expr_stmt|;
operator|*
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
name|reloc_entry
operator|=
name|reloc
operator|->
name|delta
expr_stmt|;
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|reloc_page
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
comment|/* and update the user's relocation entry */
name|reloc
operator|->
name|presumed_offset
operator|=
name|target_offset
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_relocate_object
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|)
block|{
define|#
directive|define
name|N_RELOC
parameter_list|(
name|x
parameter_list|)
value|((x) / sizeof(struct drm_i915_gem_relocation_entry))
name|struct
name|drm_i915_gem_relocation_entry
name|stack_reloc
index|[
name|N_RELOC
argument_list|(
literal|512
argument_list|)
index|]
decl_stmt|;
name|struct
name|drm_i915_gem_relocation_entry
name|__user
modifier|*
name|user_relocs
decl_stmt|;
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
init|=
name|obj
operator|->
name|exec_entry
decl_stmt|;
name|int
name|remain
decl_stmt|,
name|ret
decl_stmt|;
name|user_relocs
operator|=
operator|(
name|void
name|__user
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|entry
operator|->
name|relocs_ptr
expr_stmt|;
name|remain
operator|=
name|entry
operator|->
name|relocation_count
expr_stmt|;
while|while
condition|(
name|remain
condition|)
block|{
name|struct
name|drm_i915_gem_relocation_entry
modifier|*
name|r
init|=
name|stack_reloc
decl_stmt|;
name|int
name|count
init|=
name|remain
decl_stmt|;
if|if
condition|(
name|count
operator|>
name|ARRAY_SIZE
argument_list|(
name|stack_reloc
argument_list|)
condition|)
name|count
operator|=
name|ARRAY_SIZE
argument_list|(
name|stack_reloc
argument_list|)
expr_stmt|;
name|remain
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|__copy_from_user_inatomic
argument_list|(
name|r
argument_list|,
name|user_relocs
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|r
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
do|do
block|{
name|u64
name|offset
init|=
name|r
operator|->
name|presumed_offset
decl_stmt|;
name|ret
operator|=
name|i915_gem_execbuffer_relocate_entry
argument_list|(
name|obj
argument_list|,
name|eb
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|r
operator|->
name|presumed_offset
operator|!=
name|offset
operator|&&
name|__copy_to_user_inatomic
argument_list|(
operator|&
name|user_relocs
operator|->
name|presumed_offset
argument_list|,
operator|&
name|r
operator|->
name|presumed_offset
argument_list|,
sizeof|sizeof
argument_list|(
name|r
operator|->
name|presumed_offset
argument_list|)
argument_list|)
condition|)
block|{
return|return
operator|-
name|EFAULT
return|;
block|}
name|user_relocs
operator|++
expr_stmt|;
name|r
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
condition|)
do|;
block|}
return|return
literal|0
return|;
undef|#
directive|undef
name|N_RELOC
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_relocate_object_slow
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|,
name|struct
name|drm_i915_gem_relocation_entry
modifier|*
name|relocs
parameter_list|)
block|{
specifier|const
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
init|=
name|obj
operator|->
name|exec_entry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|relocation_count
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|i915_gem_execbuffer_relocate_entry
argument_list|(
name|obj
argument_list|,
name|eb
argument_list|,
operator|&
name|relocs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_relocate
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|,
name|struct
name|list_head
modifier|*
name|objects
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|pflags
decl_stmt|;
comment|/* This is the fast path and we cannot handle a pagefault whilst 	 * holding the struct mutex lest the user pass in the relocations 	 * contained within a mmaped bo. For in such a case we, the page 	 * fault handler would call i915_gem_fault() and we would try to 	 * acquire the struct mutex again. Obviously this is bad and so 	 * lockdep complains vehemently. 	 */
name|pflags
operator|=
name|vm_fault_disable_pagefaults
argument_list|()
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
block|{
name|ret
operator|=
name|i915_gem_execbuffer_relocate_object
argument_list|(
name|obj
argument_list|,
name|eb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
block|}
name|vm_fault_enable_pagefaults
argument_list|(
name|pflags
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_define
define|#
directive|define
name|__EXEC_OBJECT_HAS_PIN
value|(1<<31)
end_define

begin_define
define|#
directive|define
name|__EXEC_OBJECT_HAS_FENCE
value|(1<<30)
end_define

begin_function
specifier|static
name|int
name|need_reloc_mappable
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
init|=
name|obj
operator|->
name|exec_entry
decl_stmt|;
return|return
name|entry
operator|->
name|relocation_count
operator|&&
operator|!
name|use_cpu_reloc
argument_list|(
name|obj
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_reserve_object
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
init|=
name|obj
operator|->
name|exec_entry
decl_stmt|;
name|bool
name|has_fenced_gpu_access
init|=
name|INTEL_INFO
argument_list|(
name|ring
operator|->
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
decl_stmt|;
name|bool
name|need_fence
decl_stmt|,
name|need_mappable
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|need_fence
operator|=
name|has_fenced_gpu_access
operator|&&
name|entry
operator|->
name|flags
operator|&
name|EXEC_OBJECT_NEEDS_FENCE
operator|&&
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
expr_stmt|;
name|need_mappable
operator|=
name|need_fence
operator|||
name|need_reloc_mappable
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_pin
argument_list|(
name|obj
argument_list|,
name|entry
operator|->
name|alignment
argument_list|,
name|need_mappable
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|entry
operator|->
name|flags
operator||=
name|__EXEC_OBJECT_HAS_PIN
expr_stmt|;
if|if
condition|(
name|has_fenced_gpu_access
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|EXEC_OBJECT_NEEDS_FENCE
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_get_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|i915_gem_object_pin_fence
argument_list|(
name|obj
argument_list|)
condition|)
name|entry
operator|->
name|flags
operator||=
name|__EXEC_OBJECT_HAS_FENCE
expr_stmt|;
name|obj
operator|->
name|pending_fenced_gpu_access
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Ensure ppgtt mapping exists if needed */
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
operator|&&
operator|!
name|obj
operator|->
name|has_aliasing_ppgtt_mapping
condition|)
block|{
name|i915_ppgtt_bind_object
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
argument_list|,
name|obj
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
name|obj
operator|->
name|has_aliasing_ppgtt_mapping
operator|=
literal|1
expr_stmt|;
block|}
name|entry
operator|->
name|offset
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_execbuffer_unreserve_object
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|obj
operator|->
name|gtt_space
condition|)
return|return;
name|entry
operator|=
name|obj
operator|->
name|exec_entry
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|__EXEC_OBJECT_HAS_FENCE
condition|)
name|i915_gem_object_unpin_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|__EXEC_OBJECT_HAS_PIN
condition|)
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator|&=
operator|~
operator|(
name|__EXEC_OBJECT_HAS_FENCE
operator||
name|__EXEC_OBJECT_HAS_PIN
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_reserve
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|list_head
modifier|*
name|objects
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|list_head
name|ordered_objects
decl_stmt|;
name|bool
name|has_fenced_gpu_access
init|=
name|INTEL_INFO
argument_list|(
name|ring
operator|->
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ordered_objects
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
name|objects
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
decl_stmt|;
name|bool
name|need_fence
decl_stmt|,
name|need_mappable
decl_stmt|;
name|obj
operator|=
name|list_first_entry
argument_list|(
name|objects
argument_list|,
expr|struct
name|drm_i915_gem_object
argument_list|,
name|exec_list
argument_list|)
expr_stmt|;
name|entry
operator|=
name|obj
operator|->
name|exec_entry
expr_stmt|;
name|need_fence
operator|=
name|has_fenced_gpu_access
operator|&&
name|entry
operator|->
name|flags
operator|&
name|EXEC_OBJECT_NEEDS_FENCE
operator|&&
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
expr_stmt|;
name|need_mappable
operator|=
name|need_fence
operator|||
name|need_reloc_mappable
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_mappable
condition|)
name|list_move
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|,
operator|&
name|ordered_objects
argument_list|)
expr_stmt|;
else|else
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|,
operator|&
name|ordered_objects
argument_list|)
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|pending_read_domains
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|pending_write_domain
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|pending_fenced_gpu_access
operator|=
name|false
expr_stmt|;
block|}
name|list_splice
argument_list|(
operator|&
name|ordered_objects
argument_list|,
name|objects
argument_list|)
expr_stmt|;
comment|/* Attempt to pin all of the buffers into the GTT. 	 * This is done in 3 phases: 	 * 	 * 1a. Unbind all objects that do not match the GTT constraints for 	 *     the execbuffer (fenceable, mappable, alignment etc). 	 * 1b. Increment pin count for already bound objects. 	 * 2.  Bind new objects. 	 * 3.  Decrement pin count. 	 * 	 * This avoid unnecessary unbinding of later objects in order to make 	 * room for the earlier objects *unless* we need to defragment. 	 */
name|retry
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* Unbind any ill-fitting objects or pin. */
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
block|{
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|entry
init|=
name|obj
operator|->
name|exec_entry
decl_stmt|;
name|bool
name|need_fence
decl_stmt|,
name|need_mappable
decl_stmt|;
if|if
condition|(
operator|!
name|obj
operator|->
name|gtt_space
condition|)
continue|continue;
name|need_fence
operator|=
name|has_fenced_gpu_access
operator|&&
name|entry
operator|->
name|flags
operator|&
name|EXEC_OBJECT_NEEDS_FENCE
operator|&&
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
expr_stmt|;
name|need_mappable
operator|=
name|need_fence
operator|||
name|need_reloc_mappable
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|alignment
operator|&&
name|obj
operator|->
name|gtt_offset
operator|&
operator|(
name|entry
operator|->
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|need_mappable
operator|&&
operator|!
name|obj
operator|->
name|map_and_fenceable
operator|)
condition|)
name|ret
operator|=
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|i915_gem_execbuffer_reserve_object
argument_list|(
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* Bind fresh objects */
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|gtt_space
condition|)
continue|continue;
name|ret
operator|=
name|i915_gem_execbuffer_reserve_object
argument_list|(
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
block|}
name|err
label|:
comment|/* Decrement pin count for bound objects */
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
name|i915_gem_execbuffer_unreserve_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
name|ENOSPC
operator|||
name|retry
operator|++
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|i915_gem_evict_everything
argument_list|(
name|ring
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_relocate_slow
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|struct
name|list_head
modifier|*
name|objects
parameter_list|,
name|struct
name|eb_objects
modifier|*
name|eb
parameter_list|,
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|exec
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|drm_i915_gem_relocation_entry
modifier|*
name|reloc
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
modifier|*
name|reloc_offset
decl_stmt|;
name|int
name|i
decl_stmt|,
name|total
decl_stmt|,
name|ret
decl_stmt|;
comment|/* We may process another execbuffer during the unlock... */
while|while
condition|(
operator|!
name|list_empty
argument_list|(
name|objects
argument_list|)
condition|)
block|{
name|obj
operator|=
name|list_first_entry
argument_list|(
name|objects
argument_list|,
expr|struct
name|drm_i915_gem_object
argument_list|,
name|exec_list
argument_list|)
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|total
operator|+=
name|exec
index|[
name|i
index|]
operator|.
name|relocation_count
expr_stmt|;
name|reloc_offset
operator|=
name|drm_malloc_ab
argument_list|(
name|count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reloc_offset
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|drm_malloc_ab
argument_list|(
name|total
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|==
name|NULL
operator|||
name|reloc_offset
operator|==
name|NULL
condition|)
block|{
name|drm_free_large
argument_list|(
name|reloc
argument_list|)
expr_stmt|;
name|drm_free_large
argument_list|(
name|reloc_offset
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_i915_gem_relocation_entry
name|__user
modifier|*
name|user_relocs
decl_stmt|;
name|u64
name|invalid_offset
init|=
operator|(
name|u64
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|j
decl_stmt|;
name|user_relocs
operator|=
operator|(
name|void
name|__user
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|exec
index|[
name|i
index|]
operator|.
name|relocs_ptr
expr_stmt|;
if|if
condition|(
name|copy_from_user
argument_list|(
name|reloc
operator|+
name|total
argument_list|,
name|user_relocs
argument_list|,
name|exec
index|[
name|i
index|]
operator|.
name|relocation_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* As we do not update the known relocation offsets after 		 * relocating (due to the complexities in lock handling), 		 * we need to mark them as invalid now so that we force the 		 * relocation processing next time. Just in case the target 		 * object is evicted and then rebound into its old 		 * presumed_offset before the next execbuffer - if that 		 * happened we would make the mistake of assuming that the 		 * relocations were valid. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|exec
index|[
name|i
index|]
operator|.
name|relocation_count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|copy_to_user
argument_list|(
operator|&
name|user_relocs
index|[
name|j
index|]
operator|.
name|presumed_offset
argument_list|,
operator|&
name|invalid_offset
argument_list|,
sizeof|sizeof
argument_list|(
name|invalid_offset
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|reloc_offset
index|[
name|i
index|]
operator|=
name|total
expr_stmt|;
name|total
operator|+=
name|exec
index|[
name|i
index|]
operator|.
name|relocation_count
expr_stmt|;
block|}
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* reacquire the objects */
name|eb_reset
argument_list|(
name|eb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|exec
index|[
name|i
index|]
operator|.
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Invalid object handle %d at index %d\n"
argument_list|,
name|exec
index|[
name|i
index|]
operator|.
name|handle
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|list_add_tail
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|,
name|objects
argument_list|)
expr_stmt|;
name|obj
operator|->
name|exec_handle
operator|=
name|exec
index|[
name|i
index|]
operator|.
name|handle
expr_stmt|;
name|obj
operator|->
name|exec_entry
operator|=
operator|&
name|exec
index|[
name|i
index|]
expr_stmt|;
name|eb_add_object
argument_list|(
name|eb
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|i915_gem_execbuffer_reserve
argument_list|(
name|ring
argument_list|,
name|file
argument_list|,
name|objects
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
block|{
name|int
name|offset
init|=
name|obj
operator|->
name|exec_entry
operator|-
name|exec
decl_stmt|;
name|ret
operator|=
name|i915_gem_execbuffer_relocate_object_slow
argument_list|(
name|obj
argument_list|,
name|eb
argument_list|,
name|reloc
operator|+
name|reloc_offset
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* Leave the user relocations as are, this is the painfully slow path, 	 * and we want to avoid the complication of dropping the lock whilst 	 * having buffers reserved in the aperture and so causing spurious 	 * ENOSPC for random operations. 	 */
name|err
label|:
name|drm_free_large
argument_list|(
name|reloc
argument_list|)
expr_stmt|;
name|drm_free_large
argument_list|(
name|reloc_offset
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_wait_for_flips
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|u32
name|flips
parameter_list|)
block|{
name|u32
name|plane
decl_stmt|,
name|flip_mask
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Check for any pending flips. As we only maintain a flip queue depth 	 * of 1, we can simply insert a WAIT for the next display flip prior 	 * to executing the batch and avoid stalling the CPU. 	 */
for|for
control|(
name|plane
operator|=
literal|0
init|;
name|flips
operator|>>
name|plane
condition|;
name|plane
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|flips
operator|>>
name|plane
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|plane
condition|)
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_B_FLIP
expr_stmt|;
else|else
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_A_FLIP
expr_stmt|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_WAIT_FOR_EVENT
operator||
name|flip_mask
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_NOOP
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_execbuffer_move_to_gpu
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|struct
name|list_head
modifier|*
name|objects
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|uint32_t
name|flush_domains
init|=
literal|0
decl_stmt|;
name|uint32_t
name|flips
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
block|{
name|ret
operator|=
name|i915_gem_object_sync
argument_list|(
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
name|I915_GEM_DOMAIN_CPU
condition|)
name|i915_gem_clflush_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|pending_write_domain
condition|)
name|flips
operator||=
name|atomic_read
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|)
expr_stmt|;
name|flush_domains
operator||=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
block|}
if|if
condition|(
name|flips
condition|)
block|{
name|ret
operator|=
name|i915_gem_execbuffer_wait_for_flips
argument_list|(
name|ring
argument_list|,
name|flips
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
name|flush_domains
operator|&
name|I915_GEM_DOMAIN_CPU
condition|)
name|i915_gem_chipset_flush
argument_list|(
name|ring
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|flush_domains
operator|&
name|I915_GEM_DOMAIN_GTT
condition|)
name|wmb
argument_list|()
expr_stmt|;
comment|/* Unconditionally invalidate gpu caches and ensure that we do flush 	 * any residual writes from the previous batch. 	 */
return|return
name|intel_ring_invalidate_all_caches
argument_list|(
name|ring
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|i915_gem_check_execbuffer
parameter_list|(
name|struct
name|drm_i915_gem_execbuffer2
modifier|*
name|exec
parameter_list|)
block|{
return|return
operator|(
operator|(
name|exec
operator|->
name|batch_start_offset
operator||
name|exec
operator|->
name|batch_len
operator|)
operator|&
literal|0x7
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|validate_exec_list
parameter_list|(
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|exec
parameter_list|,
name|int
name|count
parameter_list|,
name|vm_page_t
modifier|*
modifier|*
modifier|*
name|map
parameter_list|,
name|int
modifier|*
modifier|*
name|maplen
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|relocs_total
init|=
literal|0
decl_stmt|;
name|int
name|relocs_max
init|=
name|INT_MAX
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|drm_i915_gem_relocation_entry
argument_list|)
decl_stmt|;
name|vm_page_t
modifier|*
name|ma
decl_stmt|;
comment|/* XXXKIB various limits checking is missing there */
operator|*
name|map
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ma
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
operator|*
name|maplen
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|maplen
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|char
name|__user
modifier|*
name|ptr
init|=
operator|(
name|char
name|__user
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|exec
index|[
name|i
index|]
operator|.
name|relocs_ptr
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* limited by fault_in_pages_readable() */
comment|/* First check for malicious input causing overflow in 		 * the worst case where we need to allocate the entire 		 * relocation tree as a single array. 		 */
if|if
condition|(
name|exec
index|[
name|i
index|]
operator|.
name|relocation_count
operator|>
name|relocs_max
operator|-
name|relocs_total
condition|)
return|return
operator|-
name|EINVAL
return|;
name|relocs_total
operator|+=
name|exec
index|[
name|i
index|]
operator|.
name|relocation_count
expr_stmt|;
name|length
operator|=
name|exec
index|[
name|i
index|]
operator|.
name|relocation_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_i915_gem_relocation_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|map
operator|)
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Since both start and end of the relocation region 		 * may be not aligned on the page boundary, be 		 * conservative and request a page slot for each 		 * partial page.  Thus +2. 		 */
name|int
name|page_count
decl_stmt|;
name|page_count
operator|=
name|howmany
argument_list|(
name|length
argument_list|,
name|PAGE_SIZE
argument_list|)
operator|+
literal|2
expr_stmt|;
name|ma
operator|=
operator|(
operator|*
name|map
operator|)
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|page_count
operator|*
sizeof|sizeof
argument_list|(
name|vm_page_t
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
operator|(
operator|*
name|maplen
operator|)
index|[
name|i
index|]
operator|=
name|vm_fault_quick_hold_pages
argument_list|(
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ptr
argument_list|,
name|length
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|ma
argument_list|,
name|page_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|maplen
operator|)
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|ma
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
operator|(
operator|*
name|map
operator|)
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_execbuffer_move_to_active
parameter_list|(
name|struct
name|list_head
modifier|*
name|objects
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|objects
argument_list|,
argument|exec_list
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|KTR
argument_list|)
name|u32
name|old_read
init|=
name|obj
operator|->
name|base
operator|.
name|read_domains
decl_stmt|;
name|u32
name|old_write
init|=
name|obj
operator|->
name|base
operator|.
name|write_domain
decl_stmt|;
endif|#
directive|endif
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|pending_read_domains
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|pending_write_domain
expr_stmt|;
name|obj
operator|->
name|fenced_gpu_access
operator|=
name|obj
operator|->
name|pending_fenced_gpu_access
expr_stmt|;
name|i915_gem_object_move_to_active
argument_list|(
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
condition|)
block|{
name|obj
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|obj
operator|->
name|last_write_seqno
operator|=
name|intel_ring_get_seqno
argument_list|(
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|pin_count
condition|)
comment|/* check for potential scanout */
name|intel_mark_fb_busy
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain move_to_active %p %x %x"
argument_list|,
name|obj
argument_list|,
name|old_read
argument_list|,
name|old_write
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_execbuffer_retire_commands
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
comment|/* Unconditionally force add_request to emit a full flush. */
name|ring
operator|->
name|gpu_caches_dirty
operator|=
name|true
expr_stmt|;
comment|/* Add a breadcrumb for the completion of the batch buffer */
operator|(
name|void
operator|)
name|i915_add_request
argument_list|(
name|ring
argument_list|,
name|file
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_reset_gen7_sol_offsets
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|||
name|ring
operator|!=
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|RCS
index|]
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|4
operator|*
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_LOAD_REGISTER_IMM
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|GEN7_SO_WRITE_OFFSET
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_do_execbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|drm_i915_gem_execbuffer2
modifier|*
name|args
parameter_list|,
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|exec
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|list_head
name|objects
decl_stmt|;
name|struct
name|eb_objects
modifier|*
name|eb
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|batch_obj
decl_stmt|;
name|struct
name|drm_clip_rect
modifier|*
name|cliprects
init|=
name|NULL
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|u32
name|ctx_id
init|=
name|i915_execbuffer2_get_context_id
argument_list|(
operator|*
name|args
argument_list|)
decl_stmt|;
name|u32
name|exec_start
decl_stmt|,
name|exec_len
decl_stmt|;
name|u32
name|mask
decl_stmt|;
name|u32
name|flags
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|mode
decl_stmt|,
name|i
decl_stmt|;
name|vm_page_t
modifier|*
modifier|*
name|relocs_ma
decl_stmt|;
name|int
modifier|*
name|relocs_len
decl_stmt|;
if|if
condition|(
operator|!
name|i915_gem_check_execbuffer
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"execbuf with invalid offset/length\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|ret
operator|=
name|validate_exec_list
argument_list|(
name|exec
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|,
operator|&
name|relocs_ma
argument_list|,
operator|&
name|relocs_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|pre_mutex_err
goto|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|I915_EXEC_SECURE
condition|)
block|{
if|if
condition|(
operator|!
name|file
operator|->
name|is_master
operator|||
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EPERM
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
name|flags
operator||=
name|I915_DISPATCH_SECURE
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|I915_EXEC_IS_PINNED
condition|)
name|flags
operator||=
name|I915_DISPATCH_PINNED
expr_stmt|;
switch|switch
condition|(
name|args
operator|->
name|flags
operator|&
name|I915_EXEC_RING_MASK
condition|)
block|{
case|case
name|I915_EXEC_DEFAULT
case|:
case|case
name|I915_EXEC_RENDER
case|:
name|ring
operator|=
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|RCS
index|]
expr_stmt|;
break|break;
case|case
name|I915_EXEC_BSD
case|:
name|ring
operator|=
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|VCS
index|]
expr_stmt|;
if|if
condition|(
name|ctx_id
operator|!=
literal|0
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Ring %s doesn't support contexts\n"
argument_list|,
name|ring
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EPERM
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
break|break;
case|case
name|I915_EXEC_BLT
case|:
name|ring
operator|=
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|BCS
index|]
expr_stmt|;
if|if
condition|(
name|ctx_id
operator|!=
literal|0
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Ring %s doesn't support contexts\n"
argument_list|,
name|ring
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EPERM
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
break|break;
default|default:
name|DRM_DEBUG
argument_list|(
literal|"execbuf with unknown ring: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|args
operator|->
name|flags
operator|&
name|I915_EXEC_RING_MASK
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
if|if
condition|(
operator|!
name|intel_ring_initialized
argument_list|(
name|ring
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"execbuf with invalid ring: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|args
operator|->
name|flags
operator|&
name|I915_EXEC_RING_MASK
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
name|mode
operator|=
name|args
operator|->
name|flags
operator|&
name|I915_EXEC_CONSTANTS_MASK
expr_stmt|;
name|mask
operator|=
name|I915_EXEC_CONSTANTS_MASK
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|I915_EXEC_CONSTANTS_REL_GENERAL
case|:
case|case
name|I915_EXEC_CONSTANTS_ABSOLUTE
case|:
case|case
name|I915_EXEC_CONSTANTS_REL_SURFACE
case|:
if|if
condition|(
name|ring
operator|==
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|RCS
index|]
operator|&&
name|mode
operator|!=
name|dev_priv
operator|->
name|relative_constants_mode
condition|)
block|{
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>
literal|5
operator|&&
name|mode
operator|==
name|I915_EXEC_CONSTANTS_REL_SURFACE
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
comment|/* The HW changed the meaning on this bit on gen6 */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|6
condition|)
name|mask
operator|&=
operator|~
name|I915_EXEC_CONSTANTS_REL_SURFACE
expr_stmt|;
block|}
break|break;
default|default:
name|DRM_DEBUG
argument_list|(
literal|"execbuf with unknown constants: %d\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
if|if
condition|(
name|args
operator|->
name|buffer_count
operator|<
literal|1
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"execbuf with %d buffers\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
if|if
condition|(
name|args
operator|->
name|num_cliprects
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ring
operator|!=
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|RCS
index|]
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"clip rectangles are only valid with the render ring\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|5
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"clip rectangles are only valid on pre-gen5\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
if|if
condition|(
name|args
operator|->
name|num_cliprects
operator|>
name|UINT_MAX
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|cliprects
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"execbuf with %u cliprects\n"
argument_list|,
name|args
operator|->
name|num_cliprects
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
name|cliprects
operator|=
name|malloc
argument_list|(
name|args
operator|->
name|num_cliprects
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cliprects
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|cliprects
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
if|if
condition|(
name|copy_from_user
argument_list|(
name|cliprects
argument_list|,
operator|(
expr|struct
name|drm_clip_rect
name|__user
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|cliprects_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cliprects
argument_list|)
operator|*
name|args
operator|->
name|num_cliprects
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
block|}
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|pre_mutex_err
goto|;
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EBUSY
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
name|eb
operator|=
name|eb_create
argument_list|(
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|==
name|NULL
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|pre_mutex_err
goto|;
block|}
comment|/* Look up object handles */
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|objects
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|buffer_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|exec
index|[
name|i
index|]
operator|.
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Invalid object handle %d at index %d\n"
argument_list|,
name|exec
index|[
name|i
index|]
operator|.
name|handle
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* prevent error path from reading uninitialized data */
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Object %p [handle %d, index %d] appears more than once in object list\n"
argument_list|,
name|obj
argument_list|,
name|exec
index|[
name|i
index|]
operator|.
name|handle
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|list_add_tail
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|,
operator|&
name|objects
argument_list|)
expr_stmt|;
name|obj
operator|->
name|exec_handle
operator|=
name|exec
index|[
name|i
index|]
operator|.
name|handle
expr_stmt|;
name|obj
operator|->
name|exec_entry
operator|=
operator|&
name|exec
index|[
name|i
index|]
expr_stmt|;
name|eb_add_object
argument_list|(
name|eb
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
comment|/* take note of the batch buffer before we might reorder the lists */
name|batch_obj
operator|=
name|list_entry
argument_list|(
name|objects
operator|.
name|prev
argument_list|,
expr|struct
name|drm_i915_gem_object
argument_list|,
name|exec_list
argument_list|)
expr_stmt|;
comment|/* Move the objects en-masse into the GTT, evicting if necessary. */
name|ret
operator|=
name|i915_gem_execbuffer_reserve
argument_list|(
name|ring
argument_list|,
name|file
argument_list|,
operator|&
name|objects
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
comment|/* The objects are in their final locations, apply the relocations. */
name|ret
operator|=
name|i915_gem_execbuffer_relocate
argument_list|(
name|dev
argument_list|,
name|eb
argument_list|,
operator|&
name|objects
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|ret
operator|==
operator|-
name|EFAULT
condition|)
block|{
name|ret
operator|=
name|i915_gem_execbuffer_relocate_slow
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|ring
argument_list|,
operator|&
name|objects
argument_list|,
name|eb
argument_list|,
name|exec
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
name|DRM_LOCK_ASSERT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* Set the pending read domains for the batch buffer to COMMAND */
if|if
condition|(
name|batch_obj
operator|->
name|base
operator|.
name|pending_write_domain
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Attempting to use self-modifying batch buffer\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|batch_obj
operator|->
name|base
operator|.
name|pending_read_domains
operator||=
name|I915_GEM_DOMAIN_COMMAND
expr_stmt|;
comment|/* snb/ivb/vlv conflate the "batch in ppgtt" bit with the "non-secure 	 * batch" bit. Hence we need to pin secure batches into the global gtt. 	 * hsw should have this fixed, but let's be paranoid and do it 	 * unconditionally for now. */
if|if
condition|(
name|flags
operator|&
name|I915_DISPATCH_SECURE
operator|&&
operator|!
name|batch_obj
operator|->
name|has_global_gtt_mapping
condition|)
name|i915_gem_gtt_bind_object
argument_list|(
name|batch_obj
argument_list|,
name|batch_obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_execbuffer_move_to_gpu
argument_list|(
name|ring
argument_list|,
operator|&
name|objects
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|i915_switch_context
argument_list|(
name|ring
argument_list|,
name|file
argument_list|,
name|ctx_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|ring
operator|==
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|RCS
index|]
operator|&&
name|mode
operator|!=
name|dev_priv
operator|->
name|relative_constants_mode
condition|)
block|{
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_NOOP
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_LOAD_REGISTER_IMM
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|INSTPM
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|mask
operator|<<
literal|16
operator||
name|mode
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|relative_constants_mode
operator|=
name|mode
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|I915_EXEC_GEN7_SOL_RESET
condition|)
block|{
name|ret
operator|=
name|i915_reset_gen7_sol_offsets
argument_list|(
name|dev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
block|}
name|exec_start
operator|=
name|batch_obj
operator|->
name|gtt_offset
operator|+
name|args
operator|->
name|batch_start_offset
expr_stmt|;
name|exec_len
operator|=
name|args
operator|->
name|batch_len
expr_stmt|;
if|if
condition|(
name|cliprects
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|num_cliprects
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|i915_emit_box
argument_list|(
name|dev
argument_list|,
operator|&
name|cliprects
index|[
name|i
index|]
argument_list|,
name|args
operator|->
name|DR1
argument_list|,
name|args
operator|->
name|DR4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|ring
operator|->
name|dispatch_execbuffer
argument_list|(
name|ring
argument_list|,
name|exec_start
argument_list|,
name|exec_len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
name|ret
operator|=
name|ring
operator|->
name|dispatch_execbuffer
argument_list|(
name|ring
argument_list|,
name|exec_start
argument_list|,
name|exec_len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
block|}
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"ring_dispatch ring=%s seqno=%d flags=%u"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|intel_ring_get_seqno
argument_list|(
name|ring
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|i915_gem_execbuffer_move_to_active
argument_list|(
operator|&
name|objects
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|i915_gem_execbuffer_retire_commands
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|err
label|:
name|eb_destroy
argument_list|(
name|eb
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|objects
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|list_first_entry
argument_list|(
operator|&
name|objects
argument_list|,
expr|struct
name|drm_i915_gem_object
argument_list|,
name|exec_list
argument_list|)
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pre_mutex_err
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|buffer_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|relocs_ma
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|vm_page_unhold_pages
argument_list|(
name|relocs_ma
index|[
name|i
index|]
argument_list|,
name|relocs_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|relocs_ma
index|[
name|i
index|]
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|relocs_len
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|relocs_ma
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cliprects
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Legacy execbuffer just creates an exec2 list from the original exec object  * list array and passes it to the real function.  */
end_comment

begin_function
name|int
name|i915_gem_execbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_execbuffer
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_execbuffer2
name|exec2
decl_stmt|;
name|struct
name|drm_i915_gem_exec_object
modifier|*
name|exec_list
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|exec2_list
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|buffer_count
operator|<
literal|1
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"execbuf with %d buffers\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Copy in the exec list from userland */
comment|/* XXXKIB user-controlled malloc size */
name|exec_list
operator|=
name|drm_malloc_ab
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|exec_list
argument_list|)
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
name|exec2_list
operator|=
name|drm_malloc_ab
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|exec2_list
argument_list|)
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_list
operator|==
name|NULL
operator|||
name|exec2_list
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Failed to allocate exec list for %d buffers\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
name|drm_free_large
argument_list|(
name|exec_list
argument_list|)
expr_stmt|;
name|drm_free_large
argument_list|(
name|exec2_list
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|ret
operator|=
name|copy_from_user
argument_list|(
name|exec_list
argument_list|,
operator|(
name|void
name|__user
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|buffers_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|exec_list
argument_list|)
operator|*
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"copy %d exec entries failed %d\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|drm_free_large
argument_list|(
name|exec_list
argument_list|)
expr_stmt|;
name|drm_free_large
argument_list|(
name|exec2_list
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|buffer_count
condition|;
name|i
operator|++
control|)
block|{
name|exec2_list
index|[
name|i
index|]
operator|.
name|handle
operator|=
name|exec_list
index|[
name|i
index|]
operator|.
name|handle
expr_stmt|;
name|exec2_list
index|[
name|i
index|]
operator|.
name|relocation_count
operator|=
name|exec_list
index|[
name|i
index|]
operator|.
name|relocation_count
expr_stmt|;
name|exec2_list
index|[
name|i
index|]
operator|.
name|relocs_ptr
operator|=
name|exec_list
index|[
name|i
index|]
operator|.
name|relocs_ptr
expr_stmt|;
name|exec2_list
index|[
name|i
index|]
operator|.
name|alignment
operator|=
name|exec_list
index|[
name|i
index|]
operator|.
name|alignment
expr_stmt|;
name|exec2_list
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|exec_list
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
condition|)
name|exec2_list
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|EXEC_OBJECT_NEEDS_FENCE
expr_stmt|;
else|else
name|exec2_list
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|exec2
operator|.
name|buffers_ptr
operator|=
name|args
operator|->
name|buffers_ptr
expr_stmt|;
name|exec2
operator|.
name|buffer_count
operator|=
name|args
operator|->
name|buffer_count
expr_stmt|;
name|exec2
operator|.
name|batch_start_offset
operator|=
name|args
operator|->
name|batch_start_offset
expr_stmt|;
name|exec2
operator|.
name|batch_len
operator|=
name|args
operator|->
name|batch_len
expr_stmt|;
name|exec2
operator|.
name|DR1
operator|=
name|args
operator|->
name|DR1
expr_stmt|;
name|exec2
operator|.
name|DR4
operator|=
name|args
operator|->
name|DR4
expr_stmt|;
name|exec2
operator|.
name|num_cliprects
operator|=
name|args
operator|->
name|num_cliprects
expr_stmt|;
name|exec2
operator|.
name|cliprects_ptr
operator|=
name|args
operator|->
name|cliprects_ptr
expr_stmt|;
name|exec2
operator|.
name|flags
operator|=
name|I915_EXEC_RENDER
expr_stmt|;
name|i915_execbuffer2_set_context_id
argument_list|(
name|exec2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_do_execbuffer
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
name|file
argument_list|,
operator|&
name|exec2
argument_list|,
name|exec2_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
comment|/* Copy the new buffer offsets back to the user's exec list. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|buffer_count
condition|;
name|i
operator|++
control|)
name|exec_list
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|exec2_list
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
comment|/* ... and back out to userspace */
name|ret
operator|=
name|copy_to_user
argument_list|(
operator|(
name|void
name|__user
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|buffers_ptr
argument_list|,
name|exec_list
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|exec_list
argument_list|)
operator|*
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"failed to copy %d exec entries "
literal|"back to user (%d)\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
name|drm_free_large
argument_list|(
name|exec_list
argument_list|)
expr_stmt|;
name|drm_free_large
argument_list|(
name|exec2_list
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_execbuffer2
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_execbuffer2
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_exec_object2
modifier|*
name|exec2_list
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|buffer_count
operator|<
literal|1
operator|||
name|args
operator|->
name|buffer_count
operator|>
name|UINT_MAX
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|exec2_list
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"execbuf2 with %d buffers\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* XXXKIB user-controllable malloc size */
name|exec2_list
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|exec2_list
argument_list|)
operator|*
name|args
operator|->
name|buffer_count
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec2_list
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Failed to allocate exec list for %d buffers\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|ret
operator|=
name|copy_from_user
argument_list|(
name|exec2_list
argument_list|,
operator|(
expr|struct
name|drm_i915_relocation_entry
name|__user
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|buffers_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|exec2_list
argument_list|)
operator|*
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"copy %d exec entries failed %d\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|exec2_list
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
name|ret
operator|=
name|i915_gem_do_execbuffer
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
name|file
argument_list|,
name|args
argument_list|,
name|exec2_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
comment|/* Copy the new buffer offsets back to the user's exec list. */
name|ret
operator|=
name|copy_to_user
argument_list|(
operator|(
name|void
name|__user
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|buffers_ptr
argument_list|,
name|exec2_list
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|exec2_list
argument_list|)
operator|*
name|args
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"failed to copy %d exec entries "
literal|"back to user (%d)\n"
argument_list|,
name|args
operator|->
name|buffer_count
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|exec2_list
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

