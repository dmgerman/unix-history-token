begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* i915_irq.c -- IRQ support for the I915 -*- linux-c -*-  */
end_comment

begin_comment
comment|/*-  * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the  * "Software"), to deal in the Software without restriction, including  * without limitation the rights to use, copy, modify, merge, publish,  * distribute, sub license, and/or sell copies of the Software, and to  * permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sf_buf.h>
end_include

begin_function_decl
specifier|static
name|void
name|i915_capture_error_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u32
name|ring_last_seqno
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Interrupts that are always left unmasked.  *  * Since pipe events are edge-triggered from the PIPESTAT register to IIR,  * we leave them always unmasked in IMR and then control enabling them through  * PIPESTAT alone.  */
end_comment

begin_define
define|#
directive|define
name|I915_INTERRUPT_ENABLE_FIX
define|\
value|(I915_ASLE_INTERRUPT |				\ 	 I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |		\ 	 I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |		\ 	 I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT |	\ 	 I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT |	\ 	 I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT)
end_define

begin_comment
comment|/** Interrupts that we mask and unmask at runtime. */
end_comment

begin_define
define|#
directive|define
name|I915_INTERRUPT_ENABLE_VAR
value|(I915_USER_INTERRUPT | I915_BSD_USER_INTERRUPT)
end_define

begin_define
define|#
directive|define
name|I915_PIPE_VBLANK_STATUS
value|(PIPE_START_VBLANK_INTERRUPT_STATUS |\ 				 PIPE_VBLANK_INTERRUPT_STATUS)
end_define

begin_define
define|#
directive|define
name|I915_PIPE_VBLANK_ENABLE
value|(PIPE_START_VBLANK_INTERRUPT_ENABLE |\ 				 PIPE_VBLANK_INTERRUPT_ENABLE)
end_define

begin_define
define|#
directive|define
name|DRM_I915_VBLANK_PIPE_ALL
value|(DRM_I915_VBLANK_PIPE_A | \ 					 DRM_I915_VBLANK_PIPE_B)
end_define

begin_comment
comment|/* For display hotplug interrupt */
end_comment

begin_function
specifier|static
name|void
name|ironlake_enable_display_irq
parameter_list|(
name|drm_i915_private_t
modifier|*
name|dev_priv
parameter_list|,
name|u32
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|irq_mask
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|dev_priv
operator|->
name|irq_mask
operator|&=
operator|~
name|mask
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIMR
argument_list|,
name|dev_priv
operator|->
name|irq_mask
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DEIMR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ironlake_disable_display_irq
parameter_list|(
name|drm_i915_private_t
modifier|*
name|dev_priv
parameter_list|,
name|u32
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|irq_mask
operator|&
name|mask
operator|)
operator|!=
name|mask
condition|)
block|{
name|dev_priv
operator|->
name|irq_mask
operator||=
name|mask
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIMR
argument_list|,
name|dev_priv
operator|->
name|irq_mask
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DEIMR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|i915_enable_pipestat
parameter_list|(
name|drm_i915_private_t
modifier|*
name|dev_priv
parameter_list|,
name|int
name|pipe
parameter_list|,
name|u32
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|pipestat
index|[
name|pipe
index|]
operator|&
name|mask
operator|)
operator|!=
name|mask
condition|)
block|{
name|u32
name|reg
init|=
name|PIPESTAT
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|dev_priv
operator|->
name|pipestat
index|[
name|pipe
index|]
operator||=
name|mask
expr_stmt|;
comment|/* Enable the interrupt, clear any pending status */
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|dev_priv
operator|->
name|pipestat
index|[
name|pipe
index|]
operator||
operator|(
name|mask
operator|>>
literal|16
operator|)
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|i915_disable_pipestat
parameter_list|(
name|drm_i915_private_t
modifier|*
name|dev_priv
parameter_list|,
name|int
name|pipe
parameter_list|,
name|u32
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|pipestat
index|[
name|pipe
index|]
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|u32
name|reg
init|=
name|PIPESTAT
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|dev_priv
operator|->
name|pipestat
index|[
name|pipe
index|]
operator|&=
operator|~
name|mask
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|dev_priv
operator|->
name|pipestat
index|[
name|pipe
index|]
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * intel_enable_asle - enable ASLE interrupt for OpRegion  */
end_comment

begin_function
name|void
name|intel_enable_asle
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|ironlake_enable_display_irq
argument_list|(
name|dev_priv
argument_list|,
name|DE_GSE
argument_list|)
expr_stmt|;
else|else
block|{
name|i915_enable_pipestat
argument_list|(
name|dev_priv
argument_list|,
literal|1
argument_list|,
name|PIPE_LEGACY_BLC_EVENT_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
name|i915_enable_pipestat
argument_list|(
name|dev_priv
argument_list|,
literal|0
argument_list|,
name|PIPE_LEGACY_BLC_EVENT_ENABLE
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * i915_pipe_enabled - check if a pipe is enabled  * @dev: DRM device  * @pipe: pipe to check  *  * Reading certain registers when the pipe is disabled can hang the chip.  * Use this routine to make sure the PLL is running and the pipe is active  * before reading such registers if unsure.  */
end_comment

begin_function
specifier|static
name|int
name|i915_pipe_enabled
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|PIPECONF_ENABLE
return|;
block|}
end_function

begin_comment
comment|/* Called from drm generic code, passed a 'crtc', which  * we use as a pipe index  */
end_comment

begin_function
specifier|static
name|u32
name|i915_get_vblank_counter
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|unsigned
name|long
name|high_frame
decl_stmt|;
name|unsigned
name|long
name|low_frame
decl_stmt|;
name|u32
name|high1
decl_stmt|,
name|high2
decl_stmt|,
name|low
decl_stmt|;
if|if
condition|(
operator|!
name|i915_pipe_enabled
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"trying to get vblank count for disabled "
literal|"pipe %c\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|high_frame
operator|=
name|PIPEFRAME
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|low_frame
operator|=
name|PIPEFRAMEPIXEL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
comment|/* 	 * High& low register fields aren't synchronized, so make sure 	 * we get a low value that's stable across two reads of the high 	 * register. 	 */
do|do
block|{
name|high1
operator|=
name|I915_READ
argument_list|(
name|high_frame
argument_list|)
operator|&
name|PIPE_FRAME_HIGH_MASK
expr_stmt|;
name|low
operator|=
name|I915_READ
argument_list|(
name|low_frame
argument_list|)
operator|&
name|PIPE_FRAME_LOW_MASK
expr_stmt|;
name|high2
operator|=
name|I915_READ
argument_list|(
name|high_frame
argument_list|)
operator|&
name|PIPE_FRAME_HIGH_MASK
expr_stmt|;
block|}
do|while
condition|(
name|high1
operator|!=
name|high2
condition|)
do|;
name|high1
operator|>>=
name|PIPE_FRAME_HIGH_SHIFT
expr_stmt|;
name|low
operator|>>=
name|PIPE_FRAME_LOW_SHIFT
expr_stmt|;
return|return
operator|(
name|high1
operator|<<
literal|8
operator|)
operator||
name|low
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|gm45_get_vblank_counter
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|reg
init|=
name|PIPE_FRMCOUNT_GM45
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|i915_pipe_enabled
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"i915: trying to get vblank count for disabled "
literal|"pipe %c\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|I915_READ
argument_list|(
name|reg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_get_crtc_scanoutpos
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|,
name|int
modifier|*
name|vpos
parameter_list|,
name|int
modifier|*
name|hpos
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|vbl
init|=
literal|0
decl_stmt|,
name|position
init|=
literal|0
decl_stmt|;
name|int
name|vbl_start
decl_stmt|,
name|vbl_end
decl_stmt|,
name|htotal
decl_stmt|,
name|vtotal
decl_stmt|;
name|bool
name|in_vbl
init|=
name|true
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|i915_pipe_enabled
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"i915: trying to get scanoutpos for disabled "
literal|"pipe %c\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Get vtotal. */
name|vtotal
operator|=
literal|1
operator|+
operator|(
operator|(
name|I915_READ
argument_list|(
name|VTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0x1fff
operator|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
comment|/* No obvious pixelcount register. Only query vertical 		 * scanout position from Display scan line register. 		 */
name|position
operator|=
name|I915_READ
argument_list|(
name|PIPEDSL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decode into vertical scanout position. Don't have 		 * horizontal scanout position. 		 */
operator|*
name|vpos
operator|=
name|position
operator|&
literal|0x1fff
expr_stmt|;
operator|*
name|hpos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Have access to pixelcount since start of frame. 		 * We can split this into vertical and horizontal 		 * scanout position. 		 */
name|position
operator|=
operator|(
name|I915_READ
argument_list|(
name|PIPEFRAMEPIXEL
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|PIPE_PIXEL_MASK
operator|)
operator|>>
name|PIPE_PIXEL_SHIFT
expr_stmt|;
name|htotal
operator|=
literal|1
operator|+
operator|(
operator|(
name|I915_READ
argument_list|(
name|HTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0x1fff
operator|)
expr_stmt|;
operator|*
name|vpos
operator|=
name|position
operator|/
name|htotal
expr_stmt|;
operator|*
name|hpos
operator|=
name|position
operator|-
operator|(
operator|*
name|vpos
operator|*
name|htotal
operator|)
expr_stmt|;
block|}
comment|/* Query vblank area. */
name|vbl
operator|=
name|I915_READ
argument_list|(
name|VBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Test position against vblank region. */
name|vbl_start
operator|=
name|vbl
operator|&
literal|0x1fff
expr_stmt|;
name|vbl_end
operator|=
operator|(
name|vbl
operator|>>
literal|16
operator|)
operator|&
literal|0x1fff
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|vpos
operator|<
name|vbl_start
operator|)
operator|||
operator|(
operator|*
name|vpos
operator|>
name|vbl_end
operator|)
condition|)
name|in_vbl
operator|=
name|false
expr_stmt|;
comment|/* Inside "upper part" of vblank area? Apply corrective offset: */
if|if
condition|(
name|in_vbl
operator|&&
operator|(
operator|*
name|vpos
operator|>=
name|vbl_start
operator|)
condition|)
operator|*
name|vpos
operator|=
operator|*
name|vpos
operator|-
name|vtotal
expr_stmt|;
comment|/* Readouts valid? */
if|if
condition|(
name|vbl
operator|>
literal|0
condition|)
name|ret
operator||=
name|DRM_SCANOUTPOS_VALID
operator||
name|DRM_SCANOUTPOS_ACCURATE
expr_stmt|;
comment|/* In vblank? */
if|if
condition|(
name|in_vbl
condition|)
name|ret
operator||=
name|DRM_SCANOUTPOS_INVBL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_get_vblank_timestamp
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|,
name|int
modifier|*
name|max_error
parameter_list|,
name|struct
name|timeval
modifier|*
name|vblank_time
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
if|if
condition|(
name|pipe
operator|<
literal|0
operator|||
name|pipe
operator|>=
name|dev_priv
operator|->
name|num_pipe
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid crtc %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Get drm_crtc to timestamp: */
name|crtc
operator|=
name|intel_get_crtc_for_pipe
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid crtc %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
name|crtc
operator|->
name|enabled
condition|)
block|{
if|#
directive|if
literal|0
block|DRM_DEBUG("crtc %d is disabled\n", pipe);
endif|#
directive|endif
return|return
operator|-
name|EBUSY
return|;
block|}
comment|/* Helper routine in DRM core does all the work: */
return|return
name|drm_calc_vbltimestamp_from_scanoutpos
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|max_error
argument_list|,
name|vblank_time
argument_list|,
name|flags
argument_list|,
name|crtc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle hotplug events outside the interrupt handler proper.  */
end_comment

begin_function
specifier|static
name|void
name|i915_hotplug_work_func
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|context
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|dev_priv
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"running encoder hotplug functions\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|=
name|context
expr_stmt|;
name|dev
operator|=
name|dev_priv
operator|->
name|dev
expr_stmt|;
name|mode_config
operator|=
operator|&
name|dev
operator|->
name|mode_config
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|mode_config
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"running encoder hotplug functions\n"
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
if|if
condition|(
name|encoder
operator|->
name|hot_plug
condition|)
name|encoder
operator|->
name|hot_plug
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|mode_config
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* Just fire off a uevent and let userspace tell us what to do */
if|#
directive|if
literal|0
block|drm_helper_hpd_irq_event(dev);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|i915_handle_rps_change
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|busy_up
decl_stmt|,
name|busy_down
decl_stmt|,
name|max_avg
decl_stmt|,
name|min_avg
decl_stmt|;
name|u8
name|new_delay
init|=
name|dev_priv
operator|->
name|cur_delay
decl_stmt|;
name|I915_WRITE16
argument_list|(
name|MEMINTRSTS
argument_list|,
name|MEMINT_EVAL_CHG
argument_list|)
expr_stmt|;
name|busy_up
operator|=
name|I915_READ
argument_list|(
name|RCPREVBSYTUPAVG
argument_list|)
expr_stmt|;
name|busy_down
operator|=
name|I915_READ
argument_list|(
name|RCPREVBSYTDNAVG
argument_list|)
expr_stmt|;
name|max_avg
operator|=
name|I915_READ
argument_list|(
name|RCBMAXAVG
argument_list|)
expr_stmt|;
name|min_avg
operator|=
name|I915_READ
argument_list|(
name|RCBMINAVG
argument_list|)
expr_stmt|;
comment|/* Handle RCS change request from hw */
if|if
condition|(
name|busy_up
operator|>
name|max_avg
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|cur_delay
operator|!=
name|dev_priv
operator|->
name|max_delay
condition|)
name|new_delay
operator|=
name|dev_priv
operator|->
name|cur_delay
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new_delay
operator|<
name|dev_priv
operator|->
name|max_delay
condition|)
name|new_delay
operator|=
name|dev_priv
operator|->
name|max_delay
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|busy_down
operator|<
name|min_avg
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|cur_delay
operator|!=
name|dev_priv
operator|->
name|min_delay
condition|)
name|new_delay
operator|=
name|dev_priv
operator|->
name|cur_delay
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|new_delay
operator|>
name|dev_priv
operator|->
name|min_delay
condition|)
name|new_delay
operator|=
name|dev_priv
operator|->
name|min_delay
expr_stmt|;
block|}
if|if
condition|(
name|ironlake_set_drps
argument_list|(
name|dev
argument_list|,
name|new_delay
argument_list|)
condition|)
name|dev_priv
operator|->
name|cur_delay
operator|=
name|new_delay
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_ring
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|seqno
decl_stmt|;
if|if
condition|(
name|ring
operator|->
name|obj
operator|==
name|NULL
condition|)
return|return;
name|seqno
operator|=
name|ring
operator|->
name|get_seqno
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"request_complete %s %d"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ring
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|ring
operator|->
name|irq_seqno
operator|=
name|seqno
expr_stmt|;
name|wakeup
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ring
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|i915_enable_hangcheck
condition|)
block|{
name|dev_priv
operator|->
name|hangcheck_count
operator|=
literal|0
expr_stmt|;
name|callout_schedule
argument_list|(
operator|&
name|dev_priv
operator|->
name|hangcheck_timer
argument_list|,
name|DRM_I915_HANGCHECK_PERIOD
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gen6_pm_rps_work_func
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|u8
name|new_delay
decl_stmt|;
name|u32
name|pm_iir
decl_stmt|,
name|pm_imr
decl_stmt|;
name|dev_priv
operator|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|arg
expr_stmt|;
name|dev
operator|=
name|dev_priv
operator|->
name|dev
expr_stmt|;
name|new_delay
operator|=
name|dev_priv
operator|->
name|cur_delay
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps_lock
argument_list|)
expr_stmt|;
name|pm_iir
operator|=
name|dev_priv
operator|->
name|pm_iir
expr_stmt|;
name|dev_priv
operator|->
name|pm_iir
operator|=
literal|0
expr_stmt|;
name|pm_imr
operator|=
name|I915_READ
argument_list|(
name|GEN6_PMIMR
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PMIMR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pm_iir
condition|)
return|return;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm_iir
operator|&
name|GEN6_PM_RP_UP_THRESHOLD
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|cur_delay
operator|!=
name|dev_priv
operator|->
name|max_delay
condition|)
name|new_delay
operator|=
name|dev_priv
operator|->
name|cur_delay
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|new_delay
operator|>
name|dev_priv
operator|->
name|max_delay
condition|)
name|new_delay
operator|=
name|dev_priv
operator|->
name|max_delay
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pm_iir
operator|&
operator|(
name|GEN6_PM_RP_DOWN_THRESHOLD
operator||
name|GEN6_PM_RP_DOWN_TIMEOUT
operator|)
condition|)
block|{
name|gen6_gt_force_wake_get
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|cur_delay
operator|!=
name|dev_priv
operator|->
name|min_delay
condition|)
name|new_delay
operator|=
name|dev_priv
operator|->
name|cur_delay
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new_delay
operator|<
name|dev_priv
operator|->
name|min_delay
condition|)
block|{
name|new_delay
operator|=
name|dev_priv
operator|->
name|min_delay
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_INTERRUPT_LIMITS
argument_list|,
name|I915_READ
argument_list|(
name|GEN6_RP_INTERRUPT_LIMITS
argument_list|)
operator||
operator|(
operator|(
name|new_delay
operator|<<
literal|16
operator|)
operator|&
literal|0x3f0000
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure we continue to get down interrupts 			 * until we hit the minimum frequency */
name|I915_WRITE
argument_list|(
name|GEN6_RP_INTERRUPT_LIMITS
argument_list|,
name|I915_READ
argument_list|(
name|GEN6_RP_INTERRUPT_LIMITS
argument_list|)
operator|&
operator|~
literal|0x3f0000
argument_list|)
expr_stmt|;
block|}
name|gen6_gt_force_wake_put
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
name|gen6_set_rps
argument_list|(
name|dev
argument_list|,
name|new_delay
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|cur_delay
operator|=
name|new_delay
expr_stmt|;
comment|/* 	 * rps_lock not held here because clearing is non-destructive. There is 	 * an *extremely* unlikely race with gen6_rps_enable() that is prevented 	 * by holding struct_mutex for the duration of the write. 	 */
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pch_irq_handler
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|pch_iir
decl_stmt|;
name|int
name|pipe
decl_stmt|;
name|pch_iir
operator|=
name|I915_READ
argument_list|(
name|SDEIIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch_iir
operator|&
name|SDE_AUDIO_POWER_MASK
condition|)
name|DRM_DEBUG
argument_list|(
literal|"i915: PCH audio power change on port %d\n"
argument_list|,
operator|(
name|pch_iir
operator|&
name|SDE_AUDIO_POWER_MASK
operator|)
operator|>>
name|SDE_AUDIO_POWER_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch_iir
operator|&
name|SDE_GMBUS
condition|)
name|DRM_DEBUG
argument_list|(
literal|"i915: PCH GMBUS interrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch_iir
operator|&
name|SDE_AUDIO_HDCP_MASK
condition|)
name|DRM_DEBUG
argument_list|(
literal|"i915: PCH HDCP audio interrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch_iir
operator|&
name|SDE_AUDIO_TRANS_MASK
condition|)
name|DRM_DEBUG
argument_list|(
literal|"i915: PCH transcoder audio interrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch_iir
operator|&
name|SDE_POISON
condition|)
name|DRM_ERROR
argument_list|(
literal|"i915: PCH poison interrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch_iir
operator|&
name|SDE_FDI_MASK
condition|)
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
name|DRM_DEBUG
argument_list|(
literal|"  pipe %c FDI IIR: 0x%08x\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch_iir
operator|&
operator|(
name|SDE_TRANSB_CRC_DONE
operator||
name|SDE_TRANSA_CRC_DONE
operator|)
condition|)
name|DRM_DEBUG
argument_list|(
literal|"i915: PCH transcoder CRC done interrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch_iir
operator|&
operator|(
name|SDE_TRANSB_CRC_ERR
operator||
name|SDE_TRANSA_CRC_ERR
operator|)
condition|)
name|DRM_DEBUG
argument_list|(
literal|"i915: PCH transcoder CRC error interrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch_iir
operator|&
name|SDE_TRANSB_FIFO_UNDER
condition|)
name|DRM_DEBUG
argument_list|(
literal|"i915: PCH transcoder B underrun interrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch_iir
operator|&
name|SDE_TRANSA_FIFO_UNDER
condition|)
name|DRM_DEBUG
argument_list|(
literal|"PCH transcoder A underrun interrupt\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ivybridge_irq_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
operator|(
expr|struct
name|drm_device
operator|*
operator|)
name|arg
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|de_iir
decl_stmt|,
name|gt_iir
decl_stmt|,
name|de_ier
decl_stmt|,
name|pch_iir
decl_stmt|,
name|pm_iir
decl_stmt|;
if|#
directive|if
literal|0
block|struct drm_i915_master_private *master_priv;
endif|#
directive|endif
name|atomic_inc
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_received
argument_list|)
expr_stmt|;
comment|/* disable master interrupt before clearing iir  */
name|de_ier
operator|=
name|I915_READ
argument_list|(
name|DEIER
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIER
argument_list|,
name|de_ier
operator|&
operator|~
name|DE_MASTER_IRQ_CONTROL
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DEIER
argument_list|)
expr_stmt|;
name|de_iir
operator|=
name|I915_READ
argument_list|(
name|DEIIR
argument_list|)
expr_stmt|;
name|gt_iir
operator|=
name|I915_READ
argument_list|(
name|GTIIR
argument_list|)
expr_stmt|;
name|pch_iir
operator|=
name|I915_READ
argument_list|(
name|SDEIIR
argument_list|)
expr_stmt|;
name|pm_iir
operator|=
name|I915_READ
argument_list|(
name|GEN6_PMIIR
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_DRM
argument_list|,
literal|"ivybridge_irq de %x gt %x pch %x pm %x"
argument_list|,
name|de_iir
argument_list|,
name|gt_iir
argument_list|,
name|pch_iir
argument_list|,
name|pm_iir
argument_list|)
expr_stmt|;
if|if
condition|(
name|de_iir
operator|==
literal|0
operator|&&
name|gt_iir
operator|==
literal|0
operator|&&
name|pch_iir
operator|==
literal|0
operator|&&
name|pm_iir
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|#
directive|if
literal|0
block|if (dev->primary->master) { 		master_priv = dev->primary->master->driver_priv; 		if (master_priv->sarea_priv) 			master_priv->sarea_priv->last_dispatch = 				READ_BREADCRUMB(dev_priv); 	}
else|#
directive|else
if|if
condition|(
name|dev_priv
operator|->
name|sarea_priv
condition|)
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_dispatch
operator|=
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|gt_iir
operator|&
operator|(
name|GT_USER_INTERRUPT
operator||
name|GT_PIPE_NOTIFY
operator|)
condition|)
name|notify_ring
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt_iir
operator|&
name|GT_GEN6_BSD_USER_INTERRUPT
condition|)
name|notify_ring
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|VCS
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt_iir
operator|&
name|GT_BLT_USER_INTERRUPT
condition|)
name|notify_ring
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|BCS
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|de_iir
operator|&
name|DE_GSE_IVB
condition|)
block|{
name|intel_opregion_gse_intr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|de_iir
operator|&
name|DE_PLANEA_FLIP_DONE_IVB
condition|)
block|{
name|intel_prepare_page_flip
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intel_finish_page_flip_plane
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|de_iir
operator|&
name|DE_PLANEB_FLIP_DONE_IVB
condition|)
block|{
name|intel_prepare_page_flip
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intel_finish_page_flip_plane
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|de_iir
operator|&
name|DE_PIPEA_VBLANK_IVB
condition|)
name|drm_handle_vblank
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|de_iir
operator|&
name|DE_PIPEB_VBLANK_IVB
condition|)
name|drm_handle_vblank
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* check event from PCH */
if|if
condition|(
name|de_iir
operator|&
name|DE_PCH_EVENT_IVB
condition|)
block|{
if|if
condition|(
name|pch_iir
operator|&
name|SDE_HOTPLUG_MASK_CPT
condition|)
name|taskqueue_enqueue
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|hotplug_task
argument_list|)
expr_stmt|;
name|pch_irq_handler
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pm_iir
operator|&
name|GEN6_PM_DEFERRED_EVENTS
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|pm_iir
operator|&
name|pm_iir
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Missed a PM interrupt\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|pm_iir
operator||=
name|pm_iir
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PMIMR
argument_list|,
name|dev_priv
operator|->
name|pm_iir
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|GEN6_PMIMR
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps_lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|rps_task
argument_list|)
expr_stmt|;
block|}
comment|/* should clear PCH hotplug event before clear CPU irq */
name|I915_WRITE
argument_list|(
name|SDEIIR
argument_list|,
name|pch_iir
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GTIIR
argument_list|,
name|gt_iir
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIIR
argument_list|,
name|de_iir
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PMIIR
argument_list|,
name|pm_iir
argument_list|)
expr_stmt|;
name|done
label|:
name|I915_WRITE
argument_list|(
name|DEIER
argument_list|,
name|de_ier
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DEIER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_irq_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|arg
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|de_iir
decl_stmt|,
name|gt_iir
decl_stmt|,
name|de_ier
decl_stmt|,
name|pch_iir
decl_stmt|,
name|pm_iir
decl_stmt|;
name|u32
name|hotplug_mask
decl_stmt|;
if|#
directive|if
literal|0
block|struct drm_i915_master_private *master_priv;
endif|#
directive|endif
name|u32
name|bsd_usr_interrupt
init|=
name|GT_BSD_USER_INTERRUPT
decl_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_received
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
name|bsd_usr_interrupt
operator|=
name|GT_GEN6_BSD_USER_INTERRUPT
expr_stmt|;
comment|/* disable master interrupt before clearing iir  */
name|de_ier
operator|=
name|I915_READ
argument_list|(
name|DEIER
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIER
argument_list|,
name|de_ier
operator|&
operator|~
name|DE_MASTER_IRQ_CONTROL
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DEIER
argument_list|)
expr_stmt|;
name|de_iir
operator|=
name|I915_READ
argument_list|(
name|DEIIR
argument_list|)
expr_stmt|;
name|gt_iir
operator|=
name|I915_READ
argument_list|(
name|GTIIR
argument_list|)
expr_stmt|;
name|pch_iir
operator|=
name|I915_READ
argument_list|(
name|SDEIIR
argument_list|)
expr_stmt|;
name|pm_iir
operator|=
name|I915_READ
argument_list|(
name|GEN6_PMIIR
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_DRM
argument_list|,
literal|"ironlake_irq de %x gt %x pch %x pm %x"
argument_list|,
name|de_iir
argument_list|,
name|gt_iir
argument_list|,
name|pch_iir
argument_list|,
name|pm_iir
argument_list|)
expr_stmt|;
if|if
condition|(
name|de_iir
operator|==
literal|0
operator|&&
name|gt_iir
operator|==
literal|0
operator|&&
name|pch_iir
operator|==
literal|0
operator|&&
operator|(
operator|!
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|||
name|pm_iir
operator|==
literal|0
operator|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
name|hotplug_mask
operator|=
name|SDE_HOTPLUG_MASK_CPT
expr_stmt|;
else|else
name|hotplug_mask
operator|=
name|SDE_HOTPLUG_MASK
expr_stmt|;
if|#
directive|if
literal|0
block|if (dev->primary->master) { 		master_priv = dev->primary->master->driver_priv; 		if (master_priv->sarea_priv) 			master_priv->sarea_priv->last_dispatch = 				READ_BREADCRUMB(dev_priv); 	}
else|#
directive|else
if|if
condition|(
name|dev_priv
operator|->
name|sarea_priv
condition|)
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_dispatch
operator|=
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|gt_iir
operator|&
operator|(
name|GT_USER_INTERRUPT
operator||
name|GT_PIPE_NOTIFY
operator|)
condition|)
name|notify_ring
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt_iir
operator|&
name|bsd_usr_interrupt
condition|)
name|notify_ring
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|VCS
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt_iir
operator|&
name|GT_BLT_USER_INTERRUPT
condition|)
name|notify_ring
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|BCS
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|de_iir
operator|&
name|DE_GSE
condition|)
block|{
name|intel_opregion_gse_intr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|de_iir
operator|&
name|DE_PLANEA_FLIP_DONE
condition|)
block|{
name|intel_prepare_page_flip
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intel_finish_page_flip_plane
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|de_iir
operator|&
name|DE_PLANEB_FLIP_DONE
condition|)
block|{
name|intel_prepare_page_flip
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intel_finish_page_flip_plane
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|de_iir
operator|&
name|DE_PIPEA_VBLANK
condition|)
name|drm_handle_vblank
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|de_iir
operator|&
name|DE_PIPEB_VBLANK
condition|)
name|drm_handle_vblank
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* check event from PCH */
if|if
condition|(
name|de_iir
operator|&
name|DE_PCH_EVENT
condition|)
block|{
if|if
condition|(
name|pch_iir
operator|&
name|hotplug_mask
condition|)
name|taskqueue_enqueue
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|hotplug_task
argument_list|)
expr_stmt|;
name|pch_irq_handler
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|de_iir
operator|&
name|DE_PCU_EVENT
condition|)
block|{
name|I915_WRITE16
argument_list|(
name|MEMINTRSTS
argument_list|,
name|I915_READ
argument_list|(
name|MEMINTRSTS
argument_list|)
argument_list|)
expr_stmt|;
name|i915_handle_rps_change
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pm_iir
operator|&
name|GEN6_PM_DEFERRED_EVENTS
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|pm_iir
operator|&
name|pm_iir
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Missed a PM interrupt\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|pm_iir
operator||=
name|pm_iir
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PMIMR
argument_list|,
name|dev_priv
operator|->
name|pm_iir
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|GEN6_PMIMR
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps_lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|rps_task
argument_list|)
expr_stmt|;
block|}
comment|/* should clear PCH hotplug event before clear CPU irq */
name|I915_WRITE
argument_list|(
name|SDEIIR
argument_list|,
name|pch_iir
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GTIIR
argument_list|,
name|gt_iir
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIIR
argument_list|,
name|de_iir
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PMIIR
argument_list|,
name|pm_iir
argument_list|)
expr_stmt|;
name|done
label|:
name|I915_WRITE
argument_list|(
name|DEIER
argument_list|,
name|de_ier
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DEIER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * i915_error_work_func - do process context error handling work  * @work: work struct  *  * Fire an error uevent so userspace can see that a hang or error  * was detected.  */
end_comment

begin_function
specifier|static
name|void
name|i915_error_work_func
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|context
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|dev_priv
operator|->
name|dev
decl_stmt|;
comment|/* kobject_uevent_env(&dev->primary->kdev.kobj, KOBJ_CHANGE, error_event); */
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"i915: resetting chip\n"
argument_list|)
expr_stmt|;
comment|/* kobject_uevent_env(&dev->primary->kdev.kobj, KOBJ_CHANGE, reset_event); */
if|if
condition|(
operator|!
name|i915_reset
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|atomic_store_rel_int
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* kobject_uevent_env(&dev->primary->kdev.kobj, KOBJ_CHANGE, reset_done_event); */
block|}
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion_lock
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|error_completion
operator|++
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i915_report_and_clear_eir
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|eir
init|=
name|I915_READ
argument_list|(
name|EIR
argument_list|)
decl_stmt|;
name|int
name|pipe
decl_stmt|;
if|if
condition|(
operator|!
name|eir
condition|)
return|return;
name|printf
argument_list|(
literal|"i915: render error detected, EIR: 0x%08x\n"
argument_list|,
name|eir
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|eir
operator|&
operator|(
name|GM45_ERROR_MEM_PRIV
operator||
name|GM45_ERROR_CP_PRIV
operator|)
condition|)
block|{
name|u32
name|ipeir
init|=
name|I915_READ
argument_list|(
name|IPEIR_I965
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"  IPEIR: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|IPEIR_I965
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  IPEHR: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|IPEHR_I965
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  INSTDONE: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|INSTDONE_I965
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  INSTPS: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|INSTPS
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  INSTDONE1: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|INSTDONE1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ACTHD: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|ACTHD_I965
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|IPEIR_I965
argument_list|,
name|ipeir
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|IPEIR_I965
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eir
operator|&
name|GM45_ERROR_PAGE_TABLE
condition|)
block|{
name|u32
name|pgtbl_err
init|=
name|I915_READ
argument_list|(
name|PGTBL_ER
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"page table error\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  PGTBL_ER: 0x%08x\n"
argument_list|,
name|pgtbl_err
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PGTBL_ER
argument_list|,
name|pgtbl_err
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PGTBL_ER
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|eir
operator|&
name|I915_ERROR_PAGE_TABLE
condition|)
block|{
name|u32
name|pgtbl_err
init|=
name|I915_READ
argument_list|(
name|PGTBL_ER
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"page table error\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  PGTBL_ER: 0x%08x\n"
argument_list|,
name|pgtbl_err
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PGTBL_ER
argument_list|,
name|pgtbl_err
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PGTBL_ER
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eir
operator|&
name|I915_ERROR_MEMORY_REFRESH
condition|)
block|{
name|printf
argument_list|(
literal|"memory refresh error:\n"
argument_list|)
expr_stmt|;
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
name|printf
argument_list|(
literal|"pipe %c stat: 0x%08x\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|PIPESTAT
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* pipestat has already been acked */
block|}
if|if
condition|(
name|eir
operator|&
name|I915_ERROR_INSTRUCTION
condition|)
block|{
name|printf
argument_list|(
literal|"instruction error\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  INSTPM: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|INSTPM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
condition|)
block|{
name|u32
name|ipeir
init|=
name|I915_READ
argument_list|(
name|IPEIR
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"  IPEIR: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|IPEIR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  IPEHR: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|IPEHR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  INSTDONE: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|INSTDONE
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ACTHD: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|ACTHD
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|IPEIR
argument_list|,
name|ipeir
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|IPEIR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u32
name|ipeir
init|=
name|I915_READ
argument_list|(
name|IPEIR_I965
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"  IPEIR: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|IPEIR_I965
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  IPEHR: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|IPEHR_I965
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  INSTDONE: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|INSTDONE_I965
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  INSTPS: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|INSTPS
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  INSTDONE1: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|INSTDONE1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ACTHD: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|ACTHD_I965
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|IPEIR_I965
argument_list|,
name|ipeir
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|IPEIR_I965
argument_list|)
expr_stmt|;
block|}
block|}
name|I915_WRITE
argument_list|(
name|EIR
argument_list|,
name|eir
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|EIR
argument_list|)
expr_stmt|;
name|eir
operator|=
name|I915_READ
argument_list|(
name|EIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|eir
condition|)
block|{
comment|/* 		 * some errors might have become stuck, 		 * mask them. 		 */
name|DRM_ERROR
argument_list|(
literal|"EIR stuck: 0x%08x, masking\n"
argument_list|,
name|eir
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EMR
argument_list|,
name|I915_READ
argument_list|(
name|EMR
argument_list|)
operator||
name|eir
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|IIR
argument_list|,
name|I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * i915_handle_error - handle an error interrupt  * @dev: drm device  *  * Do some basic checking of regsiter state at error interrupt time and  * dump it to the syslog.  Also call i915_capture_error_state() to make  * sure we get a record and make it available in debugfs.  Fire a uevent  * so userspace knows something bad happened (should trigger collection  * of a ring dump etc.).  */
end_comment

begin_function
name|void
name|i915_handle_error
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|bool
name|wedged
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|i915_capture_error_state
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_report_and_clear_eir
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|wedged
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion_lock
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|error_completion
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
operator|=
literal|1
expr_stmt|;
comment|/* unlock acts as rel barrier for store to wedged */
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Wakeup waiting processes so they don't hang 		 */
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
operator|.
name|irq_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
operator|.
name|irq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_BSD
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|VCS
index|]
operator|.
name|irq_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|VCS
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|VCS
index|]
operator|.
name|irq_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAS_BLT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|BCS
index|]
operator|.
name|irq_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|BCS
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|BCS
index|]
operator|.
name|irq_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|taskqueue_enqueue
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|error_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_pageflip_stall_check
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|pipe
index|]
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|intel_unpin_work
modifier|*
name|work
decl_stmt|;
name|bool
name|stall_detected
decl_stmt|;
comment|/* Ignore early vblank irqs */
if|if
condition|(
name|intel_crtc
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|work
operator|=
name|intel_crtc
operator|->
name|unpin_work
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|NULL
operator|||
name|work
operator|->
name|pending
operator|||
operator|!
name|work
operator|->
name|enable_stall_check
condition|)
block|{
comment|/* Either the pending flip IRQ arrived, or we're too early. Don't check */
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Potential stall - if we see that the flip has happened, assume a missed interrupt */
name|obj
operator|=
name|work
operator|->
name|pending_flip_obj
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|int
name|dspsurf
init|=
name|DSPSURF
argument_list|(
name|intel_crtc
operator|->
name|plane
argument_list|)
decl_stmt|;
name|stall_detected
operator|=
name|I915_READ
argument_list|(
name|dspsurf
argument_list|)
operator|==
name|obj
operator|->
name|gtt_offset
expr_stmt|;
block|}
else|else
block|{
name|int
name|dspaddr
init|=
name|DSPADDR
argument_list|(
name|intel_crtc
operator|->
name|plane
argument_list|)
decl_stmt|;
name|stall_detected
operator|=
name|I915_READ
argument_list|(
name|dspaddr
argument_list|)
operator|==
operator|(
name|obj
operator|->
name|gtt_offset
operator|+
name|crtc
operator|->
name|y
operator|*
name|crtc
operator|->
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|+
name|crtc
operator|->
name|x
operator|*
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
operator|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|stall_detected
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Pageflip stall detected\n"
argument_list|)
expr_stmt|;
name|intel_prepare_page_flip
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i915_driver_irq_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
operator|(
expr|struct
name|drm_device
operator|*
operator|)
name|arg
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
if|#
directive|if
literal|0
block|struct drm_i915_master_private *master_priv;
endif|#
directive|endif
name|u32
name|iir
decl_stmt|,
name|new_iir
decl_stmt|;
name|u32
name|pipe_stats
index|[
name|I915_MAX_PIPES
index|]
decl_stmt|;
name|u32
name|vblank_status
decl_stmt|;
name|int
name|vblank
init|=
literal|0
decl_stmt|;
name|int
name|irq_received
decl_stmt|;
name|int
name|pipe
decl_stmt|;
name|bool
name|blc_event
init|=
name|false
decl_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_received
argument_list|)
expr_stmt|;
name|iir
operator|=
name|I915_READ
argument_list|(
name|IIR
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_DRM
argument_list|,
literal|"driver_irq_handler %x"
argument_list|,
name|iir
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
name|vblank_status
operator|=
name|PIPE_START_VBLANK_INTERRUPT_STATUS
expr_stmt|;
else|else
name|vblank_status
operator|=
name|PIPE_VBLANK_INTERRUPT_STATUS
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|irq_received
operator|=
name|iir
operator|!=
literal|0
expr_stmt|;
comment|/* Can't rely on pipestat interrupt bit in iir as it might 		 * have been cleared after the pipestat interrupt was received. 		 * It doesn't set the bit in iir again, but it still produces 		 * interrupts (for non-MSI). 		 */
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|iir
operator|&
name|I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT
condition|)
name|i915_handle_error
argument_list|(
name|dev
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
block|{
name|int
name|reg
init|=
name|PIPESTAT
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|pipe_stats
index|[
name|pipe
index|]
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* 			 * Clear the PIPE*STAT regs before the IIR 			 */
if|if
condition|(
name|pipe_stats
index|[
name|pipe
index|]
operator|&
literal|0x8000ffff
condition|)
block|{
if|if
condition|(
name|pipe_stats
index|[
name|pipe
index|]
operator|&
name|PIPE_FIFO_UNDERRUN_STATUS
condition|)
name|DRM_DEBUG
argument_list|(
literal|"pipe %c underrun\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|pipe_stats
index|[
name|pipe
index|]
argument_list|)
expr_stmt|;
name|irq_received
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|irq_received
condition|)
break|break;
comment|/* Consume port.  Then clear IIR or we'll miss events */
if|if
condition|(
operator|(
name|I915_HAS_HOTPLUG
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
operator|(
name|iir
operator|&
name|I915_DISPLAY_PORT_INTERRUPT
operator|)
condition|)
block|{
name|u32
name|hotplug_status
init|=
name|I915_READ
argument_list|(
name|PORT_HOTPLUG_STAT
argument_list|)
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"i915: hotplug event received, stat 0x%08x\n"
argument_list|,
name|hotplug_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|hotplug_status
operator|&
name|dev_priv
operator|->
name|hotplug_supported_mask
condition|)
name|taskqueue_enqueue
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|hotplug_task
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PORT_HOTPLUG_STAT
argument_list|,
name|hotplug_status
argument_list|)
expr_stmt|;
name|I915_READ
argument_list|(
name|PORT_HOTPLUG_STAT
argument_list|)
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|IIR
argument_list|,
name|iir
argument_list|)
expr_stmt|;
name|new_iir
operator|=
name|I915_READ
argument_list|(
name|IIR
argument_list|)
expr_stmt|;
comment|/* Flush posted writes */
if|#
directive|if
literal|0
block|if (dev->primary->master) { 			master_priv = dev->primary->master->driver_priv; 			if (master_priv->sarea_priv) 				master_priv->sarea_priv->last_dispatch = 					READ_BREADCRUMB(dev_priv); 		}
else|#
directive|else
if|if
condition|(
name|dev_priv
operator|->
name|sarea_priv
condition|)
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_dispatch
operator|=
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iir
operator|&
name|I915_USER_INTERRUPT
condition|)
name|notify_ring
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|iir
operator|&
name|I915_BSD_USER_INTERRUPT
condition|)
name|notify_ring
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|VCS
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|iir
operator|&
name|I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT
condition|)
block|{
name|intel_prepare_page_flip
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|flip_pending_is_done
condition|)
name|intel_finish_page_flip_plane
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iir
operator|&
name|I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT
condition|)
block|{
name|intel_prepare_page_flip
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|flip_pending_is_done
condition|)
name|intel_finish_page_flip_plane
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
block|{
if|if
condition|(
name|pipe_stats
index|[
name|pipe
index|]
operator|&
name|vblank_status
operator|&&
name|drm_handle_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
name|vblank
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|flip_pending_is_done
condition|)
block|{
name|i915_pageflip_stall_check
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_finish_page_flip
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pipe_stats
index|[
name|pipe
index|]
operator|&
name|PIPE_LEGACY_BLC_EVENT_STATUS
condition|)
name|blc_event
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|blc_event
operator|||
operator|(
name|iir
operator|&
name|I915_ASLE_INTERRUPT
operator|)
condition|)
block|{
name|intel_opregion_asle_intr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* With MSI, interrupts are only generated when iir 		 * transitions from zero to nonzero.  If another bit got 		 * set while we were handling the existing iir bits, then 		 * we would never get another interrupt. 		 * 		 * This is fine on non-MSI as well, as if we hit this path 		 * we avoid exiting the interrupt handler only to generate 		 * another one. 		 * 		 * Note that for MSI this could cause a stray interrupt report 		 * if an interrupt landed in the time between writing IIR and 		 * the posting read.  This should be rare enough to never 		 * trigger the 99% of 100,000 interrupts test for disabling 		 * stray interrupts. 		 */
name|iir
operator|=
name|new_iir
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|i915_emit_irq
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|#
directive|if
literal|0
block|struct drm_i915_master_private *master_priv = dev->primary->master->driver_priv;
endif|#
directive|endif
name|i915_kernel_lost_context
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"i915: emit_irq\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|counter
operator|++
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|counter
operator|>
literal|0x7FFFFFFFUL
condition|)
name|dev_priv
operator|->
name|counter
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|if (master_priv->sarea_priv) 		master_priv->sarea_priv->last_enqueue = dev_priv->counter;
else|#
directive|else
if|if
condition|(
name|dev_priv
operator|->
name|sarea_priv
condition|)
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_enqueue
operator|=
name|dev_priv
operator|->
name|counter
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|BEGIN_LP_RING
argument_list|(
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|OUT_RING
argument_list|(
name|MI_STORE_DWORD_INDEX
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|I915_BREADCRUMB_INDEX
operator|<<
name|MI_STORE_DWORD_INDEX_SHIFT
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|counter
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_USER_INTERRUPT
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
block|}
return|return
name|dev_priv
operator|->
name|counter
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_wait_irq
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|irq_nr
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
if|#
directive|if
literal|0
block|struct drm_i915_master_private *master_priv = dev->primary->master->driver_priv;
endif|#
directive|endif
name|int
name|ret
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"irq_nr=%d breadcrumb=%d\n"
argument_list|,
name|irq_nr
argument_list|,
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (READ_BREADCRUMB(dev_priv)>= irq_nr) { 		if (master_priv->sarea_priv) 			master_priv->sarea_priv->last_dispatch = READ_BREADCRUMB(dev_priv); 		return 0; 	}  	if (master_priv->sarea_priv) 		master_priv->sarea_priv->perf_boxes |= I915_BOX_WAIT;
else|#
directive|else
if|if
condition|(
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
operator|>=
name|irq_nr
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|sarea_priv
condition|)
block|{
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_dispatch
operator|=
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|sarea_priv
condition|)
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|perf_boxes
operator||=
name|I915_BOX_WAIT
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ring
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|irq_get
argument_list|(
name|ring
argument_list|)
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
while|while
condition|(
name|ret
operator|==
literal|0
operator|&&
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
operator|<
name|irq_nr
condition|)
block|{
name|ret
operator|=
operator|-
name|msleep
argument_list|(
name|ring
argument_list|,
operator|&
name|ring
operator|->
name|irq_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"915wtq"
argument_list|,
literal|3
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|ring
operator|->
name|irq_put
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ring
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ring
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
operator|>=
name|irq_nr
argument_list|,
literal|3000
argument_list|,
literal|1
argument_list|,
literal|"915wir"
argument_list|)
condition|)
name|ret
operator|=
operator|-
name|EBUSY
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
operator|-
name|EBUSY
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"EBUSY -- rec: %d emitted: %d\n"
argument_list|,
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|dev_priv
operator|->
name|counter
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Needs the lock as it touches the ring.  */
end_comment

begin_function
name|int
name|i915_irq_emit
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_irq_emit_t
modifier|*
name|emit
init|=
name|data
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|||
operator|!
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
operator|->
name|virtual_start
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|RING_LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|result
operator|=
name|i915_emit_irq
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
name|emit
operator|->
name|irq_seq
argument_list|,
operator|&
name|result
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"copy_to_user\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Doesn't need the hardware lock.  */
end_comment

begin_function
name|int
name|i915_irq_wait
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_irq_wait_t
modifier|*
name|irqwait
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
name|i915_wait_irq
argument_list|(
name|dev
argument_list|,
name|irqwait
operator|->
name|irq_seq
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called from drm generic code, passed 'crtc' which  * we use as a pipe index  */
end_comment

begin_function
specifier|static
name|int
name|i915_enable_vblank
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|i915_pipe_enabled
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
name|i915_enable_pipestat
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PIPE_START_VBLANK_INTERRUPT_ENABLE
argument_list|)
expr_stmt|;
else|else
name|i915_enable_pipestat
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PIPE_VBLANK_INTERRUPT_ENABLE
argument_list|)
expr_stmt|;
comment|/* maintain vblank delivery even in deep C-states */
if|if
condition|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|==
literal|3
condition|)
name|I915_WRITE
argument_list|(
name|INSTPM
argument_list|,
name|INSTPM_AGPBUSY_DIS
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_DRM
argument_list|,
literal|"i915_enable_vblank %d"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ironlake_enable_vblank
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|i915_pipe_enabled
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|ironlake_enable_display_irq
argument_list|(
name|dev_priv
argument_list|,
operator|(
name|pipe
operator|==
literal|0
operator|)
condition|?
name|DE_PIPEA_VBLANK
else|:
name|DE_PIPEB_VBLANK
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_DRM
argument_list|,
literal|"ironlake_enable_vblank %d"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ivybridge_enable_vblank
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|i915_pipe_enabled
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|ironlake_enable_display_irq
argument_list|(
name|dev_priv
argument_list|,
operator|(
name|pipe
operator|==
literal|0
operator|)
condition|?
name|DE_PIPEA_VBLANK_IVB
else|:
name|DE_PIPEB_VBLANK_IVB
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_DRM
argument_list|,
literal|"ivybridge_enable_vblank %d"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called from drm generic code, passed 'crtc' which  * we use as a pipe index  */
end_comment

begin_function
specifier|static
name|void
name|i915_disable_vblank
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|==
literal|3
condition|)
name|I915_WRITE
argument_list|(
name|INSTPM
argument_list|,
name|INSTPM_AGPBUSY_DIS
operator|<<
literal|16
operator||
name|INSTPM_AGPBUSY_DIS
argument_list|)
expr_stmt|;
name|i915_disable_pipestat
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PIPE_VBLANK_INTERRUPT_ENABLE
operator||
name|PIPE_START_VBLANK_INTERRUPT_ENABLE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_DRM
argument_list|,
literal|"i915_disable_vblank %d"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_disable_vblank
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|ironlake_disable_display_irq
argument_list|(
name|dev_priv
argument_list|,
operator|(
name|pipe
operator|==
literal|0
operator|)
condition|?
name|DE_PIPEA_VBLANK
else|:
name|DE_PIPEB_VBLANK
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_DRM
argument_list|,
literal|"ironlake_disable_vblank %d"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ivybridge_disable_vblank
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|ironlake_disable_display_irq
argument_list|(
name|dev_priv
argument_list|,
operator|(
name|pipe
operator|==
literal|0
operator|)
condition|?
name|DE_PIPEA_VBLANK_IVB
else|:
name|DE_PIPEB_VBLANK_IVB
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_DRM
argument_list|,
literal|"ivybridge_disable_vblank %d"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the vblank monitor pipe  */
end_comment

begin_function
name|int
name|i915_vblank_pipe_set
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_vblank_pipe_get
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_vblank_pipe_t
modifier|*
name|pipe
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|pipe
operator|->
name|pipe
operator|=
name|DRM_I915_VBLANK_PIPE_A
operator||
name|DRM_I915_VBLANK_PIPE_B
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Schedule buffer swap at given vertical blank.  */
end_comment

begin_function
name|int
name|i915_vblank_swap
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
comment|/* The delayed swap mechanism was fundamentally racy, and has been 	 * removed.  The model was that the client requested a delayed flip/swap 	 * from the kernel, then waited for vblank before continuing to perform 	 * rendering.  The problem was that the kernel might wake the client 	 * up before it dispatched the vblank swap (since the lock has to be 	 * held while touching the ringbuffer), in which case the client would 	 * clear and start the next frame before the swap occurred, and 	 * flicker would occur in addition to likely missing the vblank. 	 * 	 * In the absence of this ioctl, userland falls back to a correct path 	 * of waiting for a vblank, then dispatching the swap on its own. 	 * Context switching to userland and back is plenty fast enough for 	 * meeting the requirements of vblank swapping. 	 */
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|ring_last_seqno
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|list_entry
argument_list|(
name|ring
operator|->
name|request_list
operator|.
name|prev
argument_list|,
expr|struct
name|drm_i915_gem_request
argument_list|,
name|list
argument_list|)
operator|->
name|seqno
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|i915_hangcheck_ring_idle
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|bool
modifier|*
name|err
parameter_list|)
block|{
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
operator|||
name|i915_seqno_passed
argument_list|(
name|ring
operator|->
name|get_seqno
argument_list|(
name|ring
argument_list|)
argument_list|,
name|ring_last_seqno
argument_list|(
name|ring
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Issue a wake-up to catch stuck h/w. */
if|if
condition|(
name|ring
operator|->
name|waiting_seqno
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Hangcheck timer elapsed... %s idle [waiting on %d, at %d], missed IRQ?\n"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|ring
operator|->
name|waiting_seqno
argument_list|,
name|ring
operator|->
name|get_seqno
argument_list|(
name|ring
argument_list|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ring
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
name|true
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|kick_ring
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|ring
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|tmp
init|=
name|I915_READ_CTL
argument_list|(
name|ring
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|&
name|RING_WAIT
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Kicking stuck wait on %s\n"
argument_list|,
name|ring
operator|->
name|name
argument_list|)
expr_stmt|;
name|I915_WRITE_CTL
argument_list|(
name|ring
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/**  * This is called when the chip hasn't reported back with completed  * batchbuffers in a long time. The first time this is called we simply record  * ACTHD. If ACTHD hasn't changed by the time the hangcheck timer elapses  * again, we assume the chip is wedged and try to fix it.  */
end_comment

begin_function
name|void
name|i915_hangcheck_elapsed
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
operator|(
expr|struct
name|drm_device
operator|*
operator|)
name|context
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|acthd
decl_stmt|,
name|instdone
decl_stmt|,
name|instdone1
decl_stmt|,
name|acthd_bsd
decl_stmt|,
name|acthd_blt
decl_stmt|;
name|bool
name|err
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|i915_enable_hangcheck
condition|)
return|return;
comment|/* If all work is done then ACTHD clearly hasn't advanced. */
if|if
condition|(
name|i915_hangcheck_ring_idle
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
argument_list|,
operator|&
name|err
argument_list|)
operator|&&
name|i915_hangcheck_ring_idle
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|VCS
index|]
argument_list|,
operator|&
name|err
argument_list|)
operator|&&
name|i915_hangcheck_ring_idle
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|BCS
index|]
argument_list|,
operator|&
name|err
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|hangcheck_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|repeat
goto|;
return|return;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
condition|)
block|{
name|instdone
operator|=
name|I915_READ
argument_list|(
name|INSTDONE
argument_list|)
expr_stmt|;
name|instdone1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|instdone
operator|=
name|I915_READ
argument_list|(
name|INSTDONE_I965
argument_list|)
expr_stmt|;
name|instdone1
operator|=
name|I915_READ
argument_list|(
name|INSTDONE1
argument_list|)
expr_stmt|;
block|}
name|acthd
operator|=
name|intel_ring_get_active_head
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
argument_list|)
expr_stmt|;
name|acthd_bsd
operator|=
name|HAS_BSD
argument_list|(
name|dev
argument_list|)
condition|?
name|intel_ring_get_active_head
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|VCS
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
name|acthd_blt
operator|=
name|HAS_BLT
argument_list|(
name|dev
argument_list|)
condition|?
name|intel_ring_get_active_head
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|BCS
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|last_acthd
operator|==
name|acthd
operator|&&
name|dev_priv
operator|->
name|last_acthd_bsd
operator|==
name|acthd_bsd
operator|&&
name|dev_priv
operator|->
name|last_acthd_blt
operator|==
name|acthd_blt
operator|&&
name|dev_priv
operator|->
name|last_instdone
operator|==
name|instdone
operator|&&
name|dev_priv
operator|->
name|last_instdone1
operator|==
name|instdone1
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|hangcheck_count
operator|++
operator|>
literal|1
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Hangcheck timer elapsed... GPU hung\n"
argument_list|)
expr_stmt|;
name|i915_handle_error
argument_list|(
name|dev
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* Is the chip hanging on a WAIT_FOR_EVENT? 				 * If so we can simply poke the RB_WAIT bit 				 * and break the hang. This should work on 				 * all but the second generation chipsets. 				 */
if|if
condition|(
name|kick_ring
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
argument_list|)
condition|)
goto|goto
name|repeat
goto|;
if|if
condition|(
name|HAS_BSD
argument_list|(
name|dev
argument_list|)
operator|&&
name|kick_ring
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|VCS
index|]
argument_list|)
condition|)
goto|goto
name|repeat
goto|;
if|if
condition|(
name|HAS_BLT
argument_list|(
name|dev
argument_list|)
operator|&&
name|kick_ring
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|BCS
index|]
argument_list|)
condition|)
goto|goto
name|repeat
goto|;
block|}
return|return;
block|}
block|}
else|else
block|{
name|dev_priv
operator|->
name|hangcheck_count
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|last_acthd
operator|=
name|acthd
expr_stmt|;
name|dev_priv
operator|->
name|last_acthd_bsd
operator|=
name|acthd_bsd
expr_stmt|;
name|dev_priv
operator|->
name|last_acthd_blt
operator|=
name|acthd_blt
expr_stmt|;
name|dev_priv
operator|->
name|last_instdone
operator|=
name|instdone
expr_stmt|;
name|dev_priv
operator|->
name|last_instdone1
operator|=
name|instdone1
expr_stmt|;
block|}
name|repeat
label|:
comment|/* Reset timer case chip hangs without another request being added */
name|callout_schedule
argument_list|(
operator|&
name|dev_priv
operator|->
name|hangcheck_timer
argument_list|,
name|DRM_I915_HANGCHECK_PERIOD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* drm_dma.h hooks */
end_comment

begin_function
specifier|static
name|void
name|ironlake_irq_preinstall
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|atomic_set
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_received
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|dev_priv
operator|->
name|hotplug_task
argument_list|,
literal|0
argument_list|,
name|i915_hotplug_work_func
argument_list|,
name|dev
operator|->
name|dev_private
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_task
argument_list|,
literal|0
argument_list|,
name|i915_error_work_func
argument_list|,
name|dev
operator|->
name|dev_private
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps_task
argument_list|,
literal|0
argument_list|,
name|gen6_pm_rps_work_func
argument_list|,
name|dev
operator|->
name|dev_private
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HWSTAM
argument_list|,
literal|0xeffe
argument_list|)
expr_stmt|;
comment|/* XXX hotplug from PCH */
name|I915_WRITE
argument_list|(
name|DEIMR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIER
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DEIER
argument_list|)
expr_stmt|;
comment|/* and GT */
name|I915_WRITE
argument_list|(
name|GTIMR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GTIER
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|GTIER
argument_list|)
expr_stmt|;
comment|/* south display irq */
name|I915_WRITE
argument_list|(
name|SDEIMR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SDEIER
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|SDEIER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable digital hotplug on the PCH, and configure the DP short pulse  * duration to 2ms (which is the minimum in the Display Port spec)  *  * This register is the same on all known PCH chips.  */
end_comment

begin_function
specifier|static
name|void
name|ironlake_enable_pch_hotplug
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|hotplug
decl_stmt|;
name|hotplug
operator|=
name|I915_READ
argument_list|(
name|PCH_PORT_HOTPLUG
argument_list|)
expr_stmt|;
name|hotplug
operator|&=
operator|~
operator|(
name|PORTD_PULSE_DURATION_MASK
operator||
name|PORTC_PULSE_DURATION_MASK
operator||
name|PORTB_PULSE_DURATION_MASK
operator|)
expr_stmt|;
name|hotplug
operator||=
name|PORTD_HOTPLUG_ENABLE
operator||
name|PORTD_PULSE_DURATION_2ms
expr_stmt|;
name|hotplug
operator||=
name|PORTC_HOTPLUG_ENABLE
operator||
name|PORTC_PULSE_DURATION_2ms
expr_stmt|;
name|hotplug
operator||=
name|PORTB_HOTPLUG_ENABLE
operator||
name|PORTB_PULSE_DURATION_2ms
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_PORT_HOTPLUG
argument_list|,
name|hotplug
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ironlake_irq_postinstall
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* enable kind of interrupts always enabled */
name|u32
name|display_mask
init|=
name|DE_MASTER_IRQ_CONTROL
operator||
name|DE_GSE
operator||
name|DE_PCH_EVENT
operator||
name|DE_PLANEA_FLIP_DONE
operator||
name|DE_PLANEB_FLIP_DONE
decl_stmt|;
name|u32
name|render_irqs
decl_stmt|;
name|u32
name|hotplug_mask
decl_stmt|;
name|dev_priv
operator|->
name|vblank_pipe
operator|=
name|DRM_I915_VBLANK_PIPE_A
operator||
name|DRM_I915_VBLANK_PIPE_B
expr_stmt|;
name|dev_priv
operator|->
name|irq_mask
operator|=
operator|~
name|display_mask
expr_stmt|;
comment|/* should always can generate irq */
name|I915_WRITE
argument_list|(
name|DEIIR
argument_list|,
name|I915_READ
argument_list|(
name|DEIIR
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIMR
argument_list|,
name|dev_priv
operator|->
name|irq_mask
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIER
argument_list|,
name|display_mask
operator||
name|DE_PIPEA_VBLANK
operator||
name|DE_PIPEB_VBLANK
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DEIER
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|gt_irq_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GTIIR
argument_list|,
name|I915_READ
argument_list|(
name|GTIIR
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GTIMR
argument_list|,
name|dev_priv
operator|->
name|gt_irq_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
name|render_irqs
operator|=
name|GT_USER_INTERRUPT
operator||
name|GT_GEN6_BSD_USER_INTERRUPT
operator||
name|GT_BLT_USER_INTERRUPT
expr_stmt|;
else|else
name|render_irqs
operator|=
name|GT_USER_INTERRUPT
operator||
name|GT_PIPE_NOTIFY
operator||
name|GT_BSD_USER_INTERRUPT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GTIER
argument_list|,
name|render_irqs
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|GTIER
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|hotplug_mask
operator|=
operator|(
name|SDE_CRT_HOTPLUG_CPT
operator||
name|SDE_PORTB_HOTPLUG_CPT
operator||
name|SDE_PORTC_HOTPLUG_CPT
operator||
name|SDE_PORTD_HOTPLUG_CPT
operator|)
expr_stmt|;
block|}
else|else
block|{
name|hotplug_mask
operator|=
operator|(
name|SDE_CRT_HOTPLUG
operator||
name|SDE_PORTB_HOTPLUG
operator||
name|SDE_PORTC_HOTPLUG
operator||
name|SDE_PORTD_HOTPLUG
operator||
name|SDE_AUX_MASK
operator|)
expr_stmt|;
block|}
name|dev_priv
operator|->
name|pch_irq_mask
operator|=
operator|~
name|hotplug_mask
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SDEIIR
argument_list|,
name|I915_READ
argument_list|(
name|SDEIIR
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SDEIMR
argument_list|,
name|dev_priv
operator|->
name|pch_irq_mask
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SDEIER
argument_list|,
name|hotplug_mask
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|SDEIER
argument_list|)
expr_stmt|;
name|ironlake_enable_pch_hotplug
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IRONLAKE_M
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* Clear& enable PCU event interrupts */
name|I915_WRITE
argument_list|(
name|DEIIR
argument_list|,
name|DE_PCU_EVENT
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIER
argument_list|,
name|I915_READ
argument_list|(
name|DEIER
argument_list|)
operator||
name|DE_PCU_EVENT
argument_list|)
expr_stmt|;
name|ironlake_enable_display_irq
argument_list|(
name|dev_priv
argument_list|,
name|DE_PCU_EVENT
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ivybridge_irq_postinstall
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* enable kind of interrupts always enabled */
name|u32
name|display_mask
init|=
name|DE_MASTER_IRQ_CONTROL
operator||
name|DE_GSE_IVB
operator||
name|DE_PCH_EVENT_IVB
operator||
name|DE_PLANEA_FLIP_DONE_IVB
operator||
name|DE_PLANEB_FLIP_DONE_IVB
decl_stmt|;
name|u32
name|render_irqs
decl_stmt|;
name|u32
name|hotplug_mask
decl_stmt|;
name|dev_priv
operator|->
name|vblank_pipe
operator|=
name|DRM_I915_VBLANK_PIPE_A
operator||
name|DRM_I915_VBLANK_PIPE_B
expr_stmt|;
name|dev_priv
operator|->
name|irq_mask
operator|=
operator|~
name|display_mask
expr_stmt|;
comment|/* should always can generate irq */
name|I915_WRITE
argument_list|(
name|DEIIR
argument_list|,
name|I915_READ
argument_list|(
name|DEIIR
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIMR
argument_list|,
name|dev_priv
operator|->
name|irq_mask
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIER
argument_list|,
name|display_mask
operator||
name|DE_PIPEA_VBLANK_IVB
operator||
name|DE_PIPEB_VBLANK_IVB
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DEIER
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|gt_irq_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GTIIR
argument_list|,
name|I915_READ
argument_list|(
name|GTIIR
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GTIMR
argument_list|,
name|dev_priv
operator|->
name|gt_irq_mask
argument_list|)
expr_stmt|;
name|render_irqs
operator|=
name|GT_USER_INTERRUPT
operator||
name|GT_GEN6_BSD_USER_INTERRUPT
operator||
name|GT_BLT_USER_INTERRUPT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GTIER
argument_list|,
name|render_irqs
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|GTIER
argument_list|)
expr_stmt|;
name|hotplug_mask
operator|=
operator|(
name|SDE_CRT_HOTPLUG_CPT
operator||
name|SDE_PORTB_HOTPLUG_CPT
operator||
name|SDE_PORTC_HOTPLUG_CPT
operator||
name|SDE_PORTD_HOTPLUG_CPT
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|pch_irq_mask
operator|=
operator|~
name|hotplug_mask
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SDEIIR
argument_list|,
name|I915_READ
argument_list|(
name|SDEIIR
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SDEIMR
argument_list|,
name|dev_priv
operator|->
name|pch_irq_mask
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SDEIER
argument_list|,
name|hotplug_mask
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|SDEIER
argument_list|)
expr_stmt|;
name|ironlake_enable_pch_hotplug
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_driver_irq_preinstall
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipe
decl_stmt|;
name|atomic_set
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_received
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|dev_priv
operator|->
name|hotplug_task
argument_list|,
literal|0
argument_list|,
name|i915_hotplug_work_func
argument_list|,
name|dev
operator|->
name|dev_private
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_task
argument_list|,
literal|0
argument_list|,
name|i915_error_work_func
argument_list|,
name|dev
operator|->
name|dev_private
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps_task
argument_list|,
literal|0
argument_list|,
name|gen6_pm_rps_work_func
argument_list|,
name|dev
operator|->
name|dev_private
argument_list|)
expr_stmt|;
if|if
condition|(
name|I915_HAS_HOTPLUG
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|PORT_HOTPLUG_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PORT_HOTPLUG_STAT
argument_list|,
name|I915_READ
argument_list|(
name|PORT_HOTPLUG_STAT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|HWSTAM
argument_list|,
literal|0xeffe
argument_list|)
expr_stmt|;
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
name|I915_WRITE
argument_list|(
name|PIPESTAT
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|IMR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|IER
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|IER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Must be called after intel_modeset_init or hotplug interrupts won't be  * enabled correctly.  */
end_comment

begin_function
specifier|static
name|int
name|i915_driver_irq_postinstall
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|enable_mask
init|=
name|I915_INTERRUPT_ENABLE_FIX
operator||
name|I915_INTERRUPT_ENABLE_VAR
decl_stmt|;
name|u32
name|error_mask
decl_stmt|;
name|dev_priv
operator|->
name|vblank_pipe
operator|=
name|DRM_I915_VBLANK_PIPE_A
operator||
name|DRM_I915_VBLANK_PIPE_B
expr_stmt|;
comment|/* Unmask the interrupts that we always want on. */
name|dev_priv
operator|->
name|irq_mask
operator|=
operator|~
name|I915_INTERRUPT_ENABLE_FIX
expr_stmt|;
name|dev_priv
operator|->
name|pipestat
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|pipestat
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|I915_HAS_HOTPLUG
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* Enable in IER... */
name|enable_mask
operator||=
name|I915_DISPLAY_PORT_INTERRUPT
expr_stmt|;
comment|/* and unmask in IMR */
name|dev_priv
operator|->
name|irq_mask
operator|&=
operator|~
name|I915_DISPLAY_PORT_INTERRUPT
expr_stmt|;
block|}
comment|/* 	 * Enable some error detection, note the instruction error mask 	 * bit is reserved, so we leave it masked. 	 */
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|error_mask
operator|=
operator|~
operator|(
name|GM45_ERROR_PAGE_TABLE
operator||
name|GM45_ERROR_MEM_PRIV
operator||
name|GM45_ERROR_CP_PRIV
operator||
name|I915_ERROR_MEMORY_REFRESH
operator|)
expr_stmt|;
block|}
else|else
block|{
name|error_mask
operator|=
operator|~
operator|(
name|I915_ERROR_PAGE_TABLE
operator||
name|I915_ERROR_MEMORY_REFRESH
operator|)
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|EMR
argument_list|,
name|error_mask
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|IMR
argument_list|,
name|dev_priv
operator|->
name|irq_mask
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|IER
argument_list|,
name|enable_mask
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|IER
argument_list|)
expr_stmt|;
if|if
condition|(
name|I915_HAS_HOTPLUG
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|u32
name|hotplug_en
init|=
name|I915_READ
argument_list|(
name|PORT_HOTPLUG_EN
argument_list|)
decl_stmt|;
comment|/* Note HDMI and DP share bits */
if|if
condition|(
name|dev_priv
operator|->
name|hotplug_supported_mask
operator|&
name|HDMIB_HOTPLUG_INT_STATUS
condition|)
name|hotplug_en
operator||=
name|HDMIB_HOTPLUG_INT_EN
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|hotplug_supported_mask
operator|&
name|HDMIC_HOTPLUG_INT_STATUS
condition|)
name|hotplug_en
operator||=
name|HDMIC_HOTPLUG_INT_EN
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|hotplug_supported_mask
operator|&
name|HDMID_HOTPLUG_INT_STATUS
condition|)
name|hotplug_en
operator||=
name|HDMID_HOTPLUG_INT_EN
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|hotplug_supported_mask
operator|&
name|SDVOC_HOTPLUG_INT_STATUS
condition|)
name|hotplug_en
operator||=
name|SDVOC_HOTPLUG_INT_EN
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|hotplug_supported_mask
operator|&
name|SDVOB_HOTPLUG_INT_STATUS
condition|)
name|hotplug_en
operator||=
name|SDVOB_HOTPLUG_INT_EN
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|hotplug_supported_mask
operator|&
name|CRT_HOTPLUG_INT_STATUS
condition|)
block|{
name|hotplug_en
operator||=
name|CRT_HOTPLUG_INT_EN
expr_stmt|;
comment|/* Programming the CRT detection parameters tends 			   to generate a spurious hotplug event about three 			   seconds later.  So just do it once. 			*/
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
condition|)
name|hotplug_en
operator||=
name|CRT_HOTPLUG_ACTIVATION_PERIOD_64
expr_stmt|;
name|hotplug_en
operator||=
name|CRT_HOTPLUG_VOLTAGE_COMPARE_50
expr_stmt|;
block|}
comment|/* Ignore TV since it's buggy */
name|I915_WRITE
argument_list|(
name|PORT_HOTPLUG_EN
argument_list|,
name|hotplug_en
argument_list|)
expr_stmt|;
block|}
name|intel_opregion_enable_asle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_irq_uninstall
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|==
name|NULL
condition|)
return|return;
name|dev_priv
operator|->
name|vblank_pipe
operator|=
literal|0
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HWSTAM
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIMR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIER
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIIR
argument_list|,
name|I915_READ
argument_list|(
name|DEIIR
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GTIMR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GTIER
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GTIIR
argument_list|,
name|I915_READ
argument_list|(
name|GTIIR
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SDEIMR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SDEIER
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SDEIIR
argument_list|,
name|I915_READ
argument_list|(
name|SDEIIR
argument_list|)
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|hotplug_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|error_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|rps_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_driver_irq_uninstall
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipe
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
return|return;
name|dev_priv
operator|->
name|vblank_pipe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|I915_HAS_HOTPLUG
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|PORT_HOTPLUG_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PORT_HOTPLUG_STAT
argument_list|,
name|I915_READ
argument_list|(
name|PORT_HOTPLUG_STAT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|HWSTAM
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
name|I915_WRITE
argument_list|(
name|PIPESTAT
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|IMR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|IER
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
name|I915_WRITE
argument_list|(
name|PIPESTAT
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|PIPESTAT
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
literal|0x8000ffff
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|IIR
argument_list|,
name|I915_READ
argument_list|(
name|IIR
argument_list|)
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|hotplug_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|error_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|rps_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_irq_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|dev
operator|->
name|driver
operator|->
name|get_vblank_counter
operator|=
name|i915_get_vblank_counter
expr_stmt|;
name|dev
operator|->
name|max_vblank_count
operator|=
literal|0xffffff
expr_stmt|;
comment|/* only 24 bits of frame count */
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|max_vblank_count
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* full 32 bit counter */
name|dev
operator|->
name|driver
operator|->
name|get_vblank_counter
operator|=
name|gm45_get_vblank_counter
expr_stmt|;
block|}
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
name|dev
operator|->
name|driver
operator|->
name|get_vblank_timestamp
operator|=
name|i915_get_vblank_timestamp
expr_stmt|;
else|else
name|dev
operator|->
name|driver
operator|->
name|get_vblank_timestamp
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|get_scanout_position
operator|=
name|i915_get_crtc_scanoutpos
expr_stmt|;
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* Share pre& uninstall handlers with ILK/SNB */
name|dev
operator|->
name|driver
operator|->
name|irq_handler
operator|=
name|ivybridge_irq_handler
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|irq_preinstall
operator|=
name|ironlake_irq_preinstall
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|irq_postinstall
operator|=
name|ivybridge_irq_postinstall
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|irq_uninstall
operator|=
name|ironlake_irq_uninstall
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|enable_vblank
operator|=
name|ivybridge_enable_vblank
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|disable_vblank
operator|=
name|ivybridge_disable_vblank
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|driver
operator|->
name|irq_handler
operator|=
name|ironlake_irq_handler
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|irq_preinstall
operator|=
name|ironlake_irq_preinstall
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|irq_postinstall
operator|=
name|ironlake_irq_postinstall
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|irq_uninstall
operator|=
name|ironlake_irq_uninstall
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|enable_vblank
operator|=
name|ironlake_enable_vblank
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|disable_vblank
operator|=
name|ironlake_disable_vblank
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|driver
operator|->
name|irq_preinstall
operator|=
name|i915_driver_irq_preinstall
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|irq_postinstall
operator|=
name|i915_driver_irq_postinstall
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|irq_uninstall
operator|=
name|i915_driver_irq_uninstall
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|irq_handler
operator|=
name|i915_driver_irq_handler
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|enable_vblank
operator|=
name|i915_enable_vblank
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|disable_vblank
operator|=
name|i915_disable_vblank
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_i915_error_object
modifier|*
name|i915_error_object_create
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|drm_i915_error_object
modifier|*
name|dst
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|void
modifier|*
name|d
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|page
decl_stmt|,
name|page_count
decl_stmt|;
name|u32
name|reloc_offset
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
operator|||
name|src
operator|->
name|pages
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|page_count
operator|=
name|src
operator|->
name|base
operator|.
name|size
operator|/
name|PAGE_SIZE
expr_stmt|;
name|dst
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
operator|+
name|page_count
operator|*
sizeof|sizeof
argument_list|(
name|u32
operator|*
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|reloc_offset
operator|=
name|src
operator|->
name|gtt_offset
expr_stmt|;
for|for
control|(
name|page
operator|=
literal|0
init|;
name|page
operator|<
name|page_count
condition|;
name|page
operator|++
control|)
block|{
name|d
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
goto|goto
name|unwind
goto|;
if|if
condition|(
name|reloc_offset
operator|<
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mappable_end
condition|)
block|{
comment|/* Simply ignore tiling or any overlapping fence. 			 * It's part of the error state, and this hopefully 			 * captures what the GPU read. 			 */
name|s
operator|=
name|pmap_mapdev_attr
argument_list|(
name|src
operator|->
name|base
operator|.
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|reloc_offset
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|s
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drm_clflush_pages
argument_list|(
operator|&
name|src
operator|->
name|pages
index|[
name|page
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|src
operator|->
name|pages
index|[
name|page
index|]
argument_list|,
name|SFB_CPUPRIVATE
operator||
name|SFB_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|d
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|d
argument_list|,
literal|"XXXKIB"
argument_list|)
expr_stmt|;
block|}
name|sched_unpin
argument_list|()
expr_stmt|;
name|drm_clflush_pages
argument_list|(
operator|&
name|src
operator|->
name|pages
index|[
name|page
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|dst
operator|->
name|pages
index|[
name|page
index|]
operator|=
name|d
expr_stmt|;
name|reloc_offset
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|dst
operator|->
name|page_count
operator|=
name|page_count
expr_stmt|;
name|dst
operator|->
name|gtt_offset
operator|=
name|src
operator|->
name|gtt_offset
expr_stmt|;
return|return
operator|(
name|dst
operator|)
return|;
name|unwind
label|:
while|while
condition|(
name|page
operator|--
condition|)
name|free
argument_list|(
name|dst
operator|->
name|pages
index|[
name|page
index|]
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dst
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_error_object_free
parameter_list|(
name|struct
name|drm_i915_error_object
modifier|*
name|obj
parameter_list|)
block|{
name|int
name|page
decl_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|page
operator|=
literal|0
init|;
name|page
operator|<
name|obj
operator|->
name|page_count
condition|;
name|page
operator|++
control|)
name|free
argument_list|(
name|obj
operator|->
name|pages
index|[
name|page
index|]
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obj
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_error_state_free
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_error_state
modifier|*
name|error
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_ARRAY_SIZE
argument_list|(
name|error
operator|->
name|ring
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|i915_error_object_free
argument_list|(
name|error
operator|->
name|ring
index|[
name|i
index|]
operator|.
name|batchbuffer
argument_list|)
expr_stmt|;
name|i915_error_object_free
argument_list|(
name|error
operator|->
name|ring
index|[
name|i
index|]
operator|.
name|ringbuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
operator|->
name|ring
index|[
name|i
index|]
operator|.
name|requests
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|error
operator|->
name|active_bo
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
operator|->
name|overlay
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u32
name|capture_bo_list
parameter_list|(
name|struct
name|drm_i915_error_buffer
modifier|*
name|err
parameter_list|,
name|int
name|count
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|head
argument_list|,
argument|mm_list
argument_list|)
block|{
name|err
operator|->
name|size
operator|=
name|obj
operator|->
name|base
operator|.
name|size
expr_stmt|;
name|err
operator|->
name|name
operator|=
name|obj
operator|->
name|base
operator|.
name|name
expr_stmt|;
name|err
operator|->
name|seqno
operator|=
name|obj
operator|->
name|last_rendering_seqno
expr_stmt|;
name|err
operator|->
name|gtt_offset
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
name|err
operator|->
name|read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|read_domains
expr_stmt|;
name|err
operator|->
name|write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|err
operator|->
name|fence_reg
operator|=
name|obj
operator|->
name|fence_reg
expr_stmt|;
name|err
operator|->
name|pinned
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|pin_count
operator|>
literal|0
condition|)
name|err
operator|->
name|pinned
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|user_pin_count
operator|>
literal|0
condition|)
name|err
operator|->
name|pinned
operator|=
operator|-
literal|1
expr_stmt|;
name|err
operator|->
name|tiling
operator|=
name|obj
operator|->
name|tiling_mode
expr_stmt|;
name|err
operator|->
name|dirty
operator|=
name|obj
operator|->
name|dirty
expr_stmt|;
name|err
operator|->
name|purgeable
operator|=
name|obj
operator|->
name|madv
operator|!=
name|I915_MADV_WILLNEED
expr_stmt|;
name|err
operator|->
name|ring
operator|=
name|obj
operator|->
name|ring
condition|?
name|obj
operator|->
name|ring
operator|->
name|id
else|:
operator|-
literal|1
expr_stmt|;
name|err
operator|->
name|cache_level
operator|=
name|obj
operator|->
name|cache_level
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|count
condition|)
break|break;
name|err
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_record_fences
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_error_state
modifier|*
name|error
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Fences */
switch|switch
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
condition|)
block|{
case|case
literal|7
case|:
case|case
literal|6
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|error
operator|->
name|fence
index|[
name|i
index|]
operator|=
name|I915_READ64
argument_list|(
name|FENCE_REG_SANDYBRIDGE_0
operator|+
operator|(
name|i
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
case|case
literal|4
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|error
operator|->
name|fence
index|[
name|i
index|]
operator|=
name|I915_READ64
argument_list|(
name|FENCE_REG_965_0
operator|+
operator|(
name|i
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_G33
argument_list|(
name|dev
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|error
operator|->
name|fence
index|[
name|i
operator|+
literal|8
index|]
operator|=
name|I915_READ
argument_list|(
name|FENCE_REG_945_8
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|error
operator|->
name|fence
index|[
name|i
index|]
operator|=
name|I915_READ
argument_list|(
name|FENCE_REG_830_0
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_i915_error_object
modifier|*
name|i915_error_first_batchbuffer
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|u32
name|seqno
decl_stmt|;
if|if
condition|(
operator|!
name|ring
operator|->
name|get_seqno
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|seqno
operator|=
name|ring
operator|->
name|get_seqno
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|&dev_priv->mm.active_list
argument_list|,
argument|mm_list
argument_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|ring
operator|!=
name|ring
condition|)
continue|continue;
if|if
condition|(
name|i915_seqno_passed
argument_list|(
name|seqno
argument_list|,
name|obj
operator|->
name|last_rendering_seqno
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_DOMAIN_COMMAND
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* We need to copy these to an anonymous buffer as the simplest 		 * method to avoid being overwritten by userspace. 		 */
return|return
operator|(
name|i915_error_object_create
argument_list|(
name|dev_priv
argument_list|,
name|obj
argument_list|)
operator|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_record_ring_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_error_state
modifier|*
name|error
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|6
condition|)
block|{
name|error
operator|->
name|faddr
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|I915_READ
argument_list|(
name|RING_DMA_FADD
argument_list|(
name|ring
operator|->
name|mmio_base
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|fault_reg
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|I915_READ
argument_list|(
name|RING_FAULT_REG
argument_list|(
name|ring
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|semaphore_mboxes
index|[
name|ring
operator|->
name|id
index|]
index|[
literal|0
index|]
operator|=
name|I915_READ
argument_list|(
name|RING_SYNC_0
argument_list|(
name|ring
operator|->
name|mmio_base
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|semaphore_mboxes
index|[
name|ring
operator|->
name|id
index|]
index|[
literal|1
index|]
operator|=
name|I915_READ
argument_list|(
name|RING_SYNC_1
argument_list|(
name|ring
operator|->
name|mmio_base
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|error
operator|->
name|ipeir
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|I915_READ
argument_list|(
name|RING_IPEIR
argument_list|(
name|ring
operator|->
name|mmio_base
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|ipehr
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|I915_READ
argument_list|(
name|RING_IPEHR
argument_list|(
name|ring
operator|->
name|mmio_base
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|instdone
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|I915_READ
argument_list|(
name|RING_INSTDONE
argument_list|(
name|ring
operator|->
name|mmio_base
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|instps
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|I915_READ
argument_list|(
name|RING_INSTPS
argument_list|(
name|ring
operator|->
name|mmio_base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|id
operator|==
name|RCS
condition|)
block|{
name|error
operator|->
name|instdone1
operator|=
name|I915_READ
argument_list|(
name|INSTDONE1
argument_list|)
expr_stmt|;
name|error
operator|->
name|bbaddr
operator|=
name|I915_READ64
argument_list|(
name|BB_ADDR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|->
name|ipeir
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|I915_READ
argument_list|(
name|IPEIR
argument_list|)
expr_stmt|;
name|error
operator|->
name|ipehr
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|I915_READ
argument_list|(
name|IPEHR
argument_list|)
expr_stmt|;
name|error
operator|->
name|instdone
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|I915_READ
argument_list|(
name|INSTDONE
argument_list|)
expr_stmt|;
block|}
name|error
operator|->
name|instpm
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|I915_READ
argument_list|(
name|RING_INSTPM
argument_list|(
name|ring
operator|->
name|mmio_base
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|seqno
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|ring
operator|->
name|get_seqno
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|error
operator|->
name|acthd
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|intel_ring_get_active_head
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|error
operator|->
name|head
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|I915_READ_HEAD
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|error
operator|->
name|tail
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|I915_READ_TAIL
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|error
operator|->
name|cpu_ring_head
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|ring
operator|->
name|head
expr_stmt|;
name|error
operator|->
name|cpu_ring_tail
index|[
name|ring
operator|->
name|id
index|]
operator|=
name|ring
operator|->
name|tail
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_record_rings
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_error_state
modifier|*
name|error
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I915_NUM_RINGS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ring
operator|->
name|obj
operator|==
name|NULL
condition|)
continue|continue;
name|i915_record_ring_state
argument_list|(
name|dev
argument_list|,
name|error
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|error
operator|->
name|ring
index|[
name|i
index|]
operator|.
name|batchbuffer
operator|=
name|i915_error_first_batchbuffer
argument_list|(
name|dev_priv
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|error
operator|->
name|ring
index|[
name|i
index|]
operator|.
name|ringbuffer
operator|=
name|i915_error_object_create
argument_list|(
name|dev_priv
argument_list|,
name|ring
operator|->
name|obj
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|request
argument_list|,
argument|&ring->request_list
argument_list|,
argument|list
argument_list|)
name|count
operator|++
expr_stmt|;
name|error
operator|->
name|ring
index|[
name|i
index|]
operator|.
name|num_requests
operator|=
name|count
expr_stmt|;
name|error
operator|->
name|ring
index|[
name|i
index|]
operator|.
name|requests
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_i915_error_request
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|->
name|ring
index|[
name|i
index|]
operator|.
name|requests
operator|==
name|NULL
condition|)
block|{
name|error
operator|->
name|ring
index|[
name|i
index|]
operator|.
name|num_requests
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|request
argument_list|,
argument|&ring->request_list
argument_list|,
argument|list
argument_list|)
block|{
name|struct
name|drm_i915_error_request
modifier|*
name|erq
decl_stmt|;
name|erq
operator|=
operator|&
name|error
operator|->
name|ring
index|[
name|i
index|]
operator|.
name|requests
index|[
name|count
operator|++
index|]
expr_stmt|;
name|erq
operator|->
name|seqno
operator|=
name|request
operator|->
name|seqno
expr_stmt|;
name|erq
operator|->
name|jiffies
operator|=
name|request
operator|->
name|emitted_jiffies
expr_stmt|;
name|erq
operator|->
name|tail
operator|=
name|request
operator|->
name|tail
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i915_capture_error_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_i915_error_state
modifier|*
name|error
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pipe
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|dev_priv
operator|->
name|first_error
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|NULL
condition|)
return|return;
comment|/* Account for pipe specific data like PIPE*STAT */
name|error
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|error
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"out of memory, not capturing error state\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|DRM_INFO
argument_list|(
literal|"capturing error event; look for more information in "
literal|"sysctl hw.dri.%d.info.i915_error_state\n"
argument_list|,
name|dev
operator|->
name|sysctl_node_idx
argument_list|)
expr_stmt|;
name|error
operator|->
name|eir
operator|=
name|I915_READ
argument_list|(
name|EIR
argument_list|)
expr_stmt|;
name|error
operator|->
name|pgtbl_er
operator|=
name|I915_READ
argument_list|(
name|PGTBL_ER
argument_list|)
expr_stmt|;
name|for_each_pipe
argument_list|(
name|pipe
argument_list|)
name|error
operator|->
name|pipestat
index|[
name|pipe
index|]
operator|=
name|I915_READ
argument_list|(
name|PIPESTAT
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|6
condition|)
block|{
name|error
operator|->
name|error
operator|=
name|I915_READ
argument_list|(
name|ERROR_GEN6
argument_list|)
expr_stmt|;
name|error
operator|->
name|done_reg
operator|=
name|I915_READ
argument_list|(
name|DONE_REG
argument_list|)
expr_stmt|;
block|}
name|i915_gem_record_fences
argument_list|(
name|dev
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|i915_gem_record_rings
argument_list|(
name|dev
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Record buffers on the active and pinned lists. */
name|error
operator|->
name|active_bo
operator|=
name|NULL
expr_stmt|;
name|error
operator|->
name|pinned_bo
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|&dev_priv->mm.active_list
argument_list|,
argument|mm_list
argument_list|)
name|i
operator|++
expr_stmt|;
name|error
operator|->
name|active_bo_count
operator|=
name|i
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|&dev_priv->mm.pinned_list
argument_list|,
argument|mm_list
argument_list|)
name|i
operator|++
expr_stmt|;
name|error
operator|->
name|pinned_bo_count
operator|=
name|i
operator|-
name|error
operator|->
name|active_bo_count
expr_stmt|;
name|error
operator|->
name|active_bo
operator|=
name|NULL
expr_stmt|;
name|error
operator|->
name|pinned_bo
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|error
operator|->
name|active_bo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|error
operator|->
name|active_bo
argument_list|)
operator|*
name|i
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|->
name|active_bo
condition|)
name|error
operator|->
name|pinned_bo
operator|=
name|error
operator|->
name|active_bo
operator|+
name|error
operator|->
name|active_bo_count
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|->
name|active_bo
condition|)
name|error
operator|->
name|active_bo_count
operator|=
name|capture_bo_list
argument_list|(
name|error
operator|->
name|active_bo
argument_list|,
name|error
operator|->
name|active_bo_count
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|active_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|->
name|pinned_bo
condition|)
name|error
operator|->
name|pinned_bo_count
operator|=
name|capture_bo_list
argument_list|(
name|error
operator|->
name|pinned_bo
argument_list|,
name|error
operator|->
name|pinned_bo_count
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|pinned_list
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|error
operator|->
name|time
argument_list|)
expr_stmt|;
name|error
operator|->
name|overlay
operator|=
name|intel_overlay_capture_error_state
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|->
name|display
operator|=
name|intel_display_capture_error_state
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|first_error
operator|==
name|NULL
condition|)
block|{
name|dev_priv
operator|->
name|first_error
operator|=
name|error
expr_stmt|;
name|error
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|NULL
condition|)
name|i915_error_state_free
argument_list|(
name|dev
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_destroy_error_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_error_state
modifier|*
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|dev_priv
operator|->
name|first_error
expr_stmt|;
name|dev_priv
operator|->
name|first_error
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|NULL
condition|)
name|i915_error_state_free
argument_list|(
name|dev
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

