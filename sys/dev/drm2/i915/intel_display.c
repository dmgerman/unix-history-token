begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Â© 2006-2007 Intel Corporation  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Authors:  *	Eric Anholt<eric@anholt.net>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_edid.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_dp_helper.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc_helper.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_define
define|#
directive|define
name|HAS_eDP
value|(intel_pipe_has_type(crtc, INTEL_OUTPUT_EDP))
end_define

begin_function_decl
name|bool
name|intel_pipe_has_type
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_update_watermarks
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_increase_pllclock
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_crtc_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|bool
name|on
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* given values */
name|int
name|n
decl_stmt|;
name|int
name|m1
decl_stmt|,
name|m2
decl_stmt|;
name|int
name|p1
decl_stmt|,
name|p2
decl_stmt|;
comment|/* derived values */
name|int
name|dot
decl_stmt|;
name|int
name|vco
decl_stmt|;
name|int
name|m
decl_stmt|;
name|int
name|p
decl_stmt|;
block|}
name|intel_clock_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|min
decl_stmt|,
name|max
decl_stmt|;
block|}
name|intel_range_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|dot_limit
decl_stmt|;
name|int
name|p2_slow
decl_stmt|,
name|p2_fast
decl_stmt|;
block|}
name|intel_p2_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|INTEL_P2_NUM
value|2
end_define

begin_typedef
typedef|typedef
name|struct
name|intel_limit
name|intel_limit_t
typedef|;
end_typedef

begin_struct
struct|struct
name|intel_limit
block|{
name|intel_range_t
name|dot
decl_stmt|,
name|vco
decl_stmt|,
name|n
decl_stmt|,
name|m
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|p
decl_stmt|,
name|p1
decl_stmt|;
name|intel_p2_t
name|p2
decl_stmt|;
name|bool
function_decl|(
modifier|*
name|find_pll
function_decl|)
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
parameter_list|,
name|struct
name|drm_crtc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|intel_clock_t
modifier|*
parameter_list|,
name|intel_clock_t
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* FDI */
end_comment

begin_define
define|#
directive|define
name|IRONLAKE_FDI_FREQ
value|2700000
end_define

begin_comment
comment|/* in kHz for mode->clock */
end_comment

begin_function_decl
specifier|static
name|bool
name|intel_find_best_PLL
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|intel_g4x_find_best_PLL
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|intel_find_pll_g4x_dp
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|intel_find_pll_ironlake_dp
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|u32
comment|/* units of 100MHz */
name|intel_fdi_link_freq
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
operator|(
name|I915_READ
argument_list|(
name|FDI_PLL_BIOS_0
argument_list|)
operator|&
name|FDI_PLL_FB_CLOCK_MASK
operator|)
operator|+
literal|2
return|;
block|}
else|else
return|return
literal|27
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_i8xx_dvo
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|930000
block|,
operator|.
name|max
operator|=
literal|1400000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|3
block|,
operator|.
name|max
operator|=
literal|16
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|96
block|,
operator|.
name|max
operator|=
literal|140
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|18
block|,
operator|.
name|max
operator|=
literal|26
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|6
block|,
operator|.
name|max
operator|=
literal|16
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|4
block|,
operator|.
name|max
operator|=
literal|128
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|33
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|165000
block|,
operator|.
name|p2_slow
operator|=
literal|4
block|,
operator|.
name|p2_fast
operator|=
literal|2
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_i8xx_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|930000
block|,
operator|.
name|max
operator|=
literal|1400000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|3
block|,
operator|.
name|max
operator|=
literal|16
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|96
block|,
operator|.
name|max
operator|=
literal|140
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|18
block|,
operator|.
name|max
operator|=
literal|26
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|6
block|,
operator|.
name|max
operator|=
literal|16
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|4
block|,
operator|.
name|max
operator|=
literal|128
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|165000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_i9xx_sdvo
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1400000
block|,
operator|.
name|max
operator|=
literal|2800000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|70
block|,
operator|.
name|max
operator|=
literal|120
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|80
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|200000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|5
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_i9xx_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1400000
block|,
operator|.
name|max
operator|=
literal|2800000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|70
block|,
operator|.
name|max
operator|=
literal|120
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|7
block|,
operator|.
name|max
operator|=
literal|98
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|112000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_sdvo
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|270000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|4
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|104
block|,
operator|.
name|max
operator|=
literal|138
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|17
block|,
operator|.
name|max
operator|=
literal|23
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|11
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|30
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|270000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|10
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_hdmi
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|22000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|4
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|104
block|,
operator|.
name|max
operator|=
literal|138
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|16
block|,
operator|.
name|max
operator|=
literal|23
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|11
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|80
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|165000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|5
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_single_channel_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|115000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|104
block|,
operator|.
name|max
operator|=
literal|138
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|17
block|,
operator|.
name|max
operator|=
literal|23
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|11
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|28
block|,
operator|.
name|max
operator|=
literal|112
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|0
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|14
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_dual_channel_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|80000
block|,
operator|.
name|max
operator|=
literal|224000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|104
block|,
operator|.
name|max
operator|=
literal|138
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|17
block|,
operator|.
name|max
operator|=
literal|23
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|11
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|14
block|,
operator|.
name|max
operator|=
literal|42
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|0
block|,
operator|.
name|p2_slow
operator|=
literal|7
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_display_port
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|161670
block|,
operator|.
name|max
operator|=
literal|227000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|97
block|,
operator|.
name|max
operator|=
literal|108
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|0x10
block|,
operator|.
name|max
operator|=
literal|0x12
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|0x05
block|,
operator|.
name|max
operator|=
literal|0x06
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|20
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|0
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|10
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_pll_g4x_dp
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_pineview_sdvo
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1700000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
comment|/* Pineview's Ncounter is a ring counter */
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|3
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|256
block|}
block|,
comment|/* Pineview only has one combined m divider, which we treat as m2. */
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|0
block|,
operator|.
name|max
operator|=
literal|0
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|0
block|,
operator|.
name|max
operator|=
literal|254
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|80
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|200000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|5
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_pineview_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1700000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|3
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|256
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|0
block|,
operator|.
name|max
operator|=
literal|0
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|0
block|,
operator|.
name|max
operator|=
literal|254
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|7
block|,
operator|.
name|max
operator|=
literal|112
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|112000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|14
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ironlake / Sandybridge  *  * We calculate clock using (register_value + 2) for N/M1/M2, so here  * the range value for them is (actual_value - 2).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_dac
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|5
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|127
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|80
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|5
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_single_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|118
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|28
block|,
operator|.
name|max
operator|=
literal|112
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|14
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_dual_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|127
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|14
block|,
operator|.
name|max
operator|=
literal|56
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|7
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LVDS 100mhz refclk limits. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_single_lvds_100m
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|126
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|28
block|,
operator|.
name|max
operator|=
literal|112
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|14
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_dual_lvds_100m
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|126
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|14
block|,
operator|.
name|max
operator|=
literal|42
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|7
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_display_port
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|81
block|,
operator|.
name|max
operator|=
literal|90
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|20
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|0
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|10
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_pll_ironlake_dp
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|intel_limit_t
modifier|*
name|intel_ironlake_limit
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|refclk
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
operator|&
name|LVDS_CLKB_POWER_MASK
operator|)
operator|==
name|LVDS_CLKB_POWER_UP
condition|)
block|{
comment|/* LVDS dual channel */
if|if
condition|(
name|refclk
operator|==
literal|100000
condition|)
name|limit
operator|=
operator|&
name|intel_limits_ironlake_dual_lvds_100m
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_ironlake_dual_lvds
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|refclk
operator|==
literal|100000
condition|)
name|limit
operator|=
operator|&
name|intel_limits_ironlake_single_lvds_100m
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_ironlake_single_lvds
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
operator|||
name|HAS_eDP
condition|)
name|limit
operator|=
operator|&
name|intel_limits_ironlake_display_port
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_ironlake_dac
expr_stmt|;
return|return
name|limit
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|intel_limit_t
modifier|*
name|intel_g4x_limit
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|LVDS
argument_list|)
operator|&
name|LVDS_CLKB_POWER_MASK
operator|)
operator|==
name|LVDS_CLKB_POWER_UP
condition|)
comment|/* LVDS with dual channel */
name|limit
operator|=
operator|&
name|intel_limits_g4x_dual_channel_lvds
expr_stmt|;
else|else
comment|/* LVDS with dual channel */
name|limit
operator|=
operator|&
name|intel_limits_g4x_single_channel_lvds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_HDMI
argument_list|)
operator|||
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_ANALOG
argument_list|)
condition|)
block|{
name|limit
operator|=
operator|&
name|intel_limits_g4x_hdmi
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_SDVO
argument_list|)
condition|)
block|{
name|limit
operator|=
operator|&
name|intel_limits_g4x_sdvo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
condition|)
block|{
name|limit
operator|=
operator|&
name|intel_limits_g4x_display_port
expr_stmt|;
block|}
else|else
comment|/* The option is for other outputs */
name|limit
operator|=
operator|&
name|intel_limits_i9xx_sdvo
expr_stmt|;
return|return
name|limit
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|intel_limit_t
modifier|*
name|intel_limit
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|refclk
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|limit
operator|=
name|intel_ironlake_limit
argument_list|(
name|crtc
argument_list|,
name|refclk
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|limit
operator|=
name|intel_g4x_limit
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|limit
operator|=
operator|&
name|intel_limits_pineview_lvds
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_pineview_sdvo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|limit
operator|=
operator|&
name|intel_limits_i9xx_lvds
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_i9xx_sdvo
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|limit
operator|=
operator|&
name|intel_limits_i8xx_lvds
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_i8xx_dvo
expr_stmt|;
block|}
return|return
name|limit
return|;
block|}
end_function

begin_comment
comment|/* m1 is reserved as 0 in Pineview, n is a ring counter */
end_comment

begin_function
specifier|static
name|void
name|pineview_clock
parameter_list|(
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|)
block|{
name|clock
operator|->
name|m
operator|=
name|clock
operator|->
name|m2
operator|+
literal|2
expr_stmt|;
name|clock
operator|->
name|p
operator|=
name|clock
operator|->
name|p1
operator|*
name|clock
operator|->
name|p2
expr_stmt|;
name|clock
operator|->
name|vco
operator|=
name|refclk
operator|*
name|clock
operator|->
name|m
operator|/
name|clock
operator|->
name|n
expr_stmt|;
name|clock
operator|->
name|dot
operator|=
name|clock
operator|->
name|vco
operator|/
name|clock
operator|->
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_clock
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|)
block|{
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|pineview_clock
argument_list|(
name|refclk
argument_list|,
name|clock
argument_list|)
expr_stmt|;
return|return;
block|}
name|clock
operator|->
name|m
operator|=
literal|5
operator|*
operator|(
name|clock
operator|->
name|m1
operator|+
literal|2
operator|)
operator|+
operator|(
name|clock
operator|->
name|m2
operator|+
literal|2
operator|)
expr_stmt|;
name|clock
operator|->
name|p
operator|=
name|clock
operator|->
name|p1
operator|*
name|clock
operator|->
name|p2
expr_stmt|;
name|clock
operator|->
name|vco
operator|=
name|refclk
operator|*
name|clock
operator|->
name|m
operator|/
operator|(
name|clock
operator|->
name|n
operator|+
literal|2
operator|)
expr_stmt|;
name|clock
operator|->
name|dot
operator|=
name|clock
operator|->
name|vco
operator|/
name|clock
operator|->
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Returns whether any output on the specified pipe is of the specified type  */
end_comment

begin_function
name|bool
name|intel_pipe_has_type
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|==
name|crtc
operator|&&
name|encoder
operator|->
name|type
operator|==
name|type
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_define
define|#
directive|define
name|INTELPllInvalid
parameter_list|(
name|s
parameter_list|)
value|do {
comment|/* DRM_DEBUG(s); */
value|return false; } while (0)
end_define

begin_comment
comment|/**  * Returns whether the given set of divisors are valid for a given refclk with  * the given connectors.  */
end_comment

begin_function
specifier|static
name|bool
name|intel_PLL_is_valid
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
specifier|const
name|intel_clock_t
modifier|*
name|clock
parameter_list|)
block|{
if|if
condition|(
name|clock
operator|->
name|p1
operator|<
name|limit
operator|->
name|p1
operator|.
name|min
operator|||
name|limit
operator|->
name|p1
operator|.
name|max
operator|<
name|clock
operator|->
name|p1
condition|)
name|INTELPllInvalid
argument_list|(
literal|"p1 out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|p
operator|<
name|limit
operator|->
name|p
operator|.
name|min
operator|||
name|limit
operator|->
name|p
operator|.
name|max
operator|<
name|clock
operator|->
name|p
condition|)
name|INTELPllInvalid
argument_list|(
literal|"p out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|m2
operator|<
name|limit
operator|->
name|m2
operator|.
name|min
operator|||
name|limit
operator|->
name|m2
operator|.
name|max
operator|<
name|clock
operator|->
name|m2
condition|)
name|INTELPllInvalid
argument_list|(
literal|"m2 out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|m1
operator|<
name|limit
operator|->
name|m1
operator|.
name|min
operator|||
name|limit
operator|->
name|m1
operator|.
name|max
operator|<
name|clock
operator|->
name|m1
condition|)
name|INTELPllInvalid
argument_list|(
literal|"m1 out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|m1
operator|<=
name|clock
operator|->
name|m2
operator|&&
operator|!
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|INTELPllInvalid
argument_list|(
literal|"m1<= m2\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|m
operator|<
name|limit
operator|->
name|m
operator|.
name|min
operator|||
name|limit
operator|->
name|m
operator|.
name|max
operator|<
name|clock
operator|->
name|m
condition|)
name|INTELPllInvalid
argument_list|(
literal|"m out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|n
operator|<
name|limit
operator|->
name|n
operator|.
name|min
operator|||
name|limit
operator|->
name|n
operator|.
name|max
operator|<
name|clock
operator|->
name|n
condition|)
name|INTELPllInvalid
argument_list|(
literal|"n out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|vco
operator|<
name|limit
operator|->
name|vco
operator|.
name|min
operator|||
name|limit
operator|->
name|vco
operator|.
name|max
operator|<
name|clock
operator|->
name|vco
condition|)
name|INTELPllInvalid
argument_list|(
literal|"vco out of range\n"
argument_list|)
expr_stmt|;
comment|/* XXX: We may need to be checking "Dot clock" depending on the multiplier, 	 * connector, etc., rather than just a single range. 	 */
if|if
condition|(
name|clock
operator|->
name|dot
operator|<
name|limit
operator|->
name|dot
operator|.
name|min
operator|||
name|limit
operator|->
name|dot
operator|.
name|max
operator|<
name|clock
operator|->
name|dot
condition|)
name|INTELPllInvalid
argument_list|(
literal|"dot out of range\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_find_best_PLL
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|;
name|int
name|err
init|=
name|target
decl_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|&&
operator|(
name|I915_READ
argument_list|(
name|LVDS
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * For LVDS, if the panel is on, just rely on its current 		 * settings for dual-channel.  We haven't figured out how to 		 * reliably set up different single/dual channel state, if we 		 * even can. 		 */
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|LVDS
argument_list|)
operator|&
name|LVDS_CLKB_POWER_MASK
operator|)
operator|==
name|LVDS_CLKB_POWER_UP
condition|)
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_fast
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_slow
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target
operator|<
name|limit
operator|->
name|p2
operator|.
name|dot_limit
condition|)
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_slow
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_fast
expr_stmt|;
block|}
name|memset
argument_list|(
name|best_clock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|best_clock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|clock
operator|.
name|m1
operator|=
name|limit
operator|->
name|m1
operator|.
name|min
init|;
name|clock
operator|.
name|m1
operator|<=
name|limit
operator|->
name|m1
operator|.
name|max
condition|;
name|clock
operator|.
name|m1
operator|++
control|)
block|{
for|for
control|(
name|clock
operator|.
name|m2
operator|=
name|limit
operator|->
name|m2
operator|.
name|min
init|;
name|clock
operator|.
name|m2
operator|<=
name|limit
operator|->
name|m2
operator|.
name|max
condition|;
name|clock
operator|.
name|m2
operator|++
control|)
block|{
comment|/* m1 is always 0 in Pineview */
if|if
condition|(
name|clock
operator|.
name|m2
operator|>=
name|clock
operator|.
name|m1
operator|&&
operator|!
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
break|break;
for|for
control|(
name|clock
operator|.
name|n
operator|=
name|limit
operator|->
name|n
operator|.
name|min
init|;
name|clock
operator|.
name|n
operator|<=
name|limit
operator|->
name|n
operator|.
name|max
condition|;
name|clock
operator|.
name|n
operator|++
control|)
block|{
for|for
control|(
name|clock
operator|.
name|p1
operator|=
name|limit
operator|->
name|p1
operator|.
name|min
init|;
name|clock
operator|.
name|p1
operator|<=
name|limit
operator|->
name|p1
operator|.
name|max
condition|;
name|clock
operator|.
name|p1
operator|++
control|)
block|{
name|int
name|this_err
decl_stmt|;
name|intel_clock
argument_list|(
name|dev
argument_list|,
name|refclk
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_PLL_is_valid
argument_list|(
name|dev
argument_list|,
name|limit
argument_list|,
operator|&
name|clock
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|match_clock
operator|&&
name|clock
operator|.
name|p
operator|!=
name|match_clock
operator|->
name|p
condition|)
continue|continue;
name|this_err
operator|=
name|abs
argument_list|(
name|clock
operator|.
name|dot
operator|-
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_err
operator|<
name|err
condition|)
block|{
operator|*
name|best_clock
operator|=
name|clock
expr_stmt|;
name|err
operator|=
name|this_err
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
operator|(
name|err
operator|!=
name|target
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_g4x_find_best_PLL
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|;
name|int
name|max_n
decl_stmt|;
name|bool
name|found
decl_stmt|;
comment|/* approximately equals target * 0.00585 */
name|int
name|err_most
init|=
operator|(
name|target
operator|>>
literal|8
operator|)
operator|+
operator|(
name|target
operator|>>
literal|9
operator|)
decl_stmt|;
name|found
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
name|int
name|lvds_reg
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|lvds_reg
operator|=
name|PCH_LVDS
expr_stmt|;
else|else
name|lvds_reg
operator|=
name|LVDS
expr_stmt|;
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|lvds_reg
argument_list|)
operator|&
name|LVDS_CLKB_POWER_MASK
operator|)
operator|==
name|LVDS_CLKB_POWER_UP
condition|)
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_fast
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_slow
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target
operator|<
name|limit
operator|->
name|p2
operator|.
name|dot_limit
condition|)
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_slow
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_fast
expr_stmt|;
block|}
name|memset
argument_list|(
name|best_clock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|best_clock
argument_list|)
argument_list|)
expr_stmt|;
name|max_n
operator|=
name|limit
operator|->
name|n
operator|.
name|max
expr_stmt|;
comment|/* based on hardware requirement, prefer smaller n to precision */
for|for
control|(
name|clock
operator|.
name|n
operator|=
name|limit
operator|->
name|n
operator|.
name|min
init|;
name|clock
operator|.
name|n
operator|<=
name|max_n
condition|;
name|clock
operator|.
name|n
operator|++
control|)
block|{
comment|/* based on hardware requirement, prefere larger m1,m2 */
for|for
control|(
name|clock
operator|.
name|m1
operator|=
name|limit
operator|->
name|m1
operator|.
name|max
init|;
name|clock
operator|.
name|m1
operator|>=
name|limit
operator|->
name|m1
operator|.
name|min
condition|;
name|clock
operator|.
name|m1
operator|--
control|)
block|{
for|for
control|(
name|clock
operator|.
name|m2
operator|=
name|limit
operator|->
name|m2
operator|.
name|max
init|;
name|clock
operator|.
name|m2
operator|>=
name|limit
operator|->
name|m2
operator|.
name|min
condition|;
name|clock
operator|.
name|m2
operator|--
control|)
block|{
for|for
control|(
name|clock
operator|.
name|p1
operator|=
name|limit
operator|->
name|p1
operator|.
name|max
init|;
name|clock
operator|.
name|p1
operator|>=
name|limit
operator|->
name|p1
operator|.
name|min
condition|;
name|clock
operator|.
name|p1
operator|--
control|)
block|{
name|int
name|this_err
decl_stmt|;
name|intel_clock
argument_list|(
name|dev
argument_list|,
name|refclk
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_PLL_is_valid
argument_list|(
name|dev
argument_list|,
name|limit
argument_list|,
operator|&
name|clock
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|match_clock
operator|&&
name|clock
operator|.
name|p
operator|!=
name|match_clock
operator|->
name|p
condition|)
continue|continue;
name|this_err
operator|=
name|abs
argument_list|(
name|clock
operator|.
name|dot
operator|-
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_err
operator|<
name|err_most
condition|)
block|{
operator|*
name|best_clock
operator|=
name|clock
expr_stmt|;
name|err_most
operator|=
name|this_err
expr_stmt|;
name|max_n
operator|=
name|clock
operator|.
name|n
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_find_pll_ironlake_dp
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|200000
condition|)
block|{
name|clock
operator|.
name|n
operator|=
literal|1
expr_stmt|;
name|clock
operator|.
name|p1
operator|=
literal|2
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|12
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|9
expr_stmt|;
block|}
else|else
block|{
name|clock
operator|.
name|n
operator|=
literal|2
expr_stmt|;
name|clock
operator|.
name|p1
operator|=
literal|1
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|14
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|8
expr_stmt|;
block|}
name|intel_clock
argument_list|(
name|dev
argument_list|,
name|refclk
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|best_clock
argument_list|,
operator|&
name|clock
argument_list|,
sizeof|sizeof
argument_list|(
name|intel_clock_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* DisplayPort has only two frequencies, 162MHz and 270MHz */
end_comment

begin_function
specifier|static
name|bool
name|intel_find_pll_g4x_dp
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
block|{
name|intel_clock_t
name|clock
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|200000
condition|)
block|{
name|clock
operator|.
name|p1
operator|=
literal|2
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|n
operator|=
literal|2
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|23
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|clock
operator|.
name|p1
operator|=
literal|1
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|n
operator|=
literal|1
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|14
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|2
expr_stmt|;
block|}
name|clock
operator|.
name|m
operator|=
literal|5
operator|*
operator|(
name|clock
operator|.
name|m1
operator|+
literal|2
operator|)
operator|+
operator|(
name|clock
operator|.
name|m2
operator|+
literal|2
operator|)
expr_stmt|;
name|clock
operator|.
name|p
operator|=
operator|(
name|clock
operator|.
name|p1
operator|*
name|clock
operator|.
name|p2
operator|)
expr_stmt|;
name|clock
operator|.
name|dot
operator|=
literal|96000
operator|*
name|clock
operator|.
name|m
operator|/
operator|(
name|clock
operator|.
name|n
operator|+
literal|2
operator|)
operator|/
name|clock
operator|.
name|p
expr_stmt|;
name|clock
operator|.
name|vco
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|best_clock
argument_list|,
operator|&
name|clock
argument_list|,
sizeof|sizeof
argument_list|(
name|intel_clock_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * intel_wait_for_vblank - wait for vblank on a given pipe  * @dev: drm device  * @pipe: pipe to wait for  *  * Wait for vblank to occur on a given pipe.  Needed for various bits of  * mode setting code.  */
end_comment

begin_function
name|void
name|intel_wait_for_vblank
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipestat_reg
init|=
name|PIPESTAT
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
comment|/* Clear existing vblank status. Note this will clear any other 	 * sticky status fields as well. 	 * 	 * This races with i915_driver_irq_handler() with the result 	 * that either function could miss a vblank event.  Here it is not 	 * fatal, as we will either wait upon the next vblank interrupt or 	 * timeout.  Generally speaking intel_wait_for_vblank() is only 	 * called during modeset at which time the GPU should be idle and 	 * should *not* be performing page flips and thus not waiting on 	 * vblanks... 	 * Currently, the result of us stealing a vblank from the irq 	 * handler is that a single frame will be skipped during swapbuffers. 	 */
name|I915_WRITE
argument_list|(
name|pipestat_reg
argument_list|,
name|I915_READ
argument_list|(
name|pipestat_reg
argument_list|)
operator||
name|PIPE_VBLANK_INTERRUPT_STATUS
argument_list|)
expr_stmt|;
comment|/* Wait for vblank interrupt bit to set */
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
name|I915_READ
argument_list|(
name|pipestat_reg
argument_list|)
operator|&
name|PIPE_VBLANK_INTERRUPT_STATUS
argument_list|,
literal|50
argument_list|,
literal|1
argument_list|,
literal|"915vbl"
argument_list|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"vblank wait timed out\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * intel_wait_for_pipe_off - wait for pipe to turn off  * @dev: drm device  * @pipe: pipe to wait for  *  * After disabling a pipe, we can't wait for vblank in the usual way,  * spinning on the vblank interrupt status bit, since we won't actually  * see an interrupt when the pipe is disabled.  *  * On Gen4 and above:  *   wait for the pipe register state bit to turn off  *  * Otherwise:  *   wait for the display line value to settle (it usually  *   ends up stopping at the start of the next frame).  *  */
end_comment

begin_function
name|void
name|intel_wait_for_pipe_off
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|int
name|reg
init|=
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
comment|/* Wait for the Pipe State to go off */
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|I965_PIPECONF_ACTIVE
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|,
literal|1
argument_list|,
literal|"915pip"
argument_list|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"pipe_off wait timed out\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u32
name|last_line
decl_stmt|;
name|int
name|reg
init|=
name|PIPEDSL
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|timeout
init|=
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
literal|100
argument_list|)
decl_stmt|;
comment|/* Wait for the display line to settle */
do|do
block|{
name|last_line
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|DSL_LINEMASK
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|(
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|DSL_LINEMASK
operator|)
operator|!=
name|last_line
operator|)
operator|&&
name|time_after
argument_list|(
name|timeout
argument_list|,
name|jiffies
argument_list|)
condition|)
do|;
if|if
condition|(
name|time_after
argument_list|(
name|jiffies
argument_list|,
name|timeout
argument_list|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"pipe_off wait timed out\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|state_string
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
return|return
name|enabled
condition|?
literal|"on"
else|:
literal|"off"
return|;
block|}
end_function

begin_comment
comment|/* Only for pre-ILK configs */
end_comment

begin_function
specifier|static
name|void
name|assert_pll
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
name|reg
operator|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|DPLL_VCO_ENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|!=
name|state
condition|)
name|printf
argument_list|(
literal|"PLL state assertion failure (expected %s, current %s)\n"
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|assert_pll_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_pll(d, p, true)
end_define

begin_define
define|#
directive|define
name|assert_pll_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_pll(d, p, false)
end_define

begin_comment
comment|/* For ILK+ */
end_comment

begin_function
specifier|static
name|void
name|assert_pch_pll
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|u32
name|pch_dpll
decl_stmt|;
name|pch_dpll
operator|=
name|I915_READ
argument_list|(
name|PCH_DPLL_SEL
argument_list|)
expr_stmt|;
comment|/* Make sure the selected PLL is enabled to the transcoder */
name|KASSERT
argument_list|(
operator|(
operator|(
name|pch_dpll
operator|>>
operator|(
literal|4
operator|*
name|pipe
operator|)
operator|)
operator|&
literal|8
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"transcoder %d PLL not enabled\n"
operator|,
name|pipe
operator|)
argument_list|)
expr_stmt|;
comment|/* Convert the transcoder pipe number to a pll pipe number */
name|pipe
operator|=
operator|(
name|pch_dpll
operator|>>
operator|(
literal|4
operator|*
name|pipe
operator|)
operator|)
operator|&
literal|1
expr_stmt|;
block|}
name|reg
operator|=
name|PCH_DPLL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|DPLL_VCO_ENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|!=
name|state
condition|)
name|printf
argument_list|(
literal|"PCH PLL state assertion failure (expected %s, current %s)\n"
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|assert_pch_pll_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_pch_pll(d, p, true)
end_define

begin_define
define|#
directive|define
name|assert_pch_pll_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_pch_pll(d, p, false)
end_define

begin_function
specifier|static
name|void
name|assert_fdi_tx
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|FDI_TX_ENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|!=
name|state
condition|)
name|printf
argument_list|(
literal|"FDI TX state assertion failure (expected %s, current %s)\n"
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|assert_fdi_tx_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_fdi_tx(d, p, true)
end_define

begin_define
define|#
directive|define
name|assert_fdi_tx_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_fdi_tx(d, p, false)
end_define

begin_function
specifier|static
name|void
name|assert_fdi_rx
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|FDI_RX_ENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|!=
name|state
condition|)
name|printf
argument_list|(
literal|"FDI RX state assertion failure (expected %s, current %s)\n"
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|assert_fdi_rx_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_fdi_rx(d, p, true)
end_define

begin_define
define|#
directive|define
name|assert_fdi_rx_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_fdi_rx(d, p, false)
end_define

begin_function
specifier|static
name|void
name|assert_fdi_tx_pll_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* ILK FDI PLL is always enabled */
if|if
condition|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|==
literal|5
condition|)
return|return;
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|FDI_TX_PLL_ENABLE
operator|)
condition|)
name|printf
argument_list|(
literal|"FDI TX PLL assertion failure, should be active but is disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_fdi_rx_pll_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|FDI_RX_PLL_ENABLE
operator|)
condition|)
name|printf
argument_list|(
literal|"FDI RX PLL assertion failure, should be active but is disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_panel_unlocked
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|pp_reg
decl_stmt|,
name|lvds_reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|enum
name|pipe
name|panel_pipe
init|=
name|PIPE_A
decl_stmt|;
name|bool
name|locked
init|=
name|true
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|pp_reg
operator|=
name|PCH_PP_CONTROL
expr_stmt|;
name|lvds_reg
operator|=
name|PCH_LVDS
expr_stmt|;
block|}
else|else
block|{
name|pp_reg
operator|=
name|PP_CONTROL
expr_stmt|;
name|lvds_reg
operator|=
name|LVDS
expr_stmt|;
block|}
name|val
operator|=
name|I915_READ
argument_list|(
name|pp_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PANEL_POWER_ON
operator|)
operator|||
operator|(
operator|(
name|val
operator|&
name|PANEL_UNLOCK_REGS
operator|)
operator|==
name|PANEL_UNLOCK_REGS
operator|)
condition|)
name|locked
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|lvds_reg
argument_list|)
operator|&
name|LVDS_PIPEB_SELECT
condition|)
name|panel_pipe
operator|=
name|PIPE_B
expr_stmt|;
if|if
condition|(
name|panel_pipe
operator|==
name|pipe
operator|&&
name|locked
condition|)
name|printf
argument_list|(
literal|"panel assertion failure, pipe %c regs locked\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|assert_pipe
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
comment|/* if we need the pipe A quirk it must be always on */
if|if
condition|(
name|pipe
operator|==
name|PIPE_A
operator|&&
name|dev_priv
operator|->
name|quirks
operator|&
name|QUIRK_PIPEA_FORCE
condition|)
name|state
operator|=
name|true
expr_stmt|;
name|reg
operator|=
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|PIPECONF_ENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|!=
name|state
condition|)
name|printf
argument_list|(
literal|"pipe %c assertion failure (expected %s, current %s)\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_plane
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|plane
name|plane
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|!=
name|state
condition|)
name|printf
argument_list|(
literal|"plane %c assertion failure, (expected %s, current %s)\n"
argument_list|,
name|plane_name
argument_list|(
name|plane
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|assert_plane_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_plane(d, p, true)
end_define

begin_define
define|#
directive|define
name|assert_plane_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_plane(d, p, false)
end_define

begin_function
specifier|static
name|void
name|assert_planes_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|,
name|i
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|int
name|cur_pipe
decl_stmt|;
comment|/* Planes are fixed to pipes on ILK+ */
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"plane %c assertion failure, should be disabled but not\n"
argument_list|,
name|plane_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Need to check both planes against the pipe */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_pipe
operator|=
operator|(
name|val
operator|&
name|DISPPLANE_SEL_PIPE_MASK
operator|)
operator|>>
name|DISPPLANE_SEL_PIPE_SHIFT
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
operator|&&
name|pipe
operator|==
name|cur_pipe
condition|)
name|printf
argument_list|(
literal|"plane %c assertion failure, should be off on pipe %c but is still active\n"
argument_list|,
name|plane_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|assert_pch_refclk_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|bool
name|enabled
decl_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|enabled
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
operator|(
name|DREF_SSC_SOURCE_MASK
operator||
name|DREF_NONSPREAD_SOURCE_MASK
operator||
name|DREF_SUPERSPREAD_SOURCE_MASK
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|enabled
condition|)
name|printf
argument_list|(
literal|"PCH refclk assertion failure, should be active but is disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_transcoder_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|enabled
decl_stmt|;
name|reg
operator|=
name|TRANSCONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|enabled
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|TRANS_ENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|enabled
condition|)
name|printf
argument_list|(
literal|"transcoder assertion failed, should be off on pipe %c but is still active\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|hdmi_pipe_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_TRANS_SEL_MASK
operator|)
operator|!=
name|PORT_TRANS_SEL_CPT
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|TRANSCODER_MASK
operator|)
operator|!=
name|TRANSCODER
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|lvds_pipe_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|LVDS_PORT_EN
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_TRANS_SEL_MASK
operator|)
operator|!=
name|PORT_TRANS_SEL_CPT
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|LVDS_PIPE_MASK
operator|)
operator|!=
name|LVDS_PIPE
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|adpa_pipe_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|ADPA_DAC_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_TRANS_SEL_MASK
operator|)
operator|!=
name|PORT_TRANS_SEL_CPT
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|ADPA_PIPE_SELECT_MASK
operator|)
operator|!=
name|ADPA_PIPE_SELECT
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|dp_pipe_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|u32
name|port_sel
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|DP_PORT_EN
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|u32
name|trans_dp_ctl_reg
init|=
name|TRANS_DP_CTL
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|u32
name|trans_dp_ctl
init|=
name|I915_READ
argument_list|(
name|trans_dp_ctl_reg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|trans_dp_ctl
operator|&
name|TRANS_DP_PORT_SEL_MASK
operator|)
operator|!=
name|port_sel
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|DP_PIPE_MASK
operator|)
operator|!=
operator|(
name|pipe
operator|<<
literal|30
operator|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_pch_dp_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|int
name|reg
parameter_list|,
name|u32
name|port_sel
parameter_list|)
block|{
name|u32
name|val
init|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|dp_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|port_sel
argument_list|,
name|val
argument_list|)
condition|)
name|printf
argument_list|(
literal|"PCH DP (0x%08x) enabled on transcoder %c, should be disabled\n"
argument_list|,
name|reg
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_pch_hdmi_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|u32
name|val
init|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|hdmi_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|val
argument_list|,
name|pipe
argument_list|)
condition|)
name|printf
argument_list|(
literal|"PCH HDMI (0x%08x) enabled on transcoder %c, should be disabled\n"
argument_list|,
name|reg
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_pch_ports_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|assert_pch_dp_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_B
argument_list|,
name|TRANS_DP_PORT_SEL_B
argument_list|)
expr_stmt|;
name|assert_pch_dp_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_C
argument_list|,
name|TRANS_DP_PORT_SEL_C
argument_list|)
expr_stmt|;
name|assert_pch_dp_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_D
argument_list|,
name|TRANS_DP_PORT_SEL_D
argument_list|)
expr_stmt|;
name|reg
operator|=
name|PCH_ADPA
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|adpa_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|val
argument_list|,
name|pipe
argument_list|)
condition|)
name|printf
argument_list|(
literal|"PCH VGA enabled on transcoder %c, should be disabled\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|PCH_LVDS
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvds_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|val
argument_list|,
name|pipe
argument_list|)
condition|)
name|printf
argument_list|(
literal|"PCH LVDS enabled on transcoder %c, should be disabled\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|assert_pch_hdmi_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMIB
argument_list|)
expr_stmt|;
name|assert_pch_hdmi_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMIC
argument_list|)
expr_stmt|;
name|assert_pch_hdmi_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMID
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_enable_pll - enable a PLL  * @dev_priv: i915 private structure  * @pipe: pipe PLL to enable  *  * Enable @pipe's PLL so we can start pumping pixels from a plane.  Check to  * make sure the PLL reg is writable first though, since the panel write  * protect mechanism may be enabled.  *  * Note!  This is for pre-ILK only.  */
end_comment

begin_function
specifier|static
name|void
name|intel_enable_pll
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* No really, not for ILK+ */
name|KASSERT
argument_list|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|<
literal|5
argument_list|,
operator|(
literal|"Wrong device gen"
operator|)
argument_list|)
expr_stmt|;
comment|/* PLL is protected by panel, make sure we can write it */
if|if
condition|(
name|IS_MOBILE
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
operator|&&
operator|!
name|IS_I830
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
name|assert_panel_unlocked
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator||=
name|DPLL_VCO_ENABLE
expr_stmt|;
comment|/* We do this three times for luck */
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* wait for warmup */
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* wait for warmup */
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* wait for warmup */
block|}
end_function

begin_comment
comment|/**  * intel_disable_pll - disable a PLL  * @dev_priv: i915 private structure  * @pipe: pipe PLL to disable  *  * Disable the PLL for @pipe, making sure the pipe is off first.  *  * Note!  This is for pre-ILK only.  */
end_comment

begin_function
specifier|static
name|void
name|intel_disable_pll
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* Don't disable pipe A or pipe A PLLs if needed */
if|if
condition|(
name|pipe
operator|==
name|PIPE_A
operator|&&
operator|(
name|dev_priv
operator|->
name|quirks
operator|&
name|QUIRK_PIPEA_FORCE
operator|)
condition|)
return|return;
comment|/* Make sure the pipe isn't still relying on us */
name|assert_pipe_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|DPLL_VCO_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_enable_pch_pll - enable PCH PLL  * @dev_priv: i915 private structure  * @pipe: pipe PLL to enable  *  * The PCH PLL needs to be enabled before the PCH transcoder, since it  * drives the transcoder clock.  */
end_comment

begin_function
specifier|static
name|void
name|intel_enable_pch_pll
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
if|if
condition|(
name|pipe
operator|>
literal|1
condition|)
return|return;
comment|/* PCH only available on ILK+ */
name|KASSERT
argument_list|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|>=
literal|5
argument_list|,
operator|(
literal|"Wrong device gen"
operator|)
argument_list|)
expr_stmt|;
comment|/* PCH refclock must be enabled first */
name|assert_pch_refclk_enabled
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|reg
operator|=
name|PCH_DPLL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator||=
name|DPLL_VCO_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_disable_pch_pll
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|,
name|pll_mask
init|=
name|TRANSC_DPLL_ENABLE
operator||
name|TRANSC_DPLLB_SEL
decl_stmt|,
name|pll_sel
init|=
name|TRANSC_DPLL_ENABLE
decl_stmt|;
if|if
condition|(
name|pipe
operator|>
literal|1
condition|)
return|return;
comment|/* PCH only available on ILK+ */
name|KASSERT
argument_list|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|>=
literal|5
argument_list|,
operator|(
literal|"Wrong device gen"
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure transcoder isn't still depending on us */
name|assert_transcoder_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
literal|0
condition|)
name|pll_sel
operator||=
name|TRANSC_DPLLA_SEL
expr_stmt|;
elseif|else
if|if
condition|(
name|pipe
operator|==
literal|1
condition|)
name|pll_sel
operator||=
name|TRANSC_DPLLB_SEL
expr_stmt|;
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|PCH_DPLL_SEL
argument_list|)
operator|&
name|pll_mask
operator|)
operator|==
name|pll_sel
condition|)
return|return;
name|reg
operator|=
name|PCH_DPLL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|DPLL_VCO_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_enable_transcoder
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|,
name|pipeconf_val
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|pipe
index|]
decl_stmt|;
comment|/* PCH only available on ILK+ */
name|KASSERT
argument_list|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|>=
literal|5
argument_list|,
operator|(
literal|"Wrong device gen"
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure PCH DPLL is enabled */
name|assert_pch_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* FDI must be feeding us bits for PCH ports */
name|assert_fdi_tx_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|assert_fdi_rx_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|TRANSCONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|pipeconf_val
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
comment|/* 		 * make the BPC in transcoder be consistent with 		 * that in pipeconf reg. 		 */
name|val
operator|&=
operator|~
name|PIPE_BPC_MASK
expr_stmt|;
name|val
operator||=
name|pipeconf_val
operator|&
name|PIPE_BPC_MASK
expr_stmt|;
block|}
name|val
operator|&=
operator|~
name|TRANS_INTERLACE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|pipeconf_val
operator|&
name|PIPECONF_INTERLACE_MASK
operator|)
operator|==
name|PIPECONF_INTERLACED_ILK
condition|)
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
operator|&&
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_SDVO
argument_list|)
condition|)
name|val
operator||=
name|TRANS_LEGACY_INTERLACED_ILK
expr_stmt|;
else|else
name|val
operator||=
name|TRANS_INTERLACED
expr_stmt|;
else|else
name|val
operator||=
name|TRANS_PROGRESSIVE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator||
name|TRANS_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|TRANS_STATE_ENABLE
argument_list|,
literal|100
argument_list|,
literal|1
argument_list|,
literal|"915trc"
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to enable transcoder %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_disable_transcoder
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* FDI relies on the transcoder */
name|assert_fdi_tx_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|assert_fdi_rx_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* Ports must be off as well */
name|assert_pch_ports_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|TRANSCONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|TRANS_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* wait for PCH transcoder off, transcoder state */
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|TRANS_STATE_ENABLE
operator|)
operator|==
literal|0
argument_list|,
literal|50
argument_list|,
literal|1
argument_list|,
literal|"915trd"
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to disable transcoder %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_enable_pipe - enable a pipe, asserting requirements  * @dev_priv: i915 private structure  * @pipe: pipe to enable  * @pch_port: on ILK+, is this pipe driving a PCH port or not  *  * Enable @pipe, making sure that various hardware specific requirements  * are met, if applicable, e.g. PLL enabled, LVDS pairs enabled, etc.  *  * @pipe should be %PIPE_A or %PIPE_B.  *  * Will wait until the pipe is actually running (i.e. first vblank) before  * returning.  */
end_comment

begin_function
specifier|static
name|void
name|intel_enable_pipe
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|pch_port
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* 	 * A pipe without a PLL won't actually be able to drive bits from 	 * a plane.  On ILK+ the pipe PLLs are integrated, so we don't 	 * need the check. 	 */
if|if
condition|(
operator|!
name|HAS_PCH_SPLIT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
name|assert_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pch_port
condition|)
block|{
comment|/* if driving the PCH, we need FDI enabled */
name|assert_fdi_rx_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|assert_fdi_tx_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: assert CPU port conditions for SNB+ */
block|}
name|reg
operator|=
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PIPECONF_ENABLE
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator||
name|PIPECONF_ENABLE
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_disable_pipe - disable a pipe, asserting requirements  * @dev_priv: i915 private structure  * @pipe: pipe to disable  *  * Disable @pipe, making sure that various hardware specific requirements  * are met, if applicable, e.g. plane disabled, panel fitter off, etc.  *  * @pipe should be %PIPE_A or %PIPE_B.  *  * Will wait until the pipe has shut down before returning.  */
end_comment

begin_function
specifier|static
name|void
name|intel_disable_pipe
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* 	 * Make sure planes won't keep trying to pump pixels to us, 	 * or we might hang the display. 	 */
name|assert_planes_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* Don't disable pipe A or pipe A PLLs if needed */
if|if
condition|(
name|pipe
operator|==
name|PIPE_A
operator|&&
operator|(
name|dev_priv
operator|->
name|quirks
operator|&
name|QUIRK_PIPEA_FORCE
operator|)
condition|)
return|return;
name|reg
operator|=
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PIPECONF_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator|&
operator|~
name|PIPECONF_ENABLE
argument_list|)
expr_stmt|;
name|intel_wait_for_pipe_off
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Plane regs are double buffered, going from enabled->disabled needs a  * trigger in order to latch.  The display address reg provides this.  */
end_comment

begin_function
specifier|static
name|void
name|intel_flush_display_plane
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|plane
name|plane
parameter_list|)
block|{
name|I915_WRITE
argument_list|(
name|DSPADDR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|DSPADDR
argument_list|(
name|plane
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPSURF
argument_list|(
name|plane
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|DSPSURF
argument_list|(
name|plane
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_enable_plane - enable a display plane on a given pipe  * @dev_priv: i915 private structure  * @plane: plane to enable  * @pipe: pipe being fed  *  * Enable @plane on @pipe, making sure that @pipe is running first.  */
end_comment

begin_function
specifier|static
name|void
name|intel_enable_plane
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|plane
name|plane
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* If the pipe isn't enabled, we can't pump pixels and may hang */
name|assert_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator||
name|DISPLAY_PLANE_ENABLE
argument_list|)
expr_stmt|;
name|intel_flush_display_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_disable_plane - disable a display plane  * @dev_priv: i915 private structure  * @plane: plane to disable  * @pipe: pipe consuming the data  *  * Disable @plane; should be an independent operation.  */
end_comment

begin_function
specifier|static
name|void
name|intel_disable_plane
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|plane
name|plane
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator|&
operator|~
name|DISPLAY_PLANE_ENABLE
argument_list|)
expr_stmt|;
name|intel_flush_display_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disable_pch_dp
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|int
name|reg
parameter_list|,
name|u32
name|port_sel
parameter_list|)
block|{
name|u32
name|val
init|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|dp_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|port_sel
argument_list|,
name|val
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Disabling pch dp %x on pipe %d\n"
argument_list|,
name|reg
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator|&
operator|~
name|DP_PORT_EN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|disable_pch_hdmi
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|u32
name|val
init|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|hdmi_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|val
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Disabling pch HDMI %x on pipe %d\n"
argument_list|,
name|reg
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator|&
operator|~
name|PORT_ENABLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Disable any ports connected to this transcoder */
end_comment

begin_function
specifier|static
name|void
name|intel_disable_pch_ports
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_PP_CONTROL
argument_list|,
name|val
operator||
name|PANEL_UNLOCK_REGS
argument_list|)
expr_stmt|;
name|disable_pch_dp
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_B
argument_list|,
name|TRANS_DP_PORT_SEL_B
argument_list|)
expr_stmt|;
name|disable_pch_dp
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_C
argument_list|,
name|TRANS_DP_PORT_SEL_C
argument_list|)
expr_stmt|;
name|disable_pch_dp
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_D
argument_list|,
name|TRANS_DP_PORT_SEL_D
argument_list|)
expr_stmt|;
name|reg
operator|=
name|PCH_ADPA
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|adpa_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|val
argument_list|,
name|pipe
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator|&
operator|~
name|ADPA_DAC_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|PCH_LVDS
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvds_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|val
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"disable lvds on pipe %d val 0x%08x\n"
argument_list|,
name|pipe
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator|&
operator|~
name|LVDS_PORT_EN
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|disable_pch_hdmi
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMIB
argument_list|)
expr_stmt|;
name|disable_pch_hdmi
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMIC
argument_list|)
expr_stmt|;
name|disable_pch_hdmi
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMID
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i8xx_disable_fbc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|fbc_ctl
decl_stmt|;
comment|/* Disable compression */
name|fbc_ctl
operator|=
name|I915_READ
argument_list|(
name|FBC_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fbc_ctl
operator|&
name|FBC_CTL_EN
operator|)
operator|==
literal|0
condition|)
return|return;
name|fbc_ctl
operator|&=
operator|~
name|FBC_CTL_EN
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FBC_CONTROL
argument_list|,
name|fbc_ctl
argument_list|)
expr_stmt|;
comment|/* Wait for compressing bit to clear */
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|FBC_STATUS
argument_list|)
operator|&
name|FBC_STAT_COMPRESSING
operator|)
operator|==
literal|0
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|,
literal|"915fbd"
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"FBC idle timed out\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabled FBC\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i8xx_enable_fbc
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|unsigned
name|long
name|interval
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
init|=
name|crtc
operator|->
name|fb
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
init|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|intel_fb
operator|->
name|obj
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|cfb_pitch
decl_stmt|;
name|int
name|plane
decl_stmt|,
name|i
decl_stmt|;
name|u32
name|fbc_ctl
decl_stmt|,
name|fbc_ctl2
decl_stmt|;
name|cfb_pitch
operator|=
name|dev_priv
operator|->
name|cfb_size
operator|/
name|FBC_LL_SIZE
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|<
name|cfb_pitch
condition|)
name|cfb_pitch
operator|=
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
expr_stmt|;
comment|/* FBC_CTL wants 64B units */
name|cfb_pitch
operator|=
operator|(
name|cfb_pitch
operator|/
literal|64
operator|)
operator|-
literal|1
expr_stmt|;
name|plane
operator|=
name|intel_crtc
operator|->
name|plane
operator|==
literal|0
condition|?
name|FBC_CTL_PLANEA
else|:
name|FBC_CTL_PLANEB
expr_stmt|;
comment|/* Clear old tags */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|FBC_LL_SIZE
operator|/
literal|32
operator|)
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|FBC_TAG
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set it up... */
name|fbc_ctl2
operator|=
name|FBC_CTL_FENCE_DBL
operator||
name|FBC_CTL_IDLE_IMM
operator||
name|FBC_CTL_CPU_FENCE
expr_stmt|;
name|fbc_ctl2
operator||=
name|plane
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FBC_CONTROL2
argument_list|,
name|fbc_ctl2
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FBC_FENCE_OFF
argument_list|,
name|crtc
operator|->
name|y
argument_list|)
expr_stmt|;
comment|/* enable it... */
name|fbc_ctl
operator|=
name|FBC_CTL_EN
operator||
name|FBC_CTL_PERIODIC
expr_stmt|;
if|if
condition|(
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
condition|)
name|fbc_ctl
operator||=
name|FBC_CTL_C3_IDLE
expr_stmt|;
comment|/* 945 needs special SR handling */
name|fbc_ctl
operator||=
operator|(
name|cfb_pitch
operator|&
literal|0xff
operator|)
operator|<<
name|FBC_CTL_STRIDE_SHIFT
expr_stmt|;
name|fbc_ctl
operator||=
operator|(
name|interval
operator|&
literal|0x2fff
operator|)
operator|<<
name|FBC_CTL_INTERVAL_SHIFT
expr_stmt|;
name|fbc_ctl
operator||=
name|obj
operator|->
name|fence_reg
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FBC_CONTROL
argument_list|,
name|fbc_ctl
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"enabled FBC, pitch %d, yoff %d, plane %d, "
argument_list|,
name|cfb_pitch
argument_list|,
name|crtc
operator|->
name|y
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|i8xx_fbc_enabled
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
name|I915_READ
argument_list|(
name|FBC_CONTROL
argument_list|)
operator|&
name|FBC_CTL_EN
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g4x_enable_fbc
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|unsigned
name|long
name|interval
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
init|=
name|crtc
operator|->
name|fb
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
init|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|intel_fb
operator|->
name|obj
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
operator|==
literal|0
condition|?
name|DPFC_CTL_PLANEA
else|:
name|DPFC_CTL_PLANEB
decl_stmt|;
name|unsigned
name|long
name|stall_watermark
init|=
literal|200
decl_stmt|;
name|u32
name|dpfc_ctl
decl_stmt|;
name|dpfc_ctl
operator|=
name|plane
operator||
name|DPFC_SR_EN
operator||
name|DPFC_CTL_LIMIT_1X
expr_stmt|;
name|dpfc_ctl
operator||=
name|DPFC_CTL_FENCE_EN
operator||
name|obj
operator|->
name|fence_reg
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPFC_CHICKEN
argument_list|,
name|DPFC_HT_MODIFY
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPFC_RECOMP_CTL
argument_list|,
name|DPFC_RECOMP_STALL_EN
operator||
operator|(
name|stall_watermark
operator|<<
name|DPFC_RECOMP_STALL_WM_SHIFT
operator|)
operator||
operator|(
name|interval
operator|<<
name|DPFC_RECOMP_TIMER_COUNT_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPFC_FENCE_YOFF
argument_list|,
name|crtc
operator|->
name|y
argument_list|)
expr_stmt|;
comment|/* enable it... */
name|I915_WRITE
argument_list|(
name|DPFC_CONTROL
argument_list|,
name|I915_READ
argument_list|(
name|DPFC_CONTROL
argument_list|)
operator||
name|DPFC_CTL_EN
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"enabled fbc on plane %d\n"
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g4x_disable_fbc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|dpfc_ctl
decl_stmt|;
comment|/* Disable compression */
name|dpfc_ctl
operator|=
name|I915_READ
argument_list|(
name|DPFC_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpfc_ctl
operator|&
name|DPFC_CTL_EN
condition|)
block|{
name|dpfc_ctl
operator|&=
operator|~
name|DPFC_CTL_EN
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPFC_CONTROL
argument_list|,
name|dpfc_ctl
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabled FBC\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|g4x_fbc_enabled
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
name|I915_READ
argument_list|(
name|DPFC_CONTROL
argument_list|)
operator|&
name|DPFC_CTL_EN
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sandybridge_blit_fbc_update
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|blt_ecoskpd
decl_stmt|;
comment|/* Make sure blitter notifies FBC of writes */
name|gen6_gt_force_wake_get
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|blt_ecoskpd
operator|=
name|I915_READ
argument_list|(
name|GEN6_BLITTER_ECOSKPD
argument_list|)
expr_stmt|;
name|blt_ecoskpd
operator||=
name|GEN6_BLITTER_FBC_NOTIFY
operator|<<
name|GEN6_BLITTER_LOCK_SHIFT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_BLITTER_ECOSKPD
argument_list|,
name|blt_ecoskpd
argument_list|)
expr_stmt|;
name|blt_ecoskpd
operator||=
name|GEN6_BLITTER_FBC_NOTIFY
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_BLITTER_ECOSKPD
argument_list|,
name|blt_ecoskpd
argument_list|)
expr_stmt|;
name|blt_ecoskpd
operator|&=
operator|~
operator|(
name|GEN6_BLITTER_FBC_NOTIFY
operator|<<
name|GEN6_BLITTER_LOCK_SHIFT
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_BLITTER_ECOSKPD
argument_list|,
name|blt_ecoskpd
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|GEN6_BLITTER_ECOSKPD
argument_list|)
expr_stmt|;
name|gen6_gt_force_wake_put
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_enable_fbc
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|unsigned
name|long
name|interval
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
init|=
name|crtc
operator|->
name|fb
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
init|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|intel_fb
operator|->
name|obj
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
operator|==
literal|0
condition|?
name|DPFC_CTL_PLANEA
else|:
name|DPFC_CTL_PLANEB
decl_stmt|;
name|unsigned
name|long
name|stall_watermark
init|=
literal|200
decl_stmt|;
name|u32
name|dpfc_ctl
decl_stmt|;
name|dpfc_ctl
operator|=
name|I915_READ
argument_list|(
name|ILK_DPFC_CONTROL
argument_list|)
expr_stmt|;
name|dpfc_ctl
operator|&=
name|DPFC_RESERVED
expr_stmt|;
name|dpfc_ctl
operator||=
operator|(
name|plane
operator||
name|DPFC_CTL_LIMIT_1X
operator|)
expr_stmt|;
comment|/* Set persistent mode for front-buffer rendering, ala X. */
name|dpfc_ctl
operator||=
name|DPFC_CTL_PERSISTENT_MODE
expr_stmt|;
name|dpfc_ctl
operator||=
operator|(
name|DPFC_CTL_FENCE_EN
operator||
name|obj
operator|->
name|fence_reg
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DPFC_CHICKEN
argument_list|,
name|DPFC_HT_MODIFY
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DPFC_RECOMP_CTL
argument_list|,
name|DPFC_RECOMP_STALL_EN
operator||
operator|(
name|stall_watermark
operator|<<
name|DPFC_RECOMP_STALL_WM_SHIFT
operator|)
operator||
operator|(
name|interval
operator|<<
name|DPFC_RECOMP_TIMER_COUNT_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DPFC_FENCE_YOFF
argument_list|,
name|crtc
operator|->
name|y
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_FBC_RT_BASE
argument_list|,
name|obj
operator|->
name|gtt_offset
operator||
name|ILK_FBC_RT_VALID
argument_list|)
expr_stmt|;
comment|/* enable it... */
name|I915_WRITE
argument_list|(
name|ILK_DPFC_CONTROL
argument_list|,
name|dpfc_ctl
operator||
name|DPFC_CTL_EN
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|SNB_DPFC_CTL_SA
argument_list|,
name|SNB_CPU_FENCE_ENABLE
operator||
name|obj
operator|->
name|fence_reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPFC_CPU_FENCE_OFFSET
argument_list|,
name|crtc
operator|->
name|y
argument_list|)
expr_stmt|;
name|sandybridge_blit_fbc_update
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"enabled fbc on plane %d\n"
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_disable_fbc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|dpfc_ctl
decl_stmt|;
comment|/* Disable compression */
name|dpfc_ctl
operator|=
name|I915_READ
argument_list|(
name|ILK_DPFC_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpfc_ctl
operator|&
name|DPFC_CTL_EN
condition|)
block|{
name|dpfc_ctl
operator|&=
operator|~
name|DPFC_CTL_EN
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DPFC_CONTROL
argument_list|,
name|dpfc_ctl
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabled FBC\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|ironlake_fbc_enabled
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
name|I915_READ
argument_list|(
name|ILK_DPFC_CONTROL
argument_list|)
operator|&
name|DPFC_CTL_EN
return|;
block|}
end_function

begin_function
name|bool
name|intel_fbc_enabled
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|display
operator|.
name|fbc_enabled
condition|)
return|return
name|false
return|;
return|return
name|dev_priv
operator|->
name|display
operator|.
name|fbc_enabled
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_fbc_work_fn
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|intel_fbc_work
modifier|*
name|work
init|=
name|arg
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|work
operator|->
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|dev_priv
operator|->
name|fbc_work
condition|)
block|{
comment|/* Double check that we haven't switched fb without cancelling 		 * the prior work. 		 */
if|if
condition|(
name|work
operator|->
name|crtc
operator|->
name|fb
operator|==
name|work
operator|->
name|fb
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|enable_fbc
argument_list|(
name|work
operator|->
name|crtc
argument_list|,
name|work
operator|->
name|interval
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|cfb_plane
operator|=
name|to_intel_crtc
argument_list|(
name|work
operator|->
name|crtc
argument_list|)
operator|->
name|plane
expr_stmt|;
name|dev_priv
operator|->
name|cfb_fb
operator|=
name|work
operator|->
name|crtc
operator|->
name|fb
operator|->
name|base
operator|.
name|id
expr_stmt|;
name|dev_priv
operator|->
name|cfb_y
operator|=
name|work
operator|->
name|crtc
operator|->
name|y
expr_stmt|;
block|}
name|dev_priv
operator|->
name|fbc_work
operator|=
name|NULL
expr_stmt|;
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_cancel_fbc_work
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u_int
name|pending
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|fbc_work
operator|==
name|NULL
condition|)
return|return;
name|DRM_DEBUG_KMS
argument_list|(
literal|"cancelling pending FBC enable\n"
argument_list|)
expr_stmt|;
comment|/* Synchronisation is provided by struct_mutex and checking of 	 * dev_priv->fbc_work, so we can perform the cancellation 	 * entirely asynchronously. 	 */
if|if
condition|(
name|taskqueue_cancel_timeout
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|fbc_work
operator|->
name|task
argument_list|,
operator|&
name|pending
argument_list|)
operator|==
literal|0
condition|)
comment|/* tasklet was killed before being run, clean up */
name|free
argument_list|(
name|dev_priv
operator|->
name|fbc_work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
comment|/* Mark the work as no longer wanted so that if it does 	 * wake-up (because the work was already running and waiting 	 * for our mutex), it will discover that is no longer 	 * necessary to run. 	 */
name|dev_priv
operator|->
name|fbc_work
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_enable_fbc
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|unsigned
name|long
name|interval
parameter_list|)
block|{
name|struct
name|intel_fbc_work
modifier|*
name|work
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|display
operator|.
name|enable_fbc
condition|)
return|return;
name|intel_cancel_fbc_work
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|work
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|work
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|work
operator|->
name|crtc
operator|=
name|crtc
expr_stmt|;
name|work
operator|->
name|fb
operator|=
name|crtc
operator|->
name|fb
expr_stmt|;
name|work
operator|->
name|interval
operator|=
name|interval
expr_stmt|;
name|TIMEOUT_TASK_INIT
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|work
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|intel_fbc_work_fn
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|fbc_work
operator|=
name|work
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"scheduling delayed FBC enable\n"
argument_list|)
expr_stmt|;
comment|/* Delay the actual enabling to let pageflipping cease and the 	 * display to settle before starting the compression. Note that 	 * this delay also serves a second purpose: it allows for a 	 * vblank to pass after disabling the FBC before we attempt 	 * to modify the control registers. 	 * 	 * A more complicated solution would involve tracking vblanks 	 * following the termination of the page-flipping sequence 	 * and indeed performing the enable as a co-routine and not 	 * waiting synchronously upon the vblank. 	 */
name|taskqueue_enqueue_timeout
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|work
operator|->
name|task
argument_list|,
name|msecs_to_jiffies
argument_list|(
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_disable_fbc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|intel_cancel_fbc_work
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|display
operator|.
name|disable_fbc
condition|)
return|return;
name|dev_priv
operator|->
name|display
operator|.
name|disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|cfb_plane
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_update_fbc - enable/disable FBC as needed  * @dev: the drm_device  *  * Set up the framebuffer compression hardware at mode set time.  We  * enable it if possible:  *   - plane A only (on pre-965)  *   - no pixel mulitply/line duplication  *   - no alpha buffer discard  *   - no dual wide  *   - framebuffer<= 2048 in width, 1536 in height  *  * We can't assume that any compression will take place (worst case),  * so the compressed buffer has to be the same size as the uncompressed  * one.  It also must reside (along with the line length buffer) in  * stolen memory.  *  * We need to enable/disable FBC on a global basis.  */
end_comment

begin_function
specifier|static
name|void
name|intel_update_fbc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmp_crtc
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|enable_fbc
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i915_powersave
condition|)
return|return;
if|if
condition|(
operator|!
name|I915_HAS_FBC
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
comment|/* 	 * If FBC is already on, we just have to verify that we can 	 * keep it that way... 	 * Need to disable if: 	 *   - more than one pipe is active 	 *   - changing FBC params (stride, fence, mode) 	 *   - new fb is too large to fit in compressed buffer 	 *   - going to an unsupported config (interlace, pixel multiply, etc.) 	 */
name|list_for_each_entry
argument_list|(
argument|tmp_crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|tmp_crtc
operator|->
name|enabled
operator|&&
name|tmp_crtc
operator|->
name|fb
condition|)
block|{
if|if
condition|(
name|crtc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"more than one pipe active, disabling compression\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_MULTIPLE_PIPES
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
name|crtc
operator|=
name|tmp_crtc
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|crtc
operator|||
name|crtc
operator|->
name|fb
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"no output, disabling\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_NO_OUTPUT
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|fb
operator|=
name|crtc
operator|->
name|fb
expr_stmt|;
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|obj
operator|=
name|intel_fb
operator|->
name|obj
expr_stmt|;
name|enable_fbc
operator|=
name|i915_enable_fbc
expr_stmt|;
if|if
condition|(
name|enable_fbc
operator|<
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"fbc set to per-chip default\n"
argument_list|)
expr_stmt|;
name|enable_fbc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<=
literal|6
condition|)
name|enable_fbc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|enable_fbc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"fbc disabled per module param\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_MODULE_PARAM
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
if|if
condition|(
name|intel_fb
operator|->
name|obj
operator|->
name|base
operator|.
name|size
operator|>
name|dev_priv
operator|->
name|cfb_size
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"framebuffer too large, disabling "
literal|"compression\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_STOLEN_TOO_SMALL
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
if|if
condition|(
operator|(
name|crtc
operator|->
name|mode
operator|.
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
operator|)
operator|||
operator|(
name|crtc
operator|->
name|mode
operator|.
name|flags
operator|&
name|DRM_MODE_FLAG_DBLSCAN
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"mode incompatible with compression, "
literal|"disabling\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_UNSUPPORTED_MODE
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
if|if
condition|(
operator|(
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
operator|>
literal|2048
operator|)
operator|||
operator|(
name|crtc
operator|->
name|mode
operator|.
name|vdisplay
operator|>
literal|1536
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"mode too large for compression, disabling\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_MODE_TOO_LARGE
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
if|if
condition|(
operator|(
name|IS_I915GM
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
name|intel_crtc
operator|->
name|plane
operator|!=
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"plane not 0, disabling compression\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_BAD_PLANE
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_X
operator|||
name|obj
operator|->
name|fence_reg
operator|==
name|I915_FENCE_REG_NONE
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"framebuffer not tiled or fenced, disabling compression\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_NOT_TILED
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
comment|/* If the kernel debugger is active, always disable compression */
if|if
condition|(
name|kdb_active
condition|)
goto|goto
name|out_disable
goto|;
comment|/* If the scanout has not changed, don't modify the FBC settings. 	 * Note that we make the fundamental assumption that the fb->obj 	 * cannot be unpinned (and have its GTT offset and fence revoked) 	 * without first being decoupled from the scanout and FBC disabled. 	 */
if|if
condition|(
name|dev_priv
operator|->
name|cfb_plane
operator|==
name|intel_crtc
operator|->
name|plane
operator|&&
name|dev_priv
operator|->
name|cfb_fb
operator|==
name|fb
operator|->
name|base
operator|.
name|id
operator|&&
name|dev_priv
operator|->
name|cfb_y
operator|==
name|crtc
operator|->
name|y
condition|)
return|return;
if|if
condition|(
name|intel_fbc_enabled
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* We update FBC along two paths, after changing fb/crtc 		 * configuration (modeswitching) and after page-flipping 		 * finishes. For the latter, we know that not only did 		 * we disable the FBC at the start of the page-flip 		 * sequence, but also more than one vblank has passed. 		 * 		 * For the former case of modeswitching, it is possible 		 * to switch between two FBC valid configurations 		 * instantaneously so we do need to disable the FBC 		 * before we can modify its control registers. We also 		 * have to wait for the next vblank for that to take 		 * effect. However, since we delay enabling FBC we can 		 * assume that a vblank has passed since disabling and 		 * that we can safely alter the registers in the deferred 		 * callback. 		 * 		 * In the scenario that we go from a valid to invalid 		 * and then back to valid FBC configuration we have 		 * no strict enforcement that a vblank occurred since 		 * disabling the FBC. However, along all current pipe 		 * disabling paths we do need to wait for a vblank at 		 * some point. And we wait before enabling FBC anyway. 		 */
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabling active FBC for update\n"
argument_list|)
expr_stmt|;
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|intel_enable_fbc
argument_list|(
name|crtc
argument_list|,
literal|500
argument_list|)
expr_stmt|;
return|return;
name|out_disable
label|:
comment|/* Multiple disables should be harmless */
if|if
condition|(
name|intel_fbc_enabled
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"unsupported config, disabling FBC\n"
argument_list|)
expr_stmt|;
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|intel_pin_and_fence_fb_obj
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|pipelined
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|alignment
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|alignment
operator|=
literal|0
expr_stmt|;
comment|/* shut gcc */
switch|switch
condition|(
name|obj
operator|->
name|tiling_mode
condition|)
block|{
case|case
name|I915_TILING_NONE
case|:
if|if
condition|(
name|IS_BROADWATER
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_CRESTLINE
argument_list|(
name|dev
argument_list|)
condition|)
name|alignment
operator|=
literal|128
operator|*
literal|1024
expr_stmt|;
elseif|else
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
name|alignment
operator|=
literal|4
operator|*
literal|1024
expr_stmt|;
else|else
name|alignment
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
break|break;
case|case
name|I915_TILING_X
case|:
comment|/* pin() will align the object as required by fence */
name|alignment
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|I915_TILING_Y
case|:
comment|/* FIXME: Is this true? */
name|DRM_ERROR
argument_list|(
literal|"Y tiled not allowed for scan out buffers\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
default|default:
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"Wrong tiling for fb obj"
operator|)
argument_list|)
expr_stmt|;
block|}
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|false
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_pin_to_display_plane
argument_list|(
name|obj
argument_list|,
name|alignment
argument_list|,
name|pipelined
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_interruptible
goto|;
comment|/* Install a fence for tiled scan-out. Pre-i965 always needs a 	 * fence, whereas 965+ only requires a fence if using 	 * framebuffer compression.  For simplicity, we always install 	 * a fence as the cost is not that onerous. 	 */
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_get_fence
argument_list|(
name|obj
argument_list|,
name|pipelined
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin
goto|;
name|i915_gem_object_pin_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin
label|:
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|err_interruptible
label|:
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|true
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|intel_unpin_fb_obj
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|i915_gem_object_unpin_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i9xx_update_plane
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|unsigned
name|long
name|Start
decl_stmt|,
name|Offset
decl_stmt|;
name|u32
name|dspcntr
decl_stmt|;
name|u32
name|reg
decl_stmt|;
switch|switch
condition|(
name|plane
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Can't update plane %d in SAREA\n"
argument_list|,
name|plane
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|obj
operator|=
name|intel_fb
operator|->
name|obj
expr_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|dspcntr
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* Mask out pixel format bits in case we change it */
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_PIXFORMAT_MASK
expr_stmt|;
switch|switch
condition|(
name|fb
operator|->
name|bits_per_pixel
condition|)
block|{
case|case
literal|8
case|:
name|dspcntr
operator||=
name|DISPPLANE_8BPP
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|fb
operator|->
name|depth
operator|==
literal|15
condition|)
name|dspcntr
operator||=
name|DISPPLANE_15_16BPP
expr_stmt|;
else|else
name|dspcntr
operator||=
name|DISPPLANE_16BPP
expr_stmt|;
break|break;
case|case
literal|24
case|:
case|case
literal|32
case|:
name|dspcntr
operator||=
name|DISPPLANE_32BPP_NO_ALPHA
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown color depth %d\n"
argument_list|,
name|fb
operator|->
name|bits_per_pixel
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
condition|)
name|dspcntr
operator||=
name|DISPPLANE_TILED
expr_stmt|;
else|else
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_TILED
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|dspcntr
argument_list|)
expr_stmt|;
name|Start
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
name|Offset
operator|=
name|y
operator|*
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|+
name|x
operator|*
operator|(
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
operator|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Writing base %08lX %08lX %d %d %d\n"
argument_list|,
name|Start
argument_list|,
name|Offset
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPSTRIDE
argument_list|(
name|plane
argument_list|)
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|I915_WRITE
argument_list|(
name|DSPSURF
argument_list|(
name|plane
argument_list|)
argument_list|,
name|Start
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPTILEOFF
argument_list|(
name|plane
argument_list|)
argument_list|,
operator|(
name|y
operator|<<
literal|16
operator|)
operator||
name|x
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPADDR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|Offset
argument_list|)
expr_stmt|;
block|}
else|else
name|I915_WRITE
argument_list|(
name|DSPADDR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|Start
operator|+
name|Offset
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ironlake_update_plane
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|unsigned
name|long
name|Start
decl_stmt|,
name|Offset
decl_stmt|;
name|u32
name|dspcntr
decl_stmt|;
name|u32
name|reg
decl_stmt|;
switch|switch
condition|(
name|plane
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Can't update plane %d in SAREA\n"
argument_list|,
name|plane
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|obj
operator|=
name|intel_fb
operator|->
name|obj
expr_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|dspcntr
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* Mask out pixel format bits in case we change it */
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_PIXFORMAT_MASK
expr_stmt|;
switch|switch
condition|(
name|fb
operator|->
name|bits_per_pixel
condition|)
block|{
case|case
literal|8
case|:
name|dspcntr
operator||=
name|DISPPLANE_8BPP
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|fb
operator|->
name|depth
operator|!=
literal|16
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"bpp 16, depth %d\n"
argument_list|,
name|fb
operator|->
name|depth
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|dspcntr
operator||=
name|DISPPLANE_16BPP
expr_stmt|;
break|break;
case|case
literal|24
case|:
case|case
literal|32
case|:
if|if
condition|(
name|fb
operator|->
name|depth
operator|==
literal|24
condition|)
name|dspcntr
operator||=
name|DISPPLANE_32BPP_NO_ALPHA
expr_stmt|;
elseif|else
if|if
condition|(
name|fb
operator|->
name|depth
operator|==
literal|30
condition|)
name|dspcntr
operator||=
name|DISPPLANE_32BPP_30BIT_NO_ALPHA
expr_stmt|;
else|else
block|{
name|DRM_ERROR
argument_list|(
literal|"bpp %d depth %d\n"
argument_list|,
name|fb
operator|->
name|bits_per_pixel
argument_list|,
name|fb
operator|->
name|depth
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown color depth %d\n"
argument_list|,
name|fb
operator|->
name|bits_per_pixel
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
condition|)
name|dspcntr
operator||=
name|DISPPLANE_TILED
expr_stmt|;
else|else
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_TILED
expr_stmt|;
comment|/* must disable */
name|dspcntr
operator||=
name|DISPPLANE_TRICKLE_FEED_DISABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|dspcntr
argument_list|)
expr_stmt|;
name|Start
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
name|Offset
operator|=
name|y
operator|*
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|+
name|x
operator|*
operator|(
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
operator|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Writing base %08lX %08lX %d %d %d\n"
argument_list|,
name|Start
argument_list|,
name|Offset
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPSTRIDE
argument_list|(
name|plane
argument_list|)
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPSURF
argument_list|(
name|plane
argument_list|)
argument_list|,
name|Start
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPTILEOFF
argument_list|(
name|plane
argument_list|)
argument_list|,
operator|(
name|y
operator|<<
literal|16
operator|)
operator||
name|x
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPADDR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|Offset
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Assume fb object is pinned& idle& fenced and just update base pointers */
end_comment

begin_function
specifier|static
name|int
name|intel_pipe_set_base_atomic
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|enum
name|mode_set_atomic
name|state
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|dev_priv
operator|->
name|display
operator|.
name|update_plane
argument_list|(
name|crtc
argument_list|,
name|fb
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_increase_pllclock
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_finish_fb
parameter_list|(
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|to_intel_framebuffer
argument_list|(
name|old_fb
argument_list|)
operator|->
name|obj
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|bool
name|was_interruptible
init|=
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|atomic_read
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
operator|&&
name|atomic_read
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msleep
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|,
operator|&
name|dev
operator|->
name|event_lock
argument_list|,
literal|0
argument_list|,
literal|"915flp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
comment|/* Big Hammer, we also need to ensure that any pending 	 * MI_WAIT_FOR_EVENT inside a user batch buffer on the 	 * current scanout is retired before unpinning the old 	 * framebuffer. 	 * 	 * This should only fail upon a hung GPU, in which case we 	 * can safely continue. 	 */
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|false
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_finish_gpu
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|was_interruptible
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_pipe_set_base
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
if|#
directive|if
literal|0
block|struct drm_i915_master_private *master_priv;
else|#
directive|else
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
endif|#
directive|endif
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* no fb bound */
if|if
condition|(
operator|!
name|crtc
operator|->
name|fb
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"No FB bound\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|intel_crtc
operator|->
name|plane
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
break|break;
comment|/* fall through otherwise */
default|default:
name|DRM_ERROR
argument_list|(
literal|"no plane for crtc\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
operator|->
name|obj
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"pin& fence failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|old_fb
condition|)
name|intel_finish_fb
argument_list|(
name|old_fb
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_pipe_set_base_atomic
argument_list|(
name|crtc
argument_list|,
name|crtc
operator|->
name|fb
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|LEAVE_ATOMIC_MODE_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|intel_unpin_fb_obj
argument_list|(
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
operator|->
name|obj
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"failed to update base address\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|old_fb
condition|)
block|{
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|intel_unpin_fb_obj
argument_list|(
name|to_intel_framebuffer
argument_list|(
name|old_fb
argument_list|)
operator|->
name|obj
argument_list|)
expr_stmt|;
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (!dev->primary->master) 		return 0;  	master_priv = dev->primary->master->driver_priv; 	if (!master_priv->sarea_priv) 		return 0;  	if (intel_crtc->pipe) { 		master_priv->sarea_priv->pipeB_x = x; 		master_priv->sarea_priv->pipeB_y = y; 	} else { 		master_priv->sarea_priv->pipeA_x = x; 		master_priv->sarea_priv->pipeA_y = y; 	}
else|#
directive|else
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|sarea_priv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|intel_crtc
operator|->
name|pipe
condition|)
block|{
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeB_x
operator|=
name|x
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeB_y
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeA_x
operator|=
name|x
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeA_y
operator|=
name|y
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_set_pll_edp
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|dpa_ctl
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"eDP PLL enable for clock %d\n"
argument_list|,
name|clock
argument_list|)
expr_stmt|;
name|dpa_ctl
operator|=
name|I915_READ
argument_list|(
name|DP_A
argument_list|)
expr_stmt|;
name|dpa_ctl
operator|&=
operator|~
name|DP_PLL_FREQ_MASK
expr_stmt|;
if|if
condition|(
name|clock
operator|<
literal|200000
condition|)
block|{
name|u32
name|temp
decl_stmt|;
name|dpa_ctl
operator||=
name|DP_PLL_FREQ_160MHZ
expr_stmt|;
comment|/* workaround for 160Mhz: 		   1) program 0x4600c bits 15:0 = 0x8124 		   2) program 0x46010 bit 0 = 1 		   3) program 0x46034 bit 24 = 1 		   4) program 0x64000 bit 14 = 1 		   */
name|temp
operator|=
name|I915_READ
argument_list|(
literal|0x4600c
argument_list|)
expr_stmt|;
name|temp
operator|&=
literal|0xffff0000
expr_stmt|;
name|I915_WRITE
argument_list|(
literal|0x4600c
argument_list|,
name|temp
operator||
literal|0x8124
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
literal|0x46010
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
literal|0x46010
argument_list|,
name|temp
operator||
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
literal|0x46034
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
literal|0x46034
argument_list|,
name|temp
operator||
operator|(
literal|1
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dpa_ctl
operator||=
name|DP_PLL_FREQ_270MHZ
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|DP_A
argument_list|,
name|dpa_ctl
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DP_A
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_fdi_normal_train
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
comment|/* enable normal train */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE_IVB
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_NONE_IVB
operator||
name|FDI_TX_ENHANCE_FRAME_ENABLE
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_NONE
operator||
name|FDI_TX_ENHANCE_FRAME_ENABLE
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_NORMAL_CPT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_ENHANCE_FRAME_ENABLE
argument_list|)
expr_stmt|;
comment|/* wait one idle pattern time */
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* IVB wants error correction enabled */
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator||
name|FDI_FS_ERRC_ENABLE
operator||
name|FDI_FE_ERRC_ENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cpt_phase_pointer_enable
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|flags
init|=
name|I915_READ
argument_list|(
name|SOUTH_CHICKEN1
argument_list|)
decl_stmt|;
name|flags
operator||=
name|FDI_PHASE_SYNC_OVR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SOUTH_CHICKEN1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* once to unlock... */
name|flags
operator||=
name|FDI_PHASE_SYNC_EN
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SOUTH_CHICKEN1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* then again to enable */
name|POSTING_READ
argument_list|(
name|SOUTH_CHICKEN1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The FDI link training functions for ILK/Ibexpeak. */
end_comment

begin_function
specifier|static
name|void
name|ironlake_fdi_link_train
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|,
name|tries
decl_stmt|;
comment|/* FDI needs bits from pipe& plane first */
name|assert_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|assert_plane_enabled
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|)
expr_stmt|;
comment|/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit 	   for train result */
name|reg
operator|=
name|FDI_RX_IMR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_SYMBOL_LOCK
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_BIT_LOCK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* enable CPU FDI TX and PCH FDI RX */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|19
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|-
literal|1
operator|)
operator|<<
literal|19
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_TX_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* Ironlake workaround, enable clock pointer after FDI enable*/
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|FDI_RX_CHICKEN
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|FDI_RX_PHASE_SYNC_POINTER_OVR
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FDI_RX_CHICKEN
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|FDI_RX_PHASE_SYNC_POINTER_OVR
operator||
name|FDI_RX_PHASE_SYNC_POINTER_EN
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
literal|5
condition|;
name|tries
operator|++
control|)
block|{
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|&
name|FDI_RX_BIT_LOCK
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 1 done.\n"
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_BIT_LOCK
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tries
operator|==
literal|5
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 1 fail!\n"
argument_list|)
expr_stmt|;
comment|/* Train 2 */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
literal|5
condition|;
name|tries
operator|++
control|)
block|{
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_SYMBOL_LOCK
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_SYMBOL_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 2 done.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tries
operator|==
literal|5
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 2 fail!\n"
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train done\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|int
name|snb_b_fdi_train_param
index|[]
init|=
block|{
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
block|,
name|FDI_LINK_TRAIN_400MV_6DB_SNB_B
block|,
name|FDI_LINK_TRAIN_600MV_3_5DB_SNB_B
block|,
name|FDI_LINK_TRAIN_800MV_0DB_SNB_B
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The FDI link training functions for SNB/Cougarpoint. */
end_comment

begin_function
specifier|static
name|void
name|gen6_fdi_link_train
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|,
name|i
decl_stmt|;
comment|/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit 	   for train result */
name|reg
operator|=
name|FDI_RX_IMR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_SYMBOL_LOCK
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_BIT_LOCK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* enable CPU FDI TX and PCH FDI RX */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|19
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|-
literal|1
operator|)
operator|<<
literal|19
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
comment|/* SNB-B */
name|temp
operator||=
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_TX_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1_CPT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
name|cpt_phase_pointer_enable
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|snb_b_fdi_train_param
index|[
name|i
index|]
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_BIT_LOCK
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_BIT_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 1 done.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 1 fail!\n"
argument_list|)
expr_stmt|;
comment|/* Train 2 */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2
expr_stmt|;
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
comment|/* SNB-B */
name|temp
operator||=
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2_CPT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|snb_b_fdi_train_param
index|[
name|i
index|]
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_SYMBOL_LOCK
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_SYMBOL_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 2 done.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 2 fail!\n"
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Manual link training for Ivy Bridge A0 parts */
end_comment

begin_function
specifier|static
name|void
name|ivb_manual_fdi_link_train
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|,
name|i
decl_stmt|;
comment|/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit 	   for train result */
name|reg
operator|=
name|FDI_RX_IMR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_SYMBOL_LOCK
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_BIT_LOCK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* enable CPU FDI TX and PCH FDI RX */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|19
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|-
literal|1
operator|)
operator|<<
literal|19
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|FDI_LINK_TRAIN_AUTO
operator||
name|FDI_LINK_TRAIN_NONE_IVB
operator|)
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1_IVB
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
expr_stmt|;
name|temp
operator||=
name|FDI_COMPOSITE_SYNC
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_TX_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_AUTO
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_COMPOSITE_SYNC
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|snb_b_fdi_train_param
index|[
name|i
index|]
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_BIT_LOCK
operator|||
operator|(
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|FDI_RX_BIT_LOCK
operator|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_BIT_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 1 done.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 1 fail!\n"
argument_list|)
expr_stmt|;
comment|/* Train 2 */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE_IVB
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2_IVB
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2_CPT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|snb_b_fdi_train_param
index|[
name|i
index|]
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_SYMBOL_LOCK
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_SYMBOL_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 2 done.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 2 fail!\n"
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_fdi_pll_enable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
comment|/* Write the TU size bits so error detection works */
name|I915_WRITE
argument_list|(
name|FDI_RX_TUSIZE1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|PIPE_DATA_M1
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|TU_SIZE_MASK
argument_list|)
expr_stmt|;
comment|/* enable PCH FDI RX PLL, wait warmup plus DMI latency */
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
operator|(
literal|0x7
operator|<<
literal|19
operator|)
operator||
operator|(
literal|0x7
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|-
literal|1
operator|)
operator|<<
literal|19
expr_stmt|;
name|temp
operator||=
operator|(
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|PIPE_BPC_MASK
operator|)
operator|<<
literal|11
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_PLL_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Switch from Rawclk to PCDclk */
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_PCDCLK
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Enable CPU FDI TX PLL, always on for Ironlake */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|&
name|FDI_TX_PLL_ENABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_TX_PLL_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cpt_phase_pointer_disable
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|flags
init|=
name|I915_READ
argument_list|(
name|SOUTH_CHICKEN1
argument_list|)
decl_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|FDI_PHASE_SYNC_EN
argument_list|(
name|pipe
argument_list|)
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SOUTH_CHICKEN1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* once to disable... */
name|flags
operator|&=
operator|~
operator|(
name|FDI_PHASE_SYNC_OVR
argument_list|(
name|pipe
argument_list|)
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SOUTH_CHICKEN1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* then again to lock */
name|POSTING_READ
argument_list|(
name|SOUTH_CHICKEN1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_fdi_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
comment|/* disable CPU FDI tx and PCH FDI rx */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_TX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
literal|0x7
operator|<<
literal|16
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|PIPE_BPC_MASK
operator|)
operator|<<
literal|11
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Ironlake workaround, disable clock pointer after downing FDI */
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|FDI_RX_CHICKEN
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|FDI_RX_PHASE_SYNC_POINTER_OVR
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FDI_RX_CHICKEN
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|FDI_RX_CHICKEN
argument_list|(
name|pipe
argument_list|)
operator|&
operator|~
name|FDI_RX_PHASE_SYNC_POINTER_EN
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|cpt_phase_pointer_disable
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
comment|/* still set train pattern 1 */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1_CPT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
block|}
comment|/* BPC in FDI rx is consistent with that in PIPECONF */
name|temp
operator|&=
operator|~
operator|(
literal|0x07
operator|<<
literal|16
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|PIPE_BPC_MASK
operator|)
operator|<<
literal|11
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When we disable a pipe, we need to clear any pending scanline wait events  * to avoid hanging the ring, which we assume we are waiting on.  */
end_comment

begin_function
specifier|static
name|void
name|intel_clear_scanline_wait
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|u32
name|tmp
decl_stmt|;
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
comment|/* Can't break the hang on i8xx */
return|return;
name|ring
operator|=
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|I915_READ_CTL
argument_list|(
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|RING_WAIT
condition|)
name|I915_WRITE_CTL
argument_list|(
name|ring
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_wait_for_pending_flips
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
if|if
condition|(
name|crtc
operator|->
name|fb
operator|==
name|NULL
condition|)
return|return;
name|obj
operator|=
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
operator|->
name|obj
expr_stmt|;
name|dev
operator|=
name|crtc
operator|->
name|dev
expr_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|atomic_read
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|)
operator|!=
literal|0
condition|)
name|msleep
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|,
operator|&
name|dev
operator|->
name|event_lock
argument_list|,
literal|0
argument_list|,
literal|"915wfl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_crtc_driving_pch
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
comment|/* 	 * If there's a non-PCH eDP on this crtc, it must be DP_A, and that 	 * must be driven by its own crtc; no sharing is possible. 	 */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_EDP
case|:
if|if
condition|(
operator|!
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|)
condition|)
return|return
name|false
return|;
continue|continue;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * Enable PCH resources required for PCH ports:  *   - PCH PLLs  *   - FDI training& RX/TX  *   - update transcoder timings  *   - DP transcoding bits  *   - transcoder  */
end_comment

begin_function
specifier|static
name|void
name|ironlake_pch_enable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|,
name|transc_sel
decl_stmt|;
comment|/* For PCH output, training FDI link */
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_enable_pch_pll
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|transc_sel
operator|=
name|intel_crtc
operator|->
name|use_pll_a
condition|?
name|TRANSC_DPLLA_SEL
else|:
name|TRANSC_DPLLB_SEL
expr_stmt|;
comment|/* Be sure PCH DPLL SEL is set */
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_DPLL_SEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
literal|0
condition|)
block|{
name|temp
operator|&=
operator|~
operator|(
name|TRANSA_DPLLB_SEL
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|TRANSA_DPLL_ENABLE
operator||
name|TRANSA_DPLLA_SEL
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pipe
operator|==
literal|1
condition|)
block|{
name|temp
operator|&=
operator|~
operator|(
name|TRANSB_DPLLB_SEL
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|TRANSB_DPLL_ENABLE
operator||
name|TRANSB_DPLLB_SEL
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pipe
operator|==
literal|2
condition|)
block|{
name|temp
operator|&=
operator|~
operator|(
name|TRANSC_DPLLB_SEL
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|TRANSC_DPLL_ENABLE
operator||
name|transc_sel
operator|)
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|PCH_DPLL_SEL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* set transcoder timing, panel must allow it */
name|assert_panel_unlocked
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_HTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|HTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_HBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|HBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_HSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|HSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_VTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|VTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_VBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|VBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_VSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|VSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_VSYNCSHIFT
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|VSYNCSHIFT
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intel_fdi_normal_train
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* For PCH DP, enable TRANS_DP_CTL */
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
operator|||
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_EDP
argument_list|)
operator|)
condition|)
block|{
name|u32
name|bpc
init|=
operator|(
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|PIPE_BPC_MASK
operator|)
operator|>>
literal|5
decl_stmt|;
name|reg
operator|=
name|TRANS_DP_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|TRANS_DP_PORT_SEL_MASK
operator||
name|TRANS_DP_SYNC_MASK
operator||
name|TRANS_DP_BPC_MASK
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|TRANS_DP_OUTPUT_ENABLE
operator||
name|TRANS_DP_ENH_FRAMING
operator|)
expr_stmt|;
name|temp
operator||=
name|bpc
operator|<<
literal|9
expr_stmt|;
comment|/* same format but at 11:9 */
if|if
condition|(
name|crtc
operator|->
name|mode
operator|.
name|flags
operator|&
name|DRM_MODE_FLAG_PHSYNC
condition|)
name|temp
operator||=
name|TRANS_DP_HSYNC_ACTIVE_HIGH
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|mode
operator|.
name|flags
operator|&
name|DRM_MODE_FLAG_PVSYNC
condition|)
name|temp
operator||=
name|TRANS_DP_VSYNC_ACTIVE_HIGH
expr_stmt|;
switch|switch
condition|(
name|intel_trans_dp_port_sel
argument_list|(
name|crtc
argument_list|)
condition|)
block|{
case|case
name|PCH_DP_B
case|:
name|temp
operator||=
name|TRANS_DP_PORT_SEL_B
expr_stmt|;
break|break;
case|case
name|PCH_DP_C
case|:
name|temp
operator||=
name|TRANS_DP_PORT_SEL_C
expr_stmt|;
break|break;
case|case
name|PCH_DP_D
case|:
name|temp
operator||=
name|TRANS_DP_PORT_SEL_D
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG_KMS
argument_list|(
literal|"Wrong PCH DP port return. Guess port B\n"
argument_list|)
expr_stmt|;
name|temp
operator||=
name|TRANS_DP_PORT_SEL_B
expr_stmt|;
break|break;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|intel_enable_transcoder
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_cpt_verify_modeset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|dslreg
init|=
name|PIPEDSL
argument_list|(
name|pipe
argument_list|)
decl_stmt|,
name|tc2reg
init|=
name|TRANS_CHICKEN2
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|dslreg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
name|I915_READ
argument_list|(
name|dslreg
argument_list|)
operator|!=
name|temp
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|"915cp1"
argument_list|)
condition|)
block|{
comment|/* Without this, mode sets may fail silently on FDI */
name|I915_WRITE
argument_list|(
name|tc2reg
argument_list|,
name|TRANS_AUTOTRAIN_GEN_STALL_DIS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|250
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|tc2reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
name|I915_READ
argument_list|(
name|dslreg
argument_list|)
operator|!=
name|temp
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|"915cp2"
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"mode set failed: pipe %d stuck\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_crtc_enable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|bool
name|is_pch_port
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|active
condition|)
return|return;
name|intel_crtc
operator|->
name|active
operator|=
name|true
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|&
name|LVDS_PORT_EN
operator|)
operator|==
literal|0
condition|)
name|I915_WRITE
argument_list|(
name|PCH_LVDS
argument_list|,
name|temp
operator||
name|LVDS_PORT_EN
argument_list|)
expr_stmt|;
block|}
name|is_pch_port
operator|=
name|intel_crtc_driving_pch
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pch_port
condition|)
name|ironlake_fdi_pll_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
else|else
name|ironlake_fdi_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* Enable panel fitting for LVDS */
if|if
condition|(
name|dev_priv
operator|->
name|pch_pf_size
operator|&&
operator|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|||
name|HAS_eDP
operator|)
condition|)
block|{
comment|/* Force use of hard-coded filter coefficients 		 * as some pre-programmed values are broken, 		 * e.g. x201. 		 */
name|I915_WRITE
argument_list|(
name|PF_CTL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|PF_ENABLE
operator||
name|PF_FILTER_MED_3x3
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PF_WIN_POS
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dev_priv
operator|->
name|pch_pf_pos
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PF_WIN_SZ
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dev_priv
operator|->
name|pch_pf_size
argument_list|)
expr_stmt|;
block|}
name|intel_enable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|is_pch_port
argument_list|)
expr_stmt|;
name|intel_enable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pch_port
condition|)
name|ironlake_pch_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_crtc_load_lut
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_crtc_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|active
condition|)
return|return;
name|intel_crtc_wait_for_pending_flips
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|drm_vblank_off
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|intel_disable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|cfb_plane
operator|==
name|plane
condition|)
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_disable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* Disable PF */
name|I915_WRITE
argument_list|(
name|PF_CTL
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PF_WIN_SZ
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ironlake_fdi_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* This is a horrible layering violation; we should be doing this in 	 * the connector/encoder ->prepare instead, but we don't always have 	 * enough information there about the config to know whether it will 	 * actually be necessary or just cause undesired flicker. 	 */
name|intel_disable_pch_ports
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_disable_transcoder
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* disable TRANS_DP_CTL */
name|reg
operator|=
name|TRANS_DP_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|TRANS_DP_OUTPUT_ENABLE
operator||
name|TRANS_DP_PORT_SEL_MASK
operator|)
expr_stmt|;
name|temp
operator||=
name|TRANS_DP_PORT_SEL_NONE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* disable DPLL_SEL */
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_DPLL_SEL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
case|case
literal|0
case|:
name|temp
operator|&=
operator|~
operator|(
name|TRANSA_DPLL_ENABLE
operator||
name|TRANSA_DPLLB_SEL
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|temp
operator|&=
operator|~
operator|(
name|TRANSB_DPLL_ENABLE
operator||
name|TRANSB_DPLLB_SEL
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* C shares PLL A or B */
name|temp
operator|&=
operator|~
operator|(
name|TRANSC_DPLL_ENABLE
operator||
name|TRANSC_DPLLB_SEL
operator|)
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Wrong pipe %d"
operator|,
name|pipe
operator|)
argument_list|)
expr_stmt|;
comment|/* wtf */
block|}
name|I915_WRITE
argument_list|(
name|PCH_DPLL_SEL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* disable PCH DPLL */
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|no_pll
condition|)
name|intel_disable_pch_pll
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* Switch from PCDclk to Rawclk */
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_PCDCLK
argument_list|)
expr_stmt|;
comment|/* Disable CPU FDI TX PLL */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_TX_PLL_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_RX_PLL_ENABLE
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to turn off. */
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|active
operator|=
name|false
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_clear_scanline_wait
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_crtc_dpms
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
comment|/* XXX: When our outputs are all unaware of DPMS modes other than off 	 * and on, we should map those modes to DRM_MODE_DPMS_OFF in the CRTC. 	 */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|DRM_MODE_DPMS_ON
case|:
case|case
name|DRM_MODE_DPMS_STANDBY
case|:
case|case
name|DRM_MODE_DPMS_SUSPEND
case|:
name|DRM_DEBUG_KMS
argument_list|(
literal|"crtc %d/%d dpms on\n"
argument_list|,
name|pipe
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|ironlake_crtc_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRM_MODE_DPMS_OFF
case|:
name|DRM_DEBUG_KMS
argument_list|(
literal|"crtc %d/%d dpms off\n"
argument_list|,
name|pipe
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|ironlake_crtc_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_dpms_overlay
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
if|if
condition|(
operator|!
name|enable
operator|&&
name|intel_crtc
operator|->
name|overlay
condition|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_crtc
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|false
expr_stmt|;
operator|(
name|void
operator|)
name|intel_overlay_switch_off
argument_list|(
name|intel_crtc
operator|->
name|overlay
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|true
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Let userspace switch the overlay on again. In most cases userspace 	 * has to recompute where to put it anyway. 	 */
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_crtc_enable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|active
condition|)
return|return;
name|intel_crtc
operator|->
name|active
operator|=
name|true
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_enable_pll
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_enable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|intel_enable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_crtc_load_lut
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Give the overlay scaler a chance to enable if it's on this pipe */
name|intel_crtc_dpms_overlay
argument_list|(
name|intel_crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_crtc_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|active
condition|)
return|return;
comment|/* Give the overlay scaler a chance to disable if it's on this pipe */
name|intel_crtc_wait_for_pending_flips
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|drm_vblank_off
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_crtc_dpms_overlay
argument_list|(
name|intel_crtc
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|cfb_plane
operator|==
name|plane
condition|)
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_disable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_disable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_disable_pll
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|active
operator|=
name|false
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_clear_scanline_wait
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_crtc_dpms
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
comment|/* XXX: When our outputs are all unaware of DPMS modes other than off 	 * and on, we should map those modes to DRM_MODE_DPMS_OFF in the CRTC. 	 */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|DRM_MODE_DPMS_ON
case|:
case|case
name|DRM_MODE_DPMS_STANDBY
case|:
case|case
name|DRM_MODE_DPMS_SUSPEND
case|:
name|i9xx_crtc_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRM_MODE_DPMS_OFF
case|:
name|i9xx_crtc_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * Sets the power management mode of the pipe and plane.  */
end_comment

begin_function
specifier|static
name|void
name|intel_crtc_dpms
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|#
directive|if
literal|0
block|struct drm_i915_master_private *master_priv;
endif|#
directive|endif
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|bool
name|enabled
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|dpms_mode
operator|==
name|mode
condition|)
return|return;
name|intel_crtc
operator|->
name|dpms_mode
operator|=
name|mode
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|dpms
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (!dev->primary->master) 		return;  	master_priv = dev->primary->master->driver_priv; 	if (!master_priv->sarea_priv) 		return;
else|#
directive|else
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|sarea_priv
condition|)
return|return;
endif|#
directive|endif
name|enabled
operator|=
name|crtc
operator|->
name|enabled
operator|&&
name|mode
operator|!=
name|DRM_MODE_DPMS_OFF
expr_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
case|case
literal|0
case|:
if|#
directive|if
literal|0
block|master_priv->sarea_priv->pipeA_w = enabled ? crtc->mode.hdisplay : 0; 		master_priv->sarea_priv->pipeA_h = enabled ? crtc->mode.vdisplay : 0;
else|#
directive|else
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeA_w
operator|=
name|enabled
condition|?
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
else|:
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeA_h
operator|=
name|enabled
condition|?
name|crtc
operator|->
name|mode
operator|.
name|vdisplay
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|1
case|:
if|#
directive|if
literal|0
block|master_priv->sarea_priv->pipeB_w = enabled ? crtc->mode.hdisplay : 0; 		master_priv->sarea_priv->pipeB_h = enabled ? crtc->mode.vdisplay : 0;
else|#
directive|else
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeB_w
operator|=
name|enabled
condition|?
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
else|:
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeB_h
operator|=
name|enabled
condition|?
name|crtc
operator|->
name|mode
operator|.
name|vdisplay
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Can't update pipe %c in SAREA\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_crtc_helper_funcs
modifier|*
name|crtc_funcs
init|=
name|crtc
operator|->
name|helper_private
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
comment|/* Flush any pending WAITs before we disable the pipe. Note that 	 * we need to drop the struct_mutex in order to acquire it again 	 * during the lowlevel dpms routines around a couple of the 	 * operations. It does not look trivial nor desirable to move 	 * that locking higher. So instead we leave a window for the 	 * submission of further commands on the fb before we can actually 	 * disable it. This race with userspace exists anyway, and we can 	 * only rely on the pipe being disabled by userspace after it 	 * receives the hotplug notification and has flushed any pending 	 * batches. 	 */
if|if
condition|(
name|crtc
operator|->
name|fb
condition|)
block|{
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_finish_fb
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|crtc_funcs
operator|->
name|dpms
argument_list|(
name|crtc
argument_list|,
name|DRM_MODE_DPMS_OFF
argument_list|)
expr_stmt|;
name|assert_plane_disabled
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|,
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|plane
argument_list|)
expr_stmt|;
name|assert_pipe_disabled
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|,
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|fb
condition|)
block|{
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_unpin_fb_obj
argument_list|(
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
operator|->
name|obj
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prepare for a mode set.  *  * Note we could be a lot smarter here.  We need to figure out which outputs  * will be enabled, which disabled (in short, how the config will changes)  * and perform the minimum necessary steps to accomplish that, e.g. updating  * watermarks, FBC configuration, making sure PLLs are programmed correctly,  * panel fitting is in the proper state, etc.  */
end_comment

begin_function
specifier|static
name|void
name|i9xx_crtc_prepare
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|i9xx_crtc_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_crtc_commit
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|i9xx_crtc_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_crtc_prepare
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|ironlake_crtc_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_crtc_commit
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|ironlake_crtc_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_encoder_prepare
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
init|=
name|encoder
operator|->
name|helper_private
decl_stmt|;
comment|/* lvds has its own version of prepare see intel_lvds_prepare */
name|encoder_funcs
operator|->
name|dpms
argument_list|(
name|encoder
argument_list|,
name|DRM_MODE_DPMS_OFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_encoder_commit
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
init|=
name|encoder
operator|->
name|helper_private
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
init|=
name|to_intel_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|intel_encoder
operator|->
name|base
operator|.
name|crtc
argument_list|)
decl_stmt|;
comment|/* lvds has its own version of commit see intel_lvds_commit */
name|encoder_funcs
operator|->
name|dpms
argument_list|(
name|encoder
argument_list|,
name|DRM_MODE_DPMS_ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_cpt_verify_modeset
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_encoder_destroy
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
init|=
name|to_intel_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|drm_encoder_cleanup
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intel_encoder
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_crtc_mode_fixup
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* FDI link clock is fixed at 2.7G */
if|if
condition|(
name|mode
operator|->
name|clock
operator|*
literal|3
operator|>
name|IRONLAKE_FDI_FREQ
operator|*
literal|4
condition|)
return|return
name|false
return|;
block|}
comment|/* All interlaced capable intel hw wants timings in frames. Note though 	 * that intel_lvds_mode_fixup does some funny tricks with the crtc 	 * timings, so we need to be careful not to clobber these.*/
if|if
condition|(
operator|!
operator|(
name|adjusted_mode
operator|->
name|private_flags
operator|&
name|INTEL_MODE_CRTC_TIMINGS_SET
operator|)
condition|)
name|drm_mode_set_crtcinfo
argument_list|(
name|adjusted_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i945_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|400000
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|333000
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i9xx_misc_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|200000
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915gm_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|u16
name|gcfgc
init|=
literal|0
decl_stmt|;
name|gcfgc
operator|=
name|pci_read_config
argument_list|(
name|dev
operator|->
name|device
argument_list|,
name|GCFGC
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcfgc
operator|&
name|GC_LOW_FREQUENCY_ENABLE
condition|)
return|return
literal|133000
return|;
else|else
block|{
switch|switch
condition|(
name|gcfgc
operator|&
name|GC_DISPLAY_CLOCK_MASK
condition|)
block|{
case|case
name|GC_DISPLAY_CLOCK_333_MHZ
case|:
return|return
literal|333000
return|;
default|default:
case|case
name|GC_DISPLAY_CLOCK_190_200_MHZ
case|:
return|return
literal|190000
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|i865_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|266000
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i855_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|u16
name|hpllcc
init|=
literal|0
decl_stmt|;
comment|/* Assume that the hardware is in the high speed state.  This 	 * should be the default. 	 */
switch|switch
condition|(
name|hpllcc
operator|&
name|GC_CLOCK_CONTROL_MASK
condition|)
block|{
case|case
name|GC_CLOCK_133_200
case|:
case|case
name|GC_CLOCK_100_200
case|:
return|return
literal|200000
return|;
case|case
name|GC_CLOCK_166_250
case|:
return|return
literal|250000
return|;
case|case
name|GC_CLOCK_100_133
case|:
return|return
literal|133000
return|;
block|}
comment|/* Shouldn't happen */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i830_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|133000
return|;
block|}
end_function

begin_struct
struct|struct
name|fdi_m_n
block|{
name|u32
name|tu
decl_stmt|;
name|u32
name|gmch_m
decl_stmt|;
name|u32
name|gmch_n
decl_stmt|;
name|u32
name|link_m
decl_stmt|;
name|u32
name|link_n
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|fdi_reduce_ratio
parameter_list|(
name|u32
modifier|*
name|num
parameter_list|,
name|u32
modifier|*
name|den
parameter_list|)
block|{
while|while
condition|(
operator|*
name|num
operator|>
literal|0xffffff
operator|||
operator|*
name|den
operator|>
literal|0xffffff
condition|)
block|{
operator|*
name|num
operator|>>=
literal|1
expr_stmt|;
operator|*
name|den
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_compute_m_n
parameter_list|(
name|int
name|bits_per_pixel
parameter_list|,
name|int
name|nlanes
parameter_list|,
name|int
name|pixel_clock
parameter_list|,
name|int
name|link_clock
parameter_list|,
name|struct
name|fdi_m_n
modifier|*
name|m_n
parameter_list|)
block|{
name|m_n
operator|->
name|tu
operator|=
literal|64
expr_stmt|;
comment|/* default size */
comment|/* BUG_ON(pixel_clock> INT_MAX / 36); */
name|m_n
operator|->
name|gmch_m
operator|=
name|bits_per_pixel
operator|*
name|pixel_clock
expr_stmt|;
name|m_n
operator|->
name|gmch_n
operator|=
name|link_clock
operator|*
name|nlanes
operator|*
literal|8
expr_stmt|;
name|fdi_reduce_ratio
argument_list|(
operator|&
name|m_n
operator|->
name|gmch_m
argument_list|,
operator|&
name|m_n
operator|->
name|gmch_n
argument_list|)
expr_stmt|;
name|m_n
operator|->
name|link_m
operator|=
name|pixel_clock
expr_stmt|;
name|m_n
operator|->
name|link_n
operator|=
name|link_clock
expr_stmt|;
name|fdi_reduce_ratio
argument_list|(
operator|&
name|m_n
operator|->
name|link_m
argument_list|,
operator|&
name|m_n
operator|->
name|link_n
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|intel_watermark_params
block|{
name|unsigned
name|long
name|fifo_size
decl_stmt|;
name|unsigned
name|long
name|max_wm
decl_stmt|;
name|unsigned
name|long
name|default_wm
decl_stmt|;
name|unsigned
name|long
name|guard_size
decl_stmt|;
name|unsigned
name|long
name|cacheline_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Pineview has different values for various configs */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|pineview_display_wm
init|=
block|{
name|PINEVIEW_DISPLAY_FIFO
block|,
name|PINEVIEW_MAX_WM
block|,
name|PINEVIEW_DFT_WM
block|,
name|PINEVIEW_GUARD_WM
block|,
name|PINEVIEW_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|pineview_display_hplloff_wm
init|=
block|{
name|PINEVIEW_DISPLAY_FIFO
block|,
name|PINEVIEW_MAX_WM
block|,
name|PINEVIEW_DFT_HPLLOFF_WM
block|,
name|PINEVIEW_GUARD_WM
block|,
name|PINEVIEW_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|pineview_cursor_wm
init|=
block|{
name|PINEVIEW_CURSOR_FIFO
block|,
name|PINEVIEW_CURSOR_MAX_WM
block|,
name|PINEVIEW_CURSOR_DFT_WM
block|,
name|PINEVIEW_CURSOR_GUARD_WM
block|,
name|PINEVIEW_FIFO_LINE_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|pineview_cursor_hplloff_wm
init|=
block|{
name|PINEVIEW_CURSOR_FIFO
block|,
name|PINEVIEW_CURSOR_MAX_WM
block|,
name|PINEVIEW_CURSOR_DFT_WM
block|,
name|PINEVIEW_CURSOR_GUARD_WM
block|,
name|PINEVIEW_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|g4x_wm_info
init|=
block|{
name|G4X_FIFO_SIZE
block|,
name|G4X_MAX_WM
block|,
name|G4X_MAX_WM
block|,
literal|2
block|,
name|G4X_FIFO_LINE_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|g4x_cursor_wm_info
init|=
block|{
name|I965_CURSOR_FIFO
block|,
name|I965_CURSOR_MAX_WM
block|,
name|I965_CURSOR_DFT_WM
block|,
literal|2
block|,
name|G4X_FIFO_LINE_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|i965_cursor_wm_info
init|=
block|{
name|I965_CURSOR_FIFO
block|,
name|I965_CURSOR_MAX_WM
block|,
name|I965_CURSOR_DFT_WM
block|,
literal|2
block|,
name|I915_FIFO_LINE_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|i945_wm_info
init|=
block|{
name|I945_FIFO_SIZE
block|,
name|I915_MAX_WM
block|,
literal|1
block|,
literal|2
block|,
name|I915_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|i915_wm_info
init|=
block|{
name|I915_FIFO_SIZE
block|,
name|I915_MAX_WM
block|,
literal|1
block|,
literal|2
block|,
name|I915_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|i855_wm_info
init|=
block|{
name|I855GM_FIFO_SIZE
block|,
name|I915_MAX_WM
block|,
literal|1
block|,
literal|2
block|,
name|I830_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|i830_wm_info
init|=
block|{
name|I830_FIFO_SIZE
block|,
name|I915_MAX_WM
block|,
literal|1
block|,
literal|2
block|,
name|I830_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|ironlake_display_wm_info
init|=
block|{
name|ILK_DISPLAY_FIFO
block|,
name|ILK_DISPLAY_MAXWM
block|,
name|ILK_DISPLAY_DFTWM
block|,
literal|2
block|,
name|ILK_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|ironlake_cursor_wm_info
init|=
block|{
name|ILK_CURSOR_FIFO
block|,
name|ILK_CURSOR_MAXWM
block|,
name|ILK_CURSOR_DFTWM
block|,
literal|2
block|,
name|ILK_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|ironlake_display_srwm_info
init|=
block|{
name|ILK_DISPLAY_SR_FIFO
block|,
name|ILK_DISPLAY_MAX_SRWM
block|,
name|ILK_DISPLAY_DFT_SRWM
block|,
literal|2
block|,
name|ILK_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|ironlake_cursor_srwm_info
init|=
block|{
name|ILK_CURSOR_SR_FIFO
block|,
name|ILK_CURSOR_MAX_SRWM
block|,
name|ILK_CURSOR_DFT_SRWM
block|,
literal|2
block|,
name|ILK_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|sandybridge_display_wm_info
init|=
block|{
name|SNB_DISPLAY_FIFO
block|,
name|SNB_DISPLAY_MAXWM
block|,
name|SNB_DISPLAY_DFTWM
block|,
literal|2
block|,
name|SNB_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|sandybridge_cursor_wm_info
init|=
block|{
name|SNB_CURSOR_FIFO
block|,
name|SNB_CURSOR_MAXWM
block|,
name|SNB_CURSOR_DFTWM
block|,
literal|2
block|,
name|SNB_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|sandybridge_display_srwm_info
init|=
block|{
name|SNB_DISPLAY_SR_FIFO
block|,
name|SNB_DISPLAY_MAX_SRWM
block|,
name|SNB_DISPLAY_DFT_SRWM
block|,
literal|2
block|,
name|SNB_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|sandybridge_cursor_srwm_info
init|=
block|{
name|SNB_CURSOR_SR_FIFO
block|,
name|SNB_CURSOR_MAX_SRWM
block|,
name|SNB_CURSOR_DFT_SRWM
block|,
literal|2
block|,
name|SNB_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * intel_calculate_wm - calculate watermark level  * @clock_in_khz: pixel clock  * @wm: chip FIFO params  * @pixel_size: display pixel size  * @latency_ns: memory latency for the platform  *  * Calculate the watermark level (the level at which the display plane will  * start fetching from memory again).  Each chip has a different display  * FIFO size and allocation, so the caller needs to figure that out and pass  * in the correct intel_watermark_params structure.  *  * As the pixel clock runs, the FIFO will be drained at a rate that depends  * on the pixel size.  When it reaches the watermark level, it'll start  * fetching FIFO line sized based chunks from memory until the FIFO fills  * past the watermark point.  If the FIFO drains completely, a FIFO underrun  * will occur, and a display engine hang could result.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|intel_calculate_wm
parameter_list|(
name|unsigned
name|long
name|clock_in_khz
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|wm
parameter_list|,
name|int
name|fifo_size
parameter_list|,
name|int
name|pixel_size
parameter_list|,
name|unsigned
name|long
name|latency_ns
parameter_list|)
block|{
name|long
name|entries_required
decl_stmt|,
name|wm_size
decl_stmt|;
comment|/* 	 * Note: we need to make sure we don't overflow for various clock& 	 * latency values. 	 * clocks go from a few thousand to several hundred thousand. 	 * latency is usually a few thousand 	 */
name|entries_required
operator|=
operator|(
operator|(
name|clock_in_khz
operator|/
literal|1000
operator|)
operator|*
name|pixel_size
operator|*
name|latency_ns
operator|)
operator|/
literal|1000
expr_stmt|;
name|entries_required
operator|=
name|howmany
argument_list|(
name|entries_required
argument_list|,
name|wm
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO entries required for mode: %ld\n"
argument_list|,
name|entries_required
argument_list|)
expr_stmt|;
name|wm_size
operator|=
name|fifo_size
operator|-
operator|(
name|entries_required
operator|+
name|wm
operator|->
name|guard_size
operator|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermark level: %ld\n"
argument_list|,
name|wm_size
argument_list|)
expr_stmt|;
comment|/* Don't promote wm_size to unsigned... */
if|if
condition|(
name|wm_size
operator|>
operator|(
name|long
operator|)
name|wm
operator|->
name|max_wm
condition|)
name|wm_size
operator|=
name|wm
operator|->
name|max_wm
expr_stmt|;
if|if
condition|(
name|wm_size
operator|<=
literal|0
condition|)
name|wm_size
operator|=
name|wm
operator|->
name|default_wm
expr_stmt|;
return|return
name|wm_size
return|;
block|}
end_function

begin_struct
struct|struct
name|cxsr_latency
block|{
name|int
name|is_desktop
decl_stmt|;
name|int
name|is_ddr3
decl_stmt|;
name|unsigned
name|long
name|fsb_freq
decl_stmt|;
name|unsigned
name|long
name|mem_freq
decl_stmt|;
name|unsigned
name|long
name|display_sr
decl_stmt|;
name|unsigned
name|long
name|display_hpll_disable
decl_stmt|;
name|unsigned
name|long
name|cursor_sr
decl_stmt|;
name|unsigned
name|long
name|cursor_hpll_disable
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|cxsr_latency
name|cxsr_latency_table
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|0
block|,
literal|800
block|,
literal|400
block|,
literal|3382
block|,
literal|33382
block|,
literal|3983
block|,
literal|33983
block|}
block|,
comment|/* DDR2-400 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|800
block|,
literal|667
block|,
literal|3354
block|,
literal|33354
block|,
literal|3807
block|,
literal|33807
block|}
block|,
comment|/* DDR2-667 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|800
block|,
literal|800
block|,
literal|3347
block|,
literal|33347
block|,
literal|3763
block|,
literal|33763
block|}
block|,
comment|/* DDR2-800 SC */
block|{
literal|1
block|,
literal|1
block|,
literal|800
block|,
literal|667
block|,
literal|6420
block|,
literal|36420
block|,
literal|6873
block|,
literal|36873
block|}
block|,
comment|/* DDR3-667 SC */
block|{
literal|1
block|,
literal|1
block|,
literal|800
block|,
literal|800
block|,
literal|5902
block|,
literal|35902
block|,
literal|6318
block|,
literal|36318
block|}
block|,
comment|/* DDR3-800 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|667
block|,
literal|400
block|,
literal|3400
block|,
literal|33400
block|,
literal|4021
block|,
literal|34021
block|}
block|,
comment|/* DDR2-400 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|667
block|,
literal|667
block|,
literal|3372
block|,
literal|33372
block|,
literal|3845
block|,
literal|33845
block|}
block|,
comment|/* DDR2-667 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|667
block|,
literal|800
block|,
literal|3386
block|,
literal|33386
block|,
literal|3822
block|,
literal|33822
block|}
block|,
comment|/* DDR2-800 SC */
block|{
literal|1
block|,
literal|1
block|,
literal|667
block|,
literal|667
block|,
literal|6438
block|,
literal|36438
block|,
literal|6911
block|,
literal|36911
block|}
block|,
comment|/* DDR3-667 SC */
block|{
literal|1
block|,
literal|1
block|,
literal|667
block|,
literal|800
block|,
literal|5941
block|,
literal|35941
block|,
literal|6377
block|,
literal|36377
block|}
block|,
comment|/* DDR3-800 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|400
block|,
literal|400
block|,
literal|3472
block|,
literal|33472
block|,
literal|4173
block|,
literal|34173
block|}
block|,
comment|/* DDR2-400 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|400
block|,
literal|667
block|,
literal|3443
block|,
literal|33443
block|,
literal|3996
block|,
literal|33996
block|}
block|,
comment|/* DDR2-667 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|400
block|,
literal|800
block|,
literal|3430
block|,
literal|33430
block|,
literal|3946
block|,
literal|33946
block|}
block|,
comment|/* DDR2-800 SC */
block|{
literal|1
block|,
literal|1
block|,
literal|400
block|,
literal|667
block|,
literal|6509
block|,
literal|36509
block|,
literal|7062
block|,
literal|37062
block|}
block|,
comment|/* DDR3-667 SC */
block|{
literal|1
block|,
literal|1
block|,
literal|400
block|,
literal|800
block|,
literal|5985
block|,
literal|35985
block|,
literal|6501
block|,
literal|36501
block|}
block|,
comment|/* DDR3-800 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|800
block|,
literal|400
block|,
literal|3438
block|,
literal|33438
block|,
literal|4065
block|,
literal|34065
block|}
block|,
comment|/* DDR2-400 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|800
block|,
literal|667
block|,
literal|3410
block|,
literal|33410
block|,
literal|3889
block|,
literal|33889
block|}
block|,
comment|/* DDR2-667 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|800
block|,
literal|800
block|,
literal|3403
block|,
literal|33403
block|,
literal|3845
block|,
literal|33845
block|}
block|,
comment|/* DDR2-800 SC */
block|{
literal|0
block|,
literal|1
block|,
literal|800
block|,
literal|667
block|,
literal|6476
block|,
literal|36476
block|,
literal|6955
block|,
literal|36955
block|}
block|,
comment|/* DDR3-667 SC */
block|{
literal|0
block|,
literal|1
block|,
literal|800
block|,
literal|800
block|,
literal|5958
block|,
literal|35958
block|,
literal|6400
block|,
literal|36400
block|}
block|,
comment|/* DDR3-800 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|667
block|,
literal|400
block|,
literal|3456
block|,
literal|33456
block|,
literal|4103
block|,
literal|34106
block|}
block|,
comment|/* DDR2-400 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|667
block|,
literal|667
block|,
literal|3428
block|,
literal|33428
block|,
literal|3927
block|,
literal|33927
block|}
block|,
comment|/* DDR2-667 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|667
block|,
literal|800
block|,
literal|3443
block|,
literal|33443
block|,
literal|3905
block|,
literal|33905
block|}
block|,
comment|/* DDR2-800 SC */
block|{
literal|0
block|,
literal|1
block|,
literal|667
block|,
literal|667
block|,
literal|6494
block|,
literal|36494
block|,
literal|6993
block|,
literal|36993
block|}
block|,
comment|/* DDR3-667 SC */
block|{
literal|0
block|,
literal|1
block|,
literal|667
block|,
literal|800
block|,
literal|5998
block|,
literal|35998
block|,
literal|6460
block|,
literal|36460
block|}
block|,
comment|/* DDR3-800 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|400
block|,
literal|400
block|,
literal|3528
block|,
literal|33528
block|,
literal|4255
block|,
literal|34255
block|}
block|,
comment|/* DDR2-400 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|400
block|,
literal|667
block|,
literal|3500
block|,
literal|33500
block|,
literal|4079
block|,
literal|34079
block|}
block|,
comment|/* DDR2-667 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|400
block|,
literal|800
block|,
literal|3487
block|,
literal|33487
block|,
literal|4029
block|,
literal|34029
block|}
block|,
comment|/* DDR2-800 SC */
block|{
literal|0
block|,
literal|1
block|,
literal|400
block|,
literal|667
block|,
literal|6566
block|,
literal|36566
block|,
literal|7145
block|,
literal|37145
block|}
block|,
comment|/* DDR3-667 SC */
block|{
literal|0
block|,
literal|1
block|,
literal|400
block|,
literal|800
block|,
literal|6042
block|,
literal|36042
block|,
literal|6584
block|,
literal|36584
block|}
block|,
comment|/* DDR3-800 SC */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|cxsr_latency
modifier|*
name|intel_get_cxsr_latency
parameter_list|(
name|int
name|is_desktop
parameter_list|,
name|int
name|is_ddr3
parameter_list|,
name|int
name|fsb
parameter_list|,
name|int
name|mem
parameter_list|)
block|{
specifier|const
name|struct
name|cxsr_latency
modifier|*
name|latency
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fsb
operator|==
literal|0
operator|||
name|mem
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_ARRAY_SIZE
argument_list|(
name|cxsr_latency_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|latency
operator|=
operator|&
name|cxsr_latency_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|is_desktop
operator|==
name|latency
operator|->
name|is_desktop
operator|&&
name|is_ddr3
operator|==
name|latency
operator|->
name|is_ddr3
operator|&&
name|fsb
operator|==
name|latency
operator|->
name|fsb_freq
operator|&&
name|mem
operator|==
name|latency
operator|->
name|mem_freq
condition|)
return|return
name|latency
return|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unknown FSB/MEM found, disable CxSR\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pineview_disable_cxsr
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* deactivate cxsr */
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
name|I915_READ
argument_list|(
name|DSPFW3
argument_list|)
operator|&
operator|~
name|PINEVIEW_SELF_REFRESH_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Latency for FIFO fetches is dependent on several factors:  *   - memory configuration (speed, channels)  *   - chipset  *   - current MCH state  * It can be fairly high in some situations, so here we assume a fairly  * pessimal value.  It's a tradeoff between extra memory fetches (if we  * set this value too high, the FIFO will fetch frequently to stay full)  * and power consumption (set it too low to save power and we might see  * FIFO underruns and display "flicker").  *  * A value of 5us seems to be a good balance; safe for very low end  * platforms but not overly aggressive on lower latency configs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|latency_ns
init|=
literal|5000
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i9xx_get_fifo_size
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|dsparb
init|=
name|I915_READ
argument_list|(
name|DSPARB
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
name|dsparb
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|plane
condition|)
name|size
operator|=
operator|(
operator|(
name|dsparb
operator|>>
name|DSPARB_CSTART_SHIFT
operator|)
operator|&
literal|0x7f
operator|)
operator|-
name|size
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO size - (0x%08x) %s: %d\n"
argument_list|,
name|dsparb
argument_list|,
name|plane
condition|?
literal|"B"
else|:
literal|"A"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i85x_get_fifo_size
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|dsparb
init|=
name|I915_READ
argument_list|(
name|DSPARB
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
name|dsparb
operator|&
literal|0x1ff
expr_stmt|;
if|if
condition|(
name|plane
condition|)
name|size
operator|=
operator|(
operator|(
name|dsparb
operator|>>
name|DSPARB_BEND_SHIFT
operator|)
operator|&
literal|0x1ff
operator|)
operator|-
name|size
expr_stmt|;
name|size
operator|>>=
literal|1
expr_stmt|;
comment|/* Convert to cachelines */
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO size - (0x%08x) %s: %d\n"
argument_list|,
name|dsparb
argument_list|,
name|plane
condition|?
literal|"B"
else|:
literal|"A"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i845_get_fifo_size
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|dsparb
init|=
name|I915_READ
argument_list|(
name|DSPARB
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
name|dsparb
operator|&
literal|0x7f
expr_stmt|;
name|size
operator|>>=
literal|2
expr_stmt|;
comment|/* Convert to cachelines */
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO size - (0x%08x) %s: %d\n"
argument_list|,
name|dsparb
argument_list|,
name|plane
condition|?
literal|"B"
else|:
literal|"A"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i830_get_fifo_size
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|dsparb
init|=
name|I915_READ
argument_list|(
name|DSPARB
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
name|dsparb
operator|&
literal|0x7f
expr_stmt|;
name|size
operator|>>=
literal|1
expr_stmt|;
comment|/* Convert to cachelines */
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO size - (0x%08x) %s: %d\n"
argument_list|,
name|dsparb
argument_list|,
name|plane
condition|?
literal|"B"
else|:
literal|"A"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_crtc
modifier|*
name|single_enabled_crtc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|,
modifier|*
name|enabled
init|=
name|NULL
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|crtc
operator|->
name|enabled
operator|&&
name|crtc
operator|->
name|fb
condition|)
block|{
if|if
condition|(
name|enabled
condition|)
return|return
name|NULL
return|;
name|enabled
operator|=
name|crtc
expr_stmt|;
block|}
block|}
return|return
name|enabled
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pineview_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
specifier|const
name|struct
name|cxsr_latency
modifier|*
name|latency
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|unsigned
name|long
name|wm
decl_stmt|;
name|latency
operator|=
name|intel_get_cxsr_latency
argument_list|(
name|IS_PINEVIEW_G
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev_priv
operator|->
name|is_ddr3
argument_list|,
name|dev_priv
operator|->
name|fsb_freq
argument_list|,
name|dev_priv
operator|->
name|mem_freq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|latency
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unknown FSB/MEM found, disable CxSR\n"
argument_list|)
expr_stmt|;
name|pineview_disable_cxsr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
name|crtc
operator|=
name|single_enabled_crtc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
condition|)
block|{
name|int
name|clock
init|=
name|crtc
operator|->
name|mode
operator|.
name|clock
decl_stmt|;
name|int
name|pixel_size
init|=
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
decl_stmt|;
comment|/* Display SR */
name|wm
operator|=
name|intel_calculate_wm
argument_list|(
name|clock
argument_list|,
operator|&
name|pineview_display_wm
argument_list|,
name|pineview_display_wm
operator|.
name|fifo_size
argument_list|,
name|pixel_size
argument_list|,
name|latency
operator|->
name|display_sr
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I915_READ
argument_list|(
name|DSPFW1
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|DSPFW_SR_MASK
expr_stmt|;
name|reg
operator||=
name|wm
operator|<<
name|DSPFW_SR_SHIFT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"DSPFW1 register is %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* cursor SR */
name|wm
operator|=
name|intel_calculate_wm
argument_list|(
name|clock
argument_list|,
operator|&
name|pineview_cursor_wm
argument_list|,
name|pineview_display_wm
operator|.
name|fifo_size
argument_list|,
name|pixel_size
argument_list|,
name|latency
operator|->
name|cursor_sr
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I915_READ
argument_list|(
name|DSPFW3
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|DSPFW_CURSOR_SR_MASK
expr_stmt|;
name|reg
operator||=
operator|(
name|wm
operator|&
literal|0x3f
operator|)
operator|<<
name|DSPFW_CURSOR_SR_SHIFT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Display HPLL off SR */
name|wm
operator|=
name|intel_calculate_wm
argument_list|(
name|clock
argument_list|,
operator|&
name|pineview_display_hplloff_wm
argument_list|,
name|pineview_display_hplloff_wm
operator|.
name|fifo_size
argument_list|,
name|pixel_size
argument_list|,
name|latency
operator|->
name|display_hpll_disable
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I915_READ
argument_list|(
name|DSPFW3
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|DSPFW_HPLL_SR_MASK
expr_stmt|;
name|reg
operator||=
name|wm
operator|&
name|DSPFW_HPLL_SR_MASK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* cursor HPLL off SR */
name|wm
operator|=
name|intel_calculate_wm
argument_list|(
name|clock
argument_list|,
operator|&
name|pineview_cursor_hplloff_wm
argument_list|,
name|pineview_display_hplloff_wm
operator|.
name|fifo_size
argument_list|,
name|pixel_size
argument_list|,
name|latency
operator|->
name|cursor_hpll_disable
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I915_READ
argument_list|(
name|DSPFW3
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|DSPFW_HPLL_CURSOR_MASK
expr_stmt|;
name|reg
operator||=
operator|(
name|wm
operator|&
literal|0x3f
operator|)
operator|<<
name|DSPFW_HPLL_CURSOR_SHIFT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"DSPFW3 register is %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* activate cxsr */
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
name|I915_READ
argument_list|(
name|DSPFW3
argument_list|)
operator||
name|PINEVIEW_SELF_REFRESH_EN
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Self-refresh is enabled\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pineview_disable_cxsr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Self-refresh is disabled\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|g4x_compute_wm0
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|display
parameter_list|,
name|int
name|display_latency_ns
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|cursor
parameter_list|,
name|int
name|cursor_latency_ns
parameter_list|,
name|int
modifier|*
name|plane_wm
parameter_list|,
name|int
modifier|*
name|cursor_wm
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|int
name|htotal
decl_stmt|,
name|hdisplay
decl_stmt|,
name|clock
decl_stmt|,
name|pixel_size
decl_stmt|;
name|int
name|line_time_us
decl_stmt|,
name|line_count
decl_stmt|;
name|int
name|entries
decl_stmt|,
name|tlb_miss
decl_stmt|;
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
name|plane
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|fb
operator|==
name|NULL
operator|||
operator|!
name|crtc
operator|->
name|enabled
condition|)
block|{
operator|*
name|cursor_wm
operator|=
name|cursor
operator|->
name|guard_size
expr_stmt|;
operator|*
name|plane_wm
operator|=
name|display
operator|->
name|guard_size
expr_stmt|;
return|return
name|false
return|;
block|}
name|htotal
operator|=
name|crtc
operator|->
name|mode
operator|.
name|htotal
expr_stmt|;
name|hdisplay
operator|=
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
expr_stmt|;
name|clock
operator|=
name|crtc
operator|->
name|mode
operator|.
name|clock
expr_stmt|;
name|pixel_size
operator|=
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
expr_stmt|;
comment|/* Use the small buffer method to calculate plane watermark */
name|entries
operator|=
operator|(
operator|(
name|clock
operator|*
name|pixel_size
operator|/
literal|1000
operator|)
operator|*
name|display_latency_ns
operator|)
operator|/
literal|1000
expr_stmt|;
name|tlb_miss
operator|=
name|display
operator|->
name|fifo_size
operator|*
name|display
operator|->
name|cacheline_size
operator|-
name|hdisplay
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|tlb_miss
operator|>
literal|0
condition|)
name|entries
operator|+=
name|tlb_miss
expr_stmt|;
name|entries
operator|=
name|howmany
argument_list|(
name|entries
argument_list|,
name|display
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|plane_wm
operator|=
name|entries
operator|+
name|display
operator|->
name|guard_size
expr_stmt|;
if|if
condition|(
operator|*
name|plane_wm
operator|>
operator|(
name|int
operator|)
name|display
operator|->
name|max_wm
condition|)
operator|*
name|plane_wm
operator|=
name|display
operator|->
name|max_wm
expr_stmt|;
comment|/* Use the large buffer method to calculate cursor watermark */
name|line_time_us
operator|=
operator|(
operator|(
name|htotal
operator|*
literal|1000
operator|)
operator|/
name|clock
operator|)
expr_stmt|;
name|line_count
operator|=
operator|(
name|cursor_latency_ns
operator|/
name|line_time_us
operator|+
literal|1000
operator|)
operator|/
literal|1000
expr_stmt|;
name|entries
operator|=
name|line_count
operator|*
literal|64
operator|*
name|pixel_size
expr_stmt|;
name|tlb_miss
operator|=
name|cursor
operator|->
name|fifo_size
operator|*
name|cursor
operator|->
name|cacheline_size
operator|-
name|hdisplay
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|tlb_miss
operator|>
literal|0
condition|)
name|entries
operator|+=
name|tlb_miss
expr_stmt|;
name|entries
operator|=
name|howmany
argument_list|(
name|entries
argument_list|,
name|cursor
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|cursor_wm
operator|=
name|entries
operator|+
name|cursor
operator|->
name|guard_size
expr_stmt|;
if|if
condition|(
operator|*
name|cursor_wm
operator|>
operator|(
name|int
operator|)
name|cursor
operator|->
name|max_wm
condition|)
operator|*
name|cursor_wm
operator|=
operator|(
name|int
operator|)
name|cursor
operator|->
name|max_wm
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * Check the wm result.  *  * If any calculated watermark values is larger than the maximum value that  * can be programmed into the associated watermark register, that watermark  * must be disabled.  */
end_comment

begin_function
specifier|static
name|bool
name|g4x_check_srwm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|display_wm
parameter_list|,
name|int
name|cursor_wm
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|display
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|cursor
parameter_list|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"SR watermark: display plane %d, cursor %d\n"
argument_list|,
name|display_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
if|if
condition|(
name|display_wm
operator|>
name|display
operator|->
name|max_wm
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"display watermark is too large(%d/%ld), disabling\n"
argument_list|,
name|display_wm
argument_list|,
name|display
operator|->
name|max_wm
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|cursor_wm
operator|>
name|cursor
operator|->
name|max_wm
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"cursor watermark is too large(%d/%ld), disabling\n"
argument_list|,
name|cursor_wm
argument_list|,
name|cursor
operator|->
name|max_wm
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|display_wm
operator|||
name|cursor_wm
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"SR latency is 0, disabling\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|g4x_compute_srwm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|,
name|int
name|latency_ns
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|display
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|cursor
parameter_list|,
name|int
modifier|*
name|display_wm
parameter_list|,
name|int
modifier|*
name|cursor_wm
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|int
name|hdisplay
decl_stmt|,
name|htotal
decl_stmt|,
name|pixel_size
decl_stmt|,
name|clock
decl_stmt|;
name|unsigned
name|long
name|line_time_us
decl_stmt|;
name|int
name|line_count
decl_stmt|,
name|line_size
decl_stmt|;
name|int
name|small
decl_stmt|,
name|large
decl_stmt|;
name|int
name|entries
decl_stmt|;
if|if
condition|(
operator|!
name|latency_ns
condition|)
block|{
operator|*
name|display_wm
operator|=
operator|*
name|cursor_wm
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|hdisplay
operator|=
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
expr_stmt|;
name|htotal
operator|=
name|crtc
operator|->
name|mode
operator|.
name|htotal
expr_stmt|;
name|clock
operator|=
name|crtc
operator|->
name|mode
operator|.
name|clock
expr_stmt|;
name|pixel_size
operator|=
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
expr_stmt|;
name|line_time_us
operator|=
operator|(
name|htotal
operator|*
literal|1000
operator|)
operator|/
name|clock
expr_stmt|;
name|line_count
operator|=
operator|(
name|latency_ns
operator|/
name|line_time_us
operator|+
literal|1000
operator|)
operator|/
literal|1000
expr_stmt|;
name|line_size
operator|=
name|hdisplay
operator|*
name|pixel_size
expr_stmt|;
comment|/* Use the minimum of the small and large buffer method for primary */
name|small
operator|=
operator|(
operator|(
name|clock
operator|*
name|pixel_size
operator|/
literal|1000
operator|)
operator|*
name|latency_ns
operator|)
operator|/
literal|1000
expr_stmt|;
name|large
operator|=
name|line_count
operator|*
name|line_size
expr_stmt|;
name|entries
operator|=
name|howmany
argument_list|(
name|min
argument_list|(
name|small
argument_list|,
name|large
argument_list|)
argument_list|,
name|display
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|display_wm
operator|=
name|entries
operator|+
name|display
operator|->
name|guard_size
expr_stmt|;
comment|/* calculate the self-refresh watermark for display cursor */
name|entries
operator|=
name|line_count
operator|*
name|pixel_size
operator|*
literal|64
expr_stmt|;
name|entries
operator|=
name|howmany
argument_list|(
name|entries
argument_list|,
name|cursor
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|cursor_wm
operator|=
name|entries
operator|+
name|cursor
operator|->
name|guard_size
expr_stmt|;
return|return
name|g4x_check_srwm
argument_list|(
name|dev
argument_list|,
operator|*
name|display_wm
argument_list|,
operator|*
name|cursor_wm
argument_list|,
name|display
argument_list|,
name|cursor
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|single_plane_enabled
parameter_list|(
name|mask
parameter_list|)
value|((mask) != 0&& powerof2(mask))
end_define

begin_function
specifier|static
name|void
name|g4x_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|sr_latency_ns
init|=
literal|12000
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|planea_wm
decl_stmt|,
name|planeb_wm
decl_stmt|,
name|cursora_wm
decl_stmt|,
name|cursorb_wm
decl_stmt|;
name|int
name|plane_sr
decl_stmt|,
name|cursor_sr
decl_stmt|;
name|unsigned
name|int
name|enabled
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|g4x_wm_info
argument_list|,
name|latency_ns
argument_list|,
operator|&
name|g4x_cursor_wm_info
argument_list|,
name|latency_ns
argument_list|,
operator|&
name|planea_wm
argument_list|,
operator|&
name|cursora_wm
argument_list|)
condition|)
name|enabled
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
operator|&
name|g4x_wm_info
argument_list|,
name|latency_ns
argument_list|,
operator|&
name|g4x_cursor_wm_info
argument_list|,
name|latency_ns
argument_list|,
operator|&
name|planeb_wm
argument_list|,
operator|&
name|cursorb_wm
argument_list|)
condition|)
name|enabled
operator||=
literal|2
expr_stmt|;
name|plane_sr
operator|=
name|cursor_sr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|single_plane_enabled
argument_list|(
name|enabled
argument_list|)
operator|&&
name|g4x_compute_srwm
argument_list|(
name|dev
argument_list|,
name|ffs
argument_list|(
name|enabled
argument_list|)
operator|-
literal|1
argument_list|,
name|sr_latency_ns
argument_list|,
operator|&
name|g4x_wm_info
argument_list|,
operator|&
name|g4x_cursor_wm_info
argument_list|,
operator|&
name|plane_sr
argument_list|,
operator|&
name|cursor_sr
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|FW_BLC_SELF_EN
argument_list|)
expr_stmt|;
else|else
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|I915_READ
argument_list|(
name|FW_BLC_SELF
argument_list|)
operator|&
operator|~
name|FW_BLC_SELF_EN
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Setting FIFO watermarks - A: plane=%d, cursor=%d, B: plane=%d, cursor=%d, SR: plane=%d, cursor=%d\n"
argument_list|,
name|planea_wm
argument_list|,
name|cursora_wm
argument_list|,
name|planeb_wm
argument_list|,
name|cursorb_wm
argument_list|,
name|plane_sr
argument_list|,
name|cursor_sr
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW1
argument_list|,
operator|(
name|plane_sr
operator|<<
name|DSPFW_SR_SHIFT
operator|)
operator||
operator|(
name|cursorb_wm
operator|<<
name|DSPFW_CURSORB_SHIFT
operator|)
operator||
operator|(
name|planeb_wm
operator|<<
name|DSPFW_PLANEB_SHIFT
operator|)
operator||
name|planea_wm
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW2
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|DSPFW2
argument_list|)
operator|&
name|DSPFW_CURSORA_MASK
operator|)
operator||
operator|(
name|cursora_wm
operator|<<
name|DSPFW_CURSORA_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* HPLL off in SR has some issues on G4x... disable it */
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|DSPFW3
argument_list|)
operator|&
operator|~
name|DSPFW_HPLL_SR_EN
operator|)
operator||
operator|(
name|cursor_sr
operator|<<
name|DSPFW_CURSOR_SR_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i965_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|int
name|srwm
init|=
literal|1
decl_stmt|;
name|int
name|cursor_sr
init|=
literal|16
decl_stmt|;
comment|/* Calc sr entries for one plane configs */
name|crtc
operator|=
name|single_enabled_crtc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
condition|)
block|{
comment|/* self-refresh has much higher latency */
specifier|static
specifier|const
name|int
name|sr_latency_ns
init|=
literal|12000
decl_stmt|;
name|int
name|clock
init|=
name|crtc
operator|->
name|mode
operator|.
name|clock
decl_stmt|;
name|int
name|htotal
init|=
name|crtc
operator|->
name|mode
operator|.
name|htotal
decl_stmt|;
name|int
name|hdisplay
init|=
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
decl_stmt|;
name|int
name|pixel_size
init|=
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
decl_stmt|;
name|unsigned
name|long
name|line_time_us
decl_stmt|;
name|int
name|entries
decl_stmt|;
name|line_time_us
operator|=
operator|(
operator|(
name|htotal
operator|*
literal|1000
operator|)
operator|/
name|clock
operator|)
expr_stmt|;
comment|/* Use ns/us then divide to preserve precision */
name|entries
operator|=
operator|(
operator|(
operator|(
name|sr_latency_ns
operator|/
name|line_time_us
operator|)
operator|+
literal|1000
operator|)
operator|/
literal|1000
operator|)
operator|*
name|pixel_size
operator|*
name|hdisplay
expr_stmt|;
name|entries
operator|=
name|howmany
argument_list|(
name|entries
argument_list|,
name|I915_FIFO_LINE_SIZE
argument_list|)
expr_stmt|;
name|srwm
operator|=
name|I965_FIFO_SIZE
operator|-
name|entries
expr_stmt|;
if|if
condition|(
name|srwm
operator|<
literal|0
condition|)
name|srwm
operator|=
literal|1
expr_stmt|;
name|srwm
operator|&=
literal|0x1ff
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"self-refresh entries: %d, wm: %d\n"
argument_list|,
name|entries
argument_list|,
name|srwm
argument_list|)
expr_stmt|;
name|entries
operator|=
operator|(
operator|(
operator|(
name|sr_latency_ns
operator|/
name|line_time_us
operator|)
operator|+
literal|1000
operator|)
operator|/
literal|1000
operator|)
operator|*
name|pixel_size
operator|*
literal|64
expr_stmt|;
name|entries
operator|=
name|howmany
argument_list|(
name|entries
argument_list|,
name|i965_cursor_wm_info
operator|.
name|cacheline_size
argument_list|)
expr_stmt|;
name|cursor_sr
operator|=
name|i965_cursor_wm_info
operator|.
name|fifo_size
operator|-
operator|(
name|entries
operator|+
name|i965_cursor_wm_info
operator|.
name|guard_size
operator|)
expr_stmt|;
if|if
condition|(
name|cursor_sr
operator|>
name|i965_cursor_wm_info
operator|.
name|max_wm
condition|)
name|cursor_sr
operator|=
name|i965_cursor_wm_info
operator|.
name|max_wm
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"self-refresh watermark: display plane %d "
literal|"cursor %d\n"
argument_list|,
name|srwm
argument_list|,
name|cursor_sr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CRESTLINE
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|FW_BLC_SELF_EN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Turn off self refresh if both pipes are enabled */
if|if
condition|(
name|IS_CRESTLINE
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|I915_READ
argument_list|(
name|FW_BLC_SELF
argument_list|)
operator|&
operator|~
name|FW_BLC_SELF_EN
argument_list|)
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"Setting FIFO watermarks - A: 8, B: 8, C: 8, SR %d\n"
argument_list|,
name|srwm
argument_list|)
expr_stmt|;
comment|/* 965 has limitations... */
name|I915_WRITE
argument_list|(
name|DSPFW1
argument_list|,
operator|(
name|srwm
operator|<<
name|DSPFW_SR_SHIFT
operator|)
operator||
operator|(
literal|8
operator|<<
literal|16
operator|)
operator||
operator|(
literal|8
operator|<<
literal|8
operator|)
operator||
operator|(
literal|8
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW2
argument_list|,
operator|(
literal|8
operator|<<
literal|8
operator|)
operator||
operator|(
literal|8
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* update cursor SR watermark */
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
operator|(
name|cursor_sr
operator|<<
name|DSPFW_CURSOR_SR_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|wm_info
decl_stmt|;
name|uint32_t
name|fwater_lo
decl_stmt|;
name|uint32_t
name|fwater_hi
decl_stmt|;
name|int
name|cwm
decl_stmt|,
name|srwm
init|=
literal|1
decl_stmt|;
name|int
name|fifo_size
decl_stmt|;
name|int
name|planea_wm
decl_stmt|,
name|planeb_wm
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|,
modifier|*
name|enabled
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
condition|)
name|wm_info
operator|=
operator|&
name|i945_wm_info
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|wm_info
operator|=
operator|&
name|i915_wm_info
expr_stmt|;
else|else
name|wm_info
operator|=
operator|&
name|i855_wm_info
expr_stmt|;
name|fifo_size
operator|=
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|enabled
operator|&&
name|crtc
operator|->
name|fb
condition|)
block|{
name|planea_wm
operator|=
name|intel_calculate_wm
argument_list|(
name|crtc
operator|->
name|mode
operator|.
name|clock
argument_list|,
name|wm_info
argument_list|,
name|fifo_size
argument_list|,
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
argument_list|,
name|latency_ns
argument_list|)
expr_stmt|;
name|enabled
operator|=
name|crtc
expr_stmt|;
block|}
else|else
name|planea_wm
operator|=
name|fifo_size
operator|-
name|wm_info
operator|->
name|guard_size
expr_stmt|;
name|fifo_size
operator|=
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|enabled
operator|&&
name|crtc
operator|->
name|fb
condition|)
block|{
name|planeb_wm
operator|=
name|intel_calculate_wm
argument_list|(
name|crtc
operator|->
name|mode
operator|.
name|clock
argument_list|,
name|wm_info
argument_list|,
name|fifo_size
argument_list|,
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
argument_list|,
name|latency_ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabled
operator|==
name|NULL
condition|)
name|enabled
operator|=
name|crtc
expr_stmt|;
else|else
name|enabled
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|planeb_wm
operator|=
name|fifo_size
operator|-
name|wm_info
operator|->
name|guard_size
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermarks - A: %d, B: %d\n"
argument_list|,
name|planea_wm
argument_list|,
name|planeb_wm
argument_list|)
expr_stmt|;
comment|/* 	 * Overlay gets an aggressive default since video jitter is bad. 	 */
name|cwm
operator|=
literal|2
expr_stmt|;
comment|/* Play safe and disable self-refresh before adjusting watermarks. */
if|if
condition|(
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|FW_BLC_SELF_EN_MASK
operator||
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I915GM
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|INSTPM
argument_list|,
name|I915_READ
argument_list|(
name|INSTPM
argument_list|)
operator|&
operator|~
name|INSTPM_SELF_EN
argument_list|)
expr_stmt|;
comment|/* Calc sr entries for one plane configs */
if|if
condition|(
name|HAS_FW_BLC
argument_list|(
name|dev
argument_list|)
operator|&&
name|enabled
condition|)
block|{
comment|/* self-refresh has much higher latency */
specifier|static
specifier|const
name|int
name|sr_latency_ns
init|=
literal|6000
decl_stmt|;
name|int
name|clock
init|=
name|enabled
operator|->
name|mode
operator|.
name|clock
decl_stmt|;
name|int
name|htotal
init|=
name|enabled
operator|->
name|mode
operator|.
name|htotal
decl_stmt|;
name|int
name|hdisplay
init|=
name|enabled
operator|->
name|mode
operator|.
name|hdisplay
decl_stmt|;
name|int
name|pixel_size
init|=
name|enabled
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
decl_stmt|;
name|unsigned
name|long
name|line_time_us
decl_stmt|;
name|int
name|entries
decl_stmt|;
name|line_time_us
operator|=
operator|(
name|htotal
operator|*
literal|1000
operator|)
operator|/
name|clock
expr_stmt|;
comment|/* Use ns/us then divide to preserve precision */
name|entries
operator|=
operator|(
operator|(
operator|(
name|sr_latency_ns
operator|/
name|line_time_us
operator|)
operator|+
literal|1000
operator|)
operator|/
literal|1000
operator|)
operator|*
name|pixel_size
operator|*
name|hdisplay
expr_stmt|;
name|entries
operator|=
name|howmany
argument_list|(
name|entries
argument_list|,
name|wm_info
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"self-refresh entries: %d\n"
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|srwm
operator|=
name|wm_info
operator|->
name|fifo_size
operator|-
name|entries
expr_stmt|;
if|if
condition|(
name|srwm
operator|<
literal|0
condition|)
name|srwm
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|FW_BLC_SELF_FIFO_MASK
operator||
operator|(
name|srwm
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I915GM
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|srwm
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"Setting FIFO watermarks - A: %d, B: %d, C: %d, SR %d\n"
argument_list|,
name|planea_wm
argument_list|,
name|planeb_wm
argument_list|,
name|cwm
argument_list|,
name|srwm
argument_list|)
expr_stmt|;
name|fwater_lo
operator|=
operator|(
operator|(
name|planeb_wm
operator|&
literal|0x3f
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|planea_wm
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|fwater_hi
operator|=
operator|(
name|cwm
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* Set request length to 8 cachelines per fetch */
name|fwater_lo
operator|=
name|fwater_lo
operator||
operator|(
literal|1
operator|<<
literal|24
operator|)
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|fwater_hi
operator|=
name|fwater_hi
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FW_BLC
argument_list|,
name|fwater_lo
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FW_BLC2
argument_list|,
name|fwater_hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FW_BLC
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|enabled
condition|)
block|{
if|if
condition|(
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|FW_BLC_SELF_EN_MASK
operator||
name|FW_BLC_SELF_EN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I915GM
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|INSTPM
argument_list|,
name|I915_READ
argument_list|(
name|INSTPM
argument_list|)
operator||
name|INSTPM_SELF_EN
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"memory self refresh enabled\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|DRM_DEBUG_KMS
argument_list|(
literal|"memory self refresh disabled\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i830_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|uint32_t
name|fwater_lo
decl_stmt|;
name|int
name|planea_wm
decl_stmt|;
name|crtc
operator|=
name|single_enabled_crtc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|==
name|NULL
condition|)
return|return;
name|planea_wm
operator|=
name|intel_calculate_wm
argument_list|(
name|crtc
operator|->
name|mode
operator|.
name|clock
argument_list|,
operator|&
name|i830_wm_info
argument_list|,
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
argument_list|,
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
argument_list|,
name|latency_ns
argument_list|)
expr_stmt|;
name|fwater_lo
operator|=
name|I915_READ
argument_list|(
name|FW_BLC
argument_list|)
operator|&
operator|~
literal|0xfff
expr_stmt|;
name|fwater_lo
operator||=
operator|(
literal|3
operator|<<
literal|8
operator|)
operator||
name|planea_wm
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Setting FIFO watermarks - A: %d\n"
argument_list|,
name|planea_wm
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FW_BLC
argument_list|,
name|fwater_lo
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ILK_LP0_PLANE_LATENCY
value|700
end_define

begin_define
define|#
directive|define
name|ILK_LP0_CURSOR_LATENCY
value|1300
end_define

begin_comment
comment|/*  * Check the wm result.  *  * If any calculated watermark values is larger than the maximum value that  * can be programmed into the associated watermark register, that watermark  * must be disabled.  */
end_comment

begin_function
specifier|static
name|bool
name|ironlake_check_srwm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|fbc_wm
parameter_list|,
name|int
name|display_wm
parameter_list|,
name|int
name|cursor_wm
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|display
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|cursor
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"watermark %d: display plane %d, fbc lines %d,"
literal|" cursor %d\n"
argument_list|,
name|level
argument_list|,
name|display_wm
argument_list|,
name|fbc_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
if|if
condition|(
name|fbc_wm
operator|>
name|SNB_FBC_MAX_SRWM
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"fbc watermark(%d) is too large(%d), disabling wm%d+\n"
argument_list|,
name|fbc_wm
argument_list|,
name|SNB_FBC_MAX_SRWM
argument_list|,
name|level
argument_list|)
expr_stmt|;
comment|/* fbc has it's own way to disable FBC WM */
name|I915_WRITE
argument_list|(
name|DISP_ARB_CTL
argument_list|,
name|I915_READ
argument_list|(
name|DISP_ARB_CTL
argument_list|)
operator||
name|DISP_FBC_WM_DIS
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|display_wm
operator|>
name|display
operator|->
name|max_wm
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"display watermark(%d) is too large(%d), disabling wm%d+\n"
argument_list|,
name|display_wm
argument_list|,
name|SNB_DISPLAY_MAX_SRWM
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|cursor_wm
operator|>
name|cursor
operator|->
name|max_wm
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"cursor watermark(%d) is too large(%d), disabling wm%d+\n"
argument_list|,
name|cursor_wm
argument_list|,
name|SNB_CURSOR_MAX_SRWM
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|fbc_wm
operator|||
name|display_wm
operator|||
name|cursor_wm
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"latency %d is 0, disabling wm%d+\n"
argument_list|,
name|level
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * Compute watermark values of WM[1-3],  */
end_comment

begin_function
specifier|static
name|bool
name|ironlake_compute_srwm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|plane
parameter_list|,
name|int
name|latency_ns
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|display
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|cursor
parameter_list|,
name|int
modifier|*
name|fbc_wm
parameter_list|,
name|int
modifier|*
name|display_wm
parameter_list|,
name|int
modifier|*
name|cursor_wm
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|unsigned
name|long
name|line_time_us
decl_stmt|;
name|int
name|hdisplay
decl_stmt|,
name|htotal
decl_stmt|,
name|pixel_size
decl_stmt|,
name|clock
decl_stmt|;
name|int
name|line_count
decl_stmt|,
name|line_size
decl_stmt|;
name|int
name|small
decl_stmt|,
name|large
decl_stmt|;
name|int
name|entries
decl_stmt|;
if|if
condition|(
operator|!
name|latency_ns
condition|)
block|{
operator|*
name|fbc_wm
operator|=
operator|*
name|display_wm
operator|=
operator|*
name|cursor_wm
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|hdisplay
operator|=
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
expr_stmt|;
name|htotal
operator|=
name|crtc
operator|->
name|mode
operator|.
name|htotal
expr_stmt|;
name|clock
operator|=
name|crtc
operator|->
name|mode
operator|.
name|clock
expr_stmt|;
name|pixel_size
operator|=
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
expr_stmt|;
name|line_time_us
operator|=
operator|(
name|htotal
operator|*
literal|1000
operator|)
operator|/
name|clock
expr_stmt|;
name|line_count
operator|=
operator|(
name|latency_ns
operator|/
name|line_time_us
operator|+
literal|1000
operator|)
operator|/
literal|1000
expr_stmt|;
name|line_size
operator|=
name|hdisplay
operator|*
name|pixel_size
expr_stmt|;
comment|/* Use the minimum of the small and large buffer method for primary */
name|small
operator|=
operator|(
operator|(
name|clock
operator|*
name|pixel_size
operator|/
literal|1000
operator|)
operator|*
name|latency_ns
operator|)
operator|/
literal|1000
expr_stmt|;
name|large
operator|=
name|line_count
operator|*
name|line_size
expr_stmt|;
name|entries
operator|=
name|howmany
argument_list|(
name|min
argument_list|(
name|small
argument_list|,
name|large
argument_list|)
argument_list|,
name|display
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|display_wm
operator|=
name|entries
operator|+
name|display
operator|->
name|guard_size
expr_stmt|;
comment|/* 	 * Spec says: 	 * FBC WM = ((Final Primary WM * 64) / number of bytes per line) + 2 	 */
operator|*
name|fbc_wm
operator|=
name|howmany
argument_list|(
operator|*
name|display_wm
operator|*
literal|64
argument_list|,
name|line_size
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* calculate the self-refresh watermark for display cursor */
name|entries
operator|=
name|line_count
operator|*
name|pixel_size
operator|*
literal|64
expr_stmt|;
name|entries
operator|=
name|howmany
argument_list|(
name|entries
argument_list|,
name|cursor
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|cursor_wm
operator|=
name|entries
operator|+
name|cursor
operator|->
name|guard_size
expr_stmt|;
return|return
name|ironlake_check_srwm
argument_list|(
name|dev
argument_list|,
name|level
argument_list|,
operator|*
name|fbc_wm
argument_list|,
operator|*
name|display_wm
argument_list|,
operator|*
name|cursor_wm
argument_list|,
name|display
argument_list|,
name|cursor
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|fbc_wm
decl_stmt|,
name|plane_wm
decl_stmt|,
name|cursor_wm
decl_stmt|;
name|unsigned
name|int
name|enabled
decl_stmt|;
name|enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|ironlake_display_wm_info
argument_list|,
name|ILK_LP0_PLANE_LATENCY
argument_list|,
operator|&
name|ironlake_cursor_wm_info
argument_list|,
name|ILK_LP0_CURSOR_LATENCY
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|WM0_PIPEA_ILK
argument_list|,
operator|(
name|plane_wm
operator|<<
name|WM0_PIPE_PLANE_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermarks For pipe A -"
literal|" plane %d, "
literal|"cursor: %d\n"
argument_list|,
name|plane_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
name|enabled
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
operator|&
name|ironlake_display_wm_info
argument_list|,
name|ILK_LP0_PLANE_LATENCY
argument_list|,
operator|&
name|ironlake_cursor_wm_info
argument_list|,
name|ILK_LP0_CURSOR_LATENCY
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|WM0_PIPEB_ILK
argument_list|,
operator|(
name|plane_wm
operator|<<
name|WM0_PIPE_PLANE_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermarks For pipe B -"
literal|" plane %d, cursor: %d\n"
argument_list|,
name|plane_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
name|enabled
operator||=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Calculate and update the self-refresh watermark only when one 	 * display plane is used. 	 */
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|single_plane_enabled
argument_list|(
name|enabled
argument_list|)
condition|)
return|return;
name|enabled
operator|=
name|ffs
argument_list|(
name|enabled
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* WM1 */
if|if
condition|(
operator|!
name|ironlake_compute_srwm
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
name|enabled
argument_list|,
name|ILK_READ_WM1_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|ironlake_display_srwm_info
argument_list|,
operator|&
name|ironlake_cursor_srwm_info
argument_list|,
operator|&
name|fbc_wm
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
name|WM1_LP_SR_EN
operator||
operator|(
name|ILK_READ_WM1_LATENCY
argument_list|()
operator|<<
name|WM1_LP_LATENCY_SHIFT
operator|)
operator||
operator|(
name|fbc_wm
operator|<<
name|WM1_LP_FBC_SHIFT
operator|)
operator||
operator|(
name|plane_wm
operator|<<
name|WM1_LP_SR_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
comment|/* WM2 */
if|if
condition|(
operator|!
name|ironlake_compute_srwm
argument_list|(
name|dev
argument_list|,
literal|2
argument_list|,
name|enabled
argument_list|,
name|ILK_READ_WM2_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|ironlake_display_srwm_info
argument_list|,
operator|&
name|ironlake_cursor_srwm_info
argument_list|,
operator|&
name|fbc_wm
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
name|WM2_LP_EN
operator||
operator|(
name|ILK_READ_WM2_LATENCY
argument_list|()
operator|<<
name|WM1_LP_LATENCY_SHIFT
operator|)
operator||
operator|(
name|fbc_wm
operator|<<
name|WM1_LP_FBC_SHIFT
operator|)
operator||
operator|(
name|plane_wm
operator|<<
name|WM1_LP_SR_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
comment|/* 	 * WM3 is unsupported on ILK, probably because we don't have latency 	 * data for that power state 	 */
block|}
end_function

begin_function
name|void
name|sandybridge_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|latency
init|=
name|SNB_READ_WM0_LATENCY
argument_list|()
operator|*
literal|100
decl_stmt|;
comment|/* In unit 0.1us */
name|u32
name|val
decl_stmt|;
name|int
name|fbc_wm
decl_stmt|,
name|plane_wm
decl_stmt|,
name|cursor_wm
decl_stmt|;
name|unsigned
name|int
name|enabled
decl_stmt|;
name|enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|sandybridge_display_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|sandybridge_cursor_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
block|{
name|val
operator|=
name|I915_READ
argument_list|(
name|WM0_PIPEA_ILK
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|WM0_PIPE_PLANE_MASK
operator||
name|WM0_PIPE_CURSOR_MASK
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM0_PIPEA_ILK
argument_list|,
name|val
operator||
operator|(
operator|(
name|plane_wm
operator|<<
name|WM0_PIPE_PLANE_SHIFT
operator|)
operator||
name|cursor_wm
operator|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermarks For pipe A -"
literal|" plane %d, "
literal|"cursor: %d\n"
argument_list|,
name|plane_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
name|enabled
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
operator|&
name|sandybridge_display_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|sandybridge_cursor_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
block|{
name|val
operator|=
name|I915_READ
argument_list|(
name|WM0_PIPEB_ILK
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|WM0_PIPE_PLANE_MASK
operator||
name|WM0_PIPE_CURSOR_MASK
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM0_PIPEB_ILK
argument_list|,
name|val
operator||
operator|(
operator|(
name|plane_wm
operator|<<
name|WM0_PIPE_PLANE_SHIFT
operator|)
operator||
name|cursor_wm
operator|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermarks For pipe B -"
literal|" plane %d, cursor: %d\n"
argument_list|,
name|plane_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
name|enabled
operator||=
literal|2
expr_stmt|;
block|}
comment|/* IVB has 3 pipes */
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
operator|&&
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|2
argument_list|,
operator|&
name|sandybridge_display_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|sandybridge_cursor_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
block|{
name|val
operator|=
name|I915_READ
argument_list|(
name|WM0_PIPEC_IVB
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|WM0_PIPE_PLANE_MASK
operator||
name|WM0_PIPE_CURSOR_MASK
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM0_PIPEC_IVB
argument_list|,
name|val
operator||
operator|(
operator|(
name|plane_wm
operator|<<
name|WM0_PIPE_PLANE_SHIFT
operator|)
operator||
name|cursor_wm
operator|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermarks For pipe C -"
literal|" plane %d, cursor: %d\n"
argument_list|,
name|plane_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
name|enabled
operator||=
literal|3
expr_stmt|;
block|}
comment|/* 	 * Calculate and update the self-refresh watermark only when one 	 * display plane is used. 	 * 	 * SNB support 3 levels of watermark. 	 * 	 * WM1/WM2/WM2 watermarks have to be enabled in the ascending order, 	 * and disabled in the descending order 	 * 	 */
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|single_plane_enabled
argument_list|(
name|enabled
argument_list|)
operator|||
name|dev_priv
operator|->
name|sprite_scaling_enabled
condition|)
return|return;
name|enabled
operator|=
name|ffs
argument_list|(
name|enabled
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* WM1 */
if|if
condition|(
operator|!
name|ironlake_compute_srwm
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
name|enabled
argument_list|,
name|SNB_READ_WM1_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
operator|&
name|sandybridge_cursor_srwm_info
argument_list|,
operator|&
name|fbc_wm
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
name|WM1_LP_SR_EN
operator||
operator|(
name|SNB_READ_WM1_LATENCY
argument_list|()
operator|<<
name|WM1_LP_LATENCY_SHIFT
operator|)
operator||
operator|(
name|fbc_wm
operator|<<
name|WM1_LP_FBC_SHIFT
operator|)
operator||
operator|(
name|plane_wm
operator|<<
name|WM1_LP_SR_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
comment|/* WM2 */
if|if
condition|(
operator|!
name|ironlake_compute_srwm
argument_list|(
name|dev
argument_list|,
literal|2
argument_list|,
name|enabled
argument_list|,
name|SNB_READ_WM2_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
operator|&
name|sandybridge_cursor_srwm_info
argument_list|,
operator|&
name|fbc_wm
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
name|WM2_LP_EN
operator||
operator|(
name|SNB_READ_WM2_LATENCY
argument_list|()
operator|<<
name|WM1_LP_LATENCY_SHIFT
operator|)
operator||
operator|(
name|fbc_wm
operator|<<
name|WM1_LP_FBC_SHIFT
operator|)
operator||
operator|(
name|plane_wm
operator|<<
name|WM1_LP_SR_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
comment|/* WM3 */
if|if
condition|(
operator|!
name|ironlake_compute_srwm
argument_list|(
name|dev
argument_list|,
literal|3
argument_list|,
name|enabled
argument_list|,
name|SNB_READ_WM3_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
operator|&
name|sandybridge_cursor_srwm_info
argument_list|,
operator|&
name|fbc_wm
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
name|WM3_LP_EN
operator||
operator|(
name|SNB_READ_WM3_LATENCY
argument_list|()
operator|<<
name|WM1_LP_LATENCY_SHIFT
operator|)
operator||
operator|(
name|fbc_wm
operator|<<
name|WM1_LP_FBC_SHIFT
operator|)
operator||
operator|(
name|plane_wm
operator|<<
name|WM1_LP_SR_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|sandybridge_compute_sprite_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|,
name|uint32_t
name|sprite_width
parameter_list|,
name|int
name|pixel_size
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|display
parameter_list|,
name|int
name|display_latency_ns
parameter_list|,
name|int
modifier|*
name|sprite_wm
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|int
name|clock
decl_stmt|;
name|int
name|entries
decl_stmt|,
name|tlb_miss
decl_stmt|;
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
name|plane
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|fb
operator|==
name|NULL
operator|||
operator|!
name|crtc
operator|->
name|enabled
condition|)
block|{
operator|*
name|sprite_wm
operator|=
name|display
operator|->
name|guard_size
expr_stmt|;
return|return
name|false
return|;
block|}
name|clock
operator|=
name|crtc
operator|->
name|mode
operator|.
name|clock
expr_stmt|;
comment|/* Use the small buffer method to calculate the sprite watermark */
name|entries
operator|=
operator|(
operator|(
name|clock
operator|*
name|pixel_size
operator|/
literal|1000
operator|)
operator|*
name|display_latency_ns
operator|)
operator|/
literal|1000
expr_stmt|;
name|tlb_miss
operator|=
name|display
operator|->
name|fifo_size
operator|*
name|display
operator|->
name|cacheline_size
operator|-
name|sprite_width
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|tlb_miss
operator|>
literal|0
condition|)
name|entries
operator|+=
name|tlb_miss
expr_stmt|;
name|entries
operator|=
name|howmany
argument_list|(
name|entries
argument_list|,
name|display
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|sprite_wm
operator|=
name|entries
operator|+
name|display
operator|->
name|guard_size
expr_stmt|;
if|if
condition|(
operator|*
name|sprite_wm
operator|>
operator|(
name|int
operator|)
name|display
operator|->
name|max_wm
condition|)
operator|*
name|sprite_wm
operator|=
name|display
operator|->
name|max_wm
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|sandybridge_compute_sprite_srwm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|,
name|uint32_t
name|sprite_width
parameter_list|,
name|int
name|pixel_size
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|display
parameter_list|,
name|int
name|latency_ns
parameter_list|,
name|int
modifier|*
name|sprite_wm
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|unsigned
name|long
name|line_time_us
decl_stmt|;
name|int
name|clock
decl_stmt|;
name|int
name|line_count
decl_stmt|,
name|line_size
decl_stmt|;
name|int
name|small
decl_stmt|,
name|large
decl_stmt|;
name|int
name|entries
decl_stmt|;
if|if
condition|(
operator|!
name|latency_ns
condition|)
block|{
operator|*
name|sprite_wm
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|clock
operator|=
name|crtc
operator|->
name|mode
operator|.
name|clock
expr_stmt|;
if|if
condition|(
operator|!
name|clock
condition|)
block|{
operator|*
name|sprite_wm
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
name|line_time_us
operator|=
operator|(
name|sprite_width
operator|*
literal|1000
operator|)
operator|/
name|clock
expr_stmt|;
if|if
condition|(
operator|!
name|line_time_us
condition|)
block|{
operator|*
name|sprite_wm
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
name|line_count
operator|=
operator|(
name|latency_ns
operator|/
name|line_time_us
operator|+
literal|1000
operator|)
operator|/
literal|1000
expr_stmt|;
name|line_size
operator|=
name|sprite_width
operator|*
name|pixel_size
expr_stmt|;
comment|/* Use the minimum of the small and large buffer method for primary */
name|small
operator|=
operator|(
operator|(
name|clock
operator|*
name|pixel_size
operator|/
literal|1000
operator|)
operator|*
name|latency_ns
operator|)
operator|/
literal|1000
expr_stmt|;
name|large
operator|=
name|line_count
operator|*
name|line_size
expr_stmt|;
name|entries
operator|=
name|howmany
argument_list|(
name|min
argument_list|(
name|small
argument_list|,
name|large
argument_list|)
argument_list|,
name|display
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|sprite_wm
operator|=
name|entries
operator|+
name|display
operator|->
name|guard_size
expr_stmt|;
return|return
operator|*
name|sprite_wm
operator|>
literal|0x3ff
condition|?
name|false
else|:
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sandybridge_update_sprite_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|,
name|uint32_t
name|sprite_width
parameter_list|,
name|int
name|pixel_size
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|latency
init|=
name|SNB_READ_WM0_LATENCY
argument_list|()
operator|*
literal|100
decl_stmt|;
comment|/* In unit 0.1us */
name|u32
name|val
decl_stmt|;
name|int
name|sprite_wm
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
case|case
literal|0
case|:
name|reg
operator|=
name|WM0_PIPEA_ILK
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|reg
operator|=
name|WM0_PIPEB_ILK
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|reg
operator|=
name|WM0_PIPEC_IVB
expr_stmt|;
break|break;
default|default:
return|return;
comment|/* bad pipe */
block|}
name|ret
operator|=
name|sandybridge_compute_sprite_wm
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|sprite_width
argument_list|,
name|pixel_size
argument_list|,
operator|&
name|sandybridge_display_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|sprite_wm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"failed to compute sprite wm for pipe %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return;
block|}
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|WM0_PIPE_SPRITE_MASK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator||
operator|(
name|sprite_wm
operator|<<
name|WM0_PIPE_SPRITE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"sprite watermarks For pipe %d - %d\n"
argument_list|,
name|pipe
argument_list|,
name|sprite_wm
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sandybridge_compute_sprite_srwm
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|sprite_width
argument_list|,
name|pixel_size
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
name|SNB_READ_WM1_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sprite_wm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"failed to compute sprite lp1 wm on pipe %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return;
block|}
name|I915_WRITE
argument_list|(
name|WM1S_LP_ILK
argument_list|,
name|sprite_wm
argument_list|)
expr_stmt|;
comment|/* Only IVB has two more LP watermarks for sprite */
if|if
condition|(
operator|!
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|ret
operator|=
name|sandybridge_compute_sprite_srwm
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|sprite_width
argument_list|,
name|pixel_size
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
name|SNB_READ_WM2_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sprite_wm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"failed to compute sprite lp2 wm on pipe %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return;
block|}
name|I915_WRITE
argument_list|(
name|WM2S_LP_IVB
argument_list|,
name|sprite_wm
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sandybridge_compute_sprite_srwm
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|sprite_width
argument_list|,
name|pixel_size
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
name|SNB_READ_WM3_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sprite_wm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"failed to compute sprite lp3 wm on pipe %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return;
block|}
name|I915_WRITE
argument_list|(
name|WM3S_LP_IVB
argument_list|,
name|sprite_wm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_update_watermarks - update FIFO watermark values based on current modes  *  * Calculate watermark values for the various WM regs based on current mode  * and plane configuration.  *  * There are several cases to deal with here:  *   - normal (i.e. non-self-refresh)  *   - self-refresh (SR) mode  *   - lines are large relative to FIFO size (buffer can hold up to 2)  *   - lines are small relative to FIFO size (buffer can hold more than 2  *     lines), so need to account for TLB latency  *  *   The normal calculation is:  *     watermark = dotclock * bytes per pixel * latency  *   where latency is platform& configuration dependent (we assume pessimal  *   values here).  *  *   The SR calculation is:  *     watermark = (trunc(latency/line time)+1) * surface width *  *       bytes per pixel  *   where  *     line time = htotal / dotclock  *     surface width = hdisplay for normal plane and 64 for cursor  *   and latency is assumed to be high, as above.  *  * The final value programmed to the register should always be rounded up,  * and include an extra 2 entries to account for clock crossings.  *  * We don't use the sprite, so we can ignore that.  And on Crestline we have  * to set the non-SR watermarks to 8.  */
end_comment

begin_function
specifier|static
name|void
name|intel_update_watermarks
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_update_sprite_watermarks
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|,
name|uint32_t
name|sprite_width
parameter_list|,
name|int
name|pixel_size
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|display
operator|.
name|update_sprite_wm
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|update_sprite_wm
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|sprite_width
argument_list|,
name|pixel_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|intel_panel_use_ssc
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
if|if
condition|(
name|i915_panel_use_ssc
operator|>=
literal|0
condition|)
return|return
name|i915_panel_use_ssc
operator|!=
literal|0
return|;
return|return
name|dev_priv
operator|->
name|lvds_use_ssc
operator|&&
operator|!
operator|(
name|dev_priv
operator|->
name|quirks
operator|&
name|QUIRK_LVDS_SSC_DISABLE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * intel_choose_pipe_bpp_dither - figure out what color depth the pipe should send  * @crtc: CRTC structure  * @mode: requested mode  *  * A pipe may be connected to one or more outputs.  Based on the depth of the  * attached framebuffer, choose a good color depth to use on the pipe.  *  * If possible, match the pipe depth to the fb depth.  In some cases, this  * isn't ideal, because the connected output supports a lesser or restricted  * set of depths.  Resolve that here:  *    LVDS typically supports only 6bpc, so clamp down in that case  *    HDMI supports only 8bpc or 12bpc, so clamp to 8bpc with dither for 10bpc  *    Displays may support a restricted set as well, check EDID and clamp as  *      appropriate.  *    DP may want to dither down to 6bpc to fit larger modes  *  * RETURNS:  * Dithering requirement (i.e. false if display bpc and pipe bpc match,  * true if they don't match).  */
end_comment

begin_function
specifier|static
name|bool
name|intel_choose_pipe_bpp_dither
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|unsigned
name|int
modifier|*
name|pipe_bpp
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|unsigned
name|int
name|display_bpc
init|=
name|UINT_MAX
decl_stmt|,
name|bpc
decl_stmt|;
comment|/* Walk the encoders& connectors on this crtc, get min bpc */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
init|=
name|to_intel_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
if|if
condition|(
name|encoder
operator|->
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
if|if
condition|(
name|intel_encoder
operator|->
name|type
operator|==
name|INTEL_OUTPUT_LVDS
condition|)
block|{
name|unsigned
name|int
name|lvds_bpc
decl_stmt|;
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
operator|&
name|LVDS_A3_POWER_MASK
operator|)
operator|==
name|LVDS_A3_POWER_UP
condition|)
name|lvds_bpc
operator|=
literal|8
expr_stmt|;
else|else
name|lvds_bpc
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|lvds_bpc
operator|<
name|display_bpc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"clamping display bpc (was %d) to LVDS (%d)\n"
argument_list|,
name|display_bpc
argument_list|,
name|lvds_bpc
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
name|lvds_bpc
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|intel_encoder
operator|->
name|type
operator|==
name|INTEL_OUTPUT_EDP
condition|)
block|{
comment|/* Use VBT settings if we have an eDP panel */
name|unsigned
name|int
name|edp_bpc
init|=
name|dev_priv
operator|->
name|edp
operator|.
name|bpp
operator|/
literal|3
decl_stmt|;
if|if
condition|(
name|edp_bpc
operator|<
name|display_bpc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"clamping display bpc (was %d) to eDP (%d)\n"
argument_list|,
name|display_bpc
argument_list|,
name|edp_bpc
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
name|edp_bpc
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Not one of the known troublemakers, check the EDID */
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder
operator|!=
name|encoder
condition|)
continue|continue;
comment|/* Don't use an invalid EDID bpc value */
if|if
condition|(
name|connector
operator|->
name|display_info
operator|.
name|bpc
operator|&&
name|connector
operator|->
name|display_info
operator|.
name|bpc
operator|<
name|display_bpc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"clamping display bpc (was %d) to EDID reported max of %d\n"
argument_list|,
name|display_bpc
argument_list|,
name|connector
operator|->
name|display_info
operator|.
name|bpc
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
name|connector
operator|->
name|display_info
operator|.
name|bpc
expr_stmt|;
block|}
block|}
comment|/* 		 * HDMI is either 12 or 8, so if the display lets 10bpc sneak 		 * through, clamp it down.  (Note:>12bpc will be caught below.) 		 */
if|if
condition|(
name|intel_encoder
operator|->
name|type
operator|==
name|INTEL_OUTPUT_HDMI
condition|)
block|{
if|if
condition|(
name|display_bpc
operator|>
literal|8
operator|&&
name|display_bpc
operator|<
literal|12
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"forcing bpc to 12 for HDMI\n"
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
literal|12
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"forcing bpc to 8 for HDMI\n"
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
literal|8
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mode
operator|->
name|private_flags
operator|&
name|INTEL_MODE_DP_FORCE_6BPC
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Dithering DP to 6bpc\n"
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
literal|6
expr_stmt|;
block|}
comment|/* 	 * We could just drive the pipe at the highest bpc all the time and 	 * enable dithering as needed, but that costs bandwidth.  So choose 	 * the minimum value that expresses the full color range of the fb but 	 * also stays within the max display bpc discovered above. 	 */
switch|switch
condition|(
name|crtc
operator|->
name|fb
operator|->
name|depth
condition|)
block|{
case|case
literal|8
case|:
name|bpc
operator|=
literal|8
expr_stmt|;
comment|/* since we go through a colormap */
break|break;
case|case
literal|15
case|:
case|case
literal|16
case|:
name|bpc
operator|=
literal|6
expr_stmt|;
comment|/* min is 18bpp */
break|break;
case|case
literal|24
case|:
name|bpc
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|30
case|:
name|bpc
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|48
case|:
name|bpc
operator|=
literal|12
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG
argument_list|(
literal|"unsupported depth, assuming 24 bits\n"
argument_list|)
expr_stmt|;
name|bpc
operator|=
name|min
argument_list|(
operator|(
name|unsigned
name|int
operator|)
literal|8
argument_list|,
name|display_bpc
argument_list|)
expr_stmt|;
break|break;
block|}
name|display_bpc
operator|=
name|min
argument_list|(
name|display_bpc
argument_list|,
name|bpc
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"setting pipe bpc to %d (max display bpc %d)\n"
argument_list|,
name|bpc
argument_list|,
name|display_bpc
argument_list|)
expr_stmt|;
operator|*
name|pipe_bpp
operator|=
name|display_bpc
operator|*
literal|3
expr_stmt|;
return|return
name|display_bpc
operator|!=
name|bpc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i9xx_get_refclk
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|num_connectors
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|refclk
decl_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|&&
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|num_connectors
operator|<
literal|2
condition|)
block|{
name|refclk
operator|=
name|dev_priv
operator|->
name|lvds_ssc_freq
operator|*
literal|1000
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"using SSC reference clock of %d MHz\n"
argument_list|,
name|refclk
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|refclk
operator|=
literal|96000
expr_stmt|;
block|}
else|else
block|{
name|refclk
operator|=
literal|48000
expr_stmt|;
block|}
return|return
name|refclk
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_adjust_sdvo_tv_clock
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|)
block|{
comment|/* SDVO TV has fixed PLL values depend on its clock range, 	   this mirrors vbios setting. */
if|if
condition|(
name|adjusted_mode
operator|->
name|clock
operator|>=
literal|100000
operator|&&
name|adjusted_mode
operator|->
name|clock
operator|<
literal|140500
condition|)
block|{
name|clock
operator|->
name|p1
operator|=
literal|2
expr_stmt|;
name|clock
operator|->
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|->
name|n
operator|=
literal|3
expr_stmt|;
name|clock
operator|->
name|m1
operator|=
literal|16
expr_stmt|;
name|clock
operator|->
name|m2
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adjusted_mode
operator|->
name|clock
operator|>=
literal|140500
operator|&&
name|adjusted_mode
operator|->
name|clock
operator|<=
literal|200000
condition|)
block|{
name|clock
operator|->
name|p1
operator|=
literal|1
expr_stmt|;
name|clock
operator|->
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|->
name|n
operator|=
literal|6
expr_stmt|;
name|clock
operator|->
name|m1
operator|=
literal|12
expr_stmt|;
name|clock
operator|->
name|m2
operator|=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_update_pll_dividers
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|,
name|intel_clock_t
modifier|*
name|reduced_clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|fp
decl_stmt|,
name|fp2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|fp
operator|=
operator|(
literal|1
operator|<<
name|clock
operator|->
name|n
operator|)
operator|<<
literal|16
operator||
name|clock
operator|->
name|m1
operator|<<
literal|8
operator||
name|clock
operator|->
name|m2
expr_stmt|;
if|if
condition|(
name|reduced_clock
condition|)
name|fp2
operator|=
operator|(
literal|1
operator|<<
name|reduced_clock
operator|->
name|n
operator|)
operator|<<
literal|16
operator||
name|reduced_clock
operator|->
name|m1
operator|<<
literal|8
operator||
name|reduced_clock
operator|->
name|m2
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|clock
operator|->
name|n
operator|<<
literal|16
operator||
name|clock
operator|->
name|m1
operator|<<
literal|8
operator||
name|clock
operator|->
name|m2
expr_stmt|;
if|if
condition|(
name|reduced_clock
condition|)
name|fp2
operator|=
name|reduced_clock
operator|->
name|n
operator|<<
literal|16
operator||
name|reduced_clock
operator|->
name|m1
operator|<<
literal|8
operator||
name|reduced_clock
operator|->
name|m2
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|FP0
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|lowfreq_avail
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|&&
name|reduced_clock
operator|&&
name|i915_powersave
condition|)
block|{
name|I915_WRITE
argument_list|(
name|FP1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|fp2
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|lowfreq_avail
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|I915_WRITE
argument_list|(
name|FP1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|i9xx_crtc_mode_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|int
name|refclk
decl_stmt|,
name|num_connectors
init|=
literal|0
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|,
name|reduced_clock
decl_stmt|;
name|u32
name|dpll
decl_stmt|,
name|dspcntr
decl_stmt|,
name|pipeconf
decl_stmt|,
name|vsyncshift
decl_stmt|;
name|bool
name|ok
decl_stmt|,
name|has_reduced_clock
init|=
name|false
decl_stmt|,
name|is_sdvo
init|=
name|false
decl_stmt|,
name|is_dvo
init|=
name|false
decl_stmt|;
name|bool
name|is_crt
init|=
name|false
decl_stmt|,
name|is_lvds
init|=
name|false
decl_stmt|,
name|is_tv
init|=
name|false
decl_stmt|,
name|is_dp
init|=
name|false
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|u32
name|lvds_sync
init|=
literal|0
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|is_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_SDVO
case|:
case|case
name|INTEL_OUTPUT_HDMI
case|:
name|is_sdvo
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|encoder
operator|->
name|needs_tv_clock
condition|)
name|is_tv
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_DVO
case|:
name|is_dvo
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_TVOUT
case|:
name|is_tv
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_ANALOG
case|:
name|is_crt
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_DISPLAYPORT
case|:
name|is_dp
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|num_connectors
operator|++
expr_stmt|;
block|}
name|refclk
operator|=
name|i9xx_get_refclk
argument_list|(
name|crtc
argument_list|,
name|num_connectors
argument_list|)
expr_stmt|;
comment|/* 	 * Returns a set of divisors for the desired target clock with the given 	 * refclk, or false.  The returned values represent the clock equation: 	 * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2. 	 */
name|limit
operator|=
name|intel_limit
argument_list|(
name|crtc
argument_list|,
name|refclk
argument_list|)
expr_stmt|;
name|ok
operator|=
name|limit
operator|->
name|find_pll
argument_list|(
name|limit
argument_list|,
name|crtc
argument_list|,
name|adjusted_mode
operator|->
name|clock
argument_list|,
name|refclk
argument_list|,
name|NULL
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Couldn't find PLL settings for mode!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Ensure that the cursor is valid for the new mode before changing... */
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_lvds
operator|&&
name|dev_priv
operator|->
name|lvds_downclock_avail
condition|)
block|{
comment|/* 		 * Ensure we match the reduced clock's P to the target clock. 		 * If the clocks don't match, we can't switch the display clock 		 * by using the FP0/FP1. In such case we will disable the LVDS 		 * downclock feature. 		*/
name|has_reduced_clock
operator|=
name|limit
operator|->
name|find_pll
argument_list|(
name|limit
argument_list|,
name|crtc
argument_list|,
name|dev_priv
operator|->
name|lvds_downclock
argument_list|,
name|refclk
argument_list|,
operator|&
name|clock
argument_list|,
operator|&
name|reduced_clock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_sdvo
operator|&&
name|is_tv
condition|)
name|i9xx_adjust_sdvo_tv_clock
argument_list|(
name|adjusted_mode
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
name|i9xx_update_pll_dividers
argument_list|(
name|crtc
argument_list|,
operator|&
name|clock
argument_list|,
name|has_reduced_clock
condition|?
operator|&
name|reduced_clock
else|:
name|NULL
argument_list|)
expr_stmt|;
name|dpll
operator|=
name|DPLL_VGA_MODE_DIS
expr_stmt|;
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_lvds
condition|)
name|dpll
operator||=
name|DPLLB_MODE_LVDS
expr_stmt|;
else|else
name|dpll
operator||=
name|DPLLB_MODE_DAC_SERIAL
expr_stmt|;
if|if
condition|(
name|is_sdvo
condition|)
block|{
name|int
name|pixel_multiplier
init|=
name|intel_mode_get_pixel_multiplier
argument_list|(
name|adjusted_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|pixel_multiplier
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_G33
argument_list|(
name|dev
argument_list|)
condition|)
name|dpll
operator||=
operator|(
name|pixel_multiplier
operator|-
literal|1
operator|)
operator|<<
name|SDVO_MULTIPLIER_SHIFT_HIRES
expr_stmt|;
block|}
name|dpll
operator||=
name|DPLL_DVO_HIGH_SPEED
expr_stmt|;
block|}
if|if
condition|(
name|is_dp
condition|)
name|dpll
operator||=
name|DPLL_DVO_HIGH_SPEED
expr_stmt|;
comment|/* compute bitmask from p1 value */
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|.
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT_PINEVIEW
expr_stmt|;
else|else
block|{
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|.
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT
expr_stmt|;
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
operator|&&
name|has_reduced_clock
condition|)
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|reduced_clock
operator|.
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA1_P1_POST_DIV_SHIFT
expr_stmt|;
block|}
switch|switch
condition|(
name|clock
operator|.
name|p2
condition|)
block|{
case|case
literal|5
case|:
name|dpll
operator||=
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_5
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|dpll
operator||=
name|DPLLB_LVDS_P2_CLOCK_DIV_7
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|dpll
operator||=
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_10
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|dpll
operator||=
name|DPLLB_LVDS_P2_CLOCK_DIV_14
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
name|dpll
operator||=
operator|(
literal|6
operator|<<
name|PLL_LOAD_PULSE_PHASE_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_lvds
condition|)
block|{
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|.
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|clock
operator|.
name|p1
operator|==
literal|2
condition|)
name|dpll
operator||=
name|PLL_P1_DIVIDE_BY_TWO
expr_stmt|;
else|else
name|dpll
operator||=
operator|(
name|clock
operator|.
name|p1
operator|-
literal|2
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT
expr_stmt|;
if|if
condition|(
name|clock
operator|.
name|p2
operator|==
literal|4
condition|)
name|dpll
operator||=
name|PLL_P2_DIVIDE_BY_4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_sdvo
operator|&&
name|is_tv
condition|)
name|dpll
operator||=
name|PLL_REF_INPUT_TVCLKINBC
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tv
condition|)
comment|/* XXX: just matching BIOS for now */
comment|/*	dpll |= PLL_REF_INPUT_TVCLKINBC; */
name|dpll
operator||=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|is_lvds
operator|&&
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|num_connectors
operator|<
literal|2
condition|)
name|dpll
operator||=
name|PLLB_REF_INPUT_SPREADSPECTRUMIN
expr_stmt|;
else|else
name|dpll
operator||=
name|PLL_REF_INPUT_DREFCLK
expr_stmt|;
comment|/* setup pipeconf */
name|pipeconf
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the display plane register */
name|dspcntr
operator|=
name|DISPPLANE_GAMMA_ENABLE
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
literal|0
condition|)
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_SEL_PIPE_MASK
expr_stmt|;
else|else
name|dspcntr
operator||=
name|DISPPLANE_SEL_PIPE_B
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
literal|0
operator|&&
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
condition|)
block|{
comment|/* Enable pixel doubling when the dot clock is> 90% of the (display) 		 * core speed. 		 * 		 * XXX: No double-wide on 915GM pipe B. Is that the only reason for the 		 * pipe == 0 check? 		 */
if|if
condition|(
name|mode
operator|->
name|clock
operator|>
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
argument_list|(
name|dev
argument_list|)
operator|*
literal|9
operator|/
literal|10
condition|)
name|pipeconf
operator||=
name|PIPECONF_DOUBLE_WIDE
expr_stmt|;
else|else
name|pipeconf
operator|&=
operator|~
name|PIPECONF_DOUBLE_WIDE
expr_stmt|;
block|}
comment|/* default to 8bpc */
name|pipeconf
operator|&=
operator|~
operator|(
name|PIPECONF_BPP_MASK
operator||
name|PIPECONF_DITHER_EN
operator|)
expr_stmt|;
if|if
condition|(
name|is_dp
condition|)
block|{
if|if
condition|(
name|mode
operator|->
name|private_flags
operator|&
name|INTEL_MODE_DP_FORCE_6BPC
condition|)
block|{
name|pipeconf
operator||=
name|PIPECONF_BPP_6
operator||
name|PIPECONF_DITHER_EN
operator||
name|PIPECONF_DITHER_TYPE_SP
expr_stmt|;
block|}
block|}
name|dpll
operator||=
name|DPLL_VCO_ENABLE
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Mode for pipe %c:\n"
argument_list|,
name|pipe
operator|==
literal|0
condition|?
literal|'A'
else|:
literal|'B'
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
operator|&
operator|~
name|DPLL_VCO_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* The LVDS pin pair needs to be on before the DPLLs are enabled. 	 * This is an exception to the general rule that mode_set doesn't turn 	 * things on. 	 */
if|if
condition|(
name|is_lvds
condition|)
block|{
name|temp
operator|=
name|I915_READ
argument_list|(
name|LVDS
argument_list|)
expr_stmt|;
name|temp
operator||=
name|LVDS_PORT_EN
operator||
name|LVDS_A0A2_CLKA_POWER_UP
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
literal|1
condition|)
block|{
name|temp
operator||=
name|LVDS_PIPEB_SELECT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|LVDS_PIPEB_SELECT
expr_stmt|;
block|}
comment|/* set the corresponsding LVDS_BORDER bit */
name|temp
operator||=
name|dev_priv
operator|->
name|lvds_border_bits
expr_stmt|;
comment|/* Set the B0-B3 data pairs corresponding to whether we're going to 		 * set the DPLLs for dual-channel mode or not. 		 */
if|if
condition|(
name|clock
operator|.
name|p2
operator|==
literal|7
condition|)
name|temp
operator||=
name|LVDS_B0B3_POWER_UP
operator||
name|LVDS_CLKB_POWER_UP
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
operator|(
name|LVDS_B0B3_POWER_UP
operator||
name|LVDS_CLKB_POWER_UP
operator|)
expr_stmt|;
comment|/* It would be nice to set 24 vs 18-bit mode (LVDS_A3_POWER_UP) 		 * appropriately here, but we need to look more thoroughly into how 		 * panels behave in the two modes. 		 */
comment|/* set the dithering flag on LVDS as needed */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|lvds_dither
condition|)
name|temp
operator||=
name|LVDS_ENABLE_DITHER
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
name|LVDS_ENABLE_DITHER
expr_stmt|;
block|}
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NHSYNC
condition|)
name|lvds_sync
operator||=
name|LVDS_HSYNC_POLARITY
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NVSYNC
condition|)
name|lvds_sync
operator||=
name|LVDS_VSYNC_POLARITY
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|&
operator|(
name|LVDS_HSYNC_POLARITY
operator||
name|LVDS_VSYNC_POLARITY
operator|)
operator|)
operator|!=
name|lvds_sync
condition|)
block|{
name|char
name|flags
index|[
literal|2
index|]
init|=
literal|"-+"
decl_stmt|;
name|DRM_INFO
argument_list|(
literal|"Changing LVDS panel from "
literal|"(%chsync, %cvsync) to (%chsync, %cvsync)\n"
argument_list|,
name|flags
index|[
operator|!
operator|(
name|temp
operator|&
name|LVDS_HSYNC_POLARITY
operator|)
index|]
argument_list|,
name|flags
index|[
operator|!
operator|(
name|temp
operator|&
name|LVDS_VSYNC_POLARITY
operator|)
index|]
argument_list|,
name|flags
index|[
operator|!
operator|(
name|lvds_sync
operator|&
name|LVDS_HSYNC_POLARITY
operator|)
index|]
argument_list|,
name|flags
index|[
operator|!
operator|(
name|lvds_sync
operator|&
name|LVDS_VSYNC_POLARITY
operator|)
index|]
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|LVDS_HSYNC_POLARITY
operator||
name|LVDS_VSYNC_POLARITY
operator|)
expr_stmt|;
name|temp
operator||=
name|lvds_sync
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|LVDS
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_dp
condition|)
block|{
name|intel_dp_set_m_n
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to stabilize. */
name|POSTING_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_sdvo
condition|)
block|{
name|temp
operator|=
name|intel_mode_get_pixel_multiplier
argument_list|(
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|1
condition|)
name|temp
operator|=
operator|(
name|temp
operator|-
literal|1
operator|)
operator|<<
name|DPLL_MD_UDI_MULTIPLIER_SHIFT
expr_stmt|;
else|else
name|temp
operator|=
literal|0
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|DPLL_MD
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The pixel multiplier can only be updated once the 		 * DPLL is enabled and the clocks are stable. 		 * 		 * So write it again. 		 */
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAS_PIPE_CXSR
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|intel_crtc
operator|->
name|lowfreq_avail
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"enabling CxSR downclocking\n"
argument_list|)
expr_stmt|;
name|pipeconf
operator||=
name|PIPECONF_CXSR_DOWNCLOCK
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabling CxSR downclocking\n"
argument_list|)
expr_stmt|;
name|pipeconf
operator|&=
operator|~
name|PIPECONF_CXSR_DOWNCLOCK
expr_stmt|;
block|}
block|}
name|pipeconf
operator|&=
operator|~
name|PIPECONF_INTERLACE_MASK
expr_stmt|;
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
operator|&&
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
condition|)
block|{
name|pipeconf
operator||=
name|PIPECONF_INTERLACE_W_FIELD_INDICATION
expr_stmt|;
comment|/* the chip adds 2 halflines automatically */
name|adjusted_mode
operator|->
name|crtc_vtotal
operator|-=
literal|1
expr_stmt|;
name|adjusted_mode
operator|->
name|crtc_vblank_end
operator|-=
literal|1
expr_stmt|;
name|vsyncshift
operator|=
name|adjusted_mode
operator|->
name|crtc_hsync_start
operator|-
name|adjusted_mode
operator|->
name|crtc_htotal
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|pipeconf
operator||=
name|PIPECONF_PROGRESSIVE
expr_stmt|;
name|vsyncshift
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_GEN3
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|VSYNCSHIFT
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|vsyncshift
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hdisplay
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_htotal
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hblank_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_hblank_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hsync_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_hsync_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vdisplay
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vtotal
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vblank_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vblank_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vsync_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vsync_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* pipesrc and dspsize control the size that is scaled from, 	 * which should always be the user's requested size. 	 */
name|I915_WRITE
argument_list|(
name|DSPSIZE
argument_list|(
name|plane
argument_list|)
argument_list|,
operator|(
operator|(
name|mode
operator|->
name|vdisplay
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|mode
operator|->
name|hdisplay
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPPOS
argument_list|(
name|plane
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPESRC
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
operator|(
name|mode
operator|->
name|hdisplay
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|mode
operator|->
name|vdisplay
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|pipeconf
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|intel_enable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|dspcntr
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|intel_enable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_pipe_set_base
argument_list|(
name|crtc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|old_fb
argument_list|)
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize reference clocks when the driver loads  */
end_comment

begin_function
name|void
name|ironlake_init_pch_refclk
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|bool
name|has_lvds
init|=
name|false
decl_stmt|;
name|bool
name|has_cpu_edp
init|=
name|false
decl_stmt|;
name|bool
name|has_pch_edp
init|=
name|false
decl_stmt|;
name|bool
name|has_panel
init|=
name|false
decl_stmt|;
name|bool
name|has_ck505
init|=
name|false
decl_stmt|;
name|bool
name|can_ssc
init|=
name|false
decl_stmt|;
comment|/* We need to take the global config into account */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|has_panel
operator|=
name|true
expr_stmt|;
name|has_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_EDP
case|:
name|has_panel
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|)
condition|)
name|has_pch_edp
operator|=
name|true
expr_stmt|;
else|else
name|has_cpu_edp
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|has_ck505
operator|=
name|dev_priv
operator|->
name|display_clock_mode
expr_stmt|;
name|can_ssc
operator|=
name|has_ck505
expr_stmt|;
block|}
else|else
block|{
name|has_ck505
operator|=
name|false
expr_stmt|;
name|can_ssc
operator|=
name|true
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"has_panel %d has_lvds %d has_pch_edp %d has_cpu_edp %d has_ck505 %d\n"
argument_list|,
name|has_panel
argument_list|,
name|has_lvds
argument_list|,
name|has_pch_edp
argument_list|,
name|has_cpu_edp
argument_list|,
name|has_ck505
argument_list|)
expr_stmt|;
comment|/* Ironlake: try to setup display ref clock before DPLL 	 * enabling. This is only under driver's control after 	 * PCH B stepping, previous chipset stepping should be 	 * ignoring this setting. 	 */
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
comment|/* Always enable nonspread source */
name|temp
operator|&=
operator|~
name|DREF_NONSPREAD_SOURCE_MASK
expr_stmt|;
if|if
condition|(
name|has_ck505
condition|)
name|temp
operator||=
name|DREF_NONSPREAD_CK505_ENABLE
expr_stmt|;
else|else
name|temp
operator||=
name|DREF_NONSPREAD_SOURCE_ENABLE
expr_stmt|;
if|if
condition|(
name|has_panel
condition|)
block|{
name|temp
operator|&=
operator|~
name|DREF_SSC_SOURCE_MASK
expr_stmt|;
name|temp
operator||=
name|DREF_SSC_SOURCE_ENABLE
expr_stmt|;
comment|/* SSC must be turned on before enabling the CPU output  */
if|if
condition|(
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|can_ssc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Using SSC on panel\n"
argument_list|)
expr_stmt|;
name|temp
operator||=
name|DREF_SSC1_ENABLE
expr_stmt|;
block|}
else|else
name|temp
operator|&=
operator|~
name|DREF_SSC1_ENABLE
expr_stmt|;
comment|/* Get SSC going before enabling the outputs */
name|I915_WRITE
argument_list|(
name|PCH_DREF_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|DREF_CPU_SOURCE_OUTPUT_MASK
expr_stmt|;
comment|/* Enable CPU source on CPU attached eDP */
if|if
condition|(
name|has_cpu_edp
condition|)
block|{
if|if
condition|(
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|can_ssc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Using SSC on eDP\n"
argument_list|)
expr_stmt|;
name|temp
operator||=
name|DREF_CPU_SOURCE_OUTPUT_DOWNSPREAD
expr_stmt|;
block|}
else|else
name|temp
operator||=
name|DREF_CPU_SOURCE_OUTPUT_NONSPREAD
expr_stmt|;
block|}
else|else
name|temp
operator||=
name|DREF_CPU_SOURCE_OUTPUT_DISABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DREF_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Disabling SSC entirely\n"
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|DREF_CPU_SOURCE_OUTPUT_MASK
expr_stmt|;
comment|/* Turn off CPU output */
name|temp
operator||=
name|DREF_CPU_SOURCE_OUTPUT_DISABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DREF_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Turn off the SSC source */
name|temp
operator|&=
operator|~
name|DREF_SSC_SOURCE_MASK
expr_stmt|;
name|temp
operator||=
name|DREF_SSC_SOURCE_DISABLE
expr_stmt|;
comment|/* Turn off SSC1 */
name|temp
operator|&=
operator|~
name|DREF_SSC1_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DREF_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ironlake_get_refclk
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|edp_encoder
init|=
name|NULL
decl_stmt|;
name|int
name|num_connectors
init|=
literal|0
decl_stmt|;
name|bool
name|is_lvds
init|=
name|false
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|is_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_EDP
case|:
name|edp_encoder
operator|=
name|encoder
expr_stmt|;
break|break;
block|}
name|num_connectors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|is_lvds
operator|&&
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|num_connectors
operator|<
literal|2
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"using SSC reference clock of %d MHz\n"
argument_list|,
name|dev_priv
operator|->
name|lvds_ssc_freq
argument_list|)
expr_stmt|;
return|return
name|dev_priv
operator|->
name|lvds_ssc_freq
operator|*
literal|1000
return|;
block|}
return|return
literal|120000
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ironlake_crtc_mode_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|int
name|refclk
decl_stmt|,
name|num_connectors
init|=
literal|0
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|,
name|reduced_clock
decl_stmt|;
name|u32
name|dpll
decl_stmt|,
name|fp
init|=
literal|0
decl_stmt|,
name|fp2
init|=
literal|0
decl_stmt|,
name|dspcntr
decl_stmt|,
name|pipeconf
decl_stmt|;
name|bool
name|ok
decl_stmt|,
name|has_reduced_clock
init|=
name|false
decl_stmt|,
name|is_sdvo
init|=
name|false
decl_stmt|;
name|bool
name|is_crt
init|=
name|false
decl_stmt|,
name|is_lvds
init|=
name|false
decl_stmt|,
name|is_tv
init|=
name|false
decl_stmt|,
name|is_dp
init|=
name|false
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|has_edp_encoder
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|fdi_m_n
name|m_n
init|=
block|{
literal|0
block|}
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|u32
name|lvds_sync
init|=
literal|0
decl_stmt|;
name|int
name|target_clock
decl_stmt|,
name|pixel_multiplier
decl_stmt|,
name|lane
decl_stmt|,
name|link_bw
decl_stmt|,
name|factor
decl_stmt|;
name|unsigned
name|int
name|pipe_bpp
decl_stmt|;
name|bool
name|dither
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|is_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_SDVO
case|:
case|case
name|INTEL_OUTPUT_HDMI
case|:
name|is_sdvo
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|encoder
operator|->
name|needs_tv_clock
condition|)
name|is_tv
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_TVOUT
case|:
name|is_tv
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_ANALOG
case|:
name|is_crt
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_DISPLAYPORT
case|:
name|is_dp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_EDP
case|:
name|has_edp_encoder
operator|=
name|encoder
expr_stmt|;
break|break;
block|}
name|num_connectors
operator|++
expr_stmt|;
block|}
name|refclk
operator|=
name|ironlake_get_refclk
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* 	 * Returns a set of divisors for the desired target clock with the given 	 * refclk, or false.  The returned values represent the clock equation: 	 * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2. 	 */
name|limit
operator|=
name|intel_limit
argument_list|(
name|crtc
argument_list|,
name|refclk
argument_list|)
expr_stmt|;
name|ok
operator|=
name|limit
operator|->
name|find_pll
argument_list|(
name|limit
argument_list|,
name|crtc
argument_list|,
name|adjusted_mode
operator|->
name|clock
argument_list|,
name|refclk
argument_list|,
name|NULL
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Couldn't find PLL settings for mode!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Ensure that the cursor is valid for the new mode before changing... */
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_lvds
operator|&&
name|dev_priv
operator|->
name|lvds_downclock_avail
condition|)
block|{
comment|/* 		 * Ensure we match the reduced clock's P to the target clock. 		 * If the clocks don't match, we can't switch the display clock 		 * by using the FP0/FP1. In such case we will disable the LVDS 		 * downclock feature. 		*/
name|has_reduced_clock
operator|=
name|limit
operator|->
name|find_pll
argument_list|(
name|limit
argument_list|,
name|crtc
argument_list|,
name|dev_priv
operator|->
name|lvds_downclock
argument_list|,
name|refclk
argument_list|,
operator|&
name|clock
argument_list|,
operator|&
name|reduced_clock
argument_list|)
expr_stmt|;
block|}
comment|/* SDVO TV has fixed PLL values depend on its clock range, 	   this mirrors vbios setting. */
if|if
condition|(
name|is_sdvo
operator|&&
name|is_tv
condition|)
block|{
if|if
condition|(
name|adjusted_mode
operator|->
name|clock
operator|>=
literal|100000
operator|&&
name|adjusted_mode
operator|->
name|clock
operator|<
literal|140500
condition|)
block|{
name|clock
operator|.
name|p1
operator|=
literal|2
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|n
operator|=
literal|3
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|16
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adjusted_mode
operator|->
name|clock
operator|>=
literal|140500
operator|&&
name|adjusted_mode
operator|->
name|clock
operator|<=
literal|200000
condition|)
block|{
name|clock
operator|.
name|p1
operator|=
literal|1
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|n
operator|=
literal|6
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|12
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|8
expr_stmt|;
block|}
block|}
comment|/* FDI link */
name|pixel_multiplier
operator|=
name|intel_mode_get_pixel_multiplier
argument_list|(
name|adjusted_mode
argument_list|)
expr_stmt|;
name|lane
operator|=
literal|0
expr_stmt|;
comment|/* CPU eDP doesn't require FDI link, so just set DP M/N 	   according to current link config */
if|if
condition|(
name|has_edp_encoder
operator|&&
operator|!
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|has_edp_encoder
operator|->
name|base
argument_list|)
condition|)
block|{
name|target_clock
operator|=
name|mode
operator|->
name|clock
expr_stmt|;
name|intel_edp_link_config
argument_list|(
name|has_edp_encoder
argument_list|,
operator|&
name|lane
argument_list|,
operator|&
name|link_bw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* [e]DP over FDI requires target mode clock 		   instead of link clock */
if|if
condition|(
name|is_dp
operator|||
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|has_edp_encoder
operator|->
name|base
argument_list|)
condition|)
name|target_clock
operator|=
name|mode
operator|->
name|clock
expr_stmt|;
else|else
name|target_clock
operator|=
name|adjusted_mode
operator|->
name|clock
expr_stmt|;
comment|/* FDI is a binary signal running at ~2.7GHz, encoding 		 * each output octet as 10 bits. The actual frequency 		 * is stored as a divider into a 100MHz clock, and the 		 * mode pixel clock is stored in units of 1KHz. 		 * Hence the bw of each lane in terms of the mode signal 		 * is: 		 */
name|link_bw
operator|=
name|intel_fdi_link_freq
argument_list|(
name|dev
argument_list|)
operator|*
name|MHz
argument_list|(
literal|100
argument_list|)
operator|/
name|KHz
argument_list|(
literal|1
argument_list|)
operator|/
literal|10
expr_stmt|;
block|}
comment|/* determine panel color depth */
name|temp
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|PIPE_BPC_MASK
expr_stmt|;
name|dither
operator|=
name|intel_choose_pipe_bpp_dither
argument_list|(
name|crtc
argument_list|,
operator|&
name|pipe_bpp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pipe_bpp
condition|)
block|{
case|case
literal|18
case|:
name|temp
operator||=
name|PIPE_6BPC
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|temp
operator||=
name|PIPE_8BPC
expr_stmt|;
break|break;
case|case
literal|30
case|:
name|temp
operator||=
name|PIPE_10BPC
expr_stmt|;
break|break;
case|case
literal|36
case|:
name|temp
operator||=
name|PIPE_12BPC
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"intel_choose_pipe_bpp returned invalid value %d\n"
argument_list|,
name|pipe_bpp
argument_list|)
expr_stmt|;
name|temp
operator||=
name|PIPE_8BPC
expr_stmt|;
name|pipe_bpp
operator|=
literal|24
expr_stmt|;
break|break;
block|}
name|intel_crtc
operator|->
name|bpp
operator|=
name|pipe_bpp
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lane
condition|)
block|{
comment|/* 		 * Account for spread spectrum to avoid 		 * oversubscribing the link. Max center spread 		 * is 2.5%; use 5% for safety's sake. 		 */
name|u32
name|bps
init|=
name|target_clock
operator|*
name|intel_crtc
operator|->
name|bpp
operator|*
literal|21
operator|/
literal|20
decl_stmt|;
name|lane
operator|=
name|bps
operator|/
operator|(
name|link_bw
operator|*
literal|8
operator|)
operator|+
literal|1
expr_stmt|;
block|}
name|intel_crtc
operator|->
name|fdi_lanes
operator|=
name|lane
expr_stmt|;
if|if
condition|(
name|pixel_multiplier
operator|>
literal|1
condition|)
name|link_bw
operator|*=
name|pixel_multiplier
expr_stmt|;
name|ironlake_compute_m_n
argument_list|(
name|intel_crtc
operator|->
name|bpp
argument_list|,
name|lane
argument_list|,
name|target_clock
argument_list|,
name|link_bw
argument_list|,
operator|&
name|m_n
argument_list|)
expr_stmt|;
name|fp
operator|=
name|clock
operator|.
name|n
operator|<<
literal|16
operator||
name|clock
operator|.
name|m1
operator|<<
literal|8
operator||
name|clock
operator|.
name|m2
expr_stmt|;
if|if
condition|(
name|has_reduced_clock
condition|)
name|fp2
operator|=
name|reduced_clock
operator|.
name|n
operator|<<
literal|16
operator||
name|reduced_clock
operator|.
name|m1
operator|<<
literal|8
operator||
name|reduced_clock
operator|.
name|m2
expr_stmt|;
comment|/* Enable autotuning of the PLL clock (if permissible) */
name|factor
operator|=
literal|21
expr_stmt|;
if|if
condition|(
name|is_lvds
condition|)
block|{
if|if
condition|(
operator|(
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|dev_priv
operator|->
name|lvds_ssc_freq
operator|==
literal|100
operator|)
operator|||
operator|(
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
operator|&
name|LVDS_CLKB_POWER_MASK
operator|)
operator|==
name|LVDS_CLKB_POWER_UP
condition|)
name|factor
operator|=
literal|25
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_sdvo
operator|&&
name|is_tv
condition|)
name|factor
operator|=
literal|20
expr_stmt|;
if|if
condition|(
name|clock
operator|.
name|m
operator|<
name|factor
operator|*
name|clock
operator|.
name|n
condition|)
name|fp
operator||=
name|FP_CB_TUNE
expr_stmt|;
name|dpll
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_lvds
condition|)
name|dpll
operator||=
name|DPLLB_MODE_LVDS
expr_stmt|;
else|else
name|dpll
operator||=
name|DPLLB_MODE_DAC_SERIAL
expr_stmt|;
if|if
condition|(
name|is_sdvo
condition|)
block|{
name|int
name|pixel_multiplier
init|=
name|intel_mode_get_pixel_multiplier
argument_list|(
name|adjusted_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|pixel_multiplier
operator|>
literal|1
condition|)
block|{
name|dpll
operator||=
operator|(
name|pixel_multiplier
operator|-
literal|1
operator|)
operator|<<
name|PLL_REF_SDVO_HDMI_MULTIPLIER_SHIFT
expr_stmt|;
block|}
name|dpll
operator||=
name|DPLL_DVO_HIGH_SPEED
expr_stmt|;
block|}
if|if
condition|(
name|is_dp
operator|||
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|has_edp_encoder
operator|->
name|base
argument_list|)
condition|)
name|dpll
operator||=
name|DPLL_DVO_HIGH_SPEED
expr_stmt|;
comment|/* compute bitmask from p1 value */
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|.
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT
expr_stmt|;
comment|/* also FPA1 */
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|.
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA1_P1_POST_DIV_SHIFT
expr_stmt|;
switch|switch
condition|(
name|clock
operator|.
name|p2
condition|)
block|{
case|case
literal|5
case|:
name|dpll
operator||=
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_5
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|dpll
operator||=
name|DPLLB_LVDS_P2_CLOCK_DIV_7
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|dpll
operator||=
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_10
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|dpll
operator||=
name|DPLLB_LVDS_P2_CLOCK_DIV_14
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_sdvo
operator|&&
name|is_tv
condition|)
name|dpll
operator||=
name|PLL_REF_INPUT_TVCLKINBC
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tv
condition|)
comment|/* XXX: just matching BIOS for now */
comment|/*	dpll |= PLL_REF_INPUT_TVCLKINBC; */
name|dpll
operator||=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|is_lvds
operator|&&
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|num_connectors
operator|<
literal|2
condition|)
name|dpll
operator||=
name|PLLB_REF_INPUT_SPREADSPECTRUMIN
expr_stmt|;
else|else
name|dpll
operator||=
name|PLL_REF_INPUT_DREFCLK
expr_stmt|;
comment|/* setup pipeconf */
name|pipeconf
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the display plane register */
name|dspcntr
operator|=
name|DISPPLANE_GAMMA_ENABLE
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Mode for pipe %d:\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* PCH eDP needs FDI, but CPU eDP does not */
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|no_pll
condition|)
block|{
if|if
condition|(
operator|!
name|has_edp_encoder
operator|||
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|has_edp_encoder
operator|->
name|base
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|PCH_FP0
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
operator|&
operator|~
name|DPLL_VCO_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dpll
operator|==
operator|(
name|I915_READ
argument_list|(
name|PCH_DPLL
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&
literal|0x7fffffff
operator|)
operator|&&
name|fp
operator|==
name|I915_READ
argument_list|(
name|PCH_FP0
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|intel_crtc
operator|->
name|use_pll_a
operator|=
name|true
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"using pipe a dpll\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dpll
operator|==
operator|(
name|I915_READ
argument_list|(
name|PCH_DPLL
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|&
literal|0x7fffffff
operator|)
operator|&&
name|fp
operator|==
name|I915_READ
argument_list|(
name|PCH_FP0
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|intel_crtc
operator|->
name|use_pll_a
operator|=
name|false
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"using pipe b dpll\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"no matching PLL configuration for pipe 2\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
comment|/* The LVDS pin pair needs to be on before the DPLLs are enabled. 	 * This is an exception to the general rule that mode_set doesn't turn 	 * things on. 	 */
if|if
condition|(
name|is_lvds
condition|)
block|{
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
expr_stmt|;
name|temp
operator||=
name|LVDS_PORT_EN
operator||
name|LVDS_A0A2_CLKA_POWER_UP
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|PORT_TRANS_SEL_MASK
expr_stmt|;
name|temp
operator||=
name|PORT_TRANS_SEL_CPT
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pipe
operator|==
literal|1
condition|)
name|temp
operator||=
name|LVDS_PIPEB_SELECT
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
name|LVDS_PIPEB_SELECT
expr_stmt|;
block|}
comment|/* set the corresponsding LVDS_BORDER bit */
name|temp
operator||=
name|dev_priv
operator|->
name|lvds_border_bits
expr_stmt|;
comment|/* Set the B0-B3 data pairs corresponding to whether we're going to 		 * set the DPLLs for dual-channel mode or not. 		 */
if|if
condition|(
name|clock
operator|.
name|p2
operator|==
literal|7
condition|)
name|temp
operator||=
name|LVDS_B0B3_POWER_UP
operator||
name|LVDS_CLKB_POWER_UP
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
operator|(
name|LVDS_B0B3_POWER_UP
operator||
name|LVDS_CLKB_POWER_UP
operator|)
expr_stmt|;
comment|/* It would be nice to set 24 vs 18-bit mode (LVDS_A3_POWER_UP) 		 * appropriately here, but we need to look more thoroughly into how 		 * panels behave in the two modes. 		 */
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NHSYNC
condition|)
name|lvds_sync
operator||=
name|LVDS_HSYNC_POLARITY
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NVSYNC
condition|)
name|lvds_sync
operator||=
name|LVDS_VSYNC_POLARITY
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|&
operator|(
name|LVDS_HSYNC_POLARITY
operator||
name|LVDS_VSYNC_POLARITY
operator|)
operator|)
operator|!=
name|lvds_sync
condition|)
block|{
name|char
name|flags
index|[
literal|2
index|]
init|=
literal|"-+"
decl_stmt|;
name|DRM_INFO
argument_list|(
literal|"Changing LVDS panel from "
literal|"(%chsync, %cvsync) to (%chsync, %cvsync)\n"
argument_list|,
name|flags
index|[
operator|!
operator|(
name|temp
operator|&
name|LVDS_HSYNC_POLARITY
operator|)
index|]
argument_list|,
name|flags
index|[
operator|!
operator|(
name|temp
operator|&
name|LVDS_VSYNC_POLARITY
operator|)
index|]
argument_list|,
name|flags
index|[
operator|!
operator|(
name|lvds_sync
operator|&
name|LVDS_HSYNC_POLARITY
operator|)
index|]
argument_list|,
name|flags
index|[
operator|!
operator|(
name|lvds_sync
operator|&
name|LVDS_VSYNC_POLARITY
operator|)
index|]
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|LVDS_HSYNC_POLARITY
operator||
name|LVDS_VSYNC_POLARITY
operator|)
expr_stmt|;
name|temp
operator||=
name|lvds_sync
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|PCH_LVDS
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|pipeconf
operator|&=
operator|~
name|PIPECONF_DITHER_EN
expr_stmt|;
name|pipeconf
operator|&=
operator|~
name|PIPECONF_DITHER_TYPE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|is_lvds
operator|&&
name|dev_priv
operator|->
name|lvds_dither
operator|)
operator|||
name|dither
condition|)
block|{
name|pipeconf
operator||=
name|PIPECONF_DITHER_EN
expr_stmt|;
name|pipeconf
operator||=
name|PIPECONF_DITHER_TYPE_SP
expr_stmt|;
block|}
if|if
condition|(
name|is_dp
operator|||
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|has_edp_encoder
operator|->
name|base
argument_list|)
condition|)
block|{
name|intel_dp_set_m_n
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For non-DP output, clear any trans DP clock recovery setting.*/
name|I915_WRITE
argument_list|(
name|TRANSDATA_M1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDATA_N1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDPLINK_M1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDPLINK_N1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|no_pll
operator|&&
operator|(
operator|!
name|has_edp_encoder
operator|||
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|has_edp_encoder
operator|->
name|base
argument_list|)
operator|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|PCH_DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to stabilize. */
name|POSTING_READ
argument_list|(
name|PCH_DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* The pixel multiplier can only be updated once the 		 * DPLL is enabled and the clocks are stable. 		 * 		 * So write it again. 		 */
name|I915_WRITE
argument_list|(
name|PCH_DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
block|}
name|intel_crtc
operator|->
name|lowfreq_avail
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|no_pll
condition|)
block|{
if|if
condition|(
name|is_lvds
operator|&&
name|has_reduced_clock
operator|&&
name|i915_powersave
condition|)
block|{
name|I915_WRITE
argument_list|(
name|PCH_FP1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|fp2
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|lowfreq_avail
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|HAS_PIPE_CXSR
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"enabling CxSR downclocking\n"
argument_list|)
expr_stmt|;
name|pipeconf
operator||=
name|PIPECONF_CXSR_DOWNCLOCK
expr_stmt|;
block|}
block|}
else|else
block|{
name|I915_WRITE
argument_list|(
name|PCH_FP1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PIPE_CXSR
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabling CxSR downclocking\n"
argument_list|)
expr_stmt|;
name|pipeconf
operator|&=
operator|~
name|PIPECONF_CXSR_DOWNCLOCK
expr_stmt|;
block|}
block|}
block|}
name|pipeconf
operator|&=
operator|~
name|PIPECONF_INTERLACE_MASK
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
condition|)
block|{
name|pipeconf
operator||=
name|PIPECONF_INTERLACED_ILK
expr_stmt|;
comment|/* the chip adds 2 halflines automatically */
name|adjusted_mode
operator|->
name|crtc_vtotal
operator|-=
literal|1
expr_stmt|;
name|adjusted_mode
operator|->
name|crtc_vblank_end
operator|-=
literal|1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VSYNCSHIFT
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|adjusted_mode
operator|->
name|crtc_hsync_start
operator|-
name|adjusted_mode
operator|->
name|crtc_htotal
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pipeconf
operator||=
name|PIPECONF_PROGRESSIVE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VSYNCSHIFT
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|HTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hdisplay
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_htotal
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hblank_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_hblank_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hsync_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_hsync_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vdisplay
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vtotal
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vblank_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vblank_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vsync_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vsync_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* pipesrc controls the size that is scaled from, which should 	 * always be the user's requested size. 	 */
name|I915_WRITE
argument_list|(
name|PIPESRC
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
operator|(
name|mode
operator|->
name|hdisplay
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|mode
operator|->
name|vdisplay
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_DATA_M1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|TU_SIZE
argument_list|(
name|m_n
operator|.
name|tu
argument_list|)
operator||
name|m_n
operator|.
name|gmch_m
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_DATA_N1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|m_n
operator|.
name|gmch_n
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_LINK_M1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|m_n
operator|.
name|link_m
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_LINK_N1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|m_n
operator|.
name|link_n
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_edp_encoder
operator|&&
operator|!
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|has_edp_encoder
operator|->
name|base
argument_list|)
condition|)
block|{
name|ironlake_set_pll_edp
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
operator|->
name|clock
argument_list|)
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|pipeconf
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|dspcntr
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_pipe_set_base
argument_list|(
name|crtc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|old_fb
argument_list|)
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_crtc_mode_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|drm_vblank_pre_modeset
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dev_priv
operator|->
name|display
operator|.
name|crtc_mode_set
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|old_fb
argument_list|)
expr_stmt|;
name|drm_vblank_post_modeset
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|intel_crtc
operator|->
name|dpms_mode
operator|=
name|DRM_MODE_DPMS_OFF
expr_stmt|;
else|else
name|intel_crtc
operator|->
name|dpms_mode
operator|=
name|DRM_MODE_DPMS_ON
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_eld_uptodate
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|int
name|reg_eldv
parameter_list|,
name|uint32_t
name|bits_eldv
parameter_list|,
name|int
name|reg_elda
parameter_list|,
name|uint32_t
name|bits_elda
parameter_list|,
name|int
name|reg_edid
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|connector
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint8_t
modifier|*
name|eld
init|=
name|connector
operator|->
name|eld
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|reg_eldv
argument_list|)
expr_stmt|;
name|i
operator|&=
name|bits_eldv
expr_stmt|;
if|if
condition|(
operator|!
name|eld
index|[
literal|0
index|]
condition|)
return|return
operator|!
name|i
return|;
if|if
condition|(
operator|!
name|i
condition|)
return|return
name|false
return|;
name|i
operator|=
name|I915_READ
argument_list|(
name|reg_elda
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|bits_elda
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg_elda
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eld
index|[
literal|2
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|I915_READ
argument_list|(
name|reg_edid
argument_list|)
operator|!=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|eld
operator|+
name|i
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g4x_write_eld
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|connector
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint8_t
modifier|*
name|eld
init|=
name|connector
operator|->
name|eld
decl_stmt|;
name|uint32_t
name|eldv
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|G4X_AUD_VID_DID
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|INTEL_AUDIO_DEVBLC
operator|||
name|i
operator|==
name|INTEL_AUDIO_DEVCL
condition|)
name|eldv
operator|=
name|G4X_ELDV_DEVCL_DEVBLC
expr_stmt|;
else|else
name|eldv
operator|=
name|G4X_ELDV_DEVCTG
expr_stmt|;
if|if
condition|(
name|intel_eld_uptodate
argument_list|(
name|connector
argument_list|,
name|G4X_AUD_CNTL_ST
argument_list|,
name|eldv
argument_list|,
name|G4X_AUD_CNTL_ST
argument_list|,
name|G4X_ELD_ADDR
argument_list|,
name|G4X_HDMIW_HDMIEDID
argument_list|)
condition|)
return|return;
name|i
operator|=
name|I915_READ
argument_list|(
name|G4X_AUD_CNTL_ST
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
operator|(
name|eldv
operator||
name|G4X_ELD_ADDR
operator|)
expr_stmt|;
name|len
operator|=
operator|(
name|i
operator|>>
literal|9
operator|)
operator|&
literal|0x1f
expr_stmt|;
comment|/* ELD buffer size */
name|I915_WRITE
argument_list|(
name|G4X_AUD_CNTL_ST
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eld
index|[
literal|0
index|]
condition|)
return|return;
if|if
condition|(
name|eld
index|[
literal|2
index|]
operator|<
operator|(
name|uint8_t
operator|)
name|len
condition|)
name|len
operator|=
name|eld
index|[
literal|2
index|]
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"ELD size %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|G4X_HDMIW_HDMIEDID
argument_list|,
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|eld
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|G4X_AUD_CNTL_ST
argument_list|)
expr_stmt|;
name|i
operator||=
name|eldv
expr_stmt|;
name|I915_WRITE
argument_list|(
name|G4X_AUD_CNTL_ST
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_write_eld
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|connector
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint8_t
modifier|*
name|eld
init|=
name|connector
operator|->
name|eld
decl_stmt|;
name|uint32_t
name|eldv
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hdmiw_hdmiedid
decl_stmt|;
name|int
name|aud_config
decl_stmt|;
name|int
name|aud_cntl_st
decl_stmt|;
name|int
name|aud_cntrl_st2
decl_stmt|;
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|connector
operator|->
name|dev
argument_list|)
condition|)
block|{
name|hdmiw_hdmiedid
operator|=
name|IBX_HDMIW_HDMIEDID_A
expr_stmt|;
name|aud_config
operator|=
name|IBX_AUD_CONFIG_A
expr_stmt|;
name|aud_cntl_st
operator|=
name|IBX_AUD_CNTL_ST_A
expr_stmt|;
name|aud_cntrl_st2
operator|=
name|IBX_AUD_CNTL_ST2
expr_stmt|;
block|}
else|else
block|{
name|hdmiw_hdmiedid
operator|=
name|CPT_HDMIW_HDMIEDID_A
expr_stmt|;
name|aud_config
operator|=
name|CPT_AUD_CONFIG_A
expr_stmt|;
name|aud_cntl_st
operator|=
name|CPT_AUD_CNTL_ST_A
expr_stmt|;
name|aud_cntrl_st2
operator|=
name|CPT_AUD_CNTRL_ST2
expr_stmt|;
block|}
name|i
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|pipe
expr_stmt|;
name|hdmiw_hdmiedid
operator|+=
name|i
operator|*
literal|0x100
expr_stmt|;
name|aud_cntl_st
operator|+=
name|i
operator|*
literal|0x100
expr_stmt|;
name|aud_config
operator|+=
name|i
operator|*
literal|0x100
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"ELD on pipe %c\n"
argument_list|,
name|pipe_name
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntl_st
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|>>
literal|29
operator|)
operator|&
literal|0x3
expr_stmt|;
comment|/* DIP_Port_Select, 0x1 = PortB */
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Audio directed to unknown port\n"
argument_list|)
expr_stmt|;
comment|/* operate blindly on all ports */
name|eldv
operator|=
name|IBX_ELD_VALIDB
expr_stmt|;
name|eldv
operator||=
name|IBX_ELD_VALIDB
operator|<<
literal|4
expr_stmt|;
name|eldv
operator||=
name|IBX_ELD_VALIDB
operator|<<
literal|8
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"ELD on port %c\n"
argument_list|,
literal|'A'
operator|+
name|i
argument_list|)
expr_stmt|;
name|eldv
operator|=
name|IBX_ELD_VALIDB
operator|<<
operator|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"ELD: DisplayPort detected\n"
argument_list|)
expr_stmt|;
name|eld
index|[
literal|5
index|]
operator||=
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* Conn_Type, 0x1 = DisplayPort */
name|I915_WRITE
argument_list|(
name|aud_config
argument_list|,
name|AUD_CONFIG_N_VALUE_INDEX
argument_list|)
expr_stmt|;
comment|/* 0x1 = DP */
block|}
else|else
name|I915_WRITE
argument_list|(
name|aud_config
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_eld_uptodate
argument_list|(
name|connector
argument_list|,
name|aud_cntrl_st2
argument_list|,
name|eldv
argument_list|,
name|aud_cntl_st
argument_list|,
name|IBX_ELD_ADDRESS
argument_list|,
name|hdmiw_hdmiedid
argument_list|)
condition|)
return|return;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntrl_st2
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|eldv
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_cntrl_st2
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eld
index|[
literal|0
index|]
condition|)
return|return;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntl_st
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|IBX_ELD_ADDRESS
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_cntl_st
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 84 bytes of hw ELD buffer */
name|len
operator|=
literal|21
expr_stmt|;
if|if
condition|(
name|eld
index|[
literal|2
index|]
operator|<
operator|(
name|uint8_t
operator|)
name|len
condition|)
name|len
operator|=
name|eld
index|[
literal|2
index|]
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"ELD size %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|hdmiw_hdmiedid
argument_list|,
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|eld
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntrl_st2
argument_list|)
expr_stmt|;
name|i
operator||=
name|eldv
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_cntrl_st2
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_write_eld
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|encoder
operator|->
name|crtc
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|connector
operator|=
name|drm_select_eld
argument_list|(
name|encoder
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|connector
condition|)
return|return;
name|DRM_DEBUG_KMS
argument_list|(
literal|"ELD on [CONNECTOR:%d:%s], [ENCODER:%d:%s]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|connector
operator|->
name|encoder
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
name|connector
operator|->
name|encoder
argument_list|)
argument_list|)
expr_stmt|;
name|connector
operator|->
name|eld
index|[
literal|6
index|]
operator|=
name|drm_av_sync_delay
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
argument_list|(
name|connector
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Loads the palette/gamma unit for the CRTC with the prepared values */
end_comment

begin_function
name|void
name|intel_crtc_load_lut
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|palreg
init|=
name|PALETTE
argument_list|(
name|intel_crtc
operator|->
name|pipe
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The clocks have to be on to load the palette. */
if|if
condition|(
operator|!
name|crtc
operator|->
name|enabled
operator|||
operator|!
name|intel_crtc
operator|->
name|active
condition|)
return|return;
comment|/* use legacy palette for Ironlake */
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|palreg
operator|=
name|LGC_PALETTE
argument_list|(
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|I915_WRITE
argument_list|(
name|palreg
operator|+
literal|4
operator|*
name|i
argument_list|,
operator|(
name|intel_crtc
operator|->
name|lut_r
index|[
name|i
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|intel_crtc
operator|->
name|lut_g
index|[
name|i
index|]
operator|<<
literal|8
operator|)
operator||
name|intel_crtc
operator|->
name|lut_b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i845_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u32
name|base
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|bool
name|visible
init|=
name|base
operator|!=
literal|0
decl_stmt|;
name|u32
name|cntl
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_visible
operator|==
name|visible
condition|)
return|return;
name|cntl
operator|=
name|I915_READ
argument_list|(
name|_CURACNTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|visible
condition|)
block|{
comment|/* On these chipsets we can only modify the base whilst 		 * the cursor is disabled. 		 */
name|I915_WRITE
argument_list|(
name|_CURABASE
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_FORMAT_MASK
operator|)
expr_stmt|;
comment|/* XXX width must be 64, stride 256 => 0x00<< 28 */
name|cntl
operator||=
name|CURSOR_ENABLE
operator||
name|CURSOR_GAMMA_ENABLE
operator||
name|CURSOR_FORMAT_ARGB
expr_stmt|;
block|}
else|else
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_ENABLE
operator||
name|CURSOR_GAMMA_ENABLE
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_CURACNTR
argument_list|,
name|cntl
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_visible
operator|=
name|visible
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u32
name|base
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|bool
name|visible
init|=
name|base
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_visible
operator|!=
name|visible
condition|)
block|{
name|uint32_t
name|cntl
init|=
name|I915_READ
argument_list|(
name|CURCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_MODE
operator||
name|MCURSOR_PIPE_SELECT
operator|)
expr_stmt|;
name|cntl
operator||=
name|CURSOR_MODE_64_ARGB_AX
operator||
name|MCURSOR_GAMMA_ENABLE
expr_stmt|;
name|cntl
operator||=
name|pipe
operator|<<
literal|28
expr_stmt|;
comment|/* Connect to correct pipe */
block|}
else|else
block|{
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_MODE
operator||
name|MCURSOR_GAMMA_ENABLE
operator|)
expr_stmt|;
name|cntl
operator||=
name|CURSOR_MODE_DISABLE
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|CURCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|cntl
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_visible
operator|=
name|visible
expr_stmt|;
block|}
comment|/* and commit changes on next vblank */
name|I915_WRITE
argument_list|(
name|CURBASE
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ivb_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u32
name|base
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|bool
name|visible
init|=
name|base
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_visible
operator|!=
name|visible
condition|)
block|{
name|uint32_t
name|cntl
init|=
name|I915_READ
argument_list|(
name|CURCNTR_IVB
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|cntl
operator|&=
operator|~
name|CURSOR_MODE
expr_stmt|;
name|cntl
operator||=
name|CURSOR_MODE_64_ARGB_AX
operator||
name|MCURSOR_GAMMA_ENABLE
expr_stmt|;
block|}
else|else
block|{
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_MODE
operator||
name|MCURSOR_GAMMA_ENABLE
operator|)
expr_stmt|;
name|cntl
operator||=
name|CURSOR_MODE_DISABLE
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|CURCNTR_IVB
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|cntl
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_visible
operator|=
name|visible
expr_stmt|;
block|}
comment|/* and commit changes on next vblank */
name|I915_WRITE
argument_list|(
name|CURBASE_IVB
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If no-part of the cursor is visible on the framebuffer, then the GPU may hang... */
end_comment

begin_function
specifier|static
name|void
name|intel_crtc_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|x
init|=
name|intel_crtc
operator|->
name|cursor_x
decl_stmt|;
name|int
name|y
init|=
name|intel_crtc
operator|->
name|cursor_y
decl_stmt|;
name|u32
name|base
decl_stmt|,
name|pos
decl_stmt|;
name|bool
name|visible
decl_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|on
operator|&&
name|crtc
operator|->
name|enabled
operator|&&
name|crtc
operator|->
name|fb
condition|)
block|{
name|base
operator|=
name|intel_crtc
operator|->
name|cursor_addr
expr_stmt|;
if|if
condition|(
name|x
operator|>
operator|(
name|int
operator|)
name|crtc
operator|->
name|fb
operator|->
name|width
condition|)
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y
operator|>
operator|(
name|int
operator|)
name|crtc
operator|->
name|fb
operator|->
name|height
condition|)
name|base
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|+
name|intel_crtc
operator|->
name|cursor_width
operator|<
literal|0
condition|)
name|base
operator|=
literal|0
expr_stmt|;
name|pos
operator||=
name|CURSOR_POS_SIGN
operator|<<
name|CURSOR_X_SHIFT
expr_stmt|;
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
name|pos
operator||=
name|x
operator|<<
name|CURSOR_X_SHIFT
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|+
name|intel_crtc
operator|->
name|cursor_height
operator|<
literal|0
condition|)
name|base
operator|=
literal|0
expr_stmt|;
name|pos
operator||=
name|CURSOR_POS_SIGN
operator|<<
name|CURSOR_Y_SHIFT
expr_stmt|;
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
name|pos
operator||=
name|y
operator|<<
name|CURSOR_Y_SHIFT
expr_stmt|;
name|visible
operator|=
name|base
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|visible
operator|&&
operator|!
name|intel_crtc
operator|->
name|cursor_visible
condition|)
return|return;
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|CURPOS_IVB
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|ivb_update_cursor
argument_list|(
name|crtc
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|I915_WRITE
argument_list|(
name|CURPOS
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_845G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I865G
argument_list|(
name|dev
argument_list|)
condition|)
name|i845_update_cursor
argument_list|(
name|crtc
argument_list|,
name|base
argument_list|)
expr_stmt|;
else|else
name|i9xx_update_cursor
argument_list|(
name|crtc
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|visible
condition|)
name|intel_mark_busy
argument_list|(
name|dev
argument_list|,
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
operator|->
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_crtc_cursor_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|uint32_t
name|handle
parameter_list|,
name|uint32_t
name|width
parameter_list|,
name|uint32_t
name|height
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* if we want to turn off the cursor ignore width and height */
if|if
condition|(
operator|!
name|handle
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"cursor off\n"
argument_list|)
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* Currently we only support 64x64 cursors */
if|if
condition|(
name|width
operator|!=
literal|64
operator|||
name|height
operator|!=
literal|64
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"we currently only support 64x64 cursors\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOENT
return|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|size
operator|<
name|width
operator|*
name|height
operator|*
literal|4
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"buffer is to small\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* we only need to pin inside GTT if cursor is non-phy */
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|info
operator|->
name|cursor_needs_physical
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|tiling_mode
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"cursor cannot be tiled\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|fail_locked
goto|;
block|}
name|ret
operator|=
name|i915_gem_object_pin_to_display_plane
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to move cursor bo into the GTT\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_locked
goto|;
block|}
name|ret
operator|=
name|i915_gem_object_put_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to release fence for cursor\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_unpin
goto|;
block|}
name|addr
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
block|}
else|else
block|{
name|int
name|align
init|=
name|IS_I830
argument_list|(
name|dev
argument_list|)
condition|?
literal|16
operator|*
literal|1024
else|:
literal|256
decl_stmt|;
name|ret
operator|=
name|i915_gem_attach_phys_object
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
operator|(
name|intel_crtc
operator|->
name|pipe
operator|==
literal|0
operator|)
condition|?
name|I915_GEM_PHYS_CURSOR_0
else|:
name|I915_GEM_PHYS_CURSOR_1
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to attach phys object\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_locked
goto|;
block|}
name|addr
operator|=
name|obj
operator|->
name|phys_obj
operator|->
name|handle
operator|->
name|busaddr
expr_stmt|;
block|}
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|CURSIZE
argument_list|,
operator|(
name|height
operator|<<
literal|12
operator|)
operator||
name|width
argument_list|)
expr_stmt|;
name|finish
label|:
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_bo
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|info
operator|->
name|cursor_needs_physical
condition|)
block|{
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_bo
operator|!=
name|obj
condition|)
name|i915_gem_detach_phys_object
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|cursor_bo
argument_list|)
expr_stmt|;
block|}
else|else
name|i915_gem_object_unpin
argument_list|(
name|intel_crtc
operator|->
name|cursor_bo
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|intel_crtc
operator|->
name|cursor_bo
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_addr
operator|=
name|addr
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_bo
operator|=
name|obj
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_width
operator|=
name|width
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_height
operator|=
name|height
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail_unpin
label|:
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|fail_locked
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fail
label|:
name|drm_gem_object_unreference_unlocked
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_crtc_cursor_move
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|intel_crtc
operator|->
name|cursor_x
operator|=
name|x
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_y
operator|=
name|y
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Sets the color ramps on behalf of RandR */
end_comment

begin_function
name|void
name|intel_crtc_fb_gamma_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u16
name|red
parameter_list|,
name|u16
name|green
parameter_list|,
name|u16
name|blue
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|intel_crtc
operator|->
name|lut_r
index|[
name|regno
index|]
operator|=
name|red
operator|>>
literal|8
expr_stmt|;
name|intel_crtc
operator|->
name|lut_g
index|[
name|regno
index|]
operator|=
name|green
operator|>>
literal|8
expr_stmt|;
name|intel_crtc
operator|->
name|lut_b
index|[
name|regno
index|]
operator|=
name|blue
operator|>>
literal|8
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_crtc_fb_gamma_get
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u16
modifier|*
name|red
parameter_list|,
name|u16
modifier|*
name|green
parameter_list|,
name|u16
modifier|*
name|blue
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
operator|*
name|red
operator|=
name|intel_crtc
operator|->
name|lut_r
index|[
name|regno
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|green
operator|=
name|intel_crtc
operator|->
name|lut_g
index|[
name|regno
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|blue
operator|=
name|intel_crtc
operator|->
name|lut_b
index|[
name|regno
index|]
operator|<<
literal|8
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_gamma_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u16
modifier|*
name|red
parameter_list|,
name|u16
modifier|*
name|green
parameter_list|,
name|u16
modifier|*
name|blue
parameter_list|,
name|uint32_t
name|start
parameter_list|,
name|uint32_t
name|size
parameter_list|)
block|{
name|int
name|end
init|=
operator|(
name|start
operator|+
name|size
operator|>
literal|256
operator|)
condition|?
literal|256
else|:
name|start
operator|+
name|size
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|intel_crtc
operator|->
name|lut_r
index|[
name|i
index|]
operator|=
name|red
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
name|intel_crtc
operator|->
name|lut_g
index|[
name|i
index|]
operator|=
name|green
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
name|intel_crtc
operator|->
name|lut_b
index|[
name|i
index|]
operator|=
name|blue
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
block|}
name|intel_crtc_load_lut
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Get a pipe with a simple mode set on it for doing load-based monitor  * detection.  *  * It will be up to the load-detect code to adjust the pipe as appropriate for  * its requirements.  The pipe will be connected to no other encoders.  *  * Currently this code will only succeed if there is a pipe with no encoders  * configured for it.  In the future, it could choose to temporarily disable  * some outputs to free up a pipe for its use.  *  * \return crtc, or NULL if no pipes are available.  */
end_comment

begin_comment
comment|/* VESA 640x480x72Hz mode to set on the pipe */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|drm_display_mode
name|load_detect_mode
init|=
block|{
name|DRM_MODE
argument_list|(
literal|"640x480"
argument_list|,
name|DRM_MODE_TYPE_DEFAULT
argument_list|,
literal|31500
argument_list|,
literal|640
argument_list|,
literal|664
argument_list|,
literal|704
argument_list|,
literal|832
argument_list|,
literal|0
argument_list|,
literal|480
argument_list|,
literal|489
argument_list|,
literal|491
argument_list|,
literal|520
argument_list|,
literal|0
argument_list|,
name|DRM_MODE_FLAG_NHSYNC
operator||
name|DRM_MODE_FLAG_NVSYNC
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|intel_framebuffer_create
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_mode_fb_cmd2
modifier|*
name|mode_cmd
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|intel_fb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|intel_fb
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_framebuffer_init
argument_list|(
name|dev
argument_list|,
name|intel_fb
argument_list|,
name|mode_cmd
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|drm_gem_object_unreference_unlocked
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intel_fb
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
operator|*
name|res
operator|=
operator|&
name|intel_fb
operator|->
name|base
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|intel_framebuffer_pitch_for_width
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|bpp
parameter_list|)
block|{
name|u32
name|pitch
init|=
name|howmany
argument_list|(
name|width
operator|*
name|bpp
argument_list|,
literal|8
argument_list|)
decl_stmt|;
return|return
name|roundup2
argument_list|(
name|pitch
argument_list|,
literal|64
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|intel_framebuffer_size_for_mode
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|int
name|bpp
parameter_list|)
block|{
name|u32
name|pitch
init|=
name|intel_framebuffer_pitch_for_width
argument_list|(
name|mode
operator|->
name|hdisplay
argument_list|,
name|bpp
argument_list|)
decl_stmt|;
return|return
name|roundup2
argument_list|(
name|pitch
operator|*
name|mode
operator|->
name|vdisplay
argument_list|,
name|PAGE_SIZE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_framebuffer_create_for_mode
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|bpp
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_mode_fb_cmd2
name|mode_cmd
decl_stmt|;
name|obj
operator|=
name|i915_gem_alloc_object
argument_list|(
name|dev
argument_list|,
name|intel_framebuffer_size_for_mode
argument_list|(
name|mode
argument_list|,
name|bpp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|mode_cmd
operator|.
name|width
operator|=
name|mode
operator|->
name|hdisplay
expr_stmt|;
name|mode_cmd
operator|.
name|height
operator|=
name|mode
operator|->
name|vdisplay
expr_stmt|;
name|mode_cmd
operator|.
name|pitches
index|[
literal|0
index|]
operator|=
name|intel_framebuffer_pitch_for_width
argument_list|(
name|mode_cmd
operator|.
name|width
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
name|mode_cmd
operator|.
name|pixel_format
operator|=
name|drm_mode_legacy_fb_format
argument_list|(
name|bpp
argument_list|,
name|depth
argument_list|)
expr_stmt|;
return|return
operator|(
name|intel_framebuffer_create
argument_list|(
name|dev
argument_list|,
operator|&
name|mode_cmd
argument_list|,
name|obj
argument_list|,
name|res
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mode_fits_in_fbdev
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|fbdev
operator|==
name|NULL
condition|)
block|{
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|obj
operator|=
name|dev_priv
operator|->
name|fbdev
operator|->
name|ifb
operator|.
name|obj
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fb
operator|=
operator|&
name|dev_priv
operator|->
name|fbdev
operator|->
name|ifb
operator|.
name|base
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|<
name|intel_framebuffer_pitch_for_width
argument_list|(
name|mode
operator|->
name|hdisplay
argument_list|,
name|fb
operator|->
name|bits_per_pixel
argument_list|)
condition|)
block|{
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|size
operator|<
name|mode
operator|->
name|vdisplay
operator|*
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|res
operator|=
name|fb
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|intel_get_load_detect_pipe
parameter_list|(
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
parameter_list|,
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|intel_load_detect_pipe
modifier|*
name|old
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|possible_crtc
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
operator|&
name|intel_encoder
operator|->
name|base
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|,
name|r
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s], [ENCODER:%d:%s]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
name|encoder
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Algorithm gets a little messy: 	 * 	 *   - if the connector already has an assigned crtc, use it (but make 	 *     sure it's on first) 	 * 	 *   - try to find the first unused crtc that can drive this connector, 	 *     and use that if we find one 	 */
comment|/* See if we already have a CRTC for this connector */
if|if
condition|(
name|encoder
operator|->
name|crtc
condition|)
block|{
name|crtc
operator|=
name|encoder
operator|->
name|crtc
expr_stmt|;
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|old
operator|->
name|dpms_mode
operator|=
name|intel_crtc
operator|->
name|dpms_mode
expr_stmt|;
name|old
operator|->
name|load_detect_temp
operator|=
name|false
expr_stmt|;
comment|/* Make sure the crtc and connector are running */
if|if
condition|(
name|intel_crtc
operator|->
name|dpms_mode
operator|!=
name|DRM_MODE_DPMS_ON
condition|)
block|{
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
decl_stmt|;
name|struct
name|drm_crtc_helper_funcs
modifier|*
name|crtc_funcs
decl_stmt|;
name|crtc_funcs
operator|=
name|crtc
operator|->
name|helper_private
expr_stmt|;
name|crtc_funcs
operator|->
name|dpms
argument_list|(
name|crtc
argument_list|,
name|DRM_MODE_DPMS_ON
argument_list|)
expr_stmt|;
name|encoder_funcs
operator|=
name|encoder
operator|->
name|helper_private
expr_stmt|;
name|encoder_funcs
operator|->
name|dpms
argument_list|(
name|encoder
argument_list|,
name|DRM_MODE_DPMS_ON
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
comment|/* Find an unused one (if possible) */
name|list_for_each_entry
argument_list|(
argument|possible_crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|encoder
operator|->
name|possible_crtcs
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|possible_crtc
operator|->
name|enabled
condition|)
block|{
name|crtc
operator|=
name|possible_crtc
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If we didn't find an unused CRTC, don't use any. 	 */
if|if
condition|(
operator|!
name|crtc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"no pipe available for load-detect\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|encoder
operator|->
name|crtc
operator|=
name|crtc
expr_stmt|;
name|connector
operator|->
name|encoder
operator|=
name|encoder
expr_stmt|;
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|old
operator|->
name|dpms_mode
operator|=
name|intel_crtc
operator|->
name|dpms_mode
expr_stmt|;
name|old
operator|->
name|load_detect_temp
operator|=
name|true
expr_stmt|;
name|old
operator|->
name|release_fb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
name|mode
operator|=
operator|&
name|load_detect_mode
expr_stmt|;
name|old_fb
operator|=
name|crtc
operator|->
name|fb
expr_stmt|;
comment|/* We need a framebuffer large enough to accommodate all accesses 	 * that the plane may generate whilst we perform load detection. 	 * We can not rely on the fbcon either being present (we get called 	 * during its initialisation to detect all boot displays, or it may 	 * not even exist) or that it is large enough to satisfy the 	 * requested mode. 	 */
name|r
operator|=
name|mode_fits_in_fbdev
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|,
operator|&
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|fb
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"creating tmp fb for load-detection\n"
argument_list|)
expr_stmt|;
name|r
operator|=
name|intel_framebuffer_create_for_mode
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|,
literal|24
argument_list|,
literal|32
argument_list|,
operator|&
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
name|old
operator|->
name|release_fb
operator|=
name|crtc
operator|->
name|fb
expr_stmt|;
block|}
else|else
name|DRM_DEBUG_KMS
argument_list|(
literal|"reusing fbdev for load-detection framebuffer\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"failed to allocate framebuffer for load-detection\n"
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|fb
operator|=
name|old_fb
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|drm_crtc_helper_set_mode
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|old_fb
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"failed to set mode on load-detect pipe\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|release_fb
condition|)
name|old
operator|->
name|release_fb
operator|->
name|funcs
operator|->
name|destroy
argument_list|(
name|old
operator|->
name|release_fb
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|fb
operator|=
name|old_fb
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* let the connector get through one full cycle before testing */
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|intel_release_load_detect_pipe
parameter_list|(
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
parameter_list|,
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|intel_load_detect_pipe
modifier|*
name|old
parameter_list|)
block|{
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
operator|&
name|intel_encoder
operator|->
name|base
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|encoder
operator|->
name|crtc
decl_stmt|;
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
init|=
name|encoder
operator|->
name|helper_private
decl_stmt|;
name|struct
name|drm_crtc_helper_funcs
modifier|*
name|crtc_funcs
init|=
name|crtc
operator|->
name|helper_private
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s], [ENCODER:%d:%s]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
name|encoder
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|load_detect_temp
condition|)
block|{
name|connector
operator|->
name|encoder
operator|=
name|NULL
expr_stmt|;
name|drm_helper_disable_unused_functions
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|release_fb
condition|)
name|old
operator|->
name|release_fb
operator|->
name|funcs
operator|->
name|destroy
argument_list|(
name|old
operator|->
name|release_fb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Switch crtc and encoder back off if necessary */
if|if
condition|(
name|old
operator|->
name|dpms_mode
operator|!=
name|DRM_MODE_DPMS_ON
condition|)
block|{
name|encoder_funcs
operator|->
name|dpms
argument_list|(
name|encoder
argument_list|,
name|old
operator|->
name|dpms_mode
argument_list|)
expr_stmt|;
name|crtc_funcs
operator|->
name|dpms
argument_list|(
name|crtc
argument_list|,
name|old
operator|->
name|dpms_mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the clock of the currently programmed mode of the given pipe. */
end_comment

begin_function
specifier|static
name|int
name|intel_crtc_clock_get
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|dpll
init|=
name|I915_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
name|u32
name|fp
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|;
if|if
condition|(
operator|(
name|dpll
operator|&
name|DISPLAY_RATE_SELECT_FPA1
operator|)
operator|==
literal|0
condition|)
name|fp
operator|=
name|I915_READ
argument_list|(
name|FP0
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fp
operator|=
name|I915_READ
argument_list|(
name|FP1
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
operator|(
name|fp
operator|&
name|FP_M1_DIV_MASK
operator|)
operator|>>
name|FP_M1_DIV_SHIFT
expr_stmt|;
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|clock
operator|.
name|n
operator|=
name|ffs
argument_list|(
operator|(
name|fp
operator|&
name|FP_N_PINEVIEW_DIV_MASK
operator|)
operator|>>
name|FP_N_DIV_SHIFT
argument_list|)
operator|-
literal|1
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
operator|(
name|fp
operator|&
name|FP_M2_PINEVIEW_DIV_MASK
operator|)
operator|>>
name|FP_M2_DIV_SHIFT
expr_stmt|;
block|}
else|else
block|{
name|clock
operator|.
name|n
operator|=
operator|(
name|fp
operator|&
name|FP_N_DIV_MASK
operator|)
operator|>>
name|FP_N_DIV_SHIFT
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
operator|(
name|fp
operator|&
name|FP_M2_DIV_MASK
operator|)
operator|>>
name|FP_M2_DIV_SHIFT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|clock
operator|.
name|p1
operator|=
name|ffs
argument_list|(
operator|(
name|dpll
operator|&
name|DPLL_FPA01_P1_POST_DIV_MASK_PINEVIEW
operator|)
operator|>>
name|DPLL_FPA01_P1_POST_DIV_SHIFT_PINEVIEW
argument_list|)
expr_stmt|;
else|else
name|clock
operator|.
name|p1
operator|=
name|ffs
argument_list|(
operator|(
name|dpll
operator|&
name|DPLL_FPA01_P1_POST_DIV_MASK
operator|)
operator|>>
name|DPLL_FPA01_P1_POST_DIV_SHIFT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dpll
operator|&
name|DPLL_MODE_MASK
condition|)
block|{
case|case
name|DPLLB_MODE_DAC_SERIAL
case|:
name|clock
operator|.
name|p2
operator|=
name|dpll
operator|&
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_5
condition|?
literal|5
else|:
literal|10
expr_stmt|;
break|break;
case|case
name|DPLLB_MODE_LVDS
case|:
name|clock
operator|.
name|p2
operator|=
name|dpll
operator|&
name|DPLLB_LVDS_P2_CLOCK_DIV_7
condition|?
literal|7
else|:
literal|14
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unknown DPLL mode %08x in programmed "
literal|"mode\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dpll
operator|&
name|DPLL_MODE_MASK
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* XXX: Handle the 100Mhz refclk */
name|intel_clock
argument_list|(
name|dev
argument_list|,
literal|96000
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|is_lvds
init|=
operator|(
name|pipe
operator|==
literal|1
operator|)
operator|&&
operator|(
name|I915_READ
argument_list|(
name|LVDS
argument_list|)
operator|&
name|LVDS_PORT_EN
operator|)
decl_stmt|;
if|if
condition|(
name|is_lvds
condition|)
block|{
name|clock
operator|.
name|p1
operator|=
name|ffs
argument_list|(
operator|(
name|dpll
operator|&
name|DPLL_FPA01_P1_POST_DIV_MASK_I830_LVDS
operator|)
operator|>>
name|DPLL_FPA01_P1_POST_DIV_SHIFT
argument_list|)
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|14
expr_stmt|;
if|if
condition|(
operator|(
name|dpll
operator|&
name|PLL_REF_INPUT_MASK
operator|)
operator|==
name|PLLB_REF_INPUT_SPREADSPECTRUMIN
condition|)
block|{
comment|/* XXX: might not be 66MHz */
name|intel_clock
argument_list|(
name|dev
argument_list|,
literal|66000
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
block|}
else|else
name|intel_clock
argument_list|(
name|dev
argument_list|,
literal|48000
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dpll
operator|&
name|PLL_P1_DIVIDE_BY_TWO
condition|)
name|clock
operator|.
name|p1
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|clock
operator|.
name|p1
operator|=
operator|(
operator|(
name|dpll
operator|&
name|DPLL_FPA01_P1_POST_DIV_MASK_I830
operator|)
operator|>>
name|DPLL_FPA01_P1_POST_DIV_SHIFT
operator|)
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|dpll
operator|&
name|PLL_P2_DIVIDE_BY_4
condition|)
name|clock
operator|.
name|p2
operator|=
literal|4
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
literal|2
expr_stmt|;
name|intel_clock
argument_list|(
name|dev
argument_list|,
literal|48000
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* XXX: It would be nice to validate the clocks, but we can't reuse 	 * i830PllIsValid() because it relies on the xf86_config connector 	 * configuration being accurate, which it isn't necessarily. 	 */
return|return
name|clock
operator|.
name|dot
return|;
block|}
end_function

begin_comment
comment|/** Returns the currently programmed mode of the given pipe. */
end_comment

begin_function
name|struct
name|drm_display_mode
modifier|*
name|intel_crtc_mode_get
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|int
name|htot
init|=
name|I915_READ
argument_list|(
name|HTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|hsync
init|=
name|I915_READ
argument_list|(
name|HSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|vtot
init|=
name|I915_READ
argument_list|(
name|VTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|vsync
init|=
name|I915_READ
argument_list|(
name|VSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
name|mode
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mode
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mode
operator|->
name|clock
operator|=
name|intel_crtc_clock_get
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
name|mode
operator|->
name|hdisplay
operator|=
operator|(
name|htot
operator|&
literal|0xffff
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|htotal
operator|=
operator|(
operator|(
name|htot
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|hsync_start
operator|=
operator|(
name|hsync
operator|&
literal|0xffff
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|hsync_end
operator|=
operator|(
operator|(
name|hsync
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|vdisplay
operator|=
operator|(
name|vtot
operator|&
literal|0xffff
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|vtotal
operator|=
operator|(
operator|(
name|vtot
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|vsync_start
operator|=
operator|(
name|vsync
operator|&
literal|0xffff
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|vsync_end
operator|=
operator|(
operator|(
name|vsync
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
name|drm_mode_set_name
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|drm_mode_set_crtcinfo
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|mode
return|;
block|}
end_function

begin_define
define|#
directive|define
name|GPU_IDLE_TIMEOUT
value|(500
comment|/* ms */
value|* 1000 / hz)
end_define

begin_comment
comment|/* When this timer fires, we've been idle for awhile */
end_comment

begin_function
specifier|static
name|void
name|intel_gpu_idle_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|arg
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|active_list
argument_list|)
condition|)
block|{
comment|/* Still processing requests, so just re-arm the timer. */
name|callout_schedule
argument_list|(
operator|&
name|dev_priv
operator|->
name|idle_callout
argument_list|,
name|GPU_IDLE_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|dev_priv
operator|->
name|busy
operator|=
name|false
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|idle_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|CRTC_IDLE_TIMEOUT
value|(1000
comment|/* ms */
value|* 1000 / hz)
end_define

begin_function
specifier|static
name|void
name|intel_crtc_idle_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|arg
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
operator|&
name|intel_crtc
operator|->
name|base
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|crtc
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_fb
operator|&&
name|intel_fb
operator|->
name|obj
operator|->
name|active
condition|)
block|{
comment|/* The framebuffer is still being accessed by the GPU. */
name|callout_schedule
argument_list|(
operator|&
name|intel_crtc
operator|->
name|idle_callout
argument_list|,
name|CRTC_IDLE_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|intel_crtc
operator|->
name|busy
operator|=
name|false
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|idle_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_increase_pllclock
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|dpll_reg
init|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|int
name|dpll
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|lvds_downclock_avail
condition|)
return|return;
name|dpll
operator|=
name|I915_READ
argument_list|(
name|dpll_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HAS_PIPE_CXSR
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|dpll
operator|&
name|DISPLAY_RATE_SELECT_FPA1
operator|)
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"upclocking LVDS\n"
argument_list|)
expr_stmt|;
name|assert_panel_unlocked
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|dpll
operator|&=
operator|~
name|DISPLAY_RATE_SELECT_FPA1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|dpll_reg
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|dpll
operator|=
name|I915_READ
argument_list|(
name|dpll_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpll
operator|&
name|DISPLAY_RATE_SELECT_FPA1
condition|)
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"failed to upclock LVDS!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Schedule downclock */
name|callout_reset
argument_list|(
operator|&
name|intel_crtc
operator|->
name|idle_callout
argument_list|,
name|CRTC_IDLE_TIMEOUT
argument_list|,
name|intel_crtc_idle_timer
argument_list|,
name|intel_crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_decrease_pllclock
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|lvds_downclock_avail
condition|)
return|return;
comment|/* 	 * Since this is called by a timer, we should never get here in 	 * the manual case. 	 */
if|if
condition|(
operator|!
name|HAS_PIPE_CXSR
argument_list|(
name|dev
argument_list|)
operator|&&
name|intel_crtc
operator|->
name|lowfreq_avail
condition|)
block|{
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|dpll_reg
init|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|u32
name|dpll
decl_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"downclocking LVDS\n"
argument_list|)
expr_stmt|;
name|assert_panel_unlocked
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|dpll
operator|=
name|I915_READ
argument_list|(
name|dpll_reg
argument_list|)
expr_stmt|;
name|dpll
operator||=
name|DISPLAY_RATE_SELECT_FPA1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|dpll_reg
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|dpll
operator|=
name|I915_READ
argument_list|(
name|dpll_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dpll
operator|&
name|DISPLAY_RATE_SELECT_FPA1
operator|)
condition|)
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"failed to downclock LVDS!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * intel_idle_update - adjust clocks for idleness  * @work: work struct  *  * Either the GPU or display (or both) went idle.  Check the busy status  * here and adjust the CRTC and GPU clocks as necessary.  */
end_comment

begin_function
specifier|static
name|void
name|intel_idle_update
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|arg
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|dev_priv
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
if|if
condition|(
operator|!
name|i915_powersave
condition|)
return|return;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_update_gfx_val
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
comment|/* Skip inactive CRTCs */
if|if
condition|(
operator|!
name|crtc
operator|->
name|fb
condition|)
continue|continue;
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|busy
condition|)
name|intel_decrease_pllclock
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_mark_busy - mark the GPU and possibly the display busy  * @dev: drm device  * @obj: object we're operating on  *  * Callers can use this function to indicate that the GPU is busy processing  * commands.  If @obj matches one of the CRTC objects (i.e. it's a scanout  * buffer), we'll also mark the display as busy, so we know to increase its  * clock frequency.  */
end_comment

begin_function
name|void
name|intel_mark_busy
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|NULL
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|busy
condition|)
name|dev_priv
operator|->
name|busy
operator|=
name|true
expr_stmt|;
else|else
name|callout_reset
argument_list|(
operator|&
name|dev_priv
operator|->
name|idle_callout
argument_list|,
name|GPU_IDLE_TIMEOUT
argument_list|,
name|intel_gpu_idle_timer
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|!
name|crtc
operator|->
name|fb
condition|)
continue|continue;
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_fb
operator|->
name|obj
operator|==
name|obj
condition|)
block|{
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|busy
condition|)
block|{
comment|/* Non-busy -> busy, upclock */
name|intel_increase_pllclock
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|busy
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* Busy -> busy, put off timer */
name|callout_reset
argument_list|(
operator|&
name|intel_crtc
operator|->
name|idle_callout
argument_list|,
name|CRTC_IDLE_TIMEOUT
argument_list|,
name|intel_crtc_idle_timer
argument_list|,
name|intel_crtc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_destroy
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_unpin_work
modifier|*
name|work
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|work
operator|=
name|intel_crtc
operator|->
name|unpin_work
expr_stmt|;
name|intel_crtc
operator|->
name|unpin_work
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
condition|)
block|{
name|taskqueue_cancel
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|work
operator|->
name|task
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|work
operator|->
name|task
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
name|drm_crtc_cleanup
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intel_crtc
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_unpin_work_fn
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|intel_unpin_work
modifier|*
name|work
init|=
name|arg
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|work
operator|->
name|dev
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_unpin_fb_obj
argument_list|(
name|work
operator|->
name|old_fb_obj
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|work
operator|->
name|pending_flip_obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|work
operator|->
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_intel_finish_page_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_unpin_work
modifier|*
name|work
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_pending_vblank_event
modifier|*
name|e
decl_stmt|;
name|struct
name|timeval
name|tnow
decl_stmt|,
name|tvbl
decl_stmt|;
comment|/* Ignore early vblank irqs */
if|if
condition|(
name|intel_crtc
operator|==
name|NULL
condition|)
return|return;
name|microtime
argument_list|(
operator|&
name|tnow
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|work
operator|=
name|intel_crtc
operator|->
name|unpin_work
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|NULL
operator|||
operator|!
name|work
operator|->
name|pending
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|intel_crtc
operator|->
name|unpin_work
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|event
condition|)
block|{
name|e
operator|=
name|work
operator|->
name|event
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|sequence
operator|=
name|drm_vblank_count_and_time
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|,
operator|&
name|tvbl
argument_list|)
expr_stmt|;
comment|/* Called before vblank count and timestamps have 		 * been updated for the vblank interval of flip 		 * completion? Need to increment vblank count and 		 * add one videorefresh duration to returned timestamp 		 * to account for this. We assume this happened if we 		 * get called over 0.9 frame durations after the last 		 * timestamped vblank. 		 * 		 * This calculation can not be used with vrefresh rates 		 * below 5Hz (10Hz to be on the safe side) without 		 * promoting to 64 integers. 		 */
if|if
condition|(
literal|10
operator|*
operator|(
name|timeval_to_ns
argument_list|(
operator|&
name|tnow
argument_list|)
operator|-
name|timeval_to_ns
argument_list|(
operator|&
name|tvbl
argument_list|)
operator|)
operator|>
literal|9
operator|*
name|crtc
operator|->
name|framedur_ns
condition|)
block|{
name|e
operator|->
name|event
operator|.
name|sequence
operator|++
expr_stmt|;
name|tvbl
operator|=
name|ns_to_timeval
argument_list|(
name|timeval_to_ns
argument_list|(
operator|&
name|tvbl
argument_list|)
operator|+
name|crtc
operator|->
name|framedur_ns
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|event
operator|.
name|tv_sec
operator|=
name|tvbl
operator|.
name|tv_sec
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|tv_usec
operator|=
name|tvbl
operator|.
name|tv_usec
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|e
operator|->
name|base
operator|.
name|link
argument_list|,
operator|&
name|e
operator|->
name|base
operator|.
name|file_priv
operator|->
name|event_list
argument_list|)
expr_stmt|;
name|drm_event_wakeup
argument_list|(
operator|&
name|e
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|obj
operator|=
name|work
operator|->
name|old_fb_obj
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|,
literal|1
operator|<<
name|intel_crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|)
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|work
operator|->
name|task
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"i915_flip_complete %d %p"
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|,
name|work
operator|->
name|pending_flip_obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_finish_page_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|pipe
index|]
decl_stmt|;
name|do_intel_finish_page_flip
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_finish_page_flip_plane
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|dev_priv
operator|->
name|plane_to_crtc_mapping
index|[
name|plane
index|]
decl_stmt|;
name|do_intel_finish_page_flip
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_prepare_page_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|dev_priv
operator|->
name|plane_to_crtc_mapping
index|[
name|plane
index|]
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|unpin_work
condition|)
block|{
if|if
condition|(
operator|(
operator|++
name|intel_crtc
operator|->
name|unpin_work
operator|->
name|pending
operator|)
operator|>
literal|1
condition|)
name|DRM_ERROR
argument_list|(
literal|"Prepared flip multiple times\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG
argument_list|(
literal|"preparing flip with no unpin work?\n"
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_gen2_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|u32
name|flip_mask
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
comment|/* Offset into the new buffer for cases of shared fbs between CRTCs */
name|offset
operator|=
name|crtc
operator|->
name|y
operator|*
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|+
name|crtc
operator|->
name|x
operator|*
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
expr_stmt|;
name|ret
operator|=
name|BEGIN_LP_RING
argument_list|(
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
comment|/* Can't queue multiple flips, so wait for the previous 	 * one to finish before executing the next. 	 */
if|if
condition|(
name|intel_crtc
operator|->
name|plane
condition|)
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_B_FLIP
expr_stmt|;
else|else
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_A_FLIP
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_WAIT_FOR_EVENT
operator||
name|flip_mask
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_NOOP
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_DISPLAY_FLIP
operator||
name|MI_DISPLAY_FLIP_PLANE
argument_list|(
name|intel_crtc
operator|->
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|obj
operator|->
name|gtt_offset
operator|+
name|offset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* aux display base address, unused */
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_gen3_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|u32
name|flip_mask
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
comment|/* Offset into the new buffer for cases of shared fbs between CRTCs */
name|offset
operator|=
name|crtc
operator|->
name|y
operator|*
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|+
name|crtc
operator|->
name|x
operator|*
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
expr_stmt|;
name|ret
operator|=
name|BEGIN_LP_RING
argument_list|(
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|intel_crtc
operator|->
name|plane
condition|)
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_B_FLIP
expr_stmt|;
else|else
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_A_FLIP
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_WAIT_FOR_EVENT
operator||
name|flip_mask
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_NOOP
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_DISPLAY_FLIP_I915
operator||
name|MI_DISPLAY_FLIP_PLANE
argument_list|(
name|intel_crtc
operator|->
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|obj
operator|->
name|gtt_offset
operator|+
name|offset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_NOOP
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_gen4_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|uint32_t
name|pf
decl_stmt|,
name|pipesrc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|BEGIN_LP_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
comment|/* i965+ uses the linear or tiled offsets from the 	 * Display Registers (which do not change across a page-flip) 	 * so we need only reprogram the base address. 	 */
name|OUT_RING
argument_list|(
name|MI_DISPLAY_FLIP
operator||
name|MI_DISPLAY_FLIP_PLANE
argument_list|(
name|intel_crtc
operator|->
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|obj
operator|->
name|gtt_offset
operator||
name|obj
operator|->
name|tiling_mode
argument_list|)
expr_stmt|;
comment|/* XXX Enabling the panel-fitter across page-flip is so far 	 * untested on non-native modes, so ignore it for now. 	 * pf = I915_READ(pipe == 0 ? PFA_CTL_1 : PFB_CTL_1)& PF_ENABLE; 	 */
name|pf
operator|=
literal|0
expr_stmt|;
name|pipesrc
operator|=
name|I915_READ
argument_list|(
name|PIPESRC
argument_list|(
name|intel_crtc
operator|->
name|pipe
argument_list|)
argument_list|)
operator|&
literal|0x0fff0fff
expr_stmt|;
name|OUT_RING
argument_list|(
name|pf
operator||
name|pipesrc
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_gen6_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|uint32_t
name|pf
decl_stmt|,
name|pipesrc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|BEGIN_LP_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|OUT_RING
argument_list|(
name|MI_DISPLAY_FLIP
operator||
name|MI_DISPLAY_FLIP_PLANE
argument_list|(
name|intel_crtc
operator|->
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator||
name|obj
operator|->
name|tiling_mode
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|obj
operator|->
name|gtt_offset
argument_list|)
expr_stmt|;
comment|/* Contrary to the suggestions in the documentation, 	 * "Enable Panel Fitter" does not seem to be required when page 	 * flipping with a non-native mode, and worse causes a normal 	 * modeset to fail. 	 * pf = I915_READ(PF_CTL(intel_crtc->pipe))& PF_ENABLE; 	 */
name|pf
operator|=
literal|0
expr_stmt|;
name|pipesrc
operator|=
name|I915_READ
argument_list|(
name|PIPESRC
argument_list|(
name|intel_crtc
operator|->
name|pipe
argument_list|)
argument_list|)
operator|&
literal|0x0fff0fff
expr_stmt|;
name|OUT_RING
argument_list|(
name|pf
operator||
name|pipesrc
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * On gen7 we currently use the blit ring because (in early silicon at least)  * the render ring doesn't give us interrpts for page flip completion, which  * means clients will hang after the first flip is queued.  Fortunately the  * blit ring generates interrupts properly, so use it instead.  */
end_comment

begin_function
specifier|static
name|int
name|intel_gen7_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|BCS
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_DISPLAY_FLIP_I915
operator||
operator|(
name|intel_crtc
operator|->
name|plane
operator|<<
literal|19
operator|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
operator|(
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator||
name|obj
operator|->
name|tiling_mode
operator|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
operator|(
name|obj
operator|->
name|gtt_offset
operator|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
operator|(
name|MI_NOOP
operator|)
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_default_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
return|return
operator|-
name|ENODEV
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_crtc_page_flip
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_pending_vblank_event
modifier|*
name|event
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_unpin_work
modifier|*
name|work
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|work
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|work
operator|->
name|event
operator|=
name|event
expr_stmt|;
name|work
operator|->
name|dev
operator|=
name|crtc
operator|->
name|dev
expr_stmt|;
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
name|work
operator|->
name|old_fb_obj
operator|=
name|intel_fb
operator|->
name|obj
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|work
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|intel_unpin_work_fn
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_vblank_get
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|free_work
goto|;
comment|/* We borrow the event spin lock for protecting unpin_work */
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|unpin_work
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"flip queue: crtc already busy\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
name|intel_crtc
operator|->
name|unpin_work
operator|=
name|work
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|obj
operator|=
name|intel_fb
operator|->
name|obj
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Reference the objects for the scheduled work. */
name|drm_gem_object_reference
argument_list|(
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|drm_gem_object_reference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|fb
operator|=
name|fb
expr_stmt|;
name|work
operator|->
name|pending_flip_obj
operator|=
name|obj
expr_stmt|;
name|work
operator|->
name|enable_stall_check
operator|=
name|true
expr_stmt|;
comment|/* Block clients from rendering to the new back buffer until 	 * the flip occurs and the object is no longer visible. 	 */
name|atomic_set_int
argument_list|(
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|pending_flip
argument_list|,
literal|1
operator|<<
name|intel_crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
name|fb
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup_pending
goto|;
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"i915_flip_request %d %p"
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|cleanup_pending
label|:
name|atomic_sub
argument_list|(
literal|1
operator|<<
name|intel_crtc
operator|->
name|plane
argument_list|,
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|pending_flip
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|unpin_work
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|free_work
label|:
name|free
argument_list|(
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_sanitize_modesetting
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|val
decl_stmt|;
comment|/* Clear any frame start delays used for debugging left by the BIOS */
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
block|{
name|reg
operator|=
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
operator|~
name|PIPECONF_FRAME_START_DELAY_MASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
comment|/* Who knows what state these registers were left in by the BIOS or 	 * grub? 	 * 	 * If we leave the registers in a conflicting state (e.g. with the 	 * display plane reading from the other pipe than the one we intend 	 * to use) then when we attempt to teardown the active mode, we will 	 * not disable the pipes and planes in the correct order -- leaving 	 * a plane reading from a disabled pipe and possibly leading to 	 * undefined behaviour. 	 */
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|!
operator|(
name|val
operator|&
name|DISPPLANE_SEL_PIPE_MASK
operator|)
operator|==
name|pipe
condition|)
return|return;
comment|/* This display plane is active and attached to the other CPU pipe. */
name|pipe
operator|=
operator|!
name|pipe
expr_stmt|;
comment|/* Disable the plane and wait for it to stop reading from the pipe. */
name|intel_disable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_disable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_reset
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
comment|/* Reset flags back to the 'unknown' status so that they 	 * will be correctly set on the initial modeset. 	 */
name|intel_crtc
operator|->
name|dpms_mode
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We need to fix up any BIOS configuration that conflicts with 	 * our expectations. 	 */
name|intel_sanitize_modesetting
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|drm_crtc_helper_funcs
name|intel_helper_funcs
init|=
block|{
operator|.
name|dpms
operator|=
name|intel_crtc_dpms
block|,
operator|.
name|mode_fixup
operator|=
name|intel_crtc_mode_fixup
block|,
operator|.
name|mode_set
operator|=
name|intel_crtc_mode_set
block|,
operator|.
name|mode_set_base
operator|=
name|intel_pipe_set_base
block|,
operator|.
name|mode_set_base_atomic
operator|=
name|intel_pipe_set_base_atomic
block|,
operator|.
name|load_lut
operator|=
name|intel_crtc_load_lut
block|,
operator|.
name|disable
operator|=
name|intel_crtc_disable
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_crtc_funcs
name|intel_crtc_funcs
init|=
block|{
operator|.
name|reset
operator|=
name|intel_crtc_reset
block|,
operator|.
name|cursor_set
operator|=
name|intel_crtc_cursor_set
block|,
operator|.
name|cursor_move
operator|=
name|intel_crtc_cursor_move
block|,
operator|.
name|gamma_set
operator|=
name|intel_crtc_gamma_set
block|,
operator|.
name|set_config
operator|=
name|drm_crtc_helper_set_config
block|,
operator|.
name|destroy
operator|=
name|intel_crtc_destroy
block|,
operator|.
name|page_flip
operator|=
name|intel_crtc_page_flip
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|intel_crtc_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|intel_crtc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intel_crtc
argument_list|)
operator|+
operator|(
name|INTELFB_CONN_LIMIT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_connector
operator|*
argument_list|)
operator|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|drm_crtc_init
argument_list|(
name|dev
argument_list|,
operator|&
name|intel_crtc
operator|->
name|base
argument_list|,
operator|&
name|intel_crtc_funcs
argument_list|)
expr_stmt|;
name|drm_mode_crtc_set_gamma_size
argument_list|(
operator|&
name|intel_crtc
operator|->
name|base
argument_list|,
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|intel_crtc
operator|->
name|lut_r
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|intel_crtc
operator|->
name|lut_g
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|intel_crtc
operator|->
name|lut_b
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* Swap pipes& planes for FBC on pre-965 */
name|intel_crtc
operator|->
name|pipe
operator|=
name|pipe
expr_stmt|;
name|intel_crtc
operator|->
name|plane
operator|=
name|pipe
expr_stmt|;
if|if
condition|(
name|IS_MOBILE
argument_list|(
name|dev
argument_list|)
operator|&&
name|IS_GEN3
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"swapping pipes& planes for FBC\n"
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|plane
operator|=
operator|!
name|pipe
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|pipe
operator|<
name|DRM_ARRAY_SIZE
argument_list|(
name|dev_priv
operator|->
name|plane_to_crtc_mapping
argument_list|)
operator|&&
name|dev_priv
operator|->
name|plane_to_crtc_mapping
index|[
name|intel_crtc
operator|->
name|plane
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"plane_to_crtc is already initialized"
operator|)
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|plane_to_crtc_mapping
index|[
name|intel_crtc
operator|->
name|plane
index|]
operator|=
operator|&
name|intel_crtc
operator|->
name|base
expr_stmt|;
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|intel_crtc
operator|->
name|pipe
index|]
operator|=
operator|&
name|intel_crtc
operator|->
name|base
expr_stmt|;
name|intel_crtc_reset
argument_list|(
operator|&
name|intel_crtc
operator|->
name|base
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|active
operator|=
name|true
expr_stmt|;
comment|/* force the pipe off on setup_init_config */
name|intel_crtc
operator|->
name|bpp
operator|=
literal|24
expr_stmt|;
comment|/* default for pre-Ironlake */
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|pipe
operator|==
literal|2
operator|&&
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_crtc
operator|->
name|no_pll
operator|=
name|true
expr_stmt|;
name|intel_helper_funcs
operator|.
name|prepare
operator|=
name|ironlake_crtc_prepare
expr_stmt|;
name|intel_helper_funcs
operator|.
name|commit
operator|=
name|ironlake_crtc_commit
expr_stmt|;
block|}
else|else
block|{
name|intel_helper_funcs
operator|.
name|prepare
operator|=
name|i9xx_crtc_prepare
expr_stmt|;
name|intel_helper_funcs
operator|.
name|commit
operator|=
name|i9xx_crtc_commit
expr_stmt|;
block|}
name|drm_crtc_helper_add
argument_list|(
operator|&
name|intel_crtc
operator|->
name|base
argument_list|,
operator|&
name|intel_helper_funcs
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|busy
operator|=
name|false
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|intel_crtc
operator|->
name|idle_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|intel_get_pipe_from_crtc_id
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_get_pipe_from_crtc_id
modifier|*
name|pipe_from_crtc_id
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|drmmode_obj
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|crtc
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|drmmode_obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|pipe_from_crtc_id
operator|->
name|crtc_id
argument_list|,
name|DRM_MODE_OBJECT_CRTC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drmmode_obj
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"no such CRTC id\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|crtc
operator|=
name|to_intel_crtc
argument_list|(
name|obj_to_crtc
argument_list|(
name|drmmode_obj
argument_list|)
argument_list|)
expr_stmt|;
name|pipe_from_crtc_id
operator|->
name|pipe
operator|=
name|crtc
operator|->
name|pipe
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_encoder_clones
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|type_mask
parameter_list|)
block|{
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|int
name|index_mask
init|=
literal|0
decl_stmt|;
name|int
name|entry
init|=
literal|0
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|type_mask
operator|&
name|encoder
operator|->
name|clone_mask
condition|)
name|index_mask
operator||=
operator|(
literal|1
operator|<<
name|entry
operator|)
expr_stmt|;
name|entry
operator|++
expr_stmt|;
block|}
return|return
name|index_mask
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|has_edp_a
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|IS_MOBILE
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|DP_A
argument_list|)
operator|&
name|DP_DETECTED
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN_FUSES
argument_list|)
operator|&
name|ILK_eDP_A_DISABLE
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_setup_outputs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|bool
name|dpd_is_edp
init|=
name|false
decl_stmt|;
name|bool
name|has_lvds
decl_stmt|;
name|has_lvds
operator|=
name|intel_lvds_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_lvds
operator|&&
operator|!
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* disable the panel fitter on everything but LVDS */
name|I915_WRITE
argument_list|(
name|PFIT_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dpd_is_edp
operator|=
name|intel_dpd_is_edp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_edp_a
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|DP_A
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpd_is_edp
operator|&&
operator|(
name|I915_READ
argument_list|(
name|PCH_DP_D
argument_list|)
operator|&
name|DP_DETECTED
operator|)
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|PCH_DP_D
argument_list|)
expr_stmt|;
block|}
name|intel_crt_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|int
name|found
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"HDMIB %d PCH_DP_B %d HDMIC %d HDMID %d PCH_DP_C %d PCH_DP_D %d LVDS %d\n"
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|HDMIB
argument_list|)
operator|&
name|PORT_DETECTED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|PCH_DP_B
argument_list|)
operator|&
name|DP_DETECTED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|HDMIC
argument_list|)
operator|&
name|PORT_DETECTED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|HDMID
argument_list|)
operator|&
name|PORT_DETECTED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|PCH_DP_C
argument_list|)
operator|&
name|DP_DETECTED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|PCH_DP_D
argument_list|)
operator|&
name|DP_DETECTED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
operator|&
name|LVDS_DETECTED
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|HDMIB
argument_list|)
operator|&
name|PORT_DETECTED
condition|)
block|{
comment|/* PCH SDVOB multiplex with HDMIB */
name|found
operator|=
name|intel_sdvo_init
argument_list|(
name|dev
argument_list|,
name|PCH_SDVOB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|HDMIB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
operator|&&
operator|(
name|I915_READ
argument_list|(
name|PCH_DP_B
argument_list|)
operator|&
name|DP_DETECTED
operator|)
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|PCH_DP_B
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|I915_READ
argument_list|(
name|HDMIC
argument_list|)
operator|&
name|PORT_DETECTED
condition|)
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|HDMIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|HDMID
argument_list|)
operator|&
name|PORT_DETECTED
condition|)
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|HDMID
argument_list|)
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|PCH_DP_C
argument_list|)
operator|&
name|DP_DETECTED
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|PCH_DP_C
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dpd_is_edp
operator|&&
operator|(
name|I915_READ
argument_list|(
name|PCH_DP_D
argument_list|)
operator|&
name|DP_DETECTED
operator|)
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|PCH_DP_D
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SUPPORTS_DIGITAL_OUTPUTS
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|bool
name|found
init|=
name|false
decl_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|SDVOB
argument_list|)
operator|&
name|SDVO_DETECTED
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing SDVOB\n"
argument_list|)
expr_stmt|;
name|found
operator|=
name|intel_sdvo_init
argument_list|(
name|dev
argument_list|,
name|SDVOB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
operator|&&
name|SUPPORTS_INTEGRATED_HDMI
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing HDMI on SDVOB\n"
argument_list|)
expr_stmt|;
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|SDVOB
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
operator|&&
name|SUPPORTS_INTEGRATED_DP
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing DP_B\n"
argument_list|)
expr_stmt|;
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|DP_B
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Before G4X SDVOC doesn't have its own detect register */
if|if
condition|(
name|I915_READ
argument_list|(
name|SDVOB
argument_list|)
operator|&
name|SDVO_DETECTED
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing SDVOC\n"
argument_list|)
expr_stmt|;
name|found
operator|=
name|intel_sdvo_init
argument_list|(
name|dev
argument_list|,
name|SDVOC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
operator|&&
operator|(
name|I915_READ
argument_list|(
name|SDVOC
argument_list|)
operator|&
name|SDVO_DETECTED
operator|)
condition|)
block|{
if|if
condition|(
name|SUPPORTS_INTEGRATED_HDMI
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing HDMI on SDVOC\n"
argument_list|)
expr_stmt|;
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|SDVOC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUPPORTS_INTEGRATED_DP
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing DP_C\n"
argument_list|)
expr_stmt|;
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|DP_C
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SUPPORTS_INTEGRATED_DP
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|I915_READ
argument_list|(
name|DP_D
argument_list|)
operator|&
name|DP_DETECTED
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing DP_D\n"
argument_list|)
expr_stmt|;
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|DP_D
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|#
directive|if
literal|1
name|KIB_NOTYET
argument_list|()
expr_stmt|;
else|#
directive|else
name|intel_dvo_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|SUPPORTS_TV
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_tv_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|encoder
operator|->
name|base
operator|.
name|possible_crtcs
operator|=
name|encoder
operator|->
name|crtc_mask
expr_stmt|;
name|encoder
operator|->
name|base
operator|.
name|possible_clones
operator|=
name|intel_encoder_clones
argument_list|(
name|dev
argument_list|,
name|encoder
operator|->
name|clone_mask
argument_list|)
expr_stmt|;
block|}
comment|/* disable all the possible outputs/crtcs before entering KMS mode */
name|drm_helper_disable_unused_functions
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|ironlake_init_pch_refclk
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_user_framebuffer_destroy
parameter_list|(
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|)
block|{
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
init|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
decl_stmt|;
name|drm_framebuffer_cleanup
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference_unlocked
argument_list|(
operator|&
name|intel_fb
operator|->
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intel_fb
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_user_framebuffer_create_handle
parameter_list|(
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
init|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|intel_fb
operator|->
name|obj
decl_stmt|;
return|return
name|drm_gem_handle_create
argument_list|(
name|file
argument_list|,
operator|&
name|obj
operator|->
name|base
argument_list|,
name|handle
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_framebuffer_funcs
name|intel_fb_funcs
init|=
block|{
operator|.
name|destroy
operator|=
name|intel_user_framebuffer_destroy
block|,
operator|.
name|create_handle
operator|=
name|intel_user_framebuffer_create_handle
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|intel_framebuffer_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
parameter_list|,
name|struct
name|drm_mode_fb_cmd2
modifier|*
name|mode_cmd
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_Y
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|mode_cmd
operator|->
name|pitches
index|[
literal|0
index|]
operator|&
literal|63
condition|)
return|return
operator|-
name|EINVAL
return|;
switch|switch
condition|(
name|mode_cmd
operator|->
name|pixel_format
condition|)
block|{
case|case
name|DRM_FORMAT_RGB332
case|:
case|case
name|DRM_FORMAT_RGB565
case|:
case|case
name|DRM_FORMAT_XRGB8888
case|:
case|case
name|DRM_FORMAT_XBGR8888
case|:
case|case
name|DRM_FORMAT_ARGB8888
case|:
case|case
name|DRM_FORMAT_XRGB2101010
case|:
case|case
name|DRM_FORMAT_ARGB2101010
case|:
comment|/* RGB formats are common across chipsets */
break|break;
case|case
name|DRM_FORMAT_YUYV
case|:
case|case
name|DRM_FORMAT_UYVY
case|:
case|case
name|DRM_FORMAT_YVYU
case|:
case|case
name|DRM_FORMAT_VYUY
case|:
break|break;
default|default:
name|DRM_DEBUG_KMS
argument_list|(
literal|"unsupported pixel format %u\n"
argument_list|,
name|mode_cmd
operator|->
name|pixel_format
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|ret
operator|=
name|drm_framebuffer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|intel_fb
operator|->
name|base
argument_list|,
operator|&
name|intel_fb_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"framebuffer init failed %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|drm_helper_mode_fill_fb_struct
argument_list|(
operator|&
name|intel_fb
operator|->
name|base
argument_list|,
name|mode_cmd
argument_list|)
expr_stmt|;
name|intel_fb
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_user_framebuffer_create
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|filp
parameter_list|,
name|struct
name|drm_mode_fb_cmd2
modifier|*
name|mode_cmd
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|,
name|mode_cmd
operator|->
name|handles
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOENT
operator|)
return|;
return|return
operator|(
name|intel_framebuffer_create
argument_list|(
name|dev
argument_list|,
name|mode_cmd
argument_list|,
name|obj
argument_list|,
name|res
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_mode_config_funcs
name|intel_mode_funcs
init|=
block|{
operator|.
name|fb_create
operator|=
name|intel_user_framebuffer_create
block|,
operator|.
name|output_poll_changed
operator|=
name|intel_fb_output_poll_changed
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|drm_i915_gem_object
modifier|*
name|intel_alloc_context_page
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|ctx
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_LOCK_ASSERT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|i915_gem_alloc_object
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"failed to alloc power context, RC6 disabled\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|=
name|i915_gem_object_pin
argument_list|(
name|ctx
argument_list|,
literal|4096
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to pin power context: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unref
goto|;
block|}
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to set-domain on power context: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unpin
goto|;
block|}
return|return
name|ctx
return|;
name|err_unpin
label|:
name|i915_gem_object_unpin
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|err_unref
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|ctx
operator|->
name|base
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|bool
name|ironlake_set_drps
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|u8
name|val
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u16
name|rgvswctl
decl_stmt|;
name|rgvswctl
operator|=
name|I915_READ16
argument_list|(
name|MEMSWCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rgvswctl
operator|&
name|MEMCTL_CMD_STS
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"gpu busy, RCS change rejected\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
comment|/* still busy with another command */
block|}
name|rgvswctl
operator|=
operator|(
name|MEMCTL_CMD_CHFREQ
operator|<<
name|MEMCTL_CMD_SHIFT
operator|)
operator||
operator|(
name|val
operator|<<
name|MEMCTL_FREQ_SHIFT
operator|)
operator||
name|MEMCTL_SFCAVM
expr_stmt|;
name|I915_WRITE16
argument_list|(
name|MEMSWCTL
argument_list|,
name|rgvswctl
argument_list|)
expr_stmt|;
name|POSTING_READ16
argument_list|(
name|MEMSWCTL
argument_list|)
expr_stmt|;
name|rgvswctl
operator||=
name|MEMCTL_CMD_STS
expr_stmt|;
name|I915_WRITE16
argument_list|(
name|MEMSWCTL
argument_list|,
name|rgvswctl
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|ironlake_enable_drps
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|rgvmodectl
init|=
name|I915_READ
argument_list|(
name|MEMMODECTL
argument_list|)
decl_stmt|;
name|u8
name|fmax
decl_stmt|,
name|fmin
decl_stmt|,
name|fstart
decl_stmt|,
name|vstart
decl_stmt|;
comment|/* Enable temp reporting */
name|I915_WRITE16
argument_list|(
name|PMMISC
argument_list|,
name|I915_READ
argument_list|(
name|PMMISC
argument_list|)
operator||
name|MCPPCE_EN
argument_list|)
expr_stmt|;
name|I915_WRITE16
argument_list|(
name|TSC1
argument_list|,
name|I915_READ
argument_list|(
name|TSC1
argument_list|)
operator||
name|TSE
argument_list|)
expr_stmt|;
comment|/* 100ms RC evaluation intervals */
name|I915_WRITE
argument_list|(
name|RCUPEI
argument_list|,
literal|100000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RCDNEI
argument_list|,
literal|100000
argument_list|)
expr_stmt|;
comment|/* Set max/min thresholds to 90ms and 80ms respectively */
name|I915_WRITE
argument_list|(
name|RCBMAXAVG
argument_list|,
literal|90000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RCBMINAVG
argument_list|,
literal|80000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|MEMIHYST
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set up min, max, and cur for interrupt handling */
name|fmax
operator|=
operator|(
name|rgvmodectl
operator|&
name|MEMMODE_FMAX_MASK
operator|)
operator|>>
name|MEMMODE_FMAX_SHIFT
expr_stmt|;
name|fmin
operator|=
operator|(
name|rgvmodectl
operator|&
name|MEMMODE_FMIN_MASK
operator|)
expr_stmt|;
name|fstart
operator|=
operator|(
name|rgvmodectl
operator|&
name|MEMMODE_FSTART_MASK
operator|)
operator|>>
name|MEMMODE_FSTART_SHIFT
expr_stmt|;
name|vstart
operator|=
operator|(
name|I915_READ
argument_list|(
name|PXVFREQ_BASE
operator|+
operator|(
name|fstart
operator|*
literal|4
operator|)
argument_list|)
operator|&
name|PXVFREQ_PX_MASK
operator|)
operator|>>
name|PXVFREQ_PX_SHIFT
expr_stmt|;
name|dev_priv
operator|->
name|fmax
operator|=
name|fmax
expr_stmt|;
comment|/* IPS callback will increase this */
name|dev_priv
operator|->
name|fstart
operator|=
name|fstart
expr_stmt|;
name|dev_priv
operator|->
name|max_delay
operator|=
name|fstart
expr_stmt|;
name|dev_priv
operator|->
name|min_delay
operator|=
name|fmin
expr_stmt|;
name|dev_priv
operator|->
name|cur_delay
operator|=
name|fstart
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"fmax: %d, fmin: %d, fstart: %d\n"
argument_list|,
name|fmax
argument_list|,
name|fmin
argument_list|,
name|fstart
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|MEMINTREN
argument_list|,
name|MEMINT_CX_SUPR_EN
operator||
name|MEMINT_EVAL_CHG_EN
argument_list|)
expr_stmt|;
comment|/* 	 * Interrupts will be enabled in ironlake_irq_postinstall 	 */
name|I915_WRITE
argument_list|(
name|VIDSTART
argument_list|,
name|vstart
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|VIDSTART
argument_list|)
expr_stmt|;
name|rgvmodectl
operator||=
name|MEMMODE_SWMODE_EN
expr_stmt|;
name|I915_WRITE
argument_list|(
name|MEMMODECTL
argument_list|,
name|rgvmodectl
argument_list|)
expr_stmt|;
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|MEMSWCTL
argument_list|)
operator|&
name|MEMCTL_CMD_STS
operator|)
operator|==
literal|0
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|,
literal|"915per"
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"stuck trying to change perf mode\n"
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"915dsp"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ironlake_set_drps
argument_list|(
name|dev
argument_list|,
name|fstart
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|last_count1
operator|=
name|I915_READ
argument_list|(
literal|0x112e4
argument_list|)
operator|+
name|I915_READ
argument_list|(
literal|0x112e8
argument_list|)
operator|+
name|I915_READ
argument_list|(
literal|0x112e0
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|last_time1
operator|=
name|jiffies_to_msecs
argument_list|(
name|jiffies
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|last_count2
operator|=
name|I915_READ
argument_list|(
literal|0x112f4
argument_list|)
expr_stmt|;
name|nanotime
argument_list|(
operator|&
name|dev_priv
operator|->
name|last_time2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ironlake_disable_drps
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u16
name|rgvswctl
init|=
name|I915_READ16
argument_list|(
name|MEMSWCTL
argument_list|)
decl_stmt|;
comment|/* Ack interrupts, disable EFC interrupt */
name|I915_WRITE
argument_list|(
name|MEMINTREN
argument_list|,
name|I915_READ
argument_list|(
name|MEMINTREN
argument_list|)
operator|&
operator|~
name|MEMINT_EVAL_CHG_EN
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|MEMINTRSTS
argument_list|,
name|MEMINT_EVAL_CHG
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIER
argument_list|,
name|I915_READ
argument_list|(
name|DEIER
argument_list|)
operator|&
operator|~
name|DE_PCU_EVENT
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIIR
argument_list|,
name|DE_PCU_EVENT
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIMR
argument_list|,
name|I915_READ
argument_list|(
name|DEIMR
argument_list|)
operator||
name|DE_PCU_EVENT
argument_list|)
expr_stmt|;
comment|/* Go back to the starting frequency */
name|ironlake_set_drps
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|fstart
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"915dsp"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rgvswctl
operator||=
name|MEMCTL_CMD_STS
expr_stmt|;
name|I915_WRITE
argument_list|(
name|MEMSWCTL
argument_list|,
name|rgvswctl
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"915dsp"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gen6_set_rps
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|u8
name|val
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|swreq
decl_stmt|;
name|swreq
operator|=
operator|(
name|val
operator|&
literal|0x3ff
operator|)
operator|<<
literal|25
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RPNSWREQ
argument_list|,
name|swreq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gen6_disable_rps
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RPNSWREQ
argument_list|,
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PMINTRMSK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PMIER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Complete PM interrupt masking here doesn't race with the rps work 	 * item again unmasking PM interrupts because that is using a different 	 * register (PMIMR) to mask PM interrupts. The only risk is in leaving 	 * stale bits in PMIIR and PMIMR which gen6_enable_rps will clean up. */
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps_lock
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|pm_iir
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps_lock
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PMIIR
argument_list|,
name|I915_READ
argument_list|(
name|GEN6_PMIIR
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|intel_pxfreq
parameter_list|(
name|u32
name|vidfreq
parameter_list|)
block|{
name|unsigned
name|long
name|freq
decl_stmt|;
name|int
name|div
init|=
operator|(
name|vidfreq
operator|&
literal|0x3f0000
operator|)
operator|>>
literal|16
decl_stmt|;
name|int
name|post
init|=
operator|(
name|vidfreq
operator|&
literal|0x3000
operator|)
operator|>>
literal|12
decl_stmt|;
name|int
name|pre
init|=
operator|(
name|vidfreq
operator|&
literal|0x7
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|pre
condition|)
return|return
literal|0
return|;
name|freq
operator|=
operator|(
operator|(
name|div
operator|*
literal|133333
operator|)
operator|/
operator|(
operator|(
literal|1
operator|<<
name|post
operator|)
operator|*
name|pre
operator|)
operator|)
expr_stmt|;
return|return
name|freq
return|;
block|}
end_function

begin_function
name|void
name|intel_init_emon
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|lcfuse
decl_stmt|;
name|u8
name|pxw
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Disable to program */
name|I915_WRITE
argument_list|(
name|ECR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|ECR
argument_list|)
expr_stmt|;
comment|/* Program energy weights for various events */
name|I915_WRITE
argument_list|(
name|SDEW
argument_list|,
literal|0x15040d00
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|CSIEW0
argument_list|,
literal|0x007f0000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|CSIEW1
argument_list|,
literal|0x1e220004
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|CSIEW2
argument_list|,
literal|0x04000004
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|PEW
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|DEW
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Program P-state weights to account for frequency power adjustment */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|pxvidfreq
init|=
name|I915_READ
argument_list|(
name|PXVFREQ_BASE
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|freq
init|=
name|intel_pxfreq
argument_list|(
name|pxvidfreq
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|vid
init|=
operator|(
name|pxvidfreq
operator|&
name|PXVFREQ_PX_MASK
operator|)
operator|>>
name|PXVFREQ_PX_SHIFT
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|val
operator|=
name|vid
operator|*
name|vid
expr_stmt|;
name|val
operator|*=
operator|(
name|freq
operator|/
literal|1000
operator|)
expr_stmt|;
name|val
operator|*=
literal|255
expr_stmt|;
name|val
operator|/=
operator|(
literal|127
operator|*
literal|127
operator|*
literal|900
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0xff
condition|)
name|DRM_ERROR
argument_list|(
literal|"bad pxval: %ld\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|pxw
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
block|}
comment|/* Render standby states get 0 weight */
name|pxw
index|[
literal|14
index|]
operator|=
literal|0
expr_stmt|;
name|pxw
index|[
literal|15
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|val
init|=
operator|(
name|pxw
index|[
name|i
operator|*
literal|4
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|pxw
index|[
operator|(
name|i
operator|*
literal|4
operator|)
operator|+
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|pxw
index|[
operator|(
name|i
operator|*
literal|4
operator|)
operator|+
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|pxw
index|[
operator|(
name|i
operator|*
literal|4
operator|)
operator|+
literal|3
index|]
operator|)
decl_stmt|;
name|I915_WRITE
argument_list|(
name|PXW
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust magic regs to magic values (more experimental results) */
name|I915_WRITE
argument_list|(
name|OGW0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|OGW1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG0
argument_list|,
literal|0x00007f00
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG1
argument_list|,
literal|0x0000000e
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG2
argument_list|,
literal|0x000e0000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG3
argument_list|,
literal|0x68000300
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG4
argument_list|,
literal|0x42000000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG5
argument_list|,
literal|0x00140031
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|PXWL
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable PMON + select events */
name|I915_WRITE
argument_list|(
name|ECR
argument_list|,
literal|0x80000019
argument_list|)
expr_stmt|;
name|lcfuse
operator|=
name|I915_READ
argument_list|(
name|LCFUSE02
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|corr
operator|=
operator|(
name|lcfuse
operator|&
name|LCFUSE_HIV_MASK
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_enable_rc6
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
comment|/* 	 * Respect the kernel parameter if it is set 	 */
if|if
condition|(
name|i915_enable_rc6
operator|>=
literal|0
condition|)
return|return
name|i915_enable_rc6
return|;
comment|/* 	 * Disable RC6 on Ironlake 	 */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|==
literal|5
condition|)
return|return
literal|0
return|;
comment|/* 	 * Enable rc6 on Sandybridge if DMA remapping is disabled 	 */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|==
literal|6
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"Sandybridge: intel_iommu_enabled %s -- RC6 %sabled\n"
argument_list|,
name|intel_iommu_enabled
condition|?
literal|"true"
else|:
literal|"false"
argument_list|,
operator|!
name|intel_iommu_enabled
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
return|return
operator|(
name|intel_iommu_enabled
condition|?
literal|0
else|:
name|INTEL_RC6_ENABLE
operator|)
return|;
block|}
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"RC6 and deep RC6 enabled\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|INTEL_RC6_ENABLE
operator||
name|INTEL_RC6p_ENABLE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gen6_enable_rps
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|dev_priv
operator|->
name|dev
decl_stmt|;
name|u32
name|rp_state_cap
init|=
name|I915_READ
argument_list|(
name|GEN6_RP_STATE_CAP
argument_list|)
decl_stmt|;
name|u32
name|gt_perf_status
init|=
name|I915_READ
argument_list|(
name|GEN6_GT_PERF_STATUS
argument_list|)
decl_stmt|;
name|u32
name|pcu_mbox
decl_stmt|,
name|rc6_mask
init|=
literal|0
decl_stmt|;
name|u32
name|gtfifodbg
decl_stmt|;
name|int
name|cur_freq
decl_stmt|,
name|min_freq
decl_stmt|,
name|max_freq
decl_stmt|;
name|int
name|rc6_mode
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Here begins a magic sequence of register writes to enable 	 * auto-downclocking. 	 * 	 * Perhaps there might be some value in exposing these to 	 * userspace... 	 */
name|I915_WRITE
argument_list|(
name|GEN6_RC_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Clear the DBG now so we don't confuse earlier errors */
if|if
condition|(
operator|(
name|gtfifodbg
operator|=
name|I915_READ
argument_list|(
name|GTFIFODBG
argument_list|)
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"GT fifo had a previous error %x\n"
argument_list|,
name|gtfifodbg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GTFIFODBG
argument_list|,
name|gtfifodbg
argument_list|)
expr_stmt|;
block|}
name|gen6_gt_force_wake_get
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* disable the counters and set deterministic thresholds */
name|I915_WRITE
argument_list|(
name|GEN6_RC_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC1_WAKE_RATE_LIMIT
argument_list|,
literal|1000
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC6_WAKE_RATE_LIMIT
argument_list|,
literal|40
operator|<<
literal|16
operator||
literal|30
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC6pp_WAKE_RATE_LIMIT
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC_EVALUATION_INTERVAL
argument_list|,
literal|125000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC_IDLE_HYSTERSIS
argument_list|,
literal|25
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I915_NUM_RINGS
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|RING_MAX_IDLE
argument_list|(
name|dev_priv
operator|->
name|rings
index|[
name|i
index|]
operator|.
name|mmio_base
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC_SLEEP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC1e_THRESHOLD
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC6_THRESHOLD
argument_list|,
literal|50000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC6p_THRESHOLD
argument_list|,
literal|100000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC6pp_THRESHOLD
argument_list|,
literal|64000
argument_list|)
expr_stmt|;
comment|/* unused */
name|rc6_mode
operator|=
name|intel_enable_rc6
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc6_mode
operator|&
name|INTEL_RC6_ENABLE
condition|)
name|rc6_mask
operator||=
name|GEN6_RC_CTL_RC6_ENABLE
expr_stmt|;
if|if
condition|(
name|rc6_mode
operator|&
name|INTEL_RC6p_ENABLE
condition|)
name|rc6_mask
operator||=
name|GEN6_RC_CTL_RC6p_ENABLE
expr_stmt|;
if|if
condition|(
name|rc6_mode
operator|&
name|INTEL_RC6pp_ENABLE
condition|)
name|rc6_mask
operator||=
name|GEN6_RC_CTL_RC6pp_ENABLE
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"Enabling RC6 states: RC6 %s, RC6p %s, RC6pp %s\n"
argument_list|,
operator|(
name|rc6_mode
operator|&
name|INTEL_RC6_ENABLE
operator|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|,
operator|(
name|rc6_mode
operator|&
name|INTEL_RC6p_ENABLE
operator|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|,
operator|(
name|rc6_mode
operator|&
name|INTEL_RC6pp_ENABLE
operator|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC_CONTROL
argument_list|,
name|rc6_mask
operator||
name|GEN6_RC_CTL_EI_MODE
argument_list|(
literal|1
argument_list|)
operator||
name|GEN6_RC_CTL_HW_ENABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RPNSWREQ
argument_list|,
name|GEN6_FREQUENCY
argument_list|(
literal|10
argument_list|)
operator||
name|GEN6_OFFSET
argument_list|(
literal|0
argument_list|)
operator||
name|GEN6_AGGRESSIVE_TURBO
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC_VIDEO_FREQ
argument_list|,
name|GEN6_FREQUENCY
argument_list|(
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_DOWN_TIMEOUT
argument_list|,
literal|1000000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_INTERRUPT_LIMITS
argument_list|,
literal|18
operator|<<
literal|24
operator||
literal|6
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_UP_THRESHOLD
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_DOWN_THRESHOLD
argument_list|,
literal|1000000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_UP_EI
argument_list|,
literal|100000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_DOWN_EI
argument_list|,
literal|5000000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_IDLE_HYSTERSIS
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_CONTROL
argument_list|,
name|GEN6_RP_MEDIA_TURBO
operator||
name|GEN6_RP_MEDIA_HW_MODE
operator||
name|GEN6_RP_MEDIA_IS_GFX
operator||
name|GEN6_RP_ENABLE
operator||
name|GEN6_RP_UP_BUSY_AVG
operator||
name|GEN6_RP_DOWN_IDLE_CONT
argument_list|)
expr_stmt|;
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|GEN6_PCODE_MAILBOX
argument_list|)
operator|&
name|GEN6_PCODE_READY
operator|)
operator|==
literal|0
argument_list|,
literal|500
argument_list|,
literal|1
argument_list|,
literal|"915pr1"
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for pcode mailbox to become idle\n"
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PCODE_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PCODE_MAILBOX
argument_list|,
name|GEN6_PCODE_READY
operator||
name|GEN6_PCODE_WRITE_MIN_FREQ_TABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|GEN6_PCODE_MAILBOX
argument_list|)
operator|&
name|GEN6_PCODE_READY
operator|)
operator|==
literal|0
argument_list|,
literal|500
argument_list|,
literal|1
argument_list|,
literal|"915pr2"
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for pcode mailbox to finish\n"
argument_list|)
expr_stmt|;
name|min_freq
operator|=
operator|(
name|rp_state_cap
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|max_freq
operator|=
name|rp_state_cap
operator|&
literal|0xff
expr_stmt|;
name|cur_freq
operator|=
operator|(
name|gt_perf_status
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
comment|/* Check for overclock support */
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|GEN6_PCODE_MAILBOX
argument_list|)
operator|&
name|GEN6_PCODE_READY
operator|)
operator|==
literal|0
argument_list|,
literal|500
argument_list|,
literal|1
argument_list|,
literal|"915pr3"
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for pcode mailbox to become idle\n"
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PCODE_MAILBOX
argument_list|,
name|GEN6_READ_OC_PARAMS
argument_list|)
expr_stmt|;
name|pcu_mbox
operator|=
name|I915_READ
argument_list|(
name|GEN6_PCODE_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|GEN6_PCODE_MAILBOX
argument_list|)
operator|&
name|GEN6_PCODE_READY
operator|)
operator|==
literal|0
argument_list|,
literal|500
argument_list|,
literal|1
argument_list|,
literal|"915pr4"
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for pcode mailbox to finish\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcu_mbox
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
condition|)
block|{
comment|/* OC supported */
name|max_freq
operator|=
name|pcu_mbox
operator|&
literal|0xff
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"overclocking supported, adjusting frequency max to %dMHz\n"
argument_list|,
name|pcu_mbox
operator|*
literal|50
argument_list|)
expr_stmt|;
block|}
comment|/* In units of 100MHz */
name|dev_priv
operator|->
name|max_delay
operator|=
name|max_freq
expr_stmt|;
name|dev_priv
operator|->
name|min_delay
operator|=
name|min_freq
expr_stmt|;
name|dev_priv
operator|->
name|cur_delay
operator|=
name|cur_freq
expr_stmt|;
comment|/* requires MSI enabled */
name|I915_WRITE
argument_list|(
name|GEN6_PMIER
argument_list|,
name|GEN6_PM_MBOX_EVENT
operator||
name|GEN6_PM_THERMAL_EVENT
operator||
name|GEN6_PM_RP_DOWN_TIMEOUT
operator||
name|GEN6_PM_RP_UP_THRESHOLD
operator||
name|GEN6_PM_RP_DOWN_THRESHOLD
operator||
name|GEN6_PM_RP_UP_EI_EXPIRED
operator||
name|GEN6_PM_RP_DOWN_EI_EXPIRED
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|pm_iir
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"pm_iir %x\n"
argument_list|,
name|dev_priv
operator|->
name|pm_iir
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PMIMR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps_lock
argument_list|)
expr_stmt|;
comment|/* enable all PM interrupts */
name|I915_WRITE
argument_list|(
name|GEN6_PMINTRMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gen6_gt_force_wake_put
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gen6_update_ring_freq
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|int
name|min_freq
init|=
literal|15
decl_stmt|;
name|int
name|gpu_freq
decl_stmt|,
name|ia_freq
decl_stmt|,
name|max_ia_freq
decl_stmt|;
name|int
name|scaling_factor
init|=
literal|180
decl_stmt|;
name|uint64_t
name|tsc_freq
decl_stmt|;
name|dev
operator|=
name|dev_priv
operator|->
name|dev
expr_stmt|;
if|#
directive|if
literal|0
block|max_ia_freq = cpufreq_quick_get_max(0);
comment|/* 	 * Default to measured freq if none found, PCU will ensure we don't go 	 * over 	 */
block|if (!max_ia_freq) 		max_ia_freq = tsc_freq;
comment|/* Convert from Hz to MHz */
block|max_ia_freq /= 1000;
else|#
directive|else
name|tsc_freq
operator|=
name|atomic_load_acq_64
argument_list|(
operator|&
name|tsc_freq
argument_list|)
expr_stmt|;
name|max_ia_freq
operator|=
name|tsc_freq
operator|/
literal|1000
operator|/
literal|1000
expr_stmt|;
endif|#
directive|endif
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * For each potential GPU frequency, load a ring frequency we'd like 	 * to use for memory access.  We do this by specifying the IA frequency 	 * the PCU should use as a reference to determine the ring frequency. 	 */
for|for
control|(
name|gpu_freq
operator|=
name|dev_priv
operator|->
name|max_delay
init|;
name|gpu_freq
operator|>=
name|dev_priv
operator|->
name|min_delay
condition|;
name|gpu_freq
operator|--
control|)
block|{
name|int
name|diff
init|=
name|dev_priv
operator|->
name|max_delay
operator|-
name|gpu_freq
decl_stmt|;
name|int
name|d
decl_stmt|;
comment|/* 		 * For GPU frequencies less than 750MHz, just use the lowest 		 * ring freq. 		 */
if|if
condition|(
name|gpu_freq
operator|<
name|min_freq
condition|)
name|ia_freq
operator|=
literal|800
expr_stmt|;
else|else
name|ia_freq
operator|=
name|max_ia_freq
operator|-
operator|(
operator|(
name|diff
operator|*
name|scaling_factor
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
name|d
operator|=
literal|100
expr_stmt|;
name|ia_freq
operator|=
operator|(
name|ia_freq
operator|+
name|d
operator|/
literal|2
operator|)
operator|/
name|d
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PCODE_DATA
argument_list|,
operator|(
name|ia_freq
operator|<<
name|GEN6_PCODE_FREQ_IA_RATIO_SHIFT
operator|)
operator||
name|gpu_freq
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PCODE_MAILBOX
argument_list|,
name|GEN6_PCODE_READY
operator||
name|GEN6_PCODE_WRITE_MIN_FREQ_TABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|GEN6_PCODE_MAILBOX
argument_list|)
operator|&
name|GEN6_PCODE_READY
operator|)
operator|==
literal|0
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|,
literal|"915frq"
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"pcode write of freq table timed out\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|dspclk_gate
init|=
name|VRHUNIT_CLOCK_GATE_DISABLE
decl_stmt|;
comment|/* Required for FBC */
name|dspclk_gate
operator||=
name|DPFCUNIT_CLOCK_GATE_DISABLE
operator||
name|DPFCRUNIT_CLOCK_GATE_DISABLE
operator||
name|DPFDUNIT_CLOCK_GATE_DISABLE
expr_stmt|;
comment|/* Required for CxSR */
name|dspclk_gate
operator||=
name|DPARBUNIT_CLOCK_GATE_DISABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_3DCGDIS0
argument_list|,
name|MARIUNIT_CLOCK_GATE_DISABLE
operator||
name|SVSMUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_3DCGDIS1
argument_list|,
name|VFMUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DSPCLK_GATE_D
argument_list|,
name|dspclk_gate
argument_list|)
expr_stmt|;
comment|/* 	 * According to the spec the following bits should be set in 	 * order to enable memory self-refresh 	 * The bit 22/21 of 0x42004 	 * The bit 5 of 0x42020 	 * The bit 15 of 0x45000 	 */
name|I915_WRITE
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|)
operator||
name|ILK_DPARB_GATE
operator||
name|ILK_VSDPFD_FULL
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DSPCLK_GATE
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|ILK_DSPCLK_GATE
argument_list|)
operator||
name|ILK_DPARB_CLK_GATE
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DISP_ARB_CTL
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|DISP_ARB_CTL
argument_list|)
operator||
name|DISP_FBC_WM_DIS
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Based on the document from hardware guys the following bits 	 * should be set unconditionally in order to enable FBC. 	 * The bit 22 of 0x42000 	 * The bit 22 of 0x42004 	 * The bit 7,8,9 of 0x42020. 	 */
if|if
condition|(
name|IS_IRONLAKE_M
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|ILK_DISPLAY_CHICKEN1
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN1
argument_list|)
operator||
name|ILK_FBCQ_DIS
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|)
operator||
name|ILK_DPARB_GATE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DSPCLK_GATE
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DSPCLK_GATE
argument_list|)
operator||
name|ILK_DPFC_DIS1
operator||
name|ILK_DPFC_DIS2
operator||
name|ILK_CLK_FBC
argument_list|)
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|)
operator||
name|ILK_ELPIN_409_SELECT
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_3D_CHICKEN2
argument_list|,
name|_3D_CHICKEN2_WM_READ_PIPELINED
operator|<<
literal|16
operator||
name|_3D_CHICKEN2_WM_READ_PIPELINED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen6_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipe
decl_stmt|;
name|uint32_t
name|dspclk_gate
init|=
name|VRHUNIT_CLOCK_GATE_DISABLE
decl_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DSPCLK_GATE_D
argument_list|,
name|dspclk_gate
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|)
operator||
name|ILK_ELPIN_409_SELECT
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_UCGCTL1
argument_list|,
name|I915_READ
argument_list|(
name|GEN6_UCGCTL1
argument_list|)
operator||
name|GEN6_BLBUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
comment|/* According to the BSpec vol1g, bit 12 (RCPBUNIT) clock 	 * gating disable must be set.  Failure to set it results in 	 * flickering pixels due to Z write ordering failures after 	 * some amount of runtime in the Mesa "fire" demo, and Unigine 	 * Sanctuary and Tropics, and apparently anything else with 	 * alpha test or pixel discard. 	 * 	 * According to the spec, bit 11 (RCCUNIT) must also be set, 	 * but we didn't debug actual testcases to find it out. 	 */
name|I915_WRITE
argument_list|(
name|GEN6_UCGCTL2
argument_list|,
name|GEN6_RCPBUNIT_CLOCK_GATE_DISABLE
operator||
name|GEN6_RCCUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
comment|/* 	 * According to the spec the following bits should be 	 * set in order to enable memory self-refresh and fbc: 	 * The bit21 and bit22 of 0x42000 	 * The bit21 and bit22 of 0x42004 	 * The bit5 and bit7 of 0x42020 	 * The bit14 of 0x70180 	 * The bit14 of 0x71180 	 */
name|I915_WRITE
argument_list|(
name|ILK_DISPLAY_CHICKEN1
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN1
argument_list|)
operator||
name|ILK_FBCQ_DIS
operator||
name|ILK_PABSTRETCH_DIS
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|)
operator||
name|ILK_DPARB_GATE
operator||
name|ILK_VSDPFD_FULL
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DSPCLK_GATE
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DSPCLK_GATE
argument_list|)
operator||
name|ILK_DPARB_CLK_GATE
operator||
name|ILK_DPFD_CLK_GATE
argument_list|)
expr_stmt|;
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
block|{
name|I915_WRITE
argument_list|(
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator||
name|DISPPLANE_TRICKLE_FEED_DISABLE
argument_list|)
expr_stmt|;
name|intel_flush_display_plane
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ivybridge_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipe
decl_stmt|;
name|uint32_t
name|dspclk_gate
init|=
name|VRHUNIT_CLOCK_GATE_DISABLE
decl_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DSPCLK_GATE_D
argument_list|,
name|dspclk_gate
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* According to the spec, bit 13 (RCZUNIT) must be set on IVB. 	 * This implements the WaDisableRCZUnitClockGating workaround. 	 */
name|I915_WRITE
argument_list|(
name|GEN6_UCGCTL2
argument_list|,
name|GEN6_RCZUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DSPCLK_GATE
argument_list|,
name|IVB_VRHUNIT_CLK_GATE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|IVB_CHICKEN3
argument_list|,
name|CHICKEN3_DGMG_REQ_OUT_FIX_DISABLE
operator||
name|CHICKEN3_DGMG_DONE_FIX_DISABLE
argument_list|)
expr_stmt|;
comment|/* Apply the WaDisableRHWOOptimizationForRenderHang workaround. */
name|I915_WRITE
argument_list|(
name|GEN7_COMMON_SLICE_CHICKEN1
argument_list|,
name|GEN7_CSC1_RHWO_OPT_DISABLE_IN_RCC
argument_list|)
expr_stmt|;
comment|/* WaApplyL3ControlAndL3ChickenMode requires those two on Ivy Bridge */
name|I915_WRITE
argument_list|(
name|GEN7_L3CNTLREG1
argument_list|,
name|GEN7_WA_FOR_GEN7_L3_CONTROL
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN7_L3_CHICKEN_MODE_REGISTER
argument_list|,
name|GEN7_WA_L3_CHICKEN_MODE
argument_list|)
expr_stmt|;
comment|/* This is required by WaCatErrorRejectionIssue */
name|I915_WRITE
argument_list|(
name|GEN7_SQ_CHICKEN_MBCUNIT_CONFIG
argument_list|,
name|I915_READ
argument_list|(
name|GEN7_SQ_CHICKEN_MBCUNIT_CONFIG
argument_list|)
operator||
name|GEN7_SQ_CHICKEN_MBCUNIT_SQINTMOB
argument_list|)
expr_stmt|;
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
block|{
name|I915_WRITE
argument_list|(
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator||
name|DISPPLANE_TRICKLE_FEED_DISABLE
argument_list|)
expr_stmt|;
name|intel_flush_display_plane
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g4x_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|dspclk_gate
decl_stmt|;
name|I915_WRITE
argument_list|(
name|RENCLK_GATE_D1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RENCLK_GATE_D2
argument_list|,
name|VF_UNIT_CLOCK_GATE_DISABLE
operator||
name|GS_UNIT_CLOCK_GATE_DISABLE
operator||
name|CL_UNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RAMCLK_GATE_D
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dspclk_gate
operator|=
name|VRHUNIT_CLOCK_GATE_DISABLE
operator||
name|OVRUNIT_CLOCK_GATE_DISABLE
operator||
name|OVCUNIT_CLOCK_GATE_DISABLE
expr_stmt|;
if|if
condition|(
name|IS_GM45
argument_list|(
name|dev
argument_list|)
condition|)
name|dspclk_gate
operator||=
name|DSSUNIT_CLOCK_GATE_DISABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPCLK_GATE_D
argument_list|,
name|dspclk_gate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|crestline_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|I915_WRITE
argument_list|(
name|RENCLK_GATE_D1
argument_list|,
name|I965_RCC_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RENCLK_GATE_D2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPCLK_GATE_D
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RAMCLK_GATE_D
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE16
argument_list|(
name|DEUC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|broadwater_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|I915_WRITE
argument_list|(
name|RENCLK_GATE_D1
argument_list|,
name|I965_RCZ_CLOCK_GATE_DISABLE
operator||
name|I965_RCC_CLOCK_GATE_DISABLE
operator||
name|I965_RCPB_CLOCK_GATE_DISABLE
operator||
name|I965_ISC_CLOCK_GATE_DISABLE
operator||
name|I965_FBC_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RENCLK_GATE_D2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen3_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|dstate
init|=
name|I915_READ
argument_list|(
name|D_STATE
argument_list|)
decl_stmt|;
name|dstate
operator||=
name|DSTATE_PLL_D3_OFF
operator||
name|DSTATE_GFX_CLOCK_GATING
operator||
name|DSTATE_DOT_CLOCK_GATING
expr_stmt|;
name|I915_WRITE
argument_list|(
name|D_STATE
argument_list|,
name|dstate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i85x_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|I915_WRITE
argument_list|(
name|RENCLK_GATE_D1
argument_list|,
name|SV_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i830_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|I915_WRITE
argument_list|(
name|DSPCLK_GATE_D
argument_list|,
name|OVRUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ibx_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* 	 * On Ibex Peak and Cougar Point, we need to disable clock 	 * gating for the panel power sequencer or it will fail to 	 * start up when no ports are active. 	 */
name|I915_WRITE
argument_list|(
name|SOUTH_DSPCLK_GATE_D
argument_list|,
name|PCH_DPLSUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cpt_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipe
decl_stmt|;
comment|/* 	 * On Ibex Peak and Cougar Point, we need to disable clock 	 * gating for the panel power sequencer or it will fail to 	 * start up when no ports are active. 	 */
name|I915_WRITE
argument_list|(
name|SOUTH_DSPCLK_GATE_D
argument_list|,
name|PCH_DPLSUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SOUTH_CHICKEN2
argument_list|,
name|I915_READ
argument_list|(
name|SOUTH_CHICKEN2
argument_list|)
operator||
name|DPLS_EDP_PPS_FIX_DIS
argument_list|)
expr_stmt|;
comment|/* Without this, mode sets may fail silently on FDI */
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
name|I915_WRITE
argument_list|(
name|TRANS_CHICKEN2
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|TRANS_AUTOTRAIN_GEN_STALL_DIS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_teardown_rc6
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|renderctx
condition|)
block|{
name|i915_gem_object_unpin
argument_list|(
name|dev_priv
operator|->
name|renderctx
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|dev_priv
operator|->
name|renderctx
operator|->
name|base
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|renderctx
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|pwrctx
condition|)
block|{
name|i915_gem_object_unpin
argument_list|(
name|dev_priv
operator|->
name|pwrctx
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|dev_priv
operator|->
name|pwrctx
operator|->
name|base
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|pwrctx
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_disable_rc6
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|PWRCTXA
argument_list|)
condition|)
block|{
comment|/* Wake the GPU, prevent RC6, then restore RSTDBYCTL */
name|I915_WRITE
argument_list|(
name|RSTDBYCTL
argument_list|,
name|I915_READ
argument_list|(
name|RSTDBYCTL
argument_list|)
operator||
name|RCX_SW_EXIT
argument_list|)
expr_stmt|;
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
operator|(
operator|(
name|I915_READ
argument_list|(
name|RSTDBYCTL
argument_list|)
operator|&
name|RSX_STATUS_MASK
operator|)
operator|==
name|RSX_STATUS_ON
operator|)
argument_list|,
literal|50
argument_list|,
literal|1
argument_list|,
literal|"915pro"
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PWRCTXA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PWRCTXA
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RSTDBYCTL
argument_list|,
name|I915_READ
argument_list|(
name|RSTDBYCTL
argument_list|)
operator|&
operator|~
name|RCX_SW_EXIT
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|RSTDBYCTL
argument_list|)
expr_stmt|;
block|}
name|ironlake_teardown_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ironlake_setup_rc6
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|renderctx
operator|==
name|NULL
condition|)
name|dev_priv
operator|->
name|renderctx
operator|=
name|intel_alloc_context_page
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|renderctx
condition|)
return|return
operator|-
name|ENOMEM
return|;
if|if
condition|(
name|dev_priv
operator|->
name|pwrctx
operator|==
name|NULL
condition|)
name|dev_priv
operator|->
name|pwrctx
operator|=
name|intel_alloc_context_page
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|pwrctx
condition|)
block|{
name|ironlake_teardown_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ironlake_enable_rc6
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* rc6 disabled by default due to repeated reports of hanging during 	 * boot and resume. 	 */
if|if
condition|(
operator|!
name|intel_enable_rc6
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ironlake_setup_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * GPU can automatically power down the render unit if given a page 	 * to save state. 	 */
name|ret
operator|=
name|BEGIN_LP_RING
argument_list|(
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ironlake_teardown_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
name|OUT_RING
argument_list|(
name|MI_SUSPEND_FLUSH
operator||
name|MI_SUSPEND_FLUSH_EN
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_SET_CONTEXT
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|renderctx
operator|->
name|gtt_offset
operator||
name|MI_MM_SPACE_GTT
operator||
name|MI_SAVE_EXT_STATE_EN
operator||
name|MI_RESTORE_EXT_STATE_EN
operator||
name|MI_RESTORE_INHIBIT
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_SUSPEND_FLUSH
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_NOOP
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_FLUSH
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
comment|/* 	 * Wait for the command parser to advance past MI_SET_CONTEXT. The HW 	 * does an implicit flush, combined with MI_FLUSH above, it should be 	 * safe to assume that renderctx is valid 	 */
name|ret
operator|=
name|intel_wait_ring_idle
argument_list|(
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to enable ironlake power power savings\n"
argument_list|)
expr_stmt|;
name|ironlake_teardown_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
name|I915_WRITE
argument_list|(
name|PWRCTXA
argument_list|,
name|dev_priv
operator|->
name|pwrctx
operator|->
name|gtt_offset
operator||
name|PWRCTX_EN
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RSTDBYCTL
argument_list|,
name|I915_READ
argument_list|(
name|RSTDBYCTL
argument_list|)
operator|&
operator|~
name|RCX_SW_EXIT
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|display
operator|.
name|init_pch_clock_gating
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|init_pch_clock_gating
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up chip specific display functions */
end_comment

begin_function
specifier|static
name|void
name|intel_init_display
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* We always want a DPMS function */
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|dpms
operator|=
name|ironlake_crtc_dpms
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|crtc_mode_set
operator|=
name|ironlake_crtc_mode_set
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_plane
operator|=
name|ironlake_update_plane
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|display
operator|.
name|dpms
operator|=
name|i9xx_crtc_dpms
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|crtc_mode_set
operator|=
name|i9xx_crtc_mode_set
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_plane
operator|=
name|i9xx_update_plane
expr_stmt|;
block|}
if|if
condition|(
name|I915_HAS_FBC
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|fbc_enabled
operator|=
name|ironlake_fbc_enabled
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|enable_fbc
operator|=
name|ironlake_enable_fbc
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|disable_fbc
operator|=
name|ironlake_disable_fbc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GM45
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|fbc_enabled
operator|=
name|g4x_fbc_enabled
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|enable_fbc
operator|=
name|g4x_enable_fbc
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|disable_fbc
operator|=
name|g4x_disable_fbc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_CRESTLINE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|fbc_enabled
operator|=
name|i8xx_fbc_enabled
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|enable_fbc
operator|=
name|i8xx_enable_fbc
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|disable_fbc
operator|=
name|i8xx_disable_fbc
expr_stmt|;
block|}
comment|/* 855GM needs testing */
block|}
comment|/* Returns the core display clock speed */
if|if
condition|(
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
operator|(
name|IS_G33
argument_list|(
name|dev
argument_list|)
operator|&&
operator|!
name|IS_PINEVIEW_M
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i945_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I915G
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i915_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_845G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_PINEVIEW_M
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i9xx_misc_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I915GM
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i915gm_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I865G
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i865_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I85X
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i855_get_display_clock_speed
expr_stmt|;
else|else
comment|/* 852, 830 */
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i830_get_display_clock_speed
expr_stmt|;
comment|/* For FIFO watermark updates */
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|force_wake_get
operator|=
name|__gen6_gt_force_wake_get
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|force_wake_put
operator|=
name|__gen6_gt_force_wake_put
expr_stmt|;
comment|/* IVB configs may use multi-threaded forcewake */
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|u32
name|ecobus
decl_stmt|;
comment|/* A small trick here - if the bios hasn't configured MT forcewake, 			 * and if the device is in RC6, then force_wake_mt_get will not wake 			 * the device and the ECOBUS read will return zero. Which will be 			 * (correctly) interpreted by the test below as MT forcewake being 			 * disabled. 			 */
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|__gen6_gt_force_wake_mt_get
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|ecobus
operator|=
name|I915_READ_NOTRACE
argument_list|(
name|ECOBUS
argument_list|)
expr_stmt|;
name|__gen6_gt_force_wake_mt_put
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecobus
operator|&
name|FORCEWAKE_MT_ENABLE
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Using MT version of forcewake\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|force_wake_get
operator|=
name|__gen6_gt_force_wake_mt_get
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|force_wake_put
operator|=
name|__gen6_gt_force_wake_mt_put
expr_stmt|;
block|}
block|}
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|init_pch_clock_gating
operator|=
name|ibx_init_clock_gating
expr_stmt|;
elseif|else
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|init_pch_clock_gating
operator|=
name|cpt_init_clock_gating
expr_stmt|;
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|I915_READ
argument_list|(
name|MLTR_ILK
argument_list|)
operator|&
name|ILK_SRLT_MASK
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|ironlake_update_wm
expr_stmt|;
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Failed to get proper latency. "
literal|"Disable CxSR\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|NULL
expr_stmt|;
block|}
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
operator|=
name|ironlake_fdi_link_train
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|ironlake_init_clock_gating
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
operator|=
name|ironlake_write_eld
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|SNB_READ_WM0_LATENCY
argument_list|()
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|sandybridge_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_sprite_wm
operator|=
name|sandybridge_update_sprite_wm
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Failed to read display plane latency. "
literal|"Disable CxSR\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|NULL
expr_stmt|;
block|}
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
operator|=
name|gen6_fdi_link_train
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|gen6_init_clock_gating
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
operator|=
name|ironlake_write_eld
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* FIXME: detect B0+ stepping and use auto training */
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
operator|=
name|ivb_manual_fdi_link_train
expr_stmt|;
if|if
condition|(
name|SNB_READ_WM0_LATENCY
argument_list|()
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|sandybridge_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_sprite_wm
operator|=
name|sandybridge_update_sprite_wm
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Failed to read display plane latency. "
literal|"Disable CxSR\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|NULL
expr_stmt|;
block|}
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|ivybridge_init_clock_gating
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
operator|=
name|ironlake_write_eld
expr_stmt|;
block|}
else|else
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|intel_get_cxsr_latency
argument_list|(
name|IS_PINEVIEW_G
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev_priv
operator|->
name|is_ddr3
argument_list|,
name|dev_priv
operator|->
name|fsb_freq
argument_list|,
name|dev_priv
operator|->
name|mem_freq
argument_list|)
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"failed to find known CxSR latency "
literal|"(found ddr%s fsb freq %d, mem freq %d), "
literal|"disabling CxSR\n"
argument_list|,
operator|(
name|dev_priv
operator|->
name|is_ddr3
operator|==
literal|1
operator|)
condition|?
literal|"3"
else|:
literal|"2"
argument_list|,
name|dev_priv
operator|->
name|fsb_freq
argument_list|,
name|dev_priv
operator|->
name|mem_freq
argument_list|)
expr_stmt|;
comment|/* Disable CxSR and never update its watermark again */
name|pineview_disable_cxsr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|pineview_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|gen3_init_clock_gating
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
operator|=
name|g4x_write_eld
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|g4x_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|g4x_init_clock_gating
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN4
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|i965_update_wm
expr_stmt|;
if|if
condition|(
name|IS_CRESTLINE
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|crestline_init_clock_gating
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_BROADWATER
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|broadwater_init_clock_gating
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN3
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|i9xx_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
operator|=
name|i9xx_get_fifo_size
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|gen3_init_clock_gating
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_I865G
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|i830_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|i85x_init_clock_gating
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
operator|=
name|i830_get_fifo_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_I85X
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|i9xx_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
operator|=
name|i85x_get_fifo_size
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|i85x_init_clock_gating
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|i830_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|i830_init_clock_gating
expr_stmt|;
if|if
condition|(
name|IS_845G
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
operator|=
name|i845_get_fifo_size
expr_stmt|;
else|else
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
operator|=
name|i830_get_fifo_size
expr_stmt|;
block|}
comment|/* Default just returns -ENODEV to indicate unsupported */
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_default_queue_flip
expr_stmt|;
switch|switch
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
condition|)
block|{
case|case
literal|2
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen2_queue_flip
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen3_queue_flip
expr_stmt|;
break|break;
case|case
literal|4
case|:
case|case
literal|5
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen4_queue_flip
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen6_queue_flip
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen7_queue_flip
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Some BIOSes insist on assuming the GPU's pipe A is enabled at suspend,  * resume, or other times.  This quirk makes sure that's the case for  * affected systems.  */
end_comment

begin_function
specifier|static
name|void
name|quirk_pipea_force
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|quirks
operator||=
name|QUIRK_PIPEA_FORCE
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"applying pipe a force quirk\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Some machines (Lenovo U160) do not work with SSC on LVDS for some reason  */
end_comment

begin_function
specifier|static
name|void
name|quirk_ssc_force_disable
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|quirks
operator||=
name|QUIRK_LVDS_SSC_DISABLE
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|intel_quirk
block|{
name|int
name|device
decl_stmt|;
name|int
name|subsystem_vendor
decl_stmt|;
name|int
name|subsystem_device
decl_stmt|;
name|void
function_decl|(
modifier|*
name|hook
function_decl|)
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PCI_ANY_ID
value|(~0u)
end_define

begin_decl_stmt
name|struct
name|intel_quirk
name|intel_quirks
index|[]
init|=
block|{
comment|/* HP Mini needs pipe A force quirk (LP: #322104) */
block|{
literal|0x27ae
block|,
literal|0x103c
block|,
literal|0x361a
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* Thinkpad R31 needs pipe A force quirk */
block|{
literal|0x3577
block|,
literal|0x1014
block|,
literal|0x0505
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* Toshiba Protege R-205, S-209 needs pipe A force quirk */
block|{
literal|0x2592
block|,
literal|0x1179
block|,
literal|0x0001
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* ThinkPad X30 needs pipe A force quirk (LP: #304614) */
block|{
literal|0x3577
block|,
literal|0x1014
block|,
literal|0x0513
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* ThinkPad X40 needs pipe A force quirk */
comment|/* ThinkPad T60 needs pipe A force quirk (bug #16494) */
block|{
literal|0x2782
block|,
literal|0x17aa
block|,
literal|0x201a
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* 855& before need to leave pipe A& dpll A up */
block|{
literal|0x3582
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
name|quirk_pipea_force
block|}
block|,
block|{
literal|0x2562
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* Lenovo U160 cannot use SSC on LVDS */
block|{
literal|0x0046
block|,
literal|0x17aa
block|,
literal|0x3920
block|,
name|quirk_ssc_force_disable
block|}
block|,
comment|/* Sony Vaio Y cannot use SSC on LVDS */
block|{
literal|0x0046
block|,
literal|0x104d
block|,
literal|0x9076
block|,
name|quirk_ssc_force_disable
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|intel_init_quirks
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|intel_quirk
modifier|*
name|q
decl_stmt|;
name|device_t
name|d
decl_stmt|;
name|int
name|i
decl_stmt|;
name|d
operator|=
name|dev
operator|->
name|device
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_ARRAY_SIZE
argument_list|(
name|intel_quirks
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|q
operator|=
operator|&
name|intel_quirks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pci_get_device
argument_list|(
name|d
argument_list|)
operator|==
name|q
operator|->
name|device
operator|&&
operator|(
name|pci_get_subvendor
argument_list|(
name|d
argument_list|)
operator|==
name|q
operator|->
name|subsystem_vendor
operator|||
name|q
operator|->
name|subsystem_vendor
operator|==
name|PCI_ANY_ID
operator|)
operator|&&
operator|(
name|pci_get_subdevice
argument_list|(
name|d
argument_list|)
operator|==
name|q
operator|->
name|subsystem_device
operator|||
name|q
operator|->
name|subsystem_device
operator|==
name|PCI_ANY_ID
operator|)
condition|)
name|q
operator|->
name|hook
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Disable the VGA plane that we never use */
end_comment

begin_function
specifier|static
name|void
name|i915_disable_vga
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u8
name|sr1
decl_stmt|;
name|u32
name|vga_reg
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|vga_reg
operator|=
name|CPU_VGACNTRL
expr_stmt|;
else|else
name|vga_reg
operator|=
name|VGACNTRL
expr_stmt|;
if|#
directive|if
literal|0
block|vga_get_uninterruptible(dev->pdev, VGA_RSRC_LEGACY_IO);
endif|#
directive|endif
name|outb
argument_list|(
name|VGA_SR_INDEX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sr1
operator|=
name|inb
argument_list|(
name|VGA_SR_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|VGA_SR_DATA
argument_list|,
name|sr1
operator||
literal|1
operator|<<
literal|5
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|vga_put(dev->pdev, VGA_RSRC_LEGACY_IO);
endif|#
directive|endif
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|vga_reg
argument_list|,
name|VGA_DISP_DISABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|vga_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_modeset_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|drm_mode_config_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|min_width
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|min_height
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|preferred_depth
operator|=
literal|24
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|prefer_shadow
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|funcs
operator|=
name|__DECONST
argument_list|(
expr|struct
name|drm_mode_config_funcs
operator|*
argument_list|,
operator|&
name|intel_mode_funcs
argument_list|)
expr_stmt|;
name|intel_init_quirks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_init_display
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|mode_config
operator|.
name|max_width
operator|=
literal|2048
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|max_height
operator|=
literal|2048
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN3
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|mode_config
operator|.
name|max_width
operator|=
literal|4096
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|max_height
operator|=
literal|4096
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|mode_config
operator|.
name|max_width
operator|=
literal|8192
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|max_height
operator|=
literal|8192
expr_stmt|;
block|}
name|dev
operator|->
name|mode_config
operator|.
name|fb_base
operator|=
name|dev
operator|->
name|agp
operator|->
name|base
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"%d display pipe%s available.\n"
argument_list|,
name|dev_priv
operator|->
name|num_pipe
argument_list|,
name|dev_priv
operator|->
name|num_pipe
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|num_pipe
condition|;
name|i
operator|++
control|)
block|{
name|intel_crtc_init
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_plane_init
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"plane %d init failed: %d\n"
argument_list|,
name|i
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
comment|/* Just disable it once at startup */
name|i915_disable_vga
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_setup_outputs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_init_clock_gating
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IRONLAKE_M
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ironlake_enable_drps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_init_emon
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|gen6_enable_rps
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|gen6_update_ring_freq
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
name|TASK_INIT
argument_list|(
operator|&
name|dev_priv
operator|->
name|idle_task
argument_list|,
literal|0
argument_list|,
name|intel_idle_update
argument_list|,
name|dev_priv
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|dev_priv
operator|->
name|idle_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_modeset_gem_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|IS_IRONLAKE_M
argument_list|(
name|dev
argument_list|)
condition|)
name|ironlake_enable_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_setup_overlay
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_modeset_cleanup
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
name|drm_kms_helper_poll_fini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|intel_unregister_dsm_handler();
endif|#
directive|endif
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
comment|/* Skip inactive CRTCs */
if|if
condition|(
operator|!
name|crtc
operator|->
name|fb
condition|)
continue|continue;
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_increase_pllclock
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IRONLAKE_M
argument_list|(
name|dev
argument_list|)
condition|)
name|ironlake_disable_drps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
name|gen6_disable_rps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IRONLAKE_M
argument_list|(
name|dev
argument_list|)
condition|)
name|ironlake_disable_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Disable the irq before mode object teardown, for the irq might 	 * enqueue unpin/hotplug work. */
name|drm_irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskqueue_cancel
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|hotplug_task
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|hotplug_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskqueue_cancel
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|rps_task
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|rps_task
argument_list|)
expr_stmt|;
comment|/* Shut off idle work before the crtcs get freed. */
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|intel_crtc
operator|->
name|idle_callout
argument_list|)
expr_stmt|;
block|}
name|callout_drain
argument_list|(
operator|&
name|dev_priv
operator|->
name|idle_callout
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskqueue_cancel
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|idle_task
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|idle_task
argument_list|)
expr_stmt|;
name|drm_mode_config_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return which encoder is currently attached for connector.  */
end_comment

begin_function
name|struct
name|drm_encoder
modifier|*
name|intel_best_encoder
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
return|return
operator|&
name|intel_attached_encoder
argument_list|(
name|connector
argument_list|)
operator|->
name|base
return|;
block|}
end_function

begin_function
name|void
name|intel_connector_attach_encoder
parameter_list|(
name|struct
name|intel_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|intel_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|connector
operator|->
name|encoder
operator|=
name|encoder
expr_stmt|;
name|drm_mode_connector_attach_encoder
argument_list|(
operator|&
name|connector
operator|->
name|base
argument_list|,
operator|&
name|encoder
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set vga decode state - true == enable VGA decode  */
end_comment

begin_function
name|int
name|intel_modeset_vga_set_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|device_t
name|bridge_dev
decl_stmt|;
name|u16
name|gmch_ctrl
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|bridge_dev
operator|=
name|intel_gtt_get_bridge_device
argument_list|()
expr_stmt|;
name|gmch_ctrl
operator|=
name|pci_read_config
argument_list|(
name|bridge_dev
argument_list|,
name|INTEL_GMCH_CTRL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
name|gmch_ctrl
operator|&=
operator|~
name|INTEL_GMCH_VGA_DISABLE
expr_stmt|;
else|else
name|gmch_ctrl
operator||=
name|INTEL_GMCH_VGA_DISABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|bridge_dev
argument_list|,
name|INTEL_GMCH_CTRL
argument_list|,
name|gmch_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|intel_display_error_state
block|{
struct|struct
name|intel_cursor_error_state
block|{
name|u32
name|control
decl_stmt|;
name|u32
name|position
decl_stmt|;
name|u32
name|base
decl_stmt|;
name|u32
name|size
decl_stmt|;
block|}
name|cursor
index|[
literal|2
index|]
struct|;
struct|struct
name|intel_pipe_error_state
block|{
name|u32
name|conf
decl_stmt|;
name|u32
name|source
decl_stmt|;
name|u32
name|htotal
decl_stmt|;
name|u32
name|hblank
decl_stmt|;
name|u32
name|hsync
decl_stmt|;
name|u32
name|vtotal
decl_stmt|;
name|u32
name|vblank
decl_stmt|;
name|u32
name|vsync
decl_stmt|;
block|}
name|pipe
index|[
literal|2
index|]
struct|;
struct|struct
name|intel_plane_error_state
block|{
name|u32
name|control
decl_stmt|;
name|u32
name|stride
decl_stmt|;
name|u32
name|size
decl_stmt|;
name|u32
name|pos
decl_stmt|;
name|u32
name|addr
decl_stmt|;
name|u32
name|surface
decl_stmt|;
name|u32
name|tile_offset
decl_stmt|;
block|}
name|plane
index|[
literal|2
index|]
struct|;
block|}
struct|;
end_struct

begin_function
name|struct
name|intel_display_error_state
modifier|*
name|intel_display_capture_error_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_display_error_state
modifier|*
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|error
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|error
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|control
operator|=
name|I915_READ
argument_list|(
name|CURCNTR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|position
operator|=
name|I915_READ
argument_list|(
name|CURPOS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|base
operator|=
name|I915_READ
argument_list|(
name|CURBASE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|control
operator|=
name|I915_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|stride
operator|=
name|I915_READ
argument_list|(
name|DSPSTRIDE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|size
operator|=
name|I915_READ
argument_list|(
name|DSPSIZE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|pos
operator|=
name|I915_READ
argument_list|(
name|DSPPOS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|I915_READ
argument_list|(
name|DSPADDR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|surface
operator|=
name|I915_READ
argument_list|(
name|DSPSURF
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|tile_offset
operator|=
name|I915_READ
argument_list|(
name|DSPTILEOFF
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|conf
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|source
operator|=
name|I915_READ
argument_list|(
name|PIPESRC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|htotal
operator|=
name|I915_READ
argument_list|(
name|HTOTAL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|hblank
operator|=
name|I915_READ
argument_list|(
name|HBLANK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|hsync
operator|=
name|I915_READ
argument_list|(
name|HSYNC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vtotal
operator|=
name|I915_READ
argument_list|(
name|VTOTAL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vblank
operator|=
name|I915_READ
argument_list|(
name|VBLANK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vsync
operator|=
name|I915_READ
argument_list|(
name|VSYNC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|intel_display_print_error_state
parameter_list|(
name|struct
name|sbuf
modifier|*
name|m
parameter_list|,
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|intel_display_error_state
modifier|*
name|error
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"Pipe [%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  CONF: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|conf
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  SRC: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|source
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  HTOTAL: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|htotal
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  HBLANK: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|hblank
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  HSYNC: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|hsync
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  VTOTAL: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vtotal
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  VBLANK: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vblank
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  VSYNC: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vsync
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"Plane [%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  CNTR: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|control
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  STRIDE: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|stride
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  SIZE: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  POS: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|pos
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  ADDR: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  SURF: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|surface
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  TILEOFF: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|tile_offset
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"Cursor [%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  CNTR: %08x\n"
argument_list|,
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|control
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  POS: %08x\n"
argument_list|,
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|position
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  BASE: %08x\n"
argument_list|,
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

