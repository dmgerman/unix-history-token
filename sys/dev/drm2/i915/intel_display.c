begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Â© 2006-2007 Intel Corporation  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Authors:  *	Eric Anholt<eric@anholt.net>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_edid.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_dp_helper.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc_helper.h>
end_include

begin_function_decl
name|bool
name|intel_pipe_has_type
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_increase_pllclock
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_crtc_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|bool
name|on
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* given values */
name|int
name|n
decl_stmt|;
name|int
name|m1
decl_stmt|,
name|m2
decl_stmt|;
name|int
name|p1
decl_stmt|,
name|p2
decl_stmt|;
comment|/* derived values */
name|int
name|dot
decl_stmt|;
name|int
name|vco
decl_stmt|;
name|int
name|m
decl_stmt|;
name|int
name|p
decl_stmt|;
block|}
name|intel_clock_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|min
decl_stmt|,
name|max
decl_stmt|;
block|}
name|intel_range_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|dot_limit
decl_stmt|;
name|int
name|p2_slow
decl_stmt|,
name|p2_fast
decl_stmt|;
block|}
name|intel_p2_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|INTEL_P2_NUM
value|2
end_define

begin_typedef
typedef|typedef
name|struct
name|intel_limit
name|intel_limit_t
typedef|;
end_typedef

begin_struct
struct|struct
name|intel_limit
block|{
name|intel_range_t
name|dot
decl_stmt|,
name|vco
decl_stmt|,
name|n
decl_stmt|,
name|m
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|p
decl_stmt|,
name|p1
decl_stmt|;
name|intel_p2_t
name|p2
decl_stmt|;
name|bool
function_decl|(
modifier|*
name|find_pll
function_decl|)
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
parameter_list|,
name|struct
name|drm_crtc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|intel_clock_t
modifier|*
parameter_list|,
name|intel_clock_t
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* FDI */
end_comment

begin_define
define|#
directive|define
name|IRONLAKE_FDI_FREQ
value|2700000
end_define

begin_comment
comment|/* in kHz for mode->clock */
end_comment

begin_function
name|int
name|intel_pch_rawclk
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|WARN_ON
argument_list|(
operator|!
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|I915_READ
argument_list|(
name|PCH_RAWCLK_FREQ
argument_list|)
operator|&
name|RAWCLK_FREQ_MASK
return|;
block|}
end_function

begin_function_decl
specifier|static
name|bool
name|intel_find_best_PLL
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|intel_g4x_find_best_PLL
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|intel_find_pll_g4x_dp
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|intel_find_pll_ironlake_dp
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|intel_vlv_find_best_pll
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|u32
comment|/* units of 100MHz */
name|intel_fdi_link_freq
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
operator|(
name|I915_READ
argument_list|(
name|FDI_PLL_BIOS_0
argument_list|)
operator|&
name|FDI_PLL_FB_CLOCK_MASK
operator|)
operator|+
literal|2
return|;
block|}
else|else
return|return
literal|27
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_i8xx_dvo
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|930000
block|,
operator|.
name|max
operator|=
literal|1400000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|3
block|,
operator|.
name|max
operator|=
literal|16
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|96
block|,
operator|.
name|max
operator|=
literal|140
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|18
block|,
operator|.
name|max
operator|=
literal|26
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|6
block|,
operator|.
name|max
operator|=
literal|16
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|4
block|,
operator|.
name|max
operator|=
literal|128
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|33
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|165000
block|,
operator|.
name|p2_slow
operator|=
literal|4
block|,
operator|.
name|p2_fast
operator|=
literal|2
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_i8xx_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|930000
block|,
operator|.
name|max
operator|=
literal|1400000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|3
block|,
operator|.
name|max
operator|=
literal|16
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|96
block|,
operator|.
name|max
operator|=
literal|140
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|18
block|,
operator|.
name|max
operator|=
literal|26
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|6
block|,
operator|.
name|max
operator|=
literal|16
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|4
block|,
operator|.
name|max
operator|=
literal|128
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|165000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_i9xx_sdvo
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1400000
block|,
operator|.
name|max
operator|=
literal|2800000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|70
block|,
operator|.
name|max
operator|=
literal|120
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|8
block|,
operator|.
name|max
operator|=
literal|18
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|3
block|,
operator|.
name|max
operator|=
literal|7
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|80
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|200000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|5
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_i9xx_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1400000
block|,
operator|.
name|max
operator|=
literal|2800000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|70
block|,
operator|.
name|max
operator|=
literal|120
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|7
block|,
operator|.
name|max
operator|=
literal|98
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|112000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_sdvo
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|270000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|4
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|104
block|,
operator|.
name|max
operator|=
literal|138
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|17
block|,
operator|.
name|max
operator|=
literal|23
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|11
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|30
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|270000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|10
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_hdmi
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|22000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|4
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|104
block|,
operator|.
name|max
operator|=
literal|138
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|16
block|,
operator|.
name|max
operator|=
literal|23
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|11
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|80
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|165000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|5
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_single_channel_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|115000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|104
block|,
operator|.
name|max
operator|=
literal|138
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|17
block|,
operator|.
name|max
operator|=
literal|23
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|11
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|28
block|,
operator|.
name|max
operator|=
literal|112
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|0
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|14
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_dual_channel_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|80000
block|,
operator|.
name|max
operator|=
literal|224000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|104
block|,
operator|.
name|max
operator|=
literal|138
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|17
block|,
operator|.
name|max
operator|=
literal|23
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|11
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|14
block|,
operator|.
name|max
operator|=
literal|42
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|0
block|,
operator|.
name|p2_slow
operator|=
literal|7
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_display_port
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|161670
block|,
operator|.
name|max
operator|=
literal|227000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|97
block|,
operator|.
name|max
operator|=
literal|108
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|0x10
block|,
operator|.
name|max
operator|=
literal|0x12
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|0x05
block|,
operator|.
name|max
operator|=
literal|0x06
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|20
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|0
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|10
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_pll_g4x_dp
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_pineview_sdvo
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1700000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
comment|/* Pineview's Ncounter is a ring counter */
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|3
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|256
block|}
block|,
comment|/* Pineview only has one combined m divider, which we treat as m2. */
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|0
block|,
operator|.
name|max
operator|=
literal|0
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|0
block|,
operator|.
name|max
operator|=
literal|254
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|80
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|200000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|5
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_pineview_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1700000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|3
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|256
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|0
block|,
operator|.
name|max
operator|=
literal|0
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|0
block|,
operator|.
name|max
operator|=
literal|254
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|7
block|,
operator|.
name|max
operator|=
literal|112
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|112000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|14
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ironlake / Sandybridge  *  * We calculate clock using (register_value + 2) for N/M1/M2, so here  * the range value for them is (actual_value - 2).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_dac
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|5
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|127
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|80
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|5
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_single_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|118
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|28
block|,
operator|.
name|max
operator|=
literal|112
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|14
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_dual_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|127
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|14
block|,
operator|.
name|max
operator|=
literal|56
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|7
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LVDS 100mhz refclk limits. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_single_lvds_100m
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|126
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|28
block|,
operator|.
name|max
operator|=
literal|112
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|14
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_dual_lvds_100m
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|126
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|14
block|,
operator|.
name|max
operator|=
literal|42
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|7
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_display_port
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|81
block|,
operator|.
name|max
operator|=
literal|90
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|20
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|0
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|10
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_pll_ironlake_dp
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_vlv_dac
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|270000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|4000000
block|,
operator|.
name|max
operator|=
literal|6000000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|7
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|22
block|,
operator|.
name|max
operator|=
literal|450
block|}
block|,
comment|/* guess */
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|11
block|,
operator|.
name|max
operator|=
literal|156
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|30
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|270000
block|,
operator|.
name|p2_slow
operator|=
literal|2
block|,
operator|.
name|p2_fast
operator|=
literal|20
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_vlv_find_best_pll
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_vlv_hdmi
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|165000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|4000000
block|,
operator|.
name|max
operator|=
literal|5994000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|7
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|60
block|,
operator|.
name|max
operator|=
literal|300
block|}
block|,
comment|/* guess */
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|11
block|,
operator|.
name|max
operator|=
literal|156
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|30
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|270000
block|,
operator|.
name|p2_slow
operator|=
literal|2
block|,
operator|.
name|p2_fast
operator|=
literal|20
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_vlv_find_best_pll
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_vlv_dp
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|270000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|4000000
block|,
operator|.
name|max
operator|=
literal|6000000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|7
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|22
block|,
operator|.
name|max
operator|=
literal|450
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|11
block|,
operator|.
name|max
operator|=
literal|156
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|30
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|270000
block|,
operator|.
name|p2_slow
operator|=
literal|2
block|,
operator|.
name|p2_fast
operator|=
literal|20
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_vlv_find_best_pll
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|u32
name|intel_dpio_read
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|u32
name|val
init|=
literal|0
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_atomic_us
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|DPIO_PKT
argument_list|)
operator|&
name|DPIO_BUSY
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"DPIO idle wait timed out\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|I915_WRITE
argument_list|(
name|DPIO_REG
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPIO_PKT
argument_list|,
name|DPIO_RID
operator||
name|DPIO_OP_READ
operator||
name|DPIO_PORTID
operator||
name|DPIO_BYTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_atomic_us
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|DPIO_PKT
argument_list|)
operator|&
name|DPIO_BUSY
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"DPIO read wait timed out\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|val
operator|=
name|I915_READ
argument_list|(
name|DPIO_DATA
argument_list|)
expr_stmt|;
name|out_unlock
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_dpio_write
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|int
name|reg
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_atomic_us
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|DPIO_PKT
argument_list|)
operator|&
name|DPIO_BUSY
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"DPIO idle wait timed out\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|I915_WRITE
argument_list|(
name|DPIO_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPIO_REG
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPIO_PKT
argument_list|,
name|DPIO_RID
operator||
name|DPIO_OP_WRITE
operator||
name|DPIO_PORTID
operator||
name|DPIO_BYTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_atomic_us
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|DPIO_PKT
argument_list|)
operator|&
name|DPIO_BUSY
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"DPIO write wait timed out\n"
argument_list|)
expr_stmt|;
name|out_unlock
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlv_init_dpio
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* Reset the DPIO config */
name|I915_WRITE
argument_list|(
name|DPIO_CTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DPIO_CTL
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPIO_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DPIO_CTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_dual_link_lvds_callback
parameter_list|(
specifier|const
name|struct
name|dmi_system_id
modifier|*
name|id
parameter_list|)
block|{
name|DRM_INFO
argument_list|(
literal|"Forcing lvds to dual link mode on %s\n"
argument_list|,
name|id
operator|->
name|ident
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|dmi_system_id
name|intel_dual_link_lvds
index|[]
init|=
block|{
block|{
operator|.
name|callback
operator|=
name|intel_dual_link_lvds_callback
block|,
operator|.
name|ident
operator|=
literal|"Apple MacBook Pro (Core i5/i7 Series)"
block|,
operator|.
name|matches
operator|=
block|{
name|DMI_MATCH
argument_list|(
name|DMI_SYS_VENDOR
argument_list|,
literal|"Apple Inc."
argument_list|)
block|,
name|DMI_MATCH
argument_list|(
name|DMI_PRODUCT_NAME
argument_list|,
literal|"MacBookPro8,2"
argument_list|)
block|, 		}
block|, 	}
block|,
block|{ }
comment|/* terminating entry */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|is_dual_link_lvds
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
comment|/* use the module option value if specified */
if|if
condition|(
name|i915_lvds_channel_mode
operator|>
literal|0
condition|)
return|return
name|i915_lvds_channel_mode
operator|==
literal|2
return|;
if|if
condition|(
name|dmi_check_system
argument_list|(
name|intel_dual_link_lvds
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|dev_priv
operator|->
name|lvds_val
condition|)
name|val
operator|=
name|dev_priv
operator|->
name|lvds_val
expr_stmt|;
else|else
block|{
comment|/* BIOS should set the proper LVDS register value at boot, but 		 * in reality, it doesn't set the value when the lid is closed; 		 * we need to check "the value to be set" in VBT when LVDS 		 * register is uninitialized. 		 */
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
operator|~
operator|(
name|LVDS_PIPE_MASK
operator||
name|LVDS_DETECTED
operator|)
operator|)
condition|)
name|val
operator|=
name|dev_priv
operator|->
name|bios_lvds_val
expr_stmt|;
name|dev_priv
operator|->
name|lvds_val
operator|=
name|val
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|&
name|LVDS_CLKB_POWER_MASK
operator|)
operator|==
name|LVDS_CLKB_POWER_UP
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|intel_limit_t
modifier|*
name|intel_ironlake_limit
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|refclk
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_dual_link_lvds
argument_list|(
name|dev_priv
argument_list|,
name|PCH_LVDS
argument_list|)
condition|)
block|{
comment|/* LVDS dual channel */
if|if
condition|(
name|refclk
operator|==
literal|100000
condition|)
name|limit
operator|=
operator|&
name|intel_limits_ironlake_dual_lvds_100m
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_ironlake_dual_lvds
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|refclk
operator|==
literal|100000
condition|)
name|limit
operator|=
operator|&
name|intel_limits_ironlake_single_lvds_100m
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_ironlake_single_lvds
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
operator|||
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_EDP
argument_list|)
condition|)
name|limit
operator|=
operator|&
name|intel_limits_ironlake_display_port
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_ironlake_dac
expr_stmt|;
return|return
name|limit
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|intel_limit_t
modifier|*
name|intel_g4x_limit
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_dual_link_lvds
argument_list|(
name|dev_priv
argument_list|,
name|LVDS
argument_list|)
condition|)
comment|/* LVDS with dual channel */
name|limit
operator|=
operator|&
name|intel_limits_g4x_dual_channel_lvds
expr_stmt|;
else|else
comment|/* LVDS with dual channel */
name|limit
operator|=
operator|&
name|intel_limits_g4x_single_channel_lvds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_HDMI
argument_list|)
operator|||
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_ANALOG
argument_list|)
condition|)
block|{
name|limit
operator|=
operator|&
name|intel_limits_g4x_hdmi
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_SDVO
argument_list|)
condition|)
block|{
name|limit
operator|=
operator|&
name|intel_limits_g4x_sdvo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
condition|)
block|{
name|limit
operator|=
operator|&
name|intel_limits_g4x_display_port
expr_stmt|;
block|}
else|else
comment|/* The option is for other outputs */
name|limit
operator|=
operator|&
name|intel_limits_i9xx_sdvo
expr_stmt|;
return|return
name|limit
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|intel_limit_t
modifier|*
name|intel_limit
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|refclk
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|limit
operator|=
name|intel_ironlake_limit
argument_list|(
name|crtc
argument_list|,
name|refclk
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|limit
operator|=
name|intel_g4x_limit
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|limit
operator|=
operator|&
name|intel_limits_pineview_lvds
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_pineview_sdvo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_ANALOG
argument_list|)
condition|)
name|limit
operator|=
operator|&
name|intel_limits_vlv_dac
expr_stmt|;
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_HDMI
argument_list|)
condition|)
name|limit
operator|=
operator|&
name|intel_limits_vlv_hdmi
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_vlv_dp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|limit
operator|=
operator|&
name|intel_limits_i9xx_lvds
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_i9xx_sdvo
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|limit
operator|=
operator|&
name|intel_limits_i8xx_lvds
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_i8xx_dvo
expr_stmt|;
block|}
return|return
name|limit
return|;
block|}
end_function

begin_comment
comment|/* m1 is reserved as 0 in Pineview, n is a ring counter */
end_comment

begin_function
specifier|static
name|void
name|pineview_clock
parameter_list|(
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|)
block|{
name|clock
operator|->
name|m
operator|=
name|clock
operator|->
name|m2
operator|+
literal|2
expr_stmt|;
name|clock
operator|->
name|p
operator|=
name|clock
operator|->
name|p1
operator|*
name|clock
operator|->
name|p2
expr_stmt|;
name|clock
operator|->
name|vco
operator|=
name|refclk
operator|*
name|clock
operator|->
name|m
operator|/
name|clock
operator|->
name|n
expr_stmt|;
name|clock
operator|->
name|dot
operator|=
name|clock
operator|->
name|vco
operator|/
name|clock
operator|->
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_clock
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|)
block|{
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|pineview_clock
argument_list|(
name|refclk
argument_list|,
name|clock
argument_list|)
expr_stmt|;
return|return;
block|}
name|clock
operator|->
name|m
operator|=
literal|5
operator|*
operator|(
name|clock
operator|->
name|m1
operator|+
literal|2
operator|)
operator|+
operator|(
name|clock
operator|->
name|m2
operator|+
literal|2
operator|)
expr_stmt|;
name|clock
operator|->
name|p
operator|=
name|clock
operator|->
name|p1
operator|*
name|clock
operator|->
name|p2
expr_stmt|;
name|clock
operator|->
name|vco
operator|=
name|refclk
operator|*
name|clock
operator|->
name|m
operator|/
operator|(
name|clock
operator|->
name|n
operator|+
literal|2
operator|)
expr_stmt|;
name|clock
operator|->
name|dot
operator|=
name|clock
operator|->
name|vco
operator|/
name|clock
operator|->
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Returns whether any output on the specified pipe is of the specified type  */
end_comment

begin_function
name|bool
name|intel_pipe_has_type
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
if|if
condition|(
name|encoder
operator|->
name|type
operator|==
name|type
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_define
define|#
directive|define
name|INTELPllInvalid
parameter_list|(
name|s
parameter_list|)
value|do {
comment|/* DRM_DEBUG(s); */
value|return false; } while (0)
end_define

begin_comment
comment|/**  * Returns whether the given set of divisors are valid for a given refclk with  * the given connectors.  */
end_comment

begin_function
specifier|static
name|bool
name|intel_PLL_is_valid
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
specifier|const
name|intel_clock_t
modifier|*
name|clock
parameter_list|)
block|{
if|if
condition|(
name|clock
operator|->
name|p1
operator|<
name|limit
operator|->
name|p1
operator|.
name|min
operator|||
name|limit
operator|->
name|p1
operator|.
name|max
operator|<
name|clock
operator|->
name|p1
condition|)
name|INTELPllInvalid
argument_list|(
literal|"p1 out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|p
operator|<
name|limit
operator|->
name|p
operator|.
name|min
operator|||
name|limit
operator|->
name|p
operator|.
name|max
operator|<
name|clock
operator|->
name|p
condition|)
name|INTELPllInvalid
argument_list|(
literal|"p out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|m2
operator|<
name|limit
operator|->
name|m2
operator|.
name|min
operator|||
name|limit
operator|->
name|m2
operator|.
name|max
operator|<
name|clock
operator|->
name|m2
condition|)
name|INTELPllInvalid
argument_list|(
literal|"m2 out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|m1
operator|<
name|limit
operator|->
name|m1
operator|.
name|min
operator|||
name|limit
operator|->
name|m1
operator|.
name|max
operator|<
name|clock
operator|->
name|m1
condition|)
name|INTELPllInvalid
argument_list|(
literal|"m1 out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|m1
operator|<=
name|clock
operator|->
name|m2
operator|&&
operator|!
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|INTELPllInvalid
argument_list|(
literal|"m1<= m2\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|m
operator|<
name|limit
operator|->
name|m
operator|.
name|min
operator|||
name|limit
operator|->
name|m
operator|.
name|max
operator|<
name|clock
operator|->
name|m
condition|)
name|INTELPllInvalid
argument_list|(
literal|"m out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|n
operator|<
name|limit
operator|->
name|n
operator|.
name|min
operator|||
name|limit
operator|->
name|n
operator|.
name|max
operator|<
name|clock
operator|->
name|n
condition|)
name|INTELPllInvalid
argument_list|(
literal|"n out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|vco
operator|<
name|limit
operator|->
name|vco
operator|.
name|min
operator|||
name|limit
operator|->
name|vco
operator|.
name|max
operator|<
name|clock
operator|->
name|vco
condition|)
name|INTELPllInvalid
argument_list|(
literal|"vco out of range\n"
argument_list|)
expr_stmt|;
comment|/* XXX: We may need to be checking "Dot clock" depending on the multiplier, 	 * connector, etc., rather than just a single range. 	 */
if|if
condition|(
name|clock
operator|->
name|dot
operator|<
name|limit
operator|->
name|dot
operator|.
name|min
operator|||
name|limit
operator|->
name|dot
operator|.
name|max
operator|<
name|clock
operator|->
name|dot
condition|)
name|INTELPllInvalid
argument_list|(
literal|"dot out of range\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_find_best_PLL
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|;
name|int
name|err
init|=
name|target
decl_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|&&
operator|(
name|I915_READ
argument_list|(
name|LVDS
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * For LVDS, if the panel is on, just rely on its current 		 * settings for dual-channel.  We haven't figured out how to 		 * reliably set up different single/dual channel state, if we 		 * even can. 		 */
if|if
condition|(
name|is_dual_link_lvds
argument_list|(
name|dev_priv
argument_list|,
name|LVDS
argument_list|)
condition|)
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_fast
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_slow
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target
operator|<
name|limit
operator|->
name|p2
operator|.
name|dot_limit
condition|)
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_slow
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_fast
expr_stmt|;
block|}
name|memset
argument_list|(
name|best_clock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|best_clock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|clock
operator|.
name|m1
operator|=
name|limit
operator|->
name|m1
operator|.
name|min
init|;
name|clock
operator|.
name|m1
operator|<=
name|limit
operator|->
name|m1
operator|.
name|max
condition|;
name|clock
operator|.
name|m1
operator|++
control|)
block|{
for|for
control|(
name|clock
operator|.
name|m2
operator|=
name|limit
operator|->
name|m2
operator|.
name|min
init|;
name|clock
operator|.
name|m2
operator|<=
name|limit
operator|->
name|m2
operator|.
name|max
condition|;
name|clock
operator|.
name|m2
operator|++
control|)
block|{
comment|/* m1 is always 0 in Pineview */
if|if
condition|(
name|clock
operator|.
name|m2
operator|>=
name|clock
operator|.
name|m1
operator|&&
operator|!
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
break|break;
for|for
control|(
name|clock
operator|.
name|n
operator|=
name|limit
operator|->
name|n
operator|.
name|min
init|;
name|clock
operator|.
name|n
operator|<=
name|limit
operator|->
name|n
operator|.
name|max
condition|;
name|clock
operator|.
name|n
operator|++
control|)
block|{
for|for
control|(
name|clock
operator|.
name|p1
operator|=
name|limit
operator|->
name|p1
operator|.
name|min
init|;
name|clock
operator|.
name|p1
operator|<=
name|limit
operator|->
name|p1
operator|.
name|max
condition|;
name|clock
operator|.
name|p1
operator|++
control|)
block|{
name|int
name|this_err
decl_stmt|;
name|intel_clock
argument_list|(
name|dev
argument_list|,
name|refclk
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_PLL_is_valid
argument_list|(
name|dev
argument_list|,
name|limit
argument_list|,
operator|&
name|clock
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|match_clock
operator|&&
name|clock
operator|.
name|p
operator|!=
name|match_clock
operator|->
name|p
condition|)
continue|continue;
name|this_err
operator|=
name|abs
argument_list|(
name|clock
operator|.
name|dot
operator|-
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_err
operator|<
name|err
condition|)
block|{
operator|*
name|best_clock
operator|=
name|clock
expr_stmt|;
name|err
operator|=
name|this_err
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
operator|(
name|err
operator|!=
name|target
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_g4x_find_best_PLL
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|;
name|int
name|max_n
decl_stmt|;
name|bool
name|found
decl_stmt|;
comment|/* approximately equals target * 0.00585 */
name|int
name|err_most
init|=
operator|(
name|target
operator|>>
literal|8
operator|)
operator|+
operator|(
name|target
operator|>>
literal|9
operator|)
decl_stmt|;
name|found
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
name|int
name|lvds_reg
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|lvds_reg
operator|=
name|PCH_LVDS
expr_stmt|;
else|else
name|lvds_reg
operator|=
name|LVDS
expr_stmt|;
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|lvds_reg
argument_list|)
operator|&
name|LVDS_CLKB_POWER_MASK
operator|)
operator|==
name|LVDS_CLKB_POWER_UP
condition|)
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_fast
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_slow
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target
operator|<
name|limit
operator|->
name|p2
operator|.
name|dot_limit
condition|)
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_slow
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_fast
expr_stmt|;
block|}
name|memset
argument_list|(
name|best_clock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|best_clock
argument_list|)
argument_list|)
expr_stmt|;
name|max_n
operator|=
name|limit
operator|->
name|n
operator|.
name|max
expr_stmt|;
comment|/* based on hardware requirement, prefer smaller n to precision */
for|for
control|(
name|clock
operator|.
name|n
operator|=
name|limit
operator|->
name|n
operator|.
name|min
init|;
name|clock
operator|.
name|n
operator|<=
name|max_n
condition|;
name|clock
operator|.
name|n
operator|++
control|)
block|{
comment|/* based on hardware requirement, prefere larger m1,m2 */
for|for
control|(
name|clock
operator|.
name|m1
operator|=
name|limit
operator|->
name|m1
operator|.
name|max
init|;
name|clock
operator|.
name|m1
operator|>=
name|limit
operator|->
name|m1
operator|.
name|min
condition|;
name|clock
operator|.
name|m1
operator|--
control|)
block|{
for|for
control|(
name|clock
operator|.
name|m2
operator|=
name|limit
operator|->
name|m2
operator|.
name|max
init|;
name|clock
operator|.
name|m2
operator|>=
name|limit
operator|->
name|m2
operator|.
name|min
condition|;
name|clock
operator|.
name|m2
operator|--
control|)
block|{
for|for
control|(
name|clock
operator|.
name|p1
operator|=
name|limit
operator|->
name|p1
operator|.
name|max
init|;
name|clock
operator|.
name|p1
operator|>=
name|limit
operator|->
name|p1
operator|.
name|min
condition|;
name|clock
operator|.
name|p1
operator|--
control|)
block|{
name|int
name|this_err
decl_stmt|;
name|intel_clock
argument_list|(
name|dev
argument_list|,
name|refclk
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_PLL_is_valid
argument_list|(
name|dev
argument_list|,
name|limit
argument_list|,
operator|&
name|clock
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|match_clock
operator|&&
name|clock
operator|.
name|p
operator|!=
name|match_clock
operator|->
name|p
condition|)
continue|continue;
name|this_err
operator|=
name|abs
argument_list|(
name|clock
operator|.
name|dot
operator|-
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_err
operator|<
name|err_most
condition|)
block|{
operator|*
name|best_clock
operator|=
name|clock
expr_stmt|;
name|err_most
operator|=
name|this_err
expr_stmt|;
name|max_n
operator|=
name|clock
operator|.
name|n
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_find_pll_ironlake_dp
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|200000
condition|)
block|{
name|clock
operator|.
name|n
operator|=
literal|1
expr_stmt|;
name|clock
operator|.
name|p1
operator|=
literal|2
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|12
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|9
expr_stmt|;
block|}
else|else
block|{
name|clock
operator|.
name|n
operator|=
literal|2
expr_stmt|;
name|clock
operator|.
name|p1
operator|=
literal|1
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|14
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|8
expr_stmt|;
block|}
name|intel_clock
argument_list|(
name|dev
argument_list|,
name|refclk
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|best_clock
argument_list|,
operator|&
name|clock
argument_list|,
sizeof|sizeof
argument_list|(
name|intel_clock_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* DisplayPort has only two frequencies, 162MHz and 270MHz */
end_comment

begin_function
specifier|static
name|bool
name|intel_find_pll_g4x_dp
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
block|{
name|intel_clock_t
name|clock
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|200000
condition|)
block|{
name|clock
operator|.
name|p1
operator|=
literal|2
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|n
operator|=
literal|2
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|23
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|clock
operator|.
name|p1
operator|=
literal|1
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|n
operator|=
literal|1
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|14
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|2
expr_stmt|;
block|}
name|clock
operator|.
name|m
operator|=
literal|5
operator|*
operator|(
name|clock
operator|.
name|m1
operator|+
literal|2
operator|)
operator|+
operator|(
name|clock
operator|.
name|m2
operator|+
literal|2
operator|)
expr_stmt|;
name|clock
operator|.
name|p
operator|=
operator|(
name|clock
operator|.
name|p1
operator|*
name|clock
operator|.
name|p2
operator|)
expr_stmt|;
name|clock
operator|.
name|dot
operator|=
literal|96000
operator|*
name|clock
operator|.
name|m
operator|/
operator|(
name|clock
operator|.
name|n
operator|+
literal|2
operator|)
operator|/
name|clock
operator|.
name|p
expr_stmt|;
name|clock
operator|.
name|vco
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|best_clock
argument_list|,
operator|&
name|clock
argument_list|,
sizeof|sizeof
argument_list|(
name|intel_clock_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_vlv_find_best_pll
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
block|{
name|u32
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|vco
decl_stmt|,
name|bestn
decl_stmt|,
name|bestm1
decl_stmt|,
name|bestm2
decl_stmt|,
name|bestp1
decl_stmt|,
name|bestp2
decl_stmt|;
name|u32
name|m
decl_stmt|,
name|n
decl_stmt|,
name|fastclk
decl_stmt|;
name|u32
name|updrate
decl_stmt|,
name|minupdate
decl_stmt|,
name|fracbits
decl_stmt|,
name|p
decl_stmt|;
name|unsigned
name|long
name|bestppm
decl_stmt|,
name|ppm
decl_stmt|,
name|absppm
decl_stmt|;
name|int
name|dotclk
decl_stmt|,
name|flag
decl_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
name|dotclk
operator|=
name|target
operator|*
literal|1000
expr_stmt|;
name|bestppm
operator|=
literal|1000000
expr_stmt|;
name|ppm
operator|=
name|absppm
operator|=
literal|0
expr_stmt|;
name|fastclk
operator|=
name|dotclk
operator|/
operator|(
literal|2
operator|*
literal|100
operator|)
expr_stmt|;
name|updrate
operator|=
literal|0
expr_stmt|;
name|minupdate
operator|=
literal|19200
expr_stmt|;
name|fracbits
operator|=
literal|1
expr_stmt|;
name|n
operator|=
name|p
operator|=
name|p1
operator|=
name|p2
operator|=
name|m
operator|=
name|m1
operator|=
name|m2
operator|=
name|vco
operator|=
name|bestn
operator|=
literal|0
expr_stmt|;
name|bestm1
operator|=
name|bestm2
operator|=
name|bestp1
operator|=
name|bestp2
operator|=
literal|0
expr_stmt|;
comment|/* based on hardware requirement, prefer smaller n to precision */
for|for
control|(
name|n
operator|=
name|limit
operator|->
name|n
operator|.
name|min
init|;
name|n
operator|<=
operator|(
operator|(
name|refclk
operator|)
operator|/
name|minupdate
operator|)
condition|;
name|n
operator|++
control|)
block|{
name|updrate
operator|=
name|refclk
operator|/
name|n
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|limit
operator|->
name|p1
operator|.
name|max
init|;
name|p1
operator|>
name|limit
operator|->
name|p1
operator|.
name|min
condition|;
name|p1
operator|--
control|)
block|{
for|for
control|(
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_fast
operator|+
literal|1
init|;
name|p2
operator|>
literal|0
condition|;
name|p2
operator|--
control|)
block|{
if|if
condition|(
name|p2
operator|>
literal|10
condition|)
name|p2
operator|=
name|p2
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|p1
operator|*
name|p2
expr_stmt|;
comment|/* based on hardware requirement, prefer bigger m1,m2 values */
for|for
control|(
name|m1
operator|=
name|limit
operator|->
name|m1
operator|.
name|min
init|;
name|m1
operator|<=
name|limit
operator|->
name|m1
operator|.
name|max
condition|;
name|m1
operator|++
control|)
block|{
name|m2
operator|=
operator|(
operator|(
operator|(
literal|2
operator|*
operator|(
name|fastclk
operator|*
name|p
operator|*
name|n
operator|/
name|m1
operator|)
operator|)
operator|+
name|refclk
operator|)
operator|/
operator|(
literal|2
operator|*
name|refclk
operator|)
operator|)
expr_stmt|;
name|m
operator|=
name|m1
operator|*
name|m2
expr_stmt|;
name|vco
operator|=
name|updrate
operator|*
name|m
expr_stmt|;
if|if
condition|(
name|vco
operator|>=
name|limit
operator|->
name|vco
operator|.
name|min
operator|&&
name|vco
operator|<
name|limit
operator|->
name|vco
operator|.
name|max
condition|)
block|{
name|ppm
operator|=
literal|1000000
operator|*
operator|(
operator|(
name|vco
operator|/
name|p
operator|)
operator|-
name|fastclk
operator|)
operator|/
name|fastclk
expr_stmt|;
name|absppm
operator|=
operator|(
name|ppm
operator|>
literal|0
operator|)
condition|?
name|ppm
else|:
operator|(
operator|-
name|ppm
operator|)
expr_stmt|;
if|if
condition|(
name|absppm
operator|<
literal|100
operator|&&
operator|(
operator|(
name|p1
operator|*
name|p2
operator|)
operator|>
operator|(
name|bestp1
operator|*
name|bestp2
operator|)
operator|)
condition|)
block|{
name|bestppm
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|absppm
operator|<
name|bestppm
operator|-
literal|10
condition|)
block|{
name|bestppm
operator|=
name|absppm
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flag
condition|)
block|{
name|bestn
operator|=
name|n
expr_stmt|;
name|bestm1
operator|=
name|m1
expr_stmt|;
name|bestm2
operator|=
name|m2
expr_stmt|;
name|bestp1
operator|=
name|p1
expr_stmt|;
name|bestp2
operator|=
name|p2
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|best_clock
operator|->
name|n
operator|=
name|bestn
expr_stmt|;
name|best_clock
operator|->
name|m1
operator|=
name|bestm1
expr_stmt|;
name|best_clock
operator|->
name|m2
operator|=
name|bestm2
expr_stmt|;
name|best_clock
operator|->
name|p1
operator|=
name|bestp1
expr_stmt|;
name|best_clock
operator|->
name|p2
operator|=
name|bestp2
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|enum
name|transcoder
name|intel_pipe_to_cpu_transcoder
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|pipe
index|]
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
return|return
name|intel_crtc
operator|->
name|cpu_transcoder
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_wait_for_vblank
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|frame
decl_stmt|,
name|frame_reg
init|=
name|PIPEFRAME
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|frame
operator|=
name|I915_READ
argument_list|(
name|frame_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
name|I915_READ_NOTRACE
argument_list|(
name|frame_reg
argument_list|)
operator|!=
name|frame
argument_list|,
literal|50
argument_list|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"vblank wait timed out\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_wait_for_vblank - wait for vblank on a given pipe  * @dev: drm device  * @pipe: pipe to wait for  *  * Wait for vblank to occur on a given pipe.  Needed for various bits of  * mode setting code.  */
end_comment

begin_function
name|void
name|intel_wait_for_vblank
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipestat_reg
init|=
name|PIPESTAT
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|5
condition|)
block|{
name|ironlake_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Clear existing vblank status. Note this will clear any other 	 * sticky status fields as well. 	 * 	 * This races with i915_driver_irq_handler() with the result 	 * that either function could miss a vblank event.  Here it is not 	 * fatal, as we will either wait upon the next vblank interrupt or 	 * timeout.  Generally speaking intel_wait_for_vblank() is only 	 * called during modeset at which time the GPU should be idle and 	 * should *not* be performing page flips and thus not waiting on 	 * vblanks... 	 * Currently, the result of us stealing a vblank from the irq 	 * handler is that a single frame will be skipped during swapbuffers. 	 */
name|I915_WRITE
argument_list|(
name|pipestat_reg
argument_list|,
name|I915_READ
argument_list|(
name|pipestat_reg
argument_list|)
operator||
name|PIPE_VBLANK_INTERRUPT_STATUS
argument_list|)
expr_stmt|;
comment|/* Wait for vblank interrupt bit to set */
if|if
condition|(
name|wait_for
argument_list|(
name|I915_READ
argument_list|(
name|pipestat_reg
argument_list|)
operator|&
name|PIPE_VBLANK_INTERRUPT_STATUS
argument_list|,
literal|50
argument_list|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"vblank wait timed out\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * intel_wait_for_pipe_off - wait for pipe to turn off  * @dev: drm device  * @pipe: pipe to wait for  *  * After disabling a pipe, we can't wait for vblank in the usual way,  * spinning on the vblank interrupt status bit, since we won't actually  * see an interrupt when the pipe is disabled.  *  * On Gen4 and above:  *   wait for the pipe register state bit to turn off  *  * Otherwise:  *   wait for the display line value to settle (it usually  *   ends up stopping at the start of the next frame).  *  */
end_comment

begin_function
name|void
name|intel_wait_for_pipe_off
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|enum
name|transcoder
name|cpu_transcoder
init|=
name|intel_pipe_to_cpu_transcoder
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|int
name|reg
init|=
name|PIPECONF
argument_list|(
name|cpu_transcoder
argument_list|)
decl_stmt|;
comment|/* Wait for the Pipe State to go off */
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|I965_PIPECONF_ACTIVE
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
name|WARN
argument_list|(
literal|1
argument_list|,
literal|"pipe_off wait timed out\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u32
name|last_line
decl_stmt|,
name|line_mask
decl_stmt|;
name|int
name|reg
init|=
name|PIPEDSL
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|timeout
init|=
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
literal|100
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|line_mask
operator|=
name|DSL_LINEMASK_GEN2
expr_stmt|;
else|else
name|line_mask
operator|=
name|DSL_LINEMASK_GEN3
expr_stmt|;
comment|/* Wait for the display line to settle */
do|do
block|{
name|last_line
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|line_mask
expr_stmt|;
name|mdelay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|(
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|line_mask
operator|)
operator|!=
name|last_line
operator|)
operator|&&
name|time_after
argument_list|(
name|timeout
argument_list|,
name|jiffies
argument_list|)
condition|)
do|;
if|if
condition|(
name|time_after
argument_list|(
name|jiffies
argument_list|,
name|timeout
argument_list|)
condition|)
name|WARN
argument_list|(
literal|1
argument_list|,
literal|"pipe_off wait timed out\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|state_string
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
return|return
name|enabled
condition|?
literal|"on"
else|:
literal|"off"
return|;
block|}
end_function

begin_comment
comment|/* Only for pre-ILK configs */
end_comment

begin_function
specifier|static
name|void
name|assert_pll
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
name|reg
operator|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|DPLL_VCO_ENABLE
operator|)
expr_stmt|;
name|WARN
argument_list|(
name|cur_state
operator|!=
name|state
argument_list|,
literal|"PLL state assertion failure (expected %s, current %s)\n"
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|assert_pll_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_pll(d, p, true)
end_define

begin_define
define|#
directive|define
name|assert_pll_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_pll(d, p, false)
end_define

begin_comment
comment|/* For ILK+ */
end_comment

begin_function
specifier|static
name|void
name|assert_pch_pll
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|intel_pch_pll
modifier|*
name|pll
parameter_list|,
name|struct
name|intel_crtc
modifier|*
name|crtc
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
if|if
condition|(
name|HAS_PCH_LPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"LPT detected: skipping PCH PLL test\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|WARN
argument_list|(
operator|!
name|pll
argument_list|,
literal|"asserting PCH PLL %s with no PLL\n"
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|)
condition|)
return|return;
name|val
operator|=
name|I915_READ
argument_list|(
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|DPLL_VCO_ENABLE
operator|)
expr_stmt|;
name|WARN
argument_list|(
name|cur_state
operator|!=
name|state
argument_list|,
literal|"PCH PLL state for reg %x assertion failure (expected %s, current %s), val=%08x\n"
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Make sure the selected PLL is correctly attached to the transcoder */
if|if
condition|(
name|crtc
operator|&&
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|u32
name|pch_dpll
decl_stmt|;
name|pch_dpll
operator|=
name|I915_READ
argument_list|(
name|PCH_DPLL_SEL
argument_list|)
expr_stmt|;
name|cur_state
operator|=
name|pll
operator|->
name|pll_reg
operator|==
name|_PCH_DPLL_B
expr_stmt|;
if|if
condition|(
operator|!
name|WARN
argument_list|(
operator|(
operator|(
name|pch_dpll
operator|>>
operator|(
literal|4
operator|*
name|crtc
operator|->
name|pipe
operator|)
operator|)
operator|&
literal|1
operator|)
operator|!=
name|cur_state
argument_list|,
literal|"PLL[%d] not attached to this transcoder %d: %08x\n"
argument_list|,
name|cur_state
argument_list|,
name|crtc
operator|->
name|pipe
argument_list|,
name|pch_dpll
argument_list|)
condition|)
block|{
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|>>
operator|(
literal|4
operator|*
name|crtc
operator|->
name|pipe
operator|+
literal|3
operator|)
operator|)
expr_stmt|;
name|WARN
argument_list|(
name|cur_state
operator|!=
name|state
argument_list|,
literal|"PLL[%d] not %s on this transcoder %d: %08x\n"
argument_list|,
name|pll
operator|->
name|pll_reg
operator|==
name|_PCH_DPLL_B
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|crtc
operator|->
name|pipe
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|assert_pch_pll_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|,
name|c
parameter_list|)
value|assert_pch_pll(d, p, c, true)
end_define

begin_define
define|#
directive|define
name|assert_pch_pll_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|,
name|c
parameter_list|)
value|assert_pch_pll(d, p, c, false)
end_define

begin_function
specifier|static
name|void
name|assert_fdi_tx
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
name|enum
name|transcoder
name|cpu_transcoder
init|=
name|intel_pipe_to_cpu_transcoder
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
comment|/* On Haswell, DDI is used instead of FDI_TX_CTL */
name|reg
operator|=
name|TRANS_DDI_FUNC_CTL
argument_list|(
name|cpu_transcoder
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|TRANS_DDI_FUNC_ENABLE
operator|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|FDI_TX_ENABLE
operator|)
expr_stmt|;
block|}
name|WARN
argument_list|(
name|cur_state
operator|!=
name|state
argument_list|,
literal|"FDI TX state assertion failure (expected %s, current %s)\n"
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|assert_fdi_tx_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_fdi_tx(d, p, true)
end_define

begin_define
define|#
directive|define
name|assert_fdi_tx_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_fdi_tx(d, p, false)
end_define

begin_function
specifier|static
name|void
name|assert_fdi_rx
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|FDI_RX_ENABLE
operator|)
expr_stmt|;
name|WARN
argument_list|(
name|cur_state
operator|!=
name|state
argument_list|,
literal|"FDI RX state assertion failure (expected %s, current %s)\n"
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|assert_fdi_rx_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_fdi_rx(d, p, true)
end_define

begin_define
define|#
directive|define
name|assert_fdi_rx_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_fdi_rx(d, p, false)
end_define

begin_function
specifier|static
name|void
name|assert_fdi_tx_pll_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* ILK FDI PLL is always enabled */
if|if
condition|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|==
literal|5
condition|)
return|return;
comment|/* On Haswell, DDI ports are responsible for the FDI PLL setup */
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
return|return;
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
operator|!
operator|(
name|val
operator|&
name|FDI_TX_PLL_ENABLE
operator|)
argument_list|,
literal|"FDI TX PLL assertion failure, should be active but is disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_fdi_rx_pll_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
operator|!
operator|(
name|val
operator|&
name|FDI_RX_PLL_ENABLE
operator|)
argument_list|,
literal|"FDI RX PLL assertion failure, should be active but is disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_panel_unlocked
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|pp_reg
decl_stmt|,
name|lvds_reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|enum
name|pipe
name|panel_pipe
init|=
name|PIPE_A
decl_stmt|;
name|bool
name|locked
init|=
name|true
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|pp_reg
operator|=
name|PCH_PP_CONTROL
expr_stmt|;
name|lvds_reg
operator|=
name|PCH_LVDS
expr_stmt|;
block|}
else|else
block|{
name|pp_reg
operator|=
name|PP_CONTROL
expr_stmt|;
name|lvds_reg
operator|=
name|LVDS
expr_stmt|;
block|}
name|val
operator|=
name|I915_READ
argument_list|(
name|pp_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PANEL_POWER_ON
operator|)
operator|||
operator|(
operator|(
name|val
operator|&
name|PANEL_UNLOCK_REGS
operator|)
operator|==
name|PANEL_UNLOCK_REGS
operator|)
condition|)
name|locked
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|lvds_reg
argument_list|)
operator|&
name|LVDS_PIPEB_SELECT
condition|)
name|panel_pipe
operator|=
name|PIPE_B
expr_stmt|;
name|WARN
argument_list|(
name|panel_pipe
operator|==
name|pipe
operator|&&
name|locked
argument_list|,
literal|"panel assertion failure, pipe %c regs locked\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|assert_pipe
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
name|enum
name|transcoder
name|cpu_transcoder
init|=
name|intel_pipe_to_cpu_transcoder
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
decl_stmt|;
comment|/* if we need the pipe A quirk it must be always on */
if|if
condition|(
name|pipe
operator|==
name|PIPE_A
operator|&&
name|dev_priv
operator|->
name|quirks
operator|&
name|QUIRK_PIPEA_FORCE
condition|)
name|state
operator|=
name|true
expr_stmt|;
name|reg
operator|=
name|PIPECONF
argument_list|(
name|cpu_transcoder
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|PIPECONF_ENABLE
operator|)
expr_stmt|;
name|WARN
argument_list|(
name|cur_state
operator|!=
name|state
argument_list|,
literal|"pipe %c assertion failure (expected %s, current %s)\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_plane
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|plane
name|plane
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
expr_stmt|;
name|WARN
argument_list|(
name|cur_state
operator|!=
name|state
argument_list|,
literal|"plane %c assertion failure (expected %s, current %s)\n"
argument_list|,
name|plane_name
argument_list|(
name|plane
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|assert_plane_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_plane(d, p, true)
end_define

begin_define
define|#
directive|define
name|assert_plane_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_plane(d, p, false)
end_define

begin_function
specifier|static
name|void
name|assert_planes_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|,
name|i
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|int
name|cur_pipe
decl_stmt|;
comment|/* Planes are fixed to pipes on ILK+ */
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
argument_list|,
literal|"plane %c assertion failure, should be disabled but not\n"
argument_list|,
name|plane_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Need to check both planes against the pipe */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_pipe
operator|=
operator|(
name|val
operator|&
name|DISPPLANE_SEL_PIPE_MASK
operator|)
operator|>>
name|DISPPLANE_SEL_PIPE_SHIFT
expr_stmt|;
name|WARN
argument_list|(
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
operator|&&
name|pipe
operator|==
name|cur_pipe
argument_list|,
literal|"plane %c assertion failure, should be off on pipe %c but is still active\n"
argument_list|,
name|plane_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|assert_pch_refclk_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|bool
name|enabled
decl_stmt|;
if|if
condition|(
name|HAS_PCH_LPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"LPT does not has PCH refclk, skipping check\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|val
operator|=
name|I915_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|enabled
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
operator|(
name|DREF_SSC_SOURCE_MASK
operator||
name|DREF_NONSPREAD_SOURCE_MASK
operator||
name|DREF_SUPERSPREAD_SOURCE_MASK
operator|)
operator|)
expr_stmt|;
name|WARN
argument_list|(
operator|!
name|enabled
argument_list|,
literal|"PCH refclk assertion failure, should be active but is disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_transcoder_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|enabled
decl_stmt|;
name|reg
operator|=
name|TRANSCONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|enabled
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|TRANS_ENABLE
operator|)
expr_stmt|;
name|WARN
argument_list|(
name|enabled
argument_list|,
literal|"transcoder assertion failed, should be off on pipe %c but is still active\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|dp_pipe_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|u32
name|port_sel
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|DP_PORT_EN
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|u32
name|trans_dp_ctl_reg
init|=
name|TRANS_DP_CTL
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|u32
name|trans_dp_ctl
init|=
name|I915_READ
argument_list|(
name|trans_dp_ctl_reg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|trans_dp_ctl
operator|&
name|TRANS_DP_PORT_SEL_MASK
operator|)
operator|!=
name|port_sel
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|DP_PIPE_MASK
operator|)
operator|!=
operator|(
name|pipe
operator|<<
literal|30
operator|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|hdmi_pipe_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_TRANS_SEL_MASK
operator|)
operator|!=
name|PORT_TRANS_SEL_CPT
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|TRANSCODER_MASK
operator|)
operator|!=
name|TRANSCODER
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|lvds_pipe_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|LVDS_PORT_EN
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_TRANS_SEL_MASK
operator|)
operator|!=
name|PORT_TRANS_SEL_CPT
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|LVDS_PIPE_MASK
operator|)
operator|!=
name|LVDS_PIPE
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|adpa_pipe_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|ADPA_DAC_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_TRANS_SEL_MASK
operator|)
operator|!=
name|PORT_TRANS_SEL_CPT
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|ADPA_PIPE_SELECT_MASK
operator|)
operator|!=
name|ADPA_PIPE_SELECT
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_pch_dp_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|int
name|reg
parameter_list|,
name|u32
name|port_sel
parameter_list|)
block|{
name|u32
name|val
init|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|WARN
argument_list|(
name|dp_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|port_sel
argument_list|,
name|val
argument_list|)
argument_list|,
literal|"PCH DP (0x%08x) enabled on transcoder %c, should be disabled\n"
argument_list|,
name|reg
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
name|HAS_PCH_IBX
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
operator|&&
operator|(
name|val
operator|&
name|DP_PORT_EN
operator|)
operator|==
literal|0
operator|&&
operator|(
name|val
operator|&
name|DP_PIPEB_SELECT
operator|)
argument_list|,
literal|"IBX PCH dp port still using transcoder B\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_pch_hdmi_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|u32
name|val
init|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|WARN
argument_list|(
name|hdmi_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|val
argument_list|)
argument_list|,
literal|"PCH HDMI (0x%08x) enabled on transcoder %c, should be disabled\n"
argument_list|,
name|reg
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
name|HAS_PCH_IBX
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
operator|&&
operator|(
name|val
operator|&
name|PORT_ENABLE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|val
operator|&
name|SDVO_PIPE_B_SELECT
operator|)
argument_list|,
literal|"IBX PCH hdmi port still using transcoder B\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_pch_ports_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|assert_pch_dp_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_B
argument_list|,
name|TRANS_DP_PORT_SEL_B
argument_list|)
expr_stmt|;
name|assert_pch_dp_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_C
argument_list|,
name|TRANS_DP_PORT_SEL_C
argument_list|)
expr_stmt|;
name|assert_pch_dp_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_D
argument_list|,
name|TRANS_DP_PORT_SEL_D
argument_list|)
expr_stmt|;
name|reg
operator|=
name|PCH_ADPA
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
name|adpa_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|val
argument_list|)
argument_list|,
literal|"PCH VGA enabled on transcoder %c, should be disabled\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|PCH_LVDS
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
name|lvds_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|val
argument_list|)
argument_list|,
literal|"PCH LVDS enabled on transcoder %c, should be disabled\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|assert_pch_hdmi_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMIB
argument_list|)
expr_stmt|;
name|assert_pch_hdmi_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMIC
argument_list|)
expr_stmt|;
name|assert_pch_hdmi_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMID
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_enable_pll - enable a PLL  * @dev_priv: i915 private structure  * @pipe: pipe PLL to enable  *  * Enable @pipe's PLL so we can start pumping pixels from a plane.  Check to  * make sure the PLL reg is writable first though, since the panel write  * protect mechanism may be enabled.  *  * Note!  This is for pre-ILK only.  *  * Unfortunately needed by dvo_ns2501 since the dvo depends on it running.  */
end_comment

begin_function
specifier|static
name|void
name|intel_enable_pll
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* No really, not for ILK+ */
name|BUG_ON
argument_list|(
operator|!
name|IS_VALLEYVIEW
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
operator|&&
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|>=
literal|5
argument_list|)
expr_stmt|;
comment|/* PLL is protected by panel, make sure we can write it */
if|if
condition|(
name|IS_MOBILE
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
operator|&&
operator|!
name|IS_I830
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
name|assert_panel_unlocked
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator||=
name|DPLL_VCO_ENABLE
expr_stmt|;
comment|/* We do this three times for luck */
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* wait for warmup */
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* wait for warmup */
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* wait for warmup */
block|}
end_function

begin_comment
comment|/**  * intel_disable_pll - disable a PLL  * @dev_priv: i915 private structure  * @pipe: pipe PLL to disable  *  * Disable the PLL for @pipe, making sure the pipe is off first.  *  * Note!  This is for pre-ILK only.  */
end_comment

begin_function
specifier|static
name|void
name|intel_disable_pll
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* Don't disable pipe A or pipe A PLLs if needed */
if|if
condition|(
name|pipe
operator|==
name|PIPE_A
operator|&&
operator|(
name|dev_priv
operator|->
name|quirks
operator|&
name|QUIRK_PIPEA_FORCE
operator|)
condition|)
return|return;
comment|/* Make sure the pipe isn't still relying on us */
name|assert_pipe_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|DPLL_VCO_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SBI access */
end_comment

begin_function
specifier|static
name|void
name|intel_sbi_write
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|u16
name|reg
parameter_list|,
name|u32
name|value
parameter_list|,
name|enum
name|intel_sbi_destination
name|destination
parameter_list|)
block|{
name|u32
name|tmp
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|SBI_CTL_STAT
argument_list|)
operator|&
name|SBI_BUSY
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for SBI to become ready\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|I915_WRITE
argument_list|(
name|SBI_ADDR
argument_list|,
operator|(
name|reg
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SBI_DATA
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|destination
operator|==
name|SBI_ICLK
condition|)
name|tmp
operator|=
name|SBI_CTL_DEST_ICLK
operator||
name|SBI_CTL_OP_CRWR
expr_stmt|;
else|else
name|tmp
operator|=
name|SBI_CTL_DEST_MPHY
operator||
name|SBI_CTL_OP_IOWR
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SBI_CTL_STAT
argument_list|,
name|SBI_BUSY
operator||
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|SBI_CTL_STAT
argument_list|)
operator|&
operator|(
name|SBI_BUSY
operator||
name|SBI_RESPONSE_FAIL
operator|)
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for SBI to complete write transaction\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|out_unlock
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u32
name|intel_sbi_read
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|u16
name|reg
parameter_list|,
name|enum
name|intel_sbi_destination
name|destination
parameter_list|)
block|{
name|u32
name|value
init|=
literal|0
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|SBI_CTL_STAT
argument_list|)
operator|&
name|SBI_BUSY
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for SBI to become ready\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|I915_WRITE
argument_list|(
name|SBI_ADDR
argument_list|,
operator|(
name|reg
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|destination
operator|==
name|SBI_ICLK
condition|)
name|value
operator|=
name|SBI_CTL_DEST_ICLK
operator||
name|SBI_CTL_OP_CRRD
expr_stmt|;
else|else
name|value
operator|=
name|SBI_CTL_DEST_MPHY
operator||
name|SBI_CTL_OP_IORD
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SBI_CTL_STAT
argument_list|,
name|value
operator||
name|SBI_BUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|SBI_CTL_STAT
argument_list|)
operator|&
operator|(
name|SBI_BUSY
operator||
name|SBI_RESPONSE_FAIL
operator|)
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for SBI to complete read transaction\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|value
operator|=
name|I915_READ
argument_list|(
name|SBI_DATA
argument_list|)
expr_stmt|;
name|out_unlock
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/**  * ironlake_enable_pch_pll - enable PCH PLL  * @dev_priv: i915 private structure  * @pipe: pipe PLL to enable  *  * The PCH PLL needs to be enabled before the PCH transcoder, since it  * drives the transcoder clock.  */
end_comment

begin_function
specifier|static
name|void
name|ironlake_enable_pch_pll
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|intel_crtc
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_pch_pll
modifier|*
name|pll
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* PCH PLLs only available on ILK, SNB and IVB */
name|BUG_ON
argument_list|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|<
literal|5
argument_list|)
expr_stmt|;
name|pll
operator|=
name|intel_crtc
operator|->
name|pch_pll
expr_stmt|;
if|if
condition|(
name|pll
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|WARN_ON
argument_list|(
name|pll
operator|->
name|refcount
operator|==
literal|0
argument_list|)
condition|)
return|return;
name|DRM_DEBUG_KMS
argument_list|(
literal|"enable PCH PLL %x (active %d, on? %d)for crtc %d\n"
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|,
name|pll
operator|->
name|active
argument_list|,
name|pll
operator|->
name|on
argument_list|,
name|intel_crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
comment|/* PCH refclock must be enabled first */
name|assert_pch_refclk_enabled
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll
operator|->
name|active
operator|++
operator|&&
name|pll
operator|->
name|on
condition|)
block|{
name|assert_pch_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pll
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"enabling PCH PLL %x\n"
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pll
operator|->
name|pll_reg
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator||=
name|DPLL_VCO_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|pll
operator|->
name|on
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_disable_pch_pll
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|intel_crtc
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_pch_pll
modifier|*
name|pll
init|=
name|intel_crtc
operator|->
name|pch_pll
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* PCH only available on ILK+ */
name|BUG_ON
argument_list|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|<
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|WARN_ON
argument_list|(
name|pll
operator|->
name|refcount
operator|==
literal|0
argument_list|)
condition|)
return|return;
name|DRM_DEBUG_KMS
argument_list|(
literal|"disable PCH PLL %x (active %d, on? %d) for crtc %d\n"
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|,
name|pll
operator|->
name|active
argument_list|,
name|pll
operator|->
name|on
argument_list|,
name|intel_crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|WARN_ON
argument_list|(
name|pll
operator|->
name|active
operator|==
literal|0
argument_list|)
condition|)
block|{
name|assert_pch_pll_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pll
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|pll
operator|->
name|active
condition|)
block|{
name|assert_pch_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pll
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabling PCH PLL %x\n"
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
comment|/* Make sure transcoder isn't still depending on us */
name|assert_transcoder_disabled
argument_list|(
name|dev_priv
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pll
operator|->
name|pll_reg
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|DPLL_VCO_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|pll
operator|->
name|on
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_enable_pch_transcoder
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|dev_priv
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|pipe
index|]
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|val
decl_stmt|,
name|pipeconf_val
decl_stmt|;
comment|/* PCH only available on ILK+ */
name|BUG_ON
argument_list|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|<
literal|5
argument_list|)
expr_stmt|;
comment|/* Make sure PCH DPLL is enabled */
name|assert_pch_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|pch_pll
argument_list|,
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FDI must be feeding us bits for PCH ports */
name|assert_fdi_tx_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|assert_fdi_rx_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* Workaround: Set the timing override bit before enabling the 		 * pch transcoder. */
name|reg
operator|=
name|TRANS_CHICKEN2
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator||=
name|TRANS_CHICKEN2_TIMING_OVERRIDE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|TRANSCONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|pipeconf_val
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
comment|/* 		 * make the BPC in transcoder be consistent with 		 * that in pipeconf reg. 		 */
name|val
operator|&=
operator|~
name|PIPE_BPC_MASK
expr_stmt|;
name|val
operator||=
name|pipeconf_val
operator|&
name|PIPE_BPC_MASK
expr_stmt|;
block|}
name|val
operator|&=
operator|~
name|TRANS_INTERLACE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|pipeconf_val
operator|&
name|PIPECONF_INTERLACE_MASK
operator|)
operator|==
name|PIPECONF_INTERLACED_ILK
condition|)
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
operator|&&
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_SDVO
argument_list|)
condition|)
name|val
operator||=
name|TRANS_LEGACY_INTERLACED_ILK
expr_stmt|;
else|else
name|val
operator||=
name|TRANS_INTERLACED
expr_stmt|;
else|else
name|val
operator||=
name|TRANS_PROGRESSIVE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator||
name|TRANS_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|TRANS_STATE_ENABLE
argument_list|,
literal|100
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to enable transcoder %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lpt_enable_pch_transcoder
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|transcoder
name|cpu_transcoder
parameter_list|)
block|{
name|u32
name|val
decl_stmt|,
name|pipeconf_val
decl_stmt|;
comment|/* PCH only available on ILK+ */
name|BUG_ON
argument_list|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|<
literal|5
argument_list|)
expr_stmt|;
comment|/* FDI must be feeding us bits for PCH ports */
name|assert_fdi_tx_enabled
argument_list|(
name|dev_priv
argument_list|,
operator|(
expr|enum
name|pipe
operator|)
name|cpu_transcoder
argument_list|)
expr_stmt|;
name|assert_fdi_rx_enabled
argument_list|(
name|dev_priv
argument_list|,
operator|(
expr|enum
name|pipe
operator|)
name|TRANSCODER_A
argument_list|)
expr_stmt|;
comment|/* Workaround: set timing override bit. */
name|val
operator|=
name|I915_READ
argument_list|(
name|_TRANSA_CHICKEN2
argument_list|)
expr_stmt|;
name|val
operator||=
name|TRANS_CHICKEN2_TIMING_OVERRIDE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_TRANSA_CHICKEN2
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|TRANS_ENABLE
expr_stmt|;
name|pipeconf_val
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pipeconf_val
operator|&
name|PIPECONF_INTERLACE_MASK_HSW
operator|)
operator|==
name|PIPECONF_INTERLACED_ILK
condition|)
name|val
operator||=
name|TRANS_INTERLACED
expr_stmt|;
else|else
name|val
operator||=
name|TRANS_PROGRESSIVE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSCONF
argument_list|(
name|TRANSCODER_A
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
name|I915_READ
argument_list|(
name|_TRANSACONF
argument_list|)
operator|&
name|TRANS_STATE_ENABLE
argument_list|,
literal|100
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"Failed to enable PCH transcoder\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_disable_pch_transcoder
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|dev_priv
operator|->
name|dev
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|val
decl_stmt|;
comment|/* FDI relies on the transcoder */
name|assert_fdi_tx_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|assert_fdi_rx_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* Ports must be off as well */
name|assert_pch_ports_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|TRANSCONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|TRANS_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* wait for PCH transcoder off, transcoder state */
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|TRANS_STATE_ENABLE
operator|)
operator|==
literal|0
argument_list|,
literal|50
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to disable transcoder %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* Workaround: Clear the timing override chicken bit again. */
name|reg
operator|=
name|TRANS_CHICKEN2
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|TRANS_CHICKEN2_TIMING_OVERRIDE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lpt_disable_pch_transcoder
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|_TRANSACONF
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|TRANS_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_TRANSACONF
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* wait for PCH transcoder off, transcoder state */
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|_TRANSACONF
argument_list|)
operator|&
name|TRANS_STATE_ENABLE
operator|)
operator|==
literal|0
argument_list|,
literal|50
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"Failed to disable PCH transcoder\n"
argument_list|)
expr_stmt|;
comment|/* Workaround: clear timing override bit. */
name|val
operator|=
name|I915_READ
argument_list|(
name|_TRANSA_CHICKEN2
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|TRANS_CHICKEN2_TIMING_OVERRIDE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_TRANSA_CHICKEN2
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_enable_pipe - enable a pipe, asserting requirements  * @dev_priv: i915 private structure  * @pipe: pipe to enable  * @pch_port: on ILK+, is this pipe driving a PCH port or not  *  * Enable @pipe, making sure that various hardware specific requirements  * are met, if applicable, e.g. PLL enabled, LVDS pairs enabled, etc.  *  * @pipe should be %PIPE_A or %PIPE_B.  *  * Will wait until the pipe is actually running (i.e. first vblank) before  * returning.  */
end_comment

begin_function
specifier|static
name|void
name|intel_enable_pipe
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|pch_port
parameter_list|)
block|{
name|enum
name|transcoder
name|cpu_transcoder
init|=
name|intel_pipe_to_cpu_transcoder
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
decl_stmt|;
name|enum
name|transcoder
name|pch_transcoder
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
name|pch_transcoder
operator|=
name|TRANSCODER_A
expr_stmt|;
else|else
name|pch_transcoder
operator|=
operator|(
expr|enum
name|transcoder
operator|)
name|pipe
expr_stmt|;
comment|/* 	 * A pipe without a PLL won't actually be able to drive bits from 	 * a plane.  On ILK+ the pipe PLLs are integrated, so we don't 	 * need the check. 	 */
if|if
condition|(
operator|!
name|HAS_PCH_SPLIT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
name|assert_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pch_port
condition|)
block|{
comment|/* if driving the PCH, we need FDI enabled */
name|assert_fdi_rx_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
operator|(
expr|enum
name|pipe
operator|)
name|pch_transcoder
argument_list|)
expr_stmt|;
name|assert_fdi_tx_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
operator|(
expr|enum
name|pipe
operator|)
name|cpu_transcoder
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: assert CPU port conditions for SNB+ */
block|}
name|reg
operator|=
name|PIPECONF
argument_list|(
name|cpu_transcoder
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PIPECONF_ENABLE
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator||
name|PIPECONF_ENABLE
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_disable_pipe - disable a pipe, asserting requirements  * @dev_priv: i915 private structure  * @pipe: pipe to disable  *  * Disable @pipe, making sure that various hardware specific requirements  * are met, if applicable, e.g. plane disabled, panel fitter off, etc.  *  * @pipe should be %PIPE_A or %PIPE_B.  *  * Will wait until the pipe has shut down before returning.  */
end_comment

begin_function
specifier|static
name|void
name|intel_disable_pipe
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|enum
name|transcoder
name|cpu_transcoder
init|=
name|intel_pipe_to_cpu_transcoder
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* 	 * Make sure planes won't keep trying to pump pixels to us, 	 * or we might hang the display. 	 */
name|assert_planes_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* Don't disable pipe A or pipe A PLLs if needed */
if|if
condition|(
name|pipe
operator|==
name|PIPE_A
operator|&&
operator|(
name|dev_priv
operator|->
name|quirks
operator|&
name|QUIRK_PIPEA_FORCE
operator|)
condition|)
return|return;
name|reg
operator|=
name|PIPECONF
argument_list|(
name|cpu_transcoder
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PIPECONF_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator|&
operator|~
name|PIPECONF_ENABLE
argument_list|)
expr_stmt|;
name|intel_wait_for_pipe_off
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Plane regs are double buffered, going from enabled->disabled needs a  * trigger in order to latch.  The display address reg provides this.  */
end_comment

begin_function
name|void
name|intel_flush_display_plane
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|plane
name|plane
parameter_list|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|>=
literal|4
condition|)
name|I915_WRITE
argument_list|(
name|DSPSURF
argument_list|(
name|plane
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|DSPSURF
argument_list|(
name|plane
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|I915_WRITE
argument_list|(
name|DSPADDR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|DSPADDR
argument_list|(
name|plane
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_enable_plane - enable a display plane on a given pipe  * @dev_priv: i915 private structure  * @plane: plane to enable  * @pipe: pipe being fed  *  * Enable @plane on @pipe, making sure that @pipe is running first.  */
end_comment

begin_function
specifier|static
name|void
name|intel_enable_plane
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|plane
name|plane
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* If the pipe isn't enabled, we can't pump pixels and may hang */
name|assert_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator||
name|DISPLAY_PLANE_ENABLE
argument_list|)
expr_stmt|;
name|intel_flush_display_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_disable_plane - disable a display plane  * @dev_priv: i915 private structure  * @plane: plane to disable  * @pipe: pipe consuming the data  *  * Disable @plane; should be an independent operation.  */
end_comment

begin_function
specifier|static
name|void
name|intel_disable_plane
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|plane
name|plane
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator|&
operator|~
name|DISPLAY_PLANE_ENABLE
argument_list|)
expr_stmt|;
name|intel_flush_display_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|intel_pin_and_fence_fb_obj
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|pipelined
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|alignment
decl_stmt|;
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|obj
operator|->
name|tiling_mode
condition|)
block|{
case|case
name|I915_TILING_NONE
case|:
if|if
condition|(
name|IS_BROADWATER
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_CRESTLINE
argument_list|(
name|dev
argument_list|)
condition|)
name|alignment
operator|=
literal|128
operator|*
literal|1024
expr_stmt|;
elseif|else
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
name|alignment
operator|=
literal|4
operator|*
literal|1024
expr_stmt|;
else|else
name|alignment
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
break|break;
case|case
name|I915_TILING_X
case|:
comment|/* pin() will align the object as required by fence */
name|alignment
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|I915_TILING_Y
case|:
comment|/* FIXME: Is this true? */
name|DRM_ERROR
argument_list|(
literal|"Y tiled not allowed for scan out buffers\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
default|default:
name|BUG
argument_list|()
expr_stmt|;
block|}
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|false
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_pin_to_display_plane
argument_list|(
name|obj
argument_list|,
name|alignment
argument_list|,
name|pipelined
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_interruptible
goto|;
comment|/* Install a fence for tiled scan-out. Pre-i965 always needs a 	 * fence, whereas 965+ only requires a fence if using 	 * framebuffer compression.  For simplicity, we always install 	 * a fence as the cost is not that onerous. 	 */
name|ret
operator|=
name|i915_gem_object_get_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin
goto|;
name|i915_gem_object_pin_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin
label|:
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|err_interruptible
label|:
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|true
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|intel_unpin_fb_obj
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|i915_gem_object_unpin_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Computes the linear offset to the base tile and adjusts x, y. bytes per pixel  * is assumed to be a power-of-two. */
end_comment

begin_function
name|unsigned
name|long
name|intel_gen4_compute_page_offset
parameter_list|(
name|int
modifier|*
name|x
parameter_list|,
name|int
modifier|*
name|y
parameter_list|,
name|unsigned
name|int
name|tiling_mode
parameter_list|,
name|unsigned
name|int
name|cpp
parameter_list|,
name|unsigned
name|int
name|pitch
parameter_list|)
block|{
if|if
condition|(
name|tiling_mode
operator|!=
name|I915_TILING_NONE
condition|)
block|{
name|unsigned
name|int
name|tile_rows
decl_stmt|,
name|tiles
decl_stmt|;
name|tile_rows
operator|=
operator|*
name|y
operator|/
literal|8
expr_stmt|;
operator|*
name|y
operator|%=
literal|8
expr_stmt|;
name|tiles
operator|=
operator|*
name|x
operator|/
operator|(
literal|512
operator|/
name|cpp
operator|)
expr_stmt|;
operator|*
name|x
operator|%=
literal|512
operator|/
name|cpp
expr_stmt|;
return|return
name|tile_rows
operator|*
name|pitch
operator|*
literal|8
operator|+
name|tiles
operator|*
literal|4096
return|;
block|}
else|else
block|{
name|unsigned
name|int
name|offset
decl_stmt|;
name|offset
operator|=
operator|*
name|y
operator|*
name|pitch
operator|+
operator|*
name|x
operator|*
name|cpp
expr_stmt|;
operator|*
name|y
operator|=
literal|0
expr_stmt|;
operator|*
name|x
operator|=
operator|(
name|offset
operator|&
literal|4095
operator|)
operator|/
name|cpp
expr_stmt|;
return|return
name|offset
operator|&
operator|-
literal|4096
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|i9xx_update_plane
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|unsigned
name|long
name|linear_offset
decl_stmt|;
name|u32
name|dspcntr
decl_stmt|;
name|u32
name|reg
decl_stmt|;
switch|switch
condition|(
name|plane
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Can't update plane %d in SAREA\n"
argument_list|,
name|plane
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|obj
operator|=
name|intel_fb
operator|->
name|obj
expr_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|dspcntr
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* Mask out pixel format bits in case we change it */
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_PIXFORMAT_MASK
expr_stmt|;
switch|switch
condition|(
name|fb
operator|->
name|pixel_format
condition|)
block|{
case|case
name|DRM_FORMAT_C8
case|:
name|dspcntr
operator||=
name|DISPPLANE_8BPP
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_XRGB1555
case|:
case|case
name|DRM_FORMAT_ARGB1555
case|:
name|dspcntr
operator||=
name|DISPPLANE_BGRX555
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_RGB565
case|:
name|dspcntr
operator||=
name|DISPPLANE_BGRX565
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_XRGB8888
case|:
case|case
name|DRM_FORMAT_ARGB8888
case|:
name|dspcntr
operator||=
name|DISPPLANE_BGRX888
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_XBGR8888
case|:
case|case
name|DRM_FORMAT_ABGR8888
case|:
name|dspcntr
operator||=
name|DISPPLANE_RGBX888
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_XRGB2101010
case|:
case|case
name|DRM_FORMAT_ARGB2101010
case|:
name|dspcntr
operator||=
name|DISPPLANE_BGRX101010
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_XBGR2101010
case|:
case|case
name|DRM_FORMAT_ABGR2101010
case|:
name|dspcntr
operator||=
name|DISPPLANE_RGBX101010
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown pixel format 0x%08x\n"
argument_list|,
name|fb
operator|->
name|pixel_format
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
condition|)
name|dspcntr
operator||=
name|DISPPLANE_TILED
expr_stmt|;
else|else
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_TILED
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|dspcntr
argument_list|)
expr_stmt|;
name|linear_offset
operator|=
name|y
operator|*
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|+
name|x
operator|*
operator|(
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|intel_crtc
operator|->
name|dspaddr_offset
operator|=
name|intel_gen4_compute_page_offset
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|obj
operator|->
name|tiling_mode
argument_list|,
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|linear_offset
operator|-=
name|intel_crtc
operator|->
name|dspaddr_offset
expr_stmt|;
block|}
else|else
block|{
name|intel_crtc
operator|->
name|dspaddr_offset
operator|=
name|linear_offset
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"Writing base %08X %08lX %d %d %d\n"
argument_list|,
name|obj
operator|->
name|gtt_offset
argument_list|,
name|linear_offset
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPSTRIDE
argument_list|(
name|plane
argument_list|)
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|I915_MODIFY_DISPBASE
argument_list|(
name|DSPSURF
argument_list|(
name|plane
argument_list|)
argument_list|,
name|obj
operator|->
name|gtt_offset
operator|+
name|intel_crtc
operator|->
name|dspaddr_offset
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPTILEOFF
argument_list|(
name|plane
argument_list|)
argument_list|,
operator|(
name|y
operator|<<
literal|16
operator|)
operator||
name|x
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPLINOFF
argument_list|(
name|plane
argument_list|)
argument_list|,
name|linear_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|I915_WRITE
argument_list|(
name|DSPADDR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|obj
operator|->
name|gtt_offset
operator|+
name|linear_offset
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ironlake_update_plane
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|unsigned
name|long
name|linear_offset
decl_stmt|;
name|u32
name|dspcntr
decl_stmt|;
name|u32
name|reg
decl_stmt|;
switch|switch
condition|(
name|plane
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Can't update plane %d in SAREA\n"
argument_list|,
name|plane
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|obj
operator|=
name|intel_fb
operator|->
name|obj
expr_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|dspcntr
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* Mask out pixel format bits in case we change it */
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_PIXFORMAT_MASK
expr_stmt|;
switch|switch
condition|(
name|fb
operator|->
name|pixel_format
condition|)
block|{
case|case
name|DRM_FORMAT_C8
case|:
name|dspcntr
operator||=
name|DISPPLANE_8BPP
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_RGB565
case|:
name|dspcntr
operator||=
name|DISPPLANE_BGRX565
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_XRGB8888
case|:
case|case
name|DRM_FORMAT_ARGB8888
case|:
name|dspcntr
operator||=
name|DISPPLANE_BGRX888
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_XBGR8888
case|:
case|case
name|DRM_FORMAT_ABGR8888
case|:
name|dspcntr
operator||=
name|DISPPLANE_RGBX888
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_XRGB2101010
case|:
case|case
name|DRM_FORMAT_ARGB2101010
case|:
name|dspcntr
operator||=
name|DISPPLANE_BGRX101010
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_XBGR2101010
case|:
case|case
name|DRM_FORMAT_ABGR2101010
case|:
name|dspcntr
operator||=
name|DISPPLANE_RGBX101010
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown pixel format 0x%08x\n"
argument_list|,
name|fb
operator|->
name|pixel_format
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
condition|)
name|dspcntr
operator||=
name|DISPPLANE_TILED
expr_stmt|;
else|else
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_TILED
expr_stmt|;
comment|/* must disable */
name|dspcntr
operator||=
name|DISPPLANE_TRICKLE_FEED_DISABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|dspcntr
argument_list|)
expr_stmt|;
name|linear_offset
operator|=
name|y
operator|*
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|+
name|x
operator|*
operator|(
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
operator|)
expr_stmt|;
name|intel_crtc
operator|->
name|dspaddr_offset
operator|=
name|intel_gen4_compute_page_offset
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|obj
operator|->
name|tiling_mode
argument_list|,
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|linear_offset
operator|-=
name|intel_crtc
operator|->
name|dspaddr_offset
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Writing base %08X %08lX %d %d %d\n"
argument_list|,
name|obj
operator|->
name|gtt_offset
argument_list|,
name|linear_offset
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPSTRIDE
argument_list|(
name|plane
argument_list|)
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|I915_MODIFY_DISPBASE
argument_list|(
name|DSPSURF
argument_list|(
name|plane
argument_list|)
argument_list|,
name|obj
operator|->
name|gtt_offset
operator|+
name|intel_crtc
operator|->
name|dspaddr_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|DSPOFFSET
argument_list|(
name|plane
argument_list|)
argument_list|,
operator|(
name|y
operator|<<
literal|16
operator|)
operator||
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|I915_WRITE
argument_list|(
name|DSPTILEOFF
argument_list|(
name|plane
argument_list|)
argument_list|,
operator|(
name|y
operator|<<
literal|16
operator|)
operator||
name|x
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPLINOFF
argument_list|(
name|plane
argument_list|)
argument_list|,
name|linear_offset
argument_list|)
expr_stmt|;
block|}
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Assume fb object is pinned& idle& fenced and just update base pointers */
end_comment

begin_function
specifier|static
name|int
name|intel_pipe_set_base_atomic
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|enum
name|mode_set_atomic
name|state
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|display
operator|.
name|disable_fbc
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_increase_pllclock
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
return|return
name|dev_priv
operator|->
name|display
operator|.
name|update_plane
argument_list|(
name|crtc
argument_list|,
name|fb
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_finish_fb
parameter_list|(
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|to_intel_framebuffer
argument_list|(
name|old_fb
argument_list|)
operator|->
name|obj
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|bool
name|was_interruptible
init|=
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|atomic_read
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
operator|||
name|atomic_read
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|msleep
argument_list|(
operator|&
name|dev_priv
operator|->
name|pending_flip_queue
argument_list|,
operator|&
name|dev
operator|->
name|event_lock
argument_list|,
literal|0
argument_list|,
literal|"915flp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
comment|/* Big Hammer, we also need to ensure that any pending 	 * MI_WAIT_FOR_EVENT inside a user batch buffer on the 	 * current scanout is retired before unpinning the old 	 * framebuffer. 	 * 	 * This should only fail upon a hung GPU, in which case we 	 * can safely continue. 	 */
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|false
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_finish_gpu
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|was_interruptible
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_update_sarea_pos
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_master_private
modifier|*
name|master_priv
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|primary
operator|->
name|master
condition|)
return|return;
name|master_priv
operator|=
name|dev
operator|->
name|primary
operator|->
name|master
operator|->
name|driver_priv
expr_stmt|;
if|if
condition|(
operator|!
name|master_priv
operator|->
name|sarea_priv
condition|)
return|return;
switch|switch
condition|(
name|intel_crtc
operator|->
name|pipe
condition|)
block|{
case|case
literal|0
case|:
name|master_priv
operator|->
name|sarea_priv
operator|->
name|pipeA_x
operator|=
name|x
expr_stmt|;
name|master_priv
operator|->
name|sarea_priv
operator|->
name|pipeA_y
operator|=
name|y
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|master_priv
operator|->
name|sarea_priv
operator|->
name|pipeB_x
operator|=
name|x
expr_stmt|;
name|master_priv
operator|->
name|sarea_priv
operator|->
name|pipeB_y
operator|=
name|y
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|intel_pipe_set_base
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* no fb bound */
if|if
condition|(
operator|!
name|fb
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"No FB bound\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|intel_crtc
operator|->
name|plane
operator|>
name|dev_priv
operator|->
name|num_pipe
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"no plane for crtc: plane %d, num_pipes %d\n"
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|,
name|dev_priv
operator|->
name|num_pipe
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
operator|->
name|obj
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"pin& fence failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|crtc
operator|->
name|fb
condition|)
name|intel_finish_fb
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dev_priv
operator|->
name|display
operator|.
name|update_plane
argument_list|(
name|crtc
argument_list|,
name|fb
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|intel_unpin_fb_obj
argument_list|(
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
operator|->
name|obj
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"failed to update base address\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|old_fb
operator|=
name|crtc
operator|->
name|fb
expr_stmt|;
name|crtc
operator|->
name|fb
operator|=
name|fb
expr_stmt|;
name|crtc
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|crtc
operator|->
name|y
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|old_fb
condition|)
block|{
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|intel_unpin_fb_obj
argument_list|(
name|to_intel_framebuffer
argument_list|(
name|old_fb
argument_list|)
operator|->
name|obj
argument_list|)
expr_stmt|;
block|}
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_crtc_update_sarea_pos
argument_list|(
name|crtc
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_set_pll_edp
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|dpa_ctl
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"eDP PLL enable for clock %d\n"
argument_list|,
name|clock
argument_list|)
expr_stmt|;
name|dpa_ctl
operator|=
name|I915_READ
argument_list|(
name|DP_A
argument_list|)
expr_stmt|;
name|dpa_ctl
operator|&=
operator|~
name|DP_PLL_FREQ_MASK
expr_stmt|;
if|if
condition|(
name|clock
operator|<
literal|200000
condition|)
block|{
name|u32
name|temp
decl_stmt|;
name|dpa_ctl
operator||=
name|DP_PLL_FREQ_160MHZ
expr_stmt|;
comment|/* workaround for 160Mhz: 		   1) program 0x4600c bits 15:0 = 0x8124 		   2) program 0x46010 bit 0 = 1 		   3) program 0x46034 bit 24 = 1 		   4) program 0x64000 bit 14 = 1 		   */
name|temp
operator|=
name|I915_READ
argument_list|(
literal|0x4600c
argument_list|)
expr_stmt|;
name|temp
operator|&=
literal|0xffff0000
expr_stmt|;
name|I915_WRITE
argument_list|(
literal|0x4600c
argument_list|,
name|temp
operator||
literal|0x8124
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
literal|0x46010
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
literal|0x46010
argument_list|,
name|temp
operator||
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
literal|0x46034
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
literal|0x46034
argument_list|,
name|temp
operator||
operator|(
literal|1
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dpa_ctl
operator||=
name|DP_PLL_FREQ_270MHZ
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|DP_A
argument_list|,
name|dpa_ctl
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DP_A
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_fdi_normal_train
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
comment|/* enable normal train */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE_IVB
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_NONE_IVB
operator||
name|FDI_TX_ENHANCE_FRAME_ENABLE
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_NONE
operator||
name|FDI_TX_ENHANCE_FRAME_ENABLE
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_NORMAL_CPT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_ENHANCE_FRAME_ENABLE
argument_list|)
expr_stmt|;
comment|/* wait one idle pattern time */
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* IVB wants error correction enabled */
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator||
name|FDI_FS_ERRC_ENABLE
operator||
name|FDI_FE_ERRC_ENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ivb_modeset_global_resources
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|pipe_B_crtc
init|=
name|to_intel_crtc
argument_list|(
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|PIPE_B
index|]
argument_list|)
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|pipe_C_crtc
init|=
name|to_intel_crtc
argument_list|(
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|PIPE_C
index|]
argument_list|)
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
comment|/* When everything is off disable fdi C so that we could enable fdi B 	 * with all lanes. XXX: This misses the case where a pipe is not using 	 * any pch resources and so doesn't need any fdi lanes. */
if|if
condition|(
operator|!
name|pipe_B_crtc
operator|->
name|base
operator|.
name|enabled
operator|&&
operator|!
name|pipe_C_crtc
operator|->
name|base
operator|.
name|enabled
condition|)
block|{
name|WARN_ON
argument_list|(
name|I915_READ
argument_list|(
name|FDI_RX_CTL
argument_list|(
name|PIPE_B
argument_list|)
argument_list|)
operator|&
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
name|I915_READ
argument_list|(
name|FDI_RX_CTL
argument_list|(
name|PIPE_C
argument_list|)
argument_list|)
operator|&
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|SOUTH_CHICKEN1
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_BC_BIFURCATION_SELECT
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabling fdi C rx\n"
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SOUTH_CHICKEN1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The FDI link training functions for ILK/Ibexpeak. */
end_comment

begin_function
specifier|static
name|void
name|ironlake_fdi_link_train
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|,
name|tries
decl_stmt|;
comment|/* FDI needs bits from pipe& plane first */
name|assert_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|assert_plane_enabled
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|)
expr_stmt|;
comment|/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit 	   for train result */
name|reg
operator|=
name|FDI_RX_IMR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_SYMBOL_LOCK
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_BIT_LOCK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* enable CPU FDI TX and PCH FDI RX */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|19
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|-
literal|1
operator|)
operator|<<
literal|19
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_TX_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* Ironlake workaround, enable clock pointer after FDI enable*/
name|I915_WRITE
argument_list|(
name|FDI_RX_CHICKEN
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|FDI_RX_PHASE_SYNC_POINTER_OVR
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FDI_RX_CHICKEN
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|FDI_RX_PHASE_SYNC_POINTER_OVR
operator||
name|FDI_RX_PHASE_SYNC_POINTER_EN
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
literal|5
condition|;
name|tries
operator|++
control|)
block|{
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|&
name|FDI_RX_BIT_LOCK
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 1 done.\n"
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_BIT_LOCK
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tries
operator|==
literal|5
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 1 fail!\n"
argument_list|)
expr_stmt|;
comment|/* Train 2 */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
literal|5
condition|;
name|tries
operator|++
control|)
block|{
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_SYMBOL_LOCK
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_SYMBOL_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 2 done.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tries
operator|==
literal|5
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 2 fail!\n"
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train done\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|int
name|snb_b_fdi_train_param
index|[]
init|=
block|{
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
block|,
name|FDI_LINK_TRAIN_400MV_6DB_SNB_B
block|,
name|FDI_LINK_TRAIN_600MV_3_5DB_SNB_B
block|,
name|FDI_LINK_TRAIN_800MV_0DB_SNB_B
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The FDI link training functions for SNB/Cougarpoint. */
end_comment

begin_function
specifier|static
name|void
name|gen6_fdi_link_train
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|,
name|i
decl_stmt|,
name|retry
decl_stmt|;
comment|/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit 	   for train result */
name|reg
operator|=
name|FDI_RX_IMR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_SYMBOL_LOCK
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_BIT_LOCK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* enable CPU FDI TX and PCH FDI RX */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|19
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|-
literal|1
operator|)
operator|<<
literal|19
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
comment|/* SNB-B */
name|temp
operator||=
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_TX_ENABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FDI_RX_MISC
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|FDI_RX_TP1_TO_TP2_48
operator||
name|FDI_RX_FDI_DELAY_90
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1_CPT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|snb_b_fdi_train_param
index|[
name|i
index|]
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|500
argument_list|)
expr_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
literal|5
condition|;
name|retry
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_BIT_LOCK
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_BIT_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 1 done.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|udelay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retry
operator|<
literal|5
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 1 fail!\n"
argument_list|)
expr_stmt|;
comment|/* Train 2 */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2
expr_stmt|;
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
comment|/* SNB-B */
name|temp
operator||=
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2_CPT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|snb_b_fdi_train_param
index|[
name|i
index|]
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|500
argument_list|)
expr_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
literal|5
condition|;
name|retry
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_SYMBOL_LOCK
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_SYMBOL_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 2 done.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|udelay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retry
operator|<
literal|5
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 2 fail!\n"
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Manual link training for Ivy Bridge A0 parts */
end_comment

begin_function
specifier|static
name|void
name|ivb_manual_fdi_link_train
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|,
name|i
decl_stmt|;
comment|/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit 	   for train result */
name|reg
operator|=
name|FDI_RX_IMR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_SYMBOL_LOCK
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_BIT_LOCK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR before link train 0x%x\n"
argument_list|,
name|I915_READ
argument_list|(
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* enable CPU FDI TX and PCH FDI RX */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|19
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|-
literal|1
operator|)
operator|<<
literal|19
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|FDI_LINK_TRAIN_AUTO
operator||
name|FDI_LINK_TRAIN_NONE_IVB
operator|)
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1_IVB
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
expr_stmt|;
name|temp
operator||=
name|FDI_COMPOSITE_SYNC
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_TX_ENABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FDI_RX_MISC
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|FDI_RX_TP1_TO_TP2_48
operator||
name|FDI_RX_FDI_DELAY_90
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_AUTO
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_COMPOSITE_SYNC
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|snb_b_fdi_train_param
index|[
name|i
index|]
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_BIT_LOCK
operator|||
operator|(
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|FDI_RX_BIT_LOCK
operator|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_BIT_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 1 done, level %i.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 1 fail!\n"
argument_list|)
expr_stmt|;
comment|/* Train 2 */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE_IVB
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2_IVB
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2_CPT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|snb_b_fdi_train_param
index|[
name|i
index|]
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_SYMBOL_LOCK
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_SYMBOL_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 2 done, level %i.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 2 fail!\n"
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_fdi_pll_enable
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_crtc
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
comment|/* enable PCH FDI RX PLL, wait warmup plus DMI latency */
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
operator|(
literal|0x7
operator|<<
literal|19
operator|)
operator||
operator|(
literal|0x7
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|-
literal|1
operator|)
operator|<<
literal|19
expr_stmt|;
name|temp
operator||=
operator|(
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|PIPE_BPC_MASK
operator|)
operator|<<
literal|11
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_PLL_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Switch from Rawclk to PCDclk */
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_PCDCLK
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* On Haswell, the PLL configuration for ports and pipes is handled 	 * separately, as part of DDI setup */
if|if
condition|(
operator|!
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* Enable CPU FDI TX PLL, always on for Ironlake */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|&
name|FDI_TX_PLL_ENABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_TX_PLL_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_fdi_pll_disable
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_crtc
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
comment|/* Switch from PCDclk to Rawclk */
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_PCDCLK
argument_list|)
expr_stmt|;
comment|/* Disable CPU FDI TX PLL */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_TX_PLL_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_RX_PLL_ENABLE
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to turn off. */
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_fdi_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
comment|/* disable CPU FDI tx and PCH FDI rx */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_TX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
literal|0x7
operator|<<
literal|16
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|PIPE_BPC_MASK
operator|)
operator|<<
literal|11
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Ironlake workaround, disable clock pointer after downing FDI */
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|FDI_RX_CHICKEN
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|FDI_RX_PHASE_SYNC_POINTER_OVR
argument_list|)
expr_stmt|;
block|}
comment|/* still set train pattern 1 */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1_CPT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
block|}
comment|/* BPC in FDI rx is consistent with that in PIPECONF */
name|temp
operator|&=
operator|~
operator|(
literal|0x07
operator|<<
literal|16
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|PIPE_BPC_MASK
operator|)
operator|<<
literal|11
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_crtc_has_pending_flip
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|bool
name|pending
decl_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* 	 * NOTE Linux<->FreeBSD dev->event_lock is already locked in 	 * intel_crtc_wait_for_pending_flips(). 	 */
name|pending
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|unpin_work
operator|!=
name|NULL
expr_stmt|;
return|return
name|pending
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_wait_for_pending_flips
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|crtc
operator|->
name|fb
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|intel_crtc_has_pending_flip
argument_list|(
name|crtc
argument_list|)
condition|)
block|{
name|msleep
argument_list|(
operator|&
name|dev_priv
operator|->
name|pending_flip_queue
argument_list|,
operator|&
name|dev
operator|->
name|event_lock
argument_list|,
literal|0
argument_list|,
literal|"915flp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_finish_fb
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ironlake_crtc_driving_pch
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
decl_stmt|;
comment|/* 	 * If there's a non-PCH eDP on this crtc, it must be DP_A, and that 	 * must be driven by its own crtc; no sharing is possible. 	 */
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|intel_encoder
argument_list|)
block|{
switch|switch
condition|(
name|intel_encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_EDP
case|:
if|if
condition|(
operator|!
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|intel_encoder
operator|->
name|base
argument_list|)
condition|)
return|return
name|false
return|;
continue|continue;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|haswell_crtc_driving_pch
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
return|return
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_ANALOG
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Program iCLKIP clock to the desired frequency */
end_comment

begin_function
specifier|static
name|void
name|lpt_program_iclkip
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|divsel
decl_stmt|,
name|phaseinc
decl_stmt|,
name|auxdiv
decl_stmt|,
name|phasedir
init|=
literal|0
decl_stmt|;
name|u32
name|temp
decl_stmt|;
comment|/* It is necessary to ungate the pixclk gate prior to programming 	 * the divisors, and gate it back when it is done. 	 */
name|I915_WRITE
argument_list|(
name|PIXCLK_GATE
argument_list|,
name|PIXCLK_GATE_GATE
argument_list|)
expr_stmt|;
comment|/* Disable SSCCTL */
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCCTL6
argument_list|,
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCCTL6
argument_list|,
name|SBI_ICLK
argument_list|)
operator||
name|SBI_SSCCTL_DISABLE
argument_list|,
name|SBI_ICLK
argument_list|)
expr_stmt|;
comment|/* 20MHz is a corner case which is out of range for the 7-bit divisor */
if|if
condition|(
name|crtc
operator|->
name|mode
operator|.
name|clock
operator|==
literal|20000
condition|)
block|{
name|auxdiv
operator|=
literal|1
expr_stmt|;
name|divsel
operator|=
literal|0x41
expr_stmt|;
name|phaseinc
operator|=
literal|0x20
expr_stmt|;
block|}
else|else
block|{
comment|/* The iCLK virtual clock root frequency is in MHz, 		 * but the crtc->mode.clock in in KHz. To get the divisors, 		 * it is necessary to divide one by another, so we 		 * convert the virtual clock precision to KHz here for higher 		 * precision. 		 */
name|u32
name|iclk_virtual_root_freq
init|=
literal|172800
operator|*
literal|1000
decl_stmt|;
name|u32
name|iclk_pi_range
init|=
literal|64
decl_stmt|;
name|u32
name|desired_divisor
decl_stmt|,
name|msb_divisor_value
decl_stmt|,
name|pi_value
decl_stmt|;
name|desired_divisor
operator|=
operator|(
name|iclk_virtual_root_freq
operator|/
name|crtc
operator|->
name|mode
operator|.
name|clock
operator|)
expr_stmt|;
name|msb_divisor_value
operator|=
name|desired_divisor
operator|/
name|iclk_pi_range
expr_stmt|;
name|pi_value
operator|=
name|desired_divisor
operator|%
name|iclk_pi_range
expr_stmt|;
name|auxdiv
operator|=
literal|0
expr_stmt|;
name|divsel
operator|=
name|msb_divisor_value
operator|-
literal|2
expr_stmt|;
name|phaseinc
operator|=
name|pi_value
expr_stmt|;
block|}
comment|/* This should not happen with any sane values */
name|WARN_ON
argument_list|(
name|SBI_SSCDIVINTPHASE_DIVSEL
argument_list|(
name|divsel
argument_list|)
operator|&
operator|~
name|SBI_SSCDIVINTPHASE_DIVSEL_MASK
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
name|SBI_SSCDIVINTPHASE_DIR
argument_list|(
name|phasedir
argument_list|)
operator|&
operator|~
name|SBI_SSCDIVINTPHASE_INCVAL_MASK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"iCLKIP clock: found settings for %dKHz refresh rate: auxdiv=%x, divsel=%x, phasedir=%x, phaseinc=%x\n"
argument_list|,
name|crtc
operator|->
name|mode
operator|.
name|clock
argument_list|,
name|auxdiv
argument_list|,
name|divsel
argument_list|,
name|phasedir
argument_list|,
name|phaseinc
argument_list|)
expr_stmt|;
comment|/* Program SSCDIVINTPHASE6 */
name|temp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCDIVINTPHASE6
argument_list|,
name|SBI_ICLK
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|SBI_SSCDIVINTPHASE_DIVSEL_MASK
expr_stmt|;
name|temp
operator||=
name|SBI_SSCDIVINTPHASE_DIVSEL
argument_list|(
name|divsel
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|SBI_SSCDIVINTPHASE_INCVAL_MASK
expr_stmt|;
name|temp
operator||=
name|SBI_SSCDIVINTPHASE_INCVAL
argument_list|(
name|phaseinc
argument_list|)
expr_stmt|;
name|temp
operator||=
name|SBI_SSCDIVINTPHASE_DIR
argument_list|(
name|phasedir
argument_list|)
expr_stmt|;
name|temp
operator||=
name|SBI_SSCDIVINTPHASE_PROPAGATE
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCDIVINTPHASE6
argument_list|,
name|temp
argument_list|,
name|SBI_ICLK
argument_list|)
expr_stmt|;
comment|/* Program SSCAUXDIV */
name|temp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCAUXDIV6
argument_list|,
name|SBI_ICLK
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|SBI_SSCAUXDIV_FINALDIV2SEL
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|temp
operator||=
name|SBI_SSCAUXDIV_FINALDIV2SEL
argument_list|(
name|auxdiv
argument_list|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCAUXDIV6
argument_list|,
name|temp
argument_list|,
name|SBI_ICLK
argument_list|)
expr_stmt|;
comment|/* Enable modulator and associated divider */
name|temp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCCTL6
argument_list|,
name|SBI_ICLK
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|SBI_SSCCTL_DISABLE
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCCTL6
argument_list|,
name|temp
argument_list|,
name|SBI_ICLK
argument_list|)
expr_stmt|;
comment|/* Wait for initialization time */
name|udelay
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIXCLK_GATE
argument_list|,
name|PIXCLK_GATE_UNGATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable PCH resources required for PCH ports:  *   - PCH PLLs  *   - FDI training& RX/TX  *   - update transcoder timings  *   - DP transcoding bits  *   - transcoder  */
end_comment

begin_function
specifier|static
name|void
name|ironlake_pch_enable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
name|assert_transcoder_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* Write the TU size bits before fdi link training, so that error 	 * detection works. */
name|I915_WRITE
argument_list|(
name|FDI_RX_TUSIZE1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|PIPE_DATA_M1
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|TU_SIZE_MASK
argument_list|)
expr_stmt|;
comment|/* For PCH output, training FDI link */
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* XXX: pch pll's can be enabled any time before we enable the PCH 	 * transcoder, and we actually should do this to not upset any PCH 	 * transcoder that already use the clock when we share it. 	 * 	 * Note that enable_pch_pll tries to do the right thing, but get_pch_pll 	 * unconditionally resets the pll - we need that to have the right LVDS 	 * enable sequence. */
name|ironlake_enable_pch_pll
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|u32
name|sel
decl_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_DPLL_SEL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
default|default:
case|case
literal|0
case|:
name|temp
operator||=
name|TRANSA_DPLL_ENABLE
expr_stmt|;
name|sel
operator|=
name|TRANSA_DPLLB_SEL
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|temp
operator||=
name|TRANSB_DPLL_ENABLE
expr_stmt|;
name|sel
operator|=
name|TRANSB_DPLLB_SEL
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|temp
operator||=
name|TRANSC_DPLL_ENABLE
expr_stmt|;
name|sel
operator|=
name|TRANSC_DPLLB_SEL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|pll_reg
operator|==
name|_PCH_DPLL_B
condition|)
name|temp
operator||=
name|sel
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
name|sel
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DPLL_SEL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* set transcoder timing, panel must allow it */
name|assert_panel_unlocked
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_HTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|HTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_HBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|HBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_HSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|HSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_VTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|VTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_VBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|VBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_VSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|VSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_VSYNCSHIFT
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|VSYNCSHIFT
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intel_fdi_normal_train
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* For PCH DP, enable TRANS_DP_CTL */
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
operator|||
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_EDP
argument_list|)
operator|)
condition|)
block|{
name|u32
name|bpc
init|=
operator|(
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|PIPE_BPC_MASK
operator|)
operator|>>
literal|5
decl_stmt|;
name|reg
operator|=
name|TRANS_DP_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|TRANS_DP_PORT_SEL_MASK
operator||
name|TRANS_DP_SYNC_MASK
operator||
name|TRANS_DP_BPC_MASK
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|TRANS_DP_OUTPUT_ENABLE
operator||
name|TRANS_DP_ENH_FRAMING
operator|)
expr_stmt|;
name|temp
operator||=
name|bpc
operator|<<
literal|9
expr_stmt|;
comment|/* same format but at 11:9 */
if|if
condition|(
name|crtc
operator|->
name|mode
operator|.
name|flags
operator|&
name|DRM_MODE_FLAG_PHSYNC
condition|)
name|temp
operator||=
name|TRANS_DP_HSYNC_ACTIVE_HIGH
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|mode
operator|.
name|flags
operator|&
name|DRM_MODE_FLAG_PVSYNC
condition|)
name|temp
operator||=
name|TRANS_DP_VSYNC_ACTIVE_HIGH
expr_stmt|;
switch|switch
condition|(
name|intel_trans_dp_port_sel
argument_list|(
name|crtc
argument_list|)
condition|)
block|{
case|case
name|PCH_DP_B
case|:
name|temp
operator||=
name|TRANS_DP_PORT_SEL_B
expr_stmt|;
break|break;
case|case
name|PCH_DP_C
case|:
name|temp
operator||=
name|TRANS_DP_PORT_SEL_C
expr_stmt|;
break|break;
case|case
name|PCH_DP_D
case|:
name|temp
operator||=
name|TRANS_DP_PORT_SEL_D
expr_stmt|;
break|break;
default|default:
name|BUG
argument_list|()
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|ironlake_enable_pch_transcoder
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lpt_pch_enable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|enum
name|transcoder
name|cpu_transcoder
init|=
name|intel_crtc
operator|->
name|cpu_transcoder
decl_stmt|;
name|assert_transcoder_disabled
argument_list|(
name|dev_priv
argument_list|,
operator|(
expr|enum
name|pipe
operator|)
name|TRANSCODER_A
argument_list|)
expr_stmt|;
name|lpt_program_iclkip
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* Set transcoder timing. */
name|I915_WRITE
argument_list|(
name|_TRANS_HTOTAL_A
argument_list|,
name|I915_READ
argument_list|(
name|HTOTAL
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_TRANS_HBLANK_A
argument_list|,
name|I915_READ
argument_list|(
name|HBLANK
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_TRANS_HSYNC_A
argument_list|,
name|I915_READ
argument_list|(
name|HSYNC
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_TRANS_VTOTAL_A
argument_list|,
name|I915_READ
argument_list|(
name|VTOTAL
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_TRANS_VBLANK_A
argument_list|,
name|I915_READ
argument_list|(
name|VBLANK
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_TRANS_VSYNC_A
argument_list|,
name|I915_READ
argument_list|(
name|VSYNC
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_TRANS_VSYNCSHIFT_A
argument_list|,
name|I915_READ
argument_list|(
name|VSYNCSHIFT
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lpt_enable_pch_transcoder
argument_list|(
name|dev_priv
argument_list|,
name|cpu_transcoder
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_put_pch_pll
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|)
block|{
name|struct
name|intel_pch_pll
modifier|*
name|pll
init|=
name|intel_crtc
operator|->
name|pch_pll
decl_stmt|;
if|if
condition|(
name|pll
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pll
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
name|WARN
argument_list|(
literal|1
argument_list|,
literal|"bad PCH PLL refcount\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|--
name|pll
operator|->
name|refcount
expr_stmt|;
name|intel_crtc
operator|->
name|pch_pll
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|intel_pch_pll
modifier|*
name|intel_get_pch_pll
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|,
name|u32
name|dpll
parameter_list|,
name|u32
name|fp
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|intel_crtc
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_pch_pll
modifier|*
name|pll
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pll
operator|=
name|intel_crtc
operator|->
name|pch_pll
expr_stmt|;
if|if
condition|(
name|pll
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"CRTC:%d reusing existing PCH PLL %x\n"
argument_list|,
name|intel_crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
goto|goto
name|prepare
goto|;
block|}
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
comment|/* Ironlake PCH has a fixed PLL->PCH pipe mapping. */
name|i
operator|=
name|intel_crtc
operator|->
name|pipe
expr_stmt|;
name|pll
operator|=
operator|&
name|dev_priv
operator|->
name|pch_plls
index|[
name|i
index|]
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"CRTC:%d using pre-allocated PCH PLL %x\n"
argument_list|,
name|intel_crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|num_pch_pll
condition|;
name|i
operator|++
control|)
block|{
name|pll
operator|=
operator|&
name|dev_priv
operator|->
name|pch_plls
index|[
name|i
index|]
expr_stmt|;
comment|/* Only want to check enabled timings first */
if|if
condition|(
name|pll
operator|->
name|refcount
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dpll
operator|==
operator|(
name|I915_READ
argument_list|(
name|pll
operator|->
name|pll_reg
argument_list|)
operator|&
literal|0x7fffffff
operator|)
operator|&&
name|fp
operator|==
name|I915_READ
argument_list|(
name|pll
operator|->
name|fp0_reg
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"CRTC:%d sharing existing PCH PLL %x (refcount %d, ative %d)\n"
argument_list|,
name|intel_crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|,
name|pll
operator|->
name|refcount
argument_list|,
name|pll
operator|->
name|active
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
comment|/* Ok no matching timings, maybe there's a free one? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|num_pch_pll
condition|;
name|i
operator|++
control|)
block|{
name|pll
operator|=
operator|&
name|dev_priv
operator|->
name|pch_plls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pll
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"CRTC:%d allocated PCH PLL %x\n"
argument_list|,
name|intel_crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
return|return
name|NULL
return|;
name|found
label|:
name|intel_crtc
operator|->
name|pch_pll
operator|=
name|pll
expr_stmt|;
name|pll
operator|->
name|refcount
operator|++
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"using pll %d for pipe %d\n"
argument_list|,
name|i
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|prepare
label|:
comment|/* separate function? */
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"switching PLL %x off\n"
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to stabilize before rewriting the regs */
name|I915_WRITE
argument_list|(
name|pll
operator|->
name|pll_reg
argument_list|,
name|dpll
operator|&
operator|~
name|DPLL_VCO_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|pll
operator|->
name|fp0_reg
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|pll
operator|->
name|pll_reg
argument_list|,
name|dpll
operator|&
operator|~
name|DPLL_VCO_ENABLE
argument_list|)
expr_stmt|;
name|pll
operator|->
name|on
operator|=
name|false
expr_stmt|;
return|return
name|pll
return|;
block|}
end_function

begin_function
name|void
name|intel_cpt_verify_modeset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|dslreg
init|=
name|PIPEDSL
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|dslreg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|500
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
name|I915_READ
argument_list|(
name|dslreg
argument_list|)
operator|!=
name|temp
argument_list|,
literal|5
argument_list|)
condition|)
block|{
if|if
condition|(
name|wait_for
argument_list|(
name|I915_READ
argument_list|(
name|dslreg
argument_list|)
operator|!=
name|temp
argument_list|,
literal|5
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"mode set failed: pipe %d stuck\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_crtc_enable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|bool
name|is_pch_port
decl_stmt|;
name|WARN_ON
argument_list|(
operator|!
name|crtc
operator|->
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|active
condition|)
return|return;
name|intel_crtc
operator|->
name|active
operator|=
name|true
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|&
name|LVDS_PORT_EN
operator|)
operator|==
literal|0
condition|)
name|I915_WRITE
argument_list|(
name|PCH_LVDS
argument_list|,
name|temp
operator||
name|LVDS_PORT_EN
argument_list|)
expr_stmt|;
block|}
name|is_pch_port
operator|=
name|ironlake_crtc_driving_pch
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pch_port
condition|)
block|{
comment|/* Note: FDI PLL enabling _must_ be done before we enable the 		 * cpu pipes, hence this is separate from all the other fdi/pch 		 * enabling. */
name|ironlake_fdi_pll_enable
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert_fdi_tx_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|assert_fdi_rx_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
if|if
condition|(
name|encoder
operator|->
name|pre_enable
condition|)
name|encoder
operator|->
name|pre_enable
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
comment|/* Enable panel fitting for LVDS */
if|if
condition|(
name|dev_priv
operator|->
name|pch_pf_size
operator|&&
operator|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|||
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_EDP
argument_list|)
operator|)
condition|)
block|{
comment|/* Force use of hard-coded filter coefficients 		 * as some pre-programmed values are broken, 		 * e.g. x201. 		 */
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|PF_CTL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|PF_ENABLE
operator||
name|PF_FILTER_MED_3x3
operator||
name|PF_PIPE_SEL_IVB
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|I915_WRITE
argument_list|(
name|PF_CTL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|PF_ENABLE
operator||
name|PF_FILTER_MED_3x3
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PF_WIN_POS
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dev_priv
operator|->
name|pch_pf_pos
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PF_WIN_SZ
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dev_priv
operator|->
name|pch_pf_size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * On ILK+ LUT must be loaded before the pipe is running but with 	 * clocks enabled 	 */
name|intel_crtc_load_lut
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_enable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|is_pch_port
argument_list|)
expr_stmt|;
name|intel_enable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pch_port
condition|)
name|ironlake_pch_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
name|encoder
operator|->
name|enable
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_cpt_verify_modeset
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
comment|/* 	 * There seems to be a race in PCH platform hw (at least on some 	 * outputs) where an enabled pipe still completes any pageflip right 	 * away (as if the pipe is off) instead of waiting for vblank. As soon 	 * as the first vblank happened, everything works as expected. Hence just 	 * wait for one vblank before returning to avoid strange things 	 * happening. 	 */
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|haswell_crtc_enable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|bool
name|is_pch_port
decl_stmt|;
name|WARN_ON
argument_list|(
operator|!
name|crtc
operator|->
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|active
condition|)
return|return;
name|intel_crtc
operator|->
name|active
operator|=
name|true
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|is_pch_port
operator|=
name|haswell_crtc_driving_pch
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pch_port
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
if|if
condition|(
name|encoder
operator|->
name|pre_enable
condition|)
name|encoder
operator|->
name|pre_enable
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|intel_ddi_enable_pipe_clock
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
comment|/* Enable panel fitting for eDP */
if|if
condition|(
name|dev_priv
operator|->
name|pch_pf_size
operator|&&
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_EDP
argument_list|)
condition|)
block|{
comment|/* Force use of hard-coded filter coefficients 		 * as some pre-programmed values are broken, 		 * e.g. x201. 		 */
name|I915_WRITE
argument_list|(
name|PF_CTL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|PF_ENABLE
operator||
name|PF_FILTER_MED_3x3
operator||
name|PF_PIPE_SEL_IVB
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PF_WIN_POS
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dev_priv
operator|->
name|pch_pf_pos
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PF_WIN_SZ
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dev_priv
operator|->
name|pch_pf_size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * On ILK+ LUT must be loaded before the pipe is running but with 	 * clocks enabled 	 */
name|intel_crtc_load_lut
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_ddi_set_pipe_settings
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_ddi_enable_pipe_func
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_enable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|is_pch_port
argument_list|)
expr_stmt|;
name|intel_enable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pch_port
condition|)
name|lpt_pch_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
name|encoder
operator|->
name|enable
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
comment|/* 	 * There seems to be a race in PCH platform hw (at least on some 	 * outputs) where an enabled pipe still completes any pageflip right 	 * away (as if the pipe is off) instead of waiting for vblank. As soon 	 * as the first vblank happened, everything works as expected. Hence just 	 * wait for one vblank before returning to avoid strange things 	 * happening. 	 */
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_crtc_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|active
condition|)
return|return;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
name|encoder
operator|->
name|disable
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|intel_crtc_wait_for_pending_flips
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|drm_vblank_off
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|intel_disable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|cfb_plane
operator|==
name|plane
condition|)
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_disable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* Disable PF */
name|I915_WRITE
argument_list|(
name|PF_CTL
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PF_WIN_SZ
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
if|if
condition|(
name|encoder
operator|->
name|post_disable
condition|)
name|encoder
operator|->
name|post_disable
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|ironlake_fdi_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|ironlake_disable_pch_transcoder
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* disable TRANS_DP_CTL */
name|reg
operator|=
name|TRANS_DP_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|TRANS_DP_OUTPUT_ENABLE
operator||
name|TRANS_DP_PORT_SEL_MASK
operator|)
expr_stmt|;
name|temp
operator||=
name|TRANS_DP_PORT_SEL_NONE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* disable DPLL_SEL */
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_DPLL_SEL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
case|case
literal|0
case|:
name|temp
operator|&=
operator|~
operator|(
name|TRANSA_DPLL_ENABLE
operator||
name|TRANSA_DPLLB_SEL
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|temp
operator|&=
operator|~
operator|(
name|TRANSB_DPLL_ENABLE
operator||
name|TRANSB_DPLLB_SEL
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* C shares PLL A or B */
name|temp
operator|&=
operator|~
operator|(
name|TRANSC_DPLL_ENABLE
operator||
name|TRANSC_DPLLB_SEL
operator|)
expr_stmt|;
break|break;
default|default:
name|BUG
argument_list|()
expr_stmt|;
comment|/* wtf */
block|}
name|I915_WRITE
argument_list|(
name|PCH_DPLL_SEL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* disable PCH DPLL */
name|intel_disable_pch_pll
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
name|ironlake_fdi_pll_disable
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|active
operator|=
name|false
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|haswell_crtc_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|enum
name|transcoder
name|cpu_transcoder
init|=
name|intel_crtc
operator|->
name|cpu_transcoder
decl_stmt|;
name|bool
name|is_pch_port
decl_stmt|;
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|active
condition|)
return|return;
name|is_pch_port
operator|=
name|haswell_crtc_driving_pch
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
name|encoder
operator|->
name|disable
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|intel_crtc_wait_for_pending_flips
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|drm_vblank_off
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|intel_disable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|cfb_plane
operator|==
name|plane
condition|)
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_disable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_ddi_disable_transcoder_func
argument_list|(
name|dev_priv
argument_list|,
name|cpu_transcoder
argument_list|)
expr_stmt|;
comment|/* Disable PF */
name|I915_WRITE
argument_list|(
name|PF_CTL
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PF_WIN_SZ
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intel_ddi_disable_pipe_clock
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
if|if
condition|(
name|encoder
operator|->
name|post_disable
condition|)
name|encoder
operator|->
name|post_disable
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pch_port
condition|)
block|{
name|lpt_disable_pch_transcoder
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|intel_ddi_fdi_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
name|intel_crtc
operator|->
name|active
operator|=
name|false
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_crtc_off
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|intel_put_pch_pll
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|haswell_crtc_off
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
comment|/* Stop saying we're using TRANSCODER_EDP because some other CRTC might 	 * start using it. */
name|intel_crtc
operator|->
name|cpu_transcoder
operator|=
operator|(
expr|enum
name|transcoder
operator|)
name|intel_crtc
operator|->
name|pipe
expr_stmt|;
name|intel_ddi_put_crtc_pll
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_dpms_overlay
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
if|if
condition|(
operator|!
name|enable
operator|&&
name|intel_crtc
operator|->
name|overlay
condition|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_crtc
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|false
expr_stmt|;
operator|(
name|void
operator|)
name|intel_overlay_switch_off
argument_list|(
name|intel_crtc
operator|->
name|overlay
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|true
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Let userspace switch the overlay on again. In most cases userspace 	 * has to recompute where to put it anyway. 	 */
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_crtc_enable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|WARN_ON
argument_list|(
operator|!
name|crtc
operator|->
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|active
condition|)
return|return;
name|intel_crtc
operator|->
name|active
operator|=
name|true
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_enable_pll
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_enable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|intel_enable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_crtc_load_lut
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Give the overlay scaler a chance to enable if it's on this pipe */
name|intel_crtc_dpms_overlay
argument_list|(
name|intel_crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
name|encoder
operator|->
name|enable
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_crtc_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|u32
name|pctl
decl_stmt|;
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|active
condition|)
return|return;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
name|encoder
operator|->
name|disable
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
comment|/* Give the overlay scaler a chance to disable if it's on this pipe */
name|intel_crtc_wait_for_pending_flips
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|drm_vblank_off
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_crtc_dpms_overlay
argument_list|(
name|intel_crtc
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|cfb_plane
operator|==
name|plane
condition|)
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_disable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_disable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* Disable pannel fitter if it is on this pipe. */
name|pctl
operator|=
name|I915_READ
argument_list|(
name|PFIT_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pctl
operator|&
name|PFIT_ENABLE
operator|)
operator|&&
operator|(
operator|(
name|pctl
operator|&
name|PFIT_PIPE_MASK
operator|)
operator|>>
name|PFIT_PIPE_SHIFT
operator|)
operator|==
name|pipe
condition|)
name|I915_WRITE
argument_list|(
name|PFIT_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intel_disable_pll
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|active
operator|=
name|false
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_crtc_off
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|intel_crtc_update_sarea
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_master_private
modifier|*
name|master_priv
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|primary
operator|->
name|master
condition|)
return|return;
name|master_priv
operator|=
name|dev
operator|->
name|primary
operator|->
name|master
operator|->
name|driver_priv
expr_stmt|;
if|if
condition|(
operator|!
name|master_priv
operator|->
name|sarea_priv
condition|)
return|return;
switch|switch
condition|(
name|pipe
condition|)
block|{
case|case
literal|0
case|:
name|master_priv
operator|->
name|sarea_priv
operator|->
name|pipeA_w
operator|=
name|enabled
condition|?
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
else|:
literal|0
expr_stmt|;
name|master_priv
operator|->
name|sarea_priv
operator|->
name|pipeA_h
operator|=
name|enabled
condition|?
name|crtc
operator|->
name|mode
operator|.
name|vdisplay
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|master_priv
operator|->
name|sarea_priv
operator|->
name|pipeB_w
operator|=
name|enabled
condition|?
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
else|:
literal|0
expr_stmt|;
name|master_priv
operator|->
name|sarea_priv
operator|->
name|pipeB_h
operator|=
name|enabled
condition|?
name|crtc
operator|->
name|mode
operator|.
name|vdisplay
else|:
literal|0
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Can't update pipe %c in SAREA\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * Sets the power management mode of the pipe and plane.  */
end_comment

begin_function
name|void
name|intel_crtc_update_dpms
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
decl_stmt|;
name|bool
name|enable
init|=
name|false
decl_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|intel_encoder
argument_list|)
name|enable
operator||=
name|intel_encoder
operator|->
name|connectors_active
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|crtc_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
else|else
name|dev_priv
operator|->
name|display
operator|.
name|crtc_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_crtc_update_sarea
argument_list|(
name|crtc
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_noop
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|intel_crtc_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* crtc should still be enabled when we disable it. */
name|WARN_ON
argument_list|(
operator|!
name|crtc
operator|->
name|enabled
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|crtc_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_crtc_update_sarea
argument_list|(
name|crtc
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|off
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|assert_plane_disabled
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|,
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|plane
argument_list|)
expr_stmt|;
name|assert_pipe_disabled
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|,
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|fb
condition|)
block|{
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_unpin_fb_obj
argument_list|(
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
operator|->
name|obj
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|fb
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Update computed state. */
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|!
name|connector
operator|->
name|encoder
operator|||
operator|!
name|connector
operator|->
name|encoder
operator|->
name|crtc
condition|)
continue|continue;
if|if
condition|(
name|connector
operator|->
name|encoder
operator|->
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
name|connector
operator|->
name|dpms
operator|=
name|DRM_MODE_DPMS_OFF
expr_stmt|;
name|to_intel_encoder
argument_list|(
name|connector
operator|->
name|encoder
argument_list|)
operator|->
name|connectors_active
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|intel_modeset_disable
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|crtc
operator|->
name|enabled
condition|)
name|intel_crtc_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|intel_encoder_noop
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|intel_encoder_destroy
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
init|=
name|to_intel_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|drm_encoder_cleanup
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intel_encoder
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Simple dpms helper for encodres with just one connector, no cloning and only  * one kind of off state. It clamps all !ON modes to fully OFF and changes the  * state of the entire output pipe. */
end_comment

begin_function
name|void
name|intel_encoder_dpms
parameter_list|(
name|struct
name|intel_encoder
modifier|*
name|encoder
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|DRM_MODE_DPMS_ON
condition|)
block|{
name|encoder
operator|->
name|connectors_active
operator|=
name|true
expr_stmt|;
name|intel_crtc_update_dpms
argument_list|(
name|encoder
operator|->
name|base
operator|.
name|crtc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|encoder
operator|->
name|connectors_active
operator|=
name|false
expr_stmt|;
name|intel_crtc_update_dpms
argument_list|(
name|encoder
operator|->
name|base
operator|.
name|crtc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Cross check the actual hw state with our own modeset state tracking (and it's  * internal consistency). */
end_comment

begin_function
specifier|static
name|void
name|intel_connector_check_state
parameter_list|(
name|struct
name|intel_connector
modifier|*
name|connector
parameter_list|)
block|{
if|if
condition|(
name|connector
operator|->
name|get_hw_state
argument_list|(
name|connector
argument_list|)
condition|)
block|{
name|struct
name|intel_encoder
modifier|*
name|encoder
init|=
name|connector
operator|->
name|encoder
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|bool
name|encoder_enabled
decl_stmt|;
name|enum
name|pipe
name|pipe
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
operator|&
name|connector
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
name|connector
operator|->
name|base
operator|.
name|dpms
operator|==
name|DRM_MODE_DPMS_OFF
argument_list|,
literal|"wrong connector dpms state\n"
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
name|connector
operator|->
name|base
operator|.
name|encoder
operator|!=
operator|&
name|encoder
operator|->
name|base
argument_list|,
literal|"active connector not linked to encoder\n"
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
operator|!
name|encoder
operator|->
name|connectors_active
argument_list|,
literal|"encoder->connectors_active not set\n"
argument_list|)
expr_stmt|;
name|encoder_enabled
operator|=
name|encoder
operator|->
name|get_hw_state
argument_list|(
name|encoder
argument_list|,
operator|&
name|pipe
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
operator|!
name|encoder_enabled
argument_list|,
literal|"encoder not enabled\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|WARN_ON
argument_list|(
operator|!
name|encoder
operator|->
name|base
operator|.
name|crtc
argument_list|)
condition|)
return|return;
name|crtc
operator|=
name|encoder
operator|->
name|base
operator|.
name|crtc
expr_stmt|;
name|WARN
argument_list|(
operator|!
name|crtc
operator|->
name|enabled
argument_list|,
literal|"crtc not enabled\n"
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
operator|!
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|active
argument_list|,
literal|"crtc not active\n"
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
name|pipe
operator|!=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|pipe
argument_list|,
literal|"encoder active on the wrong pipe\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Even simpler default implementation, if there's really no special case to  * consider. */
end_comment

begin_function
name|void
name|intel_connector_dpms
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|intel_encoder
modifier|*
name|encoder
init|=
name|intel_attached_encoder
argument_list|(
name|connector
argument_list|)
decl_stmt|;
comment|/* All the simple cases only support two dpms states. */
if|if
condition|(
name|mode
operator|!=
name|DRM_MODE_DPMS_ON
condition|)
name|mode
operator|=
name|DRM_MODE_DPMS_OFF
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|connector
operator|->
name|dpms
condition|)
return|return;
name|connector
operator|->
name|dpms
operator|=
name|mode
expr_stmt|;
comment|/* Only need to change hw state when actually enabled */
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
condition|)
name|intel_encoder_dpms
argument_list|(
name|encoder
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|WARN_ON
argument_list|(
name|encoder
operator|->
name|connectors_active
operator|!=
name|false
argument_list|)
expr_stmt|;
name|intel_modeset_check_state
argument_list|(
name|connector
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Simple connector->get_hw_state implementation for encoders that support only  * one connector and no cloning and hence the encoder state determines the state  * of the connector. */
end_comment

begin_function
name|bool
name|intel_connector_get_hw_state
parameter_list|(
name|struct
name|intel_connector
modifier|*
name|connector
parameter_list|)
block|{
name|enum
name|pipe
name|pipe
init|=
literal|0
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
init|=
name|connector
operator|->
name|encoder
decl_stmt|;
return|return
name|encoder
operator|->
name|get_hw_state
argument_list|(
name|encoder
argument_list|,
operator|&
name|pipe
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_crtc_mode_fixup
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
specifier|const
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* FDI link clock is fixed at 2.7G */
if|if
condition|(
name|mode
operator|->
name|clock
operator|*
literal|3
operator|>
name|IRONLAKE_FDI_FREQ
operator|*
literal|4
condition|)
return|return
name|false
return|;
block|}
comment|/* All interlaced capable intel hw wants timings in frames. Note though 	 * that intel_lvds_mode_fixup does some funny tricks with the crtc 	 * timings, so we need to be careful not to clobber these.*/
if|if
condition|(
operator|!
operator|(
name|adjusted_mode
operator|->
name|private_flags
operator|&
name|INTEL_MODE_CRTC_TIMINGS_SET
operator|)
condition|)
name|drm_mode_set_crtcinfo
argument_list|(
name|adjusted_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* WaPruneModeWithIncorrectHsyncOffset: Cantiga+ cannot handle modes 	 * with a hsync front porch of 0. 	 */
if|if
condition|(
operator|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>
literal|4
operator|||
name|IS_G4X
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
name|adjusted_mode
operator|->
name|hsync_start
operator|==
name|adjusted_mode
operator|->
name|hdisplay
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|valleyview_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|400000
return|;
comment|/* FIXME */
block|}
end_function

begin_function
specifier|static
name|int
name|i945_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|400000
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|333000
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i9xx_misc_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|200000
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915gm_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|u16
name|gcfgc
init|=
literal|0
decl_stmt|;
name|pci_read_config_word
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|GCFGC
argument_list|,
operator|&
name|gcfgc
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcfgc
operator|&
name|GC_LOW_FREQUENCY_ENABLE
condition|)
return|return
literal|133000
return|;
else|else
block|{
switch|switch
condition|(
name|gcfgc
operator|&
name|GC_DISPLAY_CLOCK_MASK
condition|)
block|{
case|case
name|GC_DISPLAY_CLOCK_333_MHZ
case|:
return|return
literal|333000
return|;
default|default:
case|case
name|GC_DISPLAY_CLOCK_190_200_MHZ
case|:
return|return
literal|190000
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|i865_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|266000
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i855_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|u16
name|hpllcc
init|=
literal|0
decl_stmt|;
comment|/* Assume that the hardware is in the high speed state.  This 	 * should be the default. 	 */
switch|switch
condition|(
name|hpllcc
operator|&
name|GC_CLOCK_CONTROL_MASK
condition|)
block|{
case|case
name|GC_CLOCK_133_200
case|:
case|case
name|GC_CLOCK_100_200
case|:
return|return
literal|200000
return|;
case|case
name|GC_CLOCK_166_250
case|:
return|return
literal|250000
return|;
case|case
name|GC_CLOCK_100_133
case|:
return|return
literal|133000
return|;
block|}
comment|/* Shouldn't happen */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i830_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|133000
return|;
block|}
end_function

begin_struct
struct|struct
name|fdi_m_n
block|{
name|u32
name|tu
decl_stmt|;
name|u32
name|gmch_m
decl_stmt|;
name|u32
name|gmch_n
decl_stmt|;
name|u32
name|link_m
decl_stmt|;
name|u32
name|link_n
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|fdi_reduce_ratio
parameter_list|(
name|u32
modifier|*
name|num
parameter_list|,
name|u32
modifier|*
name|den
parameter_list|)
block|{
while|while
condition|(
operator|*
name|num
operator|>
literal|0xffffff
operator|||
operator|*
name|den
operator|>
literal|0xffffff
condition|)
block|{
operator|*
name|num
operator|>>=
literal|1
expr_stmt|;
operator|*
name|den
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_compute_m_n
parameter_list|(
name|int
name|bits_per_pixel
parameter_list|,
name|int
name|nlanes
parameter_list|,
name|int
name|pixel_clock
parameter_list|,
name|int
name|link_clock
parameter_list|,
name|struct
name|fdi_m_n
modifier|*
name|m_n
parameter_list|)
block|{
name|m_n
operator|->
name|tu
operator|=
literal|64
expr_stmt|;
comment|/* default size */
comment|/* BUG_ON(pixel_clock> INT_MAX / 36); */
name|m_n
operator|->
name|gmch_m
operator|=
name|bits_per_pixel
operator|*
name|pixel_clock
expr_stmt|;
name|m_n
operator|->
name|gmch_n
operator|=
name|link_clock
operator|*
name|nlanes
operator|*
literal|8
expr_stmt|;
name|fdi_reduce_ratio
argument_list|(
operator|&
name|m_n
operator|->
name|gmch_m
argument_list|,
operator|&
name|m_n
operator|->
name|gmch_n
argument_list|)
expr_stmt|;
name|m_n
operator|->
name|link_m
operator|=
name|pixel_clock
expr_stmt|;
name|m_n
operator|->
name|link_n
operator|=
name|link_clock
expr_stmt|;
name|fdi_reduce_ratio
argument_list|(
operator|&
name|m_n
operator|->
name|link_m
argument_list|,
operator|&
name|m_n
operator|->
name|link_n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|intel_panel_use_ssc
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
if|if
condition|(
name|i915_panel_use_ssc
operator|>=
literal|0
condition|)
return|return
name|i915_panel_use_ssc
operator|!=
literal|0
return|;
return|return
name|dev_priv
operator|->
name|lvds_use_ssc
operator|&&
operator|!
operator|(
name|dev_priv
operator|->
name|quirks
operator|&
name|QUIRK_LVDS_SSC_DISABLE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * intel_choose_pipe_bpp_dither - figure out what color depth the pipe should send  * @crtc: CRTC structure  * @mode: requested mode  *  * A pipe may be connected to one or more outputs.  Based on the depth of the  * attached framebuffer, choose a good color depth to use on the pipe.  *  * If possible, match the pipe depth to the fb depth.  In some cases, this  * isn't ideal, because the connected output supports a lesser or restricted  * set of depths.  Resolve that here:  *    LVDS typically supports only 6bpc, so clamp down in that case  *    HDMI supports only 8bpc or 12bpc, so clamp to 8bpc with dither for 10bpc  *    Displays may support a restricted set as well, check EDID and clamp as  *      appropriate.  *    DP may want to dither down to 6bpc to fit larger modes  *  * RETURNS:  * Dithering requirement (i.e. false if display bpc and pipe bpc match,  * true if they don't match).  */
end_comment

begin_function
specifier|static
name|bool
name|intel_choose_pipe_bpp_dither
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|unsigned
name|int
modifier|*
name|pipe_bpp
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
decl_stmt|;
name|unsigned
name|int
name|display_bpc
init|=
name|UINT_MAX
decl_stmt|,
name|bpc
decl_stmt|;
comment|/* Walk the encoders& connectors on this crtc, get min bpc */
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|intel_encoder
argument_list|)
block|{
if|if
condition|(
name|intel_encoder
operator|->
name|type
operator|==
name|INTEL_OUTPUT_LVDS
condition|)
block|{
name|unsigned
name|int
name|lvds_bpc
decl_stmt|;
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
operator|&
name|LVDS_A3_POWER_MASK
operator|)
operator|==
name|LVDS_A3_POWER_UP
condition|)
name|lvds_bpc
operator|=
literal|8
expr_stmt|;
else|else
name|lvds_bpc
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|lvds_bpc
operator|<
name|display_bpc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"clamping display bpc (was %d) to LVDS (%d)\n"
argument_list|,
name|display_bpc
argument_list|,
name|lvds_bpc
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
name|lvds_bpc
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Not one of the known troublemakers, check the EDID */
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder
operator|!=
operator|&
name|intel_encoder
operator|->
name|base
condition|)
continue|continue;
comment|/* Don't use an invalid EDID bpc value */
if|if
condition|(
name|connector
operator|->
name|display_info
operator|.
name|bpc
operator|&&
name|connector
operator|->
name|display_info
operator|.
name|bpc
operator|<
name|display_bpc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"clamping display bpc (was %d) to EDID reported max of %d\n"
argument_list|,
name|display_bpc
argument_list|,
name|connector
operator|->
name|display_info
operator|.
name|bpc
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
name|connector
operator|->
name|display_info
operator|.
name|bpc
expr_stmt|;
block|}
block|}
if|if
condition|(
name|intel_encoder
operator|->
name|type
operator|==
name|INTEL_OUTPUT_EDP
condition|)
block|{
comment|/* Use VBT settings if we have an eDP panel */
name|unsigned
name|int
name|edp_bpc
init|=
name|dev_priv
operator|->
name|edp
operator|.
name|bpp
operator|/
literal|3
decl_stmt|;
if|if
condition|(
name|edp_bpc
operator|&&
name|edp_bpc
operator|<
name|display_bpc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"clamping display bpc (was %d) to eDP (%d)\n"
argument_list|,
name|display_bpc
argument_list|,
name|edp_bpc
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
name|edp_bpc
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		 * HDMI is either 12 or 8, so if the display lets 10bpc sneak 		 * through, clamp it down.  (Note:>12bpc will be caught below.) 		 */
if|if
condition|(
name|intel_encoder
operator|->
name|type
operator|==
name|INTEL_OUTPUT_HDMI
condition|)
block|{
if|if
condition|(
name|display_bpc
operator|>
literal|8
operator|&&
name|display_bpc
operator|<
literal|12
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"forcing bpc to 12 for HDMI\n"
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
literal|12
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"forcing bpc to 8 for HDMI\n"
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
literal|8
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mode
operator|->
name|private_flags
operator|&
name|INTEL_MODE_DP_FORCE_6BPC
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Dithering DP to 6bpc\n"
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
literal|6
expr_stmt|;
block|}
comment|/* 	 * We could just drive the pipe at the highest bpc all the time and 	 * enable dithering as needed, but that costs bandwidth.  So choose 	 * the minimum value that expresses the full color range of the fb but 	 * also stays within the max display bpc discovered above. 	 */
switch|switch
condition|(
name|fb
operator|->
name|depth
condition|)
block|{
case|case
literal|8
case|:
name|bpc
operator|=
literal|8
expr_stmt|;
comment|/* since we go through a colormap */
break|break;
case|case
literal|15
case|:
case|case
literal|16
case|:
name|bpc
operator|=
literal|6
expr_stmt|;
comment|/* min is 18bpp */
break|break;
case|case
literal|24
case|:
name|bpc
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|30
case|:
name|bpc
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|48
case|:
name|bpc
operator|=
literal|12
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG
argument_list|(
literal|"unsupported depth, assuming 24 bits\n"
argument_list|)
expr_stmt|;
name|bpc
operator|=
name|min
argument_list|(
operator|(
name|unsigned
name|int
operator|)
literal|8
argument_list|,
name|display_bpc
argument_list|)
expr_stmt|;
break|break;
block|}
name|display_bpc
operator|=
name|min
argument_list|(
name|display_bpc
argument_list|,
name|bpc
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"setting pipe bpc to %d (max display bpc %d)\n"
argument_list|,
name|bpc
argument_list|,
name|display_bpc
argument_list|)
expr_stmt|;
operator|*
name|pipe_bpp
operator|=
name|display_bpc
operator|*
literal|3
expr_stmt|;
return|return
name|display_bpc
operator|!=
name|bpc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vlv_get_refclk
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|refclk
init|=
literal|27000
decl_stmt|;
comment|/* for DP& HDMI */
return|return
literal|100000
return|;
comment|/* only one validated so far */
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_ANALOG
argument_list|)
condition|)
block|{
name|refclk
operator|=
literal|96000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
if|if
condition|(
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
condition|)
name|refclk
operator|=
literal|100000
expr_stmt|;
else|else
name|refclk
operator|=
literal|96000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_EDP
argument_list|)
condition|)
block|{
name|refclk
operator|=
literal|100000
expr_stmt|;
block|}
return|return
name|refclk
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i9xx_get_refclk
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|num_connectors
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|refclk
decl_stmt|;
if|if
condition|(
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|refclk
operator|=
name|vlv_get_refclk
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|&&
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|num_connectors
operator|<
literal|2
condition|)
block|{
name|refclk
operator|=
name|dev_priv
operator|->
name|lvds_ssc_freq
operator|*
literal|1000
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"using SSC reference clock of %d MHz\n"
argument_list|,
name|refclk
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|refclk
operator|=
literal|96000
expr_stmt|;
block|}
else|else
block|{
name|refclk
operator|=
literal|48000
expr_stmt|;
block|}
return|return
name|refclk
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_adjust_sdvo_tv_clock
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|)
block|{
comment|/* SDVO TV has fixed PLL values depend on its clock range, 	   this mirrors vbios setting. */
if|if
condition|(
name|adjusted_mode
operator|->
name|clock
operator|>=
literal|100000
operator|&&
name|adjusted_mode
operator|->
name|clock
operator|<
literal|140500
condition|)
block|{
name|clock
operator|->
name|p1
operator|=
literal|2
expr_stmt|;
name|clock
operator|->
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|->
name|n
operator|=
literal|3
expr_stmt|;
name|clock
operator|->
name|m1
operator|=
literal|16
expr_stmt|;
name|clock
operator|->
name|m2
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adjusted_mode
operator|->
name|clock
operator|>=
literal|140500
operator|&&
name|adjusted_mode
operator|->
name|clock
operator|<=
literal|200000
condition|)
block|{
name|clock
operator|->
name|p1
operator|=
literal|1
expr_stmt|;
name|clock
operator|->
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|->
name|n
operator|=
literal|6
expr_stmt|;
name|clock
operator|->
name|m1
operator|=
literal|12
expr_stmt|;
name|clock
operator|->
name|m2
operator|=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_update_pll_dividers
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|,
name|intel_clock_t
modifier|*
name|reduced_clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|fp
decl_stmt|,
name|fp2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|fp
operator|=
operator|(
literal|1
operator|<<
name|clock
operator|->
name|n
operator|)
operator|<<
literal|16
operator||
name|clock
operator|->
name|m1
operator|<<
literal|8
operator||
name|clock
operator|->
name|m2
expr_stmt|;
if|if
condition|(
name|reduced_clock
condition|)
name|fp2
operator|=
operator|(
literal|1
operator|<<
name|reduced_clock
operator|->
name|n
operator|)
operator|<<
literal|16
operator||
name|reduced_clock
operator|->
name|m1
operator|<<
literal|8
operator||
name|reduced_clock
operator|->
name|m2
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|clock
operator|->
name|n
operator|<<
literal|16
operator||
name|clock
operator|->
name|m1
operator|<<
literal|8
operator||
name|clock
operator|->
name|m2
expr_stmt|;
if|if
condition|(
name|reduced_clock
condition|)
name|fp2
operator|=
name|reduced_clock
operator|->
name|n
operator|<<
literal|16
operator||
name|reduced_clock
operator|->
name|m1
operator|<<
literal|8
operator||
name|reduced_clock
operator|->
name|m2
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|FP0
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|lowfreq_avail
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|&&
name|reduced_clock
operator|&&
name|i915_powersave
condition|)
block|{
name|I915_WRITE
argument_list|(
name|FP1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|fp2
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|lowfreq_avail
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|I915_WRITE
argument_list|(
name|FP1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_update_lvds
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|LVDS
argument_list|)
expr_stmt|;
name|temp
operator||=
name|LVDS_PORT_EN
operator||
name|LVDS_A0A2_CLKA_POWER_UP
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
literal|1
condition|)
block|{
name|temp
operator||=
name|LVDS_PIPEB_SELECT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|LVDS_PIPEB_SELECT
expr_stmt|;
block|}
comment|/* set the corresponsding LVDS_BORDER bit */
name|temp
operator||=
name|dev_priv
operator|->
name|lvds_border_bits
expr_stmt|;
comment|/* Set the B0-B3 data pairs corresponding to whether we're going to 	 * set the DPLLs for dual-channel mode or not. 	 */
if|if
condition|(
name|clock
operator|->
name|p2
operator|==
literal|7
condition|)
name|temp
operator||=
name|LVDS_B0B3_POWER_UP
operator||
name|LVDS_CLKB_POWER_UP
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
operator|(
name|LVDS_B0B3_POWER_UP
operator||
name|LVDS_CLKB_POWER_UP
operator|)
expr_stmt|;
comment|/* It would be nice to set 24 vs 18-bit mode (LVDS_A3_POWER_UP) 	 * appropriately here, but we need to look more thoroughly into how 	 * panels behave in the two modes. 	 */
comment|/* set the dithering flag on LVDS as needed */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|lvds_dither
condition|)
name|temp
operator||=
name|LVDS_ENABLE_DITHER
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
name|LVDS_ENABLE_DITHER
expr_stmt|;
block|}
name|temp
operator|&=
operator|~
operator|(
name|LVDS_HSYNC_POLARITY
operator||
name|LVDS_VSYNC_POLARITY
operator|)
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NHSYNC
condition|)
name|temp
operator||=
name|LVDS_HSYNC_POLARITY
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NVSYNC
condition|)
name|temp
operator||=
name|LVDS_VSYNC_POLARITY
expr_stmt|;
name|I915_WRITE
argument_list|(
name|LVDS
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlv_update_pll
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|,
name|intel_clock_t
modifier|*
name|reduced_clock
parameter_list|,
name|int
name|num_connectors
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|dpll
decl_stmt|,
name|mdiv
decl_stmt|,
name|pdiv
decl_stmt|;
name|u32
name|bestn
decl_stmt|,
name|bestm1
decl_stmt|,
name|bestm2
decl_stmt|,
name|bestp1
decl_stmt|,
name|bestp2
decl_stmt|;
name|bool
name|is_sdvo
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|is_sdvo
operator|=
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_SDVO
argument_list|)
operator|||
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_HDMI
argument_list|)
expr_stmt|;
name|dpll
operator|=
name|DPLL_VGA_MODE_DIS
expr_stmt|;
name|dpll
operator||=
name|DPLL_EXT_BUFFER_ENABLE_VLV
expr_stmt|;
name|dpll
operator||=
name|DPLL_REFA_CLK_ENABLE_VLV
expr_stmt|;
name|dpll
operator||=
name|DPLL_INTEGRATED_CLOCK_VLV
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|bestn
operator|=
name|clock
operator|->
name|n
expr_stmt|;
name|bestm1
operator|=
name|clock
operator|->
name|m1
expr_stmt|;
name|bestm2
operator|=
name|clock
operator|->
name|m2
expr_stmt|;
name|bestp1
operator|=
name|clock
operator|->
name|p1
expr_stmt|;
name|bestp2
operator|=
name|clock
operator|->
name|p2
expr_stmt|;
comment|/* 	 * In Valleyview PLL and program lane counter registers are exposed 	 * through DPIO interface 	 */
name|mdiv
operator|=
operator|(
operator|(
name|bestm1
operator|<<
name|DPIO_M1DIV_SHIFT
operator|)
operator||
operator|(
name|bestm2
operator|&
name|DPIO_M2DIV_MASK
operator|)
operator|)
expr_stmt|;
name|mdiv
operator||=
operator|(
operator|(
name|bestp1
operator|<<
name|DPIO_P1_SHIFT
operator|)
operator||
operator|(
name|bestp2
operator|<<
name|DPIO_P2_SHIFT
operator|)
operator|)
expr_stmt|;
name|mdiv
operator||=
operator|(
operator|(
name|bestn
operator|<<
name|DPIO_N_SHIFT
operator|)
operator|)
expr_stmt|;
name|mdiv
operator||=
operator|(
literal|1
operator|<<
name|DPIO_POST_DIV_SHIFT
operator|)
expr_stmt|;
name|mdiv
operator||=
operator|(
literal|1
operator|<<
name|DPIO_K_SHIFT
operator|)
expr_stmt|;
name|mdiv
operator||=
name|DPIO_ENABLE_CALIBRATION
expr_stmt|;
name|intel_dpio_write
argument_list|(
name|dev_priv
argument_list|,
name|DPIO_DIV
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|mdiv
argument_list|)
expr_stmt|;
name|intel_dpio_write
argument_list|(
name|dev_priv
argument_list|,
name|DPIO_CORE_CLK
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0x01000000
argument_list|)
expr_stmt|;
name|pdiv
operator|=
operator|(
literal|1
operator|<<
name|DPIO_REFSEL_OVERRIDE
operator|)
operator||
operator|(
literal|5
operator|<<
name|DPIO_PLL_MODESEL_SHIFT
operator|)
operator||
operator|(
literal|3
operator|<<
name|DPIO_BIAS_CURRENT_CTL_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
literal|20
operator|)
operator||
operator|(
literal|7
operator|<<
name|DPIO_PLL_REFCLK_SEL_SHIFT
operator|)
operator||
operator|(
literal|8
operator|<<
name|DPIO_DRIVER_CTL_SHIFT
operator|)
operator||
operator|(
literal|5
operator|<<
name|DPIO_CLK_BIAS_CTL_SHIFT
operator|)
expr_stmt|;
name|intel_dpio_write
argument_list|(
name|dev_priv
argument_list|,
name|DPIO_REFSFR
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|pdiv
argument_list|)
expr_stmt|;
name|intel_dpio_write
argument_list|(
name|dev_priv
argument_list|,
name|DPIO_LFP_COEFF
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0x005f003b
argument_list|)
expr_stmt|;
name|dpll
operator||=
name|DPLL_VCO_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
operator|(
operator|(
name|I915_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|DPLL_LOCK_VLV
operator|)
operator|==
name|DPLL_LOCK_VLV
operator|)
argument_list|,
literal|1
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"DPLL %d failed to lock\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_dpio_write
argument_list|(
name|dev_priv
argument_list|,
name|DPIO_FASTCLK_DISABLE
argument_list|,
literal|0x620
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
condition|)
name|intel_dp_set_m_n
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to stabilize. */
name|POSTING_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_sdvo
condition|)
block|{
name|temp
operator|=
name|intel_mode_get_pixel_multiplier
argument_list|(
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|1
condition|)
name|temp
operator|=
operator|(
name|temp
operator|-
literal|1
operator|)
operator|<<
name|DPLL_MD_UDI_MULTIPLIER_SHIFT
expr_stmt|;
else|else
name|temp
operator|=
literal|0
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|DPLL_MD
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DPLL_MD
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now program lane control registers */
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
operator|||
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_HDMI
argument_list|)
condition|)
block|{
name|temp
operator|=
literal|0x1000C4
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
literal|1
condition|)
name|temp
operator||=
operator|(
literal|1
operator|<<
literal|21
operator|)
expr_stmt|;
name|intel_dpio_write
argument_list|(
name|dev_priv
argument_list|,
name|DPIO_DATA_CHANNEL1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_EDP
argument_list|)
condition|)
block|{
name|temp
operator|=
literal|0x1000C4
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
literal|1
condition|)
name|temp
operator||=
operator|(
literal|1
operator|<<
literal|21
operator|)
expr_stmt|;
name|intel_dpio_write
argument_list|(
name|dev_priv
argument_list|,
name|DPIO_DATA_CHANNEL2
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_update_pll
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|,
name|intel_clock_t
modifier|*
name|reduced_clock
parameter_list|,
name|int
name|num_connectors
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|dpll
decl_stmt|;
name|bool
name|is_sdvo
decl_stmt|;
name|i9xx_update_pll_dividers
argument_list|(
name|crtc
argument_list|,
name|clock
argument_list|,
name|reduced_clock
argument_list|)
expr_stmt|;
name|is_sdvo
operator|=
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_SDVO
argument_list|)
operator|||
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_HDMI
argument_list|)
expr_stmt|;
name|dpll
operator|=
name|DPLL_VGA_MODE_DIS
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|dpll
operator||=
name|DPLLB_MODE_LVDS
expr_stmt|;
else|else
name|dpll
operator||=
name|DPLLB_MODE_DAC_SERIAL
expr_stmt|;
if|if
condition|(
name|is_sdvo
condition|)
block|{
name|int
name|pixel_multiplier
init|=
name|intel_mode_get_pixel_multiplier
argument_list|(
name|adjusted_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|pixel_multiplier
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_G33
argument_list|(
name|dev
argument_list|)
condition|)
name|dpll
operator||=
operator|(
name|pixel_multiplier
operator|-
literal|1
operator|)
operator|<<
name|SDVO_MULTIPLIER_SHIFT_HIRES
expr_stmt|;
block|}
name|dpll
operator||=
name|DPLL_DVO_HIGH_SPEED
expr_stmt|;
block|}
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
condition|)
name|dpll
operator||=
name|DPLL_DVO_HIGH_SPEED
expr_stmt|;
comment|/* compute bitmask from p1 value */
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|->
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT_PINEVIEW
expr_stmt|;
else|else
block|{
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|->
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT
expr_stmt|;
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
operator|&&
name|reduced_clock
condition|)
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|reduced_clock
operator|->
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA1_P1_POST_DIV_SHIFT
expr_stmt|;
block|}
switch|switch
condition|(
name|clock
operator|->
name|p2
condition|)
block|{
case|case
literal|5
case|:
name|dpll
operator||=
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_5
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|dpll
operator||=
name|DPLLB_LVDS_P2_CLOCK_DIV_7
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|dpll
operator||=
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_10
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|dpll
operator||=
name|DPLLB_LVDS_P2_CLOCK_DIV_14
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
name|dpll
operator||=
operator|(
literal|6
operator|<<
name|PLL_LOAD_PULSE_PHASE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|is_sdvo
operator|&&
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_TVOUT
argument_list|)
condition|)
name|dpll
operator||=
name|PLL_REF_INPUT_TVCLKINBC
expr_stmt|;
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_TVOUT
argument_list|)
condition|)
comment|/* XXX: just matching BIOS for now */
comment|/*	dpll |= PLL_REF_INPUT_TVCLKINBC; */
name|dpll
operator||=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|&&
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|num_connectors
operator|<
literal|2
condition|)
name|dpll
operator||=
name|PLLB_REF_INPUT_SPREADSPECTRUMIN
expr_stmt|;
else|else
name|dpll
operator||=
name|PLL_REF_INPUT_DREFCLK
expr_stmt|;
name|dpll
operator||=
name|DPLL_VCO_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
operator|&
operator|~
name|DPLL_VCO_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* The LVDS pin pair needs to be on before the DPLLs are enabled. 	 * This is an exception to the general rule that mode_set doesn't turn 	 * things on. 	 */
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|intel_update_lvds
argument_list|(
name|crtc
argument_list|,
name|clock
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
condition|)
name|intel_dp_set_m_n
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to stabilize. */
name|POSTING_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|u32
name|temp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|is_sdvo
condition|)
block|{
name|temp
operator|=
name|intel_mode_get_pixel_multiplier
argument_list|(
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|1
condition|)
name|temp
operator|=
operator|(
name|temp
operator|-
literal|1
operator|)
operator|<<
name|DPLL_MD_UDI_MULTIPLIER_SHIFT
expr_stmt|;
else|else
name|temp
operator|=
literal|0
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|DPLL_MD
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The pixel multiplier can only be updated once the 		 * DPLL is enabled and the clocks are stable. 		 * 		 * So write it again. 		 */
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i8xx_update_pll
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|,
name|intel_clock_t
modifier|*
name|reduced_clock
parameter_list|,
name|int
name|num_connectors
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|dpll
decl_stmt|;
name|i9xx_update_pll_dividers
argument_list|(
name|crtc
argument_list|,
name|clock
argument_list|,
name|reduced_clock
argument_list|)
expr_stmt|;
name|dpll
operator|=
name|DPLL_VGA_MODE_DIS
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|->
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|clock
operator|->
name|p1
operator|==
literal|2
condition|)
name|dpll
operator||=
name|PLL_P1_DIVIDE_BY_TWO
expr_stmt|;
else|else
name|dpll
operator||=
operator|(
name|clock
operator|->
name|p1
operator|-
literal|2
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|p2
operator|==
literal|4
condition|)
name|dpll
operator||=
name|PLL_P2_DIVIDE_BY_4
expr_stmt|;
block|}
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_TVOUT
argument_list|)
condition|)
comment|/* XXX: just matching BIOS for now */
comment|/*	dpll |= PLL_REF_INPUT_TVCLKINBC; */
name|dpll
operator||=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|&&
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|num_connectors
operator|<
literal|2
condition|)
name|dpll
operator||=
name|PLLB_REF_INPUT_SPREADSPECTRUMIN
expr_stmt|;
else|else
name|dpll
operator||=
name|PLL_REF_INPUT_DREFCLK
expr_stmt|;
name|dpll
operator||=
name|DPLL_VCO_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
operator|&
operator|~
name|DPLL_VCO_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* The LVDS pin pair needs to be on before the DPLLs are enabled. 	 * This is an exception to the general rule that mode_set doesn't turn 	 * things on. 	 */
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|intel_update_lvds
argument_list|(
name|crtc
argument_list|,
name|clock
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to stabilize. */
name|POSTING_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* The pixel multiplier can only be updated once the 	 * DPLL is enabled and the clocks are stable. 	 * 	 * So write it again. 	 */
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_set_pipe_timings
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_crtc
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|enum
name|pipe
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|enum
name|transcoder
name|cpu_transcoder
init|=
name|intel_crtc
operator|->
name|cpu_transcoder
decl_stmt|;
name|uint32_t
name|vsyncshift
decl_stmt|;
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
operator|&&
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
condition|)
block|{
comment|/* the chip adds 2 halflines automatically */
name|adjusted_mode
operator|->
name|crtc_vtotal
operator|-=
literal|1
expr_stmt|;
name|adjusted_mode
operator|->
name|crtc_vblank_end
operator|-=
literal|1
expr_stmt|;
name|vsyncshift
operator|=
name|adjusted_mode
operator|->
name|crtc_hsync_start
operator|-
name|adjusted_mode
operator|->
name|crtc_htotal
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|vsyncshift
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>
literal|3
condition|)
name|I915_WRITE
argument_list|(
name|VSYNCSHIFT
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|,
name|vsyncshift
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HTOTAL
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hdisplay
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_htotal
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HBLANK
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hblank_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_hblank_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HSYNC
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hsync_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_hsync_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VTOTAL
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vdisplay
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vtotal
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VBLANK
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vblank_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vblank_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VSYNC
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vsync_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vsync_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* Workaround: when the EDP input selection is B, the VTOTAL_B must be 	 * programmed with the VTOTAL_EDP value. Same for VTOTAL_C. This is 	 * documented on the DDI_FUNC_CTL register description, EDP Input Select 	 * bits. */
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
operator|&&
name|cpu_transcoder
operator|==
name|TRANSCODER_EDP
operator|&&
operator|(
name|pipe
operator|==
name|PIPE_B
operator|||
name|pipe
operator|==
name|PIPE_C
operator|)
condition|)
name|I915_WRITE
argument_list|(
name|VTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|VTOTAL
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* pipesrc controls the size that is scaled from, which should 	 * always be the user's requested size. 	 */
name|I915_WRITE
argument_list|(
name|PIPESRC
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
operator|(
name|mode
operator|->
name|hdisplay
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|mode
operator|->
name|vdisplay
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i9xx_crtc_mode_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|int
name|refclk
decl_stmt|,
name|num_connectors
init|=
literal|0
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|,
name|reduced_clock
decl_stmt|;
name|u32
name|dspcntr
decl_stmt|,
name|pipeconf
decl_stmt|;
name|bool
name|ok
decl_stmt|,
name|has_reduced_clock
init|=
name|false
decl_stmt|,
name|is_sdvo
init|=
name|false
decl_stmt|;
name|bool
name|is_lvds
init|=
name|false
decl_stmt|,
name|is_tv
init|=
name|false
decl_stmt|,
name|is_dp
init|=
name|false
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
block|{
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|is_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_SDVO
case|:
case|case
name|INTEL_OUTPUT_HDMI
case|:
name|is_sdvo
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|encoder
operator|->
name|needs_tv_clock
condition|)
name|is_tv
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_TVOUT
case|:
name|is_tv
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_DISPLAYPORT
case|:
name|is_dp
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|num_connectors
operator|++
expr_stmt|;
block|}
name|refclk
operator|=
name|i9xx_get_refclk
argument_list|(
name|crtc
argument_list|,
name|num_connectors
argument_list|)
expr_stmt|;
comment|/* 	 * Returns a set of divisors for the desired target clock with the given 	 * refclk, or FALSE.  The returned values represent the clock equation: 	 * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2. 	 */
name|limit
operator|=
name|intel_limit
argument_list|(
name|crtc
argument_list|,
name|refclk
argument_list|)
expr_stmt|;
name|ok
operator|=
name|limit
operator|->
name|find_pll
argument_list|(
name|limit
argument_list|,
name|crtc
argument_list|,
name|adjusted_mode
operator|->
name|clock
argument_list|,
name|refclk
argument_list|,
name|NULL
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Couldn't find PLL settings for mode!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Ensure that the cursor is valid for the new mode before changing... */
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_lvds
operator|&&
name|dev_priv
operator|->
name|lvds_downclock_avail
condition|)
block|{
comment|/* 		 * Ensure we match the reduced clock's P to the target clock. 		 * If the clocks don't match, we can't switch the display clock 		 * by using the FP0/FP1. In such case we will disable the LVDS 		 * downclock feature. 		*/
name|has_reduced_clock
operator|=
name|limit
operator|->
name|find_pll
argument_list|(
name|limit
argument_list|,
name|crtc
argument_list|,
name|dev_priv
operator|->
name|lvds_downclock
argument_list|,
name|refclk
argument_list|,
operator|&
name|clock
argument_list|,
operator|&
name|reduced_clock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_sdvo
operator|&&
name|is_tv
condition|)
name|i9xx_adjust_sdvo_tv_clock
argument_list|(
name|adjusted_mode
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|i8xx_update_pll
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
argument_list|,
operator|&
name|clock
argument_list|,
name|has_reduced_clock
condition|?
operator|&
name|reduced_clock
else|:
name|NULL
argument_list|,
name|num_connectors
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|vlv_update_pll
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|,
operator|&
name|clock
argument_list|,
name|has_reduced_clock
condition|?
operator|&
name|reduced_clock
else|:
name|NULL
argument_list|,
name|num_connectors
argument_list|)
expr_stmt|;
else|else
name|i9xx_update_pll
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|,
operator|&
name|clock
argument_list|,
name|has_reduced_clock
condition|?
operator|&
name|reduced_clock
else|:
name|NULL
argument_list|,
name|num_connectors
argument_list|)
expr_stmt|;
comment|/* setup pipeconf */
name|pipeconf
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the display plane register */
name|dspcntr
operator|=
name|DISPPLANE_GAMMA_ENABLE
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
literal|0
condition|)
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_SEL_PIPE_MASK
expr_stmt|;
else|else
name|dspcntr
operator||=
name|DISPPLANE_SEL_PIPE_B
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
literal|0
operator|&&
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
condition|)
block|{
comment|/* Enable pixel doubling when the dot clock is> 90% of the (display) 		 * core speed. 		 * 		 * XXX: No double-wide on 915GM pipe B. Is that the only reason for the 		 * pipe == 0 check? 		 */
if|if
condition|(
name|mode
operator|->
name|clock
operator|>
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
argument_list|(
name|dev
argument_list|)
operator|*
literal|9
operator|/
literal|10
condition|)
name|pipeconf
operator||=
name|PIPECONF_DOUBLE_WIDE
expr_stmt|;
else|else
name|pipeconf
operator|&=
operator|~
name|PIPECONF_DOUBLE_WIDE
expr_stmt|;
block|}
comment|/* default to 8bpc */
name|pipeconf
operator|&=
operator|~
operator|(
name|PIPECONF_BPP_MASK
operator||
name|PIPECONF_DITHER_EN
operator|)
expr_stmt|;
if|if
condition|(
name|is_dp
condition|)
block|{
if|if
condition|(
name|adjusted_mode
operator|->
name|private_flags
operator|&
name|INTEL_MODE_DP_FORCE_6BPC
condition|)
block|{
name|pipeconf
operator||=
name|PIPECONF_BPP_6
operator||
name|PIPECONF_DITHER_EN
operator||
name|PIPECONF_DITHER_TYPE_SP
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
operator|&&
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_EDP
argument_list|)
condition|)
block|{
if|if
condition|(
name|adjusted_mode
operator|->
name|private_flags
operator|&
name|INTEL_MODE_DP_FORCE_6BPC
condition|)
block|{
name|pipeconf
operator||=
name|PIPECONF_BPP_6
operator||
name|PIPECONF_ENABLE
operator||
name|I965_PIPECONF_ACTIVE
expr_stmt|;
block|}
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"Mode for pipe %c:\n"
argument_list|,
name|pipe
operator|==
literal|0
condition|?
literal|'A'
else|:
literal|'B'
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PIPE_CXSR
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|intel_crtc
operator|->
name|lowfreq_avail
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"enabling CxSR downclocking\n"
argument_list|)
expr_stmt|;
name|pipeconf
operator||=
name|PIPECONF_CXSR_DOWNCLOCK
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabling CxSR downclocking\n"
argument_list|)
expr_stmt|;
name|pipeconf
operator|&=
operator|~
name|PIPECONF_CXSR_DOWNCLOCK
expr_stmt|;
block|}
block|}
name|pipeconf
operator|&=
operator|~
name|PIPECONF_INTERLACE_MASK
expr_stmt|;
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
operator|&&
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
condition|)
name|pipeconf
operator||=
name|PIPECONF_INTERLACE_W_FIELD_INDICATION
expr_stmt|;
else|else
name|pipeconf
operator||=
name|PIPECONF_PROGRESSIVE
expr_stmt|;
name|intel_set_pipe_timings
argument_list|(
name|intel_crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
comment|/* pipesrc and dspsize control the size that is scaled from, 	 * which should always be the user's requested size. 	 */
name|I915_WRITE
argument_list|(
name|DSPSIZE
argument_list|(
name|plane
argument_list|)
argument_list|,
operator|(
operator|(
name|mode
operator|->
name|vdisplay
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|mode
operator|->
name|hdisplay
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPPOS
argument_list|(
name|plane
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|pipeconf
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|intel_enable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|dspcntr
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_pipe_set_base
argument_list|(
name|crtc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|fb
argument_list|)
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_init_pch_refclk
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|bool
name|has_lvds
init|=
name|false
decl_stmt|;
name|bool
name|has_cpu_edp
init|=
name|false
decl_stmt|;
name|bool
name|has_pch_edp
init|=
name|false
decl_stmt|;
name|bool
name|has_panel
init|=
name|false
decl_stmt|;
name|bool
name|has_ck505
init|=
name|false
decl_stmt|;
name|bool
name|can_ssc
init|=
name|false
decl_stmt|;
comment|/* We need to take the global config into account */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|has_panel
operator|=
name|true
expr_stmt|;
name|has_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_EDP
case|:
name|has_panel
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|)
condition|)
name|has_pch_edp
operator|=
name|true
expr_stmt|;
else|else
name|has_cpu_edp
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|has_ck505
operator|=
name|dev_priv
operator|->
name|display_clock_mode
expr_stmt|;
name|can_ssc
operator|=
name|has_ck505
expr_stmt|;
block|}
else|else
block|{
name|has_ck505
operator|=
name|false
expr_stmt|;
name|can_ssc
operator|=
name|true
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"has_panel %d has_lvds %d has_pch_edp %d has_cpu_edp %d has_ck505 %d\n"
argument_list|,
name|has_panel
argument_list|,
name|has_lvds
argument_list|,
name|has_pch_edp
argument_list|,
name|has_cpu_edp
argument_list|,
name|has_ck505
argument_list|)
expr_stmt|;
comment|/* Ironlake: try to setup display ref clock before DPLL 	 * enabling. This is only under driver's control after 	 * PCH B stepping, previous chipset stepping should be 	 * ignoring this setting. 	 */
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
comment|/* Always enable nonspread source */
name|temp
operator|&=
operator|~
name|DREF_NONSPREAD_SOURCE_MASK
expr_stmt|;
if|if
condition|(
name|has_ck505
condition|)
name|temp
operator||=
name|DREF_NONSPREAD_CK505_ENABLE
expr_stmt|;
else|else
name|temp
operator||=
name|DREF_NONSPREAD_SOURCE_ENABLE
expr_stmt|;
if|if
condition|(
name|has_panel
condition|)
block|{
name|temp
operator|&=
operator|~
name|DREF_SSC_SOURCE_MASK
expr_stmt|;
name|temp
operator||=
name|DREF_SSC_SOURCE_ENABLE
expr_stmt|;
comment|/* SSC must be turned on before enabling the CPU output  */
if|if
condition|(
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|can_ssc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Using SSC on panel\n"
argument_list|)
expr_stmt|;
name|temp
operator||=
name|DREF_SSC1_ENABLE
expr_stmt|;
block|}
else|else
name|temp
operator|&=
operator|~
name|DREF_SSC1_ENABLE
expr_stmt|;
comment|/* Get SSC going before enabling the outputs */
name|I915_WRITE
argument_list|(
name|PCH_DREF_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|DREF_CPU_SOURCE_OUTPUT_MASK
expr_stmt|;
comment|/* Enable CPU source on CPU attached eDP */
if|if
condition|(
name|has_cpu_edp
condition|)
block|{
if|if
condition|(
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|can_ssc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Using SSC on eDP\n"
argument_list|)
expr_stmt|;
name|temp
operator||=
name|DREF_CPU_SOURCE_OUTPUT_DOWNSPREAD
expr_stmt|;
block|}
else|else
name|temp
operator||=
name|DREF_CPU_SOURCE_OUTPUT_NONSPREAD
expr_stmt|;
block|}
else|else
name|temp
operator||=
name|DREF_CPU_SOURCE_OUTPUT_DISABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DREF_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Disabling SSC entirely\n"
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|DREF_CPU_SOURCE_OUTPUT_MASK
expr_stmt|;
comment|/* Turn off CPU output */
name|temp
operator||=
name|DREF_CPU_SOURCE_OUTPUT_DISABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DREF_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Turn off the SSC source */
name|temp
operator|&=
operator|~
name|DREF_SSC_SOURCE_MASK
expr_stmt|;
name|temp
operator||=
name|DREF_SSC_SOURCE_DISABLE
expr_stmt|;
comment|/* Turn off SSC1 */
name|temp
operator|&=
operator|~
name|DREF_SSC1_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DREF_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sequence to enable CLKOUT_DP for FDI usage and configure PCH FDI I/O. */
end_comment

begin_function
specifier|static
name|void
name|lpt_init_pch_refclk
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|bool
name|has_vga
init|=
name|false
decl_stmt|;
name|bool
name|is_sdv
init|=
name|false
decl_stmt|;
name|u32
name|tmp
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_ANALOG
case|:
name|has_vga
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|has_vga
condition|)
return|return;
comment|/* XXX: Rip out SDV support once Haswell ships for real. */
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|dev
operator|->
name|pci_device
operator|&
literal|0xFF00
operator|)
operator|==
literal|0x0C00
condition|)
name|is_sdv
operator|=
name|true
expr_stmt|;
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCCTL
argument_list|,
name|SBI_ICLK
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
name|SBI_SSCCTL_DISABLE
expr_stmt|;
name|tmp
operator||=
name|SBI_SSCCTL_PATHALT
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCCTL
argument_list|,
name|tmp
argument_list|,
name|SBI_ICLK
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCCTL
argument_list|,
name|SBI_ICLK
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
name|SBI_SSCCTL_PATHALT
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCCTL
argument_list|,
name|tmp
argument_list|,
name|SBI_ICLK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_sdv
condition|)
block|{
name|tmp
operator|=
name|I915_READ
argument_list|(
name|SOUTH_CHICKEN2
argument_list|)
expr_stmt|;
name|tmp
operator||=
name|FDI_MPHY_IOSFSB_RESET_CTL
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SOUTH_CHICKEN2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_atomic_us
argument_list|(
name|I915_READ
argument_list|(
name|SOUTH_CHICKEN2
argument_list|)
operator|&
name|FDI_MPHY_IOSFSB_RESET_STATUS
argument_list|,
literal|100
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI mPHY reset assert timeout\n"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|I915_READ
argument_list|(
name|SOUTH_CHICKEN2
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
name|FDI_MPHY_IOSFSB_RESET_CTL
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SOUTH_CHICKEN2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_atomic_us
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|SOUTH_CHICKEN2
argument_list|)
operator|&
name|FDI_MPHY_IOSFSB_RESET_STATUS
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI mPHY reset de-assert timeout\n"
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x8008
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
operator|(
literal|0xFF
operator|<<
literal|24
operator|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|0x12
operator|<<
literal|24
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x8008
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_sdv
condition|)
block|{
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x808C
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
operator|(
literal|0x3
operator|<<
literal|6
operator|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x808C
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_sdv
condition|)
block|{
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x800C
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator||=
literal|0x7FFF
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x800C
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x2008
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|1
operator|<<
literal|11
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x2008
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x2108
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|1
operator|<<
literal|11
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x2108
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_sdv
condition|)
block|{
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x2038
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|0x3F
operator|<<
literal|24
operator|)
operator||
operator|(
literal|0xF
operator|<<
literal|20
operator|)
operator||
operator|(
literal|0xF
operator|<<
literal|16
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x2038
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x2138
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|0x3F
operator|<<
literal|24
operator|)
operator||
operator|(
literal|0xF
operator|<<
literal|20
operator|)
operator||
operator|(
literal|0xF
operator|<<
literal|16
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x2138
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x203C
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|0x3F
operator|<<
literal|8
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x203C
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x213C
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|0x3F
operator|<<
literal|8
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x213C
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x206C
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|1
operator|<<
literal|24
operator|)
operator||
operator|(
literal|1
operator|<<
literal|21
operator|)
operator||
operator|(
literal|1
operator|<<
literal|18
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x206C
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x216C
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|1
operator|<<
literal|24
operator|)
operator||
operator|(
literal|1
operator|<<
literal|21
operator|)
operator||
operator|(
literal|1
operator|<<
literal|18
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x216C
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_sdv
condition|)
block|{
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x2080
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|13
operator|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|5
operator|<<
literal|13
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x2080
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x2180
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|13
operator|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|5
operator|<<
literal|13
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x2180
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x208C
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
literal|0xFF
expr_stmt|;
name|tmp
operator||=
literal|0x1C
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x208C
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x218C
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
literal|0xFF
expr_stmt|;
name|tmp
operator||=
literal|0x1C
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x218C
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x2098
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
operator|(
literal|0xFF
operator|<<
literal|16
operator|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|0x1C
operator|<<
literal|16
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x2098
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x2198
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
operator|(
literal|0xFF
operator|<<
literal|16
operator|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|0x1C
operator|<<
literal|16
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x2198
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_sdv
condition|)
block|{
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x20C4
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|1
operator|<<
literal|27
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x20C4
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x21C4
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|1
operator|<<
literal|27
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x21C4
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x20EC
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
operator|(
literal|0xF
operator|<<
literal|28
operator|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|4
operator|<<
literal|28
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x20EC
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
literal|0x21EC
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
operator|(
literal|0xF
operator|<<
literal|28
operator|)
expr_stmt|;
name|tmp
operator||=
operator|(
literal|4
operator|<<
literal|28
operator|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
literal|0x21EC
argument_list|,
name|tmp
argument_list|,
name|SBI_MPHY
argument_list|)
expr_stmt|;
block|}
comment|/* ULT uses SBI_GEN0, but ULT doesn't have VGA, so we don't care. */
name|tmp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
name|SBI_DBUFF0
argument_list|,
name|SBI_ICLK
argument_list|)
expr_stmt|;
name|tmp
operator||=
name|SBI_DBUFF0_ENABLE
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
name|SBI_DBUFF0
argument_list|,
name|tmp
argument_list|,
name|SBI_ICLK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize reference clocks when the driver loads  */
end_comment

begin_function
name|void
name|intel_init_pch_refclk
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
operator|||
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
name|ironlake_init_pch_refclk
argument_list|(
name|dev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HAS_PCH_LPT
argument_list|(
name|dev
argument_list|)
condition|)
name|lpt_init_pch_refclk
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ironlake_get_refclk
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|edp_encoder
init|=
name|NULL
decl_stmt|;
name|int
name|num_connectors
init|=
literal|0
decl_stmt|;
name|bool
name|is_lvds
init|=
name|false
decl_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
block|{
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|is_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_EDP
case|:
name|edp_encoder
operator|=
name|encoder
expr_stmt|;
break|break;
block|}
name|num_connectors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|is_lvds
operator|&&
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|num_connectors
operator|<
literal|2
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"using SSC reference clock of %d MHz\n"
argument_list|,
name|dev_priv
operator|->
name|lvds_ssc_freq
argument_list|)
expr_stmt|;
return|return
name|dev_priv
operator|->
name|lvds_ssc_freq
operator|*
literal|1000
return|;
block|}
return|return
literal|120000
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_set_pipeconf
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|bool
name|dither
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|crtc
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|PIPE_BPC_MASK
expr_stmt|;
switch|switch
condition|(
name|intel_crtc
operator|->
name|bpp
condition|)
block|{
case|case
literal|18
case|:
name|val
operator||=
name|PIPE_6BPC
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|val
operator||=
name|PIPE_8BPC
expr_stmt|;
break|break;
case|case
literal|30
case|:
name|val
operator||=
name|PIPE_10BPC
expr_stmt|;
break|break;
case|case
literal|36
case|:
name|val
operator||=
name|PIPE_12BPC
expr_stmt|;
break|break;
default|default:
comment|/* Case prevented by intel_choose_pipe_bpp_dither. */
name|BUG
argument_list|()
expr_stmt|;
block|}
name|val
operator|&=
operator|~
operator|(
name|PIPECONF_DITHER_EN
operator||
name|PIPECONF_DITHER_TYPE_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|dither
condition|)
name|val
operator||=
operator|(
name|PIPECONF_DITHER_EN
operator||
name|PIPECONF_DITHER_TYPE_SP
operator|)
expr_stmt|;
name|val
operator|&=
operator|~
name|PIPECONF_INTERLACE_MASK
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
condition|)
name|val
operator||=
name|PIPECONF_INTERLACED_ILK
expr_stmt|;
else|else
name|val
operator||=
name|PIPECONF_PROGRESSIVE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|haswell_set_pipeconf
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|bool
name|dither
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|crtc
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|enum
name|transcoder
name|cpu_transcoder
init|=
name|intel_crtc
operator|->
name|cpu_transcoder
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|PIPECONF_DITHER_EN
operator||
name|PIPECONF_DITHER_TYPE_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|dither
condition|)
name|val
operator||=
operator|(
name|PIPECONF_DITHER_EN
operator||
name|PIPECONF_DITHER_TYPE_SP
operator|)
expr_stmt|;
name|val
operator|&=
operator|~
name|PIPECONF_INTERLACE_MASK_HSW
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
condition|)
name|val
operator||=
name|PIPECONF_INTERLACED_ILK
expr_stmt|;
else|else
name|val
operator||=
name|PIPECONF_PROGRESSIVE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPECONF
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PIPECONF
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ironlake_compute_clocks
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|,
name|bool
modifier|*
name|has_reduced_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|reduced_clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
decl_stmt|;
name|int
name|refclk
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
name|bool
name|ret
decl_stmt|,
name|is_sdvo
init|=
name|false
decl_stmt|,
name|is_tv
init|=
name|false
decl_stmt|,
name|is_lvds
init|=
name|false
decl_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|intel_encoder
argument_list|)
block|{
switch|switch
condition|(
name|intel_encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|is_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_SDVO
case|:
case|case
name|INTEL_OUTPUT_HDMI
case|:
name|is_sdvo
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|intel_encoder
operator|->
name|needs_tv_clock
condition|)
name|is_tv
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_TVOUT
case|:
name|is_tv
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
name|refclk
operator|=
name|ironlake_get_refclk
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* 	 * Returns a set of divisors for the desired target clock with the given 	 * refclk, or FALSE.  The returned values represent the clock equation: 	 * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2. 	 */
name|limit
operator|=
name|intel_limit
argument_list|(
name|crtc
argument_list|,
name|refclk
argument_list|)
expr_stmt|;
name|ret
operator|=
name|limit
operator|->
name|find_pll
argument_list|(
name|limit
argument_list|,
name|crtc
argument_list|,
name|adjusted_mode
operator|->
name|clock
argument_list|,
name|refclk
argument_list|,
name|NULL
argument_list|,
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|false
return|;
if|if
condition|(
name|is_lvds
operator|&&
name|dev_priv
operator|->
name|lvds_downclock_avail
condition|)
block|{
comment|/* 		 * Ensure we match the reduced clock's P to the target clock. 		 * If the clocks don't match, we can't switch the display clock 		 * by using the FP0/FP1. In such case we will disable the LVDS 		 * downclock feature. 		*/
operator|*
name|has_reduced_clock
operator|=
name|limit
operator|->
name|find_pll
argument_list|(
name|limit
argument_list|,
name|crtc
argument_list|,
name|dev_priv
operator|->
name|lvds_downclock
argument_list|,
name|refclk
argument_list|,
name|clock
argument_list|,
name|reduced_clock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_sdvo
operator|&&
name|is_tv
condition|)
name|i9xx_adjust_sdvo_tv_clock
argument_list|(
name|adjusted_mode
argument_list|,
name|clock
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cpt_enable_fdi_bc_bifurcation
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|SOUTH_CHICKEN1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_BC_BIFURCATION_SELECT
condition|)
return|return;
name|WARN_ON
argument_list|(
name|I915_READ
argument_list|(
name|FDI_RX_CTL
argument_list|(
name|PIPE_B
argument_list|)
argument_list|)
operator|&
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
name|I915_READ
argument_list|(
name|FDI_RX_CTL
argument_list|(
name|PIPE_C
argument_list|)
argument_list|)
operator|&
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|temp
operator||=
name|FDI_BC_BIFURCATION_SELECT
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"enabling fdi C rx\n"
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SOUTH_CHICKEN1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|SOUTH_CHICKEN1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ironlake_check_fdi_lanes
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_crtc
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|pipe_B_crtc
init|=
name|to_intel_crtc
argument_list|(
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|PIPE_B
index|]
argument_list|)
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"checking fdi config on pipe %i, lanes %i\n"
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|,
name|intel_crtc
operator|->
name|fdi_lanes
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|>
literal|4
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"invalid fdi lane config on pipe %i: %i lanes\n"
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|,
name|intel_crtc
operator|->
name|fdi_lanes
argument_list|)
expr_stmt|;
comment|/* Clamp lanes to avoid programming the hw with bogus values. */
name|intel_crtc
operator|->
name|fdi_lanes
operator|=
literal|4
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|num_pipe
operator|==
literal|2
condition|)
return|return
name|true
return|;
switch|switch
condition|(
name|intel_crtc
operator|->
name|pipe
condition|)
block|{
case|case
name|PIPE_A
case|:
return|return
name|true
return|;
case|case
name|PIPE_B
case|:
if|if
condition|(
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|PIPE_C
index|]
operator|->
name|enabled
operator|&&
name|intel_crtc
operator|->
name|fdi_lanes
operator|>
literal|2
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"invalid shared fdi lane config on pipe %i: %i lanes\n"
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|,
name|intel_crtc
operator|->
name|fdi_lanes
argument_list|)
expr_stmt|;
comment|/* Clamp lanes to avoid programming the hw with bogus values. */
name|intel_crtc
operator|->
name|fdi_lanes
operator|=
literal|2
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|>
literal|2
condition|)
name|WARN_ON
argument_list|(
name|I915_READ
argument_list|(
name|SOUTH_CHICKEN1
argument_list|)
operator|&
name|FDI_BC_BIFURCATION_SELECT
argument_list|)
expr_stmt|;
else|else
name|cpt_enable_fdi_bc_bifurcation
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PIPE_C
case|:
if|if
condition|(
operator|!
name|pipe_B_crtc
operator|->
name|base
operator|.
name|enabled
operator|||
name|pipe_B_crtc
operator|->
name|fdi_lanes
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|>
literal|2
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"invalid shared fdi lane config on pipe %i: %i lanes\n"
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|,
name|intel_crtc
operator|->
name|fdi_lanes
argument_list|)
expr_stmt|;
comment|/* Clamp lanes to avoid programming the hw with bogus values. */
name|intel_crtc
operator|->
name|fdi_lanes
operator|=
literal|2
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"fdi link B uses too many lanes to enable link C\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|cpt_enable_fdi_bc_bifurcation
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
name|BUG
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ironlake_get_lanes_required
parameter_list|(
name|int
name|target_clock
parameter_list|,
name|int
name|link_bw
parameter_list|,
name|int
name|bpp
parameter_list|)
block|{
comment|/* 	 * Account for spread spectrum to avoid 	 * oversubscribing the link. Max center spread 	 * is 2.5%; use 5% for safety's sake. 	 */
name|u32
name|bps
init|=
name|target_clock
operator|*
name|bpp
operator|*
literal|21
operator|/
literal|20
decl_stmt|;
return|return
name|bps
operator|/
operator|(
name|link_bw
operator|*
literal|8
operator|)
operator|+
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_set_m_n
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|enum
name|transcoder
name|cpu_transcoder
init|=
name|intel_crtc
operator|->
name|cpu_transcoder
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
decl_stmt|,
modifier|*
name|edp_encoder
init|=
name|NULL
decl_stmt|;
name|struct
name|fdi_m_n
name|m_n
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|target_clock
decl_stmt|,
name|pixel_multiplier
decl_stmt|,
name|lane
decl_stmt|,
name|link_bw
decl_stmt|;
name|bool
name|is_dp
init|=
name|false
decl_stmt|,
name|is_cpu_edp
init|=
name|false
decl_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|intel_encoder
argument_list|)
block|{
switch|switch
condition|(
name|intel_encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_DISPLAYPORT
case|:
name|is_dp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_EDP
case|:
name|is_dp
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|intel_encoder
operator|->
name|base
argument_list|)
condition|)
name|is_cpu_edp
operator|=
name|true
expr_stmt|;
name|edp_encoder
operator|=
name|intel_encoder
expr_stmt|;
break|break;
block|}
block|}
comment|/* FDI link */
name|pixel_multiplier
operator|=
name|intel_mode_get_pixel_multiplier
argument_list|(
name|adjusted_mode
argument_list|)
expr_stmt|;
name|lane
operator|=
literal|0
expr_stmt|;
comment|/* CPU eDP doesn't require FDI link, so just set DP M/N 	   according to current link config */
if|if
condition|(
name|is_cpu_edp
condition|)
block|{
name|intel_edp_link_config
argument_list|(
name|edp_encoder
argument_list|,
operator|&
name|lane
argument_list|,
operator|&
name|link_bw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FDI is a binary signal running at ~2.7GHz, encoding 		 * each output octet as 10 bits. The actual frequency 		 * is stored as a divider into a 100MHz clock, and the 		 * mode pixel clock is stored in units of 1KHz. 		 * Hence the bw of each lane in terms of the mode signal 		 * is: 		 */
name|link_bw
operator|=
name|intel_fdi_link_freq
argument_list|(
name|dev
argument_list|)
operator|*
name|MHz
argument_list|(
literal|100
argument_list|)
operator|/
name|KHz
argument_list|(
literal|1
argument_list|)
operator|/
literal|10
expr_stmt|;
block|}
comment|/* [e]DP over FDI requires target mode clock instead of link clock. */
if|if
condition|(
name|edp_encoder
condition|)
name|target_clock
operator|=
name|intel_edp_target_clock
argument_list|(
name|edp_encoder
argument_list|,
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_dp
condition|)
name|target_clock
operator|=
name|mode
operator|->
name|clock
expr_stmt|;
else|else
name|target_clock
operator|=
name|adjusted_mode
operator|->
name|clock
expr_stmt|;
if|if
condition|(
operator|!
name|lane
condition|)
name|lane
operator|=
name|ironlake_get_lanes_required
argument_list|(
name|target_clock
argument_list|,
name|link_bw
argument_list|,
name|intel_crtc
operator|->
name|bpp
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|fdi_lanes
operator|=
name|lane
expr_stmt|;
if|if
condition|(
name|pixel_multiplier
operator|>
literal|1
condition|)
name|link_bw
operator|*=
name|pixel_multiplier
expr_stmt|;
name|ironlake_compute_m_n
argument_list|(
name|intel_crtc
operator|->
name|bpp
argument_list|,
name|lane
argument_list|,
name|target_clock
argument_list|,
name|link_bw
argument_list|,
operator|&
name|m_n
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_DATA_M1
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|,
name|TU_SIZE
argument_list|(
name|m_n
operator|.
name|tu
argument_list|)
operator||
name|m_n
operator|.
name|gmch_m
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_DATA_N1
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|,
name|m_n
operator|.
name|gmch_n
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_LINK_M1
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|,
name|m_n
operator|.
name|link_m
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_LINK_N1
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|,
name|m_n
operator|.
name|link_n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|ironlake_compute_dpll
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|,
name|u32
name|fp
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
operator|&
name|intel_crtc
operator|->
name|base
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
decl_stmt|;
name|uint32_t
name|dpll
decl_stmt|;
name|int
name|factor
decl_stmt|,
name|pixel_multiplier
decl_stmt|,
name|num_connectors
init|=
literal|0
decl_stmt|;
name|bool
name|is_lvds
init|=
name|false
decl_stmt|,
name|is_sdvo
init|=
name|false
decl_stmt|,
name|is_tv
init|=
name|false
decl_stmt|;
name|bool
name|is_dp
init|=
name|false
decl_stmt|,
name|is_cpu_edp
init|=
name|false
decl_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|intel_encoder
argument_list|)
block|{
switch|switch
condition|(
name|intel_encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|is_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_SDVO
case|:
case|case
name|INTEL_OUTPUT_HDMI
case|:
name|is_sdvo
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|intel_encoder
operator|->
name|needs_tv_clock
condition|)
name|is_tv
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_TVOUT
case|:
name|is_tv
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_DISPLAYPORT
case|:
name|is_dp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_EDP
case|:
name|is_dp
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|intel_encoder
operator|->
name|base
argument_list|)
condition|)
name|is_cpu_edp
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|num_connectors
operator|++
expr_stmt|;
block|}
comment|/* Enable autotuning of the PLL clock (if permissible) */
name|factor
operator|=
literal|21
expr_stmt|;
if|if
condition|(
name|is_lvds
condition|)
block|{
if|if
condition|(
operator|(
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|dev_priv
operator|->
name|lvds_ssc_freq
operator|==
literal|100
operator|)
operator|||
operator|(
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
operator|&
name|LVDS_CLKB_POWER_MASK
operator|)
operator|==
name|LVDS_CLKB_POWER_UP
condition|)
name|factor
operator|=
literal|25
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_sdvo
operator|&&
name|is_tv
condition|)
name|factor
operator|=
literal|20
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|m
operator|<
name|factor
operator|*
name|clock
operator|->
name|n
condition|)
name|fp
operator||=
name|FP_CB_TUNE
expr_stmt|;
name|dpll
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_lvds
condition|)
name|dpll
operator||=
name|DPLLB_MODE_LVDS
expr_stmt|;
else|else
name|dpll
operator||=
name|DPLLB_MODE_DAC_SERIAL
expr_stmt|;
if|if
condition|(
name|is_sdvo
condition|)
block|{
name|pixel_multiplier
operator|=
name|intel_mode_get_pixel_multiplier
argument_list|(
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pixel_multiplier
operator|>
literal|1
condition|)
block|{
name|dpll
operator||=
operator|(
name|pixel_multiplier
operator|-
literal|1
operator|)
operator|<<
name|PLL_REF_SDVO_HDMI_MULTIPLIER_SHIFT
expr_stmt|;
block|}
name|dpll
operator||=
name|DPLL_DVO_HIGH_SPEED
expr_stmt|;
block|}
if|if
condition|(
name|is_dp
operator|&&
operator|!
name|is_cpu_edp
condition|)
name|dpll
operator||=
name|DPLL_DVO_HIGH_SPEED
expr_stmt|;
comment|/* compute bitmask from p1 value */
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|->
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT
expr_stmt|;
comment|/* also FPA1 */
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|->
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA1_P1_POST_DIV_SHIFT
expr_stmt|;
switch|switch
condition|(
name|clock
operator|->
name|p2
condition|)
block|{
case|case
literal|5
case|:
name|dpll
operator||=
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_5
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|dpll
operator||=
name|DPLLB_LVDS_P2_CLOCK_DIV_7
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|dpll
operator||=
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_10
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|dpll
operator||=
name|DPLLB_LVDS_P2_CLOCK_DIV_14
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_sdvo
operator|&&
name|is_tv
condition|)
name|dpll
operator||=
name|PLL_REF_INPUT_TVCLKINBC
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tv
condition|)
comment|/* XXX: just matching BIOS for now */
comment|/*	dpll |= PLL_REF_INPUT_TVCLKINBC; */
name|dpll
operator||=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|is_lvds
operator|&&
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|num_connectors
operator|<
literal|2
condition|)
name|dpll
operator||=
name|PLLB_REF_INPUT_SPREADSPECTRUMIN
expr_stmt|;
else|else
name|dpll
operator||=
name|PLL_REF_INPUT_DREFCLK
expr_stmt|;
return|return
name|dpll
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ironlake_crtc_mode_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|int
name|num_connectors
init|=
literal|0
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|,
name|reduced_clock
decl_stmt|;
name|u32
name|dpll
decl_stmt|,
name|fp
init|=
literal|0
decl_stmt|,
name|fp2
init|=
literal|0
decl_stmt|;
name|bool
name|ok
decl_stmt|,
name|has_reduced_clock
init|=
name|false
decl_stmt|;
name|bool
name|is_lvds
init|=
name|false
decl_stmt|,
name|is_dp
init|=
name|false
decl_stmt|,
name|is_cpu_edp
init|=
name|false
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|bool
name|dither
decl_stmt|,
name|fdi_config_ok
decl_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
block|{
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|is_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_DISPLAYPORT
case|:
name|is_dp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_EDP
case|:
name|is_dp
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|)
condition|)
name|is_cpu_edp
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|num_connectors
operator|++
expr_stmt|;
block|}
name|WARN
argument_list|(
operator|!
operator|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
operator|||
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|,
literal|"Unexpected PCH type %d\n"
argument_list|,
name|INTEL_PCH_TYPE
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|ironlake_compute_clocks
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
argument_list|,
operator|&
name|clock
argument_list|,
operator|&
name|has_reduced_clock
argument_list|,
operator|&
name|reduced_clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Couldn't find PLL settings for mode!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Ensure that the cursor is valid for the new mode before changing... */
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* determine panel color depth */
name|dither
operator|=
name|intel_choose_pipe_bpp_dither
argument_list|(
name|crtc
argument_list|,
name|fb
argument_list|,
operator|&
name|intel_crtc
operator|->
name|bpp
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_lvds
operator|&&
name|dev_priv
operator|->
name|lvds_dither
condition|)
name|dither
operator|=
name|true
expr_stmt|;
name|fp
operator|=
name|clock
operator|.
name|n
operator|<<
literal|16
operator||
name|clock
operator|.
name|m1
operator|<<
literal|8
operator||
name|clock
operator|.
name|m2
expr_stmt|;
if|if
condition|(
name|has_reduced_clock
condition|)
name|fp2
operator|=
name|reduced_clock
operator|.
name|n
operator|<<
literal|16
operator||
name|reduced_clock
operator|.
name|m1
operator|<<
literal|8
operator||
name|reduced_clock
operator|.
name|m2
expr_stmt|;
name|dpll
operator|=
name|ironlake_compute_dpll
argument_list|(
name|intel_crtc
argument_list|,
name|adjusted_mode
argument_list|,
operator|&
name|clock
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Mode for pipe %d:\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* CPU eDP is the only output that doesn't need a PCH PLL of its own. */
if|if
condition|(
operator|!
name|is_cpu_edp
condition|)
block|{
name|struct
name|intel_pch_pll
modifier|*
name|pll
decl_stmt|;
name|pll
operator|=
name|intel_get_pch_pll
argument_list|(
name|intel_crtc
argument_list|,
name|dpll
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"failed to find PLL for pipe %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
else|else
name|intel_put_pch_pll
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
comment|/* The LVDS pin pair needs to be on before the DPLLs are enabled. 	 * This is an exception to the general rule that mode_set doesn't turn 	 * things on. 	 */
if|if
condition|(
name|is_lvds
condition|)
block|{
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
expr_stmt|;
name|temp
operator||=
name|LVDS_PORT_EN
operator||
name|LVDS_A0A2_CLKA_POWER_UP
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|PORT_TRANS_SEL_MASK
expr_stmt|;
name|temp
operator||=
name|PORT_TRANS_SEL_CPT
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pipe
operator|==
literal|1
condition|)
name|temp
operator||=
name|LVDS_PIPEB_SELECT
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
name|LVDS_PIPEB_SELECT
expr_stmt|;
block|}
comment|/* set the corresponsding LVDS_BORDER bit */
name|temp
operator||=
name|dev_priv
operator|->
name|lvds_border_bits
expr_stmt|;
comment|/* Set the B0-B3 data pairs corresponding to whether we're going to 		 * set the DPLLs for dual-channel mode or not. 		 */
if|if
condition|(
name|clock
operator|.
name|p2
operator|==
literal|7
condition|)
name|temp
operator||=
name|LVDS_B0B3_POWER_UP
operator||
name|LVDS_CLKB_POWER_UP
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
operator|(
name|LVDS_B0B3_POWER_UP
operator||
name|LVDS_CLKB_POWER_UP
operator|)
expr_stmt|;
comment|/* It would be nice to set 24 vs 18-bit mode (LVDS_A3_POWER_UP) 		 * appropriately here, but we need to look more thoroughly into how 		 * panels behave in the two modes. 		 */
name|temp
operator|&=
operator|~
operator|(
name|LVDS_HSYNC_POLARITY
operator||
name|LVDS_VSYNC_POLARITY
operator|)
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NHSYNC
condition|)
name|temp
operator||=
name|LVDS_HSYNC_POLARITY
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NVSYNC
condition|)
name|temp
operator||=
name|LVDS_VSYNC_POLARITY
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_LVDS
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_dp
operator|&&
operator|!
name|is_cpu_edp
condition|)
block|{
name|intel_dp_set_m_n
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For non-DP output, clear any trans DP clock recovery setting.*/
name|I915_WRITE
argument_list|(
name|TRANSDATA_M1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDATA_N1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDPLINK_M1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDPLINK_N1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intel_crtc
operator|->
name|pch_pll
condition|)
block|{
name|I915_WRITE
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|pll_reg
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to stabilize. */
name|POSTING_READ
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* The pixel multiplier can only be updated once the 		 * DPLL is enabled and the clocks are stable. 		 * 		 * So write it again. 		 */
name|I915_WRITE
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|pll_reg
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
block|}
name|intel_crtc
operator|->
name|lowfreq_avail
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|pch_pll
condition|)
block|{
if|if
condition|(
name|is_lvds
operator|&&
name|has_reduced_clock
operator|&&
name|i915_powersave
condition|)
block|{
name|I915_WRITE
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|fp1_reg
argument_list|,
name|fp2
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|lowfreq_avail
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|I915_WRITE
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|fp1_reg
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|intel_set_pipe_timings
argument_list|(
name|intel_crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
comment|/* Note, this also computes intel_crtc->fdi_lanes which is used below in 	 * ironlake_check_fdi_lanes. */
name|ironlake_set_m_n
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
name|fdi_config_ok
operator|=
name|ironlake_check_fdi_lanes
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cpu_edp
condition|)
name|ironlake_set_pll_edp
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
operator|->
name|clock
argument_list|)
expr_stmt|;
name|ironlake_set_pipeconf
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
argument_list|,
name|dither
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* Set up the display plane register */
name|I915_WRITE
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|DISPPLANE_GAMMA_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_pipe_set_base
argument_list|(
name|crtc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|fb
argument_list|)
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_update_linetime_watermarks
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
return|return
name|fdi_config_ok
condition|?
name|ret
else|:
operator|-
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|haswell_crtc_mode_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|int
name|num_connectors
init|=
literal|0
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|,
name|reduced_clock
decl_stmt|;
name|u32
name|dpll
init|=
literal|0
decl_stmt|,
name|fp
init|=
literal|0
decl_stmt|,
name|fp2
init|=
literal|0
decl_stmt|;
name|bool
name|ok
decl_stmt|,
name|has_reduced_clock
init|=
name|false
decl_stmt|;
name|bool
name|is_lvds
init|=
name|false
decl_stmt|,
name|is_dp
init|=
name|false
decl_stmt|,
name|is_cpu_edp
init|=
name|false
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|bool
name|dither
decl_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
block|{
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|is_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_DISPLAYPORT
case|:
name|is_dp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_EDP
case|:
name|is_dp
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|)
condition|)
name|is_cpu_edp
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|num_connectors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|is_cpu_edp
condition|)
name|intel_crtc
operator|->
name|cpu_transcoder
operator|=
name|TRANSCODER_EDP
expr_stmt|;
else|else
name|intel_crtc
operator|->
name|cpu_transcoder
operator|=
name|pipe
expr_stmt|;
comment|/* We are not sure yet this won't happen. */
name|WARN
argument_list|(
operator|!
name|HAS_PCH_LPT
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"Unexpected PCH type %d\n"
argument_list|,
name|INTEL_PCH_TYPE
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
name|num_connectors
operator|!=
literal|1
argument_list|,
literal|"%d connectors attached to pipe %c\n"
argument_list|,
name|num_connectors
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|intel_crtc
operator|->
name|cpu_transcoder
argument_list|)
argument_list|)
operator|&
operator|(
name|PIPECONF_ENABLE
operator||
name|I965_PIPECONF_ACTIVE
operator|)
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
name|I915_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|)
operator|&
name|DISPLAY_PLANE_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_ddi_pll_mode_set
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
operator|->
name|clock
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
operator|||
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ok
operator|=
name|ironlake_compute_clocks
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
argument_list|,
operator|&
name|clock
argument_list|,
operator|&
name|has_reduced_clock
argument_list|,
operator|&
name|reduced_clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Couldn't find PLL settings for mode!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
comment|/* Ensure that the cursor is valid for the new mode before changing... */
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* determine panel color depth */
name|dither
operator|=
name|intel_choose_pipe_bpp_dither
argument_list|(
name|crtc
argument_list|,
name|fb
argument_list|,
operator|&
name|intel_crtc
operator|->
name|bpp
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_lvds
operator|&&
name|dev_priv
operator|->
name|lvds_dither
condition|)
name|dither
operator|=
name|true
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Mode for pipe %d:\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
operator|||
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|fp
operator|=
name|clock
operator|.
name|n
operator|<<
literal|16
operator||
name|clock
operator|.
name|m1
operator|<<
literal|8
operator||
name|clock
operator|.
name|m2
expr_stmt|;
if|if
condition|(
name|has_reduced_clock
condition|)
name|fp2
operator|=
name|reduced_clock
operator|.
name|n
operator|<<
literal|16
operator||
name|reduced_clock
operator|.
name|m1
operator|<<
literal|8
operator||
name|reduced_clock
operator|.
name|m2
expr_stmt|;
name|dpll
operator|=
name|ironlake_compute_dpll
argument_list|(
name|intel_crtc
argument_list|,
name|adjusted_mode
argument_list|,
operator|&
name|clock
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* CPU eDP is the only output that doesn't need a PCH PLL of its 		 * own on pre-Haswell/LPT generation */
if|if
condition|(
operator|!
name|is_cpu_edp
condition|)
block|{
name|struct
name|intel_pch_pll
modifier|*
name|pll
decl_stmt|;
name|pll
operator|=
name|intel_get_pch_pll
argument_list|(
name|intel_crtc
argument_list|,
name|dpll
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"failed to find PLL for pipe %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
else|else
name|intel_put_pch_pll
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
comment|/* The LVDS pin pair needs to be on before the DPLLs are 		 * enabled.  This is an exception to the general rule that 		 * mode_set doesn't turn things on. 		 */
if|if
condition|(
name|is_lvds
condition|)
block|{
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
expr_stmt|;
name|temp
operator||=
name|LVDS_PORT_EN
operator||
name|LVDS_A0A2_CLKA_POWER_UP
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|PORT_TRANS_SEL_MASK
expr_stmt|;
name|temp
operator||=
name|PORT_TRANS_SEL_CPT
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pipe
operator|==
literal|1
condition|)
name|temp
operator||=
name|LVDS_PIPEB_SELECT
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
name|LVDS_PIPEB_SELECT
expr_stmt|;
block|}
comment|/* set the corresponsding LVDS_BORDER bit */
name|temp
operator||=
name|dev_priv
operator|->
name|lvds_border_bits
expr_stmt|;
comment|/* Set the B0-B3 data pairs corresponding to whether 			 * we're going to set the DPLLs for dual-channel mode or 			 * not. 			 */
if|if
condition|(
name|clock
operator|.
name|p2
operator|==
literal|7
condition|)
name|temp
operator||=
name|LVDS_B0B3_POWER_UP
operator||
name|LVDS_CLKB_POWER_UP
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
operator|(
name|LVDS_B0B3_POWER_UP
operator||
name|LVDS_CLKB_POWER_UP
operator|)
expr_stmt|;
comment|/* It would be nice to set 24 vs 18-bit mode 			 * (LVDS_A3_POWER_UP) appropriately here, but we need to 			 * look more thoroughly into how panels behave in the 			 * two modes. 			 */
name|temp
operator|&=
operator|~
operator|(
name|LVDS_HSYNC_POLARITY
operator||
name|LVDS_VSYNC_POLARITY
operator|)
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NHSYNC
condition|)
name|temp
operator||=
name|LVDS_HSYNC_POLARITY
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NVSYNC
condition|)
name|temp
operator||=
name|LVDS_VSYNC_POLARITY
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_LVDS
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_dp
operator|&&
operator|!
name|is_cpu_edp
condition|)
block|{
name|intel_dp_set_m_n
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
operator|||
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* For non-DP output, clear any trans DP clock recovery 			 * setting.*/
name|I915_WRITE
argument_list|(
name|TRANSDATA_M1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDATA_N1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDPLINK_M1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDPLINK_N1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|intel_crtc
operator|->
name|lowfreq_avail
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
operator|||
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|intel_crtc
operator|->
name|pch_pll
condition|)
block|{
name|I915_WRITE
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|pll_reg
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to stabilize. */
name|POSTING_READ
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* The pixel multiplier can only be updated once the 			 * DPLL is enabled and the clocks are stable. 			 * 			 * So write it again. 			 */
name|I915_WRITE
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|pll_reg
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intel_crtc
operator|->
name|pch_pll
condition|)
block|{
if|if
condition|(
name|is_lvds
operator|&&
name|has_reduced_clock
operator|&&
name|i915_powersave
condition|)
block|{
name|I915_WRITE
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|fp1_reg
argument_list|,
name|fp2
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|lowfreq_avail
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|I915_WRITE
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|fp1_reg
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|intel_set_pipe_timings
argument_list|(
name|intel_crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_dp
operator|||
name|is_cpu_edp
condition|)
name|ironlake_set_m_n
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
operator|||
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
if|if
condition|(
name|is_cpu_edp
condition|)
name|ironlake_set_pll_edp
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
operator|->
name|clock
argument_list|)
expr_stmt|;
name|haswell_set_pipeconf
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
argument_list|,
name|dither
argument_list|)
expr_stmt|;
comment|/* Set up the display plane register */
name|I915_WRITE
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|DISPPLANE_GAMMA_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_pipe_set_base
argument_list|(
name|crtc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|fb
argument_list|)
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_update_linetime_watermarks
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_crtc_mode_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|drm_vblank_pre_modeset
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dev_priv
operator|->
name|display
operator|.
name|crtc_mode_set
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|fb
argument_list|)
expr_stmt|;
name|drm_vblank_post_modeset
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|crtc
argument_list|,
argument|encoder
argument_list|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"[ENCODER:%d:%s] set [MODE:%d:%s]\n"
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|)
argument_list|,
name|mode
operator|->
name|base
operator|.
name|id
argument_list|,
name|mode
operator|->
name|name
argument_list|)
expr_stmt|;
name|encoder_funcs
operator|=
name|encoder
operator|->
name|base
operator|.
name|helper_private
expr_stmt|;
name|encoder_funcs
operator|->
name|mode_set
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_eld_uptodate
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|int
name|reg_eldv
parameter_list|,
name|uint32_t
name|bits_eldv
parameter_list|,
name|int
name|reg_elda
parameter_list|,
name|uint32_t
name|bits_elda
parameter_list|,
name|int
name|reg_edid
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|connector
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint8_t
modifier|*
name|eld
init|=
name|connector
operator|->
name|eld
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|reg_eldv
argument_list|)
expr_stmt|;
name|i
operator|&=
name|bits_eldv
expr_stmt|;
if|if
condition|(
operator|!
name|eld
index|[
literal|0
index|]
condition|)
return|return
operator|!
name|i
return|;
if|if
condition|(
operator|!
name|i
condition|)
return|return
name|false
return|;
name|i
operator|=
name|I915_READ
argument_list|(
name|reg_elda
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|bits_elda
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg_elda
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eld
index|[
literal|2
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|I915_READ
argument_list|(
name|reg_edid
argument_list|)
operator|!=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|eld
operator|+
name|i
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g4x_write_eld
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|connector
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint8_t
modifier|*
name|eld
init|=
name|connector
operator|->
name|eld
decl_stmt|;
name|uint32_t
name|eldv
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|G4X_AUD_VID_DID
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|INTEL_AUDIO_DEVBLC
operator|||
name|i
operator|==
name|INTEL_AUDIO_DEVCL
condition|)
name|eldv
operator|=
name|G4X_ELDV_DEVCL_DEVBLC
expr_stmt|;
else|else
name|eldv
operator|=
name|G4X_ELDV_DEVCTG
expr_stmt|;
if|if
condition|(
name|intel_eld_uptodate
argument_list|(
name|connector
argument_list|,
name|G4X_AUD_CNTL_ST
argument_list|,
name|eldv
argument_list|,
name|G4X_AUD_CNTL_ST
argument_list|,
name|G4X_ELD_ADDR
argument_list|,
name|G4X_HDMIW_HDMIEDID
argument_list|)
condition|)
return|return;
name|i
operator|=
name|I915_READ
argument_list|(
name|G4X_AUD_CNTL_ST
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
operator|(
name|eldv
operator||
name|G4X_ELD_ADDR
operator|)
expr_stmt|;
name|len
operator|=
operator|(
name|i
operator|>>
literal|9
operator|)
operator|&
literal|0x1f
expr_stmt|;
comment|/* ELD buffer size */
name|I915_WRITE
argument_list|(
name|G4X_AUD_CNTL_ST
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eld
index|[
literal|0
index|]
condition|)
return|return;
name|len
operator|=
name|min_t
argument_list|(
name|uint8_t
argument_list|,
name|eld
index|[
literal|2
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"ELD size %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|G4X_HDMIW_HDMIEDID
argument_list|,
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|eld
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|G4X_AUD_CNTL_ST
argument_list|)
expr_stmt|;
name|i
operator||=
name|eldv
expr_stmt|;
name|I915_WRITE
argument_list|(
name|G4X_AUD_CNTL_ST
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|haswell_write_eld
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|connector
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint8_t
modifier|*
name|eld
init|=
name|connector
operator|->
name|eld
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|uint32_t
name|eldv
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|pipe
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|pipe
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|int
name|hdmiw_hdmiedid
init|=
name|HSW_AUD_EDID_DATA
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|int
name|aud_cntl_st
init|=
name|HSW_AUD_DIP_ELD_CTRL
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|int
name|aud_config
init|=
name|HSW_AUD_CFG
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|int
name|aud_cntrl_st2
init|=
name|HSW_AUD_PIN_ELD_CP_VLD
decl_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"HDMI: Haswell Audio initialize....\n"
argument_list|)
expr_stmt|;
comment|/* Audio output enable */
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"HDMI audio: enable codec\n"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|I915_READ
argument_list|(
name|aud_cntrl_st2
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
name|AUDIO_OUTPUT_ENABLE_A
operator|<<
operator|(
name|pipe
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_cntrl_st2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Wait for 1 vertical blank */
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* Set ELD valid state */
name|tmp
operator|=
name|I915_READ
argument_list|(
name|aud_cntrl_st2
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"HDMI audio: pin eld vld status=0x%8x\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
name|AUDIO_ELD_VALID_A
operator|<<
operator|(
name|pipe
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_cntrl_st2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|I915_READ
argument_list|(
name|aud_cntrl_st2
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"HDMI audio: eld vld status=0x%8x\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Enable HDMI mode */
name|tmp
operator|=
name|I915_READ
argument_list|(
name|aud_config
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"HDMI audio: audio conf: 0x%8x\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* clear N_programing_enable and N_value_index */
name|tmp
operator|&=
operator|~
operator|(
name|AUD_CONFIG_N_VALUE_INDEX
operator||
name|AUD_CONFIG_N_PROG_ENABLE
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_config
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"ELD on pipe %c\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|eldv
operator|=
name|AUDIO_ELD_VALID_A
operator|<<
operator|(
name|pipe
operator|*
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"ELD: DisplayPort detected\n"
argument_list|)
expr_stmt|;
name|eld
index|[
literal|5
index|]
operator||=
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* Conn_Type, 0x1 = DisplayPort */
name|I915_WRITE
argument_list|(
name|aud_config
argument_list|,
name|AUD_CONFIG_N_VALUE_INDEX
argument_list|)
expr_stmt|;
comment|/* 0x1 = DP */
block|}
else|else
name|I915_WRITE
argument_list|(
name|aud_config
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_eld_uptodate
argument_list|(
name|connector
argument_list|,
name|aud_cntrl_st2
argument_list|,
name|eldv
argument_list|,
name|aud_cntl_st
argument_list|,
name|IBX_ELD_ADDRESS
argument_list|,
name|hdmiw_hdmiedid
argument_list|)
condition|)
return|return;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntrl_st2
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|eldv
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_cntrl_st2
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eld
index|[
literal|0
index|]
condition|)
return|return;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntl_st
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|IBX_ELD_ADDRESS
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_cntl_st
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|>>
literal|29
operator|)
operator|&
name|DIP_PORT_SEL_MASK
expr_stmt|;
comment|/* DIP_Port_Select, 0x1 = PortB */
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"port num:%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len
operator|=
name|min_t
argument_list|(
name|uint8_t
argument_list|,
name|eld
index|[
literal|2
index|]
argument_list|,
literal|21
argument_list|)
expr_stmt|;
comment|/* 84 bytes of hw ELD buffer */
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"ELD size %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|hdmiw_hdmiedid
argument_list|,
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|eld
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntrl_st2
argument_list|)
expr_stmt|;
name|i
operator||=
name|eldv
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_cntrl_st2
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_write_eld
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|connector
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint8_t
modifier|*
name|eld
init|=
name|connector
operator|->
name|eld
decl_stmt|;
name|uint32_t
name|eldv
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hdmiw_hdmiedid
decl_stmt|;
name|int
name|aud_config
decl_stmt|;
name|int
name|aud_cntl_st
decl_stmt|;
name|int
name|aud_cntrl_st2
decl_stmt|;
name|int
name|pipe
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|pipe
decl_stmt|;
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|connector
operator|->
name|dev
argument_list|)
condition|)
block|{
name|hdmiw_hdmiedid
operator|=
name|IBX_HDMIW_HDMIEDID
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|aud_config
operator|=
name|IBX_AUD_CFG
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|aud_cntl_st
operator|=
name|IBX_AUD_CNTL_ST
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|aud_cntrl_st2
operator|=
name|IBX_AUD_CNTL_ST2
expr_stmt|;
block|}
else|else
block|{
name|hdmiw_hdmiedid
operator|=
name|CPT_HDMIW_HDMIEDID
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|aud_config
operator|=
name|CPT_AUD_CFG
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|aud_cntl_st
operator|=
name|CPT_AUD_CNTL_ST
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|aud_cntrl_st2
operator|=
name|CPT_AUD_CNTRL_ST2
expr_stmt|;
block|}
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"ELD on pipe %c\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntl_st
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|>>
literal|29
operator|)
operator|&
name|DIP_PORT_SEL_MASK
expr_stmt|;
comment|/* DIP_Port_Select, 0x1 = PortB */
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"Audio directed to unknown port\n"
argument_list|)
expr_stmt|;
comment|/* operate blindly on all ports */
name|eldv
operator|=
name|IBX_ELD_VALIDB
expr_stmt|;
name|eldv
operator||=
name|IBX_ELD_VALIDB
operator|<<
literal|4
expr_stmt|;
name|eldv
operator||=
name|IBX_ELD_VALIDB
operator|<<
literal|8
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"ELD on port %c\n"
argument_list|,
literal|'A'
operator|+
name|i
argument_list|)
expr_stmt|;
name|eldv
operator|=
name|IBX_ELD_VALIDB
operator|<<
operator|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"ELD: DisplayPort detected\n"
argument_list|)
expr_stmt|;
name|eld
index|[
literal|5
index|]
operator||=
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* Conn_Type, 0x1 = DisplayPort */
name|I915_WRITE
argument_list|(
name|aud_config
argument_list|,
name|AUD_CONFIG_N_VALUE_INDEX
argument_list|)
expr_stmt|;
comment|/* 0x1 = DP */
block|}
else|else
name|I915_WRITE
argument_list|(
name|aud_config
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_eld_uptodate
argument_list|(
name|connector
argument_list|,
name|aud_cntrl_st2
argument_list|,
name|eldv
argument_list|,
name|aud_cntl_st
argument_list|,
name|IBX_ELD_ADDRESS
argument_list|,
name|hdmiw_hdmiedid
argument_list|)
condition|)
return|return;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntrl_st2
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|eldv
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_cntrl_st2
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eld
index|[
literal|0
index|]
condition|)
return|return;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntl_st
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|IBX_ELD_ADDRESS
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_cntl_st
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len
operator|=
name|min_t
argument_list|(
name|uint8_t
argument_list|,
name|eld
index|[
literal|2
index|]
argument_list|,
literal|21
argument_list|)
expr_stmt|;
comment|/* 84 bytes of hw ELD buffer */
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"ELD size %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|hdmiw_hdmiedid
argument_list|,
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|eld
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntrl_st2
argument_list|)
expr_stmt|;
name|i
operator||=
name|eldv
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_cntrl_st2
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_write_eld
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|encoder
operator|->
name|crtc
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|connector
operator|=
name|drm_select_eld
argument_list|(
name|encoder
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|connector
condition|)
return|return;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"ELD on [CONNECTOR:%d:%s], [ENCODER:%d:%s]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|connector
operator|->
name|encoder
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
name|connector
operator|->
name|encoder
argument_list|)
argument_list|)
expr_stmt|;
name|connector
operator|->
name|eld
index|[
literal|6
index|]
operator|=
name|drm_av_sync_delay
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
argument_list|(
name|connector
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Loads the palette/gamma unit for the CRTC with the prepared values */
end_comment

begin_function
name|void
name|intel_crtc_load_lut
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|palreg
init|=
name|PALETTE
argument_list|(
name|intel_crtc
operator|->
name|pipe
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The clocks have to be on to load the palette. */
if|if
condition|(
operator|!
name|crtc
operator|->
name|enabled
operator|||
operator|!
name|intel_crtc
operator|->
name|active
condition|)
return|return;
comment|/* use legacy palette for Ironlake */
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|palreg
operator|=
name|LGC_PALETTE
argument_list|(
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|I915_WRITE
argument_list|(
name|palreg
operator|+
literal|4
operator|*
name|i
argument_list|,
operator|(
name|intel_crtc
operator|->
name|lut_r
index|[
name|i
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|intel_crtc
operator|->
name|lut_g
index|[
name|i
index|]
operator|<<
literal|8
operator|)
operator||
name|intel_crtc
operator|->
name|lut_b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i845_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u32
name|base
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|bool
name|visible
init|=
name|base
operator|!=
literal|0
decl_stmt|;
name|u32
name|cntl
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_visible
operator|==
name|visible
condition|)
return|return;
name|cntl
operator|=
name|I915_READ
argument_list|(
name|_CURACNTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|visible
condition|)
block|{
comment|/* On these chipsets we can only modify the base whilst 		 * the cursor is disabled. 		 */
name|I915_WRITE
argument_list|(
name|_CURABASE
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_FORMAT_MASK
operator|)
expr_stmt|;
comment|/* XXX width must be 64, stride 256 => 0x00<< 28 */
name|cntl
operator||=
name|CURSOR_ENABLE
operator||
name|CURSOR_GAMMA_ENABLE
operator||
name|CURSOR_FORMAT_ARGB
expr_stmt|;
block|}
else|else
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_ENABLE
operator||
name|CURSOR_GAMMA_ENABLE
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_CURACNTR
argument_list|,
name|cntl
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_visible
operator|=
name|visible
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u32
name|base
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|bool
name|visible
init|=
name|base
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_visible
operator|!=
name|visible
condition|)
block|{
name|uint32_t
name|cntl
init|=
name|I915_READ
argument_list|(
name|CURCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_MODE
operator||
name|MCURSOR_PIPE_SELECT
operator|)
expr_stmt|;
name|cntl
operator||=
name|CURSOR_MODE_64_ARGB_AX
operator||
name|MCURSOR_GAMMA_ENABLE
expr_stmt|;
name|cntl
operator||=
name|pipe
operator|<<
literal|28
expr_stmt|;
comment|/* Connect to correct pipe */
block|}
else|else
block|{
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_MODE
operator||
name|MCURSOR_GAMMA_ENABLE
operator|)
expr_stmt|;
name|cntl
operator||=
name|CURSOR_MODE_DISABLE
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|CURCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|cntl
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_visible
operator|=
name|visible
expr_stmt|;
block|}
comment|/* and commit changes on next vblank */
name|I915_WRITE
argument_list|(
name|CURBASE
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ivb_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u32
name|base
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|bool
name|visible
init|=
name|base
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_visible
operator|!=
name|visible
condition|)
block|{
name|uint32_t
name|cntl
init|=
name|I915_READ
argument_list|(
name|CURCNTR_IVB
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|cntl
operator|&=
operator|~
name|CURSOR_MODE
expr_stmt|;
name|cntl
operator||=
name|CURSOR_MODE_64_ARGB_AX
operator||
name|MCURSOR_GAMMA_ENABLE
expr_stmt|;
block|}
else|else
block|{
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_MODE
operator||
name|MCURSOR_GAMMA_ENABLE
operator|)
expr_stmt|;
name|cntl
operator||=
name|CURSOR_MODE_DISABLE
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|CURCNTR_IVB
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|cntl
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_visible
operator|=
name|visible
expr_stmt|;
block|}
comment|/* and commit changes on next vblank */
name|I915_WRITE
argument_list|(
name|CURBASE_IVB
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If no-part of the cursor is visible on the framebuffer, then the GPU may hang... */
end_comment

begin_function
specifier|static
name|void
name|intel_crtc_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|x
init|=
name|intel_crtc
operator|->
name|cursor_x
decl_stmt|;
name|int
name|y
init|=
name|intel_crtc
operator|->
name|cursor_y
decl_stmt|;
name|u32
name|base
decl_stmt|,
name|pos
decl_stmt|;
name|bool
name|visible
decl_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|on
operator|&&
name|crtc
operator|->
name|enabled
operator|&&
name|crtc
operator|->
name|fb
condition|)
block|{
name|base
operator|=
name|intel_crtc
operator|->
name|cursor_addr
expr_stmt|;
if|if
condition|(
name|x
operator|>
operator|(
name|int
operator|)
name|crtc
operator|->
name|fb
operator|->
name|width
condition|)
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y
operator|>
operator|(
name|int
operator|)
name|crtc
operator|->
name|fb
operator|->
name|height
condition|)
name|base
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|+
name|intel_crtc
operator|->
name|cursor_width
operator|<
literal|0
condition|)
name|base
operator|=
literal|0
expr_stmt|;
name|pos
operator||=
name|CURSOR_POS_SIGN
operator|<<
name|CURSOR_X_SHIFT
expr_stmt|;
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
name|pos
operator||=
name|x
operator|<<
name|CURSOR_X_SHIFT
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|+
name|intel_crtc
operator|->
name|cursor_height
operator|<
literal|0
condition|)
name|base
operator|=
literal|0
expr_stmt|;
name|pos
operator||=
name|CURSOR_POS_SIGN
operator|<<
name|CURSOR_Y_SHIFT
expr_stmt|;
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
name|pos
operator||=
name|y
operator|<<
name|CURSOR_Y_SHIFT
expr_stmt|;
name|visible
operator|=
name|base
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|visible
operator|&&
operator|!
name|intel_crtc
operator|->
name|cursor_visible
condition|)
return|return;
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|CURPOS_IVB
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|ivb_update_cursor
argument_list|(
name|crtc
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|I915_WRITE
argument_list|(
name|CURPOS
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_845G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I865G
argument_list|(
name|dev
argument_list|)
condition|)
name|i845_update_cursor
argument_list|(
name|crtc
argument_list|,
name|base
argument_list|)
expr_stmt|;
else|else
name|i9xx_update_cursor
argument_list|(
name|crtc
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|intel_crtc_cursor_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|uint32_t
name|handle
parameter_list|,
name|uint32_t
name|width
parameter_list|,
name|uint32_t
name|height
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* if we want to turn off the cursor ignore width and height */
if|if
condition|(
operator|!
name|handle
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"cursor off\n"
argument_list|)
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* Currently we only support 64x64 cursors */
if|if
condition|(
name|width
operator|!=
literal|64
operator|||
name|height
operator|!=
literal|64
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"we currently only support 64x64 cursors\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOENT
return|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|size
operator|<
name|width
operator|*
name|height
operator|*
literal|4
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"buffer is to small\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* we only need to pin inside GTT if cursor is non-phy */
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|info
operator|->
name|cursor_needs_physical
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|tiling_mode
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"cursor cannot be tiled\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|fail_locked
goto|;
block|}
name|ret
operator|=
name|i915_gem_object_pin_to_display_plane
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to move cursor bo into the GTT\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_locked
goto|;
block|}
name|ret
operator|=
name|i915_gem_object_put_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to release fence for cursor"
argument_list|)
expr_stmt|;
goto|goto
name|fail_unpin
goto|;
block|}
name|addr
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
block|}
else|else
block|{
name|int
name|align
init|=
name|IS_I830
argument_list|(
name|dev
argument_list|)
condition|?
literal|16
operator|*
literal|1024
else|:
literal|256
decl_stmt|;
name|ret
operator|=
name|i915_gem_attach_phys_object
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
operator|(
name|intel_crtc
operator|->
name|pipe
operator|==
literal|0
operator|)
condition|?
name|I915_GEM_PHYS_CURSOR_0
else|:
name|I915_GEM_PHYS_CURSOR_1
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to attach phys object\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_locked
goto|;
block|}
name|addr
operator|=
name|obj
operator|->
name|phys_obj
operator|->
name|handle
operator|->
name|busaddr
expr_stmt|;
block|}
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|CURSIZE
argument_list|,
operator|(
name|height
operator|<<
literal|12
operator|)
operator||
name|width
argument_list|)
expr_stmt|;
name|finish
label|:
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_bo
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|info
operator|->
name|cursor_needs_physical
condition|)
block|{
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_bo
operator|!=
name|obj
condition|)
name|i915_gem_detach_phys_object
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|cursor_bo
argument_list|)
expr_stmt|;
block|}
else|else
name|i915_gem_object_unpin
argument_list|(
name|intel_crtc
operator|->
name|cursor_bo
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|intel_crtc
operator|->
name|cursor_bo
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_addr
operator|=
name|addr
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_bo
operator|=
name|obj
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_width
operator|=
name|width
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_height
operator|=
name|height
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail_unpin
label|:
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|fail_locked
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fail
label|:
name|drm_gem_object_unreference_unlocked
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_crtc_cursor_move
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|intel_crtc
operator|->
name|cursor_x
operator|=
name|x
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_y
operator|=
name|y
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Sets the color ramps on behalf of RandR */
end_comment

begin_function
name|void
name|intel_crtc_fb_gamma_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u16
name|red
parameter_list|,
name|u16
name|green
parameter_list|,
name|u16
name|blue
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|intel_crtc
operator|->
name|lut_r
index|[
name|regno
index|]
operator|=
name|red
operator|>>
literal|8
expr_stmt|;
name|intel_crtc
operator|->
name|lut_g
index|[
name|regno
index|]
operator|=
name|green
operator|>>
literal|8
expr_stmt|;
name|intel_crtc
operator|->
name|lut_b
index|[
name|regno
index|]
operator|=
name|blue
operator|>>
literal|8
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_crtc_fb_gamma_get
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u16
modifier|*
name|red
parameter_list|,
name|u16
modifier|*
name|green
parameter_list|,
name|u16
modifier|*
name|blue
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
operator|*
name|red
operator|=
name|intel_crtc
operator|->
name|lut_r
index|[
name|regno
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|green
operator|=
name|intel_crtc
operator|->
name|lut_g
index|[
name|regno
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|blue
operator|=
name|intel_crtc
operator|->
name|lut_b
index|[
name|regno
index|]
operator|<<
literal|8
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_gamma_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u16
modifier|*
name|red
parameter_list|,
name|u16
modifier|*
name|green
parameter_list|,
name|u16
modifier|*
name|blue
parameter_list|,
name|uint32_t
name|start
parameter_list|,
name|uint32_t
name|size
parameter_list|)
block|{
name|int
name|end
init|=
operator|(
name|start
operator|+
name|size
operator|>
literal|256
operator|)
condition|?
literal|256
else|:
name|start
operator|+
name|size
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|intel_crtc
operator|->
name|lut_r
index|[
name|i
index|]
operator|=
name|red
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
name|intel_crtc
operator|->
name|lut_g
index|[
name|i
index|]
operator|=
name|green
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
name|intel_crtc
operator|->
name|lut_b
index|[
name|i
index|]
operator|=
name|blue
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
block|}
name|intel_crtc_load_lut
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Get a pipe with a simple mode set on it for doing load-based monitor  * detection.  *  * It will be up to the load-detect code to adjust the pipe as appropriate for  * its requirements.  The pipe will be connected to no other encoders.  *  * Currently this code will only succeed if there is a pipe with no encoders  * configured for it.  In the future, it could choose to temporarily disable  * some outputs to free up a pipe for its use.  *  * \return crtc, or NULL if no pipes are available.  */
end_comment

begin_comment
comment|/* VESA 640x480x72Hz mode to set on the pipe */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|drm_display_mode
name|load_detect_mode
init|=
block|{
name|DRM_MODE
argument_list|(
literal|"640x480"
argument_list|,
name|DRM_MODE_TYPE_DEFAULT
argument_list|,
literal|31500
argument_list|,
literal|640
argument_list|,
literal|664
argument_list|,
literal|704
argument_list|,
literal|832
argument_list|,
literal|0
argument_list|,
literal|480
argument_list|,
literal|489
argument_list|,
literal|491
argument_list|,
literal|520
argument_list|,
literal|0
argument_list|,
name|DRM_MODE_FLAG_NHSYNC
operator||
name|DRM_MODE_FLAG_NVSYNC
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|intel_framebuffer_create
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_mode_fb_cmd2
modifier|*
name|mode_cmd
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|intel_fb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|intel_fb
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_fb
condition|)
block|{
name|drm_gem_object_unreference_unlocked
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|ret
operator|=
name|intel_framebuffer_init
argument_list|(
name|dev
argument_list|,
name|intel_fb
argument_list|,
name|mode_cmd
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|drm_gem_object_unreference_unlocked
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intel_fb
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
operator|*
name|res
operator|=
operator|&
name|intel_fb
operator|->
name|base
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|intel_framebuffer_pitch_for_width
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|bpp
parameter_list|)
block|{
name|u32
name|pitch
init|=
name|DIV_ROUND_UP
argument_list|(
name|width
operator|*
name|bpp
argument_list|,
literal|8
argument_list|)
decl_stmt|;
return|return
name|roundup2
argument_list|(
name|pitch
argument_list|,
literal|64
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|intel_framebuffer_size_for_mode
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|int
name|bpp
parameter_list|)
block|{
name|u32
name|pitch
init|=
name|intel_framebuffer_pitch_for_width
argument_list|(
name|mode
operator|->
name|hdisplay
argument_list|,
name|bpp
argument_list|)
decl_stmt|;
return|return
name|roundup2
argument_list|(
name|pitch
operator|*
name|mode
operator|->
name|vdisplay
argument_list|,
name|PAGE_SIZE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_framebuffer_create_for_mode
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|bpp
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_mode_fb_cmd2
name|mode_cmd
init|=
block|{
literal|0
block|}
decl_stmt|;
name|obj
operator|=
name|i915_gem_alloc_object
argument_list|(
name|dev
argument_list|,
name|intel_framebuffer_size_for_mode
argument_list|(
name|mode
argument_list|,
name|bpp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|mode_cmd
operator|.
name|width
operator|=
name|mode
operator|->
name|hdisplay
expr_stmt|;
name|mode_cmd
operator|.
name|height
operator|=
name|mode
operator|->
name|vdisplay
expr_stmt|;
name|mode_cmd
operator|.
name|pitches
index|[
literal|0
index|]
operator|=
name|intel_framebuffer_pitch_for_width
argument_list|(
name|mode_cmd
operator|.
name|width
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
name|mode_cmd
operator|.
name|pixel_format
operator|=
name|drm_mode_legacy_fb_format
argument_list|(
name|bpp
argument_list|,
name|depth
argument_list|)
expr_stmt|;
return|return
name|intel_framebuffer_create
argument_list|(
name|dev
argument_list|,
operator|&
name|mode_cmd
argument_list|,
name|obj
argument_list|,
name|res
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_framebuffer
modifier|*
name|mode_fits_in_fbdev
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|fbdev
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|obj
operator|=
name|dev_priv
operator|->
name|fbdev
operator|->
name|ifb
operator|.
name|obj
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|fb
operator|=
operator|&
name|dev_priv
operator|->
name|fbdev
operator|->
name|ifb
operator|.
name|base
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|<
name|intel_framebuffer_pitch_for_width
argument_list|(
name|mode
operator|->
name|hdisplay
argument_list|,
name|fb
operator|->
name|bits_per_pixel
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|size
operator|<
name|mode
operator|->
name|vdisplay
operator|*
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
return|return
name|fb
return|;
block|}
end_function

begin_function
name|bool
name|intel_get_load_detect_pipe
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|intel_load_detect_pipe
modifier|*
name|old
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
init|=
name|intel_attached_encoder
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|possible_crtc
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
operator|&
name|intel_encoder
operator|->
name|base
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s], [ENCODER:%d:%s]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
name|encoder
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Algorithm gets a little messy: 	 * 	 *   - if the connector already has an assigned crtc, use it (but make 	 *     sure it's on first) 	 * 	 *   - try to find the first unused crtc that can drive this connector, 	 *     and use that if we find one 	 */
comment|/* See if we already have a CRTC for this connector */
if|if
condition|(
name|encoder
operator|->
name|crtc
condition|)
block|{
name|crtc
operator|=
name|encoder
operator|->
name|crtc
expr_stmt|;
name|old
operator|->
name|dpms_mode
operator|=
name|connector
operator|->
name|dpms
expr_stmt|;
name|old
operator|->
name|load_detect_temp
operator|=
name|false
expr_stmt|;
comment|/* Make sure the crtc and connector are running */
if|if
condition|(
name|connector
operator|->
name|dpms
operator|!=
name|DRM_MODE_DPMS_ON
condition|)
name|connector
operator|->
name|funcs
operator|->
name|dpms
argument_list|(
name|connector
argument_list|,
name|DRM_MODE_DPMS_ON
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Find an unused one (if possible) */
name|list_for_each_entry
argument_list|(
argument|possible_crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|encoder
operator|->
name|possible_crtcs
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|possible_crtc
operator|->
name|enabled
condition|)
block|{
name|crtc
operator|=
name|possible_crtc
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If we didn't find an unused CRTC, don't use any. 	 */
if|if
condition|(
operator|!
name|crtc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"no pipe available for load-detect\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|intel_encoder
operator|->
name|new_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|to_intel_connector
argument_list|(
name|connector
argument_list|)
operator|->
name|new_encoder
operator|=
name|intel_encoder
expr_stmt|;
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|old
operator|->
name|dpms_mode
operator|=
name|connector
operator|->
name|dpms
expr_stmt|;
name|old
operator|->
name|load_detect_temp
operator|=
name|true
expr_stmt|;
name|old
operator|->
name|release_fb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
name|mode
operator|=
operator|&
name|load_detect_mode
expr_stmt|;
comment|/* We need a framebuffer large enough to accommodate all accesses 	 * that the plane may generate whilst we perform load detection. 	 * We can not rely on the fbcon either being present (we get called 	 * during its initialisation to detect all boot displays, or it may 	 * not even exist) or that it is large enough to satisfy the 	 * requested mode. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
name|fb
operator|=
name|mode_fits_in_fbdev
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"creating tmp fb for load-detection\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_framebuffer_create_for_mode
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|,
literal|24
argument_list|,
literal|32
argument_list|,
operator|&
name|fb
argument_list|)
expr_stmt|;
name|old
operator|->
name|release_fb
operator|=
name|fb
expr_stmt|;
block|}
else|else
name|DRM_DEBUG_KMS
argument_list|(
literal|"reusing fbdev for load-detection framebuffer\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"failed to allocate framebuffer for load-detection\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|intel_set_mode
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|fb
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"failed to set mode on load-detect pipe\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|release_fb
condition|)
name|old
operator|->
name|release_fb
operator|->
name|funcs
operator|->
name|destroy
argument_list|(
name|old
operator|->
name|release_fb
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* let the connector get through one full cycle before testing */
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|intel_release_load_detect_pipe
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|intel_load_detect_pipe
modifier|*
name|old
parameter_list|)
block|{
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
init|=
name|intel_attached_encoder
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
operator|&
name|intel_encoder
operator|->
name|base
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s], [ENCODER:%d:%s]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
name|encoder
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|load_detect_temp
condition|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|encoder
operator|->
name|crtc
decl_stmt|;
name|to_intel_connector
argument_list|(
name|connector
argument_list|)
operator|->
name|new_encoder
operator|=
name|NULL
expr_stmt|;
name|intel_encoder
operator|->
name|new_crtc
operator|=
name|NULL
expr_stmt|;
name|intel_set_mode
argument_list|(
name|crtc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|release_fb
condition|)
name|old
operator|->
name|release_fb
operator|->
name|funcs
operator|->
name|destroy
argument_list|(
name|old
operator|->
name|release_fb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Switch crtc and encoder back off if necessary */
if|if
condition|(
name|old
operator|->
name|dpms_mode
operator|!=
name|DRM_MODE_DPMS_ON
condition|)
name|connector
operator|->
name|funcs
operator|->
name|dpms
argument_list|(
name|connector
argument_list|,
name|old
operator|->
name|dpms_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the clock of the currently programmed mode of the given pipe. */
end_comment

begin_function
specifier|static
name|int
name|intel_crtc_clock_get
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|dpll
init|=
name|I915_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
name|u32
name|fp
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|;
if|if
condition|(
operator|(
name|dpll
operator|&
name|DISPLAY_RATE_SELECT_FPA1
operator|)
operator|==
literal|0
condition|)
name|fp
operator|=
name|I915_READ
argument_list|(
name|FP0
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fp
operator|=
name|I915_READ
argument_list|(
name|FP1
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
operator|(
name|fp
operator|&
name|FP_M1_DIV_MASK
operator|)
operator|>>
name|FP_M1_DIV_SHIFT
expr_stmt|;
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|clock
operator|.
name|n
operator|=
name|ffs
argument_list|(
operator|(
name|fp
operator|&
name|FP_N_PINEVIEW_DIV_MASK
operator|)
operator|>>
name|FP_N_DIV_SHIFT
argument_list|)
operator|-
literal|1
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
operator|(
name|fp
operator|&
name|FP_M2_PINEVIEW_DIV_MASK
operator|)
operator|>>
name|FP_M2_DIV_SHIFT
expr_stmt|;
block|}
else|else
block|{
name|clock
operator|.
name|n
operator|=
operator|(
name|fp
operator|&
name|FP_N_DIV_MASK
operator|)
operator|>>
name|FP_N_DIV_SHIFT
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
operator|(
name|fp
operator|&
name|FP_M2_DIV_MASK
operator|)
operator|>>
name|FP_M2_DIV_SHIFT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|clock
operator|.
name|p1
operator|=
name|ffs
argument_list|(
operator|(
name|dpll
operator|&
name|DPLL_FPA01_P1_POST_DIV_MASK_PINEVIEW
operator|)
operator|>>
name|DPLL_FPA01_P1_POST_DIV_SHIFT_PINEVIEW
argument_list|)
expr_stmt|;
else|else
name|clock
operator|.
name|p1
operator|=
name|ffs
argument_list|(
operator|(
name|dpll
operator|&
name|DPLL_FPA01_P1_POST_DIV_MASK
operator|)
operator|>>
name|DPLL_FPA01_P1_POST_DIV_SHIFT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dpll
operator|&
name|DPLL_MODE_MASK
condition|)
block|{
case|case
name|DPLLB_MODE_DAC_SERIAL
case|:
name|clock
operator|.
name|p2
operator|=
name|dpll
operator|&
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_5
condition|?
literal|5
else|:
literal|10
expr_stmt|;
break|break;
case|case
name|DPLLB_MODE_LVDS
case|:
name|clock
operator|.
name|p2
operator|=
name|dpll
operator|&
name|DPLLB_LVDS_P2_CLOCK_DIV_7
condition|?
literal|7
else|:
literal|14
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unknown DPLL mode %08x in programmed "
literal|"mode\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dpll
operator|&
name|DPLL_MODE_MASK
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* XXX: Handle the 100Mhz refclk */
name|intel_clock
argument_list|(
name|dev
argument_list|,
literal|96000
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|is_lvds
init|=
operator|(
name|pipe
operator|==
literal|1
operator|)
operator|&&
operator|(
name|I915_READ
argument_list|(
name|LVDS
argument_list|)
operator|&
name|LVDS_PORT_EN
operator|)
decl_stmt|;
if|if
condition|(
name|is_lvds
condition|)
block|{
name|clock
operator|.
name|p1
operator|=
name|ffs
argument_list|(
operator|(
name|dpll
operator|&
name|DPLL_FPA01_P1_POST_DIV_MASK_I830_LVDS
operator|)
operator|>>
name|DPLL_FPA01_P1_POST_DIV_SHIFT
argument_list|)
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|14
expr_stmt|;
if|if
condition|(
operator|(
name|dpll
operator|&
name|PLL_REF_INPUT_MASK
operator|)
operator|==
name|PLLB_REF_INPUT_SPREADSPECTRUMIN
condition|)
block|{
comment|/* XXX: might not be 66MHz */
name|intel_clock
argument_list|(
name|dev
argument_list|,
literal|66000
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
block|}
else|else
name|intel_clock
argument_list|(
name|dev
argument_list|,
literal|48000
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dpll
operator|&
name|PLL_P1_DIVIDE_BY_TWO
condition|)
name|clock
operator|.
name|p1
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|clock
operator|.
name|p1
operator|=
operator|(
operator|(
name|dpll
operator|&
name|DPLL_FPA01_P1_POST_DIV_MASK_I830
operator|)
operator|>>
name|DPLL_FPA01_P1_POST_DIV_SHIFT
operator|)
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|dpll
operator|&
name|PLL_P2_DIVIDE_BY_4
condition|)
name|clock
operator|.
name|p2
operator|=
literal|4
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
literal|2
expr_stmt|;
name|intel_clock
argument_list|(
name|dev
argument_list|,
literal|48000
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* XXX: It would be nice to validate the clocks, but we can't reuse 	 * i830PllIsValid() because it relies on the xf86_config connector 	 * configuration being accurate, which it isn't necessarily. 	 */
return|return
name|clock
operator|.
name|dot
return|;
block|}
end_function

begin_comment
comment|/** Returns the currently programmed mode of the given pipe. */
end_comment

begin_function
name|struct
name|drm_display_mode
modifier|*
name|intel_crtc_mode_get
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|enum
name|transcoder
name|cpu_transcoder
init|=
name|intel_crtc
operator|->
name|cpu_transcoder
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|int
name|htot
init|=
name|I915_READ
argument_list|(
name|HTOTAL
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|hsync
init|=
name|I915_READ
argument_list|(
name|HSYNC
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|vtot
init|=
name|I915_READ
argument_list|(
name|VTOTAL
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|vsync
init|=
name|I915_READ
argument_list|(
name|VSYNC
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
decl_stmt|;
name|mode
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mode
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
return|return
name|NULL
return|;
name|mode
operator|->
name|clock
operator|=
name|intel_crtc_clock_get
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
name|mode
operator|->
name|hdisplay
operator|=
operator|(
name|htot
operator|&
literal|0xffff
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|htotal
operator|=
operator|(
operator|(
name|htot
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|hsync_start
operator|=
operator|(
name|hsync
operator|&
literal|0xffff
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|hsync_end
operator|=
operator|(
operator|(
name|hsync
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|vdisplay
operator|=
operator|(
name|vtot
operator|&
literal|0xffff
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|vtotal
operator|=
operator|(
operator|(
name|vtot
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|vsync_start
operator|=
operator|(
name|vsync
operator|&
literal|0xffff
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|vsync_end
operator|=
operator|(
operator|(
name|vsync
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
name|drm_mode_set_name
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|mode
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_increase_pllclock
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|dpll_reg
init|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|int
name|dpll
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|lvds_downclock_avail
condition|)
return|return;
name|dpll
operator|=
name|I915_READ
argument_list|(
name|dpll_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HAS_PIPE_CXSR
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|dpll
operator|&
name|DISPLAY_RATE_SELECT_FPA1
operator|)
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"upclocking LVDS\n"
argument_list|)
expr_stmt|;
name|assert_panel_unlocked
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|dpll
operator|&=
operator|~
name|DISPLAY_RATE_SELECT_FPA1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|dpll_reg
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|dpll
operator|=
name|I915_READ
argument_list|(
name|dpll_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpll
operator|&
name|DISPLAY_RATE_SELECT_FPA1
condition|)
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"failed to upclock LVDS!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_decrease_pllclock
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|lvds_downclock_avail
condition|)
return|return;
comment|/* 	 * Since this is called by a timer, we should never get here in 	 * the manual case. 	 */
if|if
condition|(
operator|!
name|HAS_PIPE_CXSR
argument_list|(
name|dev
argument_list|)
operator|&&
name|intel_crtc
operator|->
name|lowfreq_avail
condition|)
block|{
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|dpll_reg
init|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|int
name|dpll
decl_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"downclocking LVDS\n"
argument_list|)
expr_stmt|;
name|assert_panel_unlocked
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|dpll
operator|=
name|I915_READ
argument_list|(
name|dpll_reg
argument_list|)
expr_stmt|;
name|dpll
operator||=
name|DISPLAY_RATE_SELECT_FPA1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|dpll_reg
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|dpll
operator|=
name|I915_READ
argument_list|(
name|dpll_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dpll
operator|&
name|DISPLAY_RATE_SELECT_FPA1
operator|)
condition|)
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"failed to downclock LVDS!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|intel_mark_busy
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|i915_update_gfx_val
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_mark_idle
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
if|if
condition|(
operator|!
name|i915_powersave
condition|)
return|return;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|!
name|crtc
operator|->
name|fb
condition|)
continue|continue;
name|intel_decrease_pllclock
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|intel_mark_fb_busy
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
if|if
condition|(
operator|!
name|i915_powersave
condition|)
return|return;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|!
name|crtc
operator|->
name|fb
condition|)
continue|continue;
if|if
condition|(
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
operator|->
name|obj
operator|==
name|obj
condition|)
name|intel_increase_pllclock
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_destroy
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_unpin_work
modifier|*
name|work
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|work
operator|=
name|intel_crtc
operator|->
name|unpin_work
expr_stmt|;
name|intel_crtc
operator|->
name|unpin_work
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
condition|)
block|{
name|taskqueue_cancel
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|work
operator|->
name|work
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|work
operator|->
name|work
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
name|drm_crtc_cleanup
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intel_crtc
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_unpin_work_fn
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|intel_unpin_work
modifier|*
name|work
init|=
name|arg
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|work
operator|->
name|crtc
operator|->
name|dev
decl_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_unpin_fb_obj
argument_list|(
name|work
operator|->
name|old_fb_obj
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|work
operator|->
name|pending_flip_obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|to_intel_crtc
argument_list|(
name|work
operator|->
name|crtc
argument_list|)
operator|->
name|unpin_work_count
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|to_intel_crtc
argument_list|(
name|work
operator|->
name|crtc
argument_list|)
operator|->
name|unpin_work_count
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_intel_finish_page_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_unpin_work
modifier|*
name|work
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
comment|/* Ignore early vblank irqs */
if|if
condition|(
name|intel_crtc
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|work
operator|=
name|intel_crtc
operator|->
name|unpin_work
expr_stmt|;
comment|/* Ensure we don't miss a work->pending update ... */
name|smp_rmb
argument_list|()
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|NULL
operator|||
name|atomic_read
argument_list|(
operator|&
name|work
operator|->
name|pending
argument_list|)
operator|<
name|INTEL_FLIP_COMPLETE
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* and that the unpin work is consistent wrt ->pending. */
name|smp_rmb
argument_list|()
expr_stmt|;
name|intel_crtc
operator|->
name|unpin_work
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|event
condition|)
name|drm_send_vblank_event
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|,
name|work
operator|->
name|event
argument_list|)
expr_stmt|;
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|obj
operator|=
name|work
operator|->
name|old_fb_obj
expr_stmt|;
name|atomic_clear_mask
argument_list|(
literal|1
operator|<<
name|intel_crtc
operator|->
name|plane
argument_list|,
operator|&
name|obj
operator|->
name|pending_flip
argument_list|)
expr_stmt|;
name|wake_up
argument_list|(
operator|&
name|dev_priv
operator|->
name|pending_flip_queue
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|work
operator|->
name|work
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"i915_flip_complete %d %p"
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|,
name|work
operator|->
name|pending_flip_obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_finish_page_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|pipe
index|]
decl_stmt|;
name|do_intel_finish_page_flip
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_finish_page_flip_plane
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|dev_priv
operator|->
name|plane_to_crtc_mapping
index|[
name|plane
index|]
decl_stmt|;
name|do_intel_finish_page_flip
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_prepare_page_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|dev_priv
operator|->
name|plane_to_crtc_mapping
index|[
name|plane
index|]
argument_list|)
decl_stmt|;
comment|/* NB: An MMIO update of the plane base pointer will also 	 * generate a page-flip completion irq, i.e. every modeset 	 * is also accompanied by a spurious intel_prepare_page_flip(). 	 */
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|unpin_work
condition|)
name|atomic_inc_not_zero
argument_list|(
operator|&
name|intel_crtc
operator|->
name|unpin_work
operator|->
name|pending
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
specifier|static
name|void
name|intel_mark_page_flip_active
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|)
block|{
comment|/* Ensure that the work item is consistent when activating it ... */
name|smp_wmb
argument_list|()
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|intel_crtc
operator|->
name|unpin_work
operator|->
name|pending
argument_list|,
name|INTEL_FLIP_PENDING
argument_list|)
expr_stmt|;
comment|/* and that it is marked active as soon as the irq could fire. */
name|smp_wmb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_gen2_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|u32
name|flip_mask
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|RCS
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin
goto|;
comment|/* Can't queue multiple flips, so wait for the previous 	 * one to finish before executing the next. 	 */
if|if
condition|(
name|intel_crtc
operator|->
name|plane
condition|)
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_B_FLIP
expr_stmt|;
else|else
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_A_FLIP
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_WAIT_FOR_EVENT
operator||
name|flip_mask
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_NOOP
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_DISPLAY_FLIP
operator||
name|MI_DISPLAY_FLIP_PLANE
argument_list|(
name|intel_crtc
operator|->
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|obj
operator|->
name|gtt_offset
operator|+
name|intel_crtc
operator|->
name|dspaddr_offset
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* aux display base address, unused */
name|intel_mark_page_flip_active
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin
label|:
name|intel_unpin_fb_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_gen3_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|u32
name|flip_mask
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|RCS
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin
goto|;
if|if
condition|(
name|intel_crtc
operator|->
name|plane
condition|)
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_B_FLIP
expr_stmt|;
else|else
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_A_FLIP
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_WAIT_FOR_EVENT
operator||
name|flip_mask
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_NOOP
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_DISPLAY_FLIP_I915
operator||
name|MI_DISPLAY_FLIP_PLANE
argument_list|(
name|intel_crtc
operator|->
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|obj
operator|->
name|gtt_offset
operator|+
name|intel_crtc
operator|->
name|dspaddr_offset
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_NOOP
argument_list|)
expr_stmt|;
name|intel_mark_page_flip_active
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin
label|:
name|intel_unpin_fb_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_gen4_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|uint32_t
name|pf
decl_stmt|,
name|pipesrc
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|RCS
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin
goto|;
comment|/* i965+ uses the linear or tiled offsets from the 	 * Display Registers (which do not change across a page-flip) 	 * so we need only reprogram the base address. 	 */
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_DISPLAY_FLIP
operator||
name|MI_DISPLAY_FLIP_PLANE
argument_list|(
name|intel_crtc
operator|->
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
operator|(
name|obj
operator|->
name|gtt_offset
operator|+
name|intel_crtc
operator|->
name|dspaddr_offset
operator|)
operator||
name|obj
operator|->
name|tiling_mode
argument_list|)
expr_stmt|;
comment|/* XXX Enabling the panel-fitter across page-flip is so far 	 * untested on non-native modes, so ignore it for now. 	 * pf = I915_READ(pipe == 0 ? PFA_CTL_1 : PFB_CTL_1)& PF_ENABLE; 	 */
name|pf
operator|=
literal|0
expr_stmt|;
name|pipesrc
operator|=
name|I915_READ
argument_list|(
name|PIPESRC
argument_list|(
name|intel_crtc
operator|->
name|pipe
argument_list|)
argument_list|)
operator|&
literal|0x0fff0fff
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|pf
operator||
name|pipesrc
argument_list|)
expr_stmt|;
name|intel_mark_page_flip_active
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin
label|:
name|intel_unpin_fb_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_gen6_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|RCS
index|]
decl_stmt|;
name|uint32_t
name|pf
decl_stmt|,
name|pipesrc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin
goto|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_DISPLAY_FLIP
operator||
name|MI_DISPLAY_FLIP_PLANE
argument_list|(
name|intel_crtc
operator|->
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator||
name|obj
operator|->
name|tiling_mode
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|obj
operator|->
name|gtt_offset
operator|+
name|intel_crtc
operator|->
name|dspaddr_offset
argument_list|)
expr_stmt|;
comment|/* Contrary to the suggestions in the documentation, 	 * "Enable Panel Fitter" does not seem to be required when page 	 * flipping with a non-native mode, and worse causes a normal 	 * modeset to fail. 	 * pf = I915_READ(PF_CTL(intel_crtc->pipe))& PF_ENABLE; 	 */
name|pf
operator|=
literal|0
expr_stmt|;
name|pipesrc
operator|=
name|I915_READ
argument_list|(
name|PIPESRC
argument_list|(
name|intel_crtc
operator|->
name|pipe
argument_list|)
argument_list|)
operator|&
literal|0x0fff0fff
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|pf
operator||
name|pipesrc
argument_list|)
expr_stmt|;
name|intel_mark_page_flip_active
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin
label|:
name|intel_unpin_fb_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * On gen7 we currently use the blit ring because (in early silicon at least)  * the render ring doesn't give us interrpts for page flip completion, which  * means clients will hang after the first flip is queued.  Fortunately the  * blit ring generates interrupts properly, so use it instead.  */
end_comment

begin_function
specifier|static
name|int
name|intel_gen7_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|BCS
index|]
decl_stmt|;
name|uint32_t
name|plane_bit
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
switch|switch
condition|(
name|intel_crtc
operator|->
name|plane
condition|)
block|{
case|case
name|PLANE_A
case|:
name|plane_bit
operator|=
name|MI_DISPLAY_FLIP_IVB_PLANE_A
expr_stmt|;
break|break;
case|case
name|PLANE_B
case|:
name|plane_bit
operator|=
name|MI_DISPLAY_FLIP_IVB_PLANE_B
expr_stmt|;
break|break;
case|case
name|PLANE_C
case|:
name|plane_bit
operator|=
name|MI_DISPLAY_FLIP_IVB_PLANE_C
expr_stmt|;
break|break;
default|default:
name|WARN_ONCE
argument_list|(
literal|1
argument_list|,
literal|"unknown plane in flip command\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_unpin
goto|;
block|}
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin
goto|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_DISPLAY_FLIP_I915
operator||
name|plane_bit
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
operator|(
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator||
name|obj
operator|->
name|tiling_mode
operator|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|obj
operator|->
name|gtt_offset
operator|+
name|intel_crtc
operator|->
name|dspaddr_offset
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
operator|(
name|MI_NOOP
operator|)
argument_list|)
expr_stmt|;
name|intel_mark_page_flip_active
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin
label|:
name|intel_unpin_fb_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_default_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
return|return
operator|-
name|ENODEV
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_crtc_page_flip
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_pending_vblank_event
modifier|*
name|event
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
init|=
name|crtc
operator|->
name|fb
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
operator|->
name|obj
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_unpin_work
modifier|*
name|work
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Can't change pixel format via MI display flips. */
if|if
condition|(
name|fb
operator|->
name|pixel_format
operator|!=
name|crtc
operator|->
name|fb
operator|->
name|pixel_format
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* 	 * TILEOFF/LINOFF registers can't be changed via MI display flips. 	 * Note that pitch changes could also affect these register. 	 */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>
literal|3
operator|&&
operator|(
name|fb
operator|->
name|offsets
index|[
literal|0
index|]
operator|!=
name|crtc
operator|->
name|fb
operator|->
name|offsets
index|[
literal|0
index|]
operator|||
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|!=
name|crtc
operator|->
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|work
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|work
operator|->
name|event
operator|=
name|event
expr_stmt|;
name|work
operator|->
name|crtc
operator|=
name|crtc
expr_stmt|;
name|work
operator|->
name|old_fb_obj
operator|=
name|to_intel_framebuffer
argument_list|(
name|old_fb
argument_list|)
operator|->
name|obj
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|work
operator|->
name|work
argument_list|,
literal|0
argument_list|,
name|intel_unpin_work_fn
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_vblank_get
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|free_work
goto|;
comment|/* We borrow the event spin lock for protecting unpin_work */
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|unpin_work
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"flip queue: crtc already busy\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
name|intel_crtc
operator|->
name|unpin_work
operator|=
name|work
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|intel_crtc
operator|->
name|unpin_work_count
argument_list|)
operator|>=
literal|2
condition|)
name|taskqueue_drain_all
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Reference the objects for the scheduled work. */
name|drm_gem_object_reference
argument_list|(
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|drm_gem_object_reference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|fb
operator|=
name|fb
expr_stmt|;
name|work
operator|->
name|pending_flip_obj
operator|=
name|obj
expr_stmt|;
name|work
operator|->
name|enable_stall_check
operator|=
name|true
expr_stmt|;
comment|/* Block clients from rendering to the new back buffer until 	 * the flip occurs and the object is no longer visible. 	 */
name|atomic_add
argument_list|(
literal|1
operator|<<
name|intel_crtc
operator|->
name|plane
argument_list|,
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|pending_flip
argument_list|)
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|intel_crtc
operator|->
name|unpin_work_count
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
name|fb
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup_pending
goto|;
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_mark_fb_busy
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"i915_flip_request %d %p"
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|cleanup_pending
label|:
name|atomic_dec
argument_list|(
operator|&
name|intel_crtc
operator|->
name|unpin_work_count
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|fb
operator|=
name|old_fb
expr_stmt|;
name|atomic_sub
argument_list|(
literal|1
operator|<<
name|intel_crtc
operator|->
name|plane
argument_list|,
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|pending_flip
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|unpin_work
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|free_work
label|:
name|free
argument_list|(
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|drm_crtc_helper_funcs
name|intel_helper_funcs
init|=
block|{
operator|.
name|mode_set_base_atomic
operator|=
name|intel_pipe_set_base_atomic
block|,
operator|.
name|load_lut
operator|=
name|intel_crtc_load_lut
block|,
operator|.
name|disable
operator|=
name|intel_crtc_noop
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|bool
name|intel_encoder_check_is_cloned
parameter_list|(
name|struct
name|intel_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|intel_encoder
modifier|*
name|other_encoder
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
operator|&
name|encoder
operator|->
name|new_crtc
operator|->
name|base
decl_stmt|;
if|if
condition|(
name|WARN_ON
argument_list|(
operator|!
name|crtc
argument_list|)
condition|)
return|return
name|false
return|;
name|list_for_each_entry
argument_list|(
argument|other_encoder
argument_list|,
argument|&crtc->dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
operator|&
name|other_encoder
operator|->
name|new_crtc
operator|->
name|base
operator|!=
name|crtc
operator|||
name|encoder
operator|==
name|other_encoder
condition|)
continue|continue;
else|else
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_encoder_crtc_ok
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|tmp
decl_stmt|;
name|int
name|crtc_mask
init|=
literal|1
decl_stmt|;
name|WARN
argument_list|(
operator|!
name|crtc
argument_list|,
literal|"checking null crtc?\n"
argument_list|)
expr_stmt|;
name|dev
operator|=
name|crtc
operator|->
name|dev
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|tmp
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|tmp
operator|==
name|crtc
condition|)
break|break;
name|crtc_mask
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|encoder
operator|->
name|possible_crtcs
operator|&
name|crtc_mask
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/**  * intel_modeset_update_staged_output_state  *  * Updates the staged output configuration state, e.g. after we've read out the  * current hw state.  */
end_comment

begin_function
specifier|static
name|void
name|intel_modeset_update_staged_output_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|intel_connector
modifier|*
name|connector
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|connector
operator|->
name|new_encoder
operator|=
name|to_intel_encoder
argument_list|(
name|connector
operator|->
name|base
operator|.
name|encoder
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|encoder
operator|->
name|new_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|encoder
operator|->
name|base
operator|.
name|crtc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * intel_modeset_commit_output_state  *  * This function copies the stage display pipe configuration to the real one.  */
end_comment

begin_function
specifier|static
name|void
name|intel_modeset_commit_output_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|intel_connector
modifier|*
name|connector
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|connector
operator|->
name|base
operator|.
name|encoder
operator|=
operator|&
name|connector
operator|->
name|new_encoder
operator|->
name|base
expr_stmt|;
block|}
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|=
operator|&
name|encoder
operator|->
name|new_crtc
operator|->
name|base
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|intel_modeset_adjusted_mode
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
decl_stmt|;
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|adjusted_mode
operator|=
name|drm_mode_duplicate
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adjusted_mode
condition|)
return|return
operator|-
name|ENOMEM
return|;
comment|/* Pass our mode to the connectors and the CRTC to give them a chance to 	 * adjust it according to limitations or connector properties, and also 	 * a chance to reject the mode entirely. 	 */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
operator|&
name|encoder
operator|->
name|new_crtc
operator|->
name|base
operator|!=
name|crtc
condition|)
continue|continue;
name|encoder_funcs
operator|=
name|encoder
operator|->
name|base
operator|.
name|helper_private
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|encoder_funcs
operator|->
name|mode_fixup
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Encoder fixup failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|intel_crtc_mode_fixup
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"CRTC fixup failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CRTC:%d]\n"
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|adjusted_mode
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|drm_mode_destroy
argument_list|(
name|dev
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/* Computes which crtcs are affected and sets the relevant bits in the mask. For  * simplicity we use the crtc's pipe number (because it's easier to obtain). */
end_comment

begin_function
specifier|static
name|void
name|intel_modeset_affected_pipes
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|unsigned
modifier|*
name|modeset_pipes
parameter_list|,
name|unsigned
modifier|*
name|prepare_pipes
parameter_list|,
name|unsigned
modifier|*
name|disable_pipes
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|intel_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|tmp_crtc
decl_stmt|;
operator|*
name|disable_pipes
operator|=
operator|*
name|modeset_pipes
operator|=
operator|*
name|prepare_pipes
operator|=
literal|0
expr_stmt|;
comment|/* Check which crtcs have changed outputs connected to them, these need 	 * to be part of the prepare_pipes mask. We don't (yet) support global 	 * modeset across multiple crtcs, so modeset_pipes will only have one 	 * bit set at most. */
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|connector
operator|->
name|base
operator|.
name|encoder
operator|==
operator|&
name|connector
operator|->
name|new_encoder
operator|->
name|base
condition|)
continue|continue;
if|if
condition|(
name|connector
operator|->
name|base
operator|.
name|encoder
condition|)
block|{
name|tmp_crtc
operator|=
name|connector
operator|->
name|base
operator|.
name|encoder
operator|->
name|crtc
expr_stmt|;
operator|*
name|prepare_pipes
operator||=
literal|1
operator|<<
name|to_intel_crtc
argument_list|(
name|tmp_crtc
argument_list|)
operator|->
name|pipe
expr_stmt|;
block|}
if|if
condition|(
name|connector
operator|->
name|new_encoder
condition|)
operator|*
name|prepare_pipes
operator||=
literal|1
operator|<<
name|connector
operator|->
name|new_encoder
operator|->
name|new_crtc
operator|->
name|pipe
expr_stmt|;
block|}
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|==
operator|&
name|encoder
operator|->
name|new_crtc
operator|->
name|base
condition|)
continue|continue;
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
condition|)
block|{
name|tmp_crtc
operator|=
name|encoder
operator|->
name|base
operator|.
name|crtc
expr_stmt|;
operator|*
name|prepare_pipes
operator||=
literal|1
operator|<<
name|to_intel_crtc
argument_list|(
name|tmp_crtc
argument_list|)
operator|->
name|pipe
expr_stmt|;
block|}
if|if
condition|(
name|encoder
operator|->
name|new_crtc
condition|)
operator|*
name|prepare_pipes
operator||=
literal|1
operator|<<
name|encoder
operator|->
name|new_crtc
operator|->
name|pipe
expr_stmt|;
block|}
comment|/* Check for any pipes that will be fully disabled ... */
name|list_for_each_entry
argument_list|(
argument|intel_crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|bool
name|used
init|=
name|false
decl_stmt|;
comment|/* Don't try to disable disabled crtcs. */
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|base
operator|.
name|enabled
condition|)
continue|continue;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|new_crtc
operator|==
name|intel_crtc
condition|)
name|used
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|used
condition|)
operator|*
name|disable_pipes
operator||=
literal|1
operator|<<
name|intel_crtc
operator|->
name|pipe
expr_stmt|;
block|}
comment|/* set_mode is also used to update properties on life display pipes. */
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|enabled
condition|)
operator|*
name|prepare_pipes
operator||=
literal|1
operator|<<
name|intel_crtc
operator|->
name|pipe
expr_stmt|;
comment|/* 	 * For simplicity do a full modeset on any pipe where the output routing 	 * changed. We could be more clever, but that would require us to be 	 * more careful with calling the relevant encoder->mode_set functions. 	 */
if|if
condition|(
operator|*
name|prepare_pipes
condition|)
operator|*
name|modeset_pipes
operator|=
operator|*
name|prepare_pipes
expr_stmt|;
comment|/* ... and mask these out. */
operator|*
name|modeset_pipes
operator|&=
operator|~
operator|(
operator|*
name|disable_pipes
operator|)
expr_stmt|;
operator|*
name|prepare_pipes
operator|&=
operator|~
operator|(
operator|*
name|disable_pipes
operator|)
expr_stmt|;
comment|/* 	 * HACK: We don't (yet) fully support global modesets. intel_set_config 	 * obies this rule, but the modeset restore mode of 	 * intel_modeset_setup_hw_state does not. 	 */
operator|*
name|modeset_pipes
operator|&=
literal|1
operator|<<
name|intel_crtc
operator|->
name|pipe
expr_stmt|;
operator|*
name|prepare_pipes
operator|&=
literal|1
operator|<<
name|intel_crtc
operator|->
name|pipe
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_crtc_in_use
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
if|if
condition|(
name|encoder
operator|->
name|crtc
operator|==
name|crtc
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_modeset_update_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|prepare_pipes
parameter_list|)
block|{
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|intel_encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
operator|!
name|intel_encoder
operator|->
name|base
operator|.
name|crtc
condition|)
continue|continue;
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|intel_encoder
operator|->
name|base
operator|.
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|prepare_pipes
operator|&
operator|(
literal|1
operator|<<
name|intel_crtc
operator|->
name|pipe
operator|)
condition|)
name|intel_encoder
operator|->
name|connectors_active
operator|=
name|false
expr_stmt|;
block|}
name|intel_modeset_commit_output_state
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Update computed state. */
name|list_for_each_entry
argument_list|(
argument|intel_crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|intel_crtc
operator|->
name|base
operator|.
name|enabled
operator|=
name|intel_crtc_in_use
argument_list|(
operator|&
name|intel_crtc
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|!
name|connector
operator|->
name|encoder
operator|||
operator|!
name|connector
operator|->
name|encoder
operator|->
name|crtc
condition|)
continue|continue;
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|connector
operator|->
name|encoder
operator|->
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|prepare_pipes
operator|&
operator|(
literal|1
operator|<<
name|intel_crtc
operator|->
name|pipe
operator|)
condition|)
block|{
name|struct
name|drm_property
modifier|*
name|dpms_property
init|=
name|dev
operator|->
name|mode_config
operator|.
name|dpms_property
decl_stmt|;
name|connector
operator|->
name|dpms
operator|=
name|DRM_MODE_DPMS_ON
expr_stmt|;
name|drm_object_property_set_value
argument_list|(
operator|&
name|connector
operator|->
name|base
argument_list|,
name|dpms_property
argument_list|,
name|DRM_MODE_DPMS_ON
argument_list|)
expr_stmt|;
name|intel_encoder
operator|=
name|to_intel_encoder
argument_list|(
name|connector
operator|->
name|encoder
argument_list|)
expr_stmt|;
name|intel_encoder
operator|->
name|connectors_active
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|for_each_intel_crtc_masked
parameter_list|(
name|dev
parameter_list|,
name|mask
parameter_list|,
name|intel_crtc
parameter_list|)
define|\
value|list_for_each_entry((intel_crtc), \&(dev)->mode_config.crtc_list, \ 			    base.head) \ 		if (mask& (1<<(intel_crtc)->pipe)) \  void
end_define

begin_macro
name|intel_modeset_check_state
argument_list|(
argument|struct drm_device *dev
argument_list|)
end_macro

begin_block
block|{
name|struct
name|intel_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|intel_connector
modifier|*
name|connector
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|base.head
argument_list|)
block|{
comment|/* This also checks the encoder/connector hw state with the 		 * ->get_hw_state callbacks. */
name|intel_connector_check_state
argument_list|(
name|connector
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
operator|&
name|connector
operator|->
name|new_encoder
operator|->
name|base
operator|!=
name|connector
operator|->
name|base
operator|.
name|encoder
argument_list|,
literal|"connector's staged encoder doesn't match current encoder\n"
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|bool
name|enabled
init|=
name|false
decl_stmt|;
name|bool
name|active
init|=
name|false
decl_stmt|;
name|enum
name|pipe
name|pipe
decl_stmt|,
name|tracked_pipe
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[ENCODER:%d:%s]\n"
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
operator|&
name|encoder
operator|->
name|new_crtc
operator|->
name|base
operator|!=
name|encoder
operator|->
name|base
operator|.
name|crtc
argument_list|,
literal|"encoder's stage crtc doesn't match current crtc\n"
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
name|encoder
operator|->
name|connectors_active
operator|&&
operator|!
name|encoder
operator|->
name|base
operator|.
name|crtc
argument_list|,
literal|"encoder's active_connectors set, but no crtc\n"
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|connector
operator|->
name|base
operator|.
name|encoder
operator|!=
operator|&
name|encoder
operator|->
name|base
condition|)
continue|continue;
name|enabled
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|connector
operator|->
name|base
operator|.
name|dpms
operator|!=
name|DRM_MODE_DPMS_OFF
condition|)
name|active
operator|=
name|true
expr_stmt|;
block|}
name|WARN
argument_list|(
operator|!
operator|!
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|!=
name|enabled
argument_list|,
literal|"encoder's enabled state mismatch "
literal|"(expected %i, found %i)\n"
argument_list|,
operator|!
operator|!
name|encoder
operator|->
name|base
operator|.
name|crtc
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
name|active
operator|&&
operator|!
name|encoder
operator|->
name|base
operator|.
name|crtc
argument_list|,
literal|"active encoder with no crtc\n"
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
name|encoder
operator|->
name|connectors_active
operator|!=
name|active
argument_list|,
literal|"encoder's computed active state doesn't match tracked active state "
literal|"(expected %i, found %i)\n"
argument_list|,
name|active
argument_list|,
name|encoder
operator|->
name|connectors_active
argument_list|)
expr_stmt|;
name|active
operator|=
name|encoder
operator|->
name|get_hw_state
argument_list|(
name|encoder
argument_list|,
operator|&
name|pipe
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
name|active
operator|!=
name|encoder
operator|->
name|connectors_active
argument_list|,
literal|"encoder's hw state doesn't match sw tracking "
literal|"(expected %i, found %i)\n"
argument_list|,
name|encoder
operator|->
name|connectors_active
argument_list|,
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoder
operator|->
name|base
operator|.
name|crtc
condition|)
continue|continue;
name|tracked_pipe
operator|=
name|to_intel_crtc
argument_list|(
name|encoder
operator|->
name|base
operator|.
name|crtc
argument_list|)
operator|->
name|pipe
expr_stmt|;
name|WARN
argument_list|(
name|active
operator|&&
name|pipe
operator|!=
name|tracked_pipe
argument_list|,
literal|"active encoder's pipe doesn't match"
literal|"(expected %i, found %i)\n"
argument_list|,
name|tracked_pipe
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|bool
name|enabled
init|=
name|false
decl_stmt|;
name|bool
name|active
init|=
name|false
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CRTC:%d]\n"
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
name|crtc
operator|->
name|active
operator|&&
operator|!
name|crtc
operator|->
name|base
operator|.
name|enabled
argument_list|,
literal|"active crtc, but not enabled in sw tracking\n"
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|!=
operator|&
name|crtc
operator|->
name|base
condition|)
continue|continue;
name|enabled
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|encoder
operator|->
name|connectors_active
condition|)
name|active
operator|=
name|true
expr_stmt|;
block|}
name|WARN
argument_list|(
name|active
operator|!=
name|crtc
operator|->
name|active
argument_list|,
literal|"crtc's computed active state doesn't match tracked active state "
literal|"(expected %i, found %i)\n"
argument_list|,
name|active
argument_list|,
name|crtc
operator|->
name|active
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
name|enabled
operator|!=
name|crtc
operator|->
name|base
operator|.
name|enabled
argument_list|,
literal|"crtc's computed enabled state doesn't match tracked enabled state "
literal|"(expected %i, found %i)\n"
argument_list|,
name|enabled
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|enabled
argument_list|)
expr_stmt|;
name|assert_pipe
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|,
name|crtc
operator|->
name|pipe
argument_list|,
name|crtc
operator|->
name|active
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|bool
name|intel_set_mode
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
decl_stmt|,
name|saved_mode
decl_stmt|,
name|saved_hwmode
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
name|unsigned
name|disable_pipes
decl_stmt|,
name|prepare_pipes
decl_stmt|,
name|modeset_pipes
decl_stmt|;
name|bool
name|ret
init|=
name|true
decl_stmt|;
name|intel_modeset_affected_pipes
argument_list|(
name|crtc
argument_list|,
operator|&
name|modeset_pipes
argument_list|,
operator|&
name|prepare_pipes
argument_list|,
operator|&
name|disable_pipes
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"set mode pipe masks: modeset: %x, prepare: %x, disable: %x\n"
argument_list|,
name|modeset_pipes
argument_list|,
name|prepare_pipes
argument_list|,
name|disable_pipes
argument_list|)
expr_stmt|;
name|for_each_intel_crtc_masked
argument_list|(
argument|dev
argument_list|,
argument|disable_pipes
argument_list|,
argument|intel_crtc
argument_list|)
name|intel_crtc_disable
argument_list|(
operator|&
name|intel_crtc
operator|->
name|base
argument_list|)
expr_stmt|;
name|saved_hwmode
operator|=
name|crtc
operator|->
name|hwmode
expr_stmt|;
name|saved_mode
operator|=
name|crtc
operator|->
name|mode
expr_stmt|;
comment|/* Hack: Because we don't (yet) support global modeset on multiple 	 * crtcs, we don't keep track of the new mode for more than one crtc. 	 * Hence simply check whether any bit is set in modeset_pipes in all the 	 * pieces of code that are not yet converted to deal with mutliple crtcs 	 * changing their mode at the same time. */
name|adjusted_mode
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|modeset_pipes
condition|)
block|{
name|int
name|err
init|=
name|intel_modeset_adjusted_mode
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
operator|&
name|adjusted_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
name|for_each_intel_crtc_masked
argument_list|(
argument|dev
argument_list|,
argument|prepare_pipes
argument_list|,
argument|intel_crtc
argument_list|)
block|{
if|if
condition|(
name|intel_crtc
operator|->
name|base
operator|.
name|enabled
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|crtc_disable
argument_list|(
operator|&
name|intel_crtc
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
comment|/* crtc->mode is already used by the ->mode_set callbacks, hence we need 	 * to set it here already despite that we pass it down the callchain. 	 */
if|if
condition|(
name|modeset_pipes
condition|)
name|crtc
operator|->
name|mode
operator|=
operator|*
name|mode
expr_stmt|;
comment|/* Only after disabling all output pipelines that will be changed can we 	 * update the output configuration. */
name|intel_modeset_update_state
argument_list|(
name|dev
argument_list|,
name|prepare_pipes
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|display
operator|.
name|modeset_global_resources
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|modeset_global_resources
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Set up the DPLL and any encoders state that needs to adjust or depend 	 * on the DPLL. 	 */
name|for_each_intel_crtc_masked
argument_list|(
argument|dev
argument_list|,
argument|modeset_pipes
argument_list|,
argument|intel_crtc
argument_list|)
block|{
name|ret
operator|=
operator|!
name|intel_crtc_mode_set
argument_list|(
operator|&
name|intel_crtc
operator|->
name|base
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|fb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* Now enable the clocks, plane, pipe, and connectors that we set up. */
name|for_each_intel_crtc_masked
argument_list|(
argument|dev
argument_list|,
argument|prepare_pipes
argument_list|,
argument|intel_crtc
argument_list|)
name|dev_priv
operator|->
name|display
operator|.
name|crtc_enable
argument_list|(
operator|&
name|intel_crtc
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|modeset_pipes
condition|)
block|{
comment|/* Store real post-adjustment hardware mode. */
name|crtc
operator|->
name|hwmode
operator|=
operator|*
name|adjusted_mode
expr_stmt|;
comment|/* Calculate and store various constants which 		 * are later needed by vblank and swap-completion 		 * timestamping. They are derived from true hwmode. 		 */
name|drm_calc_timestamping_constants
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: add subpixel order */
name|done
label|:
name|drm_mode_destroy
argument_list|(
name|dev
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|crtc
operator|->
name|enabled
condition|)
block|{
name|crtc
operator|->
name|hwmode
operator|=
name|saved_hwmode
expr_stmt|;
name|crtc
operator|->
name|mode
operator|=
name|saved_mode
expr_stmt|;
block|}
else|else
block|{
name|intel_modeset_check_state
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|for_each_intel_crtc_masked
end_undef

begin_function
specifier|static
name|void
name|intel_set_config_free
parameter_list|(
name|struct
name|intel_set_config
modifier|*
name|config
parameter_list|)
block|{
if|if
condition|(
operator|!
name|config
condition|)
return|return;
name|free
argument_list|(
name|config
operator|->
name|save_connector_encoders
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|config
operator|->
name|save_encoder_crtcs
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|config
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_set_config_save_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|intel_set_config
modifier|*
name|config
parameter_list|)
block|{
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|int
name|count
decl_stmt|;
name|config
operator|->
name|save_encoder_crtcs
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_encoder
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_crtc
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
operator|->
name|save_encoder_crtcs
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|config
operator|->
name|save_connector_encoders
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_encoder
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
operator|->
name|save_connector_encoders
condition|)
return|return
operator|-
name|ENOMEM
return|;
comment|/* Copy data. Note that driver private data is not affected. 	 * Should anything bad happen only the expected state is 	 * restored, not the drivers personal bookkeeping. 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
name|config
operator|->
name|save_encoder_crtcs
index|[
name|count
operator|++
index|]
operator|=
name|encoder
operator|->
name|crtc
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
name|config
operator|->
name|save_connector_encoders
index|[
name|count
operator|++
index|]
operator|=
name|connector
operator|->
name|encoder
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_set_config_restore_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|intel_set_config
modifier|*
name|config
parameter_list|)
block|{
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|intel_connector
modifier|*
name|connector
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|encoder
operator|->
name|new_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|config
operator|->
name|save_encoder_crtcs
index|[
name|count
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|connector
operator|->
name|new_encoder
operator|=
name|to_intel_encoder
argument_list|(
name|config
operator|->
name|save_connector_encoders
index|[
name|count
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_set_config_compute_mode_changes
parameter_list|(
name|struct
name|drm_mode_set
modifier|*
name|set
parameter_list|,
name|struct
name|intel_set_config
modifier|*
name|config
parameter_list|)
block|{
comment|/* We should be able to check here if the fb has the same properties 	 * and then just flip_or_move it */
if|if
condition|(
name|set
operator|->
name|crtc
operator|->
name|fb
operator|!=
name|set
operator|->
name|fb
condition|)
block|{
comment|/* If we have no fb then treat it as a full mode set */
if|if
condition|(
name|set
operator|->
name|crtc
operator|->
name|fb
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"crtc has no fb, full mode set\n"
argument_list|)
expr_stmt|;
name|config
operator|->
name|mode_changed
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|set
operator|->
name|fb
operator|==
name|NULL
condition|)
block|{
name|config
operator|->
name|mode_changed
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|set
operator|->
name|fb
operator|->
name|depth
operator|!=
name|set
operator|->
name|crtc
operator|->
name|fb
operator|->
name|depth
condition|)
block|{
name|config
operator|->
name|mode_changed
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|set
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|!=
name|set
operator|->
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
condition|)
block|{
name|config
operator|->
name|mode_changed
operator|=
name|true
expr_stmt|;
block|}
else|else
name|config
operator|->
name|fb_changed
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|set
operator|->
name|fb
operator|&&
operator|(
name|set
operator|->
name|x
operator|!=
name|set
operator|->
name|crtc
operator|->
name|x
operator|||
name|set
operator|->
name|y
operator|!=
name|set
operator|->
name|crtc
operator|->
name|y
operator|)
condition|)
name|config
operator|->
name|fb_changed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|mode
operator|&&
operator|!
name|drm_mode_equal
argument_list|(
name|set
operator|->
name|mode
argument_list|,
operator|&
name|set
operator|->
name|crtc
operator|->
name|mode
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"modes are different, full mode set\n"
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
operator|&
name|set
operator|->
name|crtc
operator|->
name|mode
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|set
operator|->
name|mode
argument_list|)
expr_stmt|;
name|config
operator|->
name|mode_changed
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|intel_modeset_stage_output_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_mode_set
modifier|*
name|set
parameter_list|,
name|struct
name|intel_set_config
modifier|*
name|config
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|new_crtc
decl_stmt|;
name|struct
name|intel_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|int
name|count
decl_stmt|,
name|ro
decl_stmt|;
comment|/* The upper layers ensure that we either disabl a crtc or have a list 	 * of connectors. For paranoia, double-check this. */
name|WARN_ON
argument_list|(
operator|!
name|set
operator|->
name|fb
operator|&&
operator|(
name|set
operator|->
name|num_connectors
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
name|set
operator|->
name|fb
operator|&&
operator|(
name|set
operator|->
name|num_connectors
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|base.head
argument_list|)
block|{
comment|/* Otherwise traverse passed in connector list and get encoders 		 * for them. */
for|for
control|(
name|ro
operator|=
literal|0
init|;
name|ro
operator|<
name|set
operator|->
name|num_connectors
condition|;
name|ro
operator|++
control|)
block|{
if|if
condition|(
name|set
operator|->
name|connectors
index|[
name|ro
index|]
operator|==
operator|&
name|connector
operator|->
name|base
condition|)
block|{
name|connector
operator|->
name|new_encoder
operator|=
name|connector
operator|->
name|encoder
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we disable the crtc, disable all its connectors. Also, if 		 * the connector is on the changing crtc but not on the new 		 * connector list, disable it. */
if|if
condition|(
operator|(
operator|!
name|set
operator|->
name|fb
operator|||
name|ro
operator|==
name|set
operator|->
name|num_connectors
operator|)
operator|&&
name|connector
operator|->
name|base
operator|.
name|encoder
operator|&&
name|connector
operator|->
name|base
operator|.
name|encoder
operator|->
name|crtc
operator|==
name|set
operator|->
name|crtc
condition|)
block|{
name|connector
operator|->
name|new_encoder
operator|=
name|NULL
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s] to [NOCRTC]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
operator|&
name|connector
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|&
name|connector
operator|->
name|new_encoder
operator|->
name|base
operator|!=
name|connector
operator|->
name|base
operator|.
name|encoder
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"encoder changed, full mode switch\n"
argument_list|)
expr_stmt|;
name|config
operator|->
name|mode_changed
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* connector->new_encoder is now updated for all connectors. */
comment|/* Update crtc of enabled connectors. */
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
operator|!
name|connector
operator|->
name|new_encoder
condition|)
continue|continue;
name|new_crtc
operator|=
name|connector
operator|->
name|new_encoder
operator|->
name|base
operator|.
name|crtc
expr_stmt|;
for|for
control|(
name|ro
operator|=
literal|0
init|;
name|ro
operator|<
name|set
operator|->
name|num_connectors
condition|;
name|ro
operator|++
control|)
block|{
if|if
condition|(
name|set
operator|->
name|connectors
index|[
name|ro
index|]
operator|==
operator|&
name|connector
operator|->
name|base
condition|)
name|new_crtc
operator|=
name|set
operator|->
name|crtc
expr_stmt|;
block|}
comment|/* Make sure the new CRTC will work with the encoder */
if|if
condition|(
operator|!
name|intel_encoder_crtc_ok
argument_list|(
operator|&
name|connector
operator|->
name|new_encoder
operator|->
name|base
argument_list|,
name|new_crtc
argument_list|)
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
name|connector
operator|->
name|encoder
operator|->
name|new_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|new_crtc
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s] to [CRTC:%d]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
operator|&
name|connector
operator|->
name|base
argument_list|)
argument_list|,
name|new_crtc
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
comment|/* Check for any encoders that needs to be disabled. */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|connector
operator|->
name|new_encoder
operator|==
name|encoder
condition|)
block|{
name|WARN_ON
argument_list|(
operator|!
name|connector
operator|->
name|new_encoder
operator|->
name|new_crtc
argument_list|)
expr_stmt|;
goto|goto
name|next_encoder
goto|;
block|}
block|}
name|encoder
operator|->
name|new_crtc
operator|=
name|NULL
expr_stmt|;
name|next_encoder
label|:
comment|/* Only now check for crtc changes so we don't miss encoders 		 * that will be disabled. */
if|if
condition|(
operator|&
name|encoder
operator|->
name|new_crtc
operator|->
name|base
operator|!=
name|encoder
operator|->
name|base
operator|.
name|crtc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"crtc changed, full mode switch\n"
argument_list|)
expr_stmt|;
name|config
operator|->
name|mode_changed
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Now we've also updated encoder->new_crtc for all encoders. */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_crtc_set_config
parameter_list|(
name|struct
name|drm_mode_set
modifier|*
name|set
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|drm_mode_set
name|save_set
decl_stmt|;
name|struct
name|intel_set_config
modifier|*
name|config
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|set
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|set
operator|->
name|crtc
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|set
operator|->
name|crtc
operator|->
name|helper_private
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|->
name|mode
condition|)
name|set
operator|->
name|fb
operator|=
name|NULL
expr_stmt|;
comment|/* The fb helper likes to play gross jokes with ->mode_set_config. 	 * Unfortunately the crtc helper doesn't do much at all for this case, 	 * so we have to cope with this madness until the fb helper is fixed up. */
if|if
condition|(
name|set
operator|->
name|fb
operator|&&
name|set
operator|->
name|num_connectors
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|set
operator|->
name|fb
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CRTC:%d] [FB:%d] #connectors=%d (x y) (%i %i)\n"
argument_list|,
name|set
operator|->
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|,
name|set
operator|->
name|fb
operator|->
name|base
operator|.
name|id
argument_list|,
operator|(
name|int
operator|)
name|set
operator|->
name|num_connectors
argument_list|,
name|set
operator|->
name|x
argument_list|,
name|set
operator|->
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CRTC:%d] [NOFB]\n"
argument_list|,
name|set
operator|->
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
name|dev
operator|=
name|set
operator|->
name|crtc
operator|->
name|dev
expr_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
name|config
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|config
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
condition|)
goto|goto
name|out_config
goto|;
name|ret
operator|=
name|intel_set_config_save_state
argument_list|(
name|dev
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out_config
goto|;
name|save_set
operator|.
name|crtc
operator|=
name|set
operator|->
name|crtc
expr_stmt|;
name|save_set
operator|.
name|mode
operator|=
operator|&
name|set
operator|->
name|crtc
operator|->
name|mode
expr_stmt|;
name|save_set
operator|.
name|x
operator|=
name|set
operator|->
name|crtc
operator|->
name|x
expr_stmt|;
name|save_set
operator|.
name|y
operator|=
name|set
operator|->
name|crtc
operator|->
name|y
expr_stmt|;
name|save_set
operator|.
name|fb
operator|=
name|set
operator|->
name|crtc
operator|->
name|fb
expr_stmt|;
comment|/* Compute whether we need a full modeset, only an fb base update or no 	 * change at all. In the future we might also check whether only the 	 * mode changed, e.g. for LVDS where we only change the panel fitter in 	 * such cases. */
name|intel_set_config_compute_mode_changes
argument_list|(
name|set
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_modeset_stage_output_state
argument_list|(
name|dev
argument_list|,
name|set
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|config
operator|->
name|mode_changed
condition|)
block|{
if|if
condition|(
name|set
operator|->
name|mode
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"attempting to set mode from"
literal|" userspace\n"
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|set
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|intel_set_mode
argument_list|(
name|set
operator|->
name|crtc
argument_list|,
name|set
operator|->
name|mode
argument_list|,
name|set
operator|->
name|x
argument_list|,
name|set
operator|->
name|y
argument_list|,
name|set
operator|->
name|fb
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to set mode on [CRTC:%d]\n"
argument_list|,
name|set
operator|->
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|config
operator|->
name|fb_changed
condition|)
block|{
name|ret
operator|=
name|intel_pipe_set_base
argument_list|(
name|set
operator|->
name|crtc
argument_list|,
name|set
operator|->
name|x
argument_list|,
name|set
operator|->
name|y
argument_list|,
name|set
operator|->
name|fb
argument_list|)
expr_stmt|;
block|}
name|intel_set_config_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|intel_set_config_restore_state
argument_list|(
name|dev
argument_list|,
name|config
argument_list|)
expr_stmt|;
comment|/* Try to restore the config */
if|if
condition|(
name|config
operator|->
name|mode_changed
operator|&&
operator|!
name|intel_set_mode
argument_list|(
name|save_set
operator|.
name|crtc
argument_list|,
name|save_set
operator|.
name|mode
argument_list|,
name|save_set
operator|.
name|x
argument_list|,
name|save_set
operator|.
name|y
argument_list|,
name|save_set
operator|.
name|fb
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to restore config after modeset failure\n"
argument_list|)
expr_stmt|;
name|out_config
label|:
name|intel_set_config_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_crtc_funcs
name|intel_crtc_funcs
init|=
block|{
operator|.
name|cursor_set
operator|=
name|intel_crtc_cursor_set
block|,
operator|.
name|cursor_move
operator|=
name|intel_crtc_cursor_move
block|,
operator|.
name|gamma_set
operator|=
name|intel_crtc_gamma_set
block|,
operator|.
name|set_config
operator|=
name|intel_crtc_set_config
block|,
operator|.
name|destroy
operator|=
name|intel_crtc_destroy
block|,
operator|.
name|page_flip
operator|=
name|intel_crtc_page_flip
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|intel_cpu_pll_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_ddi_pll_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_pch_pll_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|num_pch_pll
operator|==
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"No PCH PLLs on this hardware, skipping initialisation\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|num_pch_pll
condition|;
name|i
operator|++
control|)
block|{
name|dev_priv
operator|->
name|pch_plls
index|[
name|i
index|]
operator|.
name|pll_reg
operator|=
name|_PCH_DPLL
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|pch_plls
index|[
name|i
index|]
operator|.
name|fp0_reg
operator|=
name|_PCH_FP0
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|pch_plls
index|[
name|i
index|]
operator|.
name|fp1_reg
operator|=
name|_PCH_FP1
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|intel_crtc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intel_crtc
argument_list|)
operator|+
operator|(
name|INTELFB_CONN_LIMIT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_connector
operator|*
argument_list|)
operator|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_crtc
operator|==
name|NULL
condition|)
return|return;
name|drm_crtc_init
argument_list|(
name|dev
argument_list|,
operator|&
name|intel_crtc
operator|->
name|base
argument_list|,
operator|&
name|intel_crtc_funcs
argument_list|)
expr_stmt|;
name|drm_mode_crtc_set_gamma_size
argument_list|(
operator|&
name|intel_crtc
operator|->
name|base
argument_list|,
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|intel_crtc
operator|->
name|lut_r
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|intel_crtc
operator|->
name|lut_g
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|intel_crtc
operator|->
name|lut_b
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* Swap pipes& planes for FBC on pre-965 */
name|intel_crtc
operator|->
name|pipe
operator|=
name|pipe
expr_stmt|;
name|intel_crtc
operator|->
name|plane
operator|=
name|pipe
expr_stmt|;
name|intel_crtc
operator|->
name|cpu_transcoder
operator|=
name|pipe
expr_stmt|;
if|if
condition|(
name|IS_MOBILE
argument_list|(
name|dev
argument_list|)
operator|&&
name|IS_GEN3
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"swapping pipes& planes for FBC\n"
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|plane
operator|=
operator|!
name|pipe
expr_stmt|;
block|}
name|BUG_ON
argument_list|(
name|pipe
operator|>=
name|ARRAY_SIZE
argument_list|(
name|dev_priv
operator|->
name|plane_to_crtc_mapping
argument_list|)
operator|||
name|dev_priv
operator|->
name|plane_to_crtc_mapping
index|[
name|intel_crtc
operator|->
name|plane
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|plane_to_crtc_mapping
index|[
name|intel_crtc
operator|->
name|plane
index|]
operator|=
operator|&
name|intel_crtc
operator|->
name|base
expr_stmt|;
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|intel_crtc
operator|->
name|pipe
index|]
operator|=
operator|&
name|intel_crtc
operator|->
name|base
expr_stmt|;
name|intel_crtc
operator|->
name|bpp
operator|=
literal|24
expr_stmt|;
comment|/* default for pre-Ironlake */
name|drm_crtc_helper_add
argument_list|(
operator|&
name|intel_crtc
operator|->
name|base
argument_list|,
operator|&
name|intel_helper_funcs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|intel_get_pipe_from_crtc_id
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_get_pipe_from_crtc_id
modifier|*
name|pipe_from_crtc_id
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|drmmode_obj
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|crtc
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
name|drmmode_obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|pipe_from_crtc_id
operator|->
name|crtc_id
argument_list|,
name|DRM_MODE_OBJECT_CRTC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drmmode_obj
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"no such CRTC id\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|crtc
operator|=
name|to_intel_crtc
argument_list|(
name|obj_to_crtc
argument_list|(
name|drmmode_obj
argument_list|)
argument_list|)
expr_stmt|;
name|pipe_from_crtc_id
operator|->
name|pipe
operator|=
name|crtc
operator|->
name|pipe
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_encoder_clones
parameter_list|(
name|struct
name|intel_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|source_encoder
decl_stmt|;
name|int
name|index_mask
init|=
literal|0
decl_stmt|;
name|int
name|entry
init|=
literal|0
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|source_encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|==
name|source_encoder
condition|)
name|index_mask
operator||=
operator|(
literal|1
operator|<<
name|entry
operator|)
expr_stmt|;
comment|/* Intel hw has only one MUX where enocoders could be cloned. */
if|if
condition|(
name|encoder
operator|->
name|cloneable
operator|&&
name|source_encoder
operator|->
name|cloneable
condition|)
name|index_mask
operator||=
operator|(
literal|1
operator|<<
name|entry
operator|)
expr_stmt|;
name|entry
operator|++
expr_stmt|;
block|}
return|return
name|index_mask
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|has_edp_a
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|IS_MOBILE
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|DP_A
argument_list|)
operator|&
name|DP_DETECTED
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN_FUSES
argument_list|)
operator|&
name|ILK_eDP_A_DISABLE
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_setup_outputs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|bool
name|dpd_is_edp
init|=
name|false
decl_stmt|;
name|bool
name|has_lvds
decl_stmt|;
name|has_lvds
operator|=
name|intel_lvds_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_lvds
operator|&&
operator|!
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* disable the panel fitter on everything but LVDS */
name|I915_WRITE
argument_list|(
name|PFIT_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|I915_READ
argument_list|(
name|DDI_BUF_CTL
argument_list|(
name|PORT_A
argument_list|)
argument_list|)
operator|&
name|DDI_A_4_LANES
operator|)
operator|)
condition|)
name|intel_crt_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|int
name|found
decl_stmt|;
comment|/* Haswell uses DDI functions to detect digital outputs */
name|found
operator|=
name|I915_READ
argument_list|(
name|DDI_BUF_CTL_A
argument_list|)
operator|&
name|DDI_INIT_DISPLAY_DETECTED
expr_stmt|;
comment|/* DDI A only supports eDP */
if|if
condition|(
name|found
condition|)
name|intel_ddi_init
argument_list|(
name|dev
argument_list|,
name|PORT_A
argument_list|)
expr_stmt|;
comment|/* DDI B, C and D detection is indicated by the SFUSE_STRAP 		 * register */
name|found
operator|=
name|I915_READ
argument_list|(
name|SFUSE_STRAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&
name|SFUSE_STRAP_DDIB_DETECTED
condition|)
name|intel_ddi_init
argument_list|(
name|dev
argument_list|,
name|PORT_B
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&
name|SFUSE_STRAP_DDIC_DETECTED
condition|)
name|intel_ddi_init
argument_list|(
name|dev
argument_list|,
name|PORT_C
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&
name|SFUSE_STRAP_DDID_DETECTED
condition|)
name|intel_ddi_init
argument_list|(
name|dev
argument_list|,
name|PORT_D
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|int
name|found
decl_stmt|;
name|dpd_is_edp
operator|=
name|intel_dpd_is_edp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_edp_a
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|DP_A
argument_list|,
name|PORT_A
argument_list|)
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|HDMIB
argument_list|)
operator|&
name|PORT_DETECTED
condition|)
block|{
comment|/* PCH SDVOB multiplex with HDMIB */
name|found
operator|=
name|intel_sdvo_init
argument_list|(
name|dev
argument_list|,
name|PCH_SDVOB
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|HDMIB
argument_list|,
name|PORT_B
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
operator|&&
operator|(
name|I915_READ
argument_list|(
name|PCH_DP_B
argument_list|)
operator|&
name|DP_DETECTED
operator|)
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|PCH_DP_B
argument_list|,
name|PORT_B
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|I915_READ
argument_list|(
name|HDMIC
argument_list|)
operator|&
name|PORT_DETECTED
condition|)
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|HDMIC
argument_list|,
name|PORT_C
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dpd_is_edp
operator|&&
name|I915_READ
argument_list|(
name|HDMID
argument_list|)
operator|&
name|PORT_DETECTED
condition|)
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|HDMID
argument_list|,
name|PORT_D
argument_list|)
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|PCH_DP_C
argument_list|)
operator|&
name|DP_DETECTED
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|PCH_DP_C
argument_list|,
name|PORT_C
argument_list|)
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|PCH_DP_D
argument_list|)
operator|&
name|DP_DETECTED
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|PCH_DP_D
argument_list|,
name|PORT_D
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|int
name|found
decl_stmt|;
comment|/* Check for built-in panel first. Shares lanes with HDMI on SDVOC */
if|if
condition|(
name|I915_READ
argument_list|(
name|DP_C
argument_list|)
operator|&
name|DP_DETECTED
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|DP_C
argument_list|,
name|PORT_C
argument_list|)
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|SDVOB
argument_list|)
operator|&
name|PORT_DETECTED
condition|)
block|{
comment|/* SDVOB multiplex with HDMIB */
name|found
operator|=
name|intel_sdvo_init
argument_list|(
name|dev
argument_list|,
name|SDVOB
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|SDVOB
argument_list|,
name|PORT_B
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
operator|&&
operator|(
name|I915_READ
argument_list|(
name|DP_B
argument_list|)
operator|&
name|DP_DETECTED
operator|)
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|DP_B
argument_list|,
name|PORT_B
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|I915_READ
argument_list|(
name|SDVOC
argument_list|)
operator|&
name|PORT_DETECTED
condition|)
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|SDVOC
argument_list|,
name|PORT_C
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SUPPORTS_DIGITAL_OUTPUTS
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|bool
name|found
init|=
name|false
decl_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|SDVOB
argument_list|)
operator|&
name|SDVO_DETECTED
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing SDVOB\n"
argument_list|)
expr_stmt|;
name|found
operator|=
name|intel_sdvo_init
argument_list|(
name|dev
argument_list|,
name|SDVOB
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
operator|&&
name|SUPPORTS_INTEGRATED_HDMI
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing HDMI on SDVOB\n"
argument_list|)
expr_stmt|;
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|SDVOB
argument_list|,
name|PORT_B
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
operator|&&
name|SUPPORTS_INTEGRATED_DP
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing DP_B\n"
argument_list|)
expr_stmt|;
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|DP_B
argument_list|,
name|PORT_B
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Before G4X SDVOC doesn't have its own detect register */
if|if
condition|(
name|I915_READ
argument_list|(
name|SDVOB
argument_list|)
operator|&
name|SDVO_DETECTED
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing SDVOC\n"
argument_list|)
expr_stmt|;
name|found
operator|=
name|intel_sdvo_init
argument_list|(
name|dev
argument_list|,
name|SDVOC
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
operator|&&
operator|(
name|I915_READ
argument_list|(
name|SDVOC
argument_list|)
operator|&
name|SDVO_DETECTED
operator|)
condition|)
block|{
if|if
condition|(
name|SUPPORTS_INTEGRATED_HDMI
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing HDMI on SDVOC\n"
argument_list|)
expr_stmt|;
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|SDVOC
argument_list|,
name|PORT_C
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUPPORTS_INTEGRATED_DP
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing DP_C\n"
argument_list|)
expr_stmt|;
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|DP_C
argument_list|,
name|PORT_C
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SUPPORTS_INTEGRATED_DP
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|I915_READ
argument_list|(
name|DP_D
argument_list|)
operator|&
name|DP_DETECTED
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing DP_D\n"
argument_list|)
expr_stmt|;
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|DP_D
argument_list|,
name|PORT_D
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_dvo_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUPPORTS_TV
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_tv_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|encoder
operator|->
name|base
operator|.
name|possible_crtcs
operator|=
name|encoder
operator|->
name|crtc_mask
expr_stmt|;
name|encoder
operator|->
name|base
operator|.
name|possible_clones
operator|=
name|intel_encoder_clones
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
name|intel_init_pch_refclk
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|drm_helper_move_panel_connectors_to_head
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_user_framebuffer_destroy
parameter_list|(
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|)
block|{
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
init|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
decl_stmt|;
name|drm_framebuffer_cleanup
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference_unlocked
argument_list|(
operator|&
name|intel_fb
operator|->
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intel_fb
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_user_framebuffer_create_handle
parameter_list|(
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
init|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|intel_fb
operator|->
name|obj
decl_stmt|;
return|return
name|drm_gem_handle_create
argument_list|(
name|file
argument_list|,
operator|&
name|obj
operator|->
name|base
argument_list|,
name|handle
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_framebuffer_funcs
name|intel_fb_funcs
init|=
block|{
operator|.
name|destroy
operator|=
name|intel_user_framebuffer_destroy
block|,
operator|.
name|create_handle
operator|=
name|intel_user_framebuffer_create_handle
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|intel_framebuffer_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
parameter_list|,
name|struct
name|drm_mode_fb_cmd2
modifier|*
name|mode_cmd
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_Y
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"hardware does not support tiling Y\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|mode_cmd
operator|->
name|pitches
index|[
literal|0
index|]
operator|&
literal|63
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"pitch (%d) must be at least 64 byte aligned\n"
argument_list|,
name|mode_cmd
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* FIXME<= Gen4 stride limits are bit unclear */
if|if
condition|(
name|mode_cmd
operator|->
name|pitches
index|[
literal|0
index|]
operator|>
literal|32768
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"pitch (%d) must be at less than 32768\n"
argument_list|,
name|mode_cmd
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
operator|&&
name|mode_cmd
operator|->
name|pitches
index|[
literal|0
index|]
operator|!=
name|obj
operator|->
name|stride
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"pitch (%d) must match tiling stride (%d)\n"
argument_list|,
name|mode_cmd
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|,
name|obj
operator|->
name|stride
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Reject formats not supported by any plane early. */
switch|switch
condition|(
name|mode_cmd
operator|->
name|pixel_format
condition|)
block|{
case|case
name|DRM_FORMAT_C8
case|:
case|case
name|DRM_FORMAT_RGB565
case|:
case|case
name|DRM_FORMAT_XRGB8888
case|:
case|case
name|DRM_FORMAT_ARGB8888
case|:
break|break;
case|case
name|DRM_FORMAT_XRGB1555
case|:
case|case
name|DRM_FORMAT_ARGB1555
case|:
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>
literal|3
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"invalid format: 0x%08x\n"
argument_list|,
name|mode_cmd
operator|->
name|pixel_format
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
break|break;
case|case
name|DRM_FORMAT_XBGR8888
case|:
case|case
name|DRM_FORMAT_ABGR8888
case|:
case|case
name|DRM_FORMAT_XRGB2101010
case|:
case|case
name|DRM_FORMAT_ARGB2101010
case|:
case|case
name|DRM_FORMAT_XBGR2101010
case|:
case|case
name|DRM_FORMAT_ABGR2101010
case|:
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"invalid format: 0x%08x\n"
argument_list|,
name|mode_cmd
operator|->
name|pixel_format
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
break|break;
case|case
name|DRM_FORMAT_YUYV
case|:
case|case
name|DRM_FORMAT_UYVY
case|:
case|case
name|DRM_FORMAT_YVYU
case|:
case|case
name|DRM_FORMAT_VYUY
case|:
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|5
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"invalid format: 0x%08x\n"
argument_list|,
name|mode_cmd
operator|->
name|pixel_format
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
break|break;
default|default:
name|DRM_DEBUG
argument_list|(
literal|"unsupported pixel format 0x%08x\n"
argument_list|,
name|mode_cmd
operator|->
name|pixel_format
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* FIXME need to adjust LINOFF/TILEOFF accordingly. */
if|if
condition|(
name|mode_cmd
operator|->
name|offsets
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|ret
operator|=
name|drm_framebuffer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|intel_fb
operator|->
name|base
argument_list|,
operator|&
name|intel_fb_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"framebuffer init failed %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|drm_helper_mode_fill_fb_struct
argument_list|(
operator|&
name|intel_fb
operator|->
name|base
argument_list|,
name|mode_cmd
argument_list|)
expr_stmt|;
name|intel_fb
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_user_framebuffer_create
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|filp
parameter_list|,
name|struct
name|drm_mode_fb_cmd2
modifier|*
name|mode_cmd
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|,
name|mode_cmd
operator|->
name|handles
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOENT
return|;
return|return
name|intel_framebuffer_create
argument_list|(
name|dev
argument_list|,
name|mode_cmd
argument_list|,
name|obj
argument_list|,
name|res
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_mode_config_funcs
name|intel_mode_funcs
init|=
block|{
operator|.
name|fb_create
operator|=
name|intel_user_framebuffer_create
block|,
operator|.
name|output_poll_changed
operator|=
name|intel_fb_output_poll_changed
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up chip specific display functions */
end_comment

begin_function
specifier|static
name|void
name|intel_init_display
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* We always want a DPMS function */
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|crtc_mode_set
operator|=
name|haswell_crtc_mode_set
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|crtc_enable
operator|=
name|haswell_crtc_enable
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|crtc_disable
operator|=
name|haswell_crtc_disable
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|off
operator|=
name|haswell_crtc_off
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_plane
operator|=
name|ironlake_update_plane
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|crtc_mode_set
operator|=
name|ironlake_crtc_mode_set
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|crtc_enable
operator|=
name|ironlake_crtc_enable
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|crtc_disable
operator|=
name|ironlake_crtc_disable
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|off
operator|=
name|ironlake_crtc_off
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_plane
operator|=
name|ironlake_update_plane
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|display
operator|.
name|crtc_mode_set
operator|=
name|i9xx_crtc_mode_set
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|crtc_enable
operator|=
name|i9xx_crtc_enable
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|crtc_disable
operator|=
name|i9xx_crtc_disable
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|off
operator|=
name|i9xx_crtc_off
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_plane
operator|=
name|i9xx_update_plane
expr_stmt|;
block|}
comment|/* Returns the core display clock speed */
if|if
condition|(
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|valleyview_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
operator|(
name|IS_G33
argument_list|(
name|dev
argument_list|)
operator|&&
operator|!
name|IS_PINEVIEW_M
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i945_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I915G
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i915_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_845G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_PINEVIEW_M
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i9xx_misc_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I915GM
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i915gm_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I865G
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i865_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I85X
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i855_get_display_clock_speed
expr_stmt|;
else|else
comment|/* 852, 830 */
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i830_get_display_clock_speed
expr_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
operator|=
name|ironlake_fdi_link_train
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
operator|=
name|ironlake_write_eld
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
operator|=
name|gen6_fdi_link_train
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
operator|=
name|ironlake_write_eld
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* FIXME: detect B0+ stepping and use auto training */
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
operator|=
name|ivb_manual_fdi_link_train
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
operator|=
name|ironlake_write_eld
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|modeset_global_resources
operator|=
name|ivb_modeset_global_resources
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
operator|=
name|hsw_fdi_link_train
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
operator|=
name|haswell_write_eld
expr_stmt|;
block|}
else|else
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
operator|=
name|g4x_write_eld
expr_stmt|;
block|}
comment|/* Default just returns -ENODEV to indicate unsupported */
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_default_queue_flip
expr_stmt|;
switch|switch
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
condition|)
block|{
case|case
literal|2
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen2_queue_flip
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen3_queue_flip
expr_stmt|;
break|break;
case|case
literal|4
case|:
case|case
literal|5
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen4_queue_flip
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen6_queue_flip
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen7_queue_flip
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Some BIOSes insist on assuming the GPU's pipe A is enabled at suspend,  * resume, or other times.  This quirk makes sure that's the case for  * affected systems.  */
end_comment

begin_function
specifier|static
name|void
name|quirk_pipea_force
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|quirks
operator||=
name|QUIRK_PIPEA_FORCE
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"applying pipe a force quirk\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Some machines (Lenovo U160) do not work with SSC on LVDS for some reason  */
end_comment

begin_function
specifier|static
name|void
name|quirk_ssc_force_disable
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|quirks
operator||=
name|QUIRK_LVDS_SSC_DISABLE
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"applying lvds SSC disable quirk\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A machine (e.g. Acer Aspire 5734Z) may need to invert the panel backlight  * brightness value  */
end_comment

begin_function
specifier|static
name|void
name|quirk_invert_brightness
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|quirks
operator||=
name|QUIRK_INVERT_BRIGHTNESS
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"applying inverted panel brightness quirk\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|intel_quirk
block|{
name|int
name|device
decl_stmt|;
name|int
name|subsystem_vendor
decl_stmt|;
name|int
name|subsystem_device
decl_stmt|;
name|void
function_decl|(
modifier|*
name|hook
function_decl|)
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* For systems that don't have a meaningful PCI subdevice/subvendor ID */
end_comment

begin_struct
struct|struct
name|intel_dmi_quirk
block|{
name|void
function_decl|(
modifier|*
name|hook
function_decl|)
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
function_decl|;
specifier|const
name|struct
name|dmi_system_id
argument_list|(
operator|*
name|dmi_id_list
argument_list|)
decl|[]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|intel_dmi_reverse_brightness
parameter_list|(
specifier|const
name|struct
name|dmi_system_id
modifier|*
name|id
parameter_list|)
block|{
name|DRM_INFO
argument_list|(
literal|"Backlight polarity reversed on %s\n"
argument_list|,
name|id
operator|->
name|ident
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_dmi_quirk
name|intel_dmi_quirks
index|[]
init|=
block|{
block|{
operator|.
name|dmi_id_list
operator|=
operator|&
operator|(
specifier|const
expr|struct
name|dmi_system_id
index|[]
operator|)
block|{
block|{
operator|.
name|callback
operator|=
name|intel_dmi_reverse_brightness
block|,
operator|.
name|ident
operator|=
literal|"NCR Corporation"
block|,
operator|.
name|matches
operator|=
block|{
name|DMI_MATCH
argument_list|(
name|DMI_SYS_VENDOR
argument_list|,
literal|"NCR Corporation"
argument_list|)
block|,
name|DMI_MATCH
argument_list|(
name|DMI_PRODUCT_NAME
argument_list|,
literal|""
argument_list|)
block|, 				}
block|, 			}
block|,
block|{ }
comment|/* terminating entry */
block|}
block|,
operator|.
name|hook
operator|=
name|quirk_invert_brightness
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PCI_ANY_ID
value|(~0u)
end_define

begin_decl_stmt
specifier|static
name|struct
name|intel_quirk
name|intel_quirks
index|[]
init|=
block|{
comment|/* HP Mini needs pipe A force quirk (LP: #322104) */
block|{
literal|0x27ae
block|,
literal|0x103c
block|,
literal|0x361a
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* Toshiba Protege R-205, S-209 needs pipe A force quirk */
block|{
literal|0x2592
block|,
literal|0x1179
block|,
literal|0x0001
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* ThinkPad T60 needs pipe A force quirk (bug #16494) */
block|{
literal|0x2782
block|,
literal|0x17aa
block|,
literal|0x201a
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* 830/845 need to leave pipe A& dpll A up */
block|{
literal|0x2562
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
name|quirk_pipea_force
block|}
block|,
block|{
literal|0x3577
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* Lenovo U160 cannot use SSC on LVDS */
block|{
literal|0x0046
block|,
literal|0x17aa
block|,
literal|0x3920
block|,
name|quirk_ssc_force_disable
block|}
block|,
comment|/* Sony Vaio Y cannot use SSC on LVDS */
block|{
literal|0x0046
block|,
literal|0x104d
block|,
literal|0x9076
block|,
name|quirk_ssc_force_disable
block|}
block|,
comment|/* Acer Aspire 5734Z must invert backlight brightness */
block|{
literal|0x2a42
block|,
literal|0x1025
block|,
literal|0x0459
block|,
name|quirk_invert_brightness
block|}
block|,
comment|/* Acer Aspire 4736Z */
block|{
literal|0x2a42
block|,
literal|0x1025
block|,
literal|0x0260
block|,
name|quirk_invert_brightness
block|}
block|,
comment|/* Acer/eMachines G725 */
block|{
literal|0x2a42
block|,
literal|0x1025
block|,
literal|0x0210
block|,
name|quirk_invert_brightness
block|}
block|,
comment|/* Acer/eMachines e725 */
block|{
literal|0x2a42
block|,
literal|0x1025
block|,
literal|0x0212
block|,
name|quirk_invert_brightness
block|}
block|,
comment|/* Acer/Packard Bell NCL20 */
block|{
literal|0x2a42
block|,
literal|0x1025
block|,
literal|0x034b
block|,
name|quirk_invert_brightness
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|intel_init_quirks
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|intel_quirks
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|intel_quirk
modifier|*
name|q
init|=
operator|&
name|intel_quirks
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pci_get_device
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|==
name|q
operator|->
name|device
operator|&&
operator|(
name|pci_get_subvendor
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|==
name|q
operator|->
name|subsystem_vendor
operator|||
name|q
operator|->
name|subsystem_vendor
operator|==
name|PCI_ANY_ID
operator|)
operator|&&
operator|(
name|pci_get_subdevice
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|==
name|q
operator|->
name|subsystem_device
operator|||
name|q
operator|->
name|subsystem_device
operator|==
name|PCI_ANY_ID
operator|)
condition|)
name|q
operator|->
name|hook
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|intel_dmi_quirks
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dmi_check_system
argument_list|(
operator|*
name|intel_dmi_quirks
index|[
name|i
index|]
operator|.
name|dmi_id_list
argument_list|)
operator|!=
literal|0
condition|)
name|intel_dmi_quirks
index|[
name|i
index|]
operator|.
name|hook
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Disable the VGA plane that we never use */
end_comment

begin_function
specifier|static
name|void
name|i915_disable_vga
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u8
name|sr1
decl_stmt|;
name|u32
name|vga_reg
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|vga_reg
operator|=
name|CPU_VGACNTRL
expr_stmt|;
else|else
name|vga_reg
operator|=
name|VGACNTRL
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|vga_get_uninterruptible
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|VGA_RSRC_LEGACY_IO
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|outb
argument_list|(
name|VGA_SR_INDEX
argument_list|,
name|SR01
argument_list|)
expr_stmt|;
name|sr1
operator|=
name|inb
argument_list|(
name|VGA_SR_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|VGA_SR_DATA
argument_list|,
name|sr1
operator||
literal|1
operator|<<
literal|5
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|vga_put
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|VGA_RSRC_LEGACY_IO
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|udelay
argument_list|(
literal|300
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|vga_reg
argument_list|,
name|VGA_DISP_DISABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|vga_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_modeset_init_hw
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
comment|/* We attempt to init the necessary power wells early in the initialization 	 * time, so the subsystems that expect power to be enabled can work. 	 */
name|intel_init_power_wells
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_prepare_ddi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_init_clock_gating
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_enable_gt_powersave
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_modeset_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|drm_mode_config_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|min_width
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|min_height
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|preferred_depth
operator|=
literal|24
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|prefer_shadow
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|funcs
operator|=
operator|&
name|intel_mode_funcs
expr_stmt|;
name|intel_init_quirks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_init_pm
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_init_display
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|mode_config
operator|.
name|max_width
operator|=
literal|2048
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|max_height
operator|=
literal|2048
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN3
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|mode_config
operator|.
name|max_width
operator|=
literal|4096
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|max_height
operator|=
literal|4096
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|mode_config
operator|.
name|max_width
operator|=
literal|8192
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|max_height
operator|=
literal|8192
expr_stmt|;
block|}
name|dev
operator|->
name|mode_config
operator|.
name|fb_base
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"%d display pipe%s available.\n"
argument_list|,
name|dev_priv
operator|->
name|num_pipe
argument_list|,
name|dev_priv
operator|->
name|num_pipe
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|num_pipe
condition|;
name|i
operator|++
control|)
block|{
name|intel_crtc_init
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_plane_init
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"plane %d init failed: %d\n"
argument_list|,
name|i
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
name|intel_cpu_pll_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_pch_pll_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Just disable it once at startup */
name|i915_disable_vga
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_setup_outputs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_connector_break_all_links
parameter_list|(
name|struct
name|intel_connector
modifier|*
name|connector
parameter_list|)
block|{
name|connector
operator|->
name|base
operator|.
name|dpms
operator|=
name|DRM_MODE_DPMS_OFF
expr_stmt|;
name|connector
operator|->
name|base
operator|.
name|encoder
operator|=
name|NULL
expr_stmt|;
name|connector
operator|->
name|encoder
operator|->
name|connectors_active
operator|=
name|false
expr_stmt|;
name|connector
operator|->
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_enable_pipe_a
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|intel_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|crt
init|=
name|NULL
decl_stmt|;
name|struct
name|intel_load_detect_pipe
name|load_detect_temp
decl_stmt|;
comment|/* We can't just switch on the pipe A, we need to set things up with a 	 * proper mode and output configuration. As a gross hack, enable pipe A 	 * by enabling the load detect pipe once. */
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder
operator|->
name|type
operator|==
name|INTEL_OUTPUT_ANALOG
condition|)
block|{
name|crt
operator|=
operator|&
name|connector
operator|->
name|base
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|crt
condition|)
return|return;
if|if
condition|(
name|intel_get_load_detect_pipe
argument_list|(
name|crt
argument_list|,
name|NULL
argument_list|,
operator|&
name|load_detect_temp
argument_list|)
condition|)
name|intel_release_load_detect_pipe
argument_list|(
name|crt
argument_list|,
operator|&
name|load_detect_temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_check_plane_mapping
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|crtc
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|num_pipe
operator|==
literal|1
condition|)
return|return
name|true
return|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
operator|!
name|crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
operator|&&
operator|(
operator|!
operator|!
operator|(
name|val
operator|&
name|DISPPLANE_SEL_PIPE_MASK
operator|)
operator|==
name|crtc
operator|->
name|pipe
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_sanitize_crtc
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|reg
decl_stmt|;
comment|/* Clear any frame start delays used for debugging left by the BIOS */
name|reg
operator|=
name|PIPECONF
argument_list|(
name|crtc
operator|->
name|cpu_transcoder
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
operator|~
name|PIPECONF_FRAME_START_DELAY_MASK
argument_list|)
expr_stmt|;
comment|/* We need to sanitize the plane -> pipe mapping first because this will 	 * disable the crtc (and hence change the state) if it is wrong. Note 	 * that gen4+ has a fixed plane -> pipe mapping.  */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
operator|&&
operator|!
name|intel_check_plane_mapping
argument_list|(
name|crtc
argument_list|)
condition|)
block|{
name|struct
name|intel_connector
modifier|*
name|connector
decl_stmt|;
name|bool
name|plane
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CRTC:%d] wrong plane connection detected!\n"
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
comment|/* Pipe has the wrong plane attached and the plane is active. 		 * Temporarily change the plane mapping and disable everything 		 * ...  */
name|plane
operator|=
name|crtc
operator|->
name|plane
expr_stmt|;
name|crtc
operator|->
name|plane
operator|=
operator|!
name|plane
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|crtc_disable
argument_list|(
operator|&
name|crtc
operator|->
name|base
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|plane
operator|=
name|plane
expr_stmt|;
comment|/* ... and break all links. */
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|!=
operator|&
name|crtc
operator|->
name|base
condition|)
continue|continue;
name|intel_connector_break_all_links
argument_list|(
name|connector
argument_list|)
expr_stmt|;
block|}
name|WARN_ON
argument_list|(
name|crtc
operator|->
name|active
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|base
operator|.
name|enabled
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|quirks
operator|&
name|QUIRK_PIPEA_FORCE
operator|&&
name|crtc
operator|->
name|pipe
operator|==
name|PIPE_A
operator|&&
operator|!
name|crtc
operator|->
name|active
condition|)
block|{
comment|/* BIOS forgot to enable pipe A, this mostly happens after 		 * resume. Force-enable the pipe to fix this, the update_dpms 		 * call below we restore the pipe to the right state, but leave 		 * the required bits on. */
name|intel_enable_pipe_a
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust the state of the output pipe according to whether we 	 * have active connectors/encoders. */
name|intel_crtc_update_dpms
argument_list|(
operator|&
name|crtc
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|active
operator|!=
name|crtc
operator|->
name|base
operator|.
name|enabled
condition|)
block|{
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
comment|/* This can happen either due to bugs in the get_hw_state 		 * functions or because the pipe is force-enabled due to the 		 * pipe A quirk. */
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CRTC:%d] hw state adjusted, was %s, now %s\n"
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|enabled
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|crtc
operator|->
name|active
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|base
operator|.
name|enabled
operator|=
name|crtc
operator|->
name|active
expr_stmt|;
comment|/* Because we only establish the connector -> encoder -> 		 * crtc links if something is active, this means the 		 * crtc is now deactivated. Break the links. connector 		 * -> encoder links are only establish when things are 		 *  actually up, hence no need to break them. */
name|WARN_ON
argument_list|(
name|crtc
operator|->
name|active
argument_list|)
expr_stmt|;
name|for_each_encoder_on_crtc
argument_list|(
argument|dev
argument_list|,
argument|&crtc->base
argument_list|,
argument|encoder
argument_list|)
block|{
name|WARN_ON
argument_list|(
name|encoder
operator|->
name|connectors_active
argument_list|)
expr_stmt|;
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_sanitize_encoder
parameter_list|(
name|struct
name|intel_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|intel_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|base
operator|.
name|dev
decl_stmt|;
comment|/* We need to check both for a crtc link (meaning that the 	 * encoder is active and trying to read from a pipe) and the 	 * pipe itself being active. */
name|bool
name|has_active_crtc
init|=
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|&&
name|to_intel_crtc
argument_list|(
name|encoder
operator|->
name|base
operator|.
name|crtc
argument_list|)
operator|->
name|active
decl_stmt|;
if|if
condition|(
name|encoder
operator|->
name|connectors_active
operator|&&
operator|!
name|has_active_crtc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"[ENCODER:%d:%s] has active connectors but no active pipe!\n"
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Connector is active, but has no active pipe. This is 		 * fallout from our resume register restoring. Disable 		 * the encoder manually again. */
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"[ENCODER:%d:%s] manually disabled\n"
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|encoder
operator|->
name|disable
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
comment|/* Inconsistent output/port/pipe state happens presumably due to 		 * a bug in one of the get_hw_state functions. Or someplace else 		 * in our code, like the register restore mess on resume. Clamp 		 * things to off as a safer default. */
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder
operator|!=
name|encoder
condition|)
continue|continue;
name|intel_connector_break_all_links
argument_list|(
name|connector
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Enabled encoders without active connectors will be fixed in 	 * the crtc fixup. */
block|}
end_function

begin_function
specifier|static
name|void
name|i915_redisable_vga
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|vga_reg
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|vga_reg
operator|=
name|CPU_VGACNTRL
expr_stmt|;
else|else
name|vga_reg
operator|=
name|VGACNTRL
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|vga_reg
argument_list|)
operator|!=
name|VGA_DISP_DISABLE
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Something enabled VGA plane, disabling it\n"
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|vga_reg
argument_list|,
name|VGA_DISP_DISABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|vga_reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan out the current hw modeset state, sanitizes it and maps it into the drm  * and i915 state tracking structures. */
end_comment

begin_function
name|void
name|intel_modeset_setup_hw_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|bool
name|force_restore
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|enum
name|pipe
name|pipe
decl_stmt|;
name|u32
name|tmp
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|intel_connector
modifier|*
name|connector
decl_stmt|;
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|I915_READ
argument_list|(
name|TRANS_DDI_FUNC_CTL
argument_list|(
name|TRANSCODER_EDP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|TRANS_DDI_FUNC_ENABLE
condition|)
block|{
switch|switch
condition|(
name|tmp
operator|&
name|TRANS_DDI_EDP_INPUT_MASK
condition|)
block|{
case|case
name|TRANS_DDI_EDP_INPUT_A_ON
case|:
case|case
name|TRANS_DDI_EDP_INPUT_A_ONOFF
case|:
name|pipe
operator|=
name|PIPE_A
expr_stmt|;
break|break;
case|case
name|TRANS_DDI_EDP_INPUT_B_ONOFF
case|:
name|pipe
operator|=
name|PIPE_B
expr_stmt|;
break|break;
case|case
name|TRANS_DDI_EDP_INPUT_C_ONOFF
case|:
name|pipe
operator|=
name|PIPE_C
expr_stmt|;
break|break;
block|}
name|crtc
operator|=
name|to_intel_crtc
argument_list|(
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|pipe
index|]
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|cpu_transcoder
operator|=
name|TRANSCODER_EDP
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Pipe %c using transcoder EDP\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
block|{
name|crtc
operator|=
name|to_intel_crtc
argument_list|(
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|pipe
index|]
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|crtc
operator|->
name|cpu_transcoder
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|PIPECONF_ENABLE
condition|)
name|crtc
operator|->
name|active
operator|=
name|true
expr_stmt|;
else|else
name|crtc
operator|->
name|active
operator|=
name|false
expr_stmt|;
name|crtc
operator|->
name|base
operator|.
name|enabled
operator|=
name|crtc
operator|->
name|active
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CRTC:%d] hw state readout: %s\n"
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|crtc
operator|->
name|active
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_ddi_setup_hw_pll_state
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|pipe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|encoder
operator|->
name|get_hw_state
argument_list|(
name|encoder
argument_list|,
operator|&
name|pipe
argument_list|)
condition|)
block|{
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|=
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|pipe
index|]
expr_stmt|;
block|}
else|else
block|{
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|=
name|NULL
expr_stmt|;
block|}
name|encoder
operator|->
name|connectors_active
operator|=
name|false
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[ENCODER:%d:%s] hw state readout: %s, pipe=%i\n"
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|)
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|crtc
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|connector
operator|->
name|get_hw_state
argument_list|(
name|connector
argument_list|)
condition|)
block|{
name|connector
operator|->
name|base
operator|.
name|dpms
operator|=
name|DRM_MODE_DPMS_ON
expr_stmt|;
name|connector
operator|->
name|encoder
operator|->
name|connectors_active
operator|=
name|true
expr_stmt|;
name|connector
operator|->
name|base
operator|.
name|encoder
operator|=
operator|&
name|connector
operator|->
name|encoder
operator|->
name|base
expr_stmt|;
block|}
else|else
block|{
name|connector
operator|->
name|base
operator|.
name|dpms
operator|=
name|DRM_MODE_DPMS_OFF
expr_stmt|;
name|connector
operator|->
name|base
operator|.
name|encoder
operator|=
name|NULL
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s] hw state readout: %s\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
operator|&
name|connector
operator|->
name|base
argument_list|)
argument_list|,
name|connector
operator|->
name|base
operator|.
name|encoder
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
block|}
comment|/* HW state is read out, now we need to sanitize this mess. */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|intel_sanitize_encoder
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
block|{
name|crtc
operator|=
name|to_intel_crtc
argument_list|(
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|pipe
index|]
argument_list|)
expr_stmt|;
name|intel_sanitize_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_restore
condition|)
block|{
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
block|{
name|crtc
operator|=
name|to_intel_crtc
argument_list|(
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|pipe
index|]
argument_list|)
expr_stmt|;
name|intel_set_mode
argument_list|(
operator|&
name|crtc
operator|->
name|base
argument_list|,
operator|&
name|crtc
operator|->
name|base
operator|.
name|mode
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|x
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|y
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|fb
argument_list|)
expr_stmt|;
block|}
name|i915_redisable_vga
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|intel_modeset_update_staged_output_state
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|intel_modeset_check_state
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|drm_mode_config_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_modeset_gem_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|intel_modeset_init_hw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_setup_overlay
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_modeset_setup_hw_state
argument_list|(
name|dev
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_modeset_cleanup
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
name|drm_kms_helper_poll_fini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_unregister_dsm_handler
argument_list|()
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
comment|/* Skip inactive CRTCs */
if|if
condition|(
operator|!
name|crtc
operator|->
name|fb
condition|)
continue|continue;
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_increase_pllclock
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_disable_gt_powersave
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ironlake_teardown_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|vlv_init_dpio
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Disable the irq before mode object teardown, for the irq might 	 * enqueue unpin/hotplug work. */
name|drm_irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskqueue_cancel
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|hotplug_work
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|hotplug_work
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskqueue_cancel
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|work
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|work
argument_list|)
expr_stmt|;
comment|/* flush any delayed tasks or pending work */
name|taskqueue_drain_all
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|)
expr_stmt|;
comment|/* destroy backlight, if any, before the connectors */
name|intel_panel_destroy_backlight
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|drm_mode_config_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return which encoder is currently attached for connector.  */
end_comment

begin_function
name|struct
name|drm_encoder
modifier|*
name|intel_best_encoder
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
return|return
operator|&
name|intel_attached_encoder
argument_list|(
name|connector
argument_list|)
operator|->
name|base
return|;
block|}
end_function

begin_function
name|void
name|intel_connector_attach_encoder
parameter_list|(
name|struct
name|intel_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|intel_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|connector
operator|->
name|encoder
operator|=
name|encoder
expr_stmt|;
name|drm_mode_connector_attach_encoder
argument_list|(
operator|&
name|connector
operator|->
name|base
argument_list|,
operator|&
name|encoder
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set vga decode state - true == enable VGA decode  */
end_comment

begin_function
name|int
name|intel_modeset_vga_set_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u16
name|gmch_ctrl
decl_stmt|;
name|pci_read_config_word
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|INTEL_GMCH_CTRL
argument_list|,
operator|&
name|gmch_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
name|gmch_ctrl
operator|&=
operator|~
name|INTEL_GMCH_VGA_DISABLE
expr_stmt|;
else|else
name|gmch_ctrl
operator||=
name|INTEL_GMCH_VGA_DISABLE
expr_stmt|;
name|pci_write_config_word
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|INTEL_GMCH_CTRL
argument_list|,
name|gmch_ctrl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|//#ifdef CONFIG_DEBUG_FS
end_comment

begin_define
define|#
directive|define
name|seq_printf
parameter_list|(
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|sbuf_printf((m), (fmt), ##__VA_ARGS__)
end_define

begin_struct
struct|struct
name|intel_display_error_state
block|{
struct|struct
name|intel_cursor_error_state
block|{
name|u32
name|control
decl_stmt|;
name|u32
name|position
decl_stmt|;
name|u32
name|base
decl_stmt|;
name|u32
name|size
decl_stmt|;
block|}
name|cursor
index|[
name|I915_MAX_PIPES
index|]
struct|;
struct|struct
name|intel_pipe_error_state
block|{
name|u32
name|conf
decl_stmt|;
name|u32
name|source
decl_stmt|;
name|u32
name|htotal
decl_stmt|;
name|u32
name|hblank
decl_stmt|;
name|u32
name|hsync
decl_stmt|;
name|u32
name|vtotal
decl_stmt|;
name|u32
name|vblank
decl_stmt|;
name|u32
name|vsync
decl_stmt|;
block|}
name|pipe
index|[
name|I915_MAX_PIPES
index|]
struct|;
struct|struct
name|intel_plane_error_state
block|{
name|u32
name|control
decl_stmt|;
name|u32
name|stride
decl_stmt|;
name|u32
name|size
decl_stmt|;
name|u32
name|pos
decl_stmt|;
name|u32
name|addr
decl_stmt|;
name|u32
name|surface
decl_stmt|;
name|u32
name|tile_offset
decl_stmt|;
block|}
name|plane
index|[
name|I915_MAX_PIPES
index|]
struct|;
block|}
struct|;
end_struct

begin_function
name|struct
name|intel_display_error_state
modifier|*
name|intel_display_capture_error_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_display_error_state
modifier|*
name|error
decl_stmt|;
name|enum
name|transcoder
name|cpu_transcoder
decl_stmt|;
name|int
name|i
decl_stmt|;
name|error
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|error
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|for_each_pipe
argument_list|(
argument|i
argument_list|)
block|{
name|cpu_transcoder
operator|=
name|intel_pipe_to_cpu_transcoder
argument_list|(
name|dev_priv
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|control
operator|=
name|I915_READ
argument_list|(
name|CURCNTR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|position
operator|=
name|I915_READ
argument_list|(
name|CURPOS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|base
operator|=
name|I915_READ
argument_list|(
name|CURBASE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|control
operator|=
name|I915_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|stride
operator|=
name|I915_READ
argument_list|(
name|DSPSTRIDE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|size
operator|=
name|I915_READ
argument_list|(
name|DSPSIZE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|pos
operator|=
name|I915_READ
argument_list|(
name|DSPPOS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|I915_READ
argument_list|(
name|DSPADDR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|surface
operator|=
name|I915_READ
argument_list|(
name|DSPSURF
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|tile_offset
operator|=
name|I915_READ
argument_list|(
name|DSPTILEOFF
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|conf
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|source
operator|=
name|I915_READ
argument_list|(
name|PIPESRC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|htotal
operator|=
name|I915_READ
argument_list|(
name|HTOTAL
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|hblank
operator|=
name|I915_READ
argument_list|(
name|HBLANK
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|hsync
operator|=
name|I915_READ
argument_list|(
name|HSYNC
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vtotal
operator|=
name|I915_READ
argument_list|(
name|VTOTAL
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vblank
operator|=
name|I915_READ
argument_list|(
name|VBLANK
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vsync
operator|=
name|I915_READ
argument_list|(
name|VSYNC
argument_list|(
name|cpu_transcoder
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|intel_display_print_error_state
parameter_list|(
name|struct
name|sbuf
modifier|*
name|m
parameter_list|,
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|intel_display_error_state
modifier|*
name|error
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"Num Pipes: %d\n"
argument_list|,
name|dev_priv
operator|->
name|num_pipe
argument_list|)
expr_stmt|;
name|for_each_pipe
argument_list|(
argument|i
argument_list|)
block|{
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"Pipe [%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  CONF: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|conf
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  SRC: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|source
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  HTOTAL: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|htotal
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  HBLANK: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|hblank
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  HSYNC: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|hsync
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  VTOTAL: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vtotal
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  VBLANK: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vblank
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  VSYNC: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vsync
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"Plane [%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  CNTR: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|control
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  STRIDE: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|stride
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  SIZE: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  POS: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|pos
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  ADDR: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  SURF: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|surface
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  TILEOFF: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|tile_offset
argument_list|)
expr_stmt|;
block|}
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"Cursor [%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  CNTR: %08x\n"
argument_list|,
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|control
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  POS: %08x\n"
argument_list|,
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|position
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"  BASE: %08x\n"
argument_list|,
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//#endif
end_comment

end_unit

