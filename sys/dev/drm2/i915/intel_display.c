begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Â© 2006-2007 Intel Corporation  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Authors:  *	Eric Anholt<eric@anholt.net>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_edid.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_dp_helper.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc_helper.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_define
define|#
directive|define
name|HAS_eDP
value|(intel_pipe_has_type(crtc, INTEL_OUTPUT_EDP))
end_define

begin_function_decl
name|bool
name|intel_pipe_has_type
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_increase_pllclock
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_crtc_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|bool
name|on
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* given values */
name|int
name|n
decl_stmt|;
name|int
name|m1
decl_stmt|,
name|m2
decl_stmt|;
name|int
name|p1
decl_stmt|,
name|p2
decl_stmt|;
comment|/* derived values */
name|int
name|dot
decl_stmt|;
name|int
name|vco
decl_stmt|;
name|int
name|m
decl_stmt|;
name|int
name|p
decl_stmt|;
block|}
name|intel_clock_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|min
decl_stmt|,
name|max
decl_stmt|;
block|}
name|intel_range_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|dot_limit
decl_stmt|;
name|int
name|p2_slow
decl_stmt|,
name|p2_fast
decl_stmt|;
block|}
name|intel_p2_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|INTEL_P2_NUM
value|2
end_define

begin_typedef
typedef|typedef
name|struct
name|intel_limit
name|intel_limit_t
typedef|;
end_typedef

begin_struct
struct|struct
name|intel_limit
block|{
name|intel_range_t
name|dot
decl_stmt|,
name|vco
decl_stmt|,
name|n
decl_stmt|,
name|m
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|p
decl_stmt|,
name|p1
decl_stmt|;
name|intel_p2_t
name|p2
decl_stmt|;
name|bool
function_decl|(
modifier|*
name|find_pll
function_decl|)
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
parameter_list|,
name|struct
name|drm_crtc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|intel_clock_t
modifier|*
parameter_list|,
name|intel_clock_t
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* FDI */
end_comment

begin_define
define|#
directive|define
name|IRONLAKE_FDI_FREQ
value|2700000
end_define

begin_comment
comment|/* in kHz for mode->clock */
end_comment

begin_function_decl
specifier|static
name|bool
name|intel_find_best_PLL
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|intel_g4x_find_best_PLL
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|intel_find_pll_g4x_dp
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|intel_find_pll_ironlake_dp
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|u32
comment|/* units of 100MHz */
name|intel_fdi_link_freq
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
operator|(
name|I915_READ
argument_list|(
name|FDI_PLL_BIOS_0
argument_list|)
operator|&
name|FDI_PLL_FB_CLOCK_MASK
operator|)
operator|+
literal|2
return|;
block|}
else|else
return|return
literal|27
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_i8xx_dvo
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|930000
block|,
operator|.
name|max
operator|=
literal|1400000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|3
block|,
operator|.
name|max
operator|=
literal|16
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|96
block|,
operator|.
name|max
operator|=
literal|140
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|18
block|,
operator|.
name|max
operator|=
literal|26
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|6
block|,
operator|.
name|max
operator|=
literal|16
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|4
block|,
operator|.
name|max
operator|=
literal|128
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|33
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|165000
block|,
operator|.
name|p2_slow
operator|=
literal|4
block|,
operator|.
name|p2_fast
operator|=
literal|2
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_i8xx_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|930000
block|,
operator|.
name|max
operator|=
literal|1400000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|3
block|,
operator|.
name|max
operator|=
literal|16
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|96
block|,
operator|.
name|max
operator|=
literal|140
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|18
block|,
operator|.
name|max
operator|=
literal|26
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|6
block|,
operator|.
name|max
operator|=
literal|16
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|4
block|,
operator|.
name|max
operator|=
literal|128
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|165000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_i9xx_sdvo
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1400000
block|,
operator|.
name|max
operator|=
literal|2800000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|70
block|,
operator|.
name|max
operator|=
literal|120
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|80
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|200000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|5
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_i9xx_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1400000
block|,
operator|.
name|max
operator|=
literal|2800000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|70
block|,
operator|.
name|max
operator|=
literal|120
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|7
block|,
operator|.
name|max
operator|=
literal|98
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|112000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_sdvo
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|270000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|4
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|104
block|,
operator|.
name|max
operator|=
literal|138
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|17
block|,
operator|.
name|max
operator|=
literal|23
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|11
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|30
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|270000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|10
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_hdmi
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|22000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|4
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|104
block|,
operator|.
name|max
operator|=
literal|138
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|16
block|,
operator|.
name|max
operator|=
literal|23
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|11
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|80
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|165000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|5
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_single_channel_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|115000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|104
block|,
operator|.
name|max
operator|=
literal|138
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|17
block|,
operator|.
name|max
operator|=
literal|23
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|11
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|28
block|,
operator|.
name|max
operator|=
literal|112
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|0
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|14
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_dual_channel_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|80000
block|,
operator|.
name|max
operator|=
literal|224000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|104
block|,
operator|.
name|max
operator|=
literal|138
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|17
block|,
operator|.
name|max
operator|=
literal|23
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|11
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|14
block|,
operator|.
name|max
operator|=
literal|42
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|0
block|,
operator|.
name|p2_slow
operator|=
literal|7
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_g4x_display_port
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|161670
block|,
operator|.
name|max
operator|=
literal|227000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1750000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|97
block|,
operator|.
name|max
operator|=
literal|108
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|0x10
block|,
operator|.
name|max
operator|=
literal|0x12
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|0x05
block|,
operator|.
name|max
operator|=
literal|0x06
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|20
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|0
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|10
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_pll_g4x_dp
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_pineview_sdvo
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1700000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
comment|/* Pineview's Ncounter is a ring counter */
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|3
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|256
block|}
block|,
comment|/* Pineview only has one combined m divider, which we treat as m2. */
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|0
block|,
operator|.
name|max
operator|=
literal|0
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|0
block|,
operator|.
name|max
operator|=
literal|254
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|80
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|200000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|5
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_pineview_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|20000
block|,
operator|.
name|max
operator|=
literal|400000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1700000
block|,
operator|.
name|max
operator|=
literal|3500000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|3
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|256
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|0
block|,
operator|.
name|max
operator|=
literal|0
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|0
block|,
operator|.
name|max
operator|=
literal|254
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|7
block|,
operator|.
name|max
operator|=
literal|112
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|112000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|14
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ironlake / Sandybridge  *  * We calculate clock using (register_value + 2) for N/M1/M2, so here  * the range value for them is (actual_value - 2).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_dac
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|5
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|127
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|80
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|5
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_single_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|118
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|28
block|,
operator|.
name|max
operator|=
literal|112
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|14
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_dual_lvds
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|127
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|14
block|,
operator|.
name|max
operator|=
literal|56
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|7
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LVDS 100mhz refclk limits. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_single_lvds_100m
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|126
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|28
block|,
operator|.
name|max
operator|=
literal|112
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|8
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|14
block|,
operator|.
name|p2_fast
operator|=
literal|14
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_dual_lvds_100m
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|3
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|79
block|,
operator|.
name|max
operator|=
literal|126
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|14
block|,
operator|.
name|max
operator|=
literal|42
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|2
block|,
operator|.
name|max
operator|=
literal|6
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|225000
block|,
operator|.
name|p2_slow
operator|=
literal|7
block|,
operator|.
name|p2_fast
operator|=
literal|7
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_g4x_find_best_PLL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|intel_limit_t
name|intel_limits_ironlake_display_port
init|=
block|{
operator|.
name|dot
operator|=
block|{
operator|.
name|min
operator|=
literal|25000
block|,
operator|.
name|max
operator|=
literal|350000
block|}
block|,
operator|.
name|vco
operator|=
block|{
operator|.
name|min
operator|=
literal|1760000
block|,
operator|.
name|max
operator|=
literal|3510000
block|}
block|,
operator|.
name|n
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|m
operator|=
block|{
operator|.
name|min
operator|=
literal|81
block|,
operator|.
name|max
operator|=
literal|90
block|}
block|,
operator|.
name|m1
operator|=
block|{
operator|.
name|min
operator|=
literal|12
block|,
operator|.
name|max
operator|=
literal|22
block|}
block|,
operator|.
name|m2
operator|=
block|{
operator|.
name|min
operator|=
literal|5
block|,
operator|.
name|max
operator|=
literal|9
block|}
block|,
operator|.
name|p
operator|=
block|{
operator|.
name|min
operator|=
literal|10
block|,
operator|.
name|max
operator|=
literal|20
block|}
block|,
operator|.
name|p1
operator|=
block|{
operator|.
name|min
operator|=
literal|1
block|,
operator|.
name|max
operator|=
literal|2
block|}
block|,
operator|.
name|p2
operator|=
block|{
operator|.
name|dot_limit
operator|=
literal|0
block|,
operator|.
name|p2_slow
operator|=
literal|10
block|,
operator|.
name|p2_fast
operator|=
literal|10
block|}
block|,
operator|.
name|find_pll
operator|=
name|intel_find_pll_ironlake_dp
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|u32
name|intel_dpio_read
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|u32
name|val
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_atomic_us
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|DPIO_PKT
argument_list|)
operator|&
name|DPIO_BUSY
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"DPIO idle wait timed out\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|I915_WRITE
argument_list|(
name|DPIO_REG
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPIO_PKT
argument_list|,
name|DPIO_RID
operator||
name|DPIO_OP_READ
operator||
name|DPIO_PORTID
operator||
name|DPIO_BYTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_atomic_us
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|DPIO_PKT
argument_list|)
operator|&
name|DPIO_BUSY
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"DPIO read wait timed out\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|val
operator|=
name|I915_READ
argument_list|(
name|DPIO_DATA
argument_list|)
expr_stmt|;
name|out_unlock
label|:
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void intel_dpio_write(struct drm_i915_private *dev_priv, int reg, 			     u32 val) {  	mtx_lock(&dev_priv->dpio_lock); 	if (wait_for_atomic_us((I915_READ(DPIO_PKT)& DPIO_BUSY) == 0, 100)) { 		DRM_ERROR("DPIO idle wait timed out\n"); 		goto out_unlock; 	}  	I915_WRITE(DPIO_DATA, val); 	I915_WRITE(DPIO_REG, reg); 	I915_WRITE(DPIO_PKT, DPIO_RID | DPIO_OP_WRITE | DPIO_PORTID | 		   DPIO_BYTE); 	if (wait_for_atomic_us((I915_READ(DPIO_PKT)& DPIO_BUSY) == 0, 100)) 		DRM_ERROR("DPIO write wait timed out\n");  out_unlock: 	mtx_unlock(&dev_priv->dpio_lock); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|vlv_init_dpio
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* Reset the DPIO config */
name|I915_WRITE
argument_list|(
name|DPIO_CTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DPIO_CTL
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPIO_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DPIO_CTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_dual_link_lvds_callback
parameter_list|(
specifier|const
name|struct
name|dmi_system_id
modifier|*
name|id
parameter_list|)
block|{
name|DRM_INFO
argument_list|(
literal|"Forcing lvds to dual link mode on %s\n"
argument_list|,
name|id
operator|->
name|ident
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|dmi_system_id
name|intel_dual_link_lvds
index|[]
init|=
block|{
block|{
operator|.
name|callback
operator|=
name|intel_dual_link_lvds_callback
block|,
operator|.
name|ident
operator|=
literal|"Apple MacBook Pro (Core i5/i7 Series)"
block|,
operator|.
name|matches
operator|=
block|{
name|DMI_MATCH
argument_list|(
name|DMI_SYS_VENDOR
argument_list|,
literal|"Apple Inc."
argument_list|)
block|,
name|DMI_MATCH
argument_list|(
name|DMI_PRODUCT_NAME
argument_list|,
literal|"MacBookPro8,2"
argument_list|)
block|, 		}
block|, 	}
block|,
block|{ }
comment|/* terminating entry */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|is_dual_link_lvds
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
comment|/* use the module option value if specified */
if|if
condition|(
name|i915_lvds_channel_mode
operator|>
literal|0
condition|)
return|return
name|i915_lvds_channel_mode
operator|==
literal|2
return|;
if|if
condition|(
name|dmi_check_system
argument_list|(
name|intel_dual_link_lvds
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|dev_priv
operator|->
name|lvds_val
condition|)
name|val
operator|=
name|dev_priv
operator|->
name|lvds_val
expr_stmt|;
else|else
block|{
comment|/* BIOS should set the proper LVDS register value at boot, but 		 * in reality, it doesn't set the value when the lid is closed; 		 * we need to check "the value to be set" in VBT when LVDS 		 * register is uninitialized. 		 */
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
operator|~
name|LVDS_DETECTED
operator|)
condition|)
name|val
operator|=
name|dev_priv
operator|->
name|bios_lvds_val
expr_stmt|;
name|dev_priv
operator|->
name|lvds_val
operator|=
name|val
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|&
name|LVDS_CLKB_POWER_MASK
operator|)
operator|==
name|LVDS_CLKB_POWER_UP
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|intel_limit_t
modifier|*
name|intel_ironlake_limit
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|refclk
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_dual_link_lvds
argument_list|(
name|dev_priv
argument_list|,
name|PCH_LVDS
argument_list|)
condition|)
block|{
comment|/* LVDS dual channel */
if|if
condition|(
name|refclk
operator|==
literal|100000
condition|)
name|limit
operator|=
operator|&
name|intel_limits_ironlake_dual_lvds_100m
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_ironlake_dual_lvds
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|refclk
operator|==
literal|100000
condition|)
name|limit
operator|=
operator|&
name|intel_limits_ironlake_single_lvds_100m
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_ironlake_single_lvds
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
operator|||
name|HAS_eDP
condition|)
name|limit
operator|=
operator|&
name|intel_limits_ironlake_display_port
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_ironlake_dac
expr_stmt|;
return|return
name|limit
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|intel_limit_t
modifier|*
name|intel_g4x_limit
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_dual_link_lvds
argument_list|(
name|dev_priv
argument_list|,
name|LVDS
argument_list|)
condition|)
comment|/* LVDS with dual channel */
name|limit
operator|=
operator|&
name|intel_limits_g4x_dual_channel_lvds
expr_stmt|;
else|else
comment|/* LVDS with dual channel */
name|limit
operator|=
operator|&
name|intel_limits_g4x_single_channel_lvds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_HDMI
argument_list|)
operator|||
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_ANALOG
argument_list|)
condition|)
block|{
name|limit
operator|=
operator|&
name|intel_limits_g4x_hdmi
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_SDVO
argument_list|)
condition|)
block|{
name|limit
operator|=
operator|&
name|intel_limits_g4x_sdvo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
condition|)
block|{
name|limit
operator|=
operator|&
name|intel_limits_g4x_display_port
expr_stmt|;
block|}
else|else
comment|/* The option is for other outputs */
name|limit
operator|=
operator|&
name|intel_limits_i9xx_sdvo
expr_stmt|;
return|return
name|limit
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|intel_limit_t
modifier|*
name|intel_limit
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|refclk
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|limit
operator|=
name|intel_ironlake_limit
argument_list|(
name|crtc
argument_list|,
name|refclk
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|limit
operator|=
name|intel_g4x_limit
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|limit
operator|=
operator|&
name|intel_limits_pineview_lvds
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_pineview_sdvo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|limit
operator|=
operator|&
name|intel_limits_i9xx_lvds
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_i9xx_sdvo
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|limit
operator|=
operator|&
name|intel_limits_i8xx_lvds
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|intel_limits_i8xx_dvo
expr_stmt|;
block|}
return|return
name|limit
return|;
block|}
end_function

begin_comment
comment|/* m1 is reserved as 0 in Pineview, n is a ring counter */
end_comment

begin_function
specifier|static
name|void
name|pineview_clock
parameter_list|(
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|)
block|{
name|clock
operator|->
name|m
operator|=
name|clock
operator|->
name|m2
operator|+
literal|2
expr_stmt|;
name|clock
operator|->
name|p
operator|=
name|clock
operator|->
name|p1
operator|*
name|clock
operator|->
name|p2
expr_stmt|;
name|clock
operator|->
name|vco
operator|=
name|refclk
operator|*
name|clock
operator|->
name|m
operator|/
name|clock
operator|->
name|n
expr_stmt|;
name|clock
operator|->
name|dot
operator|=
name|clock
operator|->
name|vco
operator|/
name|clock
operator|->
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_clock
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|)
block|{
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|pineview_clock
argument_list|(
name|refclk
argument_list|,
name|clock
argument_list|)
expr_stmt|;
return|return;
block|}
name|clock
operator|->
name|m
operator|=
literal|5
operator|*
operator|(
name|clock
operator|->
name|m1
operator|+
literal|2
operator|)
operator|+
operator|(
name|clock
operator|->
name|m2
operator|+
literal|2
operator|)
expr_stmt|;
name|clock
operator|->
name|p
operator|=
name|clock
operator|->
name|p1
operator|*
name|clock
operator|->
name|p2
expr_stmt|;
name|clock
operator|->
name|vco
operator|=
name|refclk
operator|*
name|clock
operator|->
name|m
operator|/
operator|(
name|clock
operator|->
name|n
operator|+
literal|2
operator|)
expr_stmt|;
name|clock
operator|->
name|dot
operator|=
name|clock
operator|->
name|vco
operator|/
name|clock
operator|->
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Returns whether any output on the specified pipe is of the specified type  */
end_comment

begin_function
name|bool
name|intel_pipe_has_type
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|==
name|crtc
operator|&&
name|encoder
operator|->
name|type
operator|==
name|type
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_define
define|#
directive|define
name|INTELPllInvalid
parameter_list|(
name|s
parameter_list|)
value|do {
comment|/* DRM_DEBUG(s); */
value|return false; } while (0)
end_define

begin_comment
comment|/**  * Returns whether the given set of divisors are valid for a given refclk with  * the given connectors.  */
end_comment

begin_function
specifier|static
name|bool
name|intel_PLL_is_valid
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
specifier|const
name|intel_clock_t
modifier|*
name|clock
parameter_list|)
block|{
if|if
condition|(
name|clock
operator|->
name|p1
operator|<
name|limit
operator|->
name|p1
operator|.
name|min
operator|||
name|limit
operator|->
name|p1
operator|.
name|max
operator|<
name|clock
operator|->
name|p1
condition|)
name|INTELPllInvalid
argument_list|(
literal|"p1 out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|p
operator|<
name|limit
operator|->
name|p
operator|.
name|min
operator|||
name|limit
operator|->
name|p
operator|.
name|max
operator|<
name|clock
operator|->
name|p
condition|)
name|INTELPllInvalid
argument_list|(
literal|"p out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|m2
operator|<
name|limit
operator|->
name|m2
operator|.
name|min
operator|||
name|limit
operator|->
name|m2
operator|.
name|max
operator|<
name|clock
operator|->
name|m2
condition|)
name|INTELPllInvalid
argument_list|(
literal|"m2 out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|m1
operator|<
name|limit
operator|->
name|m1
operator|.
name|min
operator|||
name|limit
operator|->
name|m1
operator|.
name|max
operator|<
name|clock
operator|->
name|m1
condition|)
name|INTELPllInvalid
argument_list|(
literal|"m1 out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|m1
operator|<=
name|clock
operator|->
name|m2
operator|&&
operator|!
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|INTELPllInvalid
argument_list|(
literal|"m1<= m2\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|m
operator|<
name|limit
operator|->
name|m
operator|.
name|min
operator|||
name|limit
operator|->
name|m
operator|.
name|max
operator|<
name|clock
operator|->
name|m
condition|)
name|INTELPllInvalid
argument_list|(
literal|"m out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|n
operator|<
name|limit
operator|->
name|n
operator|.
name|min
operator|||
name|limit
operator|->
name|n
operator|.
name|max
operator|<
name|clock
operator|->
name|n
condition|)
name|INTELPllInvalid
argument_list|(
literal|"n out of range\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|vco
operator|<
name|limit
operator|->
name|vco
operator|.
name|min
operator|||
name|limit
operator|->
name|vco
operator|.
name|max
operator|<
name|clock
operator|->
name|vco
condition|)
name|INTELPllInvalid
argument_list|(
literal|"vco out of range\n"
argument_list|)
expr_stmt|;
comment|/* XXX: We may need to be checking "Dot clock" depending on the multiplier, 	 * connector, etc., rather than just a single range. 	 */
if|if
condition|(
name|clock
operator|->
name|dot
operator|<
name|limit
operator|->
name|dot
operator|.
name|min
operator|||
name|limit
operator|->
name|dot
operator|.
name|max
operator|<
name|clock
operator|->
name|dot
condition|)
name|INTELPllInvalid
argument_list|(
literal|"dot out of range\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_find_best_PLL
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|;
name|int
name|err
init|=
name|target
decl_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|&&
operator|(
name|I915_READ
argument_list|(
name|LVDS
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * For LVDS, if the panel is on, just rely on its current 		 * settings for dual-channel.  We haven't figured out how to 		 * reliably set up different single/dual channel state, if we 		 * even can. 		 */
if|if
condition|(
name|is_dual_link_lvds
argument_list|(
name|dev_priv
argument_list|,
name|LVDS
argument_list|)
condition|)
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_fast
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_slow
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target
operator|<
name|limit
operator|->
name|p2
operator|.
name|dot_limit
condition|)
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_slow
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_fast
expr_stmt|;
block|}
name|memset
argument_list|(
name|best_clock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|best_clock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|clock
operator|.
name|m1
operator|=
name|limit
operator|->
name|m1
operator|.
name|min
init|;
name|clock
operator|.
name|m1
operator|<=
name|limit
operator|->
name|m1
operator|.
name|max
condition|;
name|clock
operator|.
name|m1
operator|++
control|)
block|{
for|for
control|(
name|clock
operator|.
name|m2
operator|=
name|limit
operator|->
name|m2
operator|.
name|min
init|;
name|clock
operator|.
name|m2
operator|<=
name|limit
operator|->
name|m2
operator|.
name|max
condition|;
name|clock
operator|.
name|m2
operator|++
control|)
block|{
comment|/* m1 is always 0 in Pineview */
if|if
condition|(
name|clock
operator|.
name|m2
operator|>=
name|clock
operator|.
name|m1
operator|&&
operator|!
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
break|break;
for|for
control|(
name|clock
operator|.
name|n
operator|=
name|limit
operator|->
name|n
operator|.
name|min
init|;
name|clock
operator|.
name|n
operator|<=
name|limit
operator|->
name|n
operator|.
name|max
condition|;
name|clock
operator|.
name|n
operator|++
control|)
block|{
for|for
control|(
name|clock
operator|.
name|p1
operator|=
name|limit
operator|->
name|p1
operator|.
name|min
init|;
name|clock
operator|.
name|p1
operator|<=
name|limit
operator|->
name|p1
operator|.
name|max
condition|;
name|clock
operator|.
name|p1
operator|++
control|)
block|{
name|int
name|this_err
decl_stmt|;
name|intel_clock
argument_list|(
name|dev
argument_list|,
name|refclk
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_PLL_is_valid
argument_list|(
name|dev
argument_list|,
name|limit
argument_list|,
operator|&
name|clock
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|match_clock
operator|&&
name|clock
operator|.
name|p
operator|!=
name|match_clock
operator|->
name|p
condition|)
continue|continue;
name|this_err
operator|=
name|abs
argument_list|(
name|clock
operator|.
name|dot
operator|-
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_err
operator|<
name|err
condition|)
block|{
operator|*
name|best_clock
operator|=
name|clock
expr_stmt|;
name|err
operator|=
name|this_err
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
operator|(
name|err
operator|!=
name|target
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_g4x_find_best_PLL
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|;
name|int
name|max_n
decl_stmt|;
name|bool
name|found
decl_stmt|;
comment|/* approximately equals target * 0.00585 */
name|int
name|err_most
init|=
operator|(
name|target
operator|>>
literal|8
operator|)
operator|+
operator|(
name|target
operator|>>
literal|9
operator|)
decl_stmt|;
name|found
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
name|int
name|lvds_reg
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|lvds_reg
operator|=
name|PCH_LVDS
expr_stmt|;
else|else
name|lvds_reg
operator|=
name|LVDS
expr_stmt|;
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|lvds_reg
argument_list|)
operator|&
name|LVDS_CLKB_POWER_MASK
operator|)
operator|==
name|LVDS_CLKB_POWER_UP
condition|)
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_fast
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_slow
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target
operator|<
name|limit
operator|->
name|p2
operator|.
name|dot_limit
condition|)
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_slow
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
name|limit
operator|->
name|p2
operator|.
name|p2_fast
expr_stmt|;
block|}
name|memset
argument_list|(
name|best_clock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|best_clock
argument_list|)
argument_list|)
expr_stmt|;
name|max_n
operator|=
name|limit
operator|->
name|n
operator|.
name|max
expr_stmt|;
comment|/* based on hardware requirement, prefer smaller n to precision */
for|for
control|(
name|clock
operator|.
name|n
operator|=
name|limit
operator|->
name|n
operator|.
name|min
init|;
name|clock
operator|.
name|n
operator|<=
name|max_n
condition|;
name|clock
operator|.
name|n
operator|++
control|)
block|{
comment|/* based on hardware requirement, prefere larger m1,m2 */
for|for
control|(
name|clock
operator|.
name|m1
operator|=
name|limit
operator|->
name|m1
operator|.
name|max
init|;
name|clock
operator|.
name|m1
operator|>=
name|limit
operator|->
name|m1
operator|.
name|min
condition|;
name|clock
operator|.
name|m1
operator|--
control|)
block|{
for|for
control|(
name|clock
operator|.
name|m2
operator|=
name|limit
operator|->
name|m2
operator|.
name|max
init|;
name|clock
operator|.
name|m2
operator|>=
name|limit
operator|->
name|m2
operator|.
name|min
condition|;
name|clock
operator|.
name|m2
operator|--
control|)
block|{
for|for
control|(
name|clock
operator|.
name|p1
operator|=
name|limit
operator|->
name|p1
operator|.
name|max
init|;
name|clock
operator|.
name|p1
operator|>=
name|limit
operator|->
name|p1
operator|.
name|min
condition|;
name|clock
operator|.
name|p1
operator|--
control|)
block|{
name|int
name|this_err
decl_stmt|;
name|intel_clock
argument_list|(
name|dev
argument_list|,
name|refclk
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_PLL_is_valid
argument_list|(
name|dev
argument_list|,
name|limit
argument_list|,
operator|&
name|clock
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|match_clock
operator|&&
name|clock
operator|.
name|p
operator|!=
name|match_clock
operator|->
name|p
condition|)
continue|continue;
name|this_err
operator|=
name|abs
argument_list|(
name|clock
operator|.
name|dot
operator|-
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_err
operator|<
name|err_most
condition|)
block|{
operator|*
name|best_clock
operator|=
name|clock
expr_stmt|;
name|err_most
operator|=
name|this_err
expr_stmt|;
name|max_n
operator|=
name|clock
operator|.
name|n
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_find_pll_ironlake_dp
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|200000
condition|)
block|{
name|clock
operator|.
name|n
operator|=
literal|1
expr_stmt|;
name|clock
operator|.
name|p1
operator|=
literal|2
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|12
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|9
expr_stmt|;
block|}
else|else
block|{
name|clock
operator|.
name|n
operator|=
literal|2
expr_stmt|;
name|clock
operator|.
name|p1
operator|=
literal|1
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|14
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|8
expr_stmt|;
block|}
name|intel_clock
argument_list|(
name|dev
argument_list|,
name|refclk
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|best_clock
argument_list|,
operator|&
name|clock
argument_list|,
sizeof|sizeof
argument_list|(
name|intel_clock_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* DisplayPort has only two frequencies, 162MHz and 270MHz */
end_comment

begin_function
specifier|static
name|bool
name|intel_find_pll_g4x_dp
parameter_list|(
specifier|const
name|intel_limit_t
modifier|*
name|limit
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|refclk
parameter_list|,
name|intel_clock_t
modifier|*
name|match_clock
parameter_list|,
name|intel_clock_t
modifier|*
name|best_clock
parameter_list|)
block|{
name|intel_clock_t
name|clock
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|200000
condition|)
block|{
name|clock
operator|.
name|p1
operator|=
literal|2
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|n
operator|=
literal|2
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|23
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|clock
operator|.
name|p1
operator|=
literal|1
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|n
operator|=
literal|1
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|14
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|2
expr_stmt|;
block|}
name|clock
operator|.
name|m
operator|=
literal|5
operator|*
operator|(
name|clock
operator|.
name|m1
operator|+
literal|2
operator|)
operator|+
operator|(
name|clock
operator|.
name|m2
operator|+
literal|2
operator|)
expr_stmt|;
name|clock
operator|.
name|p
operator|=
operator|(
name|clock
operator|.
name|p1
operator|*
name|clock
operator|.
name|p2
operator|)
expr_stmt|;
name|clock
operator|.
name|dot
operator|=
literal|96000
operator|*
name|clock
operator|.
name|m
operator|/
operator|(
name|clock
operator|.
name|n
operator|+
literal|2
operator|)
operator|/
name|clock
operator|.
name|p
expr_stmt|;
name|clock
operator|.
name|vco
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|best_clock
argument_list|,
operator|&
name|clock
argument_list|,
sizeof|sizeof
argument_list|(
name|intel_clock_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_wait_for_vblank
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|frame
decl_stmt|,
name|frame_reg
init|=
name|PIPEFRAME
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|frame
operator|=
name|I915_READ
argument_list|(
name|frame_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
name|I915_READ_NOTRACE
argument_list|(
name|frame_reg
argument_list|)
operator|!=
name|frame
argument_list|,
literal|50
argument_list|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"vblank wait timed out\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_wait_for_vblank - wait for vblank on a given pipe  * @dev: drm device  * @pipe: pipe to wait for  *  * Wait for vblank to occur on a given pipe.  Needed for various bits of  * mode setting code.  */
end_comment

begin_function
name|void
name|intel_wait_for_vblank
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipestat_reg
init|=
name|PIPESTAT
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|5
condition|)
block|{
name|ironlake_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Clear existing vblank status. Note this will clear any other 	 * sticky status fields as well. 	 * 	 * This races with i915_driver_irq_handler() with the result 	 * that either function could miss a vblank event.  Here it is not 	 * fatal, as we will either wait upon the next vblank interrupt or 	 * timeout.  Generally speaking intel_wait_for_vblank() is only 	 * called during modeset at which time the GPU should be idle and 	 * should *not* be performing page flips and thus not waiting on 	 * vblanks... 	 * Currently, the result of us stealing a vblank from the irq 	 * handler is that a single frame will be skipped during swapbuffers. 	 */
name|I915_WRITE
argument_list|(
name|pipestat_reg
argument_list|,
name|I915_READ
argument_list|(
name|pipestat_reg
argument_list|)
operator||
name|PIPE_VBLANK_INTERRUPT_STATUS
argument_list|)
expr_stmt|;
comment|/* Wait for vblank interrupt bit to set */
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
name|I915_READ
argument_list|(
name|pipestat_reg
argument_list|)
operator|&
name|PIPE_VBLANK_INTERRUPT_STATUS
argument_list|,
literal|50
argument_list|,
literal|1
argument_list|,
literal|"915vbl"
argument_list|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"vblank wait timed out\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * intel_wait_for_pipe_off - wait for pipe to turn off  * @dev: drm device  * @pipe: pipe to wait for  *  * After disabling a pipe, we can't wait for vblank in the usual way,  * spinning on the vblank interrupt status bit, since we won't actually  * see an interrupt when the pipe is disabled.  *  * On Gen4 and above:  *   wait for the pipe register state bit to turn off  *  * Otherwise:  *   wait for the display line value to settle (it usually  *   ends up stopping at the start of the next frame).  *  */
end_comment

begin_function
name|void
name|intel_wait_for_pipe_off
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|int
name|reg
init|=
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
comment|/* Wait for the Pipe State to go off */
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|I965_PIPECONF_ACTIVE
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|,
literal|1
argument_list|,
literal|"915pip"
argument_list|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"pipe_off wait timed out\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u32
name|last_line
decl_stmt|,
name|line_mask
decl_stmt|;
name|int
name|reg
init|=
name|PIPEDSL
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|timeout
init|=
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
literal|100
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|line_mask
operator|=
name|DSL_LINEMASK_GEN2
expr_stmt|;
else|else
name|line_mask
operator|=
name|DSL_LINEMASK_GEN3
expr_stmt|;
comment|/* Wait for the display line to settle */
do|do
block|{
name|last_line
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|line_mask
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|(
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|line_mask
operator|)
operator|!=
name|last_line
operator|)
operator|&&
name|time_after
argument_list|(
name|timeout
argument_list|,
name|jiffies
argument_list|)
condition|)
do|;
if|if
condition|(
name|time_after
argument_list|(
name|jiffies
argument_list|,
name|timeout
argument_list|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"pipe_off wait timed out\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|state_string
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
return|return
name|enabled
condition|?
literal|"on"
else|:
literal|"off"
return|;
block|}
end_function

begin_comment
comment|/* Only for pre-ILK configs */
end_comment

begin_function
specifier|static
name|void
name|assert_pll
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
name|reg
operator|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|DPLL_VCO_ENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|!=
name|state
condition|)
name|printf
argument_list|(
literal|"PLL state assertion failure (expected %s, current %s)\n"
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|assert_pll_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_pll(d, p, true)
end_define

begin_define
define|#
directive|define
name|assert_pll_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_pll(d, p, false)
end_define

begin_comment
comment|/* For ILK+ */
end_comment

begin_function
specifier|static
name|void
name|assert_pch_pll
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
if|if
condition|(
name|HAS_PCH_LPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"LPT detected: skipping PCH PLL test\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|pch_pll
condition|)
block|{
name|printf
argument_list|(
literal|"asserting PCH PLL enabled with no PLL\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|u32
name|pch_dpll
decl_stmt|;
name|pch_dpll
operator|=
name|I915_READ
argument_list|(
name|PCH_DPLL_SEL
argument_list|)
expr_stmt|;
comment|/* Make sure the selected PLL is enabled to the transcoder */
name|KASSERT
argument_list|(
operator|(
operator|(
name|pch_dpll
operator|>>
operator|(
literal|4
operator|*
name|intel_crtc
operator|->
name|pipe
operator|)
operator|)
operator|&
literal|8
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"transcoder %d PLL not enabled\n"
operator|,
name|intel_crtc
operator|->
name|pipe
operator|)
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|pll_reg
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|DPLL_VCO_ENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|!=
name|state
condition|)
name|printf
argument_list|(
literal|"PCH PLL state assertion failure (expected %s, current %s)\n"
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|assert_pch_pll_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_pch_pll(d, p, true)
end_define

begin_define
define|#
directive|define
name|assert_pch_pll_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_pch_pll(d, p, false)
end_define

begin_function
specifier|static
name|void
name|assert_fdi_tx
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
comment|/* On Haswell, DDI is used instead of FDI_TX_CTL */
name|reg
operator|=
name|DDI_FUNC_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|PIPE_DDI_FUNC_ENABLE
operator|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|FDI_TX_ENABLE
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|cur_state
operator|!=
name|state
condition|)
name|printf
argument_list|(
literal|"FDI TX state assertion failure (expected %s, current %s)\n"
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|assert_fdi_tx_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_fdi_tx(d, p, true)
end_define

begin_define
define|#
directive|define
name|assert_fdi_tx_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_fdi_tx(d, p, false)
end_define

begin_function
specifier|static
name|void
name|assert_fdi_rx
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
operator|&&
name|pipe
operator|>
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Attempting to enable FDI_RX on Haswell pipe> 0\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|FDI_RX_ENABLE
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|cur_state
operator|!=
name|state
condition|)
name|printf
argument_list|(
literal|"FDI RX state assertion failure (expected %s, current %s)\n"
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|assert_fdi_rx_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_fdi_rx(d, p, true)
end_define

begin_define
define|#
directive|define
name|assert_fdi_rx_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_fdi_rx(d, p, false)
end_define

begin_function
specifier|static
name|void
name|assert_fdi_tx_pll_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* ILK FDI PLL is always enabled */
if|if
condition|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|==
literal|5
condition|)
return|return;
comment|/* On Haswell, DDI ports are responsible for the FDI PLL setup */
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
return|return;
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|FDI_TX_PLL_ENABLE
operator|)
condition|)
name|printf
argument_list|(
literal|"FDI TX PLL assertion failure, should be active but is disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_fdi_rx_pll_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
operator|&&
name|pipe
operator|>
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Attempting to enable FDI on Haswell with pipe> 0\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|FDI_RX_PLL_ENABLE
operator|)
condition|)
name|printf
argument_list|(
literal|"FDI RX PLL assertion failure, should be active but is disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_panel_unlocked
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|pp_reg
decl_stmt|,
name|lvds_reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|enum
name|pipe
name|panel_pipe
init|=
name|PIPE_A
decl_stmt|;
name|bool
name|locked
init|=
name|true
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|pp_reg
operator|=
name|PCH_PP_CONTROL
expr_stmt|;
name|lvds_reg
operator|=
name|PCH_LVDS
expr_stmt|;
block|}
else|else
block|{
name|pp_reg
operator|=
name|PP_CONTROL
expr_stmt|;
name|lvds_reg
operator|=
name|LVDS
expr_stmt|;
block|}
name|val
operator|=
name|I915_READ
argument_list|(
name|pp_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PANEL_POWER_ON
operator|)
operator|||
operator|(
operator|(
name|val
operator|&
name|PANEL_UNLOCK_REGS
operator|)
operator|==
name|PANEL_UNLOCK_REGS
operator|)
condition|)
name|locked
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|lvds_reg
argument_list|)
operator|&
name|LVDS_PIPEB_SELECT
condition|)
name|panel_pipe
operator|=
name|PIPE_B
expr_stmt|;
if|if
condition|(
name|panel_pipe
operator|==
name|pipe
operator|&&
name|locked
condition|)
name|printf
argument_list|(
literal|"panel assertion failure, pipe %c regs locked\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|assert_pipe
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
comment|/* if we need the pipe A quirk it must be always on */
if|if
condition|(
name|pipe
operator|==
name|PIPE_A
operator|&&
name|dev_priv
operator|->
name|quirks
operator|&
name|QUIRK_PIPEA_FORCE
condition|)
name|state
operator|=
name|true
expr_stmt|;
name|reg
operator|=
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|PIPECONF_ENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|!=
name|state
condition|)
name|printf
argument_list|(
literal|"pipe %c assertion failure (expected %s, current %s)\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_plane
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|plane
name|plane
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|cur_state
decl_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_state
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|!=
name|state
condition|)
name|printf
argument_list|(
literal|"plane %c assertion failure, (expected %s, current %s)\n"
argument_list|,
name|plane_name
argument_list|(
name|plane
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|state
argument_list|)
argument_list|,
name|state_string
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|assert_plane_enabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_plane(d, p, true)
end_define

begin_define
define|#
directive|define
name|assert_plane_disabled
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|)
value|assert_plane(d, p, false)
end_define

begin_function
specifier|static
name|void
name|assert_planes_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|,
name|i
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|int
name|cur_pipe
decl_stmt|;
comment|/* Planes are fixed to pipes on ILK+ */
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"plane %c assertion failure, should be disabled but not\n"
argument_list|,
name|plane_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Need to check both planes against the pipe */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cur_pipe
operator|=
operator|(
name|val
operator|&
name|DISPPLANE_SEL_PIPE_MASK
operator|)
operator|>>
name|DISPPLANE_SEL_PIPE_SHIFT
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
operator|&&
name|pipe
operator|==
name|cur_pipe
condition|)
name|printf
argument_list|(
literal|"plane %c assertion failure, should be off on pipe %c but is still active\n"
argument_list|,
name|plane_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|assert_pch_refclk_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|bool
name|enabled
decl_stmt|;
if|if
condition|(
name|HAS_PCH_LPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"LPT does not has PCH refclk, skipping check\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|val
operator|=
name|I915_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|enabled
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
operator|(
name|DREF_SSC_SOURCE_MASK
operator||
name|DREF_NONSPREAD_SOURCE_MASK
operator||
name|DREF_SUPERSPREAD_SOURCE_MASK
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|enabled
condition|)
name|printf
argument_list|(
literal|"PCH refclk assertion failure, should be active but is disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_transcoder_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|bool
name|enabled
decl_stmt|;
name|reg
operator|=
name|TRANSCONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|enabled
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|TRANS_ENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|enabled
condition|)
name|printf
argument_list|(
literal|"transcoder assertion failed, should be off on pipe %c but is still active\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|hdmi_pipe_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_TRANS_SEL_MASK
operator|)
operator|!=
name|PORT_TRANS_SEL_CPT
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|TRANSCODER_MASK
operator|)
operator|!=
name|TRANSCODER
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|lvds_pipe_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|LVDS_PORT_EN
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_TRANS_SEL_MASK
operator|)
operator|!=
name|PORT_TRANS_SEL_CPT
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|LVDS_PIPE_MASK
operator|)
operator|!=
name|LVDS_PIPE
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|adpa_pipe_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|ADPA_DAC_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_TRANS_SEL_MASK
operator|)
operator|!=
name|PORT_TRANS_SEL_CPT
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|ADPA_PIPE_SELECT_MASK
operator|)
operator|!=
name|ADPA_PIPE_SELECT
argument_list|(
name|pipe
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|dp_pipe_enabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|u32
name|port_sel
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|DP_PORT_EN
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|u32
name|trans_dp_ctl_reg
init|=
name|TRANS_DP_CTL
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|u32
name|trans_dp_ctl
init|=
name|I915_READ
argument_list|(
name|trans_dp_ctl_reg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|trans_dp_ctl
operator|&
name|TRANS_DP_PORT_SEL_MASK
operator|)
operator|!=
name|port_sel
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|DP_PIPE_MASK
operator|)
operator|!=
operator|(
name|pipe
operator|<<
literal|30
operator|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_pch_dp_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|int
name|reg
parameter_list|,
name|u32
name|port_sel
parameter_list|)
block|{
name|u32
name|val
init|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|dp_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|port_sel
argument_list|,
name|val
argument_list|)
condition|)
name|printf
argument_list|(
literal|"PCH DP (0x%08x) enabled on transcoder %c, should be disabled\n"
argument_list|,
name|reg
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_pch_hdmi_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|u32
name|val
init|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|hdmi_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|val
argument_list|,
name|pipe
argument_list|)
condition|)
name|printf
argument_list|(
literal|"PCH HDMI (0x%08x) enabled on transcoder %c, should be disabled\n"
argument_list|,
name|reg
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_pch_ports_disabled
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|assert_pch_dp_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_B
argument_list|,
name|TRANS_DP_PORT_SEL_B
argument_list|)
expr_stmt|;
name|assert_pch_dp_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_C
argument_list|,
name|TRANS_DP_PORT_SEL_C
argument_list|)
expr_stmt|;
name|assert_pch_dp_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_D
argument_list|,
name|TRANS_DP_PORT_SEL_D
argument_list|)
expr_stmt|;
name|reg
operator|=
name|PCH_ADPA
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|adpa_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|val
argument_list|,
name|pipe
argument_list|)
condition|)
name|printf
argument_list|(
literal|"PCH VGA enabled on transcoder %c, should be disabled\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|PCH_LVDS
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvds_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|val
argument_list|,
name|pipe
argument_list|)
condition|)
name|printf
argument_list|(
literal|"PCH LVDS enabled on transcoder %c, should be disabled\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|assert_pch_hdmi_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMIB
argument_list|)
expr_stmt|;
name|assert_pch_hdmi_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMIC
argument_list|)
expr_stmt|;
name|assert_pch_hdmi_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMID
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_enable_pll - enable a PLL  * @dev_priv: i915 private structure  * @pipe: pipe PLL to enable  *  * Enable @pipe's PLL so we can start pumping pixels from a plane.  Check to  * make sure the PLL reg is writable first though, since the panel write  * protect mechanism may be enabled.  *  * Note!  This is for pre-ILK only.  */
end_comment

begin_function
specifier|static
name|void
name|intel_enable_pll
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* No really, not for ILK+ */
name|KASSERT
argument_list|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|<
literal|5
argument_list|,
operator|(
literal|"Wrong device gen"
operator|)
argument_list|)
expr_stmt|;
comment|/* PLL is protected by panel, make sure we can write it */
if|if
condition|(
name|IS_MOBILE
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
operator|&&
operator|!
name|IS_I830
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
name|assert_panel_unlocked
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator||=
name|DPLL_VCO_ENABLE
expr_stmt|;
comment|/* We do this three times for luck */
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* wait for warmup */
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* wait for warmup */
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* wait for warmup */
block|}
end_function

begin_comment
comment|/**  * intel_disable_pll - disable a PLL  * @dev_priv: i915 private structure  * @pipe: pipe PLL to disable  *  * Disable the PLL for @pipe, making sure the pipe is off first.  *  * Note!  This is for pre-ILK only.  */
end_comment

begin_function
specifier|static
name|void
name|intel_disable_pll
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* Don't disable pipe A or pipe A PLLs if needed */
if|if
condition|(
name|pipe
operator|==
name|PIPE_A
operator|&&
operator|(
name|dev_priv
operator|->
name|quirks
operator|&
name|QUIRK_PIPEA_FORCE
operator|)
condition|)
return|return;
comment|/* Make sure the pipe isn't still relying on us */
name|assert_pipe_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|DPLL_VCO_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SBI access */
end_comment

begin_function
specifier|static
name|void
name|intel_sbi_write
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|u16
name|reg
parameter_list|,
name|u32
name|value
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|SBI_CTL_STAT
argument_list|)
operator|&
name|SBI_READY
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for SBI to become ready\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|I915_WRITE
argument_list|(
name|SBI_ADDR
argument_list|,
operator|(
name|reg
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SBI_DATA
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SBI_CTL_STAT
argument_list|,
name|SBI_BUSY
operator||
name|SBI_CTL_OP_CRWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|SBI_CTL_STAT
argument_list|)
operator|&
operator|(
name|SBI_READY
operator||
name|SBI_RESPONSE_SUCCESS
operator|)
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for SBI to complete write transaction\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|out_unlock
label|:
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u32
name|intel_sbi_read
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|u16
name|reg
parameter_list|)
block|{
name|u32
name|value
decl_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|SBI_CTL_STAT
argument_list|)
operator|&
name|SBI_READY
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for SBI to become ready\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|I915_WRITE
argument_list|(
name|SBI_ADDR
argument_list|,
operator|(
name|reg
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SBI_CTL_STAT
argument_list|,
name|SBI_BUSY
operator||
name|SBI_CTL_OP_CRRD
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|SBI_CTL_STAT
argument_list|)
operator|&
operator|(
name|SBI_READY
operator||
name|SBI_RESPONSE_SUCCESS
operator|)
operator|)
operator|==
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for SBI to complete read transaction\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|value
operator|=
name|I915_READ
argument_list|(
name|SBI_DATA
argument_list|)
expr_stmt|;
name|out_unlock
label|:
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/**  * intel_enable_pch_pll - enable PCH PLL  * @dev_priv: i915 private structure  * @pipe: pipe PLL to enable  *  * The PCH PLL needs to be enabled before the PCH transcoder, since it  * drives the transcoder clock.  */
end_comment

begin_function
specifier|static
name|void
name|intel_enable_pch_pll
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|intel_crtc
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_pch_pll
modifier|*
name|pll
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* PCH PLLs only available on ILK, SNB and IVB */
name|KASSERT
argument_list|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|>=
literal|5
argument_list|,
operator|(
literal|"Wrong device gen"
operator|)
argument_list|)
expr_stmt|;
name|pll
operator|=
name|intel_crtc
operator|->
name|pch_pll
expr_stmt|;
if|if
condition|(
name|pll
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pll
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"pll->refcount == 0\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"enable PCH PLL %x (active %d, on? %d)for crtc %d\n"
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|,
name|pll
operator|->
name|active
argument_list|,
name|pll
operator|->
name|on
argument_list|,
name|intel_crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
comment|/* PCH refclock must be enabled first */
name|assert_pch_refclk_enabled
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll
operator|->
name|active
operator|++
operator|&&
name|pll
operator|->
name|on
condition|)
block|{
name|assert_pch_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
name|intel_crtc
argument_list|)
expr_stmt|;
return|return;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"enabling PCH PLL %x\n"
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pll
operator|->
name|pll_reg
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator||=
name|DPLL_VCO_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|pll
operator|->
name|on
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_disable_pch_pll
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|intel_crtc
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_pch_pll
modifier|*
name|pll
init|=
name|intel_crtc
operator|->
name|pch_pll
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* PCH only available on ILK+ */
name|KASSERT
argument_list|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|>=
literal|5
argument_list|,
operator|(
literal|"Wrong device gen"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pll
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"pll->refcount == 0\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"disable PCH PLL %x (active %d, on? %d) for crtc %d\n"
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|,
name|pll
operator|->
name|active
argument_list|,
name|pll
operator|->
name|on
argument_list|,
name|intel_crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll
operator|->
name|active
operator|==
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"pll->active == 0\n"
argument_list|)
expr_stmt|;
name|assert_pch_pll_disabled
argument_list|(
name|dev_priv
argument_list|,
name|intel_crtc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|pll
operator|->
name|active
condition|)
block|{
name|assert_pch_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
name|intel_crtc
argument_list|)
expr_stmt|;
return|return;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabling PCH PLL %x\n"
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
comment|/* Make sure transcoder isn't still depending on us */
name|assert_transcoder_disabled
argument_list|(
name|dev_priv
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pll
operator|->
name|pll_reg
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|DPLL_VCO_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|pll
operator|->
name|on
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_enable_transcoder
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|,
name|pipeconf_val
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|pipe
index|]
decl_stmt|;
comment|/* PCH only available on ILK+ */
name|KASSERT
argument_list|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|>=
literal|5
argument_list|,
operator|(
literal|"Wrong device gen"
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure PCH DPLL is enabled */
name|assert_pch_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FDI must be feeding us bits for PCH ports */
name|assert_fdi_tx_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|assert_fdi_rx_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
operator|&&
name|pipe
operator|>
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Attempting to enable transcoder on Haswell with pipe> 0\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|reg
operator|=
name|TRANSCONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|pipeconf_val
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
comment|/* 		 * make the BPC in transcoder be consistent with 		 * that in pipeconf reg. 		 */
name|val
operator|&=
operator|~
name|PIPE_BPC_MASK
expr_stmt|;
name|val
operator||=
name|pipeconf_val
operator|&
name|PIPE_BPC_MASK
expr_stmt|;
block|}
name|val
operator|&=
operator|~
name|TRANS_INTERLACE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|pipeconf_val
operator|&
name|PIPECONF_INTERLACE_MASK
operator|)
operator|==
name|PIPECONF_INTERLACED_ILK
condition|)
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
operator|&&
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_SDVO
argument_list|)
condition|)
name|val
operator||=
name|TRANS_LEGACY_INTERLACED_ILK
expr_stmt|;
else|else
name|val
operator||=
name|TRANS_INTERLACED
expr_stmt|;
else|else
name|val
operator||=
name|TRANS_PROGRESSIVE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator||
name|TRANS_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|TRANS_STATE_ENABLE
argument_list|,
literal|100
argument_list|,
literal|1
argument_list|,
literal|"915trc"
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to enable transcoder %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_disable_transcoder
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* FDI relies on the transcoder */
name|assert_fdi_tx_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|assert_fdi_rx_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* Ports must be off as well */
name|assert_pch_ports_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|TRANSCONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|TRANS_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* wait for PCH transcoder off, transcoder state */
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|TRANS_STATE_ENABLE
operator|)
operator|==
literal|0
argument_list|,
literal|50
argument_list|,
literal|1
argument_list|,
literal|"915trd"
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to disable transcoder %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_enable_pipe - enable a pipe, asserting requirements  * @dev_priv: i915 private structure  * @pipe: pipe to enable  * @pch_port: on ILK+, is this pipe driving a PCH port or not  *  * Enable @pipe, making sure that various hardware specific requirements  * are met, if applicable, e.g. PLL enabled, LVDS pairs enabled, etc.  *  * @pipe should be %PIPE_A or %PIPE_B.  *  * Will wait until the pipe is actually running (i.e. first vblank) before  * returning.  */
end_comment

begin_function
specifier|static
name|void
name|intel_enable_pipe
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|bool
name|pch_port
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* 	 * A pipe without a PLL won't actually be able to drive bits from 	 * a plane.  On ILK+ the pipe PLLs are integrated, so we don't 	 * need the check. 	 */
if|if
condition|(
operator|!
name|HAS_PCH_SPLIT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
name|assert_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pch_port
condition|)
block|{
comment|/* if driving the PCH, we need FDI enabled */
name|assert_fdi_rx_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|assert_fdi_tx_pll_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: assert CPU port conditions for SNB+ */
block|}
name|reg
operator|=
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PIPECONF_ENABLE
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator||
name|PIPECONF_ENABLE
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_disable_pipe - disable a pipe, asserting requirements  * @dev_priv: i915 private structure  * @pipe: pipe to disable  *  * Disable @pipe, making sure that various hardware specific requirements  * are met, if applicable, e.g. plane disabled, panel fitter off, etc.  *  * @pipe should be %PIPE_A or %PIPE_B.  *  * Will wait until the pipe has shut down before returning.  */
end_comment

begin_function
specifier|static
name|void
name|intel_disable_pipe
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* 	 * Make sure planes won't keep trying to pump pixels to us, 	 * or we might hang the display. 	 */
name|assert_planes_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* Don't disable pipe A or pipe A PLLs if needed */
if|if
condition|(
name|pipe
operator|==
name|PIPE_A
operator|&&
operator|(
name|dev_priv
operator|->
name|quirks
operator|&
name|QUIRK_PIPEA_FORCE
operator|)
condition|)
return|return;
name|reg
operator|=
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PIPECONF_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator|&
operator|~
name|PIPECONF_ENABLE
argument_list|)
expr_stmt|;
name|intel_wait_for_pipe_off
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Plane regs are double buffered, going from enabled->disabled needs a  * trigger in order to latch.  The display address reg provides this.  */
end_comment

begin_function
name|void
name|intel_flush_display_plane
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|plane
name|plane
parameter_list|)
block|{
name|I915_WRITE
argument_list|(
name|DSPADDR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|DSPADDR
argument_list|(
name|plane
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPSURF
argument_list|(
name|plane
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|DSPSURF
argument_list|(
name|plane
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_enable_plane - enable a display plane on a given pipe  * @dev_priv: i915 private structure  * @plane: plane to enable  * @pipe: pipe being fed  *  * Enable @plane on @pipe, making sure that @pipe is running first.  */
end_comment

begin_function
specifier|static
name|void
name|intel_enable_plane
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|plane
name|plane
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* If the pipe isn't enabled, we can't pump pixels and may hang */
name|assert_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator||
name|DISPLAY_PLANE_ENABLE
argument_list|)
expr_stmt|;
name|intel_flush_display_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_disable_plane - disable a display plane  * @dev_priv: i915 private structure  * @plane: plane to disable  * @pipe: pipe consuming the data  *  * Disable @plane; should be an independent operation.  */
end_comment

begin_function
specifier|static
name|void
name|intel_disable_plane
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|plane
name|plane
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator|&
operator|~
name|DISPLAY_PLANE_ENABLE
argument_list|)
expr_stmt|;
name|intel_flush_display_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disable_pch_dp
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|int
name|reg
parameter_list|,
name|u32
name|port_sel
parameter_list|)
block|{
name|u32
name|val
init|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|dp_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|port_sel
argument_list|,
name|val
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Disabling pch dp %x on pipe %d\n"
argument_list|,
name|reg
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator|&
operator|~
name|DP_PORT_EN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|disable_pch_hdmi
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|u32
name|val
init|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|hdmi_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|val
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Disabling pch HDMI %x on pipe %d\n"
argument_list|,
name|reg
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator|&
operator|~
name|PORT_ENABLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Disable any ports connected to this transcoder */
end_comment

begin_function
specifier|static
name|void
name|intel_disable_pch_ports
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|enum
name|pipe
name|pipe
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_PP_CONTROL
argument_list|,
name|val
operator||
name|PANEL_UNLOCK_REGS
argument_list|)
expr_stmt|;
name|disable_pch_dp
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_B
argument_list|,
name|TRANS_DP_PORT_SEL_B
argument_list|)
expr_stmt|;
name|disable_pch_dp
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_C
argument_list|,
name|TRANS_DP_PORT_SEL_C
argument_list|)
expr_stmt|;
name|disable_pch_dp
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|PCH_DP_D
argument_list|,
name|TRANS_DP_PORT_SEL_D
argument_list|)
expr_stmt|;
name|reg
operator|=
name|PCH_ADPA
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|adpa_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|val
argument_list|,
name|pipe
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator|&
operator|~
name|ADPA_DAC_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|PCH_LVDS
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvds_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|val
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"disable lvds on pipe %d val 0x%08x\n"
argument_list|,
name|pipe
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator|&
operator|~
name|LVDS_PORT_EN
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|disable_pch_hdmi
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMIB
argument_list|)
expr_stmt|;
name|disable_pch_hdmi
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMIC
argument_list|)
expr_stmt|;
name|disable_pch_hdmi
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|HDMID
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|intel_pin_and_fence_fb_obj
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|pipelined
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|alignment
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|alignment
operator|=
literal|0
expr_stmt|;
comment|/* shut gcc */
switch|switch
condition|(
name|obj
operator|->
name|tiling_mode
condition|)
block|{
case|case
name|I915_TILING_NONE
case|:
if|if
condition|(
name|IS_BROADWATER
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_CRESTLINE
argument_list|(
name|dev
argument_list|)
condition|)
name|alignment
operator|=
literal|128
operator|*
literal|1024
expr_stmt|;
elseif|else
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
name|alignment
operator|=
literal|4
operator|*
literal|1024
expr_stmt|;
else|else
name|alignment
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
break|break;
case|case
name|I915_TILING_X
case|:
comment|/* pin() will align the object as required by fence */
name|alignment
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|I915_TILING_Y
case|:
comment|/* FIXME: Is this true? */
name|DRM_ERROR
argument_list|(
literal|"Y tiled not allowed for scan out buffers\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
default|default:
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"Wrong tiling for fb obj"
operator|)
argument_list|)
expr_stmt|;
block|}
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|false
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_pin_to_display_plane
argument_list|(
name|obj
argument_list|,
name|alignment
argument_list|,
name|pipelined
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_interruptible
goto|;
comment|/* Install a fence for tiled scan-out. Pre-i965 always needs a 	 * fence, whereas 965+ only requires a fence if using 	 * framebuffer compression.  For simplicity, we always install 	 * a fence as the cost is not that onerous. 	 */
name|ret
operator|=
name|i915_gem_object_get_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin
goto|;
name|i915_gem_object_pin_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin
label|:
name|i915_gem_object_unpin_from_display_plane
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|err_interruptible
label|:
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|true
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|intel_unpin_fb_obj
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|i915_gem_object_unpin_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|i915_gem_object_unpin_from_display_plane
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i9xx_update_plane
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|unsigned
name|long
name|Start
decl_stmt|,
name|Offset
decl_stmt|;
name|u32
name|dspcntr
decl_stmt|;
name|u32
name|reg
decl_stmt|;
switch|switch
condition|(
name|plane
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Can't update plane %d in SAREA\n"
argument_list|,
name|plane
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|obj
operator|=
name|intel_fb
operator|->
name|obj
expr_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|dspcntr
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* Mask out pixel format bits in case we change it */
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_PIXFORMAT_MASK
expr_stmt|;
switch|switch
condition|(
name|fb
operator|->
name|bits_per_pixel
condition|)
block|{
case|case
literal|8
case|:
name|dspcntr
operator||=
name|DISPPLANE_8BPP
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|fb
operator|->
name|depth
operator|==
literal|15
condition|)
name|dspcntr
operator||=
name|DISPPLANE_15_16BPP
expr_stmt|;
else|else
name|dspcntr
operator||=
name|DISPPLANE_16BPP
expr_stmt|;
break|break;
case|case
literal|24
case|:
case|case
literal|32
case|:
name|dspcntr
operator||=
name|DISPPLANE_32BPP_NO_ALPHA
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown color depth %d\n"
argument_list|,
name|fb
operator|->
name|bits_per_pixel
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
condition|)
name|dspcntr
operator||=
name|DISPPLANE_TILED
expr_stmt|;
else|else
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_TILED
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|dspcntr
argument_list|)
expr_stmt|;
name|Start
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
name|Offset
operator|=
name|y
operator|*
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|+
name|x
operator|*
operator|(
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
operator|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Writing base %08lX %08lX %d %d %d\n"
argument_list|,
name|Start
argument_list|,
name|Offset
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPSTRIDE
argument_list|(
name|plane
argument_list|)
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|I915_MODIFY_DISPBASE
argument_list|(
name|DSPSURF
argument_list|(
name|plane
argument_list|)
argument_list|,
name|Start
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPTILEOFF
argument_list|(
name|plane
argument_list|)
argument_list|,
operator|(
name|y
operator|<<
literal|16
operator|)
operator||
name|x
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPADDR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|Offset
argument_list|)
expr_stmt|;
block|}
else|else
name|I915_WRITE
argument_list|(
name|DSPADDR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|Start
operator|+
name|Offset
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ironlake_update_plane
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|unsigned
name|long
name|Start
decl_stmt|,
name|Offset
decl_stmt|;
name|u32
name|dspcntr
decl_stmt|;
name|u32
name|reg
decl_stmt|;
switch|switch
condition|(
name|plane
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Can't update plane %d in SAREA\n"
argument_list|,
name|plane
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|obj
operator|=
name|intel_fb
operator|->
name|obj
expr_stmt|;
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|dspcntr
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* Mask out pixel format bits in case we change it */
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_PIXFORMAT_MASK
expr_stmt|;
switch|switch
condition|(
name|fb
operator|->
name|bits_per_pixel
condition|)
block|{
case|case
literal|8
case|:
name|dspcntr
operator||=
name|DISPPLANE_8BPP
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|fb
operator|->
name|depth
operator|!=
literal|16
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"bpp 16, depth %d\n"
argument_list|,
name|fb
operator|->
name|depth
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|dspcntr
operator||=
name|DISPPLANE_16BPP
expr_stmt|;
break|break;
case|case
literal|24
case|:
case|case
literal|32
case|:
if|if
condition|(
name|fb
operator|->
name|depth
operator|==
literal|24
condition|)
name|dspcntr
operator||=
name|DISPPLANE_32BPP_NO_ALPHA
expr_stmt|;
elseif|else
if|if
condition|(
name|fb
operator|->
name|depth
operator|==
literal|30
condition|)
name|dspcntr
operator||=
name|DISPPLANE_32BPP_30BIT_NO_ALPHA
expr_stmt|;
else|else
block|{
name|DRM_ERROR
argument_list|(
literal|"bpp %d depth %d\n"
argument_list|,
name|fb
operator|->
name|bits_per_pixel
argument_list|,
name|fb
operator|->
name|depth
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown color depth %d\n"
argument_list|,
name|fb
operator|->
name|bits_per_pixel
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
condition|)
name|dspcntr
operator||=
name|DISPPLANE_TILED
expr_stmt|;
else|else
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_TILED
expr_stmt|;
comment|/* must disable */
name|dspcntr
operator||=
name|DISPPLANE_TRICKLE_FEED_DISABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|dspcntr
argument_list|)
expr_stmt|;
name|Start
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
name|Offset
operator|=
name|y
operator|*
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|+
name|x
operator|*
operator|(
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
operator|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Writing base %08lX %08lX %d %d %d\n"
argument_list|,
name|Start
argument_list|,
name|Offset
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPSTRIDE
argument_list|(
name|plane
argument_list|)
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|I915_MODIFY_DISPBASE
argument_list|(
name|DSPSURF
argument_list|(
name|plane
argument_list|)
argument_list|,
name|Start
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPTILEOFF
argument_list|(
name|plane
argument_list|)
argument_list|,
operator|(
name|y
operator|<<
literal|16
operator|)
operator||
name|x
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPADDR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|Offset
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Assume fb object is pinned& idle& fenced and just update base pointers */
end_comment

begin_function
specifier|static
name|int
name|intel_pipe_set_base_atomic
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|enum
name|mode_set_atomic
name|state
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|display
operator|.
name|disable_fbc
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_increase_pllclock
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
return|return
name|dev_priv
operator|->
name|display
operator|.
name|update_plane
argument_list|(
name|crtc
argument_list|,
name|fb
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_finish_fb
parameter_list|(
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|to_intel_framebuffer
argument_list|(
name|old_fb
argument_list|)
operator|->
name|obj
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|bool
name|was_interruptible
init|=
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|atomic_load_acq_int
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
operator|&&
name|atomic_load_acq_int
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msleep
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|,
operator|&
name|dev
operator|->
name|event_lock
argument_list|,
literal|0
argument_list|,
literal|"915flp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
comment|/* Big Hammer, we also need to ensure that any pending 	 * MI_WAIT_FOR_EVENT inside a user batch buffer on the 	 * current scanout is retired before unpinning the old 	 * framebuffer. 	 * 	 * This should only fail upon a hung GPU, in which case we 	 * can safely continue. 	 */
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|false
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_finish_gpu
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|was_interruptible
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_pipe_set_base
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|#
directive|if
literal|0
block|struct drm_i915_master_private *master_priv;
endif|#
directive|endif
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* no fb bound */
if|if
condition|(
operator|!
name|crtc
operator|->
name|fb
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"No FB bound\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|intel_crtc
operator|->
name|plane
operator|>
name|dev_priv
operator|->
name|num_pipe
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"no plane for crtc: plane %d, num_pipes %d\n"
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|,
name|dev_priv
operator|->
name|num_pipe
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
operator|->
name|obj
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"pin& fence failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|old_fb
condition|)
name|intel_finish_fb
argument_list|(
name|old_fb
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dev_priv
operator|->
name|display
operator|.
name|update_plane
argument_list|(
name|crtc
argument_list|,
name|crtc
operator|->
name|fb
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|intel_unpin_fb_obj
argument_list|(
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
operator|->
name|obj
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"failed to update base address\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|old_fb
condition|)
block|{
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|intel_unpin_fb_obj
argument_list|(
name|to_intel_framebuffer
argument_list|(
name|old_fb
argument_list|)
operator|->
name|obj
argument_list|)
expr_stmt|;
block|}
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (!dev->primary->master) 		return 0;  	master_priv = dev->primary->master->driver_priv; 	if (!master_priv->sarea_priv) 		return 0;  	if (intel_crtc->pipe) { 		master_priv->sarea_priv->pipeB_x = x; 		master_priv->sarea_priv->pipeB_y = y; 	} else { 		master_priv->sarea_priv->pipeA_x = x; 		master_priv->sarea_priv->pipeA_y = y; 	}
else|#
directive|else
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|sarea_priv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|intel_crtc
operator|->
name|pipe
condition|)
block|{
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeB_x
operator|=
name|x
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeB_y
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeA_x
operator|=
name|x
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeA_y
operator|=
name|y
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_set_pll_edp
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|dpa_ctl
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"eDP PLL enable for clock %d\n"
argument_list|,
name|clock
argument_list|)
expr_stmt|;
name|dpa_ctl
operator|=
name|I915_READ
argument_list|(
name|DP_A
argument_list|)
expr_stmt|;
name|dpa_ctl
operator|&=
operator|~
name|DP_PLL_FREQ_MASK
expr_stmt|;
if|if
condition|(
name|clock
operator|<
literal|200000
condition|)
block|{
name|u32
name|temp
decl_stmt|;
name|dpa_ctl
operator||=
name|DP_PLL_FREQ_160MHZ
expr_stmt|;
comment|/* workaround for 160Mhz: 		   1) program 0x4600c bits 15:0 = 0x8124 		   2) program 0x46010 bit 0 = 1 		   3) program 0x46034 bit 24 = 1 		   4) program 0x64000 bit 14 = 1 		   */
name|temp
operator|=
name|I915_READ
argument_list|(
literal|0x4600c
argument_list|)
expr_stmt|;
name|temp
operator|&=
literal|0xffff0000
expr_stmt|;
name|I915_WRITE
argument_list|(
literal|0x4600c
argument_list|,
name|temp
operator||
literal|0x8124
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
literal|0x46010
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
literal|0x46010
argument_list|,
name|temp
operator||
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
literal|0x46034
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
literal|0x46034
argument_list|,
name|temp
operator||
operator|(
literal|1
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dpa_ctl
operator||=
name|DP_PLL_FREQ_270MHZ
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|DP_A
argument_list|,
name|dpa_ctl
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DP_A
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_fdi_normal_train
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
comment|/* enable normal train */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE_IVB
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_NONE_IVB
operator||
name|FDI_TX_ENHANCE_FRAME_ENABLE
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_NONE
operator||
name|FDI_TX_ENHANCE_FRAME_ENABLE
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_NORMAL_CPT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_ENHANCE_FRAME_ENABLE
argument_list|)
expr_stmt|;
comment|/* wait one idle pattern time */
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* IVB wants error correction enabled */
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator||
name|FDI_FS_ERRC_ENABLE
operator||
name|FDI_FE_ERRC_ENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cpt_phase_pointer_enable
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|flags
init|=
name|I915_READ
argument_list|(
name|SOUTH_CHICKEN1
argument_list|)
decl_stmt|;
name|flags
operator||=
name|FDI_PHASE_SYNC_OVR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SOUTH_CHICKEN1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* once to unlock... */
name|flags
operator||=
name|FDI_PHASE_SYNC_EN
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SOUTH_CHICKEN1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* then again to enable */
name|POSTING_READ
argument_list|(
name|SOUTH_CHICKEN1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The FDI link training functions for ILK/Ibexpeak. */
end_comment

begin_function
specifier|static
name|void
name|ironlake_fdi_link_train
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|,
name|tries
decl_stmt|;
comment|/* FDI needs bits from pipe& plane first */
name|assert_pipe_enabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|assert_plane_enabled
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|)
expr_stmt|;
comment|/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit 	   for train result */
name|reg
operator|=
name|FDI_RX_IMR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_SYMBOL_LOCK
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_BIT_LOCK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* enable CPU FDI TX and PCH FDI RX */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|19
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|-
literal|1
operator|)
operator|<<
literal|19
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_TX_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* Ironlake workaround, enable clock pointer after FDI enable*/
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|FDI_RX_CHICKEN
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|FDI_RX_PHASE_SYNC_POINTER_OVR
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FDI_RX_CHICKEN
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|FDI_RX_PHASE_SYNC_POINTER_OVR
operator||
name|FDI_RX_PHASE_SYNC_POINTER_EN
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
literal|5
condition|;
name|tries
operator|++
control|)
block|{
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|&
name|FDI_RX_BIT_LOCK
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 1 done.\n"
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_BIT_LOCK
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tries
operator|==
literal|5
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 1 fail!\n"
argument_list|)
expr_stmt|;
comment|/* Train 2 */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
literal|5
condition|;
name|tries
operator|++
control|)
block|{
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_SYMBOL_LOCK
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_SYMBOL_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 2 done.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tries
operator|==
literal|5
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 2 fail!\n"
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train done\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|int
name|snb_b_fdi_train_param
index|[]
init|=
block|{
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
block|,
name|FDI_LINK_TRAIN_400MV_6DB_SNB_B
block|,
name|FDI_LINK_TRAIN_600MV_3_5DB_SNB_B
block|,
name|FDI_LINK_TRAIN_800MV_0DB_SNB_B
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The FDI link training functions for SNB/Cougarpoint. */
end_comment

begin_function
specifier|static
name|void
name|gen6_fdi_link_train
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|,
name|i
decl_stmt|,
name|retry
decl_stmt|;
comment|/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit 	   for train result */
name|reg
operator|=
name|FDI_RX_IMR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_SYMBOL_LOCK
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_BIT_LOCK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* enable CPU FDI TX and PCH FDI RX */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|19
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|-
literal|1
operator|)
operator|<<
literal|19
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
comment|/* SNB-B */
name|temp
operator||=
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_TX_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1_CPT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
name|cpt_phase_pointer_enable
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|snb_b_fdi_train_param
index|[
name|i
index|]
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
literal|5
condition|;
name|retry
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_BIT_LOCK
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_BIT_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 1 done.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retry
operator|<
literal|5
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 1 fail!\n"
argument_list|)
expr_stmt|;
comment|/* Train 2 */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2
expr_stmt|;
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
comment|/* SNB-B */
name|temp
operator||=
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2_CPT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|snb_b_fdi_train_param
index|[
name|i
index|]
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
literal|5
condition|;
name|retry
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_SYMBOL_LOCK
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_SYMBOL_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 2 done.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retry
operator|<
literal|5
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 2 fail!\n"
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Manual link training for Ivy Bridge A0 parts */
end_comment

begin_function
specifier|static
name|void
name|ivb_manual_fdi_link_train
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|,
name|i
decl_stmt|;
comment|/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit 	   for train result */
name|reg
operator|=
name|FDI_RX_IMR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_SYMBOL_LOCK
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_RX_BIT_LOCK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* enable CPU FDI TX and PCH FDI RX */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|19
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|-
literal|1
operator|)
operator|<<
literal|19
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|FDI_LINK_TRAIN_AUTO
operator||
name|FDI_LINK_TRAIN_NONE_IVB
operator|)
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1_IVB
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
expr_stmt|;
name|temp
operator||=
name|FDI_COMPOSITE_SYNC
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_TX_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_AUTO
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_COMPOSITE_SYNC
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|snb_b_fdi_train_param
index|[
name|i
index|]
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_BIT_LOCK
operator|||
operator|(
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
name|FDI_RX_BIT_LOCK
operator|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_BIT_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 1 done.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 1 fail!\n"
argument_list|)
expr_stmt|;
comment|/* Train 2 */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE_IVB
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2_IVB
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_400MV_0DB_SNB_B
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_2_CPT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_VOL_EMP_MASK
expr_stmt|;
name|temp
operator||=
name|snb_b_fdi_train_param
index|[
name|i
index|]
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_IIR
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI_RX_IIR 0x%x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|FDI_RX_SYMBOL_LOCK
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_SYMBOL_LOCK
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train 2 done.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|DRM_ERROR
argument_list|(
literal|"FDI train 2 fail!\n"
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FDI train done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_fdi_pll_enable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
comment|/* Write the TU size bits so error detection works */
name|I915_WRITE
argument_list|(
name|FDI_RX_TUSIZE1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|PIPE_DATA_M1
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|TU_SIZE_MASK
argument_list|)
expr_stmt|;
comment|/* enable PCH FDI RX PLL, wait warmup plus DMI latency */
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
operator|(
literal|0x7
operator|<<
literal|19
operator|)
operator||
operator|(
literal|0x7
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|intel_crtc
operator|->
name|fdi_lanes
operator|-
literal|1
operator|)
operator|<<
literal|19
expr_stmt|;
name|temp
operator||=
operator|(
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|PIPE_BPC_MASK
operator|)
operator|<<
literal|11
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_RX_PLL_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Switch from Rawclk to PCDclk */
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_PCDCLK
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* On Haswell, the PLL configuration for ports and pipes is handled 	 * separately, as part of DDI setup */
if|if
condition|(
operator|!
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* Enable CPU FDI TX PLL, always on for Ironlake */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|&
name|FDI_TX_PLL_ENABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator||
name|FDI_TX_PLL_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cpt_phase_pointer_disable
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|flags
init|=
name|I915_READ
argument_list|(
name|SOUTH_CHICKEN1
argument_list|)
decl_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|FDI_PHASE_SYNC_EN
argument_list|(
name|pipe
argument_list|)
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SOUTH_CHICKEN1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* once to disable... */
name|flags
operator|&=
operator|~
operator|(
name|FDI_PHASE_SYNC_OVR
argument_list|(
name|pipe
argument_list|)
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SOUTH_CHICKEN1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* then again to lock */
name|POSTING_READ
argument_list|(
name|SOUTH_CHICKEN1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_fdi_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
comment|/* disable CPU FDI tx and PCH FDI rx */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_TX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
literal|0x7
operator|<<
literal|16
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|PIPE_BPC_MASK
operator|)
operator|<<
literal|11
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_RX_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Ironlake workaround, disable clock pointer after downing FDI */
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|FDI_RX_CHICKEN
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|FDI_RX_PHASE_SYNC_POINTER_OVR
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FDI_RX_CHICKEN
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|FDI_RX_CHICKEN
argument_list|(
name|pipe
argument_list|)
operator|&
operator|~
name|FDI_RX_PHASE_SYNC_POINTER_EN
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|cpt_phase_pointer_disable
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
comment|/* still set train pattern 1 */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_PATTERN_MASK_CPT
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1_CPT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|FDI_LINK_TRAIN_NONE
expr_stmt|;
name|temp
operator||=
name|FDI_LINK_TRAIN_PATTERN_1
expr_stmt|;
block|}
comment|/* BPC in FDI rx is consistent with that in PIPECONF */
name|temp
operator|&=
operator|~
operator|(
literal|0x07
operator|<<
literal|16
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|PIPE_BPC_MASK
operator|)
operator|<<
literal|11
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_wait_for_pending_flips
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|crtc
operator|->
name|fb
operator|==
name|NULL
condition|)
return|return;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_finish_fb
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_crtc_driving_pch
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
comment|/* 	 * If there's a non-PCH eDP on this crtc, it must be DP_A, and that 	 * must be driven by its own crtc; no sharing is possible. 	 */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
comment|/* On Haswell, LPT PCH handles the VGA connection via FDI, and Haswell 		 * CPU handles all others */
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* It is still unclear how this will work on PPT, so throw up a warning */
if|if
condition|(
operator|!
name|HAS_PCH_LPT
argument_list|(
name|dev
argument_list|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"Haswell: PPT\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoder
operator|->
name|type
operator|==
name|DRM_MODE_ENCODER_DAC
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Haswell detected DAC encoder, assuming is PCH\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Haswell detected encoder %d, assuming is CPU\n"
argument_list|,
name|encoder
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_EDP
case|:
if|if
condition|(
operator|!
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|)
condition|)
return|return
name|false
return|;
continue|continue;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Program iCLKIP clock to the desired frequency */
end_comment

begin_function
specifier|static
name|void
name|lpt_program_iclkip
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|divsel
decl_stmt|,
name|phaseinc
decl_stmt|,
name|auxdiv
decl_stmt|,
name|phasedir
init|=
literal|0
decl_stmt|;
name|u32
name|temp
decl_stmt|;
comment|/* It is necessary to ungate the pixclk gate prior to programming 	 * the divisors, and gate it back when it is done. 	 */
name|I915_WRITE
argument_list|(
name|PIXCLK_GATE
argument_list|,
name|PIXCLK_GATE_GATE
argument_list|)
expr_stmt|;
comment|/* Disable SSCCTL */
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCCTL6
argument_list|,
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCCTL6
argument_list|)
operator||
name|SBI_SSCCTL_DISABLE
argument_list|)
expr_stmt|;
comment|/* 20MHz is a corner case which is out of range for the 7-bit divisor */
if|if
condition|(
name|crtc
operator|->
name|mode
operator|.
name|clock
operator|==
literal|20000
condition|)
block|{
name|auxdiv
operator|=
literal|1
expr_stmt|;
name|divsel
operator|=
literal|0x41
expr_stmt|;
name|phaseinc
operator|=
literal|0x20
expr_stmt|;
block|}
else|else
block|{
comment|/* The iCLK virtual clock root frequency is in MHz, 		 * but the crtc->mode.clock in in KHz. To get the divisors, 		 * it is necessary to divide one by another, so we 		 * convert the virtual clock precision to KHz here for higher 		 * precision. 		 */
name|u32
name|iclk_virtual_root_freq
init|=
literal|172800
operator|*
literal|1000
decl_stmt|;
name|u32
name|iclk_pi_range
init|=
literal|64
decl_stmt|;
name|u32
name|desired_divisor
decl_stmt|,
name|msb_divisor_value
decl_stmt|,
name|pi_value
decl_stmt|;
name|desired_divisor
operator|=
operator|(
name|iclk_virtual_root_freq
operator|/
name|crtc
operator|->
name|mode
operator|.
name|clock
operator|)
expr_stmt|;
name|msb_divisor_value
operator|=
name|desired_divisor
operator|/
name|iclk_pi_range
expr_stmt|;
name|pi_value
operator|=
name|desired_divisor
operator|%
name|iclk_pi_range
expr_stmt|;
name|auxdiv
operator|=
literal|0
expr_stmt|;
name|divsel
operator|=
name|msb_divisor_value
operator|-
literal|2
expr_stmt|;
name|phaseinc
operator|=
name|pi_value
expr_stmt|;
block|}
comment|/* This should not happen with any sane values */
if|if
condition|(
operator|(
name|SBI_SSCDIVINTPHASE_DIVSEL
argument_list|(
name|divsel
argument_list|)
operator|&
operator|~
name|SBI_SSCDIVINTPHASE_DIVSEL_MASK
operator|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"DIVSEL_MASK"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SBI_SSCDIVINTPHASE_DIR
argument_list|(
name|phasedir
argument_list|)
operator|&
operator|~
name|SBI_SSCDIVINTPHASE_INCVAL_MASK
operator|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"INCVAL_MASK"
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"iCLKIP clock: found settings for %dKHz refresh rate: auxdiv=%x, divsel=%x, phasedir=%x, phaseinc=%x\n"
argument_list|,
name|crtc
operator|->
name|mode
operator|.
name|clock
argument_list|,
name|auxdiv
argument_list|,
name|divsel
argument_list|,
name|phasedir
argument_list|,
name|phaseinc
argument_list|)
expr_stmt|;
comment|/* Program SSCDIVINTPHASE6 */
name|temp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCDIVINTPHASE6
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|SBI_SSCDIVINTPHASE_DIVSEL_MASK
expr_stmt|;
name|temp
operator||=
name|SBI_SSCDIVINTPHASE_DIVSEL
argument_list|(
name|divsel
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|SBI_SSCDIVINTPHASE_INCVAL_MASK
expr_stmt|;
name|temp
operator||=
name|SBI_SSCDIVINTPHASE_INCVAL
argument_list|(
name|phaseinc
argument_list|)
expr_stmt|;
name|temp
operator||=
name|SBI_SSCDIVINTPHASE_DIR
argument_list|(
name|phasedir
argument_list|)
expr_stmt|;
name|temp
operator||=
name|SBI_SSCDIVINTPHASE_PROPAGATE
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCDIVINTPHASE6
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Program SSCAUXDIV */
name|temp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCAUXDIV6
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|SBI_SSCAUXDIV_FINALDIV2SEL
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|temp
operator||=
name|SBI_SSCAUXDIV_FINALDIV2SEL
argument_list|(
name|auxdiv
argument_list|)
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCAUXDIV6
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Enable modulator and associated divider */
name|temp
operator|=
name|intel_sbi_read
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCCTL6
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|SBI_SSCCTL_DISABLE
expr_stmt|;
name|intel_sbi_write
argument_list|(
name|dev_priv
argument_list|,
name|SBI_SSCCTL6
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Wait for initialization time */
name|DELAY
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIXCLK_GATE
argument_list|,
name|PIXCLK_GATE_UNGATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable PCH resources required for PCH ports:  *   - PCH PLLs  *   - FDI training& RX/TX  *   - update transcoder timings  *   - DP transcoding bits  *   - transcoder  */
end_comment

begin_function
specifier|static
name|void
name|ironlake_pch_enable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
name|assert_transcoder_disabled
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* For PCH output, training FDI link */
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_enable_pch_pll
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_LPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"LPT detected: programming iCLKIP\n"
argument_list|)
expr_stmt|;
name|lpt_program_iclkip
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|u32
name|sel
decl_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_DPLL_SEL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
default|default:
case|case
literal|0
case|:
name|temp
operator||=
name|TRANSA_DPLL_ENABLE
expr_stmt|;
name|sel
operator|=
name|TRANSA_DPLLB_SEL
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|temp
operator||=
name|TRANSB_DPLL_ENABLE
expr_stmt|;
name|sel
operator|=
name|TRANSB_DPLLB_SEL
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|temp
operator||=
name|TRANSC_DPLL_ENABLE
expr_stmt|;
name|sel
operator|=
name|TRANSC_DPLLB_SEL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|pll_reg
operator|==
name|_PCH_DPLL_B
condition|)
name|temp
operator||=
name|sel
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
name|sel
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DPLL_SEL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* set transcoder timing, panel must allow it */
name|assert_panel_unlocked
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_HTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|HTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_HBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|HBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_HSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|HSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_VTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|VTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_VBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|VBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_VSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|VSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_VSYNCSHIFT
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|VSYNCSHIFT
argument_list|(
name|pipe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_fdi_normal_train
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* For PCH DP, enable TRANS_DP_CTL */
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
operator|||
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_EDP
argument_list|)
operator|)
condition|)
block|{
name|u32
name|bpc
init|=
operator|(
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator|&
name|PIPE_BPC_MASK
operator|)
operator|>>
literal|5
decl_stmt|;
name|reg
operator|=
name|TRANS_DP_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|TRANS_DP_PORT_SEL_MASK
operator||
name|TRANS_DP_SYNC_MASK
operator||
name|TRANS_DP_BPC_MASK
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
name|TRANS_DP_OUTPUT_ENABLE
operator||
name|TRANS_DP_ENH_FRAMING
operator|)
expr_stmt|;
name|temp
operator||=
name|bpc
operator|<<
literal|9
expr_stmt|;
comment|/* same format but at 11:9 */
if|if
condition|(
name|crtc
operator|->
name|mode
operator|.
name|flags
operator|&
name|DRM_MODE_FLAG_PHSYNC
condition|)
name|temp
operator||=
name|TRANS_DP_HSYNC_ACTIVE_HIGH
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|mode
operator|.
name|flags
operator|&
name|DRM_MODE_FLAG_PVSYNC
condition|)
name|temp
operator||=
name|TRANS_DP_VSYNC_ACTIVE_HIGH
expr_stmt|;
switch|switch
condition|(
name|intel_trans_dp_port_sel
argument_list|(
name|crtc
argument_list|)
condition|)
block|{
case|case
name|PCH_DP_B
case|:
name|temp
operator||=
name|TRANS_DP_PORT_SEL_B
expr_stmt|;
break|break;
case|case
name|PCH_DP_C
case|:
name|temp
operator||=
name|TRANS_DP_PORT_SEL_C
expr_stmt|;
break|break;
case|case
name|PCH_DP_D
case|:
name|temp
operator||=
name|TRANS_DP_PORT_SEL_D
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG_KMS
argument_list|(
literal|"Wrong PCH DP port return. Guess port B\n"
argument_list|)
expr_stmt|;
name|temp
operator||=
name|TRANS_DP_PORT_SEL_B
expr_stmt|;
break|break;
block|}
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|intel_enable_transcoder
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_put_pch_pll
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|)
block|{
name|struct
name|intel_pch_pll
modifier|*
name|pll
init|=
name|intel_crtc
operator|->
name|pch_pll
decl_stmt|;
if|if
condition|(
name|pll
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pll
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bad PCH PLL refcount\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|--
name|pll
operator|->
name|refcount
expr_stmt|;
name|intel_crtc
operator|->
name|pch_pll
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|intel_pch_pll
modifier|*
name|intel_get_pch_pll
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|,
name|u32
name|dpll
parameter_list|,
name|u32
name|fp
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|intel_crtc
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_pch_pll
modifier|*
name|pll
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pll
operator|=
name|intel_crtc
operator|->
name|pch_pll
expr_stmt|;
if|if
condition|(
name|pll
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"CRTC:%d reusing existing PCH PLL %x\n"
argument_list|,
name|intel_crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
goto|goto
name|prepare
goto|;
block|}
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
comment|/* Ironlake PCH has a fixed PLL->PCH pipe mapping. */
name|i
operator|=
name|intel_crtc
operator|->
name|pipe
expr_stmt|;
name|pll
operator|=
operator|&
name|dev_priv
operator|->
name|pch_plls
index|[
name|i
index|]
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"CRTC:%d using pre-allocated PCH PLL %x\n"
argument_list|,
name|intel_crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|num_pch_pll
condition|;
name|i
operator|++
control|)
block|{
name|pll
operator|=
operator|&
name|dev_priv
operator|->
name|pch_plls
index|[
name|i
index|]
expr_stmt|;
comment|/* Only want to check enabled timings first */
if|if
condition|(
name|pll
operator|->
name|refcount
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dpll
operator|==
operator|(
name|I915_READ
argument_list|(
name|pll
operator|->
name|pll_reg
argument_list|)
operator|&
literal|0x7fffffff
operator|)
operator|&&
name|fp
operator|==
name|I915_READ
argument_list|(
name|pll
operator|->
name|fp0_reg
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"CRTC:%d sharing existing PCH PLL %x (refcount %d, ative %d)\n"
argument_list|,
name|intel_crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|,
name|pll
operator|->
name|refcount
argument_list|,
name|pll
operator|->
name|active
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
comment|/* Ok no matching timings, maybe there's a free one? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|num_pch_pll
condition|;
name|i
operator|++
control|)
block|{
comment|/* XXXKIB: HACK */
name|pll
operator|=
operator|&
name|dev_priv
operator|->
name|pch_plls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pll
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"CRTC:%d allocated PCH PLL %x\n"
argument_list|,
name|intel_crtc
operator|->
name|base
operator|.
name|base
operator|.
name|id
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
return|return
name|NULL
return|;
name|found
label|:
name|intel_crtc
operator|->
name|pch_pll
operator|=
name|pll
expr_stmt|;
name|pll
operator|->
name|refcount
operator|++
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"using pll %d for pipe %d\n"
argument_list|,
name|i
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|prepare
label|:
comment|/* separate function? */
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"switching PLL %x off\n"
argument_list|,
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to stabilize before rewriting the regs */
name|I915_WRITE
argument_list|(
name|pll
operator|->
name|pll_reg
argument_list|,
name|dpll
operator|&
operator|~
name|DPLL_VCO_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|pll
operator|->
name|fp0_reg
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|pll
operator|->
name|pll_reg
argument_list|,
name|dpll
operator|&
operator|~
name|DPLL_VCO_ENABLE
argument_list|)
expr_stmt|;
name|pll
operator|->
name|on
operator|=
name|false
expr_stmt|;
return|return
name|pll
return|;
block|}
end_function

begin_function
name|void
name|intel_cpt_verify_modeset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|dslreg
init|=
name|PIPEDSL
argument_list|(
name|pipe
argument_list|)
decl_stmt|,
name|tc2reg
init|=
name|TRANS_CHICKEN2
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|dslreg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
name|I915_READ
argument_list|(
name|dslreg
argument_list|)
operator|!=
name|temp
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|"915cp1"
argument_list|)
condition|)
block|{
comment|/* Without this, mode sets may fail silently on FDI */
name|I915_WRITE
argument_list|(
name|tc2reg
argument_list|,
name|TRANS_AUTOTRAIN_GEN_STALL_DIS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|250
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|tc2reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
name|I915_READ
argument_list|(
name|dslreg
argument_list|)
operator|!=
name|temp
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|"915cp2"
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"mode set failed: pipe %d stuck\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_crtc_enable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|bool
name|is_pch_port
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|active
condition|)
return|return;
name|intel_crtc
operator|->
name|active
operator|=
name|true
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|&
name|LVDS_PORT_EN
operator|)
operator|==
literal|0
condition|)
name|I915_WRITE
argument_list|(
name|PCH_LVDS
argument_list|,
name|temp
operator||
name|LVDS_PORT_EN
argument_list|)
expr_stmt|;
block|}
name|is_pch_port
operator|=
name|intel_crtc_driving_pch
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pch_port
condition|)
name|ironlake_fdi_pll_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
else|else
name|ironlake_fdi_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* Enable panel fitting for LVDS */
if|if
condition|(
name|dev_priv
operator|->
name|pch_pf_size
operator|&&
operator|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|||
name|HAS_eDP
operator|)
condition|)
block|{
comment|/* Force use of hard-coded filter coefficients 		 * as some pre-programmed values are broken, 		 * e.g. x201. 		 */
name|I915_WRITE
argument_list|(
name|PF_CTL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|PF_ENABLE
operator||
name|PF_FILTER_MED_3x3
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PF_WIN_POS
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dev_priv
operator|->
name|pch_pf_pos
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PF_WIN_SZ
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dev_priv
operator|->
name|pch_pf_size
argument_list|)
expr_stmt|;
block|}
name|intel_enable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|is_pch_port
argument_list|)
expr_stmt|;
name|intel_enable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pch_port
condition|)
name|ironlake_pch_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_crtc_load_lut
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_crtc_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|active
condition|)
return|return;
name|intel_crtc_wait_for_pending_flips
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|drm_vblank_off
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|intel_disable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|cfb_plane
operator|==
name|plane
condition|)
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_disable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* Disable PF */
name|I915_WRITE
argument_list|(
name|PF_CTL
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PF_WIN_SZ
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ironlake_fdi_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* This is a horrible layering violation; we should be doing this in 	 * the connector/encoder ->prepare instead, but we don't always have 	 * enough information there about the config to know whether it will 	 * actually be necessary or just cause undesired flicker. 	 */
name|intel_disable_pch_ports
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_disable_transcoder
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* disable TRANS_DP_CTL */
name|reg
operator|=
name|TRANS_DP_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|TRANS_DP_OUTPUT_ENABLE
operator||
name|TRANS_DP_PORT_SEL_MASK
operator|)
expr_stmt|;
name|temp
operator||=
name|TRANS_DP_PORT_SEL_NONE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* disable DPLL_SEL */
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_DPLL_SEL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
case|case
literal|0
case|:
name|temp
operator|&=
operator|~
operator|(
name|TRANSA_DPLL_ENABLE
operator||
name|TRANSA_DPLLB_SEL
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|temp
operator|&=
operator|~
operator|(
name|TRANSB_DPLL_ENABLE
operator||
name|TRANSB_DPLLB_SEL
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* C shares PLL A or B */
name|temp
operator|&=
operator|~
operator|(
name|TRANSC_DPLL_ENABLE
operator||
name|TRANSC_DPLLB_SEL
operator|)
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Wrong pipe %d"
operator|,
name|pipe
operator|)
argument_list|)
expr_stmt|;
comment|/* wtf */
block|}
name|I915_WRITE
argument_list|(
name|PCH_DPLL_SEL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* disable PCH DPLL */
name|intel_disable_pch_pll
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
comment|/* Switch from PCDclk to Rawclk */
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_PCDCLK
argument_list|)
expr_stmt|;
comment|/* Disable CPU FDI TX PLL */
name|reg
operator|=
name|FDI_TX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_TX_PLL_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FDI_RX_CTL
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|temp
operator|&
operator|~
name|FDI_RX_PLL_ENABLE
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to turn off. */
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|active
operator|=
name|false
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_crtc_dpms
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
comment|/* XXX: When our outputs are all unaware of DPMS modes other than off 	 * and on, we should map those modes to DRM_MODE_DPMS_OFF in the CRTC. 	 */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|DRM_MODE_DPMS_ON
case|:
case|case
name|DRM_MODE_DPMS_STANDBY
case|:
case|case
name|DRM_MODE_DPMS_SUSPEND
case|:
name|DRM_DEBUG_KMS
argument_list|(
literal|"crtc %d/%d dpms on\n"
argument_list|,
name|pipe
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|ironlake_crtc_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRM_MODE_DPMS_OFF
case|:
name|DRM_DEBUG_KMS
argument_list|(
literal|"crtc %d/%d dpms off\n"
argument_list|,
name|pipe
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|ironlake_crtc_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_crtc_off
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|intel_put_pch_pll
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_dpms_overlay
parameter_list|(
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
if|if
condition|(
operator|!
name|enable
operator|&&
name|intel_crtc
operator|->
name|overlay
condition|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_crtc
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|false
expr_stmt|;
operator|(
name|void
operator|)
name|intel_overlay_switch_off
argument_list|(
name|intel_crtc
operator|->
name|overlay
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|true
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Let userspace switch the overlay on again. In most cases userspace 	 * has to recompute where to put it anyway. 	 */
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_crtc_enable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|active
condition|)
return|return;
name|intel_crtc
operator|->
name|active
operator|=
name|true
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_enable_pll
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_enable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|intel_enable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_crtc_load_lut
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Give the overlay scaler a chance to enable if it's on this pipe */
name|intel_crtc_dpms_overlay
argument_list|(
name|intel_crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_crtc_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|active
condition|)
return|return;
comment|/* Give the overlay scaler a chance to disable if it's on this pipe */
name|intel_crtc_wait_for_pending_flips
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|drm_vblank_off
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_crtc_dpms_overlay
argument_list|(
name|intel_crtc
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|cfb_plane
operator|==
name|plane
condition|)
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_disable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_disable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_disable_pll
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|active
operator|=
name|false
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_crtc_dpms
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
comment|/* XXX: When our outputs are all unaware of DPMS modes other than off 	 * and on, we should map those modes to DRM_MODE_DPMS_OFF in the CRTC. 	 */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|DRM_MODE_DPMS_ON
case|:
case|case
name|DRM_MODE_DPMS_STANDBY
case|:
case|case
name|DRM_MODE_DPMS_SUSPEND
case|:
name|i9xx_crtc_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRM_MODE_DPMS_OFF
case|:
name|i9xx_crtc_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_crtc_off
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{ }
end_function

begin_comment
comment|/**  * Sets the power management mode of the pipe and plane.  */
end_comment

begin_function
specifier|static
name|void
name|intel_crtc_dpms
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|#
directive|if
literal|0
block|struct drm_i915_master_private *master_priv;
endif|#
directive|endif
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|bool
name|enabled
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|dpms_mode
operator|==
name|mode
condition|)
return|return;
name|intel_crtc
operator|->
name|dpms_mode
operator|=
name|mode
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|dpms
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (!dev->primary->master) 		return;  	master_priv = dev->primary->master->driver_priv; 	if (!master_priv->sarea_priv) 		return;
else|#
directive|else
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|sarea_priv
condition|)
return|return;
endif|#
directive|endif
name|enabled
operator|=
name|crtc
operator|->
name|enabled
operator|&&
name|mode
operator|!=
name|DRM_MODE_DPMS_OFF
expr_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
case|case
literal|0
case|:
if|#
directive|if
literal|0
block|master_priv->sarea_priv->pipeA_w = enabled ? crtc->mode.hdisplay : 0; 		master_priv->sarea_priv->pipeA_h = enabled ? crtc->mode.vdisplay : 0;
else|#
directive|else
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeA_w
operator|=
name|enabled
condition|?
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
else|:
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeA_h
operator|=
name|enabled
condition|?
name|crtc
operator|->
name|mode
operator|.
name|vdisplay
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|1
case|:
if|#
directive|if
literal|0
block|master_priv->sarea_priv->pipeB_w = enabled ? crtc->mode.hdisplay : 0; 		master_priv->sarea_priv->pipeB_h = enabled ? crtc->mode.vdisplay : 0;
else|#
directive|else
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeB_w
operator|=
name|enabled
condition|?
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
else|:
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeB_h
operator|=
name|enabled
condition|?
name|crtc
operator|->
name|mode
operator|.
name|vdisplay
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Can't update pipe %c in SAREA\n"
argument_list|,
name|pipe_name
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_crtc_helper_funcs
modifier|*
name|crtc_funcs
init|=
name|crtc
operator|->
name|helper_private
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|crtc_funcs
operator|->
name|dpms
argument_list|(
name|crtc
argument_list|,
name|DRM_MODE_DPMS_OFF
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|off
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|assert_plane_disabled
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|,
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|plane
argument_list|)
expr_stmt|;
name|assert_pipe_disabled
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|,
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|fb
condition|)
block|{
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_unpin_fb_obj
argument_list|(
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
operator|->
name|obj
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prepare for a mode set.  *  * Note we could be a lot smarter here.  We need to figure out which outputs  * will be enabled, which disabled (in short, how the config will changes)  * and perform the minimum necessary steps to accomplish that, e.g. updating  * watermarks, FBC configuration, making sure PLLs are programmed correctly,  * panel fitting is in the proper state, etc.  */
end_comment

begin_function
specifier|static
name|void
name|i9xx_crtc_prepare
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|i9xx_crtc_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_crtc_commit
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|i9xx_crtc_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_crtc_prepare
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|ironlake_crtc_disable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_crtc_commit
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|ironlake_crtc_enable
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_encoder_prepare
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
init|=
name|encoder
operator|->
name|helper_private
decl_stmt|;
comment|/* lvds has its own version of prepare see intel_lvds_prepare */
name|encoder_funcs
operator|->
name|dpms
argument_list|(
name|encoder
argument_list|,
name|DRM_MODE_DPMS_OFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_encoder_commit
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
init|=
name|encoder
operator|->
name|helper_private
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|encoder
operator|->
name|crtc
argument_list|)
decl_stmt|;
comment|/* lvds has its own version of commit see intel_lvds_commit */
name|encoder_funcs
operator|->
name|dpms
argument_list|(
name|encoder
argument_list|,
name|DRM_MODE_DPMS_ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_cpt_verify_modeset
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_encoder_destroy
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
init|=
name|to_intel_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|drm_encoder_cleanup
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intel_encoder
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_crtc_mode_fixup
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
specifier|const
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* FDI link clock is fixed at 2.7G */
if|if
condition|(
name|mode
operator|->
name|clock
operator|*
literal|3
operator|>
name|IRONLAKE_FDI_FREQ
operator|*
literal|4
condition|)
return|return
name|false
return|;
block|}
comment|/* All interlaced capable intel hw wants timings in frames. Note though 	 * that intel_lvds_mode_fixup does some funny tricks with the crtc 	 * timings, so we need to be careful not to clobber these.*/
if|if
condition|(
operator|!
operator|(
name|adjusted_mode
operator|->
name|private_flags
operator|&
name|INTEL_MODE_CRTC_TIMINGS_SET
operator|)
condition|)
name|drm_mode_set_crtcinfo
argument_list|(
name|adjusted_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|valleyview_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|400000
return|;
comment|/* FIXME */
block|}
end_function

begin_function
specifier|static
name|int
name|i945_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|400000
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|333000
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i9xx_misc_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|200000
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915gm_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|u16
name|gcfgc
init|=
literal|0
decl_stmt|;
name|gcfgc
operator|=
name|pci_read_config
argument_list|(
name|dev
operator|->
name|device
argument_list|,
name|GCFGC
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcfgc
operator|&
name|GC_LOW_FREQUENCY_ENABLE
condition|)
return|return
literal|133000
return|;
else|else
block|{
switch|switch
condition|(
name|gcfgc
operator|&
name|GC_DISPLAY_CLOCK_MASK
condition|)
block|{
case|case
name|GC_DISPLAY_CLOCK_333_MHZ
case|:
return|return
literal|333000
return|;
default|default:
case|case
name|GC_DISPLAY_CLOCK_190_200_MHZ
case|:
return|return
literal|190000
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|i865_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|266000
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i855_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|u16
name|hpllcc
init|=
literal|0
decl_stmt|;
comment|/* Assume that the hardware is in the high speed state.  This 	 * should be the default. 	 */
switch|switch
condition|(
name|hpllcc
operator|&
name|GC_CLOCK_CONTROL_MASK
condition|)
block|{
case|case
name|GC_CLOCK_133_200
case|:
case|case
name|GC_CLOCK_100_200
case|:
return|return
literal|200000
return|;
case|case
name|GC_CLOCK_166_250
case|:
return|return
literal|250000
return|;
case|case
name|GC_CLOCK_100_133
case|:
return|return
literal|133000
return|;
block|}
comment|/* Shouldn't happen */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i830_get_display_clock_speed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|133000
return|;
block|}
end_function

begin_struct
struct|struct
name|fdi_m_n
block|{
name|u32
name|tu
decl_stmt|;
name|u32
name|gmch_m
decl_stmt|;
name|u32
name|gmch_n
decl_stmt|;
name|u32
name|link_m
decl_stmt|;
name|u32
name|link_n
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|fdi_reduce_ratio
parameter_list|(
name|u32
modifier|*
name|num
parameter_list|,
name|u32
modifier|*
name|den
parameter_list|)
block|{
while|while
condition|(
operator|*
name|num
operator|>
literal|0xffffff
operator|||
operator|*
name|den
operator|>
literal|0xffffff
condition|)
block|{
operator|*
name|num
operator|>>=
literal|1
expr_stmt|;
operator|*
name|den
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_compute_m_n
parameter_list|(
name|int
name|bits_per_pixel
parameter_list|,
name|int
name|nlanes
parameter_list|,
name|int
name|pixel_clock
parameter_list|,
name|int
name|link_clock
parameter_list|,
name|struct
name|fdi_m_n
modifier|*
name|m_n
parameter_list|)
block|{
name|m_n
operator|->
name|tu
operator|=
literal|64
expr_stmt|;
comment|/* default size */
comment|/* BUG_ON(pixel_clock> INT_MAX / 36); */
name|m_n
operator|->
name|gmch_m
operator|=
name|bits_per_pixel
operator|*
name|pixel_clock
expr_stmt|;
name|m_n
operator|->
name|gmch_n
operator|=
name|link_clock
operator|*
name|nlanes
operator|*
literal|8
expr_stmt|;
name|fdi_reduce_ratio
argument_list|(
operator|&
name|m_n
operator|->
name|gmch_m
argument_list|,
operator|&
name|m_n
operator|->
name|gmch_n
argument_list|)
expr_stmt|;
name|m_n
operator|->
name|link_m
operator|=
name|pixel_clock
expr_stmt|;
name|m_n
operator|->
name|link_n
operator|=
name|link_clock
expr_stmt|;
name|fdi_reduce_ratio
argument_list|(
operator|&
name|m_n
operator|->
name|link_m
argument_list|,
operator|&
name|m_n
operator|->
name|link_n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|intel_panel_use_ssc
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
if|if
condition|(
name|i915_panel_use_ssc
operator|>=
literal|0
condition|)
return|return
name|i915_panel_use_ssc
operator|!=
literal|0
return|;
return|return
name|dev_priv
operator|->
name|lvds_use_ssc
operator|&&
operator|!
operator|(
name|dev_priv
operator|->
name|quirks
operator|&
name|QUIRK_LVDS_SSC_DISABLE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * intel_choose_pipe_bpp_dither - figure out what color depth the pipe should send  * @crtc: CRTC structure  * @mode: requested mode  *  * A pipe may be connected to one or more outputs.  Based on the depth of the  * attached framebuffer, choose a good color depth to use on the pipe.  *  * If possible, match the pipe depth to the fb depth.  In some cases, this  * isn't ideal, because the connected output supports a lesser or restricted  * set of depths.  Resolve that here:  *    LVDS typically supports only 6bpc, so clamp down in that case  *    HDMI supports only 8bpc or 12bpc, so clamp to 8bpc with dither for 10bpc  *    Displays may support a restricted set as well, check EDID and clamp as  *      appropriate.  *    DP may want to dither down to 6bpc to fit larger modes  *  * RETURNS:  * Dithering requirement (i.e. false if display bpc and pipe bpc match,  * true if they don't match).  */
end_comment

begin_function
specifier|static
name|bool
name|intel_choose_pipe_bpp_dither
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|unsigned
name|int
modifier|*
name|pipe_bpp
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|unsigned
name|int
name|display_bpc
init|=
name|UINT_MAX
decl_stmt|,
name|bpc
decl_stmt|;
comment|/* Walk the encoders& connectors on this crtc, get min bpc */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
init|=
name|to_intel_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
if|if
condition|(
name|encoder
operator|->
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
if|if
condition|(
name|intel_encoder
operator|->
name|type
operator|==
name|INTEL_OUTPUT_LVDS
condition|)
block|{
name|unsigned
name|int
name|lvds_bpc
decl_stmt|;
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
operator|&
name|LVDS_A3_POWER_MASK
operator|)
operator|==
name|LVDS_A3_POWER_UP
condition|)
name|lvds_bpc
operator|=
literal|8
expr_stmt|;
else|else
name|lvds_bpc
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|lvds_bpc
operator|<
name|display_bpc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"clamping display bpc (was %d) to LVDS (%d)\n"
argument_list|,
name|display_bpc
argument_list|,
name|lvds_bpc
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
name|lvds_bpc
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|intel_encoder
operator|->
name|type
operator|==
name|INTEL_OUTPUT_EDP
condition|)
block|{
comment|/* Use VBT settings if we have an eDP panel */
name|unsigned
name|int
name|edp_bpc
init|=
name|dev_priv
operator|->
name|edp
operator|.
name|bpp
operator|/
literal|3
decl_stmt|;
if|if
condition|(
name|edp_bpc
operator|<
name|display_bpc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"clamping display bpc (was %d) to eDP (%d)\n"
argument_list|,
name|display_bpc
argument_list|,
name|edp_bpc
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
name|edp_bpc
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Not one of the known troublemakers, check the EDID */
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder
operator|!=
name|encoder
condition|)
continue|continue;
comment|/* Don't use an invalid EDID bpc value */
if|if
condition|(
name|connector
operator|->
name|display_info
operator|.
name|bpc
operator|&&
name|connector
operator|->
name|display_info
operator|.
name|bpc
operator|<
name|display_bpc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"clamping display bpc (was %d) to EDID reported max of %d\n"
argument_list|,
name|display_bpc
argument_list|,
name|connector
operator|->
name|display_info
operator|.
name|bpc
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
name|connector
operator|->
name|display_info
operator|.
name|bpc
expr_stmt|;
block|}
block|}
comment|/* 		 * HDMI is either 12 or 8, so if the display lets 10bpc sneak 		 * through, clamp it down.  (Note:>12bpc will be caught below.) 		 */
if|if
condition|(
name|intel_encoder
operator|->
name|type
operator|==
name|INTEL_OUTPUT_HDMI
condition|)
block|{
if|if
condition|(
name|display_bpc
operator|>
literal|8
operator|&&
name|display_bpc
operator|<
literal|12
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"forcing bpc to 12 for HDMI\n"
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
literal|12
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"forcing bpc to 8 for HDMI\n"
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
literal|8
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mode
operator|->
name|private_flags
operator|&
name|INTEL_MODE_DP_FORCE_6BPC
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Dithering DP to 6bpc\n"
argument_list|)
expr_stmt|;
name|display_bpc
operator|=
literal|6
expr_stmt|;
block|}
comment|/* 	 * We could just drive the pipe at the highest bpc all the time and 	 * enable dithering as needed, but that costs bandwidth.  So choose 	 * the minimum value that expresses the full color range of the fb but 	 * also stays within the max display bpc discovered above. 	 */
switch|switch
condition|(
name|crtc
operator|->
name|fb
operator|->
name|depth
condition|)
block|{
case|case
literal|8
case|:
name|bpc
operator|=
literal|8
expr_stmt|;
comment|/* since we go through a colormap */
break|break;
case|case
literal|15
case|:
case|case
literal|16
case|:
name|bpc
operator|=
literal|6
expr_stmt|;
comment|/* min is 18bpp */
break|break;
case|case
literal|24
case|:
name|bpc
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|30
case|:
name|bpc
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|48
case|:
name|bpc
operator|=
literal|12
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG
argument_list|(
literal|"unsupported depth, assuming 24 bits\n"
argument_list|)
expr_stmt|;
name|bpc
operator|=
name|min
argument_list|(
operator|(
name|unsigned
name|int
operator|)
literal|8
argument_list|,
name|display_bpc
argument_list|)
expr_stmt|;
break|break;
block|}
name|display_bpc
operator|=
name|min
argument_list|(
name|display_bpc
argument_list|,
name|bpc
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"setting pipe bpc to %d (max display bpc %d)\n"
argument_list|,
name|bpc
argument_list|,
name|display_bpc
argument_list|)
expr_stmt|;
operator|*
name|pipe_bpp
operator|=
name|display_bpc
operator|*
literal|3
expr_stmt|;
return|return
name|display_bpc
operator|!=
name|bpc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i9xx_get_refclk
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|num_connectors
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|refclk
decl_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|&&
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|num_connectors
operator|<
literal|2
condition|)
block|{
name|refclk
operator|=
name|dev_priv
operator|->
name|lvds_ssc_freq
operator|*
literal|1000
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"using SSC reference clock of %d MHz\n"
argument_list|,
name|refclk
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|refclk
operator|=
literal|96000
expr_stmt|;
block|}
else|else
block|{
name|refclk
operator|=
literal|48000
expr_stmt|;
block|}
return|return
name|refclk
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_adjust_sdvo_tv_clock
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|)
block|{
comment|/* SDVO TV has fixed PLL values depend on its clock range, 	   this mirrors vbios setting. */
if|if
condition|(
name|adjusted_mode
operator|->
name|clock
operator|>=
literal|100000
operator|&&
name|adjusted_mode
operator|->
name|clock
operator|<
literal|140500
condition|)
block|{
name|clock
operator|->
name|p1
operator|=
literal|2
expr_stmt|;
name|clock
operator|->
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|->
name|n
operator|=
literal|3
expr_stmt|;
name|clock
operator|->
name|m1
operator|=
literal|16
expr_stmt|;
name|clock
operator|->
name|m2
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adjusted_mode
operator|->
name|clock
operator|>=
literal|140500
operator|&&
name|adjusted_mode
operator|->
name|clock
operator|<=
literal|200000
condition|)
block|{
name|clock
operator|->
name|p1
operator|=
literal|1
expr_stmt|;
name|clock
operator|->
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|->
name|n
operator|=
literal|6
expr_stmt|;
name|clock
operator|->
name|m1
operator|=
literal|12
expr_stmt|;
name|clock
operator|->
name|m2
operator|=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_update_pll_dividers
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|,
name|intel_clock_t
modifier|*
name|reduced_clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|fp
decl_stmt|,
name|fp2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|fp
operator|=
operator|(
literal|1
operator|<<
name|clock
operator|->
name|n
operator|)
operator|<<
literal|16
operator||
name|clock
operator|->
name|m1
operator|<<
literal|8
operator||
name|clock
operator|->
name|m2
expr_stmt|;
if|if
condition|(
name|reduced_clock
condition|)
name|fp2
operator|=
operator|(
literal|1
operator|<<
name|reduced_clock
operator|->
name|n
operator|)
operator|<<
literal|16
operator||
name|reduced_clock
operator|->
name|m1
operator|<<
literal|8
operator||
name|reduced_clock
operator|->
name|m2
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|clock
operator|->
name|n
operator|<<
literal|16
operator||
name|clock
operator|->
name|m1
operator|<<
literal|8
operator||
name|clock
operator|->
name|m2
expr_stmt|;
if|if
condition|(
name|reduced_clock
condition|)
name|fp2
operator|=
name|reduced_clock
operator|->
name|n
operator|<<
literal|16
operator||
name|reduced_clock
operator|->
name|m1
operator|<<
literal|8
operator||
name|reduced_clock
operator|->
name|m2
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|FP0
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|lowfreq_avail
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|&&
name|reduced_clock
operator|&&
name|i915_powersave
condition|)
block|{
name|I915_WRITE
argument_list|(
name|FP1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|fp2
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|lowfreq_avail
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|I915_WRITE
argument_list|(
name|FP1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_update_lvds
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|LVDS
argument_list|)
expr_stmt|;
name|temp
operator||=
name|LVDS_PORT_EN
operator||
name|LVDS_A0A2_CLKA_POWER_UP
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
literal|1
condition|)
block|{
name|temp
operator||=
name|LVDS_PIPEB_SELECT
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|LVDS_PIPEB_SELECT
expr_stmt|;
block|}
comment|/* set the corresponsding LVDS_BORDER bit */
name|temp
operator||=
name|dev_priv
operator|->
name|lvds_border_bits
expr_stmt|;
comment|/* Set the B0-B3 data pairs corresponding to whether we're going to 	 * set the DPLLs for dual-channel mode or not. 	 */
if|if
condition|(
name|clock
operator|->
name|p2
operator|==
literal|7
condition|)
name|temp
operator||=
name|LVDS_B0B3_POWER_UP
operator||
name|LVDS_CLKB_POWER_UP
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
operator|(
name|LVDS_B0B3_POWER_UP
operator||
name|LVDS_CLKB_POWER_UP
operator|)
expr_stmt|;
comment|/* It would be nice to set 24 vs 18-bit mode (LVDS_A3_POWER_UP) 	 * appropriately here, but we need to look more thoroughly into how 	 * panels behave in the two modes. 	 */
comment|/* set the dithering flag on LVDS as needed */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|lvds_dither
condition|)
name|temp
operator||=
name|LVDS_ENABLE_DITHER
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
name|LVDS_ENABLE_DITHER
expr_stmt|;
block|}
name|temp
operator|&=
operator|~
operator|(
name|LVDS_HSYNC_POLARITY
operator||
name|LVDS_VSYNC_POLARITY
operator|)
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NHSYNC
condition|)
name|temp
operator||=
name|LVDS_HSYNC_POLARITY
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NVSYNC
condition|)
name|temp
operator||=
name|LVDS_VSYNC_POLARITY
expr_stmt|;
name|I915_WRITE
argument_list|(
name|LVDS
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_update_pll
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|,
name|intel_clock_t
modifier|*
name|reduced_clock
parameter_list|,
name|int
name|num_connectors
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|dpll
decl_stmt|;
name|bool
name|is_sdvo
decl_stmt|;
name|is_sdvo
operator|=
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_SDVO
argument_list|)
operator|||
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_HDMI
argument_list|)
expr_stmt|;
name|dpll
operator|=
name|DPLL_VGA_MODE_DIS
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|dpll
operator||=
name|DPLLB_MODE_LVDS
expr_stmt|;
else|else
name|dpll
operator||=
name|DPLLB_MODE_DAC_SERIAL
expr_stmt|;
if|if
condition|(
name|is_sdvo
condition|)
block|{
name|int
name|pixel_multiplier
init|=
name|intel_mode_get_pixel_multiplier
argument_list|(
name|adjusted_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|pixel_multiplier
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_G33
argument_list|(
name|dev
argument_list|)
condition|)
name|dpll
operator||=
operator|(
name|pixel_multiplier
operator|-
literal|1
operator|)
operator|<<
name|SDVO_MULTIPLIER_SHIFT_HIRES
expr_stmt|;
block|}
name|dpll
operator||=
name|DPLL_DVO_HIGH_SPEED
expr_stmt|;
block|}
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
condition|)
name|dpll
operator||=
name|DPLL_DVO_HIGH_SPEED
expr_stmt|;
comment|/* compute bitmask from p1 value */
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|->
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT_PINEVIEW
expr_stmt|;
else|else
block|{
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|->
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT
expr_stmt|;
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
operator|&&
name|reduced_clock
condition|)
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|reduced_clock
operator|->
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA1_P1_POST_DIV_SHIFT
expr_stmt|;
block|}
switch|switch
condition|(
name|clock
operator|->
name|p2
condition|)
block|{
case|case
literal|5
case|:
name|dpll
operator||=
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_5
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|dpll
operator||=
name|DPLLB_LVDS_P2_CLOCK_DIV_7
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|dpll
operator||=
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_10
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|dpll
operator||=
name|DPLLB_LVDS_P2_CLOCK_DIV_14
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
name|dpll
operator||=
operator|(
literal|6
operator|<<
name|PLL_LOAD_PULSE_PHASE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|is_sdvo
operator|&&
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_TVOUT
argument_list|)
condition|)
name|dpll
operator||=
name|PLL_REF_INPUT_TVCLKINBC
expr_stmt|;
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_TVOUT
argument_list|)
condition|)
comment|/* XXX: just matching BIOS for now */
comment|/*	dpll |= PLL_REF_INPUT_TVCLKINBC; */
name|dpll
operator||=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|&&
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|num_connectors
operator|<
literal|2
condition|)
name|dpll
operator||=
name|PLLB_REF_INPUT_SPREADSPECTRUMIN
expr_stmt|;
else|else
name|dpll
operator||=
name|PLL_REF_INPUT_DREFCLK
expr_stmt|;
name|dpll
operator||=
name|DPLL_VCO_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
operator|&
operator|~
name|DPLL_VCO_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* The LVDS pin pair needs to be on before the DPLLs are enabled. 	 * This is an exception to the general rule that mode_set doesn't turn 	 * things on. 	 */
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|intel_update_lvds
argument_list|(
name|crtc
argument_list|,
name|clock
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
condition|)
name|intel_dp_set_m_n
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to stabilize. */
name|POSTING_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|u32
name|temp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|is_sdvo
condition|)
block|{
name|temp
operator|=
name|intel_mode_get_pixel_multiplier
argument_list|(
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|1
condition|)
name|temp
operator|=
operator|(
name|temp
operator|-
literal|1
operator|)
operator|<<
name|DPLL_MD_UDI_MULTIPLIER_SHIFT
expr_stmt|;
else|else
name|temp
operator|=
literal|0
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|DPLL_MD
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The pixel multiplier can only be updated once the 		 * DPLL is enabled and the clocks are stable. 		 * 		 * So write it again. 		 */
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i8xx_update_pll
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|intel_clock_t
modifier|*
name|clock
parameter_list|,
name|int
name|num_connectors
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|dpll
decl_stmt|;
name|dpll
operator|=
name|DPLL_VGA_MODE_DIS
expr_stmt|;
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
block|{
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|->
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|clock
operator|->
name|p1
operator|==
literal|2
condition|)
name|dpll
operator||=
name|PLL_P1_DIVIDE_BY_TWO
expr_stmt|;
else|else
name|dpll
operator||=
operator|(
name|clock
operator|->
name|p1
operator|-
literal|2
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|p2
operator|==
literal|4
condition|)
name|dpll
operator||=
name|PLL_P2_DIVIDE_BY_4
expr_stmt|;
block|}
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_TVOUT
argument_list|)
condition|)
comment|/* XXX: just matching BIOS for now */
comment|/*	dpll |= PLL_REF_INPUT_TVCLKINBC; */
name|dpll
operator||=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
operator|&&
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|num_connectors
operator|<
literal|2
condition|)
name|dpll
operator||=
name|PLLB_REF_INPUT_SPREADSPECTRUMIN
expr_stmt|;
else|else
name|dpll
operator||=
name|PLL_REF_INPUT_DREFCLK
expr_stmt|;
name|dpll
operator||=
name|DPLL_VCO_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
operator|&
operator|~
name|DPLL_VCO_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to stabilize. */
name|POSTING_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* The LVDS pin pair needs to be on before the DPLLs are enabled. 	 * This is an exception to the general rule that mode_set doesn't turn 	 * things on. 	 */
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_LVDS
argument_list|)
condition|)
name|intel_update_lvds
argument_list|(
name|crtc
argument_list|,
name|clock
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
comment|/* The pixel multiplier can only be updated once the 	 * DPLL is enabled and the clocks are stable. 	 * 	 * So write it again. 	 */
name|I915_WRITE
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i9xx_crtc_mode_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|int
name|refclk
decl_stmt|,
name|num_connectors
init|=
literal|0
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|,
name|reduced_clock
decl_stmt|;
name|u32
name|dspcntr
decl_stmt|,
name|pipeconf
decl_stmt|,
name|vsyncshift
decl_stmt|;
name|bool
name|ok
decl_stmt|,
name|has_reduced_clock
init|=
name|false
decl_stmt|,
name|is_sdvo
init|=
name|false
decl_stmt|;
name|bool
name|is_lvds
init|=
name|false
decl_stmt|,
name|is_tv
init|=
name|false
decl_stmt|,
name|is_dp
init|=
name|false
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|is_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_SDVO
case|:
case|case
name|INTEL_OUTPUT_HDMI
case|:
name|is_sdvo
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|encoder
operator|->
name|needs_tv_clock
condition|)
name|is_tv
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_TVOUT
case|:
name|is_tv
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_DISPLAYPORT
case|:
name|is_dp
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|num_connectors
operator|++
expr_stmt|;
block|}
name|refclk
operator|=
name|i9xx_get_refclk
argument_list|(
name|crtc
argument_list|,
name|num_connectors
argument_list|)
expr_stmt|;
comment|/* 	 * Returns a set of divisors for the desired target clock with the given 	 * refclk, or false.  The returned values represent the clock equation: 	 * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2. 	 */
name|limit
operator|=
name|intel_limit
argument_list|(
name|crtc
argument_list|,
name|refclk
argument_list|)
expr_stmt|;
name|ok
operator|=
name|limit
operator|->
name|find_pll
argument_list|(
name|limit
argument_list|,
name|crtc
argument_list|,
name|adjusted_mode
operator|->
name|clock
argument_list|,
name|refclk
argument_list|,
name|NULL
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Couldn't find PLL settings for mode!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Ensure that the cursor is valid for the new mode before changing... */
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_lvds
operator|&&
name|dev_priv
operator|->
name|lvds_downclock_avail
condition|)
block|{
comment|/* 		 * Ensure we match the reduced clock's P to the target clock. 		 * If the clocks don't match, we can't switch the display clock 		 * by using the FP0/FP1. In such case we will disable the LVDS 		 * downclock feature. 		*/
name|has_reduced_clock
operator|=
name|limit
operator|->
name|find_pll
argument_list|(
name|limit
argument_list|,
name|crtc
argument_list|,
name|dev_priv
operator|->
name|lvds_downclock
argument_list|,
name|refclk
argument_list|,
operator|&
name|clock
argument_list|,
operator|&
name|reduced_clock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_sdvo
operator|&&
name|is_tv
condition|)
name|i9xx_adjust_sdvo_tv_clock
argument_list|(
name|adjusted_mode
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
name|i9xx_update_pll_dividers
argument_list|(
name|crtc
argument_list|,
operator|&
name|clock
argument_list|,
name|has_reduced_clock
condition|?
operator|&
name|reduced_clock
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|i8xx_update_pll
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
argument_list|,
operator|&
name|clock
argument_list|,
name|num_connectors
argument_list|)
expr_stmt|;
else|else
name|i9xx_update_pll
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|,
operator|&
name|clock
argument_list|,
name|has_reduced_clock
condition|?
operator|&
name|reduced_clock
else|:
name|NULL
argument_list|,
name|num_connectors
argument_list|)
expr_stmt|;
comment|/* setup pipeconf */
name|pipeconf
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the display plane register */
name|dspcntr
operator|=
name|DISPPLANE_GAMMA_ENABLE
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
literal|0
condition|)
name|dspcntr
operator|&=
operator|~
name|DISPPLANE_SEL_PIPE_MASK
expr_stmt|;
else|else
name|dspcntr
operator||=
name|DISPPLANE_SEL_PIPE_B
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
literal|0
operator|&&
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
condition|)
block|{
comment|/* Enable pixel doubling when the dot clock is> 90% of the (display) 		 * core speed. 		 * 		 * XXX: No double-wide on 915GM pipe B. Is that the only reason for the 		 * pipe == 0 check? 		 */
if|if
condition|(
name|mode
operator|->
name|clock
operator|>
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
argument_list|(
name|dev
argument_list|)
operator|*
literal|9
operator|/
literal|10
condition|)
name|pipeconf
operator||=
name|PIPECONF_DOUBLE_WIDE
expr_stmt|;
else|else
name|pipeconf
operator|&=
operator|~
name|PIPECONF_DOUBLE_WIDE
expr_stmt|;
block|}
comment|/* default to 8bpc */
name|pipeconf
operator|&=
operator|~
operator|(
name|PIPECONF_BPP_MASK
operator||
name|PIPECONF_DITHER_EN
operator|)
expr_stmt|;
if|if
condition|(
name|is_dp
condition|)
block|{
if|if
condition|(
name|mode
operator|->
name|private_flags
operator|&
name|INTEL_MODE_DP_FORCE_6BPC
condition|)
block|{
name|pipeconf
operator||=
name|PIPECONF_BPP_6
operator||
name|PIPECONF_DITHER_EN
operator||
name|PIPECONF_DITHER_TYPE_SP
expr_stmt|;
block|}
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"Mode for pipe %c:\n"
argument_list|,
name|pipe
operator|==
literal|0
condition|?
literal|'A'
else|:
literal|'B'
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PIPE_CXSR
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|intel_crtc
operator|->
name|lowfreq_avail
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"enabling CxSR downclocking\n"
argument_list|)
expr_stmt|;
name|pipeconf
operator||=
name|PIPECONF_CXSR_DOWNCLOCK
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabling CxSR downclocking\n"
argument_list|)
expr_stmt|;
name|pipeconf
operator|&=
operator|~
name|PIPECONF_CXSR_DOWNCLOCK
expr_stmt|;
block|}
block|}
name|pipeconf
operator|&=
operator|~
name|PIPECONF_INTERLACE_MASK
expr_stmt|;
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
operator|&&
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
condition|)
block|{
name|pipeconf
operator||=
name|PIPECONF_INTERLACE_W_FIELD_INDICATION
expr_stmt|;
comment|/* the chip adds 2 halflines automatically */
name|adjusted_mode
operator|->
name|crtc_vtotal
operator|-=
literal|1
expr_stmt|;
name|adjusted_mode
operator|->
name|crtc_vblank_end
operator|-=
literal|1
expr_stmt|;
name|vsyncshift
operator|=
name|adjusted_mode
operator|->
name|crtc_hsync_start
operator|-
name|adjusted_mode
operator|->
name|crtc_htotal
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|pipeconf
operator||=
name|PIPECONF_PROGRESSIVE
expr_stmt|;
name|vsyncshift
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_GEN3
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|VSYNCSHIFT
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|vsyncshift
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hdisplay
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_htotal
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hblank_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_hblank_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hsync_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_hsync_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vdisplay
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vtotal
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vblank_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vblank_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vsync_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vsync_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* pipesrc and dspsize control the size that is scaled from, 	 * which should always be the user's requested size. 	 */
name|I915_WRITE
argument_list|(
name|DSPSIZE
argument_list|(
name|plane
argument_list|)
argument_list|,
operator|(
operator|(
name|mode
operator|->
name|vdisplay
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|mode
operator|->
name|hdisplay
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPPOS
argument_list|(
name|plane
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPESRC
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
operator|(
name|mode
operator|->
name|hdisplay
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|mode
operator|->
name|vdisplay
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|pipeconf
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|intel_enable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|dspcntr
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_pipe_set_base
argument_list|(
name|crtc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|old_fb
argument_list|)
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize reference clocks when the driver loads  */
end_comment

begin_function
name|void
name|ironlake_init_pch_refclk
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|bool
name|has_lvds
init|=
name|false
decl_stmt|;
name|bool
name|has_cpu_edp
init|=
name|false
decl_stmt|;
name|bool
name|has_pch_edp
init|=
name|false
decl_stmt|;
name|bool
name|has_panel
init|=
name|false
decl_stmt|;
name|bool
name|has_ck505
init|=
name|false
decl_stmt|;
name|bool
name|can_ssc
init|=
name|false
decl_stmt|;
comment|/* We need to take the global config into account */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|has_panel
operator|=
name|true
expr_stmt|;
name|has_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_EDP
case|:
name|has_panel
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|)
condition|)
name|has_pch_edp
operator|=
name|true
expr_stmt|;
else|else
name|has_cpu_edp
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|has_ck505
operator|=
name|dev_priv
operator|->
name|display_clock_mode
expr_stmt|;
name|can_ssc
operator|=
name|has_ck505
expr_stmt|;
block|}
else|else
block|{
name|has_ck505
operator|=
name|false
expr_stmt|;
name|can_ssc
operator|=
name|true
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"has_panel %d has_lvds %d has_pch_edp %d has_cpu_edp %d has_ck505 %d\n"
argument_list|,
name|has_panel
argument_list|,
name|has_lvds
argument_list|,
name|has_pch_edp
argument_list|,
name|has_cpu_edp
argument_list|,
name|has_ck505
argument_list|)
expr_stmt|;
comment|/* Ironlake: try to setup display ref clock before DPLL 	 * enabling. This is only under driver's control after 	 * PCH B stepping, previous chipset stepping should be 	 * ignoring this setting. 	 */
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
comment|/* Always enable nonspread source */
name|temp
operator|&=
operator|~
name|DREF_NONSPREAD_SOURCE_MASK
expr_stmt|;
if|if
condition|(
name|has_ck505
condition|)
name|temp
operator||=
name|DREF_NONSPREAD_CK505_ENABLE
expr_stmt|;
else|else
name|temp
operator||=
name|DREF_NONSPREAD_SOURCE_ENABLE
expr_stmt|;
if|if
condition|(
name|has_panel
condition|)
block|{
name|temp
operator|&=
operator|~
name|DREF_SSC_SOURCE_MASK
expr_stmt|;
name|temp
operator||=
name|DREF_SSC_SOURCE_ENABLE
expr_stmt|;
comment|/* SSC must be turned on before enabling the CPU output  */
if|if
condition|(
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|can_ssc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Using SSC on panel\n"
argument_list|)
expr_stmt|;
name|temp
operator||=
name|DREF_SSC1_ENABLE
expr_stmt|;
block|}
else|else
name|temp
operator|&=
operator|~
name|DREF_SSC1_ENABLE
expr_stmt|;
comment|/* Get SSC going before enabling the outputs */
name|I915_WRITE
argument_list|(
name|PCH_DREF_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|DREF_CPU_SOURCE_OUTPUT_MASK
expr_stmt|;
comment|/* Enable CPU source on CPU attached eDP */
if|if
condition|(
name|has_cpu_edp
condition|)
block|{
if|if
condition|(
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|can_ssc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Using SSC on eDP\n"
argument_list|)
expr_stmt|;
name|temp
operator||=
name|DREF_CPU_SOURCE_OUTPUT_DOWNSPREAD
expr_stmt|;
block|}
else|else
name|temp
operator||=
name|DREF_CPU_SOURCE_OUTPUT_NONSPREAD
expr_stmt|;
block|}
else|else
name|temp
operator||=
name|DREF_CPU_SOURCE_OUTPUT_DISABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DREF_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Disabling SSC entirely\n"
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|DREF_CPU_SOURCE_OUTPUT_MASK
expr_stmt|;
comment|/* Turn off CPU output */
name|temp
operator||=
name|DREF_CPU_SOURCE_OUTPUT_DISABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DREF_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Turn off the SSC source */
name|temp
operator|&=
operator|~
name|DREF_SSC_SOURCE_MASK
expr_stmt|;
name|temp
operator||=
name|DREF_SSC_SOURCE_DISABLE
expr_stmt|;
comment|/* Turn off SSC1 */
name|temp
operator|&=
operator|~
name|DREF_SSC1_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_DREF_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_DREF_CONTROL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ironlake_get_refclk
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|edp_encoder
init|=
name|NULL
decl_stmt|;
name|int
name|num_connectors
init|=
literal|0
decl_stmt|;
name|bool
name|is_lvds
init|=
name|false
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|is_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_EDP
case|:
name|edp_encoder
operator|=
name|encoder
expr_stmt|;
break|break;
block|}
name|num_connectors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|is_lvds
operator|&&
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|num_connectors
operator|<
literal|2
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"using SSC reference clock of %d MHz\n"
argument_list|,
name|dev_priv
operator|->
name|lvds_ssc_freq
argument_list|)
expr_stmt|;
return|return
name|dev_priv
operator|->
name|lvds_ssc_freq
operator|*
literal|1000
return|;
block|}
return|return
literal|120000
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ironlake_crtc_mode_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
decl_stmt|;
name|int
name|refclk
decl_stmt|,
name|num_connectors
init|=
literal|0
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|,
name|reduced_clock
decl_stmt|;
name|u32
name|dpll
decl_stmt|,
name|fp
init|=
literal|0
decl_stmt|,
name|fp2
init|=
literal|0
decl_stmt|,
name|dspcntr
decl_stmt|,
name|pipeconf
decl_stmt|;
name|bool
name|ok
decl_stmt|,
name|has_reduced_clock
init|=
name|false
decl_stmt|,
name|is_sdvo
init|=
name|false
decl_stmt|;
name|bool
name|is_crt
init|=
name|false
decl_stmt|,
name|is_lvds
init|=
name|false
decl_stmt|,
name|is_tv
init|=
name|false
decl_stmt|,
name|is_dp
init|=
name|false
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|,
modifier|*
name|edp_encoder
init|=
name|NULL
decl_stmt|;
specifier|const
name|intel_limit_t
modifier|*
name|limit
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|fdi_m_n
name|m_n
init|=
block|{
literal|0
block|}
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|int
name|target_clock
decl_stmt|,
name|pixel_multiplier
decl_stmt|,
name|lane
decl_stmt|,
name|link_bw
decl_stmt|,
name|factor
decl_stmt|;
name|unsigned
name|int
name|pipe_bpp
decl_stmt|;
name|bool
name|dither
decl_stmt|;
name|bool
name|is_cpu_edp
init|=
name|false
decl_stmt|,
name|is_pch_edp
init|=
name|false
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|base
operator|.
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
switch|switch
condition|(
name|encoder
operator|->
name|type
condition|)
block|{
case|case
name|INTEL_OUTPUT_LVDS
case|:
name|is_lvds
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_SDVO
case|:
case|case
name|INTEL_OUTPUT_HDMI
case|:
name|is_sdvo
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|encoder
operator|->
name|needs_tv_clock
condition|)
name|is_tv
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_TVOUT
case|:
name|is_tv
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_ANALOG
case|:
name|is_crt
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_DISPLAYPORT
case|:
name|is_dp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INTEL_OUTPUT_EDP
case|:
name|is_dp
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|intel_encoder_is_pch_edp
argument_list|(
operator|&
name|encoder
operator|->
name|base
argument_list|)
condition|)
name|is_pch_edp
operator|=
name|true
expr_stmt|;
else|else
name|is_cpu_edp
operator|=
name|true
expr_stmt|;
name|edp_encoder
operator|=
name|encoder
expr_stmt|;
break|break;
block|}
name|num_connectors
operator|++
expr_stmt|;
block|}
name|refclk
operator|=
name|ironlake_get_refclk
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* 	 * Returns a set of divisors for the desired target clock with the given 	 * refclk, or false.  The returned values represent the clock equation: 	 * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2. 	 */
name|limit
operator|=
name|intel_limit
argument_list|(
name|crtc
argument_list|,
name|refclk
argument_list|)
expr_stmt|;
name|ok
operator|=
name|limit
operator|->
name|find_pll
argument_list|(
name|limit
argument_list|,
name|crtc
argument_list|,
name|adjusted_mode
operator|->
name|clock
argument_list|,
name|refclk
argument_list|,
name|NULL
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Couldn't find PLL settings for mode!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Ensure that the cursor is valid for the new mode before changing... */
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_lvds
operator|&&
name|dev_priv
operator|->
name|lvds_downclock_avail
condition|)
block|{
comment|/* 		 * Ensure we match the reduced clock's P to the target clock. 		 * If the clocks don't match, we can't switch the display clock 		 * by using the FP0/FP1. In such case we will disable the LVDS 		 * downclock feature. 		*/
name|has_reduced_clock
operator|=
name|limit
operator|->
name|find_pll
argument_list|(
name|limit
argument_list|,
name|crtc
argument_list|,
name|dev_priv
operator|->
name|lvds_downclock
argument_list|,
name|refclk
argument_list|,
operator|&
name|clock
argument_list|,
operator|&
name|reduced_clock
argument_list|)
expr_stmt|;
block|}
comment|/* SDVO TV has fixed PLL values depend on its clock range, 	   this mirrors vbios setting. */
if|if
condition|(
name|is_sdvo
operator|&&
name|is_tv
condition|)
block|{
if|if
condition|(
name|adjusted_mode
operator|->
name|clock
operator|>=
literal|100000
operator|&&
name|adjusted_mode
operator|->
name|clock
operator|<
literal|140500
condition|)
block|{
name|clock
operator|.
name|p1
operator|=
literal|2
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|n
operator|=
literal|3
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|16
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adjusted_mode
operator|->
name|clock
operator|>=
literal|140500
operator|&&
name|adjusted_mode
operator|->
name|clock
operator|<=
literal|200000
condition|)
block|{
name|clock
operator|.
name|p1
operator|=
literal|1
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|10
expr_stmt|;
name|clock
operator|.
name|n
operator|=
literal|6
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
literal|12
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
literal|8
expr_stmt|;
block|}
block|}
comment|/* FDI link */
name|pixel_multiplier
operator|=
name|intel_mode_get_pixel_multiplier
argument_list|(
name|adjusted_mode
argument_list|)
expr_stmt|;
name|lane
operator|=
literal|0
expr_stmt|;
comment|/* CPU eDP doesn't require FDI link, so just set DP M/N 	   according to current link config */
if|if
condition|(
name|is_cpu_edp
condition|)
block|{
name|target_clock
operator|=
name|mode
operator|->
name|clock
expr_stmt|;
name|intel_edp_link_config
argument_list|(
name|edp_encoder
argument_list|,
operator|&
name|lane
argument_list|,
operator|&
name|link_bw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* [e]DP over FDI requires target mode clock 		   instead of link clock */
if|if
condition|(
name|is_dp
condition|)
name|target_clock
operator|=
name|mode
operator|->
name|clock
expr_stmt|;
else|else
name|target_clock
operator|=
name|adjusted_mode
operator|->
name|clock
expr_stmt|;
comment|/* FDI is a binary signal running at ~2.7GHz, encoding 		 * each output octet as 10 bits. The actual frequency 		 * is stored as a divider into a 100MHz clock, and the 		 * mode pixel clock is stored in units of 1KHz. 		 * Hence the bw of each lane in terms of the mode signal 		 * is: 		 */
name|link_bw
operator|=
name|intel_fdi_link_freq
argument_list|(
name|dev
argument_list|)
operator|*
name|MHz
argument_list|(
literal|100
argument_list|)
operator|/
name|KHz
argument_list|(
literal|1
argument_list|)
operator|/
literal|10
expr_stmt|;
block|}
comment|/* determine panel color depth */
name|temp
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|PIPE_BPC_MASK
expr_stmt|;
name|dither
operator|=
name|intel_choose_pipe_bpp_dither
argument_list|(
name|crtc
argument_list|,
operator|&
name|pipe_bpp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pipe_bpp
condition|)
block|{
case|case
literal|18
case|:
name|temp
operator||=
name|PIPE_6BPC
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|temp
operator||=
name|PIPE_8BPC
expr_stmt|;
break|break;
case|case
literal|30
case|:
name|temp
operator||=
name|PIPE_10BPC
expr_stmt|;
break|break;
case|case
literal|36
case|:
name|temp
operator||=
name|PIPE_12BPC
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"intel_choose_pipe_bpp returned invalid value %d\n"
argument_list|,
name|pipe_bpp
argument_list|)
expr_stmt|;
name|temp
operator||=
name|PIPE_8BPC
expr_stmt|;
name|pipe_bpp
operator|=
literal|24
expr_stmt|;
break|break;
block|}
name|intel_crtc
operator|->
name|bpp
operator|=
name|pipe_bpp
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lane
condition|)
block|{
comment|/* 		 * Account for spread spectrum to avoid 		 * oversubscribing the link. Max center spread 		 * is 2.5%; use 5% for safety's sake. 		 */
name|u32
name|bps
init|=
name|target_clock
operator|*
name|intel_crtc
operator|->
name|bpp
operator|*
literal|21
operator|/
literal|20
decl_stmt|;
name|lane
operator|=
name|bps
operator|/
operator|(
name|link_bw
operator|*
literal|8
operator|)
operator|+
literal|1
expr_stmt|;
block|}
name|intel_crtc
operator|->
name|fdi_lanes
operator|=
name|lane
expr_stmt|;
if|if
condition|(
name|pixel_multiplier
operator|>
literal|1
condition|)
name|link_bw
operator|*=
name|pixel_multiplier
expr_stmt|;
name|ironlake_compute_m_n
argument_list|(
name|intel_crtc
operator|->
name|bpp
argument_list|,
name|lane
argument_list|,
name|target_clock
argument_list|,
name|link_bw
argument_list|,
operator|&
name|m_n
argument_list|)
expr_stmt|;
name|fp
operator|=
name|clock
operator|.
name|n
operator|<<
literal|16
operator||
name|clock
operator|.
name|m1
operator|<<
literal|8
operator||
name|clock
operator|.
name|m2
expr_stmt|;
if|if
condition|(
name|has_reduced_clock
condition|)
name|fp2
operator|=
name|reduced_clock
operator|.
name|n
operator|<<
literal|16
operator||
name|reduced_clock
operator|.
name|m1
operator|<<
literal|8
operator||
name|reduced_clock
operator|.
name|m2
expr_stmt|;
comment|/* Enable autotuning of the PLL clock (if permissible) */
name|factor
operator|=
literal|21
expr_stmt|;
if|if
condition|(
name|is_lvds
condition|)
block|{
if|if
condition|(
operator|(
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|dev_priv
operator|->
name|lvds_ssc_freq
operator|==
literal|100
operator|)
operator|||
operator|(
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
operator|&
name|LVDS_CLKB_POWER_MASK
operator|)
operator|==
name|LVDS_CLKB_POWER_UP
condition|)
name|factor
operator|=
literal|25
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_sdvo
operator|&&
name|is_tv
condition|)
name|factor
operator|=
literal|20
expr_stmt|;
if|if
condition|(
name|clock
operator|.
name|m
operator|<
name|factor
operator|*
name|clock
operator|.
name|n
condition|)
name|fp
operator||=
name|FP_CB_TUNE
expr_stmt|;
name|dpll
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_lvds
condition|)
name|dpll
operator||=
name|DPLLB_MODE_LVDS
expr_stmt|;
else|else
name|dpll
operator||=
name|DPLLB_MODE_DAC_SERIAL
expr_stmt|;
if|if
condition|(
name|is_sdvo
condition|)
block|{
name|int
name|pixel_multiplier
init|=
name|intel_mode_get_pixel_multiplier
argument_list|(
name|adjusted_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|pixel_multiplier
operator|>
literal|1
condition|)
block|{
name|dpll
operator||=
operator|(
name|pixel_multiplier
operator|-
literal|1
operator|)
operator|<<
name|PLL_REF_SDVO_HDMI_MULTIPLIER_SHIFT
expr_stmt|;
block|}
name|dpll
operator||=
name|DPLL_DVO_HIGH_SPEED
expr_stmt|;
block|}
if|if
condition|(
name|is_dp
operator|&&
operator|!
name|is_cpu_edp
condition|)
name|dpll
operator||=
name|DPLL_DVO_HIGH_SPEED
expr_stmt|;
comment|/* compute bitmask from p1 value */
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|.
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA01_P1_POST_DIV_SHIFT
expr_stmt|;
comment|/* also FPA1 */
name|dpll
operator||=
operator|(
literal|1
operator|<<
operator|(
name|clock
operator|.
name|p1
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DPLL_FPA1_P1_POST_DIV_SHIFT
expr_stmt|;
switch|switch
condition|(
name|clock
operator|.
name|p2
condition|)
block|{
case|case
literal|5
case|:
name|dpll
operator||=
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_5
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|dpll
operator||=
name|DPLLB_LVDS_P2_CLOCK_DIV_7
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|dpll
operator||=
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_10
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|dpll
operator||=
name|DPLLB_LVDS_P2_CLOCK_DIV_14
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_sdvo
operator|&&
name|is_tv
condition|)
name|dpll
operator||=
name|PLL_REF_INPUT_TVCLKINBC
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tv
condition|)
comment|/* XXX: just matching BIOS for now */
comment|/*	dpll |= PLL_REF_INPUT_TVCLKINBC; */
name|dpll
operator||=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|is_lvds
operator|&&
name|intel_panel_use_ssc
argument_list|(
name|dev_priv
argument_list|)
operator|&&
name|num_connectors
operator|<
literal|2
condition|)
name|dpll
operator||=
name|PLLB_REF_INPUT_SPREADSPECTRUMIN
expr_stmt|;
else|else
name|dpll
operator||=
name|PLL_REF_INPUT_DREFCLK
expr_stmt|;
comment|/* setup pipeconf */
name|pipeconf
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the display plane register */
name|dspcntr
operator|=
name|DISPPLANE_GAMMA_ENABLE
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Mode for pipe %d:\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* CPU eDP is the only output that doesn't need a PCH PLL of its own on 	 * pre-Haswell/LPT generation */
if|if
condition|(
name|HAS_PCH_LPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"LPT detected: no PLL for pipe %d necessary\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_cpu_edp
condition|)
block|{
name|struct
name|intel_pch_pll
modifier|*
name|pll
decl_stmt|;
name|pll
operator|=
name|intel_get_pch_pll
argument_list|(
name|intel_crtc
argument_list|,
name|dpll
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"failed to find PLL for pipe %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
else|else
name|intel_put_pch_pll
argument_list|(
name|intel_crtc
argument_list|)
expr_stmt|;
comment|/* The LVDS pin pair needs to be on before the DPLLs are enabled. 	 * This is an exception to the general rule that mode_set doesn't turn 	 * things on. 	 */
if|if
condition|(
name|is_lvds
condition|)
block|{
name|temp
operator|=
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
expr_stmt|;
name|temp
operator||=
name|LVDS_PORT_EN
operator||
name|LVDS_A0A2_CLKA_POWER_UP
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|temp
operator|&=
operator|~
name|PORT_TRANS_SEL_MASK
expr_stmt|;
name|temp
operator||=
name|PORT_TRANS_SEL_CPT
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pipe
operator|==
literal|1
condition|)
name|temp
operator||=
name|LVDS_PIPEB_SELECT
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
name|LVDS_PIPEB_SELECT
expr_stmt|;
block|}
comment|/* set the corresponsding LVDS_BORDER bit */
name|temp
operator||=
name|dev_priv
operator|->
name|lvds_border_bits
expr_stmt|;
comment|/* Set the B0-B3 data pairs corresponding to whether we're going to 		 * set the DPLLs for dual-channel mode or not. 		 */
if|if
condition|(
name|clock
operator|.
name|p2
operator|==
literal|7
condition|)
name|temp
operator||=
name|LVDS_B0B3_POWER_UP
operator||
name|LVDS_CLKB_POWER_UP
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
operator|(
name|LVDS_B0B3_POWER_UP
operator||
name|LVDS_CLKB_POWER_UP
operator|)
expr_stmt|;
comment|/* It would be nice to set 24 vs 18-bit mode (LVDS_A3_POWER_UP) 		 * appropriately here, but we need to look more thoroughly into how 		 * panels behave in the two modes. 		 */
name|temp
operator|&=
operator|~
operator|(
name|LVDS_HSYNC_POLARITY
operator||
name|LVDS_VSYNC_POLARITY
operator|)
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NHSYNC
condition|)
name|temp
operator||=
name|LVDS_HSYNC_POLARITY
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NVSYNC
condition|)
name|temp
operator||=
name|LVDS_VSYNC_POLARITY
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_LVDS
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|pipeconf
operator|&=
operator|~
name|PIPECONF_DITHER_EN
expr_stmt|;
name|pipeconf
operator|&=
operator|~
name|PIPECONF_DITHER_TYPE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|is_lvds
operator|&&
name|dev_priv
operator|->
name|lvds_dither
operator|)
operator|||
name|dither
condition|)
block|{
name|pipeconf
operator||=
name|PIPECONF_DITHER_EN
expr_stmt|;
name|pipeconf
operator||=
name|PIPECONF_DITHER_TYPE_SP
expr_stmt|;
block|}
if|if
condition|(
name|is_dp
operator|&&
operator|!
name|is_cpu_edp
condition|)
block|{
name|intel_dp_set_m_n
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For non-DP output, clear any trans DP clock recovery setting.*/
name|I915_WRITE
argument_list|(
name|TRANSDATA_M1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDATA_N1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDPLINK_M1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDPLINK_N1
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intel_crtc
operator|->
name|pch_pll
condition|)
block|{
name|I915_WRITE
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|pll_reg
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
comment|/* Wait for the clocks to stabilize. */
name|POSTING_READ
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|pll_reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* The pixel multiplier can only be updated once the 		 * DPLL is enabled and the clocks are stable. 		 * 		 * So write it again. 		 */
name|I915_WRITE
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|pll_reg
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
block|}
name|intel_crtc
operator|->
name|lowfreq_avail
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|pch_pll
condition|)
block|{
if|if
condition|(
name|is_lvds
operator|&&
name|has_reduced_clock
operator|&&
name|i915_powersave
condition|)
block|{
name|I915_WRITE
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|fp1_reg
argument_list|,
name|fp2
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|lowfreq_avail
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|HAS_PIPE_CXSR
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"enabling CxSR downclocking\n"
argument_list|)
expr_stmt|;
name|pipeconf
operator||=
name|PIPECONF_CXSR_DOWNCLOCK
expr_stmt|;
block|}
block|}
else|else
block|{
name|I915_WRITE
argument_list|(
name|intel_crtc
operator|->
name|pch_pll
operator|->
name|fp1_reg
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PIPE_CXSR
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabling CxSR downclocking\n"
argument_list|)
expr_stmt|;
name|pipeconf
operator|&=
operator|~
name|PIPECONF_CXSR_DOWNCLOCK
expr_stmt|;
block|}
block|}
block|}
name|pipeconf
operator|&=
operator|~
name|PIPECONF_INTERLACE_MASK
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
condition|)
block|{
name|pipeconf
operator||=
name|PIPECONF_INTERLACED_ILK
expr_stmt|;
comment|/* the chip adds 2 halflines automatically */
name|adjusted_mode
operator|->
name|crtc_vtotal
operator|-=
literal|1
expr_stmt|;
name|adjusted_mode
operator|->
name|crtc_vblank_end
operator|-=
literal|1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VSYNCSHIFT
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|adjusted_mode
operator|->
name|crtc_hsync_start
operator|-
name|adjusted_mode
operator|->
name|crtc_htotal
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pipeconf
operator||=
name|PIPECONF_PROGRESSIVE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VSYNCSHIFT
argument_list|(
name|pipe
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|HTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hdisplay
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_htotal
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hblank_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_hblank_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_hsync_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_hsync_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vdisplay
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vtotal
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VBLANK
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vblank_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vblank_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
name|adjusted_mode
operator|->
name|crtc_vsync_start
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vsync_end
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* pipesrc controls the size that is scaled from, which should 	 * always be the user's requested size. 	 */
name|I915_WRITE
argument_list|(
name|PIPESRC
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
operator|(
name|mode
operator|->
name|hdisplay
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|mode
operator|->
name|vdisplay
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_DATA_M1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|TU_SIZE
argument_list|(
name|m_n
operator|.
name|tu
argument_list|)
operator||
name|m_n
operator|.
name|gmch_m
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_DATA_N1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|m_n
operator|.
name|gmch_n
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_LINK_M1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|m_n
operator|.
name|link_m
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_LINK_N1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|m_n
operator|.
name|link_n
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cpu_edp
condition|)
name|ironlake_set_pll_edp
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
operator|->
name|clock
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|pipeconf
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PIPECONF
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|,
name|dspcntr
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_pipe_set_base
argument_list|(
name|crtc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|old_fb
argument_list|)
expr_stmt|;
name|intel_update_watermarks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_update_linetime_watermarks
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_crtc_mode_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|drm_vblank_pre_modeset
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dev_priv
operator|->
name|display
operator|.
name|crtc_mode_set
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|old_fb
argument_list|)
expr_stmt|;
name|drm_vblank_post_modeset
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|intel_crtc
operator|->
name|dpms_mode
operator|=
name|DRM_MODE_DPMS_OFF
expr_stmt|;
else|else
name|intel_crtc
operator|->
name|dpms_mode
operator|=
name|DRM_MODE_DPMS_ON
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_eld_uptodate
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|int
name|reg_eldv
parameter_list|,
name|uint32_t
name|bits_eldv
parameter_list|,
name|int
name|reg_elda
parameter_list|,
name|uint32_t
name|bits_elda
parameter_list|,
name|int
name|reg_edid
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|connector
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint8_t
modifier|*
name|eld
init|=
name|connector
operator|->
name|eld
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|reg_eldv
argument_list|)
expr_stmt|;
name|i
operator|&=
name|bits_eldv
expr_stmt|;
if|if
condition|(
operator|!
name|eld
index|[
literal|0
index|]
condition|)
return|return
operator|!
name|i
return|;
if|if
condition|(
operator|!
name|i
condition|)
return|return
name|false
return|;
name|i
operator|=
name|I915_READ
argument_list|(
name|reg_elda
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|bits_elda
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg_elda
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eld
index|[
literal|2
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|I915_READ
argument_list|(
name|reg_edid
argument_list|)
operator|!=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|eld
operator|+
name|i
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g4x_write_eld
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|connector
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint8_t
modifier|*
name|eld
init|=
name|connector
operator|->
name|eld
decl_stmt|;
name|uint32_t
name|eldv
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|G4X_AUD_VID_DID
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|INTEL_AUDIO_DEVBLC
operator|||
name|i
operator|==
name|INTEL_AUDIO_DEVCL
condition|)
name|eldv
operator|=
name|G4X_ELDV_DEVCL_DEVBLC
expr_stmt|;
else|else
name|eldv
operator|=
name|G4X_ELDV_DEVCTG
expr_stmt|;
if|if
condition|(
name|intel_eld_uptodate
argument_list|(
name|connector
argument_list|,
name|G4X_AUD_CNTL_ST
argument_list|,
name|eldv
argument_list|,
name|G4X_AUD_CNTL_ST
argument_list|,
name|G4X_ELD_ADDR
argument_list|,
name|G4X_HDMIW_HDMIEDID
argument_list|)
condition|)
return|return;
name|i
operator|=
name|I915_READ
argument_list|(
name|G4X_AUD_CNTL_ST
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
operator|(
name|eldv
operator||
name|G4X_ELD_ADDR
operator|)
expr_stmt|;
name|len
operator|=
operator|(
name|i
operator|>>
literal|9
operator|)
operator|&
literal|0x1f
expr_stmt|;
comment|/* ELD buffer size */
name|I915_WRITE
argument_list|(
name|G4X_AUD_CNTL_ST
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eld
index|[
literal|0
index|]
condition|)
return|return;
if|if
condition|(
name|eld
index|[
literal|2
index|]
operator|<
operator|(
name|uint8_t
operator|)
name|len
condition|)
name|len
operator|=
name|eld
index|[
literal|2
index|]
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"ELD size %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|G4X_HDMIW_HDMIEDID
argument_list|,
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|eld
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|G4X_AUD_CNTL_ST
argument_list|)
expr_stmt|;
name|i
operator||=
name|eldv
expr_stmt|;
name|I915_WRITE
argument_list|(
name|G4X_AUD_CNTL_ST
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_write_eld
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|connector
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint8_t
modifier|*
name|eld
init|=
name|connector
operator|->
name|eld
decl_stmt|;
name|uint32_t
name|eldv
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hdmiw_hdmiedid
decl_stmt|;
name|int
name|aud_config
decl_stmt|;
name|int
name|aud_cntl_st
decl_stmt|;
name|int
name|aud_cntrl_st2
decl_stmt|;
if|if
condition|(
name|HAS_PCH_IBX
argument_list|(
name|connector
operator|->
name|dev
argument_list|)
condition|)
block|{
name|hdmiw_hdmiedid
operator|=
name|IBX_HDMIW_HDMIEDID_A
expr_stmt|;
name|aud_config
operator|=
name|IBX_AUD_CONFIG_A
expr_stmt|;
name|aud_cntl_st
operator|=
name|IBX_AUD_CNTL_ST_A
expr_stmt|;
name|aud_cntrl_st2
operator|=
name|IBX_AUD_CNTL_ST2
expr_stmt|;
block|}
else|else
block|{
name|hdmiw_hdmiedid
operator|=
name|CPT_HDMIW_HDMIEDID_A
expr_stmt|;
name|aud_config
operator|=
name|CPT_AUD_CONFIG_A
expr_stmt|;
name|aud_cntl_st
operator|=
name|CPT_AUD_CNTL_ST_A
expr_stmt|;
name|aud_cntrl_st2
operator|=
name|CPT_AUD_CNTRL_ST2
expr_stmt|;
block|}
name|i
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|pipe
expr_stmt|;
name|hdmiw_hdmiedid
operator|+=
name|i
operator|*
literal|0x100
expr_stmt|;
name|aud_cntl_st
operator|+=
name|i
operator|*
literal|0x100
expr_stmt|;
name|aud_config
operator|+=
name|i
operator|*
literal|0x100
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"ELD on pipe %c\n"
argument_list|,
name|pipe_name
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntl_st
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|>>
literal|29
operator|)
operator|&
literal|0x3
expr_stmt|;
comment|/* DIP_Port_Select, 0x1 = PortB */
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Audio directed to unknown port\n"
argument_list|)
expr_stmt|;
comment|/* operate blindly on all ports */
name|eldv
operator|=
name|IBX_ELD_VALIDB
expr_stmt|;
name|eldv
operator||=
name|IBX_ELD_VALIDB
operator|<<
literal|4
expr_stmt|;
name|eldv
operator||=
name|IBX_ELD_VALIDB
operator|<<
literal|8
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"ELD on port %c\n"
argument_list|,
literal|'A'
operator|+
name|i
argument_list|)
expr_stmt|;
name|eldv
operator|=
name|IBX_ELD_VALIDB
operator|<<
operator|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|intel_pipe_has_type
argument_list|(
name|crtc
argument_list|,
name|INTEL_OUTPUT_DISPLAYPORT
argument_list|)
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"ELD: DisplayPort detected\n"
argument_list|)
expr_stmt|;
name|eld
index|[
literal|5
index|]
operator||=
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* Conn_Type, 0x1 = DisplayPort */
name|I915_WRITE
argument_list|(
name|aud_config
argument_list|,
name|AUD_CONFIG_N_VALUE_INDEX
argument_list|)
expr_stmt|;
comment|/* 0x1 = DP */
block|}
else|else
name|I915_WRITE
argument_list|(
name|aud_config
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_eld_uptodate
argument_list|(
name|connector
argument_list|,
name|aud_cntrl_st2
argument_list|,
name|eldv
argument_list|,
name|aud_cntl_st
argument_list|,
name|IBX_ELD_ADDRESS
argument_list|,
name|hdmiw_hdmiedid
argument_list|)
condition|)
return|return;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntrl_st2
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|eldv
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_cntrl_st2
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eld
index|[
literal|0
index|]
condition|)
return|return;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntl_st
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|IBX_ELD_ADDRESS
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_cntl_st
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 84 bytes of hw ELD buffer */
name|len
operator|=
literal|21
expr_stmt|;
if|if
condition|(
name|eld
index|[
literal|2
index|]
operator|<
operator|(
name|uint8_t
operator|)
name|len
condition|)
name|len
operator|=
name|eld
index|[
literal|2
index|]
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"ELD size %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|hdmiw_hdmiedid
argument_list|,
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|eld
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|I915_READ
argument_list|(
name|aud_cntrl_st2
argument_list|)
expr_stmt|;
name|i
operator||=
name|eldv
expr_stmt|;
name|I915_WRITE
argument_list|(
name|aud_cntrl_st2
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_write_eld
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|encoder
operator|->
name|crtc
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|connector
operator|=
name|drm_select_eld
argument_list|(
name|encoder
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|connector
condition|)
return|return;
name|DRM_DEBUG_KMS
argument_list|(
literal|"ELD on [CONNECTOR:%d:%s], [ENCODER:%d:%s]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|connector
operator|->
name|encoder
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
name|connector
operator|->
name|encoder
argument_list|)
argument_list|)
expr_stmt|;
name|connector
operator|->
name|eld
index|[
literal|6
index|]
operator|=
name|drm_av_sync_delay
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
argument_list|(
name|connector
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Loads the palette/gamma unit for the CRTC with the prepared values */
end_comment

begin_function
name|void
name|intel_crtc_load_lut
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|palreg
init|=
name|PALETTE
argument_list|(
name|intel_crtc
operator|->
name|pipe
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The clocks have to be on to load the palette. */
if|if
condition|(
operator|!
name|crtc
operator|->
name|enabled
operator|||
operator|!
name|intel_crtc
operator|->
name|active
condition|)
return|return;
comment|/* use legacy palette for Ironlake */
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|palreg
operator|=
name|LGC_PALETTE
argument_list|(
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|I915_WRITE
argument_list|(
name|palreg
operator|+
literal|4
operator|*
name|i
argument_list|,
operator|(
name|intel_crtc
operator|->
name|lut_r
index|[
name|i
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|intel_crtc
operator|->
name|lut_g
index|[
name|i
index|]
operator|<<
literal|8
operator|)
operator||
name|intel_crtc
operator|->
name|lut_b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i845_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u32
name|base
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|bool
name|visible
init|=
name|base
operator|!=
literal|0
decl_stmt|;
name|u32
name|cntl
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_visible
operator|==
name|visible
condition|)
return|return;
name|cntl
operator|=
name|I915_READ
argument_list|(
name|_CURACNTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|visible
condition|)
block|{
comment|/* On these chipsets we can only modify the base whilst 		 * the cursor is disabled. 		 */
name|I915_WRITE
argument_list|(
name|_CURABASE
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_FORMAT_MASK
operator|)
expr_stmt|;
comment|/* XXX width must be 64, stride 256 => 0x00<< 28 */
name|cntl
operator||=
name|CURSOR_ENABLE
operator||
name|CURSOR_GAMMA_ENABLE
operator||
name|CURSOR_FORMAT_ARGB
expr_stmt|;
block|}
else|else
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_ENABLE
operator||
name|CURSOR_GAMMA_ENABLE
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_CURACNTR
argument_list|,
name|cntl
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_visible
operator|=
name|visible
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u32
name|base
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|bool
name|visible
init|=
name|base
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_visible
operator|!=
name|visible
condition|)
block|{
name|uint32_t
name|cntl
init|=
name|I915_READ
argument_list|(
name|CURCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_MODE
operator||
name|MCURSOR_PIPE_SELECT
operator|)
expr_stmt|;
name|cntl
operator||=
name|CURSOR_MODE_64_ARGB_AX
operator||
name|MCURSOR_GAMMA_ENABLE
expr_stmt|;
name|cntl
operator||=
name|pipe
operator|<<
literal|28
expr_stmt|;
comment|/* Connect to correct pipe */
block|}
else|else
block|{
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_MODE
operator||
name|MCURSOR_GAMMA_ENABLE
operator|)
expr_stmt|;
name|cntl
operator||=
name|CURSOR_MODE_DISABLE
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|CURCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|cntl
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_visible
operator|=
name|visible
expr_stmt|;
block|}
comment|/* and commit changes on next vblank */
name|I915_WRITE
argument_list|(
name|CURBASE
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ivb_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u32
name|base
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|bool
name|visible
init|=
name|base
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_visible
operator|!=
name|visible
condition|)
block|{
name|uint32_t
name|cntl
init|=
name|I915_READ
argument_list|(
name|CURCNTR_IVB
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|cntl
operator|&=
operator|~
name|CURSOR_MODE
expr_stmt|;
name|cntl
operator||=
name|CURSOR_MODE_64_ARGB_AX
operator||
name|MCURSOR_GAMMA_ENABLE
expr_stmt|;
block|}
else|else
block|{
name|cntl
operator|&=
operator|~
operator|(
name|CURSOR_MODE
operator||
name|MCURSOR_GAMMA_ENABLE
operator|)
expr_stmt|;
name|cntl
operator||=
name|CURSOR_MODE_DISABLE
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|CURCNTR_IVB
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|cntl
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_visible
operator|=
name|visible
expr_stmt|;
block|}
comment|/* and commit changes on next vblank */
name|I915_WRITE
argument_list|(
name|CURBASE_IVB
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If no-part of the cursor is visible on the framebuffer, then the GPU may hang... */
end_comment

begin_function
specifier|static
name|void
name|intel_crtc_update_cursor
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|x
init|=
name|intel_crtc
operator|->
name|cursor_x
decl_stmt|;
name|int
name|y
init|=
name|intel_crtc
operator|->
name|cursor_y
decl_stmt|;
name|u32
name|base
decl_stmt|,
name|pos
decl_stmt|;
name|bool
name|visible
decl_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|on
operator|&&
name|crtc
operator|->
name|enabled
operator|&&
name|crtc
operator|->
name|fb
condition|)
block|{
name|base
operator|=
name|intel_crtc
operator|->
name|cursor_addr
expr_stmt|;
if|if
condition|(
name|x
operator|>
operator|(
name|int
operator|)
name|crtc
operator|->
name|fb
operator|->
name|width
condition|)
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y
operator|>
operator|(
name|int
operator|)
name|crtc
operator|->
name|fb
operator|->
name|height
condition|)
name|base
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|+
name|intel_crtc
operator|->
name|cursor_width
operator|<
literal|0
condition|)
name|base
operator|=
literal|0
expr_stmt|;
name|pos
operator||=
name|CURSOR_POS_SIGN
operator|<<
name|CURSOR_X_SHIFT
expr_stmt|;
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
name|pos
operator||=
name|x
operator|<<
name|CURSOR_X_SHIFT
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|+
name|intel_crtc
operator|->
name|cursor_height
operator|<
literal|0
condition|)
name|base
operator|=
literal|0
expr_stmt|;
name|pos
operator||=
name|CURSOR_POS_SIGN
operator|<<
name|CURSOR_Y_SHIFT
expr_stmt|;
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
name|pos
operator||=
name|y
operator|<<
name|CURSOR_Y_SHIFT
expr_stmt|;
name|visible
operator|=
name|base
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|visible
operator|&&
operator|!
name|intel_crtc
operator|->
name|cursor_visible
condition|)
return|return;
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|CURPOS_IVB
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|ivb_update_cursor
argument_list|(
name|crtc
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|I915_WRITE
argument_list|(
name|CURPOS
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_845G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I865G
argument_list|(
name|dev
argument_list|)
condition|)
name|i845_update_cursor
argument_list|(
name|crtc
argument_list|,
name|base
argument_list|)
expr_stmt|;
else|else
name|i9xx_update_cursor
argument_list|(
name|crtc
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|intel_crtc_cursor_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|uint32_t
name|handle
parameter_list|,
name|uint32_t
name|width
parameter_list|,
name|uint32_t
name|height
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* if we want to turn off the cursor ignore width and height */
if|if
condition|(
operator|!
name|handle
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"cursor off\n"
argument_list|)
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* Currently we only support 64x64 cursors */
if|if
condition|(
name|width
operator|!=
literal|64
operator|||
name|height
operator|!=
literal|64
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"we currently only support 64x64 cursors\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOENT
return|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|size
operator|<
name|width
operator|*
name|height
operator|*
literal|4
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"buffer is to small\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* we only need to pin inside GTT if cursor is non-phy */
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|info
operator|->
name|cursor_needs_physical
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|tiling_mode
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"cursor cannot be tiled\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|fail_locked
goto|;
block|}
name|ret
operator|=
name|i915_gem_object_pin_to_display_plane
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to move cursor bo into the GTT\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_locked
goto|;
block|}
name|ret
operator|=
name|i915_gem_object_put_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to release fence for cursor\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_unpin
goto|;
block|}
name|addr
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
block|}
else|else
block|{
name|int
name|align
init|=
name|IS_I830
argument_list|(
name|dev
argument_list|)
condition|?
literal|16
operator|*
literal|1024
else|:
literal|256
decl_stmt|;
name|ret
operator|=
name|i915_gem_attach_phys_object
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
operator|(
name|intel_crtc
operator|->
name|pipe
operator|==
literal|0
operator|)
condition|?
name|I915_GEM_PHYS_CURSOR_0
else|:
name|I915_GEM_PHYS_CURSOR_1
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to attach phys object\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_locked
goto|;
block|}
name|addr
operator|=
name|obj
operator|->
name|phys_obj
operator|->
name|handle
operator|->
name|busaddr
expr_stmt|;
block|}
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|CURSIZE
argument_list|,
operator|(
name|height
operator|<<
literal|12
operator|)
operator||
name|width
argument_list|)
expr_stmt|;
name|finish
label|:
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_bo
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|info
operator|->
name|cursor_needs_physical
condition|)
block|{
if|if
condition|(
name|intel_crtc
operator|->
name|cursor_bo
operator|!=
name|obj
condition|)
name|i915_gem_detach_phys_object
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|cursor_bo
argument_list|)
expr_stmt|;
block|}
else|else
name|i915_gem_object_unpin_from_display_plane
argument_list|(
name|intel_crtc
operator|->
name|cursor_bo
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|intel_crtc
operator|->
name|cursor_bo
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_addr
operator|=
name|addr
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_bo
operator|=
name|obj
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_width
operator|=
name|width
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_height
operator|=
name|height
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail_unpin
label|:
name|i915_gem_object_unpin_from_display_plane
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|fail_locked
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fail
label|:
name|drm_gem_object_unreference_unlocked
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_crtc_cursor_move
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|intel_crtc
operator|->
name|cursor_x
operator|=
name|x
expr_stmt|;
name|intel_crtc
operator|->
name|cursor_y
operator|=
name|y
expr_stmt|;
name|intel_crtc_update_cursor
argument_list|(
name|crtc
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Sets the color ramps on behalf of RandR */
end_comment

begin_function
name|void
name|intel_crtc_fb_gamma_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u16
name|red
parameter_list|,
name|u16
name|green
parameter_list|,
name|u16
name|blue
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|intel_crtc
operator|->
name|lut_r
index|[
name|regno
index|]
operator|=
name|red
operator|>>
literal|8
expr_stmt|;
name|intel_crtc
operator|->
name|lut_g
index|[
name|regno
index|]
operator|=
name|green
operator|>>
literal|8
expr_stmt|;
name|intel_crtc
operator|->
name|lut_b
index|[
name|regno
index|]
operator|=
name|blue
operator|>>
literal|8
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_crtc_fb_gamma_get
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u16
modifier|*
name|red
parameter_list|,
name|u16
modifier|*
name|green
parameter_list|,
name|u16
modifier|*
name|blue
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
operator|*
name|red
operator|=
name|intel_crtc
operator|->
name|lut_r
index|[
name|regno
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|green
operator|=
name|intel_crtc
operator|->
name|lut_g
index|[
name|regno
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|blue
operator|=
name|intel_crtc
operator|->
name|lut_b
index|[
name|regno
index|]
operator|<<
literal|8
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_gamma_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u16
modifier|*
name|red
parameter_list|,
name|u16
modifier|*
name|green
parameter_list|,
name|u16
modifier|*
name|blue
parameter_list|,
name|uint32_t
name|start
parameter_list|,
name|uint32_t
name|size
parameter_list|)
block|{
name|int
name|end
init|=
operator|(
name|start
operator|+
name|size
operator|>
literal|256
operator|)
condition|?
literal|256
else|:
name|start
operator|+
name|size
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|intel_crtc
operator|->
name|lut_r
index|[
name|i
index|]
operator|=
name|red
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
name|intel_crtc
operator|->
name|lut_g
index|[
name|i
index|]
operator|=
name|green
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
name|intel_crtc
operator|->
name|lut_b
index|[
name|i
index|]
operator|=
name|blue
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
block|}
name|intel_crtc_load_lut
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Get a pipe with a simple mode set on it for doing load-based monitor  * detection.  *  * It will be up to the load-detect code to adjust the pipe as appropriate for  * its requirements.  The pipe will be connected to no other encoders.  *  * Currently this code will only succeed if there is a pipe with no encoders  * configured for it.  In the future, it could choose to temporarily disable  * some outputs to free up a pipe for its use.  *  * \return crtc, or NULL if no pipes are available.  */
end_comment

begin_comment
comment|/* VESA 640x480x72Hz mode to set on the pipe */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|drm_display_mode
name|load_detect_mode
init|=
block|{
name|DRM_MODE
argument_list|(
literal|"640x480"
argument_list|,
name|DRM_MODE_TYPE_DEFAULT
argument_list|,
literal|31500
argument_list|,
literal|640
argument_list|,
literal|664
argument_list|,
literal|704
argument_list|,
literal|832
argument_list|,
literal|0
argument_list|,
literal|480
argument_list|,
literal|489
argument_list|,
literal|491
argument_list|,
literal|520
argument_list|,
literal|0
argument_list|,
name|DRM_MODE_FLAG_NHSYNC
operator||
name|DRM_MODE_FLAG_NVSYNC
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|intel_framebuffer_create
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_mode_fb_cmd2
modifier|*
name|mode_cmd
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|intel_fb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|intel_fb
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_framebuffer_init
argument_list|(
name|dev
argument_list|,
name|intel_fb
argument_list|,
name|mode_cmd
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|drm_gem_object_unreference_unlocked
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intel_fb
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
operator|*
name|res
operator|=
operator|&
name|intel_fb
operator|->
name|base
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|intel_framebuffer_pitch_for_width
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|bpp
parameter_list|)
block|{
name|u32
name|pitch
init|=
name|howmany
argument_list|(
name|width
operator|*
name|bpp
argument_list|,
literal|8
argument_list|)
decl_stmt|;
return|return
name|roundup2
argument_list|(
name|pitch
argument_list|,
literal|64
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|intel_framebuffer_size_for_mode
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|int
name|bpp
parameter_list|)
block|{
name|u32
name|pitch
init|=
name|intel_framebuffer_pitch_for_width
argument_list|(
name|mode
operator|->
name|hdisplay
argument_list|,
name|bpp
argument_list|)
decl_stmt|;
return|return
name|roundup2
argument_list|(
name|pitch
operator|*
name|mode
operator|->
name|vdisplay
argument_list|,
name|PAGE_SIZE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_framebuffer_create_for_mode
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|bpp
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_mode_fb_cmd2
name|mode_cmd
decl_stmt|;
name|obj
operator|=
name|i915_gem_alloc_object
argument_list|(
name|dev
argument_list|,
name|intel_framebuffer_size_for_mode
argument_list|(
name|mode
argument_list|,
name|bpp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|mode_cmd
operator|.
name|width
operator|=
name|mode
operator|->
name|hdisplay
expr_stmt|;
name|mode_cmd
operator|.
name|height
operator|=
name|mode
operator|->
name|vdisplay
expr_stmt|;
name|mode_cmd
operator|.
name|pitches
index|[
literal|0
index|]
operator|=
name|intel_framebuffer_pitch_for_width
argument_list|(
name|mode_cmd
operator|.
name|width
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
name|mode_cmd
operator|.
name|pixel_format
operator|=
name|drm_mode_legacy_fb_format
argument_list|(
name|bpp
argument_list|,
name|depth
argument_list|)
expr_stmt|;
return|return
operator|(
name|intel_framebuffer_create
argument_list|(
name|dev
argument_list|,
operator|&
name|mode_cmd
argument_list|,
name|obj
argument_list|,
name|res
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mode_fits_in_fbdev
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|fbdev
operator|==
name|NULL
condition|)
block|{
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|obj
operator|=
name|dev_priv
operator|->
name|fbdev
operator|->
name|ifb
operator|.
name|obj
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fb
operator|=
operator|&
name|dev_priv
operator|->
name|fbdev
operator|->
name|ifb
operator|.
name|base
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|<
name|intel_framebuffer_pitch_for_width
argument_list|(
name|mode
operator|->
name|hdisplay
argument_list|,
name|fb
operator|->
name|bits_per_pixel
argument_list|)
condition|)
block|{
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|size
operator|<
name|mode
operator|->
name|vdisplay
operator|*
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|res
operator|=
name|fb
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|intel_get_load_detect_pipe
parameter_list|(
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
parameter_list|,
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|intel_load_detect_pipe
modifier|*
name|old
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|possible_crtc
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
operator|&
name|intel_encoder
operator|->
name|base
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|,
name|r
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s], [ENCODER:%d:%s]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
name|encoder
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Algorithm gets a little messy: 	 * 	 *   - if the connector already has an assigned crtc, use it (but make 	 *     sure it's on first) 	 * 	 *   - try to find the first unused crtc that can drive this connector, 	 *     and use that if we find one 	 */
comment|/* See if we already have a CRTC for this connector */
if|if
condition|(
name|encoder
operator|->
name|crtc
condition|)
block|{
name|crtc
operator|=
name|encoder
operator|->
name|crtc
expr_stmt|;
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|old
operator|->
name|dpms_mode
operator|=
name|intel_crtc
operator|->
name|dpms_mode
expr_stmt|;
name|old
operator|->
name|load_detect_temp
operator|=
name|false
expr_stmt|;
comment|/* Make sure the crtc and connector are running */
if|if
condition|(
name|intel_crtc
operator|->
name|dpms_mode
operator|!=
name|DRM_MODE_DPMS_ON
condition|)
block|{
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
decl_stmt|;
name|struct
name|drm_crtc_helper_funcs
modifier|*
name|crtc_funcs
decl_stmt|;
name|crtc_funcs
operator|=
name|crtc
operator|->
name|helper_private
expr_stmt|;
name|crtc_funcs
operator|->
name|dpms
argument_list|(
name|crtc
argument_list|,
name|DRM_MODE_DPMS_ON
argument_list|)
expr_stmt|;
name|encoder_funcs
operator|=
name|encoder
operator|->
name|helper_private
expr_stmt|;
name|encoder_funcs
operator|->
name|dpms
argument_list|(
name|encoder
argument_list|,
name|DRM_MODE_DPMS_ON
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
comment|/* Find an unused one (if possible) */
name|list_for_each_entry
argument_list|(
argument|possible_crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|encoder
operator|->
name|possible_crtcs
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|possible_crtc
operator|->
name|enabled
condition|)
block|{
name|crtc
operator|=
name|possible_crtc
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If we didn't find an unused CRTC, don't use any. 	 */
if|if
condition|(
operator|!
name|crtc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"no pipe available for load-detect\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|encoder
operator|->
name|crtc
operator|=
name|crtc
expr_stmt|;
name|connector
operator|->
name|encoder
operator|=
name|encoder
expr_stmt|;
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|old
operator|->
name|dpms_mode
operator|=
name|intel_crtc
operator|->
name|dpms_mode
expr_stmt|;
name|old
operator|->
name|load_detect_temp
operator|=
name|true
expr_stmt|;
name|old
operator|->
name|release_fb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
name|mode
operator|=
operator|&
name|load_detect_mode
expr_stmt|;
name|old_fb
operator|=
name|crtc
operator|->
name|fb
expr_stmt|;
comment|/* We need a framebuffer large enough to accommodate all accesses 	 * that the plane may generate whilst we perform load detection. 	 * We can not rely on the fbcon either being present (we get called 	 * during its initialisation to detect all boot displays, or it may 	 * not even exist) or that it is large enough to satisfy the 	 * requested mode. 	 */
name|r
operator|=
name|mode_fits_in_fbdev
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|,
operator|&
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|fb
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"creating tmp fb for load-detection\n"
argument_list|)
expr_stmt|;
name|r
operator|=
name|intel_framebuffer_create_for_mode
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|,
literal|24
argument_list|,
literal|32
argument_list|,
operator|&
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
name|old
operator|->
name|release_fb
operator|=
name|crtc
operator|->
name|fb
expr_stmt|;
block|}
else|else
name|DRM_DEBUG_KMS
argument_list|(
literal|"reusing fbdev for load-detection framebuffer\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"failed to allocate framebuffer for load-detection\n"
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|fb
operator|=
name|old_fb
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|drm_crtc_helper_set_mode
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|old_fb
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"failed to set mode on load-detect pipe\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|release_fb
condition|)
name|old
operator|->
name|release_fb
operator|->
name|funcs
operator|->
name|destroy
argument_list|(
name|old
operator|->
name|release_fb
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|fb
operator|=
name|old_fb
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* let the connector get through one full cycle before testing */
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|intel_release_load_detect_pipe
parameter_list|(
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
parameter_list|,
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|intel_load_detect_pipe
modifier|*
name|old
parameter_list|)
block|{
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
operator|&
name|intel_encoder
operator|->
name|base
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|encoder
operator|->
name|crtc
decl_stmt|;
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
init|=
name|encoder
operator|->
name|helper_private
decl_stmt|;
name|struct
name|drm_crtc_helper_funcs
modifier|*
name|crtc_funcs
init|=
name|crtc
operator|->
name|helper_private
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s], [ENCODER:%d:%s]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
name|encoder
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|load_detect_temp
condition|)
block|{
name|connector
operator|->
name|encoder
operator|=
name|NULL
expr_stmt|;
name|drm_helper_disable_unused_functions
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|release_fb
condition|)
name|old
operator|->
name|release_fb
operator|->
name|funcs
operator|->
name|destroy
argument_list|(
name|old
operator|->
name|release_fb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Switch crtc and encoder back off if necessary */
if|if
condition|(
name|old
operator|->
name|dpms_mode
operator|!=
name|DRM_MODE_DPMS_ON
condition|)
block|{
name|encoder_funcs
operator|->
name|dpms
argument_list|(
name|encoder
argument_list|,
name|old
operator|->
name|dpms_mode
argument_list|)
expr_stmt|;
name|crtc_funcs
operator|->
name|dpms
argument_list|(
name|crtc
argument_list|,
name|old
operator|->
name|dpms_mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the clock of the currently programmed mode of the given pipe. */
end_comment

begin_function
specifier|static
name|int
name|intel_crtc_clock_get
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|u32
name|dpll
init|=
name|I915_READ
argument_list|(
name|DPLL
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
name|u32
name|fp
decl_stmt|;
name|intel_clock_t
name|clock
decl_stmt|;
if|if
condition|(
operator|(
name|dpll
operator|&
name|DISPLAY_RATE_SELECT_FPA1
operator|)
operator|==
literal|0
condition|)
name|fp
operator|=
name|I915_READ
argument_list|(
name|FP0
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fp
operator|=
name|I915_READ
argument_list|(
name|FP1
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|clock
operator|.
name|m1
operator|=
operator|(
name|fp
operator|&
name|FP_M1_DIV_MASK
operator|)
operator|>>
name|FP_M1_DIV_SHIFT
expr_stmt|;
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|clock
operator|.
name|n
operator|=
name|ffs
argument_list|(
operator|(
name|fp
operator|&
name|FP_N_PINEVIEW_DIV_MASK
operator|)
operator|>>
name|FP_N_DIV_SHIFT
argument_list|)
operator|-
literal|1
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
operator|(
name|fp
operator|&
name|FP_M2_PINEVIEW_DIV_MASK
operator|)
operator|>>
name|FP_M2_DIV_SHIFT
expr_stmt|;
block|}
else|else
block|{
name|clock
operator|.
name|n
operator|=
operator|(
name|fp
operator|&
name|FP_N_DIV_MASK
operator|)
operator|>>
name|FP_N_DIV_SHIFT
expr_stmt|;
name|clock
operator|.
name|m2
operator|=
operator|(
name|fp
operator|&
name|FP_M2_DIV_MASK
operator|)
operator|>>
name|FP_M2_DIV_SHIFT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|clock
operator|.
name|p1
operator|=
name|ffs
argument_list|(
operator|(
name|dpll
operator|&
name|DPLL_FPA01_P1_POST_DIV_MASK_PINEVIEW
operator|)
operator|>>
name|DPLL_FPA01_P1_POST_DIV_SHIFT_PINEVIEW
argument_list|)
expr_stmt|;
else|else
name|clock
operator|.
name|p1
operator|=
name|ffs
argument_list|(
operator|(
name|dpll
operator|&
name|DPLL_FPA01_P1_POST_DIV_MASK
operator|)
operator|>>
name|DPLL_FPA01_P1_POST_DIV_SHIFT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dpll
operator|&
name|DPLL_MODE_MASK
condition|)
block|{
case|case
name|DPLLB_MODE_DAC_SERIAL
case|:
name|clock
operator|.
name|p2
operator|=
name|dpll
operator|&
name|DPLL_DAC_SERIAL_P2_CLOCK_DIV_5
condition|?
literal|5
else|:
literal|10
expr_stmt|;
break|break;
case|case
name|DPLLB_MODE_LVDS
case|:
name|clock
operator|.
name|p2
operator|=
name|dpll
operator|&
name|DPLLB_LVDS_P2_CLOCK_DIV_7
condition|?
literal|7
else|:
literal|14
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unknown DPLL mode %08x in programmed "
literal|"mode\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dpll
operator|&
name|DPLL_MODE_MASK
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* XXX: Handle the 100Mhz refclk */
name|intel_clock
argument_list|(
name|dev
argument_list|,
literal|96000
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|is_lvds
init|=
operator|(
name|pipe
operator|==
literal|1
operator|)
operator|&&
operator|(
name|I915_READ
argument_list|(
name|LVDS
argument_list|)
operator|&
name|LVDS_PORT_EN
operator|)
decl_stmt|;
if|if
condition|(
name|is_lvds
condition|)
block|{
name|clock
operator|.
name|p1
operator|=
name|ffs
argument_list|(
operator|(
name|dpll
operator|&
name|DPLL_FPA01_P1_POST_DIV_MASK_I830_LVDS
operator|)
operator|>>
name|DPLL_FPA01_P1_POST_DIV_SHIFT
argument_list|)
expr_stmt|;
name|clock
operator|.
name|p2
operator|=
literal|14
expr_stmt|;
if|if
condition|(
operator|(
name|dpll
operator|&
name|PLL_REF_INPUT_MASK
operator|)
operator|==
name|PLLB_REF_INPUT_SPREADSPECTRUMIN
condition|)
block|{
comment|/* XXX: might not be 66MHz */
name|intel_clock
argument_list|(
name|dev
argument_list|,
literal|66000
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
block|}
else|else
name|intel_clock
argument_list|(
name|dev
argument_list|,
literal|48000
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dpll
operator|&
name|PLL_P1_DIVIDE_BY_TWO
condition|)
name|clock
operator|.
name|p1
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|clock
operator|.
name|p1
operator|=
operator|(
operator|(
name|dpll
operator|&
name|DPLL_FPA01_P1_POST_DIV_MASK_I830
operator|)
operator|>>
name|DPLL_FPA01_P1_POST_DIV_SHIFT
operator|)
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|dpll
operator|&
name|PLL_P2_DIVIDE_BY_4
condition|)
name|clock
operator|.
name|p2
operator|=
literal|4
expr_stmt|;
else|else
name|clock
operator|.
name|p2
operator|=
literal|2
expr_stmt|;
name|intel_clock
argument_list|(
name|dev
argument_list|,
literal|48000
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* XXX: It would be nice to validate the clocks, but we can't reuse 	 * i830PllIsValid() because it relies on the xf86_config connector 	 * configuration being accurate, which it isn't necessarily. 	 */
return|return
name|clock
operator|.
name|dot
return|;
block|}
end_function

begin_comment
comment|/** Returns the currently programmed mode of the given pipe. */
end_comment

begin_function
name|struct
name|drm_display_mode
modifier|*
name|intel_crtc_mode_get
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|int
name|htot
init|=
name|I915_READ
argument_list|(
name|HTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|hsync
init|=
name|I915_READ
argument_list|(
name|HSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|vtot
init|=
name|I915_READ
argument_list|(
name|VTOTAL
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|vsync
init|=
name|I915_READ
argument_list|(
name|VSYNC
argument_list|(
name|pipe
argument_list|)
argument_list|)
decl_stmt|;
name|mode
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mode
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mode
operator|->
name|clock
operator|=
name|intel_crtc_clock_get
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
name|mode
operator|->
name|hdisplay
operator|=
operator|(
name|htot
operator|&
literal|0xffff
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|htotal
operator|=
operator|(
operator|(
name|htot
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|hsync_start
operator|=
operator|(
name|hsync
operator|&
literal|0xffff
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|hsync_end
operator|=
operator|(
operator|(
name|hsync
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|vdisplay
operator|=
operator|(
name|vtot
operator|&
literal|0xffff
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|vtotal
operator|=
operator|(
operator|(
name|vtot
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|vsync_start
operator|=
operator|(
name|vsync
operator|&
literal|0xffff
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|->
name|vsync_end
operator|=
operator|(
operator|(
name|vsync
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
name|drm_mode_set_name
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|mode
return|;
block|}
end_function

begin_define
define|#
directive|define
name|GPU_IDLE_TIMEOUT
value|(500
comment|/* ms */
value|* 1000 / hz)
end_define

begin_comment
comment|/* When this timer fires, we've been idle for awhile */
end_comment

begin_function
specifier|static
name|void
name|intel_gpu_idle_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|arg
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|active_list
argument_list|)
condition|)
block|{
comment|/* Still processing requests, so just re-arm the timer. */
name|callout_schedule
argument_list|(
operator|&
name|dev_priv
operator|->
name|idle_callout
argument_list|,
name|GPU_IDLE_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|dev_priv
operator|->
name|busy
operator|=
name|false
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|idle_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|CRTC_IDLE_TIMEOUT
value|(1000
comment|/* ms */
value|* 1000 / hz)
end_define

begin_function
specifier|static
name|void
name|intel_crtc_idle_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|arg
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
operator|&
name|intel_crtc
operator|->
name|base
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|crtc
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_fb
operator|&&
name|intel_fb
operator|->
name|obj
operator|->
name|active
condition|)
block|{
comment|/* The framebuffer is still being accessed by the GPU. */
name|callout_schedule
argument_list|(
operator|&
name|intel_crtc
operator|->
name|idle_callout
argument_list|,
name|CRTC_IDLE_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|intel_crtc
operator|->
name|busy
operator|=
name|false
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|idle_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_increase_pllclock
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|dpll_reg
init|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|int
name|dpll
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|lvds_downclock_avail
condition|)
return|return;
name|dpll
operator|=
name|I915_READ
argument_list|(
name|dpll_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HAS_PIPE_CXSR
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|dpll
operator|&
name|DISPLAY_RATE_SELECT_FPA1
operator|)
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"upclocking LVDS\n"
argument_list|)
expr_stmt|;
name|assert_panel_unlocked
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|dpll
operator|&=
operator|~
name|DISPLAY_RATE_SELECT_FPA1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|dpll_reg
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|dpll
operator|=
name|I915_READ
argument_list|(
name|dpll_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpll
operator|&
name|DISPLAY_RATE_SELECT_FPA1
condition|)
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"failed to upclock LVDS!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Schedule downclock */
name|callout_reset
argument_list|(
operator|&
name|intel_crtc
operator|->
name|idle_callout
argument_list|,
name|CRTC_IDLE_TIMEOUT
argument_list|,
name|intel_crtc_idle_timer
argument_list|,
name|intel_crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_decrease_pllclock
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|lvds_downclock_avail
condition|)
return|return;
comment|/* 	 * Since this is called by a timer, we should never get here in 	 * the manual case. 	 */
if|if
condition|(
operator|!
name|HAS_PIPE_CXSR
argument_list|(
name|dev
argument_list|)
operator|&&
name|intel_crtc
operator|->
name|lowfreq_avail
condition|)
block|{
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
name|int
name|dpll_reg
init|=
name|DPLL
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
name|u32
name|dpll
decl_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"downclocking LVDS\n"
argument_list|)
expr_stmt|;
name|assert_panel_unlocked
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|dpll
operator|=
name|I915_READ
argument_list|(
name|dpll_reg
argument_list|)
expr_stmt|;
name|dpll
operator||=
name|DISPLAY_RATE_SELECT_FPA1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|dpll_reg
argument_list|,
name|dpll
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|dpll
operator|=
name|I915_READ
argument_list|(
name|dpll_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dpll
operator|&
name|DISPLAY_RATE_SELECT_FPA1
operator|)
condition|)
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"failed to downclock LVDS!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * intel_idle_update - adjust clocks for idleness  * @work: work struct  *  * Either the GPU or display (or both) went idle.  Check the busy status  * here and adjust the CRTC and GPU clocks as necessary.  */
end_comment

begin_function
specifier|static
name|void
name|intel_idle_update
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|arg
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|dev_priv
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
if|if
condition|(
operator|!
name|i915_powersave
condition|)
return|return;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_update_gfx_val
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
comment|/* Skip inactive CRTCs */
if|if
condition|(
operator|!
name|crtc
operator|->
name|fb
condition|)
continue|continue;
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|busy
condition|)
name|intel_decrease_pllclock
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_mark_busy - mark the GPU and possibly the display busy  * @dev: drm device  * @obj: object we're operating on  *  * Callers can use this function to indicate that the GPU is busy processing  * commands.  If @obj matches one of the CRTC objects (i.e. it's a scanout  * buffer), we'll also mark the display as busy, so we know to increase its  * clock frequency.  */
end_comment

begin_function
name|void
name|intel_mark_busy
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|NULL
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|busy
condition|)
block|{
name|intel_sanitize_pm
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|busy
operator|=
name|true
expr_stmt|;
block|}
else|else
name|callout_reset
argument_list|(
operator|&
name|dev_priv
operator|->
name|idle_callout
argument_list|,
name|GPU_IDLE_TIMEOUT
argument_list|,
name|intel_gpu_idle_timer
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|!
name|crtc
operator|->
name|fb
condition|)
continue|continue;
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_fb
operator|->
name|obj
operator|==
name|obj
condition|)
block|{
if|if
condition|(
operator|!
name|intel_crtc
operator|->
name|busy
condition|)
block|{
comment|/* Non-busy -> busy, upclock */
name|intel_increase_pllclock
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|busy
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* Busy -> busy, put off timer */
name|callout_reset
argument_list|(
operator|&
name|intel_crtc
operator|->
name|idle_callout
argument_list|,
name|CRTC_IDLE_TIMEOUT
argument_list|,
name|intel_crtc_idle_timer
argument_list|,
name|intel_crtc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_destroy
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_unpin_work
modifier|*
name|work
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|work
operator|=
name|intel_crtc
operator|->
name|unpin_work
expr_stmt|;
name|intel_crtc
operator|->
name|unpin_work
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
condition|)
block|{
name|taskqueue_cancel
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|work
operator|->
name|task
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|work
operator|->
name|task
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
name|drm_crtc_cleanup
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intel_crtc
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_unpin_work_fn
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|intel_unpin_work
modifier|*
name|work
init|=
name|arg
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|work
operator|->
name|dev
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_unpin_fb_obj
argument_list|(
name|work
operator|->
name|old_fb_obj
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|work
operator|->
name|pending_flip_obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|intel_update_fbc
argument_list|(
name|work
operator|->
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_intel_finish_page_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_unpin_work
modifier|*
name|work
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_pending_vblank_event
modifier|*
name|e
decl_stmt|;
name|struct
name|timeval
name|tnow
decl_stmt|,
name|tvbl
decl_stmt|;
comment|/* Ignore early vblank irqs */
if|if
condition|(
name|intel_crtc
operator|==
name|NULL
condition|)
return|return;
name|microtime
argument_list|(
operator|&
name|tnow
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|work
operator|=
name|intel_crtc
operator|->
name|unpin_work
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|NULL
operator|||
operator|!
name|work
operator|->
name|pending
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|intel_crtc
operator|->
name|unpin_work
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|event
condition|)
block|{
name|e
operator|=
name|work
operator|->
name|event
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|sequence
operator|=
name|drm_vblank_count_and_time
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|,
operator|&
name|tvbl
argument_list|)
expr_stmt|;
comment|/* Called before vblank count and timestamps have 		 * been updated for the vblank interval of flip 		 * completion? Need to increment vblank count and 		 * add one videorefresh duration to returned timestamp 		 * to account for this. We assume this happened if we 		 * get called over 0.9 frame durations after the last 		 * timestamped vblank. 		 * 		 * This calculation can not be used with vrefresh rates 		 * below 5Hz (10Hz to be on the safe side) without 		 * promoting to 64 integers. 		 */
if|if
condition|(
literal|10
operator|*
operator|(
name|timeval_to_ns
argument_list|(
operator|&
name|tnow
argument_list|)
operator|-
name|timeval_to_ns
argument_list|(
operator|&
name|tvbl
argument_list|)
operator|)
operator|>
literal|9
operator|*
name|crtc
operator|->
name|framedur_ns
condition|)
block|{
name|e
operator|->
name|event
operator|.
name|sequence
operator|++
expr_stmt|;
name|tvbl
operator|=
name|ns_to_timeval
argument_list|(
name|timeval_to_ns
argument_list|(
operator|&
name|tvbl
argument_list|)
operator|+
name|crtc
operator|->
name|framedur_ns
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|event
operator|.
name|tv_sec
operator|=
name|tvbl
operator|.
name|tv_sec
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|tv_usec
operator|=
name|tvbl
operator|.
name|tv_usec
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|e
operator|->
name|base
operator|.
name|link
argument_list|,
operator|&
name|e
operator|->
name|base
operator|.
name|file_priv
operator|->
name|event_list
argument_list|)
expr_stmt|;
name|drm_event_wakeup
argument_list|(
operator|&
name|e
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|obj
operator|=
name|work
operator|->
name|old_fb_obj
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|,
literal|1
operator|<<
name|intel_crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|)
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|&
name|obj
operator|->
name|pending_flip
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|work
operator|->
name|task
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"i915_flip_complete %d %p"
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|,
name|work
operator|->
name|pending_flip_obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_finish_page_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|pipe
index|]
decl_stmt|;
name|do_intel_finish_page_flip
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_finish_page_flip_plane
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|dev_priv
operator|->
name|plane_to_crtc_mapping
index|[
name|plane
index|]
decl_stmt|;
name|do_intel_finish_page_flip
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_prepare_page_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|dev_priv
operator|->
name|plane_to_crtc_mapping
index|[
name|plane
index|]
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|unpin_work
condition|)
block|{
if|if
condition|(
operator|(
operator|++
name|intel_crtc
operator|->
name|unpin_work
operator|->
name|pending
operator|)
operator|>
literal|1
condition|)
name|DRM_ERROR
argument_list|(
literal|"Prepared flip multiple times\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG
argument_list|(
literal|"preparing flip with no unpin work?\n"
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_gen2_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|u32
name|flip_mask
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
comment|/* Offset into the new buffer for cases of shared fbs between CRTCs */
name|offset
operator|=
name|crtc
operator|->
name|y
operator|*
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|+
name|crtc
operator|->
name|x
operator|*
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
expr_stmt|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin
goto|;
comment|/* Can't queue multiple flips, so wait for the previous 	 * one to finish before executing the next. 	 */
if|if
condition|(
name|intel_crtc
operator|->
name|plane
condition|)
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_B_FLIP
expr_stmt|;
else|else
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_A_FLIP
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_WAIT_FOR_EVENT
operator||
name|flip_mask
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_NOOP
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_DISPLAY_FLIP
operator||
name|MI_DISPLAY_FLIP_PLANE
argument_list|(
name|intel_crtc
operator|->
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|obj
operator|->
name|gtt_offset
operator|+
name|offset
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* aux display base address, unused */
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin
label|:
name|intel_unpin_fb_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_gen3_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|u32
name|flip_mask
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
comment|/* Offset into the new buffer for cases of shared fbs between CRTCs */
name|offset
operator|=
name|crtc
operator|->
name|y
operator|*
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|+
name|crtc
operator|->
name|x
operator|*
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
expr_stmt|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin
goto|;
if|if
condition|(
name|intel_crtc
operator|->
name|plane
condition|)
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_B_FLIP
expr_stmt|;
else|else
name|flip_mask
operator|=
name|MI_WAIT_FOR_PLANE_A_FLIP
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_WAIT_FOR_EVENT
operator||
name|flip_mask
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_NOOP
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_DISPLAY_FLIP_I915
operator||
name|MI_DISPLAY_FLIP_PLANE
argument_list|(
name|intel_crtc
operator|->
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|obj
operator|->
name|gtt_offset
operator|+
name|offset
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_NOOP
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin
label|:
name|intel_unpin_fb_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_gen4_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|uint32_t
name|pf
decl_stmt|,
name|pipesrc
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin
goto|;
comment|/* i965+ uses the linear or tiled offsets from the 	 * Display Registers (which do not change across a page-flip) 	 * so we need only reprogram the base address. 	 */
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_DISPLAY_FLIP
operator||
name|MI_DISPLAY_FLIP_PLANE
argument_list|(
name|intel_crtc
operator|->
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|obj
operator|->
name|gtt_offset
operator||
name|obj
operator|->
name|tiling_mode
argument_list|)
expr_stmt|;
comment|/* XXX Enabling the panel-fitter across page-flip is so far 	 * untested on non-native modes, so ignore it for now. 	 * pf = I915_READ(pipe == 0 ? PFA_CTL_1 : PFB_CTL_1)& PF_ENABLE; 	 */
name|pf
operator|=
literal|0
expr_stmt|;
name|pipesrc
operator|=
name|I915_READ
argument_list|(
name|PIPESRC
argument_list|(
name|intel_crtc
operator|->
name|pipe
argument_list|)
argument_list|)
operator|&
literal|0x0fff0fff
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|pf
operator||
name|pipesrc
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin
label|:
name|intel_unpin_fb_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_gen6_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
decl_stmt|;
name|uint32_t
name|pf
decl_stmt|,
name|pipesrc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin
goto|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_DISPLAY_FLIP
operator||
name|MI_DISPLAY_FLIP_PLANE
argument_list|(
name|intel_crtc
operator|->
name|plane
argument_list|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator||
name|obj
operator|->
name|tiling_mode
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|obj
operator|->
name|gtt_offset
argument_list|)
expr_stmt|;
comment|/* Contrary to the suggestions in the documentation, 	 * "Enable Panel Fitter" does not seem to be required when page 	 * flipping with a non-native mode, and worse causes a normal 	 * modeset to fail. 	 * pf = I915_READ(PF_CTL(intel_crtc->pipe))& PF_ENABLE; 	 */
name|pf
operator|=
literal|0
expr_stmt|;
name|pipesrc
operator|=
name|I915_READ
argument_list|(
name|PIPESRC
argument_list|(
name|intel_crtc
operator|->
name|pipe
argument_list|)
argument_list|)
operator|&
literal|0x0fff0fff
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|pf
operator||
name|pipesrc
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin
label|:
name|intel_unpin_fb_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * On gen7 we currently use the blit ring because (in early silicon at least)  * the render ring doesn't give us interrpts for page flip completion, which  * means clients will hang after the first flip is queued.  Fortunately the  * blit ring generates interrupts properly, so use it instead.  */
end_comment

begin_function
specifier|static
name|int
name|intel_gen7_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|BCS
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_pin_and_fence_fb_obj
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin
goto|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_DISPLAY_FLIP_I915
operator||
operator|(
name|intel_crtc
operator|->
name|plane
operator|<<
literal|19
operator|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
operator|(
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator||
name|obj
operator|->
name|tiling_mode
operator|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
operator|(
name|obj
operator|->
name|gtt_offset
operator|)
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
operator|(
name|MI_NOOP
operator|)
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin
label|:
name|intel_unpin_fb_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_default_queue_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
return|return
operator|-
name|ENODEV
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_crtc_page_flip
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_pending_vblank_event
modifier|*
name|event
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|intel_unpin_work
modifier|*
name|work
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|work
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|work
operator|->
name|event
operator|=
name|event
expr_stmt|;
name|work
operator|->
name|dev
operator|=
name|crtc
operator|->
name|dev
expr_stmt|;
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
name|work
operator|->
name|old_fb_obj
operator|=
name|intel_fb
operator|->
name|obj
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|work
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|intel_unpin_work_fn
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_vblank_get
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|free_work
goto|;
comment|/* We borrow the event spin lock for protecting unpin_work */
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|unpin_work
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"flip queue: crtc already busy\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
name|intel_crtc
operator|->
name|unpin_work
operator|=
name|work
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|obj
operator|=
name|intel_fb
operator|->
name|obj
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Reference the objects for the scheduled work. */
name|drm_gem_object_reference
argument_list|(
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|drm_gem_object_reference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|fb
operator|=
name|fb
expr_stmt|;
name|work
operator|->
name|pending_flip_obj
operator|=
name|obj
expr_stmt|;
name|work
operator|->
name|enable_stall_check
operator|=
name|true
expr_stmt|;
comment|/* Block clients from rendering to the new back buffer until 	 * the flip occurs and the object is no longer visible. 	 */
name|atomic_set_int
argument_list|(
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|pending_flip
argument_list|,
literal|1
operator|<<
name|intel_crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
name|fb
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup_pending
goto|;
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_mark_busy
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"i915_flip_request %d %p"
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|cleanup_pending
label|:
name|atomic_clear_int
argument_list|(
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|pending_flip
argument_list|,
literal|1
operator|<<
name|intel_crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|work
operator|->
name|old_fb_obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|unpin_work
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|free_work
label|:
name|free
argument_list|(
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_sanitize_modesetting
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Clear any frame start delays used for debugging left by the BIOS */
name|for_each_pipe
argument_list|(
argument|i
argument_list|)
block|{
name|reg
operator|=
name|PIPECONF
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|I915_READ
argument_list|(
name|reg
argument_list|)
operator|&
operator|~
name|PIPECONF_FRAME_START_DELAY_MASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
comment|/* Who knows what state these registers were left in by the BIOS or 	 * grub? 	 * 	 * If we leave the registers in a conflicting state (e.g. with the 	 * display plane reading from the other pipe than the one we intend 	 * to use) then when we attempt to teardown the active mode, we will 	 * not disable the pipes and planes in the correct order -- leaving 	 * a plane reading from a disabled pipe and possibly leading to 	 * undefined behaviour. 	 */
name|reg
operator|=
name|DSPCNTR
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|DISPLAY_PLANE_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|!
operator|(
name|val
operator|&
name|DISPPLANE_SEL_PIPE_MASK
operator|)
operator|==
name|pipe
condition|)
return|return;
comment|/* This display plane is active and attached to the other CPU pipe. */
name|pipe
operator|=
operator|!
name|pipe
expr_stmt|;
comment|/* Disable the plane and wait for it to stop reading from the pipe. */
name|intel_disable_plane
argument_list|(
name|dev_priv
argument_list|,
name|plane
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|intel_disable_pipe
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_reset
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
comment|/* Reset flags back to the 'unknown' status so that they 	 * will be correctly set on the initial modeset. 	 */
name|intel_crtc
operator|->
name|dpms_mode
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We need to fix up any BIOS configuration that conflicts with 	 * our expectations. 	 */
name|intel_sanitize_modesetting
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|drm_crtc_helper_funcs
name|intel_helper_funcs
init|=
block|{
operator|.
name|dpms
operator|=
name|intel_crtc_dpms
block|,
operator|.
name|mode_fixup
operator|=
name|intel_crtc_mode_fixup
block|,
operator|.
name|mode_set
operator|=
name|intel_crtc_mode_set
block|,
operator|.
name|mode_set_base
operator|=
name|intel_pipe_set_base
block|,
operator|.
name|mode_set_base_atomic
operator|=
name|intel_pipe_set_base_atomic
block|,
operator|.
name|load_lut
operator|=
name|intel_crtc_load_lut
block|,
operator|.
name|disable
operator|=
name|intel_crtc_disable
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_crtc_funcs
name|intel_crtc_funcs
init|=
block|{
operator|.
name|reset
operator|=
name|intel_crtc_reset
block|,
operator|.
name|cursor_set
operator|=
name|intel_crtc_cursor_set
block|,
operator|.
name|cursor_move
operator|=
name|intel_crtc_cursor_move
block|,
operator|.
name|gamma_set
operator|=
name|intel_crtc_gamma_set
block|,
operator|.
name|set_config
operator|=
name|drm_crtc_helper_set_config
block|,
operator|.
name|destroy
operator|=
name|intel_crtc_destroy
block|,
operator|.
name|page_flip
operator|=
name|intel_crtc_page_flip
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|intel_pch_pll_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|num_pch_pll
operator|==
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"No PCH PLLs on this hardware, skipping initialisation\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|num_pch_pll
condition|;
name|i
operator|++
control|)
block|{
name|dev_priv
operator|->
name|pch_plls
index|[
name|i
index|]
operator|.
name|pll_reg
operator|=
name|_PCH_DPLL
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|pch_plls
index|[
name|i
index|]
operator|.
name|fp0_reg
operator|=
name|_PCH_FP0
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|pch_plls
index|[
name|i
index|]
operator|.
name|fp1_reg
operator|=
name|_PCH_FP1
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_crtc_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|intel_crtc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intel_crtc
argument_list|)
operator|+
operator|(
name|INTELFB_CONN_LIMIT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_connector
operator|*
argument_list|)
operator|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|drm_crtc_init
argument_list|(
name|dev
argument_list|,
operator|&
name|intel_crtc
operator|->
name|base
argument_list|,
operator|&
name|intel_crtc_funcs
argument_list|)
expr_stmt|;
name|drm_mode_crtc_set_gamma_size
argument_list|(
operator|&
name|intel_crtc
operator|->
name|base
argument_list|,
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|intel_crtc
operator|->
name|lut_r
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|intel_crtc
operator|->
name|lut_g
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|intel_crtc
operator|->
name|lut_b
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* Swap pipes& planes for FBC on pre-965 */
name|intel_crtc
operator|->
name|pipe
operator|=
name|pipe
expr_stmt|;
name|intel_crtc
operator|->
name|plane
operator|=
name|pipe
expr_stmt|;
if|if
condition|(
name|IS_MOBILE
argument_list|(
name|dev
argument_list|)
operator|&&
name|IS_GEN3
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"swapping pipes& planes for FBC\n"
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|plane
operator|=
operator|!
name|pipe
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|pipe
operator|<
name|DRM_ARRAY_SIZE
argument_list|(
name|dev_priv
operator|->
name|plane_to_crtc_mapping
argument_list|)
operator|&&
name|dev_priv
operator|->
name|plane_to_crtc_mapping
index|[
name|intel_crtc
operator|->
name|plane
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"plane_to_crtc is already initialized"
operator|)
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|plane_to_crtc_mapping
index|[
name|intel_crtc
operator|->
name|plane
index|]
operator|=
operator|&
name|intel_crtc
operator|->
name|base
expr_stmt|;
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
name|intel_crtc
operator|->
name|pipe
index|]
operator|=
operator|&
name|intel_crtc
operator|->
name|base
expr_stmt|;
name|intel_crtc_reset
argument_list|(
operator|&
name|intel_crtc
operator|->
name|base
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|active
operator|=
name|true
expr_stmt|;
comment|/* force the pipe off on setup_init_config */
name|intel_crtc
operator|->
name|bpp
operator|=
literal|24
expr_stmt|;
comment|/* default for pre-Ironlake */
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|intel_helper_funcs
operator|.
name|prepare
operator|=
name|ironlake_crtc_prepare
expr_stmt|;
name|intel_helper_funcs
operator|.
name|commit
operator|=
name|ironlake_crtc_commit
expr_stmt|;
block|}
else|else
block|{
name|intel_helper_funcs
operator|.
name|prepare
operator|=
name|i9xx_crtc_prepare
expr_stmt|;
name|intel_helper_funcs
operator|.
name|commit
operator|=
name|i9xx_crtc_commit
expr_stmt|;
block|}
name|drm_crtc_helper_add
argument_list|(
operator|&
name|intel_crtc
operator|->
name|base
argument_list|,
operator|&
name|intel_helper_funcs
argument_list|)
expr_stmt|;
name|intel_crtc
operator|->
name|busy
operator|=
name|false
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|intel_crtc
operator|->
name|idle_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|intel_get_pipe_from_crtc_id
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_get_pipe_from_crtc_id
modifier|*
name|pipe_from_crtc_id
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|drmmode_obj
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|crtc
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
name|drmmode_obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|pipe_from_crtc_id
operator|->
name|crtc_id
argument_list|,
name|DRM_MODE_OBJECT_CRTC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drmmode_obj
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"no such CRTC id\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|crtc
operator|=
name|to_intel_crtc
argument_list|(
name|obj_to_crtc
argument_list|(
name|drmmode_obj
argument_list|)
argument_list|)
expr_stmt|;
name|pipe_from_crtc_id
operator|->
name|pipe
operator|=
name|crtc
operator|->
name|pipe
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_encoder_clones
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|type_mask
parameter_list|)
block|{
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|int
name|index_mask
init|=
literal|0
decl_stmt|;
name|int
name|entry
init|=
literal|0
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
if|if
condition|(
name|type_mask
operator|&
name|encoder
operator|->
name|clone_mask
condition|)
name|index_mask
operator||=
operator|(
literal|1
operator|<<
name|entry
operator|)
expr_stmt|;
name|entry
operator|++
expr_stmt|;
block|}
return|return
name|index_mask
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|has_edp_a
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|IS_MOBILE
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|DP_A
argument_list|)
operator|&
name|DP_DETECTED
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN_FUSES
argument_list|)
operator|&
name|ILK_eDP_A_DISABLE
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_setup_outputs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|encoder
decl_stmt|;
name|bool
name|dpd_is_edp
init|=
name|false
decl_stmt|;
name|bool
name|has_lvds
decl_stmt|;
name|has_lvds
operator|=
name|intel_lvds_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_lvds
operator|&&
operator|!
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* disable the panel fitter on everything but LVDS */
name|I915_WRITE
argument_list|(
name|PFIT_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dpd_is_edp
operator|=
name|intel_dpd_is_edp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_edp_a
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|DP_A
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpd_is_edp
operator|&&
operator|(
name|I915_READ
argument_list|(
name|PCH_DP_D
argument_list|)
operator|&
name|DP_DETECTED
operator|)
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|PCH_DP_D
argument_list|)
expr_stmt|;
block|}
name|intel_crt_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|int
name|found
decl_stmt|;
comment|/* Haswell uses DDI functions to detect digital outputs */
name|found
operator|=
name|I915_READ
argument_list|(
name|DDI_BUF_CTL_A
argument_list|)
operator|&
name|DDI_INIT_DISPLAY_DETECTED
expr_stmt|;
comment|/* DDI A only supports eDP */
if|if
condition|(
name|found
condition|)
name|intel_ddi_init
argument_list|(
name|dev
argument_list|,
name|PORT_A
argument_list|)
expr_stmt|;
comment|/* DDI B, C and D detection is indicated by the SFUSE_STRAP 		 * register */
name|found
operator|=
name|I915_READ
argument_list|(
name|SFUSE_STRAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&
name|SFUSE_STRAP_DDIB_DETECTED
condition|)
name|intel_ddi_init
argument_list|(
name|dev
argument_list|,
name|PORT_B
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&
name|SFUSE_STRAP_DDIC_DETECTED
condition|)
name|intel_ddi_init
argument_list|(
name|dev
argument_list|,
name|PORT_C
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&
name|SFUSE_STRAP_DDID_DETECTED
condition|)
name|intel_ddi_init
argument_list|(
name|dev
argument_list|,
name|PORT_D
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|int
name|found
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"HDMIB %d PCH_DP_B %d HDMIC %d HDMID %d PCH_DP_C %d PCH_DP_D %d LVDS %d\n"
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|HDMIB
argument_list|)
operator|&
name|PORT_DETECTED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|PCH_DP_B
argument_list|)
operator|&
name|DP_DETECTED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|HDMIC
argument_list|)
operator|&
name|PORT_DETECTED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|HDMID
argument_list|)
operator|&
name|PORT_DETECTED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|PCH_DP_C
argument_list|)
operator|&
name|DP_DETECTED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|PCH_DP_D
argument_list|)
operator|&
name|DP_DETECTED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|PCH_LVDS
argument_list|)
operator|&
name|LVDS_DETECTED
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|HDMIB
argument_list|)
operator|&
name|PORT_DETECTED
condition|)
block|{
comment|/* PCH SDVOB multiplex with HDMIB */
name|found
operator|=
name|intel_sdvo_init
argument_list|(
name|dev
argument_list|,
name|PCH_SDVOB
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|HDMIB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
operator|&&
operator|(
name|I915_READ
argument_list|(
name|PCH_DP_B
argument_list|)
operator|&
name|DP_DETECTED
operator|)
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|PCH_DP_B
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|I915_READ
argument_list|(
name|HDMIC
argument_list|)
operator|&
name|PORT_DETECTED
condition|)
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|HDMIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|HDMID
argument_list|)
operator|&
name|PORT_DETECTED
condition|)
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|HDMID
argument_list|)
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|PCH_DP_C
argument_list|)
operator|&
name|DP_DETECTED
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|PCH_DP_C
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dpd_is_edp
operator|&&
operator|(
name|I915_READ
argument_list|(
name|PCH_DP_D
argument_list|)
operator|&
name|DP_DETECTED
operator|)
condition|)
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|PCH_DP_D
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SUPPORTS_DIGITAL_OUTPUTS
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|bool
name|found
init|=
name|false
decl_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|SDVOB
argument_list|)
operator|&
name|SDVO_DETECTED
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing SDVOB\n"
argument_list|)
expr_stmt|;
name|found
operator|=
name|intel_sdvo_init
argument_list|(
name|dev
argument_list|,
name|SDVOB
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
operator|&&
name|SUPPORTS_INTEGRATED_HDMI
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing HDMI on SDVOB\n"
argument_list|)
expr_stmt|;
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|SDVOB
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
operator|&&
name|SUPPORTS_INTEGRATED_DP
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing DP_B\n"
argument_list|)
expr_stmt|;
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|DP_B
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Before G4X SDVOC doesn't have its own detect register */
if|if
condition|(
name|I915_READ
argument_list|(
name|SDVOB
argument_list|)
operator|&
name|SDVO_DETECTED
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing SDVOC\n"
argument_list|)
expr_stmt|;
name|found
operator|=
name|intel_sdvo_init
argument_list|(
name|dev
argument_list|,
name|SDVOC
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
operator|&&
operator|(
name|I915_READ
argument_list|(
name|SDVOC
argument_list|)
operator|&
name|SDVO_DETECTED
operator|)
condition|)
block|{
if|if
condition|(
name|SUPPORTS_INTEGRATED_HDMI
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing HDMI on SDVOC\n"
argument_list|)
expr_stmt|;
name|intel_hdmi_init
argument_list|(
name|dev
argument_list|,
name|SDVOC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUPPORTS_INTEGRATED_DP
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing DP_C\n"
argument_list|)
expr_stmt|;
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|DP_C
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SUPPORTS_INTEGRATED_DP
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|I915_READ
argument_list|(
name|DP_D
argument_list|)
operator|&
name|DP_DETECTED
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"probing DP_D\n"
argument_list|)
expr_stmt|;
name|intel_dp_init
argument_list|(
name|dev
argument_list|,
name|DP_D
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|#
directive|if
literal|1
name|KIB_NOTYET
argument_list|()
expr_stmt|;
else|#
directive|else
name|intel_dvo_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|SUPPORTS_TV
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_tv_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|base.head
argument_list|)
block|{
name|encoder
operator|->
name|base
operator|.
name|possible_crtcs
operator|=
name|encoder
operator|->
name|crtc_mask
expr_stmt|;
name|encoder
operator|->
name|base
operator|.
name|possible_clones
operator|=
name|intel_encoder_clones
argument_list|(
name|dev
argument_list|,
name|encoder
operator|->
name|clone_mask
argument_list|)
expr_stmt|;
block|}
comment|/* disable all the possible outputs/crtcs before entering KMS mode */
name|drm_helper_disable_unused_functions
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|ironlake_init_pch_refclk
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_user_framebuffer_destroy
parameter_list|(
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|)
block|{
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
init|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
decl_stmt|;
name|drm_framebuffer_cleanup
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference_unlocked
argument_list|(
operator|&
name|intel_fb
operator|->
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intel_fb
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_user_framebuffer_create_handle
parameter_list|(
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
init|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|intel_fb
operator|->
name|obj
decl_stmt|;
return|return
name|drm_gem_handle_create
argument_list|(
name|file
argument_list|,
operator|&
name|obj
operator|->
name|base
argument_list|,
name|handle
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_framebuffer_funcs
name|intel_fb_funcs
init|=
block|{
operator|.
name|destroy
operator|=
name|intel_user_framebuffer_destroy
block|,
operator|.
name|create_handle
operator|=
name|intel_user_framebuffer_create_handle
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|intel_framebuffer_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
parameter_list|,
name|struct
name|drm_mode_fb_cmd2
modifier|*
name|mode_cmd
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_Y
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|mode_cmd
operator|->
name|pitches
index|[
literal|0
index|]
operator|&
literal|63
condition|)
return|return
operator|-
name|EINVAL
return|;
switch|switch
condition|(
name|mode_cmd
operator|->
name|pixel_format
condition|)
block|{
case|case
name|DRM_FORMAT_RGB332
case|:
case|case
name|DRM_FORMAT_RGB565
case|:
case|case
name|DRM_FORMAT_XRGB8888
case|:
case|case
name|DRM_FORMAT_XBGR8888
case|:
case|case
name|DRM_FORMAT_ARGB8888
case|:
case|case
name|DRM_FORMAT_XRGB2101010
case|:
case|case
name|DRM_FORMAT_ARGB2101010
case|:
comment|/* RGB formats are common across chipsets */
break|break;
case|case
name|DRM_FORMAT_YUYV
case|:
case|case
name|DRM_FORMAT_UYVY
case|:
case|case
name|DRM_FORMAT_YVYU
case|:
case|case
name|DRM_FORMAT_VYUY
case|:
break|break;
default|default:
name|DRM_DEBUG_KMS
argument_list|(
literal|"unsupported pixel format %u\n"
argument_list|,
name|mode_cmd
operator|->
name|pixel_format
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|ret
operator|=
name|drm_framebuffer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|intel_fb
operator|->
name|base
argument_list|,
operator|&
name|intel_fb_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"framebuffer init failed %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|drm_helper_mode_fill_fb_struct
argument_list|(
operator|&
name|intel_fb
operator|->
name|base
argument_list|,
name|mode_cmd
argument_list|)
expr_stmt|;
name|intel_fb
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_user_framebuffer_create
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|filp
parameter_list|,
name|struct
name|drm_mode_fb_cmd2
modifier|*
name|mode_cmd
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|,
name|mode_cmd
operator|->
name|handles
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOENT
operator|)
return|;
return|return
operator|(
name|intel_framebuffer_create
argument_list|(
name|dev
argument_list|,
name|mode_cmd
argument_list|,
name|obj
argument_list|,
name|res
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_mode_config_funcs
name|intel_mode_funcs
init|=
block|{
operator|.
name|fb_create
operator|=
name|intel_user_framebuffer_create
block|,
operator|.
name|output_poll_changed
operator|=
name|intel_fb_output_poll_changed
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up chip specific display functions */
end_comment

begin_function
specifier|static
name|void
name|intel_init_display
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* We always want a DPMS function */
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|dpms
operator|=
name|ironlake_crtc_dpms
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|crtc_mode_set
operator|=
name|ironlake_crtc_mode_set
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|off
operator|=
name|ironlake_crtc_off
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_plane
operator|=
name|ironlake_update_plane
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|display
operator|.
name|dpms
operator|=
name|i9xx_crtc_dpms
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|crtc_mode_set
operator|=
name|i9xx_crtc_mode_set
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|off
operator|=
name|i9xx_crtc_off
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_plane
operator|=
name|i9xx_update_plane
expr_stmt|;
block|}
comment|/* Returns the core display clock speed */
if|if
condition|(
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|valleyview_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
operator|(
name|IS_G33
argument_list|(
name|dev
argument_list|)
operator|&&
operator|!
name|IS_PINEVIEW_M
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i945_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I915G
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i915_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_845G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_PINEVIEW_M
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i9xx_misc_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I915GM
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i915gm_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I865G
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i865_get_display_clock_speed
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I85X
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i855_get_display_clock_speed
expr_stmt|;
else|else
comment|/* 852, 830 */
name|dev_priv
operator|->
name|display
operator|.
name|get_display_clock_speed
operator|=
name|i830_get_display_clock_speed
expr_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
operator|=
name|ironlake_fdi_link_train
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
operator|=
name|ironlake_write_eld
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
operator|=
name|gen6_fdi_link_train
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
operator|=
name|ironlake_write_eld
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* FIXME: detect B0+ stepping and use auto training */
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
operator|=
name|ivb_manual_fdi_link_train
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
operator|=
name|ironlake_write_eld
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|fdi_link_train
operator|=
name|hsw_fdi_link_train
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
operator|=
name|ironlake_write_eld
expr_stmt|;
block|}
else|else
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|force_wake_get
operator|=
name|vlv_force_wake_get
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|force_wake_put
operator|=
name|vlv_force_wake_put
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|write_eld
operator|=
name|g4x_write_eld
expr_stmt|;
block|}
comment|/* Default just returns -ENODEV to indicate unsupported */
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_default_queue_flip
expr_stmt|;
switch|switch
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
condition|)
block|{
case|case
literal|2
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen2_queue_flip
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen3_queue_flip
expr_stmt|;
break|break;
case|case
literal|4
case|:
case|case
literal|5
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen4_queue_flip
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen6_queue_flip
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|dev_priv
operator|->
name|display
operator|.
name|queue_flip
operator|=
name|intel_gen7_queue_flip
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Some BIOSes insist on assuming the GPU's pipe A is enabled at suspend,  * resume, or other times.  This quirk makes sure that's the case for  * affected systems.  */
end_comment

begin_function
specifier|static
name|void
name|quirk_pipea_force
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|quirks
operator||=
name|QUIRK_PIPEA_FORCE
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"applying pipe a force quirk\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Some machines (Lenovo U160) do not work with SSC on LVDS for some reason  */
end_comment

begin_function
specifier|static
name|void
name|quirk_ssc_force_disable
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|quirks
operator||=
name|QUIRK_LVDS_SSC_DISABLE
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"applying lvds SSC disable quirk\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A machine (e.g. Acer Aspire 5734Z) may need to invert the panel backlight  * brightness value  */
end_comment

begin_function
specifier|static
name|void
name|quirk_invert_brightness
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|quirks
operator||=
name|QUIRK_INVERT_BRIGHTNESS
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"applying inverted panel brightness quirk\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|intel_quirk
block|{
name|int
name|device
decl_stmt|;
name|int
name|subsystem_vendor
decl_stmt|;
name|int
name|subsystem_device
decl_stmt|;
name|void
function_decl|(
modifier|*
name|hook
function_decl|)
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PCI_ANY_ID
value|(~0u)
end_define

begin_decl_stmt
specifier|static
name|struct
name|intel_quirk
name|intel_quirks
index|[]
init|=
block|{
comment|/* HP Mini needs pipe A force quirk (LP: #322104) */
block|{
literal|0x27ae
block|,
literal|0x103c
block|,
literal|0x361a
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* Thinkpad R31 needs pipe A force quirk */
block|{
literal|0x3577
block|,
literal|0x1014
block|,
literal|0x0505
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* Toshiba Protege R-205, S-209 needs pipe A force quirk */
block|{
literal|0x2592
block|,
literal|0x1179
block|,
literal|0x0001
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* ThinkPad X30 needs pipe A force quirk (LP: #304614) */
block|{
literal|0x3577
block|,
literal|0x1014
block|,
literal|0x0513
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* ThinkPad X40 needs pipe A force quirk */
comment|/* ThinkPad T60 needs pipe A force quirk (bug #16494) */
block|{
literal|0x2782
block|,
literal|0x17aa
block|,
literal|0x201a
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* 855& before need to leave pipe A& dpll A up */
block|{
literal|0x3582
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
name|quirk_pipea_force
block|}
block|,
block|{
literal|0x2562
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
name|quirk_pipea_force
block|}
block|,
comment|/* Lenovo U160 cannot use SSC on LVDS */
block|{
literal|0x0046
block|,
literal|0x17aa
block|,
literal|0x3920
block|,
name|quirk_ssc_force_disable
block|}
block|,
comment|/* Sony Vaio Y cannot use SSC on LVDS */
block|{
literal|0x0046
block|,
literal|0x104d
block|,
literal|0x9076
block|,
name|quirk_ssc_force_disable
block|}
block|,
comment|/* Acer Aspire 5734Z must invert backlight brightness */
block|{
literal|0x2a42
block|,
literal|0x1025
block|,
literal|0x0459
block|,
name|quirk_invert_brightness
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|intel_init_quirks
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|intel_quirk
modifier|*
name|q
decl_stmt|;
name|device_t
name|d
decl_stmt|;
name|int
name|i
decl_stmt|;
name|d
operator|=
name|dev
operator|->
name|device
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_ARRAY_SIZE
argument_list|(
name|intel_quirks
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|q
operator|=
operator|&
name|intel_quirks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pci_get_device
argument_list|(
name|d
argument_list|)
operator|==
name|q
operator|->
name|device
operator|&&
operator|(
name|pci_get_subvendor
argument_list|(
name|d
argument_list|)
operator|==
name|q
operator|->
name|subsystem_vendor
operator|||
name|q
operator|->
name|subsystem_vendor
operator|==
name|PCI_ANY_ID
operator|)
operator|&&
operator|(
name|pci_get_subdevice
argument_list|(
name|d
argument_list|)
operator|==
name|q
operator|->
name|subsystem_device
operator|||
name|q
operator|->
name|subsystem_device
operator|==
name|PCI_ANY_ID
operator|)
condition|)
name|q
operator|->
name|hook
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Disable the VGA plane that we never use */
end_comment

begin_function
specifier|static
name|void
name|i915_disable_vga
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u8
name|sr1
decl_stmt|;
name|u32
name|vga_reg
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|vga_reg
operator|=
name|CPU_VGACNTRL
expr_stmt|;
else|else
name|vga_reg
operator|=
name|VGACNTRL
expr_stmt|;
if|#
directive|if
literal|0
block|vga_get_uninterruptible(dev->pdev, VGA_RSRC_LEGACY_IO);
endif|#
directive|endif
name|outb
argument_list|(
name|VGA_SR_INDEX
argument_list|,
name|SR01
argument_list|)
expr_stmt|;
name|sr1
operator|=
name|inb
argument_list|(
name|VGA_SR_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|VGA_SR_DATA
argument_list|,
name|sr1
operator||
literal|1
operator|<<
literal|5
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|vga_put(dev->pdev, VGA_RSRC_LEGACY_IO);
endif|#
directive|endif
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|vga_reg
argument_list|,
name|VGA_DISP_DISABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|vga_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ivb_pch_pwm_override
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* 	 * IVB has CPU eDP backlight regs too, set things up to let the 	 * PCH regs control the backlight 	 */
name|I915_WRITE
argument_list|(
name|BLC_PWM_CPU_CTL2
argument_list|,
name|PWM_ENABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|BLC_PWM_CPU_CTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|BLC_PWM_PCH_CTL1
argument_list|,
name|PWM_ENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_modeset_init_hw
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|intel_init_clock_gating
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IRONLAKE_M
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ironlake_enable_drps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ironlake_enable_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_init_emon
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
operator|!
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|gen6_enable_rps
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|gen6_update_ring_freq
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
name|ivb_pch_pwm_override
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_modeset_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|drm_mode_config_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|min_width
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|min_height
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|preferred_depth
operator|=
literal|24
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|prefer_shadow
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|funcs
operator|=
operator|&
name|intel_mode_funcs
expr_stmt|;
name|intel_init_quirks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_init_pm
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_prepare_ddi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_init_display
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|mode_config
operator|.
name|max_width
operator|=
literal|2048
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|max_height
operator|=
literal|2048
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN3
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|mode_config
operator|.
name|max_width
operator|=
literal|4096
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|max_height
operator|=
literal|4096
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|mode_config
operator|.
name|max_width
operator|=
literal|8192
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|max_height
operator|=
literal|8192
expr_stmt|;
block|}
name|dev
operator|->
name|mode_config
operator|.
name|fb_base
operator|=
name|dev
operator|->
name|agp
operator|->
name|base
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"%d display pipe%s available.\n"
argument_list|,
name|dev_priv
operator|->
name|num_pipe
argument_list|,
name|dev_priv
operator|->
name|num_pipe
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|num_pipe
condition|;
name|i
operator|++
control|)
block|{
name|intel_crtc_init
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_plane_init
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"plane %d init failed: %d\n"
argument_list|,
name|i
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
name|intel_pch_pll_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Just disable it once at startup */
name|i915_disable_vga
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_setup_outputs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|dev_priv
operator|->
name|idle_task
argument_list|,
literal|0
argument_list|,
name|intel_idle_update
argument_list|,
name|dev_priv
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|dev_priv
operator|->
name|idle_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_modeset_gem_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|intel_modeset_init_hw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_setup_overlay
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_modeset_cleanup
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
name|drm_kms_helper_poll_fini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|intel_unregister_dsm_handler();
endif|#
directive|endif
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
comment|/* Skip inactive CRTCs */
if|if
condition|(
operator|!
name|crtc
operator|->
name|fb
condition|)
continue|continue;
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|intel_increase_pllclock
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IRONLAKE_M
argument_list|(
name|dev
argument_list|)
condition|)
name|ironlake_disable_drps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
operator|!
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|gen6_disable_rps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IRONLAKE_M
argument_list|(
name|dev
argument_list|)
condition|)
name|ironlake_disable_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|vlv_init_dpio
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Disable the irq before mode object teardown, for the irq might 	 * enqueue unpin/hotplug work. */
name|drm_irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskqueue_cancel
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|hotplug_task
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|hotplug_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskqueue_cancel
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|rps_task
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|rps_task
argument_list|)
expr_stmt|;
comment|/* Shut off idle work before the crtcs get freed. */
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|intel_crtc
operator|->
name|idle_callout
argument_list|)
expr_stmt|;
block|}
name|callout_drain
argument_list|(
operator|&
name|dev_priv
operator|->
name|idle_callout
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskqueue_cancel
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|idle_task
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|idle_task
argument_list|)
expr_stmt|;
name|drm_mode_config_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return which encoder is currently attached for connector.  */
end_comment

begin_function
name|struct
name|drm_encoder
modifier|*
name|intel_best_encoder
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
return|return
operator|&
name|intel_attached_encoder
argument_list|(
name|connector
argument_list|)
operator|->
name|base
return|;
block|}
end_function

begin_function
name|void
name|intel_connector_attach_encoder
parameter_list|(
name|struct
name|intel_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|intel_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|connector
operator|->
name|encoder
operator|=
name|encoder
expr_stmt|;
name|drm_mode_connector_attach_encoder
argument_list|(
operator|&
name|connector
operator|->
name|base
argument_list|,
operator|&
name|encoder
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set vga decode state - true == enable VGA decode  */
end_comment

begin_function
name|int
name|intel_modeset_vga_set_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|device_t
name|bridge_dev
decl_stmt|;
name|u16
name|gmch_ctrl
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|bridge_dev
operator|=
name|intel_gtt_get_bridge_device
argument_list|()
expr_stmt|;
name|gmch_ctrl
operator|=
name|pci_read_config
argument_list|(
name|bridge_dev
argument_list|,
name|INTEL_GMCH_CTRL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
name|gmch_ctrl
operator|&=
operator|~
name|INTEL_GMCH_VGA_DISABLE
expr_stmt|;
else|else
name|gmch_ctrl
operator||=
name|INTEL_GMCH_VGA_DISABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|bridge_dev
argument_list|,
name|INTEL_GMCH_CTRL
argument_list|,
name|gmch_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|intel_display_error_state
block|{
struct|struct
name|intel_cursor_error_state
block|{
name|u32
name|control
decl_stmt|;
name|u32
name|position
decl_stmt|;
name|u32
name|base
decl_stmt|;
name|u32
name|size
decl_stmt|;
block|}
name|cursor
index|[
literal|2
index|]
struct|;
struct|struct
name|intel_pipe_error_state
block|{
name|u32
name|conf
decl_stmt|;
name|u32
name|source
decl_stmt|;
name|u32
name|htotal
decl_stmt|;
name|u32
name|hblank
decl_stmt|;
name|u32
name|hsync
decl_stmt|;
name|u32
name|vtotal
decl_stmt|;
name|u32
name|vblank
decl_stmt|;
name|u32
name|vsync
decl_stmt|;
block|}
name|pipe
index|[
literal|2
index|]
struct|;
struct|struct
name|intel_plane_error_state
block|{
name|u32
name|control
decl_stmt|;
name|u32
name|stride
decl_stmt|;
name|u32
name|size
decl_stmt|;
name|u32
name|pos
decl_stmt|;
name|u32
name|addr
decl_stmt|;
name|u32
name|surface
decl_stmt|;
name|u32
name|tile_offset
decl_stmt|;
block|}
name|plane
index|[
literal|2
index|]
struct|;
block|}
struct|;
end_struct

begin_function
name|struct
name|intel_display_error_state
modifier|*
name|intel_display_capture_error_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_display_error_state
modifier|*
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|error
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|error
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|control
operator|=
name|I915_READ
argument_list|(
name|CURCNTR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|position
operator|=
name|I915_READ
argument_list|(
name|CURPOS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|base
operator|=
name|I915_READ
argument_list|(
name|CURBASE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|control
operator|=
name|I915_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|stride
operator|=
name|I915_READ
argument_list|(
name|DSPSTRIDE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|size
operator|=
name|I915_READ
argument_list|(
name|DSPSIZE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|pos
operator|=
name|I915_READ
argument_list|(
name|DSPPOS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|I915_READ
argument_list|(
name|DSPADDR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|surface
operator|=
name|I915_READ
argument_list|(
name|DSPSURF
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|tile_offset
operator|=
name|I915_READ
argument_list|(
name|DSPTILEOFF
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|conf
operator|=
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|source
operator|=
name|I915_READ
argument_list|(
name|PIPESRC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|htotal
operator|=
name|I915_READ
argument_list|(
name|HTOTAL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|hblank
operator|=
name|I915_READ
argument_list|(
name|HBLANK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|hsync
operator|=
name|I915_READ
argument_list|(
name|HSYNC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vtotal
operator|=
name|I915_READ
argument_list|(
name|VTOTAL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vblank
operator|=
name|I915_READ
argument_list|(
name|VBLANK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vsync
operator|=
name|I915_READ
argument_list|(
name|VSYNC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|intel_display_print_error_state
parameter_list|(
name|struct
name|sbuf
modifier|*
name|m
parameter_list|,
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|intel_display_error_state
modifier|*
name|error
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"Pipe [%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  CONF: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|conf
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  SRC: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|source
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  HTOTAL: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|htotal
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  HBLANK: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|hblank
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  HSYNC: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|hsync
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  VTOTAL: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vtotal
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  VBLANK: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vblank
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  VSYNC: %08x\n"
argument_list|,
name|error
operator|->
name|pipe
index|[
name|i
index|]
operator|.
name|vsync
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"Plane [%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  CNTR: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|control
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  STRIDE: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|stride
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  SIZE: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  POS: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|pos
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  ADDR: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  SURF: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|surface
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  TILEOFF: %08x\n"
argument_list|,
name|error
operator|->
name|plane
index|[
name|i
index|]
operator|.
name|tile_offset
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"Cursor [%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  CNTR: %08x\n"
argument_list|,
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|control
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  POS: %08x\n"
argument_list|,
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|position
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  BASE: %08x\n"
argument_list|,
name|error
operator|->
name|cursor
index|[
name|i
index|]
operator|.
name|base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

