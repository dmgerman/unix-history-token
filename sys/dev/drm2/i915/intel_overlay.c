begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Â© 2009  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  * Authors:  *    Daniel Vetter<daniel@ffwll.ch>  *  * Derived from Xorg ddx, xf86-video-intel, src/i830_video.c  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_comment
comment|/* Limits for overlay size. According to intel doc, the real limits are:  * Y width: 4095, UV width (planar): 2047, Y height: 2047,  * UV width (planar): * 1023. But the xorg thinks 2048 for height and width. Use  * the mininum of both.  */
end_comment

begin_define
define|#
directive|define
name|IMAGE_MAX_WIDTH
value|2048
end_define

begin_define
define|#
directive|define
name|IMAGE_MAX_HEIGHT
value|2046
end_define

begin_comment
comment|/* 2 * 1023 */
end_comment

begin_comment
comment|/* on 830 and 845 these large limits result in the card hanging */
end_comment

begin_define
define|#
directive|define
name|IMAGE_MAX_WIDTH_LEGACY
value|1024
end_define

begin_define
define|#
directive|define
name|IMAGE_MAX_HEIGHT_LEGACY
value|1088
end_define

begin_comment
comment|/* overlay register definitions */
end_comment

begin_comment
comment|/* OCMD register */
end_comment

begin_define
define|#
directive|define
name|OCMD_TILED_SURFACE
value|(0x1<<19)
end_define

begin_define
define|#
directive|define
name|OCMD_MIRROR_MASK
value|(0x3<<17)
end_define

begin_define
define|#
directive|define
name|OCMD_MIRROR_MODE
value|(0x3<<17)
end_define

begin_define
define|#
directive|define
name|OCMD_MIRROR_HORIZONTAL
value|(0x1<<17)
end_define

begin_define
define|#
directive|define
name|OCMD_MIRROR_VERTICAL
value|(0x2<<17)
end_define

begin_define
define|#
directive|define
name|OCMD_MIRROR_BOTH
value|(0x3<<17)
end_define

begin_define
define|#
directive|define
name|OCMD_BYTEORDER_MASK
value|(0x3<<14)
end_define

begin_comment
comment|/* zero for YUYV or FOURCC YUY2 */
end_comment

begin_define
define|#
directive|define
name|OCMD_UV_SWAP
value|(0x1<<14)
end_define

begin_comment
comment|/* YVYU */
end_comment

begin_define
define|#
directive|define
name|OCMD_Y_SWAP
value|(0x2<<14)
end_define

begin_comment
comment|/* UYVY or FOURCC UYVY */
end_comment

begin_define
define|#
directive|define
name|OCMD_Y_AND_UV_SWAP
value|(0x3<<14)
end_define

begin_comment
comment|/* VYUY */
end_comment

begin_define
define|#
directive|define
name|OCMD_SOURCE_FORMAT_MASK
value|(0xf<<10)
end_define

begin_define
define|#
directive|define
name|OCMD_RGB_888
value|(0x1<<10)
end_define

begin_comment
comment|/* not in i965 Intel docs */
end_comment

begin_define
define|#
directive|define
name|OCMD_RGB_555
value|(0x2<<10)
end_define

begin_comment
comment|/* not in i965 Intel docs */
end_comment

begin_define
define|#
directive|define
name|OCMD_RGB_565
value|(0x3<<10)
end_define

begin_comment
comment|/* not in i965 Intel docs */
end_comment

begin_define
define|#
directive|define
name|OCMD_YUV_422_PACKED
value|(0x8<<10)
end_define

begin_define
define|#
directive|define
name|OCMD_YUV_411_PACKED
value|(0x9<<10)
end_define

begin_comment
comment|/* not in i965 Intel docs */
end_comment

begin_define
define|#
directive|define
name|OCMD_YUV_420_PLANAR
value|(0xc<<10)
end_define

begin_define
define|#
directive|define
name|OCMD_YUV_422_PLANAR
value|(0xd<<10)
end_define

begin_define
define|#
directive|define
name|OCMD_YUV_410_PLANAR
value|(0xe<<10)
end_define

begin_comment
comment|/* also 411 */
end_comment

begin_define
define|#
directive|define
name|OCMD_TVSYNCFLIP_PARITY
value|(0x1<<9)
end_define

begin_define
define|#
directive|define
name|OCMD_TVSYNCFLIP_ENABLE
value|(0x1<<7)
end_define

begin_define
define|#
directive|define
name|OCMD_BUF_TYPE_MASK
value|(0x1<<5)
end_define

begin_define
define|#
directive|define
name|OCMD_BUF_TYPE_FRAME
value|(0x0<<5)
end_define

begin_define
define|#
directive|define
name|OCMD_BUF_TYPE_FIELD
value|(0x1<<5)
end_define

begin_define
define|#
directive|define
name|OCMD_TEST_MODE
value|(0x1<<4)
end_define

begin_define
define|#
directive|define
name|OCMD_BUFFER_SELECT
value|(0x3<<2)
end_define

begin_define
define|#
directive|define
name|OCMD_BUFFER0
value|(0x0<<2)
end_define

begin_define
define|#
directive|define
name|OCMD_BUFFER1
value|(0x1<<2)
end_define

begin_define
define|#
directive|define
name|OCMD_FIELD_SELECT
value|(0x1<<2)
end_define

begin_define
define|#
directive|define
name|OCMD_FIELD0
value|(0x0<<1)
end_define

begin_define
define|#
directive|define
name|OCMD_FIELD1
value|(0x1<<1)
end_define

begin_define
define|#
directive|define
name|OCMD_ENABLE
value|(0x1<<0)
end_define

begin_comment
comment|/* OCONFIG register */
end_comment

begin_define
define|#
directive|define
name|OCONF_PIPE_MASK
value|(0x1<<18)
end_define

begin_define
define|#
directive|define
name|OCONF_PIPE_A
value|(0x0<<18)
end_define

begin_define
define|#
directive|define
name|OCONF_PIPE_B
value|(0x1<<18)
end_define

begin_define
define|#
directive|define
name|OCONF_GAMMA2_ENABLE
value|(0x1<<16)
end_define

begin_define
define|#
directive|define
name|OCONF_CSC_MODE_BT601
value|(0x0<<5)
end_define

begin_define
define|#
directive|define
name|OCONF_CSC_MODE_BT709
value|(0x1<<5)
end_define

begin_define
define|#
directive|define
name|OCONF_CSC_BYPASS
value|(0x1<<4)
end_define

begin_define
define|#
directive|define
name|OCONF_CC_OUT_8BIT
value|(0x1<<3)
end_define

begin_define
define|#
directive|define
name|OCONF_TEST_MODE
value|(0x1<<2)
end_define

begin_define
define|#
directive|define
name|OCONF_THREE_LINE_BUFFER
value|(0x1<<0)
end_define

begin_define
define|#
directive|define
name|OCONF_TWO_LINE_BUFFER
value|(0x0<<0)
end_define

begin_comment
comment|/* DCLRKM (dst-key) register */
end_comment

begin_define
define|#
directive|define
name|DST_KEY_ENABLE
value|(0x1<<31)
end_define

begin_define
define|#
directive|define
name|CLK_RGB24_MASK
value|0x0
end_define

begin_define
define|#
directive|define
name|CLK_RGB16_MASK
value|0x070307
end_define

begin_define
define|#
directive|define
name|CLK_RGB15_MASK
value|0x070707
end_define

begin_define
define|#
directive|define
name|CLK_RGB8I_MASK
value|0xffffff
end_define

begin_define
define|#
directive|define
name|RGB16_TO_COLORKEY
parameter_list|(
name|c
parameter_list|)
define|\
value|(((c& 0xF800)<< 8) | ((c& 0x07E0)<< 5) | ((c& 0x001F)<< 3))
end_define

begin_define
define|#
directive|define
name|RGB15_TO_COLORKEY
parameter_list|(
name|c
parameter_list|)
define|\
value|(((c& 0x7c00)<< 9) | ((c& 0x03E0)<< 6) | ((c& 0x001F)<< 3))
end_define

begin_comment
comment|/* overlay flip addr flag */
end_comment

begin_define
define|#
directive|define
name|OFC_UPDATE
value|0x1
end_define

begin_comment
comment|/* polyphase filter coefficients */
end_comment

begin_define
define|#
directive|define
name|N_HORIZ_Y_TAPS
value|5
end_define

begin_define
define|#
directive|define
name|N_VERT_Y_TAPS
value|3
end_define

begin_define
define|#
directive|define
name|N_HORIZ_UV_TAPS
value|3
end_define

begin_define
define|#
directive|define
name|N_VERT_UV_TAPS
value|3
end_define

begin_define
define|#
directive|define
name|N_PHASES
value|17
end_define

begin_define
define|#
directive|define
name|MAX_TAPS
value|5
end_define

begin_comment
comment|/* memory bufferd overlay registers */
end_comment

begin_struct
struct|struct
name|overlay_registers
block|{
name|u32
name|OBUF_0Y
decl_stmt|;
name|u32
name|OBUF_1Y
decl_stmt|;
name|u32
name|OBUF_0U
decl_stmt|;
name|u32
name|OBUF_0V
decl_stmt|;
name|u32
name|OBUF_1U
decl_stmt|;
name|u32
name|OBUF_1V
decl_stmt|;
name|u32
name|OSTRIDE
decl_stmt|;
name|u32
name|YRGB_VPH
decl_stmt|;
name|u32
name|UV_VPH
decl_stmt|;
name|u32
name|HORZ_PH
decl_stmt|;
name|u32
name|INIT_PHS
decl_stmt|;
name|u32
name|DWINPOS
decl_stmt|;
name|u32
name|DWINSZ
decl_stmt|;
name|u32
name|SWIDTH
decl_stmt|;
name|u32
name|SWIDTHSW
decl_stmt|;
name|u32
name|SHEIGHT
decl_stmt|;
name|u32
name|YRGBSCALE
decl_stmt|;
name|u32
name|UVSCALE
decl_stmt|;
name|u32
name|OCLRC0
decl_stmt|;
name|u32
name|OCLRC1
decl_stmt|;
name|u32
name|DCLRKV
decl_stmt|;
name|u32
name|DCLRKM
decl_stmt|;
name|u32
name|SCLRKVH
decl_stmt|;
name|u32
name|SCLRKVL
decl_stmt|;
name|u32
name|SCLRKEN
decl_stmt|;
name|u32
name|OCONFIG
decl_stmt|;
name|u32
name|OCMD
decl_stmt|;
name|u32
name|RESERVED1
decl_stmt|;
comment|/* 0x6C */
name|u32
name|OSTART_0Y
decl_stmt|;
name|u32
name|OSTART_1Y
decl_stmt|;
name|u32
name|OSTART_0U
decl_stmt|;
name|u32
name|OSTART_0V
decl_stmt|;
name|u32
name|OSTART_1U
decl_stmt|;
name|u32
name|OSTART_1V
decl_stmt|;
name|u32
name|OTILEOFF_0Y
decl_stmt|;
name|u32
name|OTILEOFF_1Y
decl_stmt|;
name|u32
name|OTILEOFF_0U
decl_stmt|;
name|u32
name|OTILEOFF_0V
decl_stmt|;
name|u32
name|OTILEOFF_1U
decl_stmt|;
name|u32
name|OTILEOFF_1V
decl_stmt|;
name|u32
name|FASTHSCALE
decl_stmt|;
comment|/* 0xA0 */
name|u32
name|UVSCALEV
decl_stmt|;
comment|/* 0xA4 */
name|u32
name|RESERVEDC
index|[
operator|(
literal|0x200
operator|-
literal|0xA8
operator|)
operator|/
literal|4
index|]
decl_stmt|;
comment|/* 0xA8 - 0x1FC */
name|u16
name|Y_VCOEFS
index|[
name|N_VERT_Y_TAPS
operator|*
name|N_PHASES
index|]
decl_stmt|;
comment|/* 0x200 */
name|u16
name|RESERVEDD
index|[
literal|0x100
operator|/
literal|2
operator|-
name|N_VERT_Y_TAPS
operator|*
name|N_PHASES
index|]
decl_stmt|;
name|u16
name|Y_HCOEFS
index|[
name|N_HORIZ_Y_TAPS
operator|*
name|N_PHASES
index|]
decl_stmt|;
comment|/* 0x300 */
name|u16
name|RESERVEDE
index|[
literal|0x200
operator|/
literal|2
operator|-
name|N_HORIZ_Y_TAPS
operator|*
name|N_PHASES
index|]
decl_stmt|;
name|u16
name|UV_VCOEFS
index|[
name|N_VERT_UV_TAPS
operator|*
name|N_PHASES
index|]
decl_stmt|;
comment|/* 0x500 */
name|u16
name|RESERVEDF
index|[
literal|0x100
operator|/
literal|2
operator|-
name|N_VERT_UV_TAPS
operator|*
name|N_PHASES
index|]
decl_stmt|;
name|u16
name|UV_HCOEFS
index|[
name|N_HORIZ_UV_TAPS
operator|*
name|N_PHASES
index|]
decl_stmt|;
comment|/* 0x600 */
name|u16
name|RESERVEDG
index|[
literal|0x100
operator|/
literal|2
operator|-
name|N_HORIZ_UV_TAPS
operator|*
name|N_PHASES
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|intel_overlay
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|vid_bo
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|old_vid_bo
decl_stmt|;
name|int
name|active
decl_stmt|;
name|int
name|pfit_active
decl_stmt|;
name|u32
name|pfit_vscale_ratio
decl_stmt|;
comment|/* shifted-point number, (1<<12) == 1.0 */
name|u32
name|color_key
decl_stmt|;
name|u32
name|brightness
decl_stmt|,
name|contrast
decl_stmt|,
name|saturation
decl_stmt|;
name|u32
name|old_xscale
decl_stmt|,
name|old_yscale
decl_stmt|;
comment|/* register access */
name|u32
name|flip_addr
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|reg_bo
decl_stmt|;
comment|/* flip handling */
name|uint32_t
name|last_flip_req
decl_stmt|;
name|void
function_decl|(
modifier|*
name|flip_tail
function_decl|)
parameter_list|(
name|struct
name|intel_overlay
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|overlay_registers
modifier|*
name|intel_overlay_map_regs
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|)
block|{
name|struct
name|overlay_registers
modifier|*
name|regs
decl_stmt|;
if|if
condition|(
name|OVERLAY_NEEDS_PHYSICAL
argument_list|(
name|overlay
operator|->
name|dev
argument_list|)
condition|)
block|{
name|regs
operator|=
name|overlay
operator|->
name|reg_bo
operator|->
name|phys_obj
operator|->
name|handle
operator|->
name|vaddr
expr_stmt|;
block|}
else|else
block|{
name|regs
operator|=
name|pmap_mapdev_attr
argument_list|(
name|overlay
operator|->
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|overlay
operator|->
name|reg_bo
operator|->
name|gtt_offset
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|regs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_overlay_unmap_regs
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|,
name|struct
name|overlay_registers
modifier|*
name|regs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|OVERLAY_NEEDS_PHYSICAL
argument_list|(
name|overlay
operator|->
name|dev
argument_list|)
condition|)
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|regs
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_overlay_do_wait_request
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|,
name|struct
name|drm_i915_gem_request
modifier|*
name|request
parameter_list|,
name|void
function_decl|(
modifier|*
name|tail
function_decl|)
parameter_list|(
name|struct
name|intel_overlay
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|overlay
operator|->
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|overlay
operator|->
name|last_flip_req
argument_list|,
operator|(
literal|"Overlay already has flip req"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_add_request
argument_list|(
name|ring
argument_list|,
name|NULL
argument_list|,
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|overlay
operator|->
name|last_flip_req
operator|=
name|request
operator|->
name|seqno
expr_stmt|;
name|overlay
operator|->
name|flip_tail
operator|=
name|tail
expr_stmt|;
name|ret
operator|=
name|i915_wait_request
argument_list|(
name|ring
argument_list|,
name|overlay
operator|->
name|last_flip_req
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_retire_requests
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|overlay
operator|->
name|last_flip_req
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Workaround for i830 bug where pipe a must be enable to change control regs */
end_comment

begin_function
specifier|static
name|int
name|i830_activate_pipe_a
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_crtc_helper_funcs
modifier|*
name|crtc_funcs
decl_stmt|;
name|struct
name|drm_display_mode
name|vesa_640x480
init|=
block|{
name|DRM_MODE
argument_list|(
literal|"640x480"
argument_list|,
argument|DRM_MODE_TYPE_DRIVER
argument_list|,
literal|25175
argument_list|,
literal|640
argument_list|,
literal|656
argument_list|,
literal|752
argument_list|,
literal|800
argument_list|,
literal|0
argument_list|,
literal|480
argument_list|,
literal|489
argument_list|,
literal|492
argument_list|,
literal|525
argument_list|,
literal|0
argument_list|,
argument|DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC
argument_list|)
block|}
decl_stmt|,
modifier|*
name|mode
decl_stmt|;
name|crtc
operator|=
name|to_intel_crtc
argument_list|(
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|dpms_mode
operator|==
name|DRM_MODE_DPMS_ON
condition|)
return|return
literal|0
return|;
comment|/* most i8xx have pipe a forced on, so don't trust dpms mode */
if|if
condition|(
name|I915_READ
argument_list|(
name|_PIPEACONF
argument_list|)
operator|&
name|PIPECONF_ENABLE
condition|)
return|return
literal|0
return|;
name|crtc_funcs
operator|=
name|crtc
operator|->
name|base
operator|.
name|helper_private
expr_stmt|;
if|if
condition|(
name|crtc_funcs
operator|->
name|dpms
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"Enabling pipe A in order to enable overlay\n"
argument_list|)
expr_stmt|;
name|mode
operator|=
name|drm_mode_duplicate
argument_list|(
name|dev
argument_list|,
operator|&
name|vesa_640x480
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drm_crtc_helper_set_mode
argument_list|(
operator|&
name|crtc
operator|->
name|base
argument_list|,
name|mode
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|x
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|y
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|fb
argument_list|)
condition|)
return|return
literal|0
return|;
name|crtc_funcs
operator|->
name|dpms
argument_list|(
operator|&
name|crtc
operator|->
name|base
argument_list|,
name|DRM_MODE_DPMS_ON
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i830_deactivate_pipe_a
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|dev_priv
operator|->
name|pipe_to_crtc_mapping
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|drm_crtc_helper_funcs
modifier|*
name|crtc_funcs
init|=
name|crtc
operator|->
name|helper_private
decl_stmt|;
name|crtc_funcs
operator|->
name|dpms
argument_list|(
name|crtc
argument_list|,
name|DRM_MODE_DPMS_OFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* overlay needs to be disable in OCMD reg */
end_comment

begin_function
specifier|static
name|int
name|intel_overlay_on
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|overlay
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
decl_stmt|;
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|int
name|pipe_a_quirk
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|overlay
operator|->
name|active
argument_list|,
operator|(
literal|"Overlay is active"
operator|)
argument_list|)
expr_stmt|;
name|overlay
operator|->
name|active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_I830
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|pipe_a_quirk
operator|=
name|i830_activate_pipe_a
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe_a_quirk
operator|<
literal|0
condition|)
return|return
name|pipe_a_quirk
return|;
block|}
name|request
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_OVERLAY_FLIP
operator||
name|MI_OVERLAY_ON
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|overlay
operator|->
name|flip_addr
operator||
name|OFC_UPDATE
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_WAIT_FOR_EVENT
operator||
name|MI_WAIT_FOR_OVERLAY_FLIP
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_NOOP
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_overlay_do_wait_request
argument_list|(
name|overlay
argument_list|,
name|request
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|pipe_a_quirk
condition|)
name|i830_deactivate_pipe_a
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* overlay needs to be enabled in OCMD reg */
end_comment

begin_function
specifier|static
name|int
name|intel_overlay_continue
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|,
name|bool
name|load_polyphase_filter
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|overlay
operator|->
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
decl_stmt|;
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|u32
name|flip_addr
init|=
name|overlay
operator|->
name|flip_addr
decl_stmt|;
name|u32
name|tmp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|KASSERT
argument_list|(
name|overlay
operator|->
name|active
argument_list|,
operator|(
literal|"Overlay not active"
operator|)
argument_list|)
expr_stmt|;
name|request
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_polyphase_filter
condition|)
name|flip_addr
operator||=
name|OFC_UPDATE
expr_stmt|;
comment|/* check for underruns */
name|tmp
operator|=
name|I915_READ
argument_list|(
name|DOVSTA
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
operator|(
literal|1
operator|<<
literal|17
operator|)
condition|)
name|DRM_DEBUG
argument_list|(
literal|"overlay underrun, DOVSTA: %x\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_OVERLAY_FLIP
operator||
name|MI_OVERLAY_CONTINUE
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|flip_addr
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_add_request
argument_list|(
name|ring
argument_list|,
name|NULL
argument_list|,
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|overlay
operator|->
name|last_flip_req
operator|=
name|request
operator|->
name|seqno
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_overlay_release_old_vid_tail
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|overlay
operator|->
name|old_vid_bo
decl_stmt|;
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|overlay
operator|->
name|old_vid_bo
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_overlay_off_tail
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|overlay
operator|->
name|vid_bo
decl_stmt|;
comment|/* never have the overlay hw on without showing a frame */
name|KASSERT
argument_list|(
name|overlay
operator|->
name|vid_bo
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No vid_bo"
operator|)
argument_list|)
expr_stmt|;
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|overlay
operator|->
name|vid_bo
operator|=
name|NULL
expr_stmt|;
name|overlay
operator|->
name|crtc
operator|->
name|overlay
operator|=
name|NULL
expr_stmt|;
name|overlay
operator|->
name|crtc
operator|=
name|NULL
expr_stmt|;
name|overlay
operator|->
name|active
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* overlay needs to be disabled in OCMD reg */
end_comment

begin_function
specifier|static
name|int
name|intel_overlay_off
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|overlay
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
decl_stmt|;
name|u32
name|flip_addr
init|=
name|overlay
operator|->
name|flip_addr
decl_stmt|;
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|KASSERT
argument_list|(
name|overlay
operator|->
name|active
argument_list|,
operator|(
literal|"Overlay is not active"
operator|)
argument_list|)
expr_stmt|;
name|request
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* According to intel docs the overlay hw may hang (when switching 	 * off) without loading the filter coeffs. It is however unclear whether 	 * this applies to the disabling of the overlay or to the switching off 	 * of the hw. Do it in both cases */
name|flip_addr
operator||=
name|OFC_UPDATE
expr_stmt|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* wait for overlay to go idle */
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_OVERLAY_FLIP
operator||
name|MI_OVERLAY_CONTINUE
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|flip_addr
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_WAIT_FOR_EVENT
operator||
name|MI_WAIT_FOR_OVERLAY_FLIP
argument_list|)
expr_stmt|;
comment|/* turn overlay off */
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_OVERLAY_FLIP
operator||
name|MI_OVERLAY_OFF
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|flip_addr
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_WAIT_FOR_EVENT
operator||
name|MI_WAIT_FOR_OVERLAY_FLIP
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
name|intel_overlay_do_wait_request
argument_list|(
name|overlay
argument_list|,
name|request
argument_list|,
name|intel_overlay_off_tail
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* recover from an interruption due to a signal  * We have to be careful not to repeat work forever an make forward progess. */
end_comment

begin_function
specifier|static
name|int
name|intel_overlay_recover_from_interrupt
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|overlay
operator|->
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|overlay
operator|->
name|last_flip_req
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|i915_wait_request
argument_list|(
name|ring
argument_list|,
name|overlay
operator|->
name|last_flip_req
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_retire_requests
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|overlay
operator|->
name|flip_tail
condition|)
name|overlay
operator|->
name|flip_tail
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
name|overlay
operator|->
name|last_flip_req
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Wait for pending overlay flip and release old frame.  * Needs to be called before the overlay register are changed  * via intel_overlay_(un)map_regs  */
end_comment

begin_function
specifier|static
name|int
name|intel_overlay_release_old_vid
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|overlay
operator|->
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Only wait if there is actually an old frame to release to 	 * guarantee forward progress. 	 */
if|if
condition|(
operator|!
name|overlay
operator|->
name|old_vid_bo
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|I915_READ
argument_list|(
name|ISR
argument_list|)
operator|&
name|I915_OVERLAY_PLANE_FLIP_PENDING_INTERRUPT
condition|)
block|{
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
comment|/* synchronous slowpath */
name|request
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_WAIT_FOR_EVENT
operator||
name|MI_WAIT_FOR_OVERLAY_FLIP
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_NOOP
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_overlay_do_wait_request
argument_list|(
name|overlay
argument_list|,
name|request
argument_list|,
name|intel_overlay_release_old_vid_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|intel_overlay_release_old_vid_tail
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|put_image_params
block|{
name|int
name|format
decl_stmt|;
name|short
name|dst_x
decl_stmt|;
name|short
name|dst_y
decl_stmt|;
name|short
name|dst_w
decl_stmt|;
name|short
name|dst_h
decl_stmt|;
name|short
name|src_w
decl_stmt|;
name|short
name|src_scan_h
decl_stmt|;
name|short
name|src_scan_w
decl_stmt|;
name|short
name|src_h
decl_stmt|;
name|short
name|stride_Y
decl_stmt|;
name|short
name|stride_UV
decl_stmt|;
name|int
name|offset_Y
decl_stmt|;
name|int
name|offset_U
decl_stmt|;
name|int
name|offset_V
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|packed_depth_bytes
parameter_list|(
name|u32
name|format
parameter_list|)
block|{
switch|switch
condition|(
name|format
operator|&
name|I915_OVERLAY_DEPTH_MASK
condition|)
block|{
case|case
name|I915_OVERLAY_YUV422
case|:
return|return
literal|4
return|;
case|case
name|I915_OVERLAY_YUV411
case|:
comment|/* return 6; not implemented */
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|packed_width_bytes
parameter_list|(
name|u32
name|format
parameter_list|,
name|short
name|width
parameter_list|)
block|{
switch|switch
condition|(
name|format
operator|&
name|I915_OVERLAY_DEPTH_MASK
condition|)
block|{
case|case
name|I915_OVERLAY_YUV422
case|:
return|return
name|width
operator|<<
literal|1
return|;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|uv_hsubsampling
parameter_list|(
name|u32
name|format
parameter_list|)
block|{
switch|switch
condition|(
name|format
operator|&
name|I915_OVERLAY_DEPTH_MASK
condition|)
block|{
case|case
name|I915_OVERLAY_YUV422
case|:
case|case
name|I915_OVERLAY_YUV420
case|:
return|return
literal|2
return|;
case|case
name|I915_OVERLAY_YUV411
case|:
case|case
name|I915_OVERLAY_YUV410
case|:
return|return
literal|4
return|;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|uv_vsubsampling
parameter_list|(
name|u32
name|format
parameter_list|)
block|{
switch|switch
condition|(
name|format
operator|&
name|I915_OVERLAY_DEPTH_MASK
condition|)
block|{
case|case
name|I915_OVERLAY_YUV420
case|:
case|case
name|I915_OVERLAY_YUV410
case|:
return|return
literal|2
return|;
case|case
name|I915_OVERLAY_YUV422
case|:
case|case
name|I915_OVERLAY_YUV411
case|:
return|return
literal|1
return|;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|u32
name|calc_swidthsw
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|width
parameter_list|)
block|{
name|u32
name|mask
decl_stmt|,
name|shift
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mask
operator|=
literal|0x1f
expr_stmt|;
name|shift
operator|=
literal|5
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
literal|0x3f
expr_stmt|;
name|shift
operator|=
literal|6
expr_stmt|;
block|}
name|ret
operator|=
operator|(
operator|(
name|offset
operator|+
name|width
operator|+
name|mask
operator|)
operator|>>
name|shift
operator|)
operator|-
operator|(
name|offset
operator|>>
name|shift
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|ret
operator|<<=
literal|1
expr_stmt|;
name|ret
operator|-=
literal|1
expr_stmt|;
return|return
name|ret
operator|<<
literal|2
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|u16
name|y_static_hcoeffs
index|[
name|N_HORIZ_Y_TAPS
operator|*
name|N_PHASES
index|]
init|=
block|{
literal|0x3000
block|,
literal|0xb4a0
block|,
literal|0x1930
block|,
literal|0x1920
block|,
literal|0xb4a0
block|,
literal|0x3000
block|,
literal|0xb500
block|,
literal|0x19d0
block|,
literal|0x1880
block|,
literal|0xb440
block|,
literal|0x3000
block|,
literal|0xb540
block|,
literal|0x1a88
block|,
literal|0x2f80
block|,
literal|0xb3e0
block|,
literal|0x3000
block|,
literal|0xb580
block|,
literal|0x1b30
block|,
literal|0x2e20
block|,
literal|0xb380
block|,
literal|0x3000
block|,
literal|0xb5c0
block|,
literal|0x1bd8
block|,
literal|0x2cc0
block|,
literal|0xb320
block|,
literal|0x3020
block|,
literal|0xb5e0
block|,
literal|0x1c60
block|,
literal|0x2b80
block|,
literal|0xb2c0
block|,
literal|0x3020
block|,
literal|0xb5e0
block|,
literal|0x1cf8
block|,
literal|0x2a20
block|,
literal|0xb260
block|,
literal|0x3020
block|,
literal|0xb5e0
block|,
literal|0x1d80
block|,
literal|0x28e0
block|,
literal|0xb200
block|,
literal|0x3020
block|,
literal|0xb5c0
block|,
literal|0x1e08
block|,
literal|0x3f40
block|,
literal|0xb1c0
block|,
literal|0x3020
block|,
literal|0xb580
block|,
literal|0x1e78
block|,
literal|0x3ce0
block|,
literal|0xb160
block|,
literal|0x3040
block|,
literal|0xb520
block|,
literal|0x1ed8
block|,
literal|0x3aa0
block|,
literal|0xb120
block|,
literal|0x3040
block|,
literal|0xb4a0
block|,
literal|0x1f30
block|,
literal|0x3880
block|,
literal|0xb0e0
block|,
literal|0x3040
block|,
literal|0xb400
block|,
literal|0x1f78
block|,
literal|0x3680
block|,
literal|0xb0a0
block|,
literal|0x3020
block|,
literal|0xb340
block|,
literal|0x1fb8
block|,
literal|0x34a0
block|,
literal|0xb060
block|,
literal|0x3020
block|,
literal|0xb240
block|,
literal|0x1fe0
block|,
literal|0x32e0
block|,
literal|0xb040
block|,
literal|0x3020
block|,
literal|0xb140
block|,
literal|0x1ff8
block|,
literal|0x3160
block|,
literal|0xb020
block|,
literal|0xb000
block|,
literal|0x3000
block|,
literal|0x0800
block|,
literal|0x3000
block|,
literal|0xb000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u16
name|uv_static_hcoeffs
index|[
name|N_HORIZ_UV_TAPS
operator|*
name|N_PHASES
index|]
init|=
block|{
literal|0x3000
block|,
literal|0x1800
block|,
literal|0x1800
block|,
literal|0xb000
block|,
literal|0x18d0
block|,
literal|0x2e60
block|,
literal|0xb000
block|,
literal|0x1990
block|,
literal|0x2ce0
block|,
literal|0xb020
block|,
literal|0x1a68
block|,
literal|0x2b40
block|,
literal|0xb040
block|,
literal|0x1b20
block|,
literal|0x29e0
block|,
literal|0xb060
block|,
literal|0x1bd8
block|,
literal|0x2880
block|,
literal|0xb080
block|,
literal|0x1c88
block|,
literal|0x3e60
block|,
literal|0xb0a0
block|,
literal|0x1d28
block|,
literal|0x3c00
block|,
literal|0xb0c0
block|,
literal|0x1db8
block|,
literal|0x39e0
block|,
literal|0xb0e0
block|,
literal|0x1e40
block|,
literal|0x37e0
block|,
literal|0xb100
block|,
literal|0x1eb8
block|,
literal|0x3620
block|,
literal|0xb100
block|,
literal|0x1f18
block|,
literal|0x34a0
block|,
literal|0xb100
block|,
literal|0x1f68
block|,
literal|0x3360
block|,
literal|0xb0e0
block|,
literal|0x1fa8
block|,
literal|0x3240
block|,
literal|0xb0c0
block|,
literal|0x1fe0
block|,
literal|0x3140
block|,
literal|0xb060
block|,
literal|0x1ff0
block|,
literal|0x30a0
block|,
literal|0x3000
block|,
literal|0x0800
block|,
literal|0x3000
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|update_polyphase_filter
parameter_list|(
name|struct
name|overlay_registers
modifier|*
name|regs
parameter_list|)
block|{
name|memcpy
argument_list|(
name|regs
operator|->
name|Y_HCOEFS
argument_list|,
name|y_static_hcoeffs
argument_list|,
sizeof|sizeof
argument_list|(
name|y_static_hcoeffs
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|regs
operator|->
name|UV_HCOEFS
argument_list|,
name|uv_static_hcoeffs
argument_list|,
sizeof|sizeof
argument_list|(
name|uv_static_hcoeffs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|update_scaling_factors
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|,
name|struct
name|overlay_registers
modifier|*
name|regs
parameter_list|,
name|struct
name|put_image_params
modifier|*
name|params
parameter_list|)
block|{
comment|/* fixed point with a 12 bit shift */
name|u32
name|xscale
decl_stmt|,
name|yscale
decl_stmt|,
name|xscale_UV
decl_stmt|,
name|yscale_UV
decl_stmt|;
define|#
directive|define
name|FP_SHIFT
value|12
define|#
directive|define
name|FRACT_MASK
value|0xfff
name|bool
name|scale_changed
init|=
name|false
decl_stmt|;
name|int
name|uv_hscale
init|=
name|uv_hsubsampling
argument_list|(
name|params
operator|->
name|format
argument_list|)
decl_stmt|;
name|int
name|uv_vscale
init|=
name|uv_vsubsampling
argument_list|(
name|params
operator|->
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|params
operator|->
name|dst_w
operator|>
literal|1
condition|)
name|xscale
operator|=
operator|(
operator|(
name|params
operator|->
name|src_scan_w
operator|-
literal|1
operator|)
operator|<<
name|FP_SHIFT
operator|)
operator|/
operator|(
name|params
operator|->
name|dst_w
operator|)
expr_stmt|;
else|else
name|xscale
operator|=
literal|1
operator|<<
name|FP_SHIFT
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|dst_h
operator|>
literal|1
condition|)
name|yscale
operator|=
operator|(
operator|(
name|params
operator|->
name|src_scan_h
operator|-
literal|1
operator|)
operator|<<
name|FP_SHIFT
operator|)
operator|/
operator|(
name|params
operator|->
name|dst_h
operator|)
expr_stmt|;
else|else
name|yscale
operator|=
literal|1
operator|<<
name|FP_SHIFT
expr_stmt|;
comment|/*if (params->format& I915_OVERLAY_YUV_PLANAR) {*/
name|xscale_UV
operator|=
name|xscale
operator|/
name|uv_hscale
expr_stmt|;
name|yscale_UV
operator|=
name|yscale
operator|/
name|uv_vscale
expr_stmt|;
comment|/* make the Y scale to UV scale ratio an exact multiply */
name|xscale
operator|=
name|xscale_UV
operator|*
name|uv_hscale
expr_stmt|;
name|yscale
operator|=
name|yscale_UV
operator|*
name|uv_vscale
expr_stmt|;
comment|/*} else { 	  xscale_UV = 0; 	  yscale_UV = 0; 	  }*/
if|if
condition|(
name|xscale
operator|!=
name|overlay
operator|->
name|old_xscale
operator|||
name|yscale
operator|!=
name|overlay
operator|->
name|old_yscale
condition|)
name|scale_changed
operator|=
name|true
expr_stmt|;
name|overlay
operator|->
name|old_xscale
operator|=
name|xscale
expr_stmt|;
name|overlay
operator|->
name|old_yscale
operator|=
name|yscale
expr_stmt|;
name|regs
operator|->
name|YRGBSCALE
operator|=
operator|(
operator|(
operator|(
name|yscale
operator|&
name|FRACT_MASK
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
name|xscale
operator|>>
name|FP_SHIFT
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|xscale
operator|&
name|FRACT_MASK
operator|)
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|regs
operator|->
name|UVSCALE
operator|=
operator|(
operator|(
operator|(
name|yscale_UV
operator|&
name|FRACT_MASK
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
name|xscale_UV
operator|>>
name|FP_SHIFT
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|xscale_UV
operator|&
name|FRACT_MASK
operator|)
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|regs
operator|->
name|UVSCALEV
operator|=
operator|(
operator|(
operator|(
operator|(
name|yscale
operator|>>
name|FP_SHIFT
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|yscale_UV
operator|>>
name|FP_SHIFT
operator|)
operator|<<
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|scale_changed
condition|)
name|update_polyphase_filter
argument_list|(
name|regs
argument_list|)
expr_stmt|;
return|return
name|scale_changed
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_colorkey
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|,
name|struct
name|overlay_registers
modifier|*
name|regs
parameter_list|)
block|{
name|u32
name|key
init|=
name|overlay
operator|->
name|color_key
decl_stmt|;
switch|switch
condition|(
name|overlay
operator|->
name|crtc
operator|->
name|base
operator|.
name|fb
operator|->
name|bits_per_pixel
condition|)
block|{
case|case
literal|8
case|:
name|regs
operator|->
name|DCLRKV
operator|=
literal|0
expr_stmt|;
name|regs
operator|->
name|DCLRKM
operator|=
name|CLK_RGB8I_MASK
operator||
name|DST_KEY_ENABLE
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|overlay
operator|->
name|crtc
operator|->
name|base
operator|.
name|fb
operator|->
name|depth
operator|==
literal|15
condition|)
block|{
name|regs
operator|->
name|DCLRKV
operator|=
name|RGB15_TO_COLORKEY
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|regs
operator|->
name|DCLRKM
operator|=
name|CLK_RGB15_MASK
operator||
name|DST_KEY_ENABLE
expr_stmt|;
block|}
else|else
block|{
name|regs
operator|->
name|DCLRKV
operator|=
name|RGB16_TO_COLORKEY
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|regs
operator|->
name|DCLRKM
operator|=
name|CLK_RGB16_MASK
operator||
name|DST_KEY_ENABLE
expr_stmt|;
block|}
break|break;
case|case
literal|24
case|:
case|case
literal|32
case|:
name|regs
operator|->
name|DCLRKV
operator|=
name|key
expr_stmt|;
name|regs
operator|->
name|DCLRKM
operator|=
name|CLK_RGB24_MASK
operator||
name|DST_KEY_ENABLE
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|u32
name|overlay_cmd_reg
parameter_list|(
name|struct
name|put_image_params
modifier|*
name|params
parameter_list|)
block|{
name|u32
name|cmd
init|=
name|OCMD_ENABLE
operator||
name|OCMD_BUF_TYPE_FRAME
operator||
name|OCMD_BUFFER0
decl_stmt|;
if|if
condition|(
name|params
operator|->
name|format
operator|&
name|I915_OVERLAY_YUV_PLANAR
condition|)
block|{
switch|switch
condition|(
name|params
operator|->
name|format
operator|&
name|I915_OVERLAY_DEPTH_MASK
condition|)
block|{
case|case
name|I915_OVERLAY_YUV422
case|:
name|cmd
operator||=
name|OCMD_YUV_422_PLANAR
expr_stmt|;
break|break;
case|case
name|I915_OVERLAY_YUV420
case|:
name|cmd
operator||=
name|OCMD_YUV_420_PLANAR
expr_stmt|;
break|break;
case|case
name|I915_OVERLAY_YUV411
case|:
case|case
name|I915_OVERLAY_YUV410
case|:
name|cmd
operator||=
name|OCMD_YUV_410_PLANAR
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* YUV packed */
switch|switch
condition|(
name|params
operator|->
name|format
operator|&
name|I915_OVERLAY_DEPTH_MASK
condition|)
block|{
case|case
name|I915_OVERLAY_YUV422
case|:
name|cmd
operator||=
name|OCMD_YUV_422_PACKED
expr_stmt|;
break|break;
case|case
name|I915_OVERLAY_YUV411
case|:
name|cmd
operator||=
name|OCMD_YUV_411_PACKED
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|params
operator|->
name|format
operator|&
name|I915_OVERLAY_SWAP_MASK
condition|)
block|{
case|case
name|I915_OVERLAY_NO_SWAP
case|:
break|break;
case|case
name|I915_OVERLAY_UV_SWAP
case|:
name|cmd
operator||=
name|OCMD_UV_SWAP
expr_stmt|;
break|break;
case|case
name|I915_OVERLAY_Y_SWAP
case|:
name|cmd
operator||=
name|OCMD_Y_SWAP
expr_stmt|;
break|break;
case|case
name|I915_OVERLAY_Y_AND_UV_SWAP
case|:
name|cmd
operator||=
name|OCMD_Y_AND_UV_SWAP
expr_stmt|;
break|break;
block|}
block|}
return|return
name|cmd
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|max_u32
parameter_list|(
name|u32
name|a
parameter_list|,
name|u32
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|>
name|b
condition|?
name|a
else|:
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_overlay_do_put_image
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|new_bo
parameter_list|,
name|struct
name|put_image_params
modifier|*
name|params
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|tmp_width
decl_stmt|;
name|struct
name|overlay_registers
modifier|*
name|regs
decl_stmt|;
name|bool
name|scale_changed
init|=
name|false
decl_stmt|;
name|u32
name|swidth
decl_stmt|,
name|swidthsw
decl_stmt|,
name|sheight
decl_stmt|,
name|ostride
decl_stmt|;
name|KASSERT
argument_list|(
name|overlay
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No overlay ?"
operator|)
argument_list|)
expr_stmt|;
name|DRM_LOCK_ASSERT
argument_list|(
name|overlay
operator|->
name|dev
argument_list|)
expr_stmt|;
name|DRM_MODE_CONFIG_ASSERT_LOCKED
argument_list|(
name|overlay
operator|->
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_overlay_release_old_vid
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|i915_gem_object_pin_to_display_plane
argument_list|(
name|new_bo
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out_unpin
goto|;
name|ret
operator|=
name|i915_gem_object_put_fence
argument_list|(
name|new_bo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out_unpin
goto|;
if|if
condition|(
operator|!
name|overlay
operator|->
name|active
condition|)
block|{
name|u32
name|oconfig
decl_stmt|;
name|regs
operator|=
name|intel_overlay_map_regs
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regs
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_unpin
goto|;
block|}
name|oconfig
operator|=
name|OCONF_CC_OUT_8BIT
expr_stmt|;
if|if
condition|(
name|IS_GEN4
argument_list|(
name|overlay
operator|->
name|dev
argument_list|)
condition|)
name|oconfig
operator||=
name|OCONF_CSC_MODE_BT709
expr_stmt|;
name|oconfig
operator||=
name|overlay
operator|->
name|crtc
operator|->
name|pipe
operator|==
literal|0
condition|?
name|OCONF_PIPE_A
else|:
name|OCONF_PIPE_B
expr_stmt|;
name|regs
operator|->
name|OCONFIG
operator|=
name|oconfig
expr_stmt|;
name|intel_overlay_unmap_regs
argument_list|(
name|overlay
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_overlay_on
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out_unpin
goto|;
block|}
name|regs
operator|=
name|intel_overlay_map_regs
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regs
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_unpin
goto|;
block|}
name|regs
operator|->
name|DWINPOS
operator|=
operator|(
name|params
operator|->
name|dst_y
operator|<<
literal|16
operator|)
operator||
name|params
operator|->
name|dst_x
expr_stmt|;
name|regs
operator|->
name|DWINSZ
operator|=
operator|(
name|params
operator|->
name|dst_h
operator|<<
literal|16
operator|)
operator||
name|params
operator|->
name|dst_w
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|format
operator|&
name|I915_OVERLAY_YUV_PACKED
condition|)
name|tmp_width
operator|=
name|packed_width_bytes
argument_list|(
name|params
operator|->
name|format
argument_list|,
name|params
operator|->
name|src_w
argument_list|)
expr_stmt|;
else|else
name|tmp_width
operator|=
name|params
operator|->
name|src_w
expr_stmt|;
name|swidth
operator|=
name|params
operator|->
name|src_w
expr_stmt|;
name|swidthsw
operator|=
name|calc_swidthsw
argument_list|(
name|overlay
operator|->
name|dev
argument_list|,
name|params
operator|->
name|offset_Y
argument_list|,
name|tmp_width
argument_list|)
expr_stmt|;
name|sheight
operator|=
name|params
operator|->
name|src_h
expr_stmt|;
name|regs
operator|->
name|OBUF_0Y
operator|=
name|new_bo
operator|->
name|gtt_offset
operator|+
name|params
operator|->
name|offset_Y
expr_stmt|;
name|ostride
operator|=
name|params
operator|->
name|stride_Y
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|format
operator|&
name|I915_OVERLAY_YUV_PLANAR
condition|)
block|{
name|int
name|uv_hscale
init|=
name|uv_hsubsampling
argument_list|(
name|params
operator|->
name|format
argument_list|)
decl_stmt|;
name|int
name|uv_vscale
init|=
name|uv_vsubsampling
argument_list|(
name|params
operator|->
name|format
argument_list|)
decl_stmt|;
name|u32
name|tmp_U
decl_stmt|,
name|tmp_V
decl_stmt|;
name|swidth
operator||=
operator|(
name|params
operator|->
name|src_w
operator|/
name|uv_hscale
operator|)
operator|<<
literal|16
expr_stmt|;
name|tmp_U
operator|=
name|calc_swidthsw
argument_list|(
name|overlay
operator|->
name|dev
argument_list|,
name|params
operator|->
name|offset_U
argument_list|,
name|params
operator|->
name|src_w
operator|/
name|uv_hscale
argument_list|)
expr_stmt|;
name|tmp_V
operator|=
name|calc_swidthsw
argument_list|(
name|overlay
operator|->
name|dev
argument_list|,
name|params
operator|->
name|offset_V
argument_list|,
name|params
operator|->
name|src_w
operator|/
name|uv_hscale
argument_list|)
expr_stmt|;
name|swidthsw
operator||=
name|max_u32
argument_list|(
name|tmp_U
argument_list|,
name|tmp_V
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|sheight
operator||=
operator|(
name|params
operator|->
name|src_h
operator|/
name|uv_vscale
operator|)
operator|<<
literal|16
expr_stmt|;
name|regs
operator|->
name|OBUF_0U
operator|=
name|new_bo
operator|->
name|gtt_offset
operator|+
name|params
operator|->
name|offset_U
expr_stmt|;
name|regs
operator|->
name|OBUF_0V
operator|=
name|new_bo
operator|->
name|gtt_offset
operator|+
name|params
operator|->
name|offset_V
expr_stmt|;
name|ostride
operator||=
name|params
operator|->
name|stride_UV
operator|<<
literal|16
expr_stmt|;
block|}
name|regs
operator|->
name|SWIDTH
operator|=
name|swidth
expr_stmt|;
name|regs
operator|->
name|SWIDTHSW
operator|=
name|swidthsw
expr_stmt|;
name|regs
operator|->
name|SHEIGHT
operator|=
name|sheight
expr_stmt|;
name|regs
operator|->
name|OSTRIDE
operator|=
name|ostride
expr_stmt|;
name|scale_changed
operator|=
name|update_scaling_factors
argument_list|(
name|overlay
argument_list|,
name|regs
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|update_colorkey
argument_list|(
name|overlay
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|->
name|OCMD
operator|=
name|overlay_cmd_reg
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|intel_overlay_unmap_regs
argument_list|(
name|overlay
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_overlay_continue
argument_list|(
name|overlay
argument_list|,
name|scale_changed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out_unpin
goto|;
name|overlay
operator|->
name|old_vid_bo
operator|=
name|overlay
operator|->
name|vid_bo
expr_stmt|;
name|overlay
operator|->
name|vid_bo
operator|=
name|new_bo
expr_stmt|;
return|return
literal|0
return|;
name|out_unpin
label|:
name|i915_gem_object_unpin
argument_list|(
name|new_bo
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|intel_overlay_switch_off
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|)
block|{
name|struct
name|overlay_registers
modifier|*
name|regs
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_LOCK_ASSERT
argument_list|(
name|overlay
operator|->
name|dev
argument_list|)
expr_stmt|;
name|DRM_MODE_CONFIG_ASSERT_LOCKED
argument_list|(
name|overlay
operator|->
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_overlay_recover_from_interrupt
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|overlay
operator|->
name|active
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|intel_overlay_release_old_vid
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
name|regs
operator|=
name|intel_overlay_map_regs
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
name|regs
operator|->
name|OCMD
operator|=
literal|0
expr_stmt|;
name|intel_overlay_unmap_regs
argument_list|(
name|overlay
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_overlay_off
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
name|intel_overlay_off_tail
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_overlay_possible_on_crtc
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|,
name|struct
name|intel_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|overlay
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|crtc
operator|->
name|active
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* can't use the overlay with double wide pipe */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|overlay
operator|->
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
operator|&&
operator|(
name|I915_READ
argument_list|(
name|PIPECONF
argument_list|(
name|crtc
operator|->
name|pipe
argument_list|)
argument_list|)
operator|&
operator|(
name|PIPECONF_DOUBLE_WIDE
operator||
name|PIPECONF_ENABLE
operator|)
operator|)
operator|!=
name|PIPECONF_ENABLE
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_pfit_vscale_ratio
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|overlay
operator|->
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|pfit_control
init|=
name|I915_READ
argument_list|(
name|PFIT_CONTROL
argument_list|)
decl_stmt|;
name|u32
name|ratio
decl_stmt|;
comment|/* XXX: This is not the same logic as in the xorg driver, but more in 	 * line with the intel documentation for the i965 	 */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
comment|/* on i965 use the PGM reg to read out the autoscaler values */
name|ratio
operator|=
name|I915_READ
argument_list|(
name|PFIT_PGM_RATIOS
argument_list|)
operator|>>
name|PFIT_VERT_SCALE_SHIFT_965
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pfit_control
operator|&
name|VERT_AUTO_SCALE
condition|)
name|ratio
operator|=
name|I915_READ
argument_list|(
name|PFIT_AUTO_RATIOS
argument_list|)
expr_stmt|;
else|else
name|ratio
operator|=
name|I915_READ
argument_list|(
name|PFIT_PGM_RATIOS
argument_list|)
expr_stmt|;
name|ratio
operator|>>=
name|PFIT_VERT_SCALE_SHIFT
expr_stmt|;
block|}
name|overlay
operator|->
name|pfit_vscale_ratio
operator|=
name|ratio
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_overlay_dst
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|,
name|struct
name|drm_intel_overlay_put_image
modifier|*
name|rec
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
init|=
operator|&
name|overlay
operator|->
name|crtc
operator|->
name|base
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|rec
operator|->
name|dst_x
operator|<
name|mode
operator|->
name|hdisplay
operator|&&
name|rec
operator|->
name|dst_x
operator|+
name|rec
operator|->
name|dst_width
operator|<=
name|mode
operator|->
name|hdisplay
operator|&&
name|rec
operator|->
name|dst_y
operator|<
name|mode
operator|->
name|vdisplay
operator|&&
name|rec
operator|->
name|dst_y
operator|+
name|rec
operator|->
name|dst_height
operator|<=
name|mode
operator|->
name|vdisplay
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_overlay_scaling
parameter_list|(
name|struct
name|put_image_params
modifier|*
name|rec
parameter_list|)
block|{
name|u32
name|tmp
decl_stmt|;
comment|/* downscaling limit is 8.0 */
name|tmp
operator|=
operator|(
operator|(
name|rec
operator|->
name|src_scan_h
operator|<<
literal|16
operator|)
operator|/
name|rec
operator|->
name|dst_h
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
literal|7
condition|)
return|return
operator|-
name|EINVAL
return|;
name|tmp
operator|=
operator|(
operator|(
name|rec
operator|->
name|src_scan_w
operator|<<
literal|16
operator|)
operator|/
name|rec
operator|->
name|dst_w
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
literal|7
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_overlay_src
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_intel_overlay_put_image
modifier|*
name|rec
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|new_bo
parameter_list|)
block|{
name|int
name|uv_hscale
init|=
name|uv_hsubsampling
argument_list|(
name|rec
operator|->
name|flags
argument_list|)
decl_stmt|;
name|int
name|uv_vscale
init|=
name|uv_vsubsampling
argument_list|(
name|rec
operator|->
name|flags
argument_list|)
decl_stmt|;
name|u32
name|stride_mask
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|u32
name|tmp
decl_stmt|;
comment|/* check src dimensions */
if|if
condition|(
name|IS_845G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I830
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|rec
operator|->
name|src_height
operator|>
name|IMAGE_MAX_HEIGHT_LEGACY
operator|||
name|rec
operator|->
name|src_width
operator|>
name|IMAGE_MAX_WIDTH_LEGACY
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
else|else
block|{
if|if
condition|(
name|rec
operator|->
name|src_height
operator|>
name|IMAGE_MAX_HEIGHT
operator|||
name|rec
operator|->
name|src_width
operator|>
name|IMAGE_MAX_WIDTH
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* better safe than sorry, use 4 as the maximal subsampling ratio */
if|if
condition|(
name|rec
operator|->
name|src_height
operator|<
name|N_VERT_Y_TAPS
operator|*
literal|4
operator|||
name|rec
operator|->
name|src_width
operator|<
name|N_HORIZ_Y_TAPS
operator|*
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* check alignment constraints */
switch|switch
condition|(
name|rec
operator|->
name|flags
operator|&
name|I915_OVERLAY_TYPE_MASK
condition|)
block|{
case|case
name|I915_OVERLAY_RGB
case|:
comment|/* not implemented */
return|return
operator|-
name|EINVAL
return|;
case|case
name|I915_OVERLAY_YUV_PACKED
case|:
if|if
condition|(
name|uv_vscale
operator|!=
literal|1
condition|)
return|return
operator|-
name|EINVAL
return|;
name|depth
operator|=
name|packed_depth_bytes
argument_list|(
name|rec
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|<
literal|0
condition|)
return|return
name|depth
return|;
comment|/* ignore UV planes */
name|rec
operator|->
name|stride_UV
operator|=
literal|0
expr_stmt|;
name|rec
operator|->
name|offset_U
operator|=
literal|0
expr_stmt|;
name|rec
operator|->
name|offset_V
operator|=
literal|0
expr_stmt|;
comment|/* check pixel alignment */
if|if
condition|(
name|rec
operator|->
name|offset_Y
operator|%
name|depth
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|I915_OVERLAY_YUV_PLANAR
case|:
if|if
condition|(
name|uv_vscale
operator|<
literal|0
operator|||
name|uv_hscale
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* no offset restrictions for planar formats */
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|rec
operator|->
name|src_width
operator|%
name|uv_hscale
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* stride checking */
if|if
condition|(
name|IS_I830
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_845G
argument_list|(
name|dev
argument_list|)
condition|)
name|stride_mask
operator|=
literal|255
expr_stmt|;
else|else
name|stride_mask
operator|=
literal|63
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|stride_Y
operator|&
name|stride_mask
operator|||
name|rec
operator|->
name|stride_UV
operator|&
name|stride_mask
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|IS_GEN4
argument_list|(
name|dev
argument_list|)
operator|&&
name|rec
operator|->
name|stride_Y
operator|<
literal|512
condition|)
return|return
operator|-
name|EINVAL
return|;
name|tmp
operator|=
operator|(
name|rec
operator|->
name|flags
operator|&
name|I915_OVERLAY_TYPE_MASK
operator|)
operator|==
name|I915_OVERLAY_YUV_PLANAR
condition|?
literal|4096
else|:
literal|8192
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|stride_Y
operator|>
name|tmp
operator|||
name|rec
operator|->
name|stride_UV
operator|>
literal|2
operator|*
literal|1024
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* check buffer dimensions */
switch|switch
condition|(
name|rec
operator|->
name|flags
operator|&
name|I915_OVERLAY_TYPE_MASK
condition|)
block|{
case|case
name|I915_OVERLAY_RGB
case|:
case|case
name|I915_OVERLAY_YUV_PACKED
case|:
comment|/* always 4 Y values per depth pixels */
if|if
condition|(
name|packed_width_bytes
argument_list|(
name|rec
operator|->
name|flags
argument_list|,
name|rec
operator|->
name|src_width
argument_list|)
operator|>
name|rec
operator|->
name|stride_Y
condition|)
return|return
operator|-
name|EINVAL
return|;
name|tmp
operator|=
name|rec
operator|->
name|stride_Y
operator|*
name|rec
operator|->
name|src_height
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|offset_Y
operator|+
name|tmp
operator|>
name|new_bo
operator|->
name|base
operator|.
name|size
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|I915_OVERLAY_YUV_PLANAR
case|:
if|if
condition|(
name|rec
operator|->
name|src_width
operator|>
name|rec
operator|->
name|stride_Y
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|rec
operator|->
name|src_width
operator|/
name|uv_hscale
operator|>
name|rec
operator|->
name|stride_UV
condition|)
return|return
operator|-
name|EINVAL
return|;
name|tmp
operator|=
name|rec
operator|->
name|stride_Y
operator|*
name|rec
operator|->
name|src_height
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|offset_Y
operator|+
name|tmp
operator|>
name|new_bo
operator|->
name|base
operator|.
name|size
condition|)
return|return
operator|-
name|EINVAL
return|;
name|tmp
operator|=
name|rec
operator|->
name|stride_UV
operator|*
operator|(
name|rec
operator|->
name|src_height
operator|/
name|uv_vscale
operator|)
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|offset_U
operator|+
name|tmp
operator|>
name|new_bo
operator|->
name|base
operator|.
name|size
operator|||
name|rec
operator|->
name|offset_V
operator|+
name|tmp
operator|>
name|new_bo
operator|->
name|base
operator|.
name|size
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Return the pipe currently connected to the panel fitter,  * or -1 if the panel fitter is not present or not in use  */
end_comment

begin_function
specifier|static
name|int
name|intel_panel_fitter_pipe
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|pfit_control
decl_stmt|;
comment|/* i830 doesn't have a panel fitter */
if|if
condition|(
name|IS_I830
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|pfit_control
operator|=
name|I915_READ
argument_list|(
name|PFIT_CONTROL
argument_list|)
expr_stmt|;
comment|/* See if the panel fitter is in use */
if|if
condition|(
operator|(
name|pfit_control
operator|&
name|PFIT_ENABLE
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 965 can place panel fitter on either pipe */
if|if
condition|(
name|IS_GEN4
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|pfit_control
operator|>>
literal|29
operator|)
operator|&
literal|0x3
return|;
comment|/* older chips can only use pipe 1 */
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|intel_overlay_put_image
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_intel_overlay_put_image
modifier|*
name|put_image_rec
init|=
name|data
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_overlay
modifier|*
name|overlay
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|drmmode_obj
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|new_bo
decl_stmt|;
name|struct
name|put_image_params
modifier|*
name|params
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* No need to check for DRIVER_MODESET - we don't set it up then. */
name|overlay
operator|=
name|dev_priv
operator|->
name|overlay
expr_stmt|;
if|if
condition|(
operator|!
name|overlay
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"userspace bug: no overlay\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|put_image_rec
operator|->
name|flags
operator|&
name|I915_OVERLAY_ENABLE
operator|)
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_overlay_switch_off
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|params
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|put_image_params
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|drmmode_obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|put_image_rec
operator|->
name|crtc_id
argument_list|,
name|DRM_MODE_OBJECT_CRTC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drmmode_obj
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
name|crtc
operator|=
name|to_intel_crtc
argument_list|(
name|obj_to_crtc
argument_list|(
name|drmmode_obj
argument_list|)
argument_list|)
expr_stmt|;
name|new_bo
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|,
name|put_image_rec
operator|->
name|bo_handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|new_bo
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_bo
operator|->
name|tiling_mode
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"buffer used for overlay image can not be tiled\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|ret
operator|=
name|intel_overlay_recover_from_interrupt
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out_unlock
goto|;
if|if
condition|(
name|overlay
operator|->
name|crtc
operator|!=
name|crtc
condition|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
init|=
operator|&
name|crtc
operator|->
name|base
operator|.
name|mode
decl_stmt|;
name|ret
operator|=
name|intel_overlay_switch_off
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out_unlock
goto|;
name|ret
operator|=
name|check_overlay_possible_on_crtc
argument_list|(
name|overlay
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out_unlock
goto|;
name|overlay
operator|->
name|crtc
operator|=
name|crtc
expr_stmt|;
name|crtc
operator|->
name|overlay
operator|=
name|overlay
expr_stmt|;
comment|/* line too wide, i.e. one-line-mode */
if|if
condition|(
name|mode
operator|->
name|hdisplay
operator|>
literal|1024
operator|&&
name|intel_panel_fitter_pipe
argument_list|(
name|dev
argument_list|)
operator|==
name|crtc
operator|->
name|pipe
condition|)
block|{
name|overlay
operator|->
name|pfit_active
operator|=
literal|1
expr_stmt|;
name|update_pfit_vscale_ratio
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
block|}
else|else
name|overlay
operator|->
name|pfit_active
operator|=
literal|0
expr_stmt|;
block|}
name|ret
operator|=
name|check_overlay_dst
argument_list|(
name|overlay
argument_list|,
name|put_image_rec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out_unlock
goto|;
if|if
condition|(
name|overlay
operator|->
name|pfit_active
condition|)
block|{
name|params
operator|->
name|dst_y
operator|=
operator|(
operator|(
operator|(
operator|(
name|u32
operator|)
name|put_image_rec
operator|->
name|dst_y
operator|)
operator|<<
literal|12
operator|)
operator|/
name|overlay
operator|->
name|pfit_vscale_ratio
operator|)
expr_stmt|;
comment|/* shifting right rounds downwards, so add 1 */
name|params
operator|->
name|dst_h
operator|=
operator|(
operator|(
operator|(
operator|(
name|u32
operator|)
name|put_image_rec
operator|->
name|dst_height
operator|)
operator|<<
literal|12
operator|)
operator|/
name|overlay
operator|->
name|pfit_vscale_ratio
operator|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|params
operator|->
name|dst_y
operator|=
name|put_image_rec
operator|->
name|dst_y
expr_stmt|;
name|params
operator|->
name|dst_h
operator|=
name|put_image_rec
operator|->
name|dst_height
expr_stmt|;
block|}
name|params
operator|->
name|dst_x
operator|=
name|put_image_rec
operator|->
name|dst_x
expr_stmt|;
name|params
operator|->
name|dst_w
operator|=
name|put_image_rec
operator|->
name|dst_width
expr_stmt|;
name|params
operator|->
name|src_w
operator|=
name|put_image_rec
operator|->
name|src_width
expr_stmt|;
name|params
operator|->
name|src_h
operator|=
name|put_image_rec
operator|->
name|src_height
expr_stmt|;
name|params
operator|->
name|src_scan_w
operator|=
name|put_image_rec
operator|->
name|src_scan_width
expr_stmt|;
name|params
operator|->
name|src_scan_h
operator|=
name|put_image_rec
operator|->
name|src_scan_height
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|src_scan_h
operator|>
name|params
operator|->
name|src_h
operator|||
name|params
operator|->
name|src_scan_w
operator|>
name|params
operator|->
name|src_w
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|ret
operator|=
name|check_overlay_src
argument_list|(
name|dev
argument_list|,
name|put_image_rec
argument_list|,
name|new_bo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out_unlock
goto|;
name|params
operator|->
name|format
operator|=
name|put_image_rec
operator|->
name|flags
operator|&
operator|~
name|I915_OVERLAY_FLAGS_MASK
expr_stmt|;
name|params
operator|->
name|stride_Y
operator|=
name|put_image_rec
operator|->
name|stride_Y
expr_stmt|;
name|params
operator|->
name|stride_UV
operator|=
name|put_image_rec
operator|->
name|stride_UV
expr_stmt|;
name|params
operator|->
name|offset_Y
operator|=
name|put_image_rec
operator|->
name|offset_Y
expr_stmt|;
name|params
operator|->
name|offset_U
operator|=
name|put_image_rec
operator|->
name|offset_U
expr_stmt|;
name|params
operator|->
name|offset_V
operator|=
name|put_image_rec
operator|->
name|offset_V
expr_stmt|;
comment|/* Check scaling after src size to prevent a divide-by-zero. */
name|ret
operator|=
name|check_overlay_scaling
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out_unlock
goto|;
name|ret
operator|=
name|intel_overlay_do_put_image
argument_list|(
name|overlay
argument_list|,
name|new_bo
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out_unlock
goto|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|params
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out_unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference_unlocked
argument_list|(
operator|&
name|new_bo
operator|->
name|base
argument_list|)
expr_stmt|;
name|out_free
label|:
name|free
argument_list|(
name|params
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_reg_attrs
parameter_list|(
name|struct
name|intel_overlay
modifier|*
name|overlay
parameter_list|,
name|struct
name|overlay_registers
modifier|*
name|regs
parameter_list|)
block|{
name|regs
operator|->
name|OCLRC0
operator|=
operator|(
name|overlay
operator|->
name|contrast
operator|<<
literal|18
operator|)
operator||
operator|(
name|overlay
operator|->
name|brightness
operator|&
literal|0xff
operator|)
expr_stmt|;
name|regs
operator|->
name|OCLRC1
operator|=
name|overlay
operator|->
name|saturation
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|check_gamma_bounds
parameter_list|(
name|u32
name|gamma1
parameter_list|,
name|u32
name|gamma2
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|gamma1
operator|&
literal|0xff000000
operator|||
name|gamma2
operator|&
literal|0xff000000
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|gamma1
operator|>>
name|i
operator|*
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|>=
operator|(
operator|(
name|gamma2
operator|>>
name|i
operator|*
literal|8
operator|)
operator|&
literal|0xff
operator|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|check_gamma5_errata
parameter_list|(
name|u32
name|gamma5
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|gamma5
operator|>>
name|i
operator|*
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|==
literal|0x80
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_gamma
parameter_list|(
name|struct
name|drm_intel_overlay_attrs
modifier|*
name|attrs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|check_gamma_bounds
argument_list|(
literal|0
argument_list|,
name|attrs
operator|->
name|gamma0
argument_list|)
operator|||
operator|!
name|check_gamma_bounds
argument_list|(
name|attrs
operator|->
name|gamma0
argument_list|,
name|attrs
operator|->
name|gamma1
argument_list|)
operator|||
operator|!
name|check_gamma_bounds
argument_list|(
name|attrs
operator|->
name|gamma1
argument_list|,
name|attrs
operator|->
name|gamma2
argument_list|)
operator|||
operator|!
name|check_gamma_bounds
argument_list|(
name|attrs
operator|->
name|gamma2
argument_list|,
name|attrs
operator|->
name|gamma3
argument_list|)
operator|||
operator|!
name|check_gamma_bounds
argument_list|(
name|attrs
operator|->
name|gamma3
argument_list|,
name|attrs
operator|->
name|gamma4
argument_list|)
operator|||
operator|!
name|check_gamma_bounds
argument_list|(
name|attrs
operator|->
name|gamma4
argument_list|,
name|attrs
operator|->
name|gamma5
argument_list|)
operator|||
operator|!
name|check_gamma_bounds
argument_list|(
name|attrs
operator|->
name|gamma5
argument_list|,
literal|0x00ffffff
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|check_gamma5_errata
argument_list|(
name|attrs
operator|->
name|gamma5
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|intel_overlay_attrs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_intel_overlay_attrs
modifier|*
name|attrs
init|=
name|data
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_overlay
modifier|*
name|overlay
decl_stmt|;
name|struct
name|overlay_registers
modifier|*
name|regs
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* No need to check for DRIVER_MODESET - we don't set it up then. */
name|overlay
operator|=
name|dev_priv
operator|->
name|overlay
expr_stmt|;
if|if
condition|(
operator|!
name|overlay
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"userspace bug: no overlay\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|attrs
operator|->
name|flags
operator|&
name|I915_OVERLAY_UPDATE_ATTRS
operator|)
condition|)
block|{
name|attrs
operator|->
name|color_key
operator|=
name|overlay
operator|->
name|color_key
expr_stmt|;
name|attrs
operator|->
name|brightness
operator|=
name|overlay
operator|->
name|brightness
expr_stmt|;
name|attrs
operator|->
name|contrast
operator|=
name|overlay
operator|->
name|contrast
expr_stmt|;
name|attrs
operator|->
name|saturation
operator|=
name|overlay
operator|->
name|saturation
expr_stmt|;
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|attrs
operator|->
name|gamma0
operator|=
name|I915_READ
argument_list|(
name|OGAMC0
argument_list|)
expr_stmt|;
name|attrs
operator|->
name|gamma1
operator|=
name|I915_READ
argument_list|(
name|OGAMC1
argument_list|)
expr_stmt|;
name|attrs
operator|->
name|gamma2
operator|=
name|I915_READ
argument_list|(
name|OGAMC2
argument_list|)
expr_stmt|;
name|attrs
operator|->
name|gamma3
operator|=
name|I915_READ
argument_list|(
name|OGAMC3
argument_list|)
expr_stmt|;
name|attrs
operator|->
name|gamma4
operator|=
name|I915_READ
argument_list|(
name|OGAMC4
argument_list|)
expr_stmt|;
name|attrs
operator|->
name|gamma5
operator|=
name|I915_READ
argument_list|(
name|OGAMC5
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|attrs
operator|->
name|brightness
operator|<
operator|-
literal|128
operator|||
name|attrs
operator|->
name|brightness
operator|>
literal|127
condition|)
goto|goto
name|out_unlock
goto|;
if|if
condition|(
name|attrs
operator|->
name|contrast
operator|>
literal|255
condition|)
goto|goto
name|out_unlock
goto|;
if|if
condition|(
name|attrs
operator|->
name|saturation
operator|>
literal|1023
condition|)
goto|goto
name|out_unlock
goto|;
name|overlay
operator|->
name|color_key
operator|=
name|attrs
operator|->
name|color_key
expr_stmt|;
name|overlay
operator|->
name|brightness
operator|=
name|attrs
operator|->
name|brightness
expr_stmt|;
name|overlay
operator|->
name|contrast
operator|=
name|attrs
operator|->
name|contrast
expr_stmt|;
name|overlay
operator|->
name|saturation
operator|=
name|attrs
operator|->
name|saturation
expr_stmt|;
name|regs
operator|=
name|intel_overlay_map_regs
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regs
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|update_reg_attrs
argument_list|(
name|overlay
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|intel_overlay_unmap_regs
argument_list|(
name|overlay
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrs
operator|->
name|flags
operator|&
name|I915_OVERLAY_UPDATE_GAMMA
condition|)
block|{
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
goto|goto
name|out_unlock
goto|;
if|if
condition|(
name|overlay
operator|->
name|active
condition|)
block|{
name|ret
operator|=
operator|-
name|EBUSY
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|ret
operator|=
name|check_gamma
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out_unlock
goto|;
name|I915_WRITE
argument_list|(
name|OGAMC0
argument_list|,
name|attrs
operator|->
name|gamma0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|OGAMC1
argument_list|,
name|attrs
operator|->
name|gamma1
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|OGAMC2
argument_list|,
name|attrs
operator|->
name|gamma2
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|OGAMC3
argument_list|,
name|attrs
operator|->
name|gamma3
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|OGAMC4
argument_list|,
name|attrs
operator|->
name|gamma4
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|OGAMC5
argument_list|,
name|attrs
operator|->
name|gamma5
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|out_unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|intel_setup_overlay
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_overlay
modifier|*
name|overlay
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|reg_bo
decl_stmt|;
name|struct
name|overlay_registers
modifier|*
name|regs
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|HAS_OVERLAY
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|overlay
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intel_overlay
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|overlay
operator|!=
name|NULL
condition|)
goto|goto
name|out_free
goto|;
name|overlay
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|reg_bo
operator|=
name|i915_gem_alloc_object
argument_list|(
name|dev
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg_bo
condition|)
goto|goto
name|out_free
goto|;
name|overlay
operator|->
name|reg_bo
operator|=
name|reg_bo
expr_stmt|;
if|if
condition|(
name|OVERLAY_NEEDS_PHYSICAL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ret
operator|=
name|i915_gem_attach_phys_object
argument_list|(
name|dev
argument_list|,
name|reg_bo
argument_list|,
name|I915_GEM_PHYS_OVERLAY_REGS
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to attach phys overlay regs\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_free_bo
goto|;
block|}
name|overlay
operator|->
name|flip_addr
operator|=
name|reg_bo
operator|->
name|phys_obj
operator|->
name|handle
operator|->
name|busaddr
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|i915_gem_object_pin
argument_list|(
name|reg_bo
argument_list|,
name|PAGE_SIZE
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to pin overlay register bo\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_free_bo
goto|;
block|}
name|overlay
operator|->
name|flip_addr
operator|=
name|reg_bo
operator|->
name|gtt_offset
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|reg_bo
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to move overlay register bo into the GTT\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_unpin_bo
goto|;
block|}
block|}
comment|/* init all values */
name|overlay
operator|->
name|color_key
operator|=
literal|0x0101fe
expr_stmt|;
name|overlay
operator|->
name|brightness
operator|=
operator|-
literal|19
expr_stmt|;
name|overlay
operator|->
name|contrast
operator|=
literal|75
expr_stmt|;
name|overlay
operator|->
name|saturation
operator|=
literal|146
expr_stmt|;
name|regs
operator|=
name|intel_overlay_map_regs
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regs
condition|)
goto|goto
name|out_unpin_bo
goto|;
name|memset
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|overlay_registers
argument_list|)
argument_list|)
expr_stmt|;
name|update_polyphase_filter
argument_list|(
name|regs
argument_list|)
expr_stmt|;
name|update_reg_attrs
argument_list|(
name|overlay
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|intel_overlay_unmap_regs
argument_list|(
name|overlay
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|overlay
operator|=
name|overlay
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"initialized overlay support\n"
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
name|out_unpin_bo
label|:
if|if
condition|(
operator|!
name|OVERLAY_NEEDS_PHYSICAL
argument_list|(
name|dev
argument_list|)
condition|)
name|i915_gem_object_unpin
argument_list|(
name|reg_bo
argument_list|)
expr_stmt|;
name|out_free_bo
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|reg_bo
operator|->
name|base
argument_list|)
expr_stmt|;
name|out_free
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|overlay
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|intel_cleanup_overlay
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|overlay
condition|)
return|return;
comment|/* The bo's should be free'd by the generic code already. 	 * Furthermore modesetting teardown happens beforehand so the 	 * hardware should be off already */
name|KASSERT
argument_list|(
operator|!
name|dev_priv
operator|->
name|overlay
operator|->
name|active
argument_list|,
operator|(
literal|"Overlay still active"
operator|)
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference_unlocked
argument_list|(
operator|&
name|dev_priv
operator|->
name|overlay
operator|->
name|reg_bo
operator|->
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev_priv
operator|->
name|overlay
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|intel_overlay_error_state
block|{
name|struct
name|overlay_registers
name|regs
decl_stmt|;
name|unsigned
name|long
name|base
decl_stmt|;
name|u32
name|dovsta
decl_stmt|;
name|u32
name|isr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|struct
name|intel_overlay_error_state
modifier|*
name|intel_overlay_capture_error_state
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_overlay
modifier|*
name|overlay
init|=
name|dev_priv
operator|->
name|overlay
decl_stmt|;
name|struct
name|intel_overlay_error_state
modifier|*
name|error
decl_stmt|;
name|struct
name|overlay_registers
name|__iomem
modifier|*
name|regs
decl_stmt|;
if|if
condition|(
operator|!
name|overlay
operator|||
operator|!
name|overlay
operator|->
name|active
condition|)
return|return
name|NULL
return|;
name|error
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|error
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|error
operator|->
name|dovsta
operator|=
name|I915_READ
argument_list|(
name|DOVSTA
argument_list|)
expr_stmt|;
name|error
operator|->
name|isr
operator|=
name|I915_READ
argument_list|(
name|ISR
argument_list|)
expr_stmt|;
if|if
condition|(
name|OVERLAY_NEEDS_PHYSICAL
argument_list|(
name|overlay
operator|->
name|dev
argument_list|)
condition|)
name|error
operator|->
name|base
operator|=
operator|(
name|long
operator|)
name|overlay
operator|->
name|reg_bo
operator|->
name|phys_obj
operator|->
name|handle
operator|->
name|vaddr
expr_stmt|;
else|else
name|error
operator|->
name|base
operator|=
operator|(
name|long
operator|)
name|overlay
operator|->
name|reg_bo
operator|->
name|gtt_offset
expr_stmt|;
name|regs
operator|=
name|intel_overlay_map_regs
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regs
condition|)
goto|goto
name|err
goto|;
name|memcpy
argument_list|(
operator|&
name|error
operator|->
name|regs
argument_list|,
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|overlay_registers
argument_list|)
argument_list|)
expr_stmt|;
name|intel_overlay_unmap_regs
argument_list|(
name|overlay
argument_list|,
name|regs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|err
label|:
name|free
argument_list|(
name|error
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|intel_overlay_print_error_state
parameter_list|(
name|struct
name|sbuf
modifier|*
name|m
parameter_list|,
name|struct
name|intel_overlay_error_state
modifier|*
name|error
parameter_list|)
block|{
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"Overlay, status: 0x%08x, interrupt: 0x%08x\n"
argument_list|,
name|error
operator|->
name|dovsta
argument_list|,
name|error
operator|->
name|isr
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"  Register file at 0x%08lx:\n"
argument_list|,
name|error
operator|->
name|base
argument_list|)
expr_stmt|;
define|#
directive|define
name|P
parameter_list|(
name|x
parameter_list|)
value|sbuf_printf(m, "    " #x ":	0x%08x\n", error->regs.x)
name|P
argument_list|(
name|OBUF_0Y
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OBUF_1Y
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OBUF_0U
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OBUF_0V
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OBUF_1U
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OBUF_1V
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OSTRIDE
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|YRGB_VPH
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|UV_VPH
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|HORZ_PH
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|INIT_PHS
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|DWINPOS
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|DWINSZ
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|SWIDTH
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|SWIDTHSW
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|SHEIGHT
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|YRGBSCALE
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|UVSCALE
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OCLRC0
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OCLRC1
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|DCLRKV
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|DCLRKM
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|SCLRKVH
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|SCLRKVL
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|SCLRKEN
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OCONFIG
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OCMD
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OSTART_0Y
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OSTART_1Y
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OSTART_0U
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OSTART_0V
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OSTART_1U
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OSTART_1V
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OTILEOFF_0Y
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OTILEOFF_1Y
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OTILEOFF_0U
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OTILEOFF_0V
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OTILEOFF_1U
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|OTILEOFF_1V
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|FASTHSCALE
argument_list|)
expr_stmt|;
name|P
argument_list|(
name|UVSCALEV
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|P
block|}
end_function

end_unit

