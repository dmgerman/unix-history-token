begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Â© 2010 Daniel Vetter  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sf_buf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_typedef
typedef|typedef
name|uint32_t
name|gtt_pte_t
typedef|;
end_typedef

begin_comment
comment|/* PPGTT stuff */
end_comment

begin_define
define|#
directive|define
name|GEN6_GTT_ADDR_ENCODE
parameter_list|(
name|addr
parameter_list|)
value|((addr) | (((addr)>> 28)& 0xff0))
end_define

begin_define
define|#
directive|define
name|GEN6_PDE_VALID
value|(1<< 0)
end_define

begin_comment
comment|/* gen6+ has bit 11-4 for physical addr bit 39-32 */
end_comment

begin_define
define|#
directive|define
name|GEN6_PDE_ADDR_ENCODE
parameter_list|(
name|addr
parameter_list|)
value|GEN6_GTT_ADDR_ENCODE(addr)
end_define

begin_define
define|#
directive|define
name|GEN6_PTE_VALID
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|GEN6_PTE_UNCACHED
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|HSW_PTE_UNCACHED
value|(0)
end_define

begin_define
define|#
directive|define
name|GEN6_PTE_CACHE_LLC
value|(2<< 1)
end_define

begin_define
define|#
directive|define
name|GEN6_PTE_CACHE_LLC_MLC
value|(3<< 1)
end_define

begin_define
define|#
directive|define
name|GEN6_PTE_ADDR_ENCODE
parameter_list|(
name|addr
parameter_list|)
value|GEN6_GTT_ADDR_ENCODE(addr)
end_define

begin_function
specifier|static
specifier|inline
name|gtt_pte_t
name|pte_encode
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|dma_addr_t
name|addr
parameter_list|,
name|enum
name|i915_cache_level
name|level
parameter_list|)
block|{
name|gtt_pte_t
name|pte
init|=
name|GEN6_PTE_VALID
decl_stmt|;
name|pte
operator||=
name|GEN6_PTE_ADDR_ENCODE
argument_list|(
name|addr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|I915_CACHE_LLC_MLC
case|:
comment|/* Haswell doesn't set L3 this way */
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
name|pte
operator||=
name|GEN6_PTE_CACHE_LLC
expr_stmt|;
else|else
name|pte
operator||=
name|GEN6_PTE_CACHE_LLC_MLC
expr_stmt|;
break|break;
case|case
name|I915_CACHE_LLC
case|:
name|pte
operator||=
name|GEN6_PTE_CACHE_LLC
expr_stmt|;
break|break;
case|case
name|I915_CACHE_NONE
case|:
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
name|pte
operator||=
name|HSW_PTE_UNCACHED
expr_stmt|;
else|else
name|pte
operator||=
name|GEN6_PTE_UNCACHED
expr_stmt|;
break|break;
default|default:
name|BUG
argument_list|()
expr_stmt|;
block|}
return|return
name|pte
return|;
block|}
end_function

begin_comment
comment|/* PPGTT support for Sandybdrige/Gen6 and later */
end_comment

begin_function
specifier|static
name|void
name|i915_ppgtt_clear_range
parameter_list|(
name|struct
name|i915_hw_ppgtt
modifier|*
name|ppgtt
parameter_list|,
name|unsigned
name|first_entry
parameter_list|,
name|unsigned
name|num_entries
parameter_list|)
block|{
name|gtt_pte_t
modifier|*
name|pt_vaddr
decl_stmt|;
name|gtt_pte_t
name|scratch_pte
decl_stmt|;
name|unsigned
name|act_pd
init|=
name|first_entry
operator|/
name|I915_PPGTT_PT_ENTRIES
decl_stmt|;
name|unsigned
name|first_pte
init|=
name|first_entry
operator|%
name|I915_PPGTT_PT_ENTRIES
decl_stmt|;
name|unsigned
name|last_pte
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|scratch_pte
operator|=
name|pte_encode
argument_list|(
name|ppgtt
operator|->
name|dev
argument_list|,
name|ppgtt
operator|->
name|scratch_page_dma_addr
argument_list|,
name|I915_CACHE_LLC
argument_list|)
expr_stmt|;
while|while
condition|(
name|num_entries
condition|)
block|{
name|last_pte
operator|=
name|first_pte
operator|+
name|num_entries
expr_stmt|;
if|if
condition|(
name|last_pte
operator|>
name|I915_PPGTT_PT_ENTRIES
condition|)
name|last_pte
operator|=
name|I915_PPGTT_PT_ENTRIES
expr_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|ppgtt
operator|->
name|pt_pages
index|[
name|act_pd
index|]
argument_list|,
name|SFB_CPUPRIVATE
argument_list|)
expr_stmt|;
name|pt_vaddr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first_pte
init|;
name|i
operator|<
name|last_pte
condition|;
name|i
operator|++
control|)
name|pt_vaddr
index|[
name|i
index|]
operator|=
name|scratch_pte
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
name|num_entries
operator|-=
name|last_pte
operator|-
name|first_pte
expr_stmt|;
name|first_pte
operator|=
literal|0
expr_stmt|;
name|act_pd
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|i915_gem_init_aliasing_ppgtt
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|i915_hw_ppgtt
modifier|*
name|ppgtt
decl_stmt|;
name|unsigned
name|first_pd_entry_in_global_pt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
init|=
operator|-
name|ENOMEM
decl_stmt|;
comment|/* ppgtt PDEs reside in the global gtt pagetable, which has 512*1024 	 * entries. For aliasing ppgtt support we just steal them at the end for 	 * now. */
name|first_pd_entry_in_global_pt
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_total_entries
operator|-
name|I915_PPGTT_PD_ENTRIES
expr_stmt|;
name|ppgtt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ppgtt
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ppgtt
condition|)
return|return
name|ret
return|;
name|ppgtt
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|ppgtt
operator|->
name|num_pd_entries
operator|=
name|I915_PPGTT_PD_ENTRIES
expr_stmt|;
name|ppgtt
operator|->
name|pt_pages
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|page
operator|*
argument_list|)
operator|*
name|ppgtt
operator|->
name|num_pd_entries
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ppgtt
operator|->
name|pt_pages
condition|)
goto|goto
name|err_ppgtt
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppgtt
operator|->
name|num_pd_entries
condition|;
name|i
operator|++
control|)
block|{
name|ppgtt
operator|->
name|pt_pages
index|[
name|i
index|]
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ppgtt
operator|->
name|pt_pages
index|[
name|i
index|]
condition|)
goto|goto
name|err_pt_alloc
goto|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|needs_dmar
condition|)
block|{
name|ppgtt
operator|->
name|pt_dma_addr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dma_addr_t
argument_list|)
operator|*
name|ppgtt
operator|->
name|num_pd_entries
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ppgtt
operator|->
name|pt_dma_addr
condition|)
goto|goto
name|err_pt_alloc
goto|;
ifdef|#
directive|ifdef
name|CONFIG_INTEL_IOMMU
comment|/*<- Added as a marker on FreeBSD. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppgtt
operator|->
name|num_pd_entries
condition|;
name|i
operator|++
control|)
block|{
name|dma_addr_t
name|pt_addr
decl_stmt|;
name|pt_addr
operator|=
name|pci_map_page
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|ppgtt
operator|->
name|pt_pages
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|4096
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_dma_mapping_error
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|pt_addr
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EIO
expr_stmt|;
goto|goto
name|err_pd_pin
goto|;
block|}
name|ppgtt
operator|->
name|pt_dma_addr
index|[
name|i
index|]
operator|=
name|pt_addr
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|ppgtt
operator|->
name|scratch_page_dma_addr
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|scratch_page_dma
expr_stmt|;
name|i915_ppgtt_clear_range
argument_list|(
name|ppgtt
argument_list|,
literal|0
argument_list|,
name|ppgtt
operator|->
name|num_pd_entries
operator|*
name|I915_PPGTT_PT_ENTRIES
argument_list|)
expr_stmt|;
name|ppgtt
operator|->
name|pd_offset
operator|=
operator|(
name|first_pd_entry_in_global_pt
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|gtt_pte_t
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
operator|=
name|ppgtt
expr_stmt|;
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|CONFIG_INTEL_IOMMU
comment|/*<- Added as a marker on FreeBSD. */
name|err_pd_pin
label|:
if|if
condition|(
name|ppgtt
operator|->
name|pt_dma_addr
condition|)
block|{
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|pci_unmap_page
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|ppgtt
operator|->
name|pt_dma_addr
index|[
name|i
index|]
argument_list|,
literal|4096
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|err_pt_alloc
label|:
name|free
argument_list|(
name|ppgtt
operator|->
name|pt_dma_addr
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppgtt
operator|->
name|num_pd_entries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ppgtt
operator|->
name|pt_pages
index|[
name|i
index|]
condition|)
block|{
name|vm_page_unwire
argument_list|(
name|ppgtt
operator|->
name|pt_pages
index|[
name|i
index|]
argument_list|,
name|PQ_NONE
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|ppgtt
operator|->
name|pt_pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|ppgtt
operator|->
name|pt_pages
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|err_ppgtt
label|:
name|free
argument_list|(
name|ppgtt
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_cleanup_aliasing_ppgtt
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|i915_hw_ppgtt
modifier|*
name|ppgtt
init|=
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ppgtt
condition|)
return|return;
ifdef|#
directive|ifdef
name|CONFIG_INTEL_IOMMU
comment|/*<- Added as a marker on FreeBSD. */
if|if
condition|(
name|ppgtt
operator|->
name|pt_dma_addr
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppgtt
operator|->
name|num_pd_entries
condition|;
name|i
operator|++
control|)
name|pci_unmap_page
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|ppgtt
operator|->
name|pt_dma_addr
index|[
name|i
index|]
argument_list|,
literal|4096
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|ppgtt
operator|->
name|pt_dma_addr
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppgtt
operator|->
name|num_pd_entries
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_unwire
argument_list|(
name|ppgtt
operator|->
name|pt_pages
index|[
name|i
index|]
argument_list|,
name|PQ_NONE
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|ppgtt
operator|->
name|pt_pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ppgtt
operator|->
name|pt_pages
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ppgtt
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_ppgtt_insert_pages
parameter_list|(
name|struct
name|i915_hw_ppgtt
modifier|*
name|ppgtt
parameter_list|,
name|vm_page_t
modifier|*
name|pages
parameter_list|,
name|unsigned
name|first_entry
parameter_list|,
name|unsigned
name|num_entries
parameter_list|,
name|enum
name|i915_cache_level
name|cache_level
parameter_list|)
block|{
name|uint32_t
modifier|*
name|pt_vaddr
decl_stmt|;
name|unsigned
name|act_pd
init|=
name|first_entry
operator|/
name|I915_PPGTT_PT_ENTRIES
decl_stmt|;
name|unsigned
name|first_pte
init|=
name|first_entry
operator|%
name|I915_PPGTT_PT_ENTRIES
decl_stmt|;
name|unsigned
name|j
decl_stmt|,
name|last_pte
decl_stmt|;
name|vm_paddr_t
name|page_addr
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
while|while
condition|(
name|num_entries
condition|)
block|{
name|last_pte
operator|=
name|first_pte
operator|+
name|num_entries
expr_stmt|;
if|if
condition|(
name|last_pte
operator|>
name|I915_PPGTT_PT_ENTRIES
condition|)
name|last_pte
operator|=
name|I915_PPGTT_PT_ENTRIES
expr_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|ppgtt
operator|->
name|pt_pages
index|[
name|act_pd
index|]
argument_list|,
name|SFB_CPUPRIVATE
argument_list|)
expr_stmt|;
name|pt_vaddr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|first_pte
init|;
name|j
operator|<
name|last_pte
condition|;
name|j
operator|++
control|)
block|{
name|page_addr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
operator|*
name|pages
argument_list|)
expr_stmt|;
name|pt_vaddr
index|[
name|j
index|]
operator|=
name|pte_encode
argument_list|(
name|ppgtt
operator|->
name|dev
argument_list|,
name|page_addr
argument_list|,
name|cache_level
argument_list|)
expr_stmt|;
name|pages
operator|++
expr_stmt|;
block|}
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
name|num_entries
operator|-=
name|last_pte
operator|-
name|first_pte
expr_stmt|;
name|first_pte
operator|=
literal|0
expr_stmt|;
name|act_pd
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|i915_ppgtt_bind_object
parameter_list|(
name|struct
name|i915_hw_ppgtt
modifier|*
name|ppgtt
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|enum
name|i915_cache_level
name|cache_level
parameter_list|)
block|{
name|i915_ppgtt_insert_pages
argument_list|(
name|ppgtt
argument_list|,
name|obj
operator|->
name|pages
argument_list|,
name|obj
operator|->
name|gtt_space
operator|->
name|start
operator|>>
name|PAGE_SHIFT
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
operator|>>
name|PAGE_SHIFT
argument_list|,
name|cache_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_ppgtt_unbind_object
parameter_list|(
name|struct
name|i915_hw_ppgtt
modifier|*
name|ppgtt
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|i915_ppgtt_clear_range
argument_list|(
name|ppgtt
argument_list|,
name|obj
operator|->
name|gtt_space
operator|->
name|start
operator|>>
name|PAGE_SHIFT
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_init_ppgtt
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|pd_offset
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|struct
name|i915_hw_ppgtt
modifier|*
name|ppgtt
init|=
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
decl_stmt|;
name|uint32_t
name|__iomem
modifier|*
name|pd_addr
decl_stmt|;
name|uint32_t
name|pd_entry
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
condition|)
return|return;
name|pd_addr
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt
operator|+
name|ppgtt
operator|->
name|pd_offset
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppgtt
operator|->
name|num_pd_entries
condition|;
name|i
operator|++
control|)
block|{
name|vm_paddr_t
name|pt_addr
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|needs_dmar
condition|)
name|pt_addr
operator|=
name|ppgtt
operator|->
name|pt_dma_addr
index|[
name|i
index|]
expr_stmt|;
else|else
name|pt_addr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|ppgtt
operator|->
name|pt_pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pd_entry
operator|=
name|GEN6_PDE_ADDR_ENCODE
argument_list|(
name|pt_addr
argument_list|)
expr_stmt|;
name|pd_entry
operator||=
name|GEN6_PDE_VALID
expr_stmt|;
comment|/* NOTE Linux<->FreeBSD: Arguments of writel() are reversed. */
name|writel
argument_list|(
name|pd_addr
operator|+
name|i
argument_list|,
name|pd_entry
argument_list|)
expr_stmt|;
block|}
name|readl
argument_list|(
name|pd_addr
argument_list|)
expr_stmt|;
name|pd_offset
operator|=
name|ppgtt
operator|->
name|pd_offset
expr_stmt|;
name|pd_offset
operator|/=
literal|64
expr_stmt|;
comment|/* in cachelines, */
name|pd_offset
operator|<<=
literal|16
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|==
literal|6
condition|)
block|{
name|uint32_t
name|ecochk
decl_stmt|,
name|gab_ctl
decl_stmt|,
name|ecobits
decl_stmt|;
name|ecobits
operator|=
name|I915_READ
argument_list|(
name|GAC_ECO_BITS
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GAC_ECO_BITS
argument_list|,
name|ecobits
operator||
name|ECOBITS_PPGTT_CACHE64B
argument_list|)
expr_stmt|;
name|gab_ctl
operator|=
name|I915_READ
argument_list|(
name|GAB_CTL
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GAB_CTL
argument_list|,
name|gab_ctl
operator||
name|GAB_CTL_CONT_AFTER_PAGEFAULT
argument_list|)
expr_stmt|;
name|ecochk
operator|=
name|I915_READ
argument_list|(
name|GAM_ECOCHK
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GAM_ECOCHK
argument_list|,
name|ecochk
operator||
name|ECOCHK_SNB_BIT
operator||
name|ECOCHK_PPGTT_CACHE64B
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GFX_MODE
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|GFX_PPGTT_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|7
condition|)
block|{
name|I915_WRITE
argument_list|(
name|GAM_ECOCHK
argument_list|,
name|ECOCHK_PPGTT_CACHE64B
argument_list|)
expr_stmt|;
comment|/* GFX_MODE is per-ring on gen7+ */
block|}
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|7
condition|)
name|I915_WRITE
argument_list|(
name|RING_MODE_GEN7
argument_list|(
name|ring
argument_list|)
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|GFX_PPGTT_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RING_PP_DIR_DCLV
argument_list|(
name|ring
argument_list|)
argument_list|,
name|PP_DIR_DCLV_2G
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RING_PP_DIR_BASE
argument_list|(
name|ring
argument_list|)
argument_list|,
name|pd_offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|do_idling
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|bool
name|ret
init|=
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|do_idle_maps
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|i915_gpu_idle
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Couldn't idle GPU\n"
argument_list|)
expr_stmt|;
comment|/* Wait a bit, in hopes it avoids the hang */
name|udelay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|undo_idling
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|bool
name|interruptible
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|do_idle_maps
argument_list|)
condition|)
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|interruptible
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_ggtt_clear_range
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|first_entry
parameter_list|,
name|unsigned
name|num_entries
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|gtt_pte_t
name|scratch_pte
decl_stmt|;
name|gtt_pte_t
name|__iomem
modifier|*
name|gtt_base
init|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt
operator|+
name|first_entry
decl_stmt|;
specifier|const
name|int
name|max_entries
init|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_total_entries
operator|-
name|first_entry
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|6
condition|)
block|{
name|intel_gtt_clear_range
argument_list|(
name|first_entry
argument_list|,
name|num_entries
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|WARN
argument_list|(
name|num_entries
operator|>
name|max_entries
argument_list|,
literal|"First entry = %d; Num entries = %d (max=%d)\n"
argument_list|,
name|first_entry
argument_list|,
name|num_entries
argument_list|,
name|max_entries
argument_list|)
condition|)
name|num_entries
operator|=
name|max_entries
expr_stmt|;
name|scratch_pte
operator|=
name|pte_encode
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|scratch_page_dma
argument_list|,
name|I915_CACHE_LLC
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
control|)
name|iowrite32
argument_list|(
name|scratch_pte
argument_list|,
operator|&
name|gtt_base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|readl
argument_list|(
name|gtt_base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_restore_gtt_mappings
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
comment|/* First fill our portion of the GTT with scratch pages */
name|i915_ggtt_clear_range
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_start
operator|/
name|PAGE_SIZE
argument_list|,
operator|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_end
operator|-
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_start
operator|)
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|&dev_priv->mm.bound_list
argument_list|,
argument|gtt_list
argument_list|)
block|{
name|i915_gem_clflush_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|i915_gem_gtt_bind_object
argument_list|(
name|obj
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
block|}
name|i915_gem_chipset_flush
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_gtt_prepare_object
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|has_dma_mapping
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
if|if
condition|(
operator|!
name|dma_map_sg
argument_list|(
operator|&
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|obj
operator|->
name|pages
operator|->
name|sgl
argument_list|,
name|obj
operator|->
name|pages
operator|->
name|nents
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
condition|)
return|return
operator|-
name|ENOSPC
return|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Binds an object into the global gtt with the specified cache level. The object  * will be accessible to the GPU via commands whose operands reference offsets  * within the global GTT as well as accessible by the GPU through the GMADR  * mapped BAR (dev_priv->mm.gtt->gtt).  */
end_comment

begin_function
specifier|static
name|void
name|gen6_ggtt_bind_object
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|enum
name|i915_cache_level
name|level
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
specifier|const
name|int
name|first_entry
init|=
name|obj
operator|->
name|gtt_space
operator|->
name|start
operator|>>
name|PAGE_SHIFT
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INVARIANTS
argument_list|)
specifier|const
name|int
name|max_entries
init|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_total_entries
operator|-
name|first_entry
decl_stmt|;
endif|#
directive|endif
name|gtt_pte_t
name|__iomem
modifier|*
name|gtt_entries
init|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt
operator|+
name|first_entry
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|vm_paddr_t
name|addr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|obj
operator|->
name|base
operator|.
name|size
operator|>>
name|PAGE_SHIFT
condition|;
operator|++
name|i
control|)
block|{
name|addr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|obj
operator|->
name|pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|iowrite32
argument_list|(
name|pte_encode
argument_list|(
name|dev
argument_list|,
name|addr
argument_list|,
name|level
argument_list|)
argument_list|,
operator|&
name|gtt_entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|BUG_ON
argument_list|(
name|i
operator|>
name|max_entries
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|i
operator|!=
name|obj
operator|->
name|base
operator|.
name|size
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* XXX: This serves as a posting read to make sure that the PTE has 	 * actually been updated. There is some concern that even though 	 * registers and PTEs are within the same BAR that they are potentially 	 * of NUMA access patterns. Therefore, even with the way we assume 	 * hardware should work, we must keep this posting read for paranoia. 	 */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|WARN_ON
argument_list|(
name|readl
argument_list|(
operator|&
name|gtt_entries
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|pte_encode
argument_list|(
name|dev
argument_list|,
name|addr
argument_list|,
name|level
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This next bit makes the above posting read even more important. We 	 * want to flush the TLBs only after we're certain all the PTE updates 	 * have finished. 	 */
name|I915_WRITE
argument_list|(
name|GFX_FLSH_CNTL_GEN6
argument_list|,
name|GFX_FLSH_CNTL_EN
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|GFX_FLSH_CNTL_GEN6
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_gtt_bind_object
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|enum
name|i915_cache_level
name|cache_level
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|6
condition|)
block|{
name|unsigned
name|int
name|flags
init|=
operator|(
name|cache_level
operator|==
name|I915_CACHE_NONE
operator|)
condition|?
name|AGP_USER_MEMORY
else|:
name|AGP_USER_CACHED_MEMORY
decl_stmt|;
name|intel_gtt_insert_pages
argument_list|(
name|obj
operator|->
name|gtt_space
operator|->
name|start
operator|>>
name|PAGE_SHIFT
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
operator|>>
name|PAGE_SHIFT
argument_list|,
name|obj
operator|->
name|pages
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gen6_ggtt_bind_object
argument_list|(
name|obj
argument_list|,
name|cache_level
argument_list|)
expr_stmt|;
block|}
name|obj
operator|->
name|has_global_gtt_mapping
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_gtt_unbind_object
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|i915_ggtt_clear_range
argument_list|(
name|obj
operator|->
name|base
operator|.
name|dev
argument_list|,
name|obj
operator|->
name|gtt_space
operator|->
name|start
operator|>>
name|PAGE_SHIFT
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
name|obj
operator|->
name|has_global_gtt_mapping
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_gtt_finish_object
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|bool
name|interruptible
decl_stmt|;
name|interruptible
operator|=
name|do_idling
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
if|if
condition|(
operator|!
name|obj
operator|->
name|has_dma_mapping
condition|)
name|dma_unmap_sg
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|obj
operator|->
name|pages
operator|->
name|sgl
argument_list|,
name|obj
operator|->
name|pages
operator|->
name|nents
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|undo_idling
argument_list|(
name|dev_priv
argument_list|,
name|interruptible
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gtt_color_adjust
parameter_list|(
name|struct
name|drm_mm_node
modifier|*
name|node
parameter_list|,
name|unsigned
name|long
name|color
parameter_list|,
name|unsigned
name|long
modifier|*
name|start
parameter_list|,
name|unsigned
name|long
modifier|*
name|end
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|color
operator|!=
name|color
condition|)
operator|*
name|start
operator|+=
literal|4096
expr_stmt|;
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|node
operator|->
name|node_list
argument_list|)
condition|)
block|{
name|node
operator|=
name|list_entry
argument_list|(
name|node
operator|->
name|node_list
operator|.
name|next
argument_list|,
expr|struct
name|drm_mm_node
argument_list|,
name|node_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|allocated
operator|&&
name|node
operator|->
name|color
operator|!=
name|color
condition|)
operator|*
name|end
operator|-=
literal|4096
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|i915_gem_init_global_gtt
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|start
parameter_list|,
name|unsigned
name|long
name|mappable_end
parameter_list|,
name|unsigned
name|long
name|end
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* Subtract the guard page ... */
name|drm_mm_init
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_space
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
operator|-
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HAS_LLC
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_space
operator|.
name|color_adjust
operator|=
name|i915_gtt_color_adjust
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_start
operator|=
name|start
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mappable_end
operator|=
name|mappable_end
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_end
operator|=
name|end
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_total
operator|=
name|end
operator|-
name|start
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|mappable_gtt_total
operator|=
name|min
argument_list|(
name|end
argument_list|,
name|mappable_end
argument_list|)
operator|-
name|start
expr_stmt|;
comment|/* ... but ensure that we clear the entire range. */
name|i915_ggtt_clear_range
argument_list|(
name|dev
argument_list|,
name|start
operator|/
name|PAGE_SIZE
argument_list|,
operator|(
name|end
operator|-
name|start
operator|)
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
literal|"taking over the fictitious range 0x%jx-0x%jx\n"
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
operator|+
name|start
argument_list|)
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
operator|+
name|start
operator|+
name|dev_priv
operator|->
name|mm
operator|.
name|mappable_gtt_total
argument_list|)
argument_list|)
expr_stmt|;
name|vm_phys_fictitious_reg_range
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
operator|+
name|start
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
operator|+
name|start
operator|+
name|dev_priv
operator|->
name|mm
operator|.
name|mappable_gtt_total
argument_list|,
name|VM_MEMATTR_WRITE_COMBINING
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|setup_scratch_page
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|vm_page_t
name|page
decl_stmt|;
name|dma_addr_t
name|dma_addr
decl_stmt|;
name|int
name|tries
init|=
literal|0
decl_stmt|;
name|int
name|req
init|=
name|VM_ALLOC_ZERO
operator||
name|VM_ALLOC_NOOBJ
decl_stmt|;
name|retry
label|:
name|page
operator|=
name|vm_page_alloc_contig
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|req
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|VM_MEMATTR_UNCACHEABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tries
operator|<
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|vm_page_reclaim_contig
argument_list|(
name|req
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
condition|)
name|VM_WAIT
expr_stmt|;
name|tries
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
return|return
operator|-
name|ENOMEM
return|;
block|}
if|if
condition|(
operator|(
name|page
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pmap_zero_page
argument_list|(
name|page
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_INTEL_IOMMU
name|dma_addr
operator|=
name|pci_map_page
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|page
argument_list|,
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_dma_mapping_error
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|dma_addr
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
else|#
directive|else
name|dma_addr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|page
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|scratch_page
operator|=
name|page
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|scratch_page_dma
operator|=
name|dma_addr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|teardown_scratch_page
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_INTEL_IOMMU
comment|/*<- Added as a marker on FreeBSD. */
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|pci_unmap_page
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|scratch_page_dma
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|gen6_get_total_gtt_size
parameter_list|(
name|u16
name|snb_gmch_ctl
parameter_list|)
block|{
name|snb_gmch_ctl
operator|>>=
name|SNB_GMCH_GGMS_SHIFT
expr_stmt|;
name|snb_gmch_ctl
operator|&=
name|SNB_GMCH_GGMS_MASK
expr_stmt|;
return|return
name|snb_gmch_ctl
operator|<<
literal|20
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|gen6_get_stolen_size
parameter_list|(
name|u16
name|snb_gmch_ctl
parameter_list|)
block|{
name|snb_gmch_ctl
operator|>>=
name|SNB_GMCH_GMS_SHIFT
expr_stmt|;
name|snb_gmch_ctl
operator|&=
name|SNB_GMCH_GMS_MASK
expr_stmt|;
return|return
name|snb_gmch_ctl
operator|<<
literal|25
return|;
comment|/* 32 MB units */
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|gen7_get_stolen_size
parameter_list|(
name|u16
name|snb_gmch_ctl
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|stolen_decoder
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
literal|48
block|,
literal|64
block|,
literal|128
block|,
literal|256
block|,
literal|96
block|,
literal|160
block|,
literal|224
block|,
literal|352
block|}
decl_stmt|;
name|snb_gmch_ctl
operator|>>=
name|IVB_GMCH_GMS_SHIFT
expr_stmt|;
name|snb_gmch_ctl
operator|&=
name|IVB_GMCH_GMS_MASK
expr_stmt|;
return|return
name|stolen_decoder
index|[
name|snb_gmch_ctl
index|]
operator|<<
literal|20
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_gtt_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|vm_paddr_t
name|gtt_bus_addr
decl_stmt|;
name|u16
name|snb_gmch_ctl
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* On modern platforms we need not worry ourself with the legacy 	 * hostbridge query stuff. Skip it entirely 	 */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|6
condition|)
block|{
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|ret
operator|=
name|intel_gmch_probe
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|dev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to set up gmch\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|=
name|intel_gtt_get
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed to initialize GTT\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|intel_gmch_remove
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
return|return
operator|-
name|ENODEV
return|;
block|}
return|return
literal|0
return|;
block|}
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
condition|)
return|return
operator|-
name|ENOMEM
return|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
if|if
condition|(
operator|!
name|pci_set_dma_mask
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|40
argument_list|)
argument_list|)
condition|)
name|pci_set_consistent_dma_mask
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|40
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
ifdef|#
directive|ifdef
name|CONFIG_INTEL_IOMMU
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|needs_dmar
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* For GEN6+ the PTEs for the ggtt live at 2MB + BAR0 */
name|gtt_bus_addr
operator|=
name|drm_get_resource_start
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
operator|+
operator|(
literal|2
operator|<<
literal|20
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gma_bus_addr
operator|=
name|drm_get_resource_start
argument_list|(
name|dev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* i9xx_setup */
name|pci_read_config_word
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|SNB_GMCH_CTRL
argument_list|,
operator|&
name|snb_gmch_ctl
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_total_entries
operator|=
name|gen6_get_total_gtt_size
argument_list|(
name|snb_gmch_ctl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|gtt_pte_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|7
condition|)
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|stolen_size
operator|=
name|gen6_get_stolen_size
argument_list|(
name|snb_gmch_ctl
argument_list|)
expr_stmt|;
else|else
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|stolen_size
operator|=
name|gen7_get_stolen_size
argument_list|(
name|snb_gmch_ctl
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_mappable_entries
operator|=
name|drm_get_resource_len
argument_list|(
name|dev
argument_list|,
literal|2
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
comment|/* 64/512MB is the current min/max we actually know of, but this is just a 	 * coarse sanity check. 	 */
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_mappable_entries
operator|>>
literal|8
operator|)
operator|<
literal|64
operator|||
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_mappable_entries
operator|>
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_total_entries
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unknown GMADR entries (%d)\n"
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_mappable_entries
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ENXIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|ret
operator|=
name|setup_scratch_page
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Scratch setup failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt
operator|=
name|pmap_mapdev_attr
argument_list|(
name|gtt_bus_addr
argument_list|,
comment|/* The size is used later by pmap_unmapdev. */
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_total_entries
operator|*
sizeof|sizeof
argument_list|(
name|gtt_pte_t
argument_list|)
argument_list|,
name|VM_MEMATTR_WRITE_COMBINING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed to map the gtt page table\n"
argument_list|)
expr_stmt|;
name|teardown_scratch_page
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* GMADR is the PCI aperture used by SW to access tiled GFX surfaces in a linear fashion. */
name|DRM_INFO
argument_list|(
literal|"Memory usable by graphics device = %dM\n"
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_total_entries
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"GMADR size = %dM\n"
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_mappable_entries
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"GTT stolen size = %dM\n"
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|stolen_size
operator|>>
literal|20
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_out
label|:
name|free
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|6
condition|)
name|intel_gmch_remove
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_gtt_fini
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_total_entries
operator|*
sizeof|sizeof
argument_list|(
name|gtt_pte_t
argument_list|)
argument_list|)
expr_stmt|;
name|teardown_scratch_page
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|6
condition|)
name|intel_gmch_remove
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|6
condition|)
name|free
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

