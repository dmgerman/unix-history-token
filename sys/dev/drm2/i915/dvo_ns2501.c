begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Copyright (c) 2012 Gilles Dartiguelongue, Thomas Richter  *  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the  * "Software"), to deal in the Software without restriction, including  * without limitation the rights to use, copy, modify, merge, publish,  * distribute, sub license, and/or sell copies of the Software, and to  * permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"dvo.h"
end_include

begin_include
include|#
directive|include
file|"i915_reg.h"
end_include

begin_include
include|#
directive|include
file|"i915_drv.h"
end_include

begin_define
define|#
directive|define
name|NS2501_VID
value|0x1305
end_define

begin_define
define|#
directive|define
name|NS2501_DID
value|0x6726
end_define

begin_define
define|#
directive|define
name|NS2501_VID_LO
value|0x00
end_define

begin_define
define|#
directive|define
name|NS2501_VID_HI
value|0x01
end_define

begin_define
define|#
directive|define
name|NS2501_DID_LO
value|0x02
end_define

begin_define
define|#
directive|define
name|NS2501_DID_HI
value|0x03
end_define

begin_define
define|#
directive|define
name|NS2501_REV
value|0x04
end_define

begin_define
define|#
directive|define
name|NS2501_RSVD
value|0x05
end_define

begin_define
define|#
directive|define
name|NS2501_FREQ_LO
value|0x06
end_define

begin_define
define|#
directive|define
name|NS2501_FREQ_HI
value|0x07
end_define

begin_define
define|#
directive|define
name|NS2501_REG8
value|0x08
end_define

begin_define
define|#
directive|define
name|NS2501_8_VEN
value|(1<<5)
end_define

begin_define
define|#
directive|define
name|NS2501_8_HEN
value|(1<<4)
end_define

begin_define
define|#
directive|define
name|NS2501_8_DSEL
value|(1<<3)
end_define

begin_define
define|#
directive|define
name|NS2501_8_BPAS
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|NS2501_8_RSVD
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|NS2501_8_PD
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|NS2501_REG9
value|0x09
end_define

begin_define
define|#
directive|define
name|NS2501_9_VLOW
value|(1<<7)
end_define

begin_define
define|#
directive|define
name|NS2501_9_MSEL_MASK
value|(0x7<<4)
end_define

begin_define
define|#
directive|define
name|NS2501_9_TSEL
value|(1<<3)
end_define

begin_define
define|#
directive|define
name|NS2501_9_RSEN
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|NS2501_9_RSVD
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|NS2501_9_MDI
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|NS2501_REGC
value|0x0c
end_define

begin_struct
struct|struct
name|ns2501_priv
block|{
comment|//I2CDevRec d;
name|bool
name|quiet
decl_stmt|;
name|int
name|reg_8_shadow
decl_stmt|;
name|int
name|reg_8_set
decl_stmt|;
comment|// Shadow registers for i915
name|int
name|dvoc
decl_stmt|;
name|int
name|pll_a
decl_stmt|;
name|int
name|srcdim
decl_stmt|;
name|int
name|fw_blc
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NSPTR
parameter_list|(
name|d
parameter_list|)
value|((NS2501Ptr)(d->DriverPrivate.ptr))
end_define

begin_comment
comment|/*  * For reasons unclear to me, the ns2501 at least on the Fujitsu/Siemens  * laptops does not react on the i2c bus unless  * both the PLL is running and the display is configured in its native  * resolution.  * This function forces the DVO on, and stores the registers it touches.  * Afterwards, registers are restored to regular values.  *  * This is pretty much a hack, though it works.  * Without that, ns2501_readb and ns2501_writeb fail  * when switching the resolution.  */
end_comment

begin_function
specifier|static
name|void
name|enable_dvo
parameter_list|(
name|struct
name|intel_dvo_device
modifier|*
name|dvo
parameter_list|)
block|{
name|struct
name|ns2501_priv
modifier|*
name|ns
init|=
operator|(
expr|struct
name|ns2501_priv
operator|*
operator|)
operator|(
name|dvo
operator|->
name|dev_priv
operator|)
decl_stmt|;
name|device_t
name|adapter
init|=
name|dvo
operator|->
name|i2c_bus
decl_stmt|;
comment|/* 	 * FIXME Linux<->FreeBSD: device_get_softc() returns a struct 	 * intel_iic_softc in reality, where struct intel_gmbus is 	 * the first member. struct intel_iic_softc is defined in 	 * intel_iic.c. 	 */
name|struct
name|intel_gmbus
modifier|*
name|bus
init|=
operator|(
expr|struct
name|intel_gmbus
operator|*
operator|)
name|device_get_softc
argument_list|(
name|adapter
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|bus
operator|->
name|dev_priv
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"%s: Trying to re-enable the DVO\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|ns
operator|->
name|dvoc
operator|=
name|I915_READ
argument_list|(
name|DVO_C
argument_list|)
expr_stmt|;
name|ns
operator|->
name|pll_a
operator|=
name|I915_READ
argument_list|(
name|_DPLL_A
argument_list|)
expr_stmt|;
name|ns
operator|->
name|srcdim
operator|=
name|I915_READ
argument_list|(
name|DVOC_SRCDIM
argument_list|)
expr_stmt|;
name|ns
operator|->
name|fw_blc
operator|=
name|I915_READ
argument_list|(
name|FW_BLC
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DVOC
argument_list|,
literal|0x10004084
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_DPLL_A
argument_list|,
literal|0xd0820000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DVOC_SRCDIM
argument_list|,
literal|0x400300
argument_list|)
expr_stmt|;
comment|// 1024x768
name|I915_WRITE
argument_list|(
name|FW_BLC
argument_list|,
literal|0x1080304
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DVOC
argument_list|,
literal|0x90004084
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore the I915 registers modified by the above  * trigger function.  */
end_comment

begin_function
specifier|static
name|void
name|restore_dvo
parameter_list|(
name|struct
name|intel_dvo_device
modifier|*
name|dvo
parameter_list|)
block|{
name|device_t
name|adapter
init|=
name|dvo
operator|->
name|i2c_bus
decl_stmt|;
comment|/* 	 * FIXME Linux<->FreeBSD: device_get_softc() returns a struct 	 * intel_iic_softc in reality, where struct intel_gmbus is 	 * the first member. struct intel_iic_softc is defined in 	 * intel_iic.c. 	 */
name|struct
name|intel_gmbus
modifier|*
name|bus
init|=
operator|(
expr|struct
name|intel_gmbus
operator|*
operator|)
name|device_get_softc
argument_list|(
name|adapter
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|bus
operator|->
name|dev_priv
decl_stmt|;
name|struct
name|ns2501_priv
modifier|*
name|ns
init|=
operator|(
expr|struct
name|ns2501_priv
operator|*
operator|)
operator|(
name|dvo
operator|->
name|dev_priv
operator|)
decl_stmt|;
name|I915_WRITE
argument_list|(
name|DVOC
argument_list|,
name|ns
operator|->
name|dvoc
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_DPLL_A
argument_list|,
name|ns
operator|->
name|pll_a
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DVOC_SRCDIM
argument_list|,
name|ns
operator|->
name|srcdim
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FW_BLC
argument_list|,
name|ns
operator|->
name|fw_blc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Read a register from the ns2501. ** Returns true if successful, false otherwise. ** If it returns false, it might be wise to enable the ** DVO with the above function. */
end_comment

begin_function
specifier|static
name|bool
name|ns2501_readb
parameter_list|(
name|struct
name|intel_dvo_device
modifier|*
name|dvo
parameter_list|,
name|int
name|addr
parameter_list|,
name|uint8_t
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|ns2501_priv
modifier|*
name|ns
init|=
name|dvo
operator|->
name|dev_priv
decl_stmt|;
name|device_t
name|adapter
init|=
name|dvo
operator|->
name|i2c_bus
decl_stmt|;
name|u8
name|out_buf
index|[
literal|2
index|]
decl_stmt|;
name|u8
name|in_buf
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|iic_msg
name|msgs
index|[]
init|=
block|{
block|{
operator|.
name|slave
operator|=
name|dvo
operator|->
name|slave_addr
operator|<<
literal|1
block|,
operator|.
name|flags
operator|=
literal|0
block|,
operator|.
name|len
operator|=
literal|1
block|,
operator|.
name|buf
operator|=
name|out_buf
block|, 		 }
block|,
block|{
operator|.
name|slave
operator|=
name|dvo
operator|->
name|slave_addr
operator|<<
literal|1
block|,
operator|.
name|flags
operator|=
name|I2C_M_RD
block|,
operator|.
name|len
operator|=
literal|1
block|,
operator|.
name|buf
operator|=
name|in_buf
block|, 		 }
block|}
decl_stmt|;
name|out_buf
index|[
literal|0
index|]
operator|=
name|addr
expr_stmt|;
name|out_buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|-
name|iicbus_transfer
argument_list|(
name|adapter
argument_list|,
name|msgs
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|ch
operator|=
name|in_buf
index|[
literal|0
index|]
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|!
name|ns
operator|->
name|quiet
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unable to read register 0x%02x from %s:0x%02x.\n"
argument_list|,
name|addr
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
argument_list|)
argument_list|,
name|dvo
operator|->
name|slave_addr
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* ** Write a register to the ns2501. ** Returns true if successful, false otherwise. ** If it returns false, it might be wise to enable the ** DVO with the above function. */
end_comment

begin_function
specifier|static
name|bool
name|ns2501_writeb
parameter_list|(
name|struct
name|intel_dvo_device
modifier|*
name|dvo
parameter_list|,
name|int
name|addr
parameter_list|,
name|uint8_t
name|ch
parameter_list|)
block|{
name|struct
name|ns2501_priv
modifier|*
name|ns
init|=
name|dvo
operator|->
name|dev_priv
decl_stmt|;
name|device_t
name|adapter
init|=
name|dvo
operator|->
name|i2c_bus
decl_stmt|;
name|uint8_t
name|out_buf
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|iic_msg
name|msg
init|=
block|{
operator|.
name|slave
operator|=
name|dvo
operator|->
name|slave_addr
operator|<<
literal|1
block|,
operator|.
name|flags
operator|=
literal|0
block|,
operator|.
name|len
operator|=
literal|2
block|,
operator|.
name|buf
operator|=
name|out_buf
block|, 	}
decl_stmt|;
name|out_buf
index|[
literal|0
index|]
operator|=
name|addr
expr_stmt|;
name|out_buf
index|[
literal|1
index|]
operator|=
name|ch
expr_stmt|;
if|if
condition|(
operator|-
name|iicbus_transfer
argument_list|(
name|adapter
argument_list|,
operator|&
name|msg
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
operator|!
name|ns
operator|->
name|quiet
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unable to write register 0x%02x to %s:%d\n"
argument_list|,
name|addr
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
argument_list|)
argument_list|,
name|dvo
operator|->
name|slave_addr
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* National Semiconductor 2501 driver for chip on i2c bus  * scan for the chip on the bus.  * Hope the VBIOS initialized the PLL correctly so we can  * talk to it. If not, it will not be seen and not detected.  * Bummer!  */
end_comment

begin_function
specifier|static
name|bool
name|ns2501_init
parameter_list|(
name|struct
name|intel_dvo_device
modifier|*
name|dvo
parameter_list|,
name|device_t
name|adapter
parameter_list|)
block|{
comment|/* this will detect the NS2501 chip on the specified i2c bus */
name|struct
name|ns2501_priv
modifier|*
name|ns
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
name|ns
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ns2501_priv
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|dvo
operator|->
name|i2c_bus
operator|=
name|adapter
expr_stmt|;
name|dvo
operator|->
name|dev_priv
operator|=
name|ns
expr_stmt|;
name|ns
operator|->
name|quiet
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|ns2501_readb
argument_list|(
name|dvo
argument_list|,
name|NS2501_VID_LO
argument_list|,
operator|&
name|ch
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ch
operator|!=
operator|(
name|NS2501_VID
operator|&
literal|0xff
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"ns2501 not detected got %d: from %s Slave %d.\n"
argument_list|,
name|ch
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
argument_list|)
argument_list|,
name|dvo
operator|->
name|slave_addr
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|ns2501_readb
argument_list|(
name|dvo
argument_list|,
name|NS2501_DID_LO
argument_list|,
operator|&
name|ch
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ch
operator|!=
operator|(
name|NS2501_DID
operator|&
literal|0xff
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"ns2501 not detected got %d: from %s Slave %d.\n"
argument_list|,
name|ch
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
argument_list|)
argument_list|,
name|dvo
operator|->
name|slave_addr
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ns
operator|->
name|quiet
operator|=
name|false
expr_stmt|;
name|ns
operator|->
name|reg_8_set
operator|=
literal|0
expr_stmt|;
name|ns
operator|->
name|reg_8_shadow
operator|=
name|NS2501_8_PD
operator||
name|NS2501_8_BPAS
operator||
name|NS2501_8_VEN
operator||
name|NS2501_8_HEN
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"init ns2501 dvo controller successfully!\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|out
label|:
name|free
argument_list|(
name|ns
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|drm_connector_status
name|ns2501_detect
parameter_list|(
name|struct
name|intel_dvo_device
modifier|*
name|dvo
parameter_list|)
block|{
comment|/* 	 * This is a Laptop display, it doesn't have hotplugging. 	 * Even if not, the detection bit of the 2501 is unreliable as 	 * it only works for some display types. 	 * It is even more unreliable as the PLL must be active for 	 * allowing reading from the chiop. 	 */
return|return
name|connector_status_connected
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|drm_mode_status
name|ns2501_mode_valid
parameter_list|(
name|struct
name|intel_dvo_device
modifier|*
name|dvo
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"%s: is mode valid (hdisplay=%d,htotal=%d,vdisplay=%d,vtotal=%d)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|mode
operator|->
name|hdisplay
argument_list|,
name|mode
operator|->
name|htotal
argument_list|,
name|mode
operator|->
name|vdisplay
argument_list|,
name|mode
operator|->
name|vtotal
argument_list|)
expr_stmt|;
comment|/* 	 * Currently, these are all the modes I have data from. 	 * More might exist. Unclear how to find the native resolution 	 * of the panel in here so we could always accept it 	 * by disabling the scaler. 	 */
if|if
condition|(
operator|(
name|mode
operator|->
name|hdisplay
operator|==
literal|800
operator|&&
name|mode
operator|->
name|vdisplay
operator|==
literal|600
operator|)
operator|||
operator|(
name|mode
operator|->
name|hdisplay
operator|==
literal|640
operator|&&
name|mode
operator|->
name|vdisplay
operator|==
literal|480
operator|)
operator|||
operator|(
name|mode
operator|->
name|hdisplay
operator|==
literal|1024
operator|&&
name|mode
operator|->
name|vdisplay
operator|==
literal|768
operator|)
condition|)
block|{
return|return
name|MODE_OK
return|;
block|}
else|else
block|{
return|return
name|MODE_ONE_SIZE
return|;
comment|/* Is this a reasonable error? */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ns2501_mode_set
parameter_list|(
name|struct
name|intel_dvo_device
modifier|*
name|dvo
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|bool
name|restore
init|=
name|false
decl_stmt|;
name|struct
name|ns2501_priv
modifier|*
name|ns
init|=
operator|(
expr|struct
name|ns2501_priv
operator|*
operator|)
operator|(
name|dvo
operator|->
name|dev_priv
operator|)
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"%s: set mode (hdisplay=%d,htotal=%d,vdisplay=%d,vtotal=%d).\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|mode
operator|->
name|hdisplay
argument_list|,
name|mode
operator|->
name|htotal
argument_list|,
name|mode
operator|->
name|vdisplay
argument_list|,
name|mode
operator|->
name|vtotal
argument_list|)
expr_stmt|;
comment|/* 	 * Where do I find the native resolution for which scaling is not required??? 	 * 	 * First trigger the DVO on as otherwise the chip does not appear on the i2c 	 * bus. 	 */
do|do
block|{
name|ok
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|hdisplay
operator|==
literal|800
operator|&&
name|mode
operator|->
name|vdisplay
operator|==
literal|600
condition|)
block|{
comment|/* mode 277 */
name|ns
operator|->
name|reg_8_shadow
operator|&=
operator|~
name|NS2501_8_BPAS
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"%s: switching to 800x600\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* 			 * No, I do not know where this data comes from. 			 * It is just what the video bios left in the DVO, so 			 * I'm just copying it here over. 			 * This also means that I cannot support any other modes 			 * except the ones supported by the bios. 			 */
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x11
argument_list|,
literal|0xc8
argument_list|)
expr_stmt|;
comment|// 0xc7 also works.
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x1b
argument_list|,
literal|0x19
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x1c
argument_list|,
literal|0x62
argument_list|)
expr_stmt|;
comment|// VBIOS left 0x64 here, but 0x62 works nicer
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x1d
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x34
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x35
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x80
argument_list|,
literal|0x27
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x81
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x82
argument_list|,
literal|0x41
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x83
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x8d
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x8e
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x8f
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x90
argument_list|,
literal|0xfe
argument_list|)
expr_stmt|;
comment|/* vertical. VBIOS left 0xff here, but 0xfe works better */
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x91
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x94
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x95
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x96
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x99
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x9a
argument_list|,
literal|0x88
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x9c
argument_list|,
literal|0x23
argument_list|)
expr_stmt|;
comment|/* Looks like first and last line of the image. */
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x9d
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x9e
argument_list|,
literal|0x25
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x9f
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xa4
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xb6
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xb9
argument_list|,
literal|0xc8
argument_list|)
expr_stmt|;
comment|/* horizontal? */
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xba
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* horizontal? */
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc0
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* horizontal? */
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc1
argument_list|,
literal|0xd7
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc2
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc3
argument_list|,
literal|0xf8
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc4
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc5
argument_list|,
literal|0x1a
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc6
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc7
argument_list|,
literal|0x73
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc8
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|->
name|hdisplay
operator|==
literal|640
operator|&&
name|mode
operator|->
name|vdisplay
operator|==
literal|480
condition|)
block|{
comment|/* mode 274 */
name|DRM_DEBUG_KMS
argument_list|(
literal|"%s: switching to 640x480\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* 			 * No, I do not know where this data comes from. 			 * It is just what the video bios left in the DVO, so 			 * I'm just copying it here over. 			 * This also means that I cannot support any other modes 			 * except the ones supported by the bios. 			 */
name|ns
operator|->
name|reg_8_shadow
operator|&=
operator|~
name|NS2501_8_BPAS
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x11
argument_list|,
literal|0xa0
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x1b
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x1c
argument_list|,
literal|0x54
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x1d
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x34
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x35
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x80
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x81
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x82
argument_list|,
literal|0x3d
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x83
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x8d
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x8e
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x8f
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x90
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* vertical */
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x91
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x94
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x95
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x96
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x99
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x9a
argument_list|,
literal|0x88
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x9c
argument_list|,
literal|0x24
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x9d
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x9e
argument_list|,
literal|0x25
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x9f
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xa4
argument_list|,
literal|0x84
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xb6
argument_list|,
literal|0x09
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xb9
argument_list|,
literal|0xa0
argument_list|)
expr_stmt|;
comment|/* horizontal? */
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xba
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* horizontal? */
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc0
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* horizontal? */
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc1
argument_list|,
literal|0x90
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc2
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc3
argument_list|,
literal|0x0f
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc4
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc5
argument_list|,
literal|0x16
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc6
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc7
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0xc8
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|->
name|hdisplay
operator|==
literal|1024
operator|&&
name|mode
operator|->
name|vdisplay
operator|==
literal|768
condition|)
block|{
comment|/* mode 280 */
name|DRM_DEBUG_KMS
argument_list|(
literal|"%s: switching to 1024x768\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* 			 * This might or might not work, actually. I'm silently 			 * assuming here that the native panel resolution is 			 * 1024x768. If not, then this leaves the scaler disabled 			 * generating a picture that is likely not the expected. 			 * 			 * Problem is that I do not know where to take the panel 			 * dimensions from. 			 * 			 * Enable the bypass, scaling not required. 			 * 			 * The scaler registers are irrelevant here.... 			 * 			 */
name|ns
operator|->
name|reg_8_shadow
operator||=
name|NS2501_8_BPAS
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x37
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Data not known. Bummer! 			 * Hopefully, the code should not go here 			 * as mode_OK delivered no other modes. 			 */
name|ns
operator|->
name|reg_8_shadow
operator||=
name|NS2501_8_BPAS
expr_stmt|;
block|}
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
name|NS2501_REG8
argument_list|,
name|ns
operator|->
name|reg_8_shadow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|restore
condition|)
name|restore_dvo
argument_list|(
name|dvo
argument_list|)
expr_stmt|;
name|enable_dvo
argument_list|(
name|dvo
argument_list|)
expr_stmt|;
name|restore
operator|=
name|true
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|ok
condition|)
do|;
comment|/* 	 * Restore the old i915 registers before 	 * forcing the ns2501 on. 	 */
if|if
condition|(
name|restore
condition|)
name|restore_dvo
argument_list|(
name|dvo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set the NS2501 power state */
end_comment

begin_function
specifier|static
name|bool
name|ns2501_get_hw_state
parameter_list|(
name|struct
name|intel_dvo_device
modifier|*
name|dvo
parameter_list|)
block|{
name|unsigned
name|char
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|ns2501_readb
argument_list|(
name|dvo
argument_list|,
name|NS2501_REG8
argument_list|,
operator|&
name|ch
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ch
operator|&
name|NS2501_8_PD
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* set the NS2501 power state */
end_comment

begin_function
specifier|static
name|void
name|ns2501_dpms
parameter_list|(
name|struct
name|intel_dvo_device
modifier|*
name|dvo
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|bool
name|restore
init|=
name|false
decl_stmt|;
name|struct
name|ns2501_priv
modifier|*
name|ns
init|=
operator|(
expr|struct
name|ns2501_priv
operator|*
operator|)
operator|(
name|dvo
operator|->
name|dev_priv
operator|)
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"%s: Trying set the dpms of the DVO to %i\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|ch
operator|=
name|ns
operator|->
name|reg_8_shadow
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|ch
operator||=
name|NS2501_8_PD
expr_stmt|;
else|else
name|ch
operator|&=
operator|~
name|NS2501_8_PD
expr_stmt|;
if|if
condition|(
name|ns
operator|->
name|reg_8_set
operator|==
literal|0
operator|||
name|ns
operator|->
name|reg_8_shadow
operator|!=
name|ch
condition|)
block|{
name|ns
operator|->
name|reg_8_set
operator|=
literal|1
expr_stmt|;
name|ns
operator|->
name|reg_8_shadow
operator|=
name|ch
expr_stmt|;
do|do
block|{
name|ok
operator|=
name|true
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
name|NS2501_REG8
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x34
argument_list|,
name|enable
condition|?
literal|0x03
else|:
literal|0x00
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|ns2501_writeb
argument_list|(
name|dvo
argument_list|,
literal|0x35
argument_list|,
name|enable
condition|?
literal|0xff
else|:
literal|0x00
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|restore
condition|)
name|restore_dvo
argument_list|(
name|dvo
argument_list|)
expr_stmt|;
name|enable_dvo
argument_list|(
name|dvo
argument_list|)
expr_stmt|;
name|restore
operator|=
name|true
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|ok
condition|)
do|;
if|if
condition|(
name|restore
condition|)
name|restore_dvo
argument_list|(
name|dvo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ns2501_dump_regs
parameter_list|(
name|struct
name|intel_dvo_device
modifier|*
name|dvo
parameter_list|)
block|{
name|uint8_t
name|val
decl_stmt|;
name|ns2501_readb
argument_list|(
name|dvo
argument_list|,
name|NS2501_FREQ_LO
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|DRM_LOG_KMS
argument_list|(
literal|"NS2501_FREQ_LO: 0x%02x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ns2501_readb
argument_list|(
name|dvo
argument_list|,
name|NS2501_FREQ_HI
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|DRM_LOG_KMS
argument_list|(
literal|"NS2501_FREQ_HI: 0x%02x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ns2501_readb
argument_list|(
name|dvo
argument_list|,
name|NS2501_REG8
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|DRM_LOG_KMS
argument_list|(
literal|"NS2501_REG8: 0x%02x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ns2501_readb
argument_list|(
name|dvo
argument_list|,
name|NS2501_REG9
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|DRM_LOG_KMS
argument_list|(
literal|"NS2501_REG9: 0x%02x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ns2501_readb
argument_list|(
name|dvo
argument_list|,
name|NS2501_REGC
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|DRM_LOG_KMS
argument_list|(
literal|"NS2501_REGC: 0x%02x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ns2501_destroy
parameter_list|(
name|struct
name|intel_dvo_device
modifier|*
name|dvo
parameter_list|)
block|{
name|struct
name|ns2501_priv
modifier|*
name|ns
init|=
name|dvo
operator|->
name|dev_priv
decl_stmt|;
if|if
condition|(
name|ns
condition|)
block|{
name|free
argument_list|(
name|ns
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|dvo
operator|->
name|dev_priv
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|struct
name|intel_dvo_dev_ops
name|ns2501_ops
init|=
block|{
operator|.
name|init
operator|=
name|ns2501_init
block|,
operator|.
name|detect
operator|=
name|ns2501_detect
block|,
operator|.
name|mode_valid
operator|=
name|ns2501_mode_valid
block|,
operator|.
name|mode_set
operator|=
name|ns2501_mode_set
block|,
operator|.
name|dpms
operator|=
name|ns2501_dpms
block|,
operator|.
name|get_hw_state
operator|=
name|ns2501_get_hw_state
block|,
operator|.
name|dump_regs
operator|=
name|ns2501_dump_regs
block|,
operator|.
name|destroy
operator|=
name|ns2501_destroy
block|, }
decl_stmt|;
end_decl_stmt

end_unit

