begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Â© 2008 Intel Corporation  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  *  * Authors:  *    Eric Anholt<eric@anholt.net>  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<sys/sf_buf.h>
end_include

begin_comment
comment|/** @file i915_gem_tiling.c  *  * Support for managing tiling state of buffer objects.  *  * The idea behind tiling is to increase cache hit rates by rearranging  * pixel data so that a group of pixel accesses are in the same cacheline.  * Performance improvement from doing this on the back/depth buffer are on  * the order of 30%.  *  * Intel architectures make this somewhat more complicated, though, by  * adjustments made to addressing of data when the memory is in interleaved  * mode (matched pairs of DIMMS) to improve memory bandwidth.  * For interleaved memory, the CPU sends every sequential 64 bytes  * to an alternate memory channel so it can get the bandwidth from both.  *  * The GPU also rearranges its accesses for increased bandwidth to interleaved  * memory, and it matches what the CPU does for non-tiled.  However, when tiled  * it does it a little differently, since one walks addresses not just in the  * X direction but also Y.  So, along with alternating channels when bit  * 6 of the address flips, it also alternates when other bits flip --  Bits 9  * (every 512 bytes, an X tile scanline) and 10 (every two X tile scanlines)  * are common to both the 915 and 965-class hardware.  *  * The CPU also sometimes XORs in higher bits as well, to improve  * bandwidth doing strided access like we do so frequently in graphics.  This  * is called "Channel XOR Randomization" in the MCH documentation.  The result  * is that the CPU is XORing in either bit 11 or bit 17 to bit 6 of its address  * decode.  *  * All of this bit 6 XORing has an effect on our memory management,  * as we need to make sure that the 3d driver can correctly address object  * contents.  *  * If we don't have interleaved memory, all tiling is safe and no swizzling is  * required.  *  * When bit 17 is XORed in, we simply refuse to tile at all.  Bit  * 17 is not just a page offset, so as we page an objet out and back in,  * individual pages in it will have different bit 17 addresses, resulting in  * each 64 bytes being swapped with its neighbor!  *  * Otherwise, if interleaved, we have to tell the 3d driver what the address  * swizzling it needs to do is, since it's writing with the CPU to the pages  * (bit 6 and potentially bit 11 XORed in), and the GPU is reading from the  * pages (bit 6, 9, and 10 XORed in), resulting in a cumulative bit swizzling  * required by the CPU of XORing in bit 6, 9, 10, and potentially 11, in order  * to match what the GPU expects.  */
end_comment

begin_comment
comment|/**  * Detects bit 6 swizzling of address lookup between IGD access and CPU  * access through main memory.  */
end_comment

begin_function
name|void
name|i915_gem_detect_bit_6_swizzle
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|swizzle_x
init|=
name|I915_BIT_6_SWIZZLE_UNKNOWN
decl_stmt|;
name|uint32_t
name|swizzle_y
init|=
name|I915_BIT_6_SWIZZLE_UNKNOWN
decl_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|6
condition|)
block|{
name|uint32_t
name|dimm_c0
decl_stmt|,
name|dimm_c1
decl_stmt|;
name|dimm_c0
operator|=
name|I915_READ
argument_list|(
name|MAD_DIMM_C0
argument_list|)
expr_stmt|;
name|dimm_c1
operator|=
name|I915_READ
argument_list|(
name|MAD_DIMM_C1
argument_list|)
expr_stmt|;
name|dimm_c0
operator|&=
name|MAD_DIMM_A_SIZE_MASK
operator||
name|MAD_DIMM_B_SIZE_MASK
expr_stmt|;
name|dimm_c1
operator|&=
name|MAD_DIMM_A_SIZE_MASK
operator||
name|MAD_DIMM_B_SIZE_MASK
expr_stmt|;
comment|/* Enable swizzling when the channels are populated with 		 * identically sized dimms. We don't need to check the 3rd 		 * channel because no cpu with gpu attached ships in that 		 * configuration. Also, swizzling only makes sense for 2 		 * channels anyway. */
if|if
condition|(
name|dimm_c0
operator|==
name|dimm_c1
condition|)
block|{
name|swizzle_x
operator|=
name|I915_BIT_6_SWIZZLE_9_10
expr_stmt|;
name|swizzle_y
operator|=
name|I915_BIT_6_SWIZZLE_9
expr_stmt|;
block|}
else|else
block|{
name|swizzle_x
operator|=
name|I915_BIT_6_SWIZZLE_NONE
expr_stmt|;
name|swizzle_y
operator|=
name|I915_BIT_6_SWIZZLE_NONE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* On Ironlake whatever DRAM config, GPU always do 		 * same swizzling setup. 		 */
name|swizzle_x
operator|=
name|I915_BIT_6_SWIZZLE_9_10
expr_stmt|;
name|swizzle_y
operator|=
name|I915_BIT_6_SWIZZLE_9
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* As far as we know, the 865 doesn't have these bit 6 		 * swizzling issues. 		 */
name|swizzle_x
operator|=
name|I915_BIT_6_SWIZZLE_NONE
expr_stmt|;
name|swizzle_y
operator|=
name|I915_BIT_6_SWIZZLE_NONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_MOBILE
argument_list|(
name|dev
argument_list|)
operator|||
operator|(
name|IS_GEN3
argument_list|(
name|dev
argument_list|)
operator|&&
operator|!
name|IS_G33
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
name|uint32_t
name|dcc
decl_stmt|;
comment|/* On 9xx chipsets, channel interleave by the CPU is 		 * determined by DCC.  For single-channel, neither the CPU 		 * nor the GPU do swizzling.  For dual channel interleaved, 		 * the GPU's interleave is bit 9 and 10 for X tiled, and bit 		 * 9 for Y tiled.  The CPU's interleave is independent, and 		 * can be based on either bit 11 (haven't seen this yet) or 		 * bit 17 (common). 		 */
name|dcc
operator|=
name|I915_READ
argument_list|(
name|DCC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dcc
operator|&
name|DCC_ADDRESSING_MODE_MASK
condition|)
block|{
case|case
name|DCC_ADDRESSING_MODE_SINGLE_CHANNEL
case|:
case|case
name|DCC_ADDRESSING_MODE_DUAL_CHANNEL_ASYMMETRIC
case|:
name|swizzle_x
operator|=
name|I915_BIT_6_SWIZZLE_NONE
expr_stmt|;
name|swizzle_y
operator|=
name|I915_BIT_6_SWIZZLE_NONE
expr_stmt|;
break|break;
case|case
name|DCC_ADDRESSING_MODE_DUAL_CHANNEL_INTERLEAVED
case|:
if|if
condition|(
name|dcc
operator|&
name|DCC_CHANNEL_XOR_DISABLE
condition|)
block|{
comment|/* This is the base swizzling by the GPU for 				 * tiled buffers. 				 */
name|swizzle_x
operator|=
name|I915_BIT_6_SWIZZLE_9_10
expr_stmt|;
name|swizzle_y
operator|=
name|I915_BIT_6_SWIZZLE_9
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dcc
operator|&
name|DCC_CHANNEL_XOR_BIT_17
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Bit 11 swizzling by the CPU in addition. */
name|swizzle_x
operator|=
name|I915_BIT_6_SWIZZLE_9_10_11
expr_stmt|;
name|swizzle_y
operator|=
name|I915_BIT_6_SWIZZLE_9_11
expr_stmt|;
block|}
else|else
block|{
comment|/* Bit 17 swizzling by the CPU in addition. */
name|swizzle_x
operator|=
name|I915_BIT_6_SWIZZLE_9_10_17
expr_stmt|;
name|swizzle_y
operator|=
name|I915_BIT_6_SWIZZLE_9_17
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|dcc
operator|==
literal|0xffffffff
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Couldn't read from MCHBAR.  "
literal|"Disabling tiling.\n"
argument_list|)
expr_stmt|;
name|swizzle_x
operator|=
name|I915_BIT_6_SWIZZLE_UNKNOWN
expr_stmt|;
name|swizzle_y
operator|=
name|I915_BIT_6_SWIZZLE_UNKNOWN
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The 965, G33, and newer, have a very flexible memory 		 * configuration.  It will enable dual-channel mode 		 * (interleaving) on as much memory as it can, and the GPU 		 * will additionally sometimes enable different bit 6 		 * swizzling for tiled objects from the CPU. 		 * 		 * Here's what I found on the G965: 		 *    slot fill         memory size  swizzling 		 * 0A   0B   1A   1B    1-ch   2-ch 		 * 512  0    0    0     512    0     O 		 * 512  0    512  0     16     1008  X 		 * 512  0    0    512   16     1008  X 		 * 0    512  0    512   16     1008  X 		 * 1024 1024 1024 0     2048   1024  O 		 * 		 * We could probably detect this based on either the DRB 		 * matching, which was the case for the swizzling required in 		 * the table above, or from the 1-ch value being less than 		 * the minimum size of a rank. 		 */
if|if
condition|(
name|I915_READ16
argument_list|(
name|C0DRB3
argument_list|)
operator|!=
name|I915_READ16
argument_list|(
name|C1DRB3
argument_list|)
condition|)
block|{
name|swizzle_x
operator|=
name|I915_BIT_6_SWIZZLE_NONE
expr_stmt|;
name|swizzle_y
operator|=
name|I915_BIT_6_SWIZZLE_NONE
expr_stmt|;
block|}
else|else
block|{
name|swizzle_x
operator|=
name|I915_BIT_6_SWIZZLE_9_10
expr_stmt|;
name|swizzle_y
operator|=
name|I915_BIT_6_SWIZZLE_9
expr_stmt|;
block|}
block|}
name|dev_priv
operator|->
name|mm
operator|.
name|bit_6_swizzle_x
operator|=
name|swizzle_x
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|bit_6_swizzle_y
operator|=
name|swizzle_y
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check pitch constriants for all chips& tiling formats */
end_comment

begin_function
specifier|static
name|bool
name|i915_tiling_ok
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|stride
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|tiling_mode
parameter_list|)
block|{
name|int
name|tile_width
decl_stmt|;
comment|/* Linear is always fine */
if|if
condition|(
name|tiling_mode
operator|==
name|I915_TILING_NONE
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
operator|||
operator|(
name|tiling_mode
operator|==
name|I915_TILING_Y
operator|&&
name|HAS_128_BYTE_Y_TILING
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
name|tile_width
operator|=
literal|128
expr_stmt|;
else|else
name|tile_width
operator|=
literal|512
expr_stmt|;
comment|/* check maximum stride& object size */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
comment|/* i965 stores the end address of the gtt mapping in the fence 		 * reg, so dont bother to check the size */
if|if
condition|(
name|stride
operator|/
literal|128
operator|>
name|I965_FENCE_MAX_PITCH_VAL
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|stride
operator|>
literal|8192
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|IS_GEN3
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|size
operator|>
name|I830_FENCE_MAX_SIZE_VAL
operator|<<
literal|20
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|>
name|I830_FENCE_MAX_SIZE_VAL
operator|<<
literal|19
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
block|}
comment|/* 965+ just needs multiples of tile width */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|stride
operator|&
operator|(
name|tile_width
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* Pre-965 needs power of two tile widths */
if|if
condition|(
name|stride
operator|<
name|tile_width
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|stride
operator|&
operator|(
name|stride
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Is the current GTT allocation valid for the change in tiling? */
end_comment

begin_function
specifier|static
name|bool
name|i915_gem_object_fence_ok
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|int
name|tiling_mode
parameter_list|)
block|{
name|u32
name|size
decl_stmt|;
if|if
condition|(
name|tiling_mode
operator|==
name|I915_TILING_NONE
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|obj
operator|->
name|base
operator|.
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|obj
operator|->
name|base
operator|.
name|dev
argument_list|)
operator|->
name|gen
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|gtt_offset
operator|&
operator|~
name|I915_FENCE_START_MASK
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|obj
operator|->
name|gtt_offset
operator|&
operator|~
name|I830_FENCE_START_MASK
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* 	 * Previous chips need to be aligned to the size of the smallest 	 * fence register that can contain the object. 	 */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|obj
operator|->
name|base
operator|.
name|dev
argument_list|)
operator|->
name|gen
operator|==
literal|3
condition|)
name|size
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
else|else
name|size
operator|=
literal|512
operator|*
literal|1024
expr_stmt|;
while|while
condition|(
name|size
operator|<
name|obj
operator|->
name|base
operator|.
name|size
condition|)
name|size
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|gtt_space
operator|->
name|size
operator|!=
name|size
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|obj
operator|->
name|gtt_offset
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Sets the tiling mode of an object, returning the required swizzling of  * bit 6 of addresses in the object.  */
end_comment

begin_function
name|int
name|i915_gem_set_tiling
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_set_tiling
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOENT
return|;
if|if
condition|(
operator|!
name|i915_tiling_ok
argument_list|(
name|dev
argument_list|,
name|args
operator|->
name|stride
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|,
name|args
operator|->
name|tiling_mode
argument_list|)
condition|)
block|{
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|pin_count
condition|)
block|{
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
if|if
condition|(
name|args
operator|->
name|tiling_mode
operator|==
name|I915_TILING_NONE
condition|)
block|{
name|args
operator|->
name|swizzle_mode
operator|=
name|I915_BIT_6_SWIZZLE_NONE
expr_stmt|;
name|args
operator|->
name|stride
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|args
operator|->
name|tiling_mode
operator|==
name|I915_TILING_X
condition|)
name|args
operator|->
name|swizzle_mode
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|bit_6_swizzle_x
expr_stmt|;
else|else
name|args
operator|->
name|swizzle_mode
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|bit_6_swizzle_y
expr_stmt|;
comment|/* Hide bit 17 swizzling from the user.  This prevents old Mesa 		 * from aborting the application on sw fallbacks to bit 17, 		 * and we use the pread/pwrite bit17 paths to swizzle for it. 		 * If there was a user that was relying on the swizzle 		 * information for drm_intel_bo_map()ed reads/writes this would 		 * break it, but we don't have any of those. 		 */
if|if
condition|(
name|args
operator|->
name|swizzle_mode
operator|==
name|I915_BIT_6_SWIZZLE_9_17
condition|)
name|args
operator|->
name|swizzle_mode
operator|=
name|I915_BIT_6_SWIZZLE_9
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|swizzle_mode
operator|==
name|I915_BIT_6_SWIZZLE_9_10_17
condition|)
name|args
operator|->
name|swizzle_mode
operator|=
name|I915_BIT_6_SWIZZLE_9_10
expr_stmt|;
comment|/* If we can't handle the swizzling, make it untiled. */
if|if
condition|(
name|args
operator|->
name|swizzle_mode
operator|==
name|I915_BIT_6_SWIZZLE_UNKNOWN
condition|)
block|{
name|args
operator|->
name|tiling_mode
operator|=
name|I915_TILING_NONE
expr_stmt|;
name|args
operator|->
name|swizzle_mode
operator|=
name|I915_BIT_6_SWIZZLE_NONE
expr_stmt|;
name|args
operator|->
name|stride
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|args
operator|->
name|tiling_mode
operator|!=
name|obj
operator|->
name|tiling_mode
operator|||
name|args
operator|->
name|stride
operator|!=
name|obj
operator|->
name|stride
condition|)
block|{
comment|/* We need to rebind the object if its current allocation 		 * no longer meets the alignment restrictions for its new 		 * tiling mode. Otherwise we can just leave it alone, but 		 * need to ensure that any fence register is updated before 		 * the next fenced (either through the GTT or by the BLT unit 		 * on older GPUs) access. 		 * 		 * After updating the tiling parameters, we then flag whether 		 * we need to update an associated fence register. Note this 		 * has to also include the unfenced register the GPU uses 		 * whilst executing a fenced command for an untiled object. 		 */
name|obj
operator|->
name|map_and_fenceable
operator|=
name|obj
operator|->
name|gtt_space
operator|==
name|NULL
operator|||
operator|(
name|obj
operator|->
name|gtt_offset
operator|+
name|obj
operator|->
name|base
operator|.
name|size
operator|<=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mappable_end
operator|&&
name|i915_gem_object_fence_ok
argument_list|(
name|obj
argument_list|,
name|args
operator|->
name|tiling_mode
argument_list|)
operator|)
expr_stmt|;
comment|/* Rebind if we need a change of alignment */
if|if
condition|(
operator|!
name|obj
operator|->
name|map_and_fenceable
condition|)
block|{
name|uint32_t
name|unfenced_alignment
init|=
name|i915_gem_get_unfenced_gtt_alignment
argument_list|(
name|dev
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|,
name|args
operator|->
name|tiling_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|gtt_offset
operator|&
operator|(
name|unfenced_alignment
operator|-
literal|1
operator|)
condition|)
name|ret
operator|=
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|obj
operator|->
name|fence_dirty
operator|=
name|obj
operator|->
name|fenced_gpu_access
operator|||
name|obj
operator|->
name|fence_reg
operator|!=
name|I915_FENCE_REG_NONE
expr_stmt|;
name|obj
operator|->
name|tiling_mode
operator|=
name|args
operator|->
name|tiling_mode
expr_stmt|;
name|obj
operator|->
name|stride
operator|=
name|args
operator|->
name|stride
expr_stmt|;
comment|/* Force the fence to be reacquired for GTT access */
name|i915_gem_release_mmap
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* we have to maintain this existing ABI... */
name|args
operator|->
name|stride
operator|=
name|obj
operator|->
name|stride
expr_stmt|;
name|args
operator|->
name|tiling_mode
operator|=
name|obj
operator|->
name|tiling_mode
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Returns the current tiling mode and required bit 6 swizzling for the object.  */
end_comment

begin_function
name|int
name|i915_gem_get_tiling
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_get_tiling
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOENT
return|;
name|args
operator|->
name|tiling_mode
operator|=
name|obj
operator|->
name|tiling_mode
expr_stmt|;
switch|switch
condition|(
name|obj
operator|->
name|tiling_mode
condition|)
block|{
case|case
name|I915_TILING_X
case|:
name|args
operator|->
name|swizzle_mode
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|bit_6_swizzle_x
expr_stmt|;
break|break;
case|case
name|I915_TILING_Y
case|:
name|args
operator|->
name|swizzle_mode
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|bit_6_swizzle_y
expr_stmt|;
break|break;
case|case
name|I915_TILING_NONE
case|:
name|args
operator|->
name|swizzle_mode
operator|=
name|I915_BIT_6_SWIZZLE_NONE
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"unknown tiling mode\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Hide bit 17 from the user -- see comment in i915_gem_set_tiling */
if|if
condition|(
name|args
operator|->
name|swizzle_mode
operator|==
name|I915_BIT_6_SWIZZLE_9_17
condition|)
name|args
operator|->
name|swizzle_mode
operator|=
name|I915_BIT_6_SWIZZLE_9
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|swizzle_mode
operator|==
name|I915_BIT_6_SWIZZLE_9_10_17
condition|)
name|args
operator|->
name|swizzle_mode
operator|=
name|I915_BIT_6_SWIZZLE_9_10
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Swap every 64 bytes of this page around, to account for it having a new  * bit 17 of its physical address and therefore being interpreted differently  * by the GPU.  */
end_comment

begin_function
specifier|static
name|void
name|i915_gem_swizzle_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|char
name|temp
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|vaddr
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* XXXKIB sleep */
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|m
argument_list|,
name|SFB_DEFAULT
argument_list|)
expr_stmt|;
name|vaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PAGE_SIZE
condition|;
name|i
operator|+=
literal|128
control|)
block|{
name|memcpy
argument_list|(
name|temp
argument_list|,
operator|&
name|vaddr
index|[
name|i
index|]
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|vaddr
index|[
name|i
index|]
argument_list|,
operator|&
name|vaddr
index|[
name|i
operator|+
literal|64
index|]
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|vaddr
index|[
name|i
operator|+
literal|64
index|]
argument_list|,
name|temp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_object_do_bit_17_swizzle_page
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|char
name|new_bit_17
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|bit_17
operator|==
name|NULL
condition|)
return|return;
name|new_bit_17
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|>>
literal|17
expr_stmt|;
if|if
condition|(
operator|(
name|new_bit_17
operator|&
literal|0x1
operator|)
operator|!=
operator|(
name|test_bit
argument_list|(
name|m
operator|->
name|pindex
argument_list|,
name|obj
operator|->
name|bit_17
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|i915_gem_swizzle_page
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|i915_gem_object_do_bit_17_swizzle
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|int
name|page_count
init|=
name|obj
operator|->
name|base
operator|.
name|size
operator|>>
name|PAGE_SHIFT
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|bit_17
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_count
condition|;
name|i
operator|++
control|)
block|{
name|char
name|new_bit_17
init|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|obj
operator|->
name|pages
index|[
name|i
index|]
argument_list|)
operator|>>
literal|17
decl_stmt|;
if|if
condition|(
operator|(
name|new_bit_17
operator|&
literal|0x1
operator|)
operator|!=
operator|(
name|test_bit
argument_list|(
name|i
argument_list|,
name|obj
operator|->
name|bit_17
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|i915_gem_swizzle_page
argument_list|(
name|obj
operator|->
name|pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|obj
operator|->
name|pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|i915_gem_object_save_bit_17_swizzle
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|int
name|page_count
init|=
name|obj
operator|->
name|base
operator|.
name|size
operator|>>
name|PAGE_SHIFT
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|bit_17
operator|==
name|NULL
condition|)
block|{
name|obj
operator|->
name|bit_17
operator|=
name|malloc
argument_list|(
name|BITS_TO_LONGS
argument_list|(
name|page_count
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
comment|/* XXXKIB: review locking, atomics might be not needed there */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|obj
operator|->
name|pages
index|[
name|i
index|]
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|17
operator|)
condition|)
name|set_bit
argument_list|(
name|i
argument_list|,
name|obj
operator|->
name|bit_17
argument_list|)
expr_stmt|;
else|else
name|clear_bit
argument_list|(
name|i
argument_list|,
name|obj
operator|->
name|bit_17
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

