begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* i915_dma.c -- DMA support for the I915 -*- linux-c -*-  */
end_comment

begin_comment
comment|/*  * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the  * "Software"), to deal in the Software without restriction, including  * without limitation the rights to use, copy, modify, merge, publish,  * distribute, sub license, and/or sell copies of the Software, and to  * permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|pr_fmt
parameter_list|(
name|fmt
parameter_list|)
value|KBUILD_MODNAME ": " fmt
end_define

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc_helper.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_fb_helper.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_define
define|#
directive|define
name|LP_RING
parameter_list|(
name|d
parameter_list|)
value|(&((struct drm_i915_private *)(d))->ring[RCS])
end_define

begin_define
define|#
directive|define
name|BEGIN_LP_RING
parameter_list|(
name|n
parameter_list|)
define|\
value|intel_ring_begin(LP_RING(dev_priv), (n))
end_define

begin_define
define|#
directive|define
name|OUT_RING
parameter_list|(
name|x
parameter_list|)
define|\
value|intel_ring_emit(LP_RING(dev_priv), x)
end_define

begin_define
define|#
directive|define
name|ADVANCE_LP_RING
parameter_list|()
define|\
value|intel_ring_advance(LP_RING(dev_priv))
end_define

begin_comment
comment|/**  * Lock test for when it's just for synchronization of ring access.  *  * In that case, we don't need to do it when GEM is initialized as nobody else  * has access to the ring.  */
end_comment

begin_define
define|#
directive|define
name|RING_LOCK_TEST_WITH_RETURN
parameter_list|(
name|dev
parameter_list|,
name|file
parameter_list|)
value|do {			\ 	if (LP_RING(dev->dev_private)->obj == NULL)			\ 		LOCK_TEST_WITH_RETURN(dev, file);			\ } while (0)
end_define

begin_function
specifier|static
specifier|inline
name|u32
name|intel_read_legacy_status_page
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
if|if
condition|(
name|I915_NEED_GFX_HWS
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
return|return
name|ioread32
argument_list|(
name|dev_priv
operator|->
name|dri1
operator|.
name|gfx_hws_cpu_addr
operator|+
name|reg
argument_list|)
return|;
else|else
return|return
name|intel_read_status_page
argument_list|(
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
argument_list|,
name|reg
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|READ_HWSP
parameter_list|(
name|dev_priv
parameter_list|,
name|reg
parameter_list|)
value|intel_read_legacy_status_page(dev_priv, reg)
end_define

begin_define
define|#
directive|define
name|READ_BREADCRUMB
parameter_list|(
name|dev_priv
parameter_list|)
value|READ_HWSP(dev_priv, I915_BREADCRUMB_INDEX)
end_define

begin_define
define|#
directive|define
name|I915_BREADCRUMB_INDEX
value|0x21
end_define

begin_function
name|void
name|i915_update_dri1_breadcrumb
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_master_private
modifier|*
name|master_priv
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|primary
operator|->
name|master
condition|)
block|{
name|master_priv
operator|=
name|dev
operator|->
name|primary
operator|->
name|master
operator|->
name|driver_priv
expr_stmt|;
if|if
condition|(
name|master_priv
operator|->
name|sarea_priv
condition|)
name|master_priv
operator|->
name|sarea_priv
operator|->
name|last_dispatch
operator|=
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i915_write_hws_pga
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|addr
decl_stmt|;
name|addr
operator|=
name|dev_priv
operator|->
name|status_page_dmah
operator|->
name|busaddr
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
name|addr
operator||=
operator|(
name|dev_priv
operator|->
name|status_page_dmah
operator|->
name|busaddr
operator|>>
literal|28
operator|)
operator|&
literal|0xf0
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HWS_PGA
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Frees the hardware status page, whether it's a physical address or a virtual  * address set up by the X Server.  */
end_comment

begin_function
specifier|static
name|void
name|i915_free_hws
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|status_page_dmah
condition|)
block|{
name|drm_pci_free
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|status_page_dmah
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|status_page_dmah
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ring
operator|->
name|status_page
operator|.
name|gfx_addr
condition|)
block|{
name|ring
operator|->
name|status_page
operator|.
name|gfx_addr
operator|=
literal|0
expr_stmt|;
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|dev_priv
operator|->
name|dri1
operator|.
name|gfx_hws_cpu_addr
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
comment|/* Need to rewrite hardware status page */
name|I915_WRITE
argument_list|(
name|HWS_PGA
argument_list|,
literal|0x1ffff000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_kernel_lost_context
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_master_private
modifier|*
name|master_priv
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
decl_stmt|;
comment|/* 	 * We should never lose context on the ring with modesetting 	 * as we don't expose it to userspace 	 */
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return;
name|ring
operator|->
name|head
operator|=
name|I915_READ_HEAD
argument_list|(
name|ring
argument_list|)
operator|&
name|HEAD_ADDR
expr_stmt|;
name|ring
operator|->
name|tail
operator|=
name|I915_READ_TAIL
argument_list|(
name|ring
argument_list|)
operator|&
name|TAIL_ADDR
expr_stmt|;
name|ring
operator|->
name|space
operator|=
name|ring
operator|->
name|head
operator|-
operator|(
name|ring
operator|->
name|tail
operator|+
name|I915_RING_FREE_SPACE
operator|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|space
operator|<
literal|0
condition|)
name|ring
operator|->
name|space
operator|+=
name|ring
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|primary
operator|->
name|master
condition|)
return|return;
name|master_priv
operator|=
name|dev
operator|->
name|primary
operator|->
name|master
operator|->
name|driver_priv
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|head
operator|==
name|ring
operator|->
name|tail
operator|&&
name|master_priv
operator|->
name|sarea_priv
condition|)
name|master_priv
operator|->
name|sarea_priv
operator|->
name|perf_boxes
operator||=
name|I915_BOX_RING_EMPTY
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_dma_cleanup
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Make sure interrupts are disabled here because the uninstall ioctl 	 * may not have been called from userspace and after dev_private 	 * is freed, it's too late. 	 */
if|if
condition|(
name|dev
operator|->
name|irq_enabled
condition|)
name|drm_irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I915_NUM_RINGS
condition|;
name|i
operator|++
control|)
name|intel_cleanup_ring_buffer
argument_list|(
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Clear the HWS virtual address at teardown */
if|if
condition|(
name|I915_NEED_GFX_HWS
argument_list|(
name|dev
argument_list|)
condition|)
name|i915_free_hws
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_initialize
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_i915_init_t
modifier|*
name|init
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_master_private
modifier|*
name|master_priv
init|=
name|dev
operator|->
name|primary
operator|->
name|master
operator|->
name|driver_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|master_priv
operator|->
name|sarea
operator|=
name|drm_getsarea
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|master_priv
operator|->
name|sarea
condition|)
block|{
name|master_priv
operator|->
name|sarea_priv
operator|=
operator|(
name|drm_i915_sarea_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|master_priv
operator|->
name|sarea
operator|->
name|handle
operator|+
name|init
operator|->
name|sarea_priv_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"sarea not found assuming DRI2 userspace\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|->
name|ring_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
operator|->
name|obj
operator|!=
name|NULL
condition|)
block|{
name|i915_dma_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"Client tried to initialize ringbuffer in "
literal|"GEM mode\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|ret
operator|=
name|intel_render_ring_init_dri
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|ring_start
argument_list|,
name|init
operator|->
name|ring_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|i915_dma_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|dev_priv
operator|->
name|dri1
operator|.
name|cpp
operator|=
name|init
operator|->
name|cpp
expr_stmt|;
name|dev_priv
operator|->
name|dri1
operator|.
name|back_offset
operator|=
name|init
operator|->
name|back_offset
expr_stmt|;
name|dev_priv
operator|->
name|dri1
operator|.
name|front_offset
operator|=
name|init
operator|->
name|front_offset
expr_stmt|;
name|dev_priv
operator|->
name|dri1
operator|.
name|current_page
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|master_priv
operator|->
name|sarea_priv
condition|)
name|master_priv
operator|->
name|sarea_priv
operator|->
name|pf_current_page
operator|=
literal|0
expr_stmt|;
comment|/* Allow hardware batchbuffers unless told otherwise. 	 */
name|dev_priv
operator|->
name|dri1
operator|.
name|allow_batchbuffer
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_dma_resume
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
decl_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|virtual_start
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"can not ioremap virtual address for"
literal|" ring buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
comment|/* Program Hardware Status Page */
if|if
condition|(
operator|!
name|ring
operator|->
name|status_page
operator|.
name|page_addr
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Can not find hardware status page\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"hw status page @ %p\n"
argument_list|,
name|ring
operator|->
name|status_page
operator|.
name|page_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|status_page
operator|.
name|gfx_addr
operator|!=
literal|0
condition|)
name|intel_ring_setup_status_page
argument_list|(
name|ring
argument_list|)
expr_stmt|;
else|else
name|i915_write_hws_pga
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"Enabled hardware status page\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_dma_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_init_t
modifier|*
name|init
init|=
name|data
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
switch|switch
condition|(
name|init
operator|->
name|func
condition|)
block|{
case|case
name|I915_INIT_DMA
case|:
name|retcode
operator|=
name|i915_initialize
argument_list|(
name|dev
argument_list|,
name|init
argument_list|)
expr_stmt|;
break|break;
case|case
name|I915_CLEANUP_DMA
case|:
name|retcode
operator|=
name|i915_dma_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|I915_RESUME_DMA
case|:
name|retcode
operator|=
name|i915_dma_resume
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
default|default:
name|retcode
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|retcode
return|;
block|}
end_function

begin_comment
comment|/* Implement basically the same security restrictions as hardware does  * for MI_BATCH_NON_SECURE.  These can be made stricter at any time.  *  * Most of the calculations below involve calculating the size of a  * particular instruction.  It's important to get the size right as  * that tells us where the next instruction to check is.  Any illegal  * instruction detected will be given a size of zero, which is a  * signal to abort the rest of the buffer.  */
end_comment

begin_function
specifier|static
name|int
name|validate_cmd
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
operator|(
operator|(
name|cmd
operator|>>
literal|29
operator|)
operator|&
literal|0x7
operator|)
condition|)
block|{
case|case
literal|0x0
case|:
switch|switch
condition|(
operator|(
name|cmd
operator|>>
literal|23
operator|)
operator|&
literal|0x3f
condition|)
block|{
case|case
literal|0x0
case|:
return|return
literal|1
return|;
comment|/* MI_NOOP */
case|case
literal|0x4
case|:
return|return
literal|1
return|;
comment|/* MI_FLUSH */
default|default:
return|return
literal|0
return|;
comment|/* disallow everything else */
block|}
break|break;
case|case
literal|0x1
case|:
return|return
literal|0
return|;
comment|/* reserved */
case|case
literal|0x2
case|:
return|return
operator|(
name|cmd
operator|&
literal|0xff
operator|)
operator|+
literal|2
return|;
comment|/* 2d commands */
case|case
literal|0x3
case|:
if|if
condition|(
operator|(
operator|(
name|cmd
operator|>>
literal|24
operator|)
operator|&
literal|0x1f
operator|)
operator|<=
literal|0x18
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
operator|(
name|cmd
operator|>>
literal|24
operator|)
operator|&
literal|0x1f
condition|)
block|{
case|case
literal|0x1c
case|:
return|return
literal|1
return|;
case|case
literal|0x1d
case|:
switch|switch
condition|(
operator|(
name|cmd
operator|>>
literal|16
operator|)
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0x3
case|:
return|return
operator|(
name|cmd
operator|&
literal|0x1f
operator|)
operator|+
literal|2
return|;
case|case
literal|0x4
case|:
return|return
operator|(
name|cmd
operator|&
literal|0xf
operator|)
operator|+
literal|2
return|;
default|default:
return|return
operator|(
name|cmd
operator|&
literal|0xffff
operator|)
operator|+
literal|2
return|;
block|}
case|case
literal|0x1e
case|:
if|if
condition|(
name|cmd
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
return|return
operator|(
name|cmd
operator|&
literal|0xffff
operator|)
operator|+
literal|1
return|;
else|else
return|return
literal|1
return|;
case|case
literal|0x1f
case|:
if|if
condition|(
operator|(
name|cmd
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* inline vertices */
return|return
operator|(
name|cmd
operator|&
literal|0x1ffff
operator|)
operator|+
literal|2
return|;
elseif|else
if|if
condition|(
name|cmd
operator|&
operator|(
literal|1
operator|<<
literal|17
operator|)
condition|)
comment|/* indirect random */
if|if
condition|(
operator|(
name|cmd
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* unknown length, too hard */
else|else
return|return
operator|(
operator|(
operator|(
name|cmd
operator|&
literal|0xffff
operator|)
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
operator|+
literal|1
return|;
else|else
return|return
literal|2
return|;
comment|/* indirect sequential */
default|default:
return|return
literal|0
return|;
block|}
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_emit_cmds
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
modifier|*
name|buffer
parameter_list|,
name|int
name|dwords
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|dwords
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|>=
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
operator|->
name|size
operator|-
literal|8
condition|)
return|return
operator|-
name|EINVAL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dwords
condition|;
control|)
block|{
name|int
name|sz
init|=
name|validate_cmd
argument_list|(
name|buffer
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|sz
operator|==
literal|0
operator|||
name|i
operator|+
name|sz
operator|>
name|dwords
condition|)
return|return
operator|-
name|EINVAL
return|;
name|i
operator|+=
name|sz
expr_stmt|;
block|}
name|ret
operator|=
name|BEGIN_LP_RING
argument_list|(
operator|(
name|dwords
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dwords
condition|;
name|i
operator|++
control|)
name|OUT_RING
argument_list|(
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwords
operator|&
literal|1
condition|)
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_emit_box
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_clip_rect
modifier|*
name|box
parameter_list|,
name|int
name|DR1
parameter_list|,
name|int
name|DR4
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|box
operator|->
name|y2
operator|<=
name|box
operator|->
name|y1
operator|||
name|box
operator|->
name|x2
operator|<=
name|box
operator|->
name|x1
operator|||
name|box
operator|->
name|y2
operator|<=
literal|0
operator|||
name|box
operator|->
name|x2
operator|<=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Bad box %d,%d..%d,%d\n"
argument_list|,
name|box
operator|->
name|x1
argument_list|,
name|box
operator|->
name|y1
argument_list|,
name|box
operator|->
name|x2
argument_list|,
name|box
operator|->
name|y2
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|ret
operator|=
name|BEGIN_LP_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|OUT_RING
argument_list|(
name|GFX_OP_DRAWRECT_INFO_I965
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|box
operator|->
name|x1
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|box
operator|->
name|y1
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
operator|(
name|box
operator|->
name|x2
operator|-
literal|1
operator|)
operator|&
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|box
operator|->
name|y2
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|DR4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|BEGIN_LP_RING
argument_list|(
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|OUT_RING
argument_list|(
name|GFX_OP_DRAWRECT_INFO
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|DR1
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|box
operator|->
name|x1
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|box
operator|->
name|y1
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
operator|(
name|box
operator|->
name|x2
operator|-
literal|1
operator|)
operator|&
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|box
operator|->
name|y2
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|DR4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* XXX: Emitting the counter should really be moved to part of the IRQ  * emit. For now, do it in both places:  */
end_comment

begin_function
specifier|static
name|void
name|i915_emit_breadcrumb
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_master_private
modifier|*
name|master_priv
init|=
name|dev
operator|->
name|primary
operator|->
name|master
operator|->
name|driver_priv
decl_stmt|;
name|dev_priv
operator|->
name|dri1
operator|.
name|counter
operator|++
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|dri1
operator|.
name|counter
operator|>
literal|0x7FFFFFFFUL
condition|)
name|dev_priv
operator|->
name|dri1
operator|.
name|counter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|master_priv
operator|->
name|sarea_priv
condition|)
name|master_priv
operator|->
name|sarea_priv
operator|->
name|last_enqueue
operator|=
name|dev_priv
operator|->
name|dri1
operator|.
name|counter
expr_stmt|;
if|if
condition|(
name|BEGIN_LP_RING
argument_list|(
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|OUT_RING
argument_list|(
name|MI_STORE_DWORD_INDEX
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|I915_BREADCRUMB_INDEX
operator|<<
name|MI_STORE_DWORD_INDEX_SHIFT
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|dri1
operator|.
name|counter
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|i915_dispatch_cmdbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_i915_cmdbuffer_t
modifier|*
name|cmd
parameter_list|,
name|struct
name|drm_clip_rect
modifier|*
name|cliprects
parameter_list|,
name|void
modifier|*
name|cmdbuf
parameter_list|)
block|{
name|int
name|nbox
init|=
name|cmd
operator|->
name|num_cliprects
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|count
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|sz
operator|&
literal|0x3
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"alignment"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|i915_kernel_lost_context
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|count
operator|=
name|nbox
condition|?
name|nbox
else|:
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|nbox
condition|)
block|{
name|ret
operator|=
name|i915_emit_box
argument_list|(
name|dev
argument_list|,
operator|&
name|cliprects
index|[
name|i
index|]
argument_list|,
name|cmd
operator|->
name|DR1
argument_list|,
name|cmd
operator|->
name|DR4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|i915_emit_cmds
argument_list|(
name|dev
argument_list|,
name|cmdbuf
argument_list|,
name|cmd
operator|->
name|sz
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|i915_emit_breadcrumb
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_dispatch_batchbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_i915_batchbuffer_t
modifier|*
name|batch
parameter_list|,
name|struct
name|drm_clip_rect
modifier|*
name|cliprects
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|nbox
init|=
name|batch
operator|->
name|num_cliprects
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|batch
operator|->
name|start
operator||
name|batch
operator|->
name|used
operator|)
operator|&
literal|0x7
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"alignment"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|i915_kernel_lost_context
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|count
operator|=
name|nbox
condition|?
name|nbox
else|:
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|nbox
condition|)
block|{
name|ret
operator|=
name|i915_emit_box
argument_list|(
name|dev
argument_list|,
operator|&
name|cliprects
index|[
name|i
index|]
argument_list|,
name|batch
operator|->
name|DR1
argument_list|,
name|batch
operator|->
name|DR4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|!
name|IS_I830
argument_list|(
name|dev
argument_list|)
operator|&&
operator|!
name|IS_845G
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ret
operator|=
name|BEGIN_LP_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
block|{
name|OUT_RING
argument_list|(
name|MI_BATCH_BUFFER_START
operator||
operator|(
literal|2
operator|<<
literal|6
operator|)
operator||
name|MI_BATCH_NON_SECURE_I965
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|batch
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OUT_RING
argument_list|(
name|MI_BATCH_BUFFER_START
operator||
operator|(
literal|2
operator|<<
literal|6
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|batch
operator|->
name|start
operator||
name|MI_BATCH_NON_SECURE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
name|BEGIN_LP_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|OUT_RING
argument_list|(
name|MI_BATCH_BUFFER
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|batch
operator|->
name|start
operator||
name|MI_BATCH_NON_SECURE
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|batch
operator|->
name|start
operator|+
name|batch
operator|->
name|used
operator|-
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|BEGIN_LP_RING
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|OUT_RING
argument_list|(
name|MI_FLUSH
operator||
name|MI_NO_WRITE_FLUSH
operator||
name|MI_INVALIDATE_ISP
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_NOOP
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
block|}
block|}
name|i915_emit_breadcrumb
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_dispatch_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_master_private
modifier|*
name|master_priv
init|=
name|dev
operator|->
name|primary
operator|->
name|master
operator|->
name|driver_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|master_priv
operator|->
name|sarea_priv
condition|)
return|return
operator|-
name|EINVAL
return|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"%s: page=%d pfCurrentPage=%d\n"
argument_list|,
name|__func__
argument_list|,
name|dev_priv
operator|->
name|dri1
operator|.
name|current_page
argument_list|,
name|master_priv
operator|->
name|sarea_priv
operator|->
name|pf_current_page
argument_list|)
expr_stmt|;
name|i915_kernel_lost_context
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|BEGIN_LP_RING
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|OUT_RING
argument_list|(
name|MI_FLUSH
operator||
name|MI_READ_FLUSH
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CMD_OP_DISPLAYBUFFER_INFO
operator||
name|ASYNC_FLIP
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|dri1
operator|.
name|current_page
operator|==
literal|0
condition|)
block|{
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|dri1
operator|.
name|back_offset
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|dri1
operator|.
name|current_page
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|dri1
operator|.
name|front_offset
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|dri1
operator|.
name|current_page
operator|=
literal|0
expr_stmt|;
block|}
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_WAIT_FOR_EVENT
operator||
name|MI_WAIT_FOR_PLANE_A_FLIP
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
name|master_priv
operator|->
name|sarea_priv
operator|->
name|last_enqueue
operator|=
name|dev_priv
operator|->
name|dri1
operator|.
name|counter
operator|++
expr_stmt|;
if|if
condition|(
name|BEGIN_LP_RING
argument_list|(
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|OUT_RING
argument_list|(
name|MI_STORE_DWORD_INDEX
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|I915_BREADCRUMB_INDEX
operator|<<
name|MI_STORE_DWORD_INDEX_SHIFT
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|dri1
operator|.
name|counter
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
block|}
name|master_priv
operator|->
name|sarea_priv
operator|->
name|pf_current_page
operator|=
name|dev_priv
operator|->
name|dri1
operator|.
name|current_page
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_quiescent
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|i915_kernel_lost_context
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|intel_ring_idle
argument_list|(
name|LP_RING
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_flush_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
name|RING_LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_quiescent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_batchbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_master_private
modifier|*
name|master_priv
init|=
name|dev
operator|->
name|primary
operator|->
name|master
operator|->
name|driver_priv
decl_stmt|;
name|drm_i915_sarea_t
modifier|*
name|sarea_priv
init|=
operator|(
name|drm_i915_sarea_t
operator|*
operator|)
name|master_priv
operator|->
name|sarea_priv
decl_stmt|;
name|drm_i915_batchbuffer_t
modifier|*
name|batch
init|=
name|data
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|drm_clip_rect
modifier|*
name|cliprects
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|dri1
operator|.
name|allow_batchbuffer
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Batchbuffer ioctl disabled\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"i915 batchbuffer, start %x used %d cliprects %d\n"
argument_list|,
name|batch
operator|->
name|start
argument_list|,
name|batch
operator|->
name|used
argument_list|,
name|batch
operator|->
name|num_cliprects
argument_list|)
expr_stmt|;
name|RING_LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|batch
operator|->
name|num_cliprects
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|batch
operator|->
name|num_cliprects
condition|)
block|{
name|cliprects
operator|=
name|malloc
argument_list|(
name|batch
operator|->
name|num_cliprects
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_clip_rect
argument_list|)
argument_list|,
name|DRM_MEM_DMA
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cliprects
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|ret
operator|=
name|copy_from_user
argument_list|(
name|cliprects
argument_list|,
name|batch
operator|->
name|cliprects
argument_list|,
name|batch
operator|->
name|num_cliprects
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_clip_rect
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|fail_free
goto|;
block|}
block|}
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_dispatch_batchbuffer
argument_list|(
name|dev
argument_list|,
name|batch
argument_list|,
name|cliprects
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sarea_priv
condition|)
name|sarea_priv
operator|->
name|last_dispatch
operator|=
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|fail_free
label|:
name|free
argument_list|(
name|cliprects
argument_list|,
name|DRM_MEM_DMA
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_cmdbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_master_private
modifier|*
name|master_priv
init|=
name|dev
operator|->
name|primary
operator|->
name|master
operator|->
name|driver_priv
decl_stmt|;
name|drm_i915_sarea_t
modifier|*
name|sarea_priv
init|=
operator|(
name|drm_i915_sarea_t
operator|*
operator|)
name|master_priv
operator|->
name|sarea_priv
decl_stmt|;
name|drm_i915_cmdbuffer_t
modifier|*
name|cmdbuf
init|=
name|data
decl_stmt|;
name|struct
name|drm_clip_rect
modifier|*
name|cliprects
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|batch_data
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"i915 cmdbuffer, buf %p sz %d cliprects %d\n"
argument_list|,
name|cmdbuf
operator|->
name|buf
argument_list|,
name|cmdbuf
operator|->
name|sz
argument_list|,
name|cmdbuf
operator|->
name|num_cliprects
argument_list|)
expr_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
name|RING_LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdbuf
operator|->
name|num_cliprects
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|batch_data
operator|=
name|malloc
argument_list|(
name|cmdbuf
operator|->
name|sz
argument_list|,
name|DRM_MEM_DMA
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|batch_data
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|ret
operator|=
name|copy_from_user
argument_list|(
name|batch_data
argument_list|,
name|cmdbuf
operator|->
name|buf
argument_list|,
name|cmdbuf
operator|->
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|fail_batch_free
goto|;
block|}
if|if
condition|(
name|cmdbuf
operator|->
name|num_cliprects
condition|)
block|{
name|cliprects
operator|=
name|malloc
argument_list|(
name|cmdbuf
operator|->
name|num_cliprects
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_clip_rect
argument_list|)
argument_list|,
name|DRM_MEM_DMA
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cliprects
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|fail_batch_free
goto|;
block|}
name|ret
operator|=
name|copy_from_user
argument_list|(
name|cliprects
argument_list|,
name|cmdbuf
operator|->
name|cliprects
argument_list|,
name|cmdbuf
operator|->
name|num_cliprects
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_clip_rect
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|fail_clip_free
goto|;
block|}
block|}
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_dispatch_cmdbuffer
argument_list|(
name|dev
argument_list|,
name|cmdbuf
argument_list|,
name|cliprects
argument_list|,
name|batch_data
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"i915_dispatch_cmdbuffer failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_clip_free
goto|;
block|}
if|if
condition|(
name|sarea_priv
condition|)
name|sarea_priv
operator|->
name|last_dispatch
operator|=
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|fail_clip_free
label|:
name|free
argument_list|(
name|cliprects
argument_list|,
name|DRM_MEM_DMA
argument_list|)
expr_stmt|;
name|fail_batch_free
label|:
name|free
argument_list|(
name|batch_data
argument_list|,
name|DRM_MEM_DMA
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_emit_irq
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_master_private
modifier|*
name|master_priv
init|=
name|dev
operator|->
name|primary
operator|->
name|master
operator|->
name|driver_priv
decl_stmt|;
name|i915_kernel_lost_context
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|dri1
operator|.
name|counter
operator|++
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|dri1
operator|.
name|counter
operator|>
literal|0x7FFFFFFFUL
condition|)
name|dev_priv
operator|->
name|dri1
operator|.
name|counter
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|master_priv
operator|->
name|sarea_priv
condition|)
name|master_priv
operator|->
name|sarea_priv
operator|->
name|last_enqueue
operator|=
name|dev_priv
operator|->
name|dri1
operator|.
name|counter
expr_stmt|;
if|if
condition|(
name|BEGIN_LP_RING
argument_list|(
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|OUT_RING
argument_list|(
name|MI_STORE_DWORD_INDEX
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|I915_BREADCRUMB_INDEX
operator|<<
name|MI_STORE_DWORD_INDEX_SHIFT
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|dri1
operator|.
name|counter
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_USER_INTERRUPT
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
block|}
return|return
name|dev_priv
operator|->
name|dri1
operator|.
name|counter
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_wait_irq
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|irq_nr
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_master_private
modifier|*
name|master_priv
init|=
name|dev
operator|->
name|primary
operator|->
name|master
operator|->
name|driver_priv
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
decl_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"irq_nr=%d breadcrumb=%d\n"
argument_list|,
name|irq_nr
argument_list|,
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
operator|>=
name|irq_nr
condition|)
block|{
if|if
condition|(
name|master_priv
operator|->
name|sarea_priv
condition|)
name|master_priv
operator|->
name|sarea_priv
operator|->
name|last_dispatch
operator|=
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|master_priv
operator|->
name|sarea_priv
condition|)
name|master_priv
operator|->
name|sarea_priv
operator|->
name|perf_boxes
operator||=
name|I915_BOX_WAIT
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|irq_get
argument_list|(
name|ring
argument_list|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|ret
operator|==
literal|0
operator|&&
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
operator|<
name|irq_nr
condition|)
block|{
name|ret
operator|=
operator|-
name|msleep
argument_list|(
operator|&
name|ring
operator|->
name|irq_queue
argument_list|,
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"915wtq"
argument_list|,
literal|3
operator|*
name|DRM_HZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|ERESTART
condition|)
name|ret
operator|=
operator|-
name|ERESTARTSYS
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|ring
operator|->
name|irq_put
argument_list|(
name|ring
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wait_for
argument_list|(
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
operator|>=
name|irq_nr
argument_list|,
literal|3000
argument_list|)
condition|)
name|ret
operator|=
operator|-
name|EBUSY
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|EBUSY
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"EBUSY -- rec: %d emitted: %d\n"
argument_list|,
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|dev_priv
operator|->
name|dri1
operator|.
name|counter
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Needs the lock as it touches the ring.  */
end_comment

begin_function
name|int
name|i915_irq_emit
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_irq_emit_t
modifier|*
name|emit
init|=
name|data
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
if|if
condition|(
operator|!
name|dev_priv
operator|||
operator|!
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
operator|->
name|virtual_start
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|RING_LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|result
operator|=
name|i915_emit_irq
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
name|emit
operator|->
name|irq_seq
argument_list|,
operator|&
name|result
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"copy_to_user\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Doesn't need the hardware lock.  */
end_comment

begin_function
specifier|static
name|int
name|i915_irq_wait
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_irq_wait_t
modifier|*
name|irqwait
init|=
name|data
decl_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
name|i915_wait_irq
argument_list|(
name|dev
argument_list|,
name|irqwait
operator|->
name|irq_seq
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_vblank_pipe_get
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_vblank_pipe_t
modifier|*
name|pipe
init|=
name|data
decl_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|pipe
operator|->
name|pipe
operator|=
name|DRM_I915_VBLANK_PIPE_A
operator||
name|DRM_I915_VBLANK_PIPE_B
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Schedule buffer swap at given vertical blank.  */
end_comment

begin_function
specifier|static
name|int
name|i915_vblank_swap
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
comment|/* The delayed swap mechanism was fundamentally racy, and has been 	 * removed.  The model was that the client requested a delayed flip/swap 	 * from the kernel, then waited for vblank before continuing to perform 	 * rendering.  The problem was that the kernel might wake the client 	 * up before it dispatched the vblank swap (since the lock has to be 	 * held while touching the ringbuffer), in which case the client would 	 * clear and start the next frame before the swap occurred, and 	 * flicker would occur in addition to likely missing the vblank. 	 * 	 * In the absence of this ioctl, userland falls back to a correct path 	 * of waiting for a vblank, then dispatching the swap on its own. 	 * Context switching to userland and back is plenty fast enough for 	 * meeting the requirements of vblank swapping. 	 */
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_flip_bufs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|RING_LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_dispatch_flip
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_getparam
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_getparam_t
modifier|*
name|param
init|=
name|data
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|param
operator|->
name|param
condition|)
block|{
case|case
name|I915_PARAM_IRQ_ACTIVE
case|:
name|value
operator|=
name|dev
operator|->
name|irq_enabled
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|I915_PARAM_ALLOW_BATCHBUFFER
case|:
name|value
operator|=
name|dev_priv
operator|->
name|dri1
operator|.
name|allow_batchbuffer
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|I915_PARAM_LAST_DISPATCH
case|:
name|value
operator|=
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
break|break;
case|case
name|I915_PARAM_CHIPSET_ID
case|:
name|value
operator|=
name|dev
operator|->
name|pci_device
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_GEM
case|:
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|I915_PARAM_NUM_FENCES_AVAIL
case|:
name|value
operator|=
name|dev_priv
operator|->
name|num_fence_regs
operator|-
name|dev_priv
operator|->
name|fence_reg_start
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_OVERLAY
case|:
name|value
operator|=
name|dev_priv
operator|->
name|overlay
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_PAGEFLIPPING
case|:
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_EXECBUF2
case|:
comment|/* depends on GEM */
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_BSD
case|:
name|value
operator|=
name|intel_ring_initialized
argument_list|(
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|VCS
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_BLT
case|:
name|value
operator|=
name|intel_ring_initialized
argument_list|(
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|BCS
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_RELAXED_FENCING
case|:
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_COHERENT_RINGS
case|:
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_EXEC_CONSTANTS
case|:
name|value
operator|=
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_RELAXED_DELTA
case|:
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_GEN7_SOL_RESET
case|:
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_LLC
case|:
name|value
operator|=
name|HAS_LLC
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_ALIASING_PPGTT
case|:
name|value
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_WAIT_TIMEOUT
case|:
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_SEMAPHORES
case|:
name|value
operator|=
name|i915_semaphore_is_enabled
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_PRIME_VMAP_FLUSH
case|:
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_SECURE_BATCHES
case|:
comment|/* FIXME Linux<->FreeBSD: Is there a better choice than 		 * curthread? */
name|value
operator|=
name|DRM_SUSER
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_PINNED_BATCHES
case|:
name|value
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"Unknown parameter %d\n"
argument_list|,
name|param
operator|->
name|param
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
name|param
operator|->
name|value
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"DRM_COPY_TO_USER failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_setparam
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_setparam_t
modifier|*
name|param
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|param
operator|->
name|param
condition|)
block|{
case|case
name|I915_SETPARAM_USE_MI_BATCHBUFFER_START
case|:
break|break;
case|case
name|I915_SETPARAM_TEX_LRU_LOG_GRANULARITY
case|:
break|break;
case|case
name|I915_SETPARAM_ALLOW_BATCHBUFFER
case|:
name|dev_priv
operator|->
name|dri1
operator|.
name|allow_batchbuffer
operator|=
name|param
operator|->
name|value
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|I915_SETPARAM_NUM_USED_FENCES
case|:
if|if
condition|(
name|param
operator|->
name|value
operator|>
name|dev_priv
operator|->
name|num_fence_regs
operator|||
name|param
operator|->
name|value
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* Userspace can use first N regs */
name|dev_priv
operator|->
name|fence_reg_start
operator|=
name|param
operator|->
name|value
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"unknown parameter %d\n"
argument_list|,
name|param
operator|->
name|param
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_set_status_page
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_hws_addr_t
modifier|*
name|hws
init|=
name|data
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
if|if
condition|(
operator|!
name|I915_NEED_GFX_HWS
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
literal|1
argument_list|,
literal|"tried to set status page when mode setting active\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"set status page addr 0x%08x\n"
argument_list|,
operator|(
name|u32
operator|)
name|hws
operator|->
name|addr
argument_list|)
expr_stmt|;
name|ring
operator|=
name|LP_RING
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|ring
operator|->
name|status_page
operator|.
name|gfx_addr
operator|=
name|hws
operator|->
name|addr
operator|&
operator|(
literal|0x1ffff
operator|<<
literal|12
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|dri1
operator|.
name|gfx_hws_cpu_addr
operator|=
name|pmap_mapdev_attr
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
operator|+
name|hws
operator|->
name|addr
argument_list|,
name|PAGE_SIZE
argument_list|,
name|VM_MEMATTR_WRITE_COMBINING
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|dri1
operator|.
name|gfx_hws_cpu_addr
operator|==
name|NULL
condition|)
block|{
name|i915_dma_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ring
operator|->
name|status_page
operator|.
name|gfx_addr
operator|=
literal|0
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"can not ioremap virtual address for"
literal|" G33 hw status page\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|memset_io
argument_list|(
name|dev_priv
operator|->
name|dri1
operator|.
name|gfx_hws_cpu_addr
argument_list|,
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HWS_PGA
argument_list|,
name|ring
operator|->
name|status_page
operator|.
name|gfx_addr
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"load hws HWS_PGA with gfx mem 0x%x\n"
argument_list|,
name|ring
operator|->
name|status_page
operator|.
name|gfx_addr
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"load hws at %p\n"
argument_list|,
name|ring
operator|->
name|status_page
operator|.
name|page_addr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_get_bridge_dev
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|bridge_dev
operator|=
name|pci_find_dbsf
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|bridge_dev
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"bridge device not found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MCHBAR_I915
value|0x44
end_define

begin_define
define|#
directive|define
name|MCHBAR_I965
value|0x48
end_define

begin_define
define|#
directive|define
name|MCHBAR_SIZE
value|(4*4096)
end_define

begin_define
define|#
directive|define
name|DEVEN_REG
value|0x54
end_define

begin_define
define|#
directive|define
name|DEVEN_MCHBAR_EN
value|(1<< 28)
end_define

begin_comment
comment|/* Allocate space for the MCH regs if needed, return nonzero on error */
end_comment

begin_function
specifier|static
name|int
name|intel_alloc_mchbar_resource
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|reg
init|=
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|?
name|MCHBAR_I965
else|:
name|MCHBAR_I915
decl_stmt|;
name|u32
name|temp_lo
decl_stmt|,
name|temp_hi
init|=
literal|0
decl_stmt|;
name|u64
name|mchbar_addr
decl_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
name|pci_read_config_dword
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
operator|&
name|temp_hi
argument_list|)
expr_stmt|;
name|pci_read_config_dword
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|reg
argument_list|,
operator|&
name|temp_lo
argument_list|)
expr_stmt|;
name|mchbar_addr
operator|=
operator|(
operator|(
name|u64
operator|)
name|temp_hi
operator|<<
literal|32
operator|)
operator||
name|temp_lo
expr_stmt|;
comment|/* If ACPI doesn't have it, assume we need to allocate it ourselves */
ifdef|#
directive|ifdef
name|CONFIG_PNP
if|if
condition|(
name|mchbar_addr
operator|&&
name|pnp_range_reserved
argument_list|(
name|mchbar_addr
argument_list|,
name|mchbar_addr
operator|+
name|MCHBAR_SIZE
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* Get some space for it */
name|device_t
name|vga
decl_stmt|;
name|vga
operator|=
name|device_get_parent
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mch_res_rid
operator|=
literal|0x100
expr_stmt|;
name|dev_priv
operator|->
name|mch_res
operator|=
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|vga
argument_list|)
argument_list|,
name|dev
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|dev_priv
operator|->
name|mch_res_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0UL
argument_list|,
name|MCHBAR_SIZE
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|mch_res
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"failed bus alloc\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
name|pci_write_config_dword
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
name|upper_32_bits
argument_list|(
name|rman_get_start
argument_list|(
name|dev_priv
operator|->
name|mch_res
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pci_write_config_dword
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|reg
argument_list|,
name|lower_32_bits
argument_list|(
name|rman_get_start
argument_list|(
name|dev_priv
operator|->
name|mch_res
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Setup MCHBAR if possible, return true if we should disable it again */
end_comment

begin_function
specifier|static
name|void
name|intel_setup_mchbar
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|mchbar_reg
init|=
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|?
name|MCHBAR_I965
else|:
name|MCHBAR_I915
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|bool
name|enabled
decl_stmt|;
name|dev_priv
operator|->
name|mchbar_need_disable
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|IS_I915G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I915GM
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|pci_read_config_dword
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|DEVEN_REG
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|enabled
operator|=
operator|!
operator|!
operator|(
name|temp
operator|&
name|DEVEN_MCHBAR_EN
operator|)
expr_stmt|;
block|}
else|else
block|{
name|pci_read_config_dword
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|mchbar_reg
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|enabled
operator|=
name|temp
operator|&
literal|1
expr_stmt|;
block|}
comment|/* If it's already enabled, don't have to do anything */
if|if
condition|(
name|enabled
condition|)
return|return;
if|if
condition|(
name|intel_alloc_mchbar_resource
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|dev_priv
operator|->
name|mchbar_need_disable
operator|=
name|true
expr_stmt|;
comment|/* Space is allocated or reserved, so enable it. */
if|if
condition|(
name|IS_I915G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I915GM
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|pci_write_config_dword
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|DEVEN_REG
argument_list|,
name|temp
operator||
name|DEVEN_MCHBAR_EN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pci_read_config_dword
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|mchbar_reg
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|pci_write_config_dword
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|mchbar_reg
argument_list|,
name|temp
operator||
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_teardown_mchbar
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|mchbar_reg
init|=
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|?
name|MCHBAR_I965
else|:
name|MCHBAR_I915
decl_stmt|;
name|u32
name|temp
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|mchbar_need_disable
condition|)
block|{
if|if
condition|(
name|IS_I915G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I915GM
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|pci_read_config_dword
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|DEVEN_REG
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|DEVEN_MCHBAR_EN
expr_stmt|;
name|pci_write_config_dword
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|DEVEN_REG
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pci_read_config_dword
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|mchbar_reg
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
literal|1
expr_stmt|;
name|pci_write_config_dword
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|,
name|mchbar_reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dev_priv
operator|->
name|mch_res
operator|!=
name|NULL
condition|)
block|{
name|device_t
name|vga
decl_stmt|;
name|vga
operator|=
name|device_get_parent
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
expr_stmt|;
name|BUS_DEACTIVATE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|vga
argument_list|)
argument_list|,
name|dev
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|dev_priv
operator|->
name|mch_res_rid
argument_list|,
name|dev_priv
operator|->
name|mch_res
argument_list|)
expr_stmt|;
name|BUS_RELEASE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|vga
argument_list|)
argument_list|,
name|dev
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|dev_priv
operator|->
name|mch_res_rid
argument_list|,
name|dev_priv
operator|->
name|mch_res
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mch_res
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_comment
comment|/* true = enable decode, false = disable decoder */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|i915_vga_set_decode
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|cookie
decl_stmt|;
name|intel_modeset_vga_set_state
argument_list|(
name|dev
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
return|return
name|VGA_RSRC_LEGACY_IO
operator||
name|VGA_RSRC_LEGACY_MEM
operator||
name|VGA_RSRC_NORMAL_IO
operator||
name|VGA_RSRC_NORMAL_MEM
return|;
else|else
return|return
name|VGA_RSRC_NORMAL_IO
operator||
name|VGA_RSRC_NORMAL_MEM
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_switcheroo_set_state
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|enum
name|vga_switcheroo_state
name|state
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|pm_message_t
name|pmm
init|=
block|{
operator|.
name|event
operator|=
name|PM_EVENT_SUSPEND
block|}
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|VGA_SWITCHEROO_ON
condition|)
block|{
name|pr_info
argument_list|(
literal|"switched on\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|switch_power_state
operator|=
name|DRM_SWITCH_POWER_CHANGING
expr_stmt|;
comment|/* i915 resume handler doesn't set to D0 */
name|pci_set_power_state
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|PCI_D0
argument_list|)
expr_stmt|;
name|i915_resume
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|switch_power_state
operator|=
name|DRM_SWITCH_POWER_ON
expr_stmt|;
block|}
else|else
block|{
name|pr_err
argument_list|(
literal|"switched off\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|switch_power_state
operator|=
name|DRM_SWITCH_POWER_CHANGING
expr_stmt|;
name|i915_suspend
argument_list|(
name|dev
argument_list|,
name|pmm
argument_list|)
expr_stmt|;
name|dev
operator|->
name|switch_power_state
operator|=
name|DRM_SWITCH_POWER_OFF
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|i915_switcheroo_can_switch
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|bool
name|can_switch
decl_stmt|;
name|spin_lock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
name|can_switch
operator|=
operator|(
name|dev
operator|->
name|open_count
operator|==
literal|0
operator|)
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
return|return
name|can_switch
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|vga_switcheroo_client_ops
name|i915_switcheroo_ops
init|=
block|{
operator|.
name|set_gpu_state
operator|=
name|i915_switcheroo_set_state
block|,
operator|.
name|reprobe
operator|=
name|NULL
block|,
operator|.
name|can_switch
operator|=
name|i915_switcheroo_can_switch
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|i915_load_modeset_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_parse_bios
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|DRM_INFO
argument_list|(
literal|"failed to find VBIOS tables\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
comment|/* If we have> 1 VGA cards, then we need to arbitrate access 	 * to the common VGA resources. 	 * 	 * If we are a secondary display controller (!PCI_DISPLAY_CLASS_VGA), 	 * then we do not take part in VGA arbitration and the 	 * vga_client_register() fails with -ENODEV. 	 */
name|ret
operator|=
name|vga_client_register
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|dev
argument_list|,
name|NULL
argument_list|,
name|i915_vga_set_decode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|ret
operator|!=
operator|-
name|ENODEV
condition|)
goto|goto
name|out
goto|;
name|intel_register_dsm_handler
argument_list|()
expr_stmt|;
name|ret
operator|=
name|vga_switcheroo_register_client
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
operator|&
name|i915_switcheroo_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup_vga_client
goto|;
endif|#
directive|endif
comment|/* Initialise stolen first so that we may reserve preallocated 	 * objects for the BIOS to KMS transition. 	 */
name|ret
operator|=
name|i915_gem_init_stolen
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup_vga_switcheroo
goto|;
name|intel_modeset_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup_gem_stolen
goto|;
name|intel_modeset_gem_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|dev_priv
operator|->
name|console_resume_work
argument_list|,
literal|0
argument_list|,
name|intel_console_resume
argument_list|,
name|dev
operator|->
name|dev_private
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_irq_install
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup_gem
goto|;
comment|/* Always safe in the mode setting case. */
comment|/* FIXME: do pre/post-mode set stuff in core KMS code */
name|dev
operator|->
name|vblank_disable_allowed
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|intel_fbdev_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup_irq
goto|;
name|drm_kms_helper_poll_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* We're off and running w/KMS */
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
name|cleanup_irq
label|:
name|drm_irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cleanup_gem
label|:
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_cleanup_ringbuffer
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_cleanup_aliasing_ppgtt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cleanup_gem_stolen
label|:
name|i915_gem_cleanup_stolen
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cleanup_vga_switcheroo
label|:
ifdef|#
directive|ifdef
name|__linux__
name|vga_switcheroo_unregister_client
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
expr_stmt|;
name|cleanup_vga_client
label|:
name|vga_client_register
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|out
label|:
endif|#
directive|endif
name|intel_free_parsed_bios_data
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_master_create
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_master
modifier|*
name|master
parameter_list|)
block|{
name|struct
name|drm_i915_master_private
modifier|*
name|master_priv
decl_stmt|;
name|master_priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|master_priv
argument_list|)
argument_list|,
name|DRM_MEM_DMA
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|master_priv
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|master
operator|->
name|driver_priv
operator|=
name|master_priv
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|i915_master_destroy
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_master
modifier|*
name|master
parameter_list|)
block|{
name|struct
name|drm_i915_master_private
modifier|*
name|master_priv
init|=
name|master
operator|->
name|driver_priv
decl_stmt|;
if|if
condition|(
operator|!
name|master_priv
condition|)
return|return;
name|free
argument_list|(
name|master_priv
argument_list|,
name|DRM_MEM_DMA
argument_list|)
expr_stmt|;
name|master
operator|->
name|driver_priv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_mtrr_setup
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|unsigned
name|long
name|base
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mtrr
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_X86_PAT
argument_list|)
if|if
condition|(
name|cpu_has_pat
condition|)
return|return;
endif|#
directive|endif
comment|/* Set up a WC MTRR for non-PAT systems.  This is more common than 	 * one would think, because the kernel disables PAT on first 	 * generation Core chips because WC PAT gets overridden by a UC 	 * MTRR if present.  Even if a UC MTRR isn't present. 	 */
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mtrr
operator|=
name|drm_mtrr_add
argument_list|(
name|base
argument_list|,
name|size
argument_list|,
name|DRM_MTRR_WC
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mtrr
operator|<
literal|0
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"MTRR allocation failed.  Graphics "
literal|"performance may suffer.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_function
specifier|static
name|void
name|i915_kick_out_firmware_fb
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|struct
name|apertures_struct
modifier|*
name|ap
decl_stmt|;
name|struct
name|pci_dev
modifier|*
name|pdev
init|=
name|dev_priv
operator|->
name|dev
operator|->
name|pdev
decl_stmt|;
name|bool
name|primary
decl_stmt|;
name|ap
operator|=
name|alloc_apertures
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
return|return;
name|ap
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|base
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gma_bus_addr
expr_stmt|;
name|ap
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_mappable_entries
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|primary
operator|=
name|pdev
operator|->
name|resource
index|[
name|PCI_ROM_RESOURCE
index|]
operator|.
name|flags
operator|&
name|IORESOURCE_ROM_SHADOW
expr_stmt|;
name|remove_conflicting_framebuffers
argument_list|(
name|ap
argument_list|,
literal|"inteldrmfb"
argument_list|,
name|primary
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|i915_dump_device_info
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
specifier|const
name|struct
name|intel_device_info
modifier|*
name|info
init|=
name|dev_priv
operator|->
name|info
decl_stmt|;
define|#
directive|define
name|DEV_INFO_FLAG
parameter_list|(
name|name
parameter_list|)
value|info->name ? #name "," : ""
define|#
directive|define
name|DEV_INFO_SEP
value|,
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"i915 device info: gen=%i, pciid=0x%04x flags="
literal|"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s"
argument_list|,
name|info
operator|->
name|gen
argument_list|,
name|dev_priv
operator|->
name|dev
operator|->
name|pci_device
argument_list|,
name|DEV_INFO_FLAGS
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|DEV_INFO_FLAG
undef|#
directive|undef
name|DEV_INFO_SEP
block|}
end_function

begin_comment
comment|/**  * i915_driver_load - setup chip and create an initial config  * @dev: DRM device  * @flags: startup flags  *  * The driver load routine has to do several things:  *   - drive output discovery via intel_modeset_init()  *   - initialize the memory manager  *   - allocate initial config memory  *   - setup the DRM framebuffer with the allocated memory  */
end_comment

begin_function
name|int
name|i915_driver_load
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
specifier|const
name|struct
name|intel_device_info
modifier|*
name|info
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|mmio_bar
decl_stmt|,
name|mmio_size
decl_stmt|;
name|uint32_t
name|aperture_size
decl_stmt|;
name|info
operator|=
name|i915_get_device_id
argument_list|(
name|dev
operator|->
name|pci_device
argument_list|)
expr_stmt|;
comment|/* Refuse to load on gen6+ without kms enabled. */
if|if
condition|(
name|info
operator|->
name|gen
operator|>=
literal|6
operator|&&
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
comment|/* i915 has 4 more counters */
name|dev
operator|->
name|counters
operator|+=
literal|4
expr_stmt|;
name|dev
operator|->
name|types
index|[
literal|6
index|]
operator|=
name|_DRM_STAT_IRQ
expr_stmt|;
name|dev
operator|->
name|types
index|[
literal|7
index|]
operator|=
name|_DRM_STAT_PRIMARY
expr_stmt|;
name|dev
operator|->
name|types
index|[
literal|8
index|]
operator|=
name|_DRM_STAT_SECONDARY
expr_stmt|;
name|dev
operator|->
name|types
index|[
literal|9
index|]
operator|=
name|_DRM_STAT_DMA
expr_stmt|;
name|dev_priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|drm_i915_private_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|dev_priv
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|dev_priv
operator|->
name|info
operator|=
name|info
expr_stmt|;
name|i915_dump_device_info
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|i915_get_bridge_dev
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EIO
expr_stmt|;
goto|goto
name|free_priv
goto|;
block|}
name|ret
operator|=
name|i915_gem_gtt_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|put_bridge
goto|;
ifdef|#
directive|ifdef
name|__linux__
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
name|i915_kick_out_firmware_fb
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|pci_set_master
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
expr_stmt|;
comment|/* overlay on gen2 is broken and can't address above 1G */
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|dma_set_coherent_mask
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|30
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 965GM sometimes incorrectly writes to hardware status page (HWS) 	 * using 32bit addressing, overwriting memory if HWS is located 	 * above 4GB. 	 * 	 * The documentation also mentions an issue with undefined 	 * behaviour if any general state is accessed within a page above 4GB, 	 * which also needs to be handled carefully. 	 */
if|if
condition|(
name|IS_BROADWATER
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_CRESTLINE
argument_list|(
name|dev
argument_list|)
condition|)
name|dma_set_coherent_mask
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|32
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mmio_bar
operator|=
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Before gen4, the registers and the GTT are behind different BARs. 	 * However, from gen4 onwards, the registers and the GTT are shared 	 * in the same BAR, so we want to restrict this ioremap from 	 * clobbering the GTT which we want ioremap_wc instead. Fortunately, 	 * the register BAR remains the same size for all the earlier 	 * generations up to Ironlake. 	 */
if|if
condition|(
name|info
operator|->
name|gen
operator|<
literal|5
condition|)
name|mmio_size
operator|=
literal|512
operator|*
literal|1024
expr_stmt|;
else|else
name|mmio_size
operator|=
literal|2
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
name|ret
operator|=
name|drm_addmap
argument_list|(
name|dev
argument_list|,
name|drm_get_resource_start
argument_list|(
name|dev
argument_list|,
name|mmio_bar
argument_list|)
argument_list|,
name|mmio_size
argument_list|,
name|_DRM_REGISTERS
argument_list|,
name|_DRM_KERNEL
operator||
name|_DRM_DRIVER
argument_list|,
operator|&
name|dev_priv
operator|->
name|mmio_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to map registers\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EIO
expr_stmt|;
goto|goto
name|put_gmch
goto|;
block|}
name|aperture_size
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_mappable_entries
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gma_bus_addr
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mapping
operator|=
name|io_mapping_create_wc
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
argument_list|,
name|aperture_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mapping
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|EIO
expr_stmt|;
goto|goto
name|out_rmmap
goto|;
block|}
endif|#
directive|endif
name|i915_mtrr_setup
argument_list|(
name|dev_priv
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
argument_list|,
name|aperture_size
argument_list|)
expr_stmt|;
comment|/* The i915 workqueue is primarily used for batched retirement of 	 * requests (and thus managing bo) once the task has been completed 	 * by the GPU. i915_gem_retire_requests() is called directly when we 	 * need high-priority retirement, such as waiting for an explicit 	 * bo. 	 * 	 * It is also used for periodic low-priority events, such as 	 * idle-timers and recording error state. 	 * 	 * All tasks on the workqueue are expected to acquire the dev mutex 	 * so there is no point in running more than one instance of the 	 * workqueue at any time.  Use an ordered one. 	 */
name|dev_priv
operator|->
name|wq
operator|=
name|taskqueue_create
argument_list|(
literal|"915"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|dev_priv
operator|->
name|wq
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|wq
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed to create our workqueue.\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_mtrrfree
goto|;
block|}
name|taskqueue_start_threads
argument_list|(
operator|&
name|dev_priv
operator|->
name|wq
argument_list|,
literal|1
argument_list|,
name|PWAIT
argument_list|,
literal|"i915 taskq"
argument_list|)
expr_stmt|;
comment|/* This must be called before any calls to HAS_PCH_* */
name|intel_detect_pch
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_irq_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_gt_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Try to make sure MCHBAR is enabled before poking at it */
name|intel_setup_mchbar
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_setup_gmbus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_opregion_setup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_setup_bios
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_load
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* On the 945G/GM, the chipset reports the MSI capability on the 	 * integrated graphics even though the support isn't actually there 	 * according to the published specs.  It doesn't appear to function 	 * correctly in testing on 945G. 	 * This may be a side effect of MSI having been made available for PEG 	 * and the registers being closely associated. 	 * 	 * According to chipset errata, on the 965GM, MSI interrupts may 	 * be lost or delayed, but we use them anyways to avoid 	 * stuck interrupts on some machines. 	 */
if|if
condition|(
operator|!
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|&&
operator|!
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
condition|)
name|drm_pci_enable_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|,
literal|"userirq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_lock
argument_list|,
literal|"915err"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|lock
argument_list|,
literal|"915rps"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|,
literal|"915dpi"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|hw_lock
argument_list|,
literal|"915rpshw"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|num_pipe
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_MOBILE
argument_list|(
name|dev
argument_list|)
operator|||
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|num_pipe
operator|=
literal|2
expr_stmt|;
else|else
name|dev_priv
operator|->
name|num_pipe
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|drm_vblank_init
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|num_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out_gem_unload
goto|;
comment|/* Start out suspended */
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
block|{
name|ret
operator|=
name|i915_load_modeset_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to init modeset\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_gem_unload
goto|;
block|}
block|}
name|pci_enable_busmaster
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|i915_setup_sysfs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Must be done after probing outputs */
name|intel_opregion_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|acpi_video_register
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|callout_init
argument_list|(
operator|&
name|dev_priv
operator|->
name|hangcheck_timer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|dev_priv
operator|->
name|hangcheck_timer
argument_list|,
name|DRM_I915_HANGCHECK_PERIOD
argument_list|,
name|i915_hangcheck_elapsed
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_gpu_ips_init
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out_gem_unload
label|:
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vm_lowmem
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|inactive_shrinker
argument_list|)
expr_stmt|;
name|free_completion
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|hw_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|msi_enabled
condition|)
name|drm_pci_disable_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_teardown_gmbus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_teardown_mchbar
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|wq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_free
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|wq
operator|=
name|NULL
expr_stmt|;
block|}
name|out_mtrrfree
label|:
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mtrr
operator|>=
literal|0
condition|)
block|{
name|drm_mtrr_del
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mtrr
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
argument_list|,
name|aperture_size
argument_list|,
name|DRM_MTRR_WC
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mtrr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__linux__
name|io_mapping_free
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mapping
argument_list|)
expr_stmt|;
name|out_rmmap
label|:
endif|#
directive|endif
if|if
condition|(
name|dev_priv
operator|->
name|mmio_map
operator|!=
name|NULL
condition|)
name|drm_rmmap
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|mmio_map
argument_list|)
expr_stmt|;
name|put_gmch
label|:
name|i915_gem_gtt_fini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|put_bridge
label|:
ifdef|#
directive|ifdef
name|__linux__
name|pci_dev_put
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free_priv
label|:
name|free
argument_list|(
name|dev_priv
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_driver_unload
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|intel_gpu_ips_teardown
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|i915_teardown_sysfs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|inactive_shrinker
operator|.
name|shrink
condition|)
name|unregister_shrinker
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|inactive_shrinker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|intel_free_parsed_bios_data
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gpu_idle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to idle hardware: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|i915_gem_retire_requests
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Cancel the retire work handler, which should be idle now. */
while|while
condition|(
name|taskqueue_cancel_timeout
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|retire_work
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|taskqueue_drain_timeout
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|retire_work
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|io_mapping_free
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mapping
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mtrr
operator|>=
literal|0
condition|)
block|{
name|drm_mtrr_del
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mtrr
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_mappable_entries
operator|*
name|PAGE_SIZE
argument_list|,
name|DRM_MTRR_WC
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mtrr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__linux__
name|acpi_video_unregister
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
block|{
name|intel_fbdev_fini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_modeset_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|console_resume_work
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|console_resume_work
argument_list|)
expr_stmt|;
comment|/* 		 * free the memory space allocated for the child device 		 * config parsed from VBT 		 */
if|if
condition|(
name|dev_priv
operator|->
name|child_dev
operator|&&
name|dev_priv
operator|->
name|child_dev_num
condition|)
block|{
name|free
argument_list|(
name|dev_priv
operator|->
name|child_dev
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|child_dev
operator|=
name|NULL
expr_stmt|;
name|dev_priv
operator|->
name|child_dev_num
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__linux__
name|vga_switcheroo_unregister_client
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
expr_stmt|;
name|vga_client_register
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Free error state after interrupts are fully disabled. */
name|callout_stop
argument_list|(
operator|&
name|dev_priv
operator|->
name|hangcheck_timer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|dev_priv
operator|->
name|hangcheck_timer
argument_list|)
expr_stmt|;
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|error_work
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|taskqueue_drain
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|error_work
argument_list|)
expr_stmt|;
name|i915_destroy_error_state
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|msi_enabled
condition|)
name|drm_pci_disable_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_opregion_fini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
block|{
comment|/* Flush any outstanding unpin_work. */
name|taskqueue_drain_all
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_free_all_phys_object
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_cleanup_ringbuffer
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_context_fini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_cleanup_aliasing_ppgtt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_cleanup_stolen
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|drm_mm_takedown
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|stolen
argument_list|)
expr_stmt|;
name|intel_cleanup_overlay
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|I915_NEED_GFX_HWS
argument_list|(
name|dev
argument_list|)
condition|)
name|i915_free_hws
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|intel_teardown_gmbus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_teardown_mchbar
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE Linux<->FreeBSD: Free mmio_map after 	 * intel_teardown_gmbus(), because, on FreeBSD, 	 * intel_i2c_reset() is called during iicbus_detach(). 	 */
if|if
condition|(
name|dev_priv
operator|->
name|mmio_map
operator|!=
name|NULL
condition|)
name|drm_rmmap
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|mmio_map
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE Linux<->FreeBSD: Linux forgots to call 	 * i915_gem_gtt_fini(), causing memory leaks. 	 */
name|i915_gem_gtt_fini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|wq
operator|!=
name|NULL
condition|)
name|taskqueue_free
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|)
expr_stmt|;
name|free_completion
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|dev_priv
operator|->
name|dpio_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|hw_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|pci_dev_put
argument_list|(
name|dev_priv
operator|->
name|bridge_dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_driver_open
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_file_private
modifier|*
name|file_priv
decl_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|file_priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|file_priv
argument_list|)
argument_list|,
name|DRM_MEM_FILES
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_priv
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|file
operator|->
name|driver_priv
operator|=
name|file_priv
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lock
argument_list|,
literal|"915fp"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|request_list
argument_list|)
expr_stmt|;
name|drm_gem_names_init
argument_list|(
operator|&
name|file_priv
operator|->
name|context_idr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * i915_driver_lastclose - clean up after all DRM clients have exited  * @dev: DRM device  *  * Take care of cleaning up after all DRM clients have exited.  In the  * mode setting case, we want to restore the kernel's initial mode (just  * in case the last client left us in a bad state).  *  * Additionally, in the non-mode setting case, we'll tear down the GTT  * and DMA structures, since the kernel won't be using them, and clea  * up any GEM state.  */
end_comment

begin_function
name|void
name|i915_driver_lastclose
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* On gen6+ we refuse to init without kms enabled, but then the drm core 	 * goes right around and calls lastclose. Check for this and don't clean 	 * up anything. */
if|if
condition|(
operator|!
name|dev_priv
condition|)
return|return;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
block|{
name|intel_fb_restore_mode
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|vga_switcheroo_process_delayed_switch
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|i915_gem_lastclose
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_dma_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_driver_preclose
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|i915_gem_context_close
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
name|i915_gem_release
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_driver_postclose
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_file_private
modifier|*
name|file_priv
init|=
name|file
operator|->
name|driver_priv
decl_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_priv
argument_list|,
name|DRM_MEM_FILES
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|drm_ioctl_desc
name|i915_ioctls
index|[]
init|=
block|{
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_INIT
argument_list|,
name|i915_dma_init
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_FLUSH
argument_list|,
name|i915_flush_ioctl
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_FLIP
argument_list|,
name|i915_flip_bufs
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_BATCHBUFFER
argument_list|,
name|i915_batchbuffer
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_IRQ_EMIT
argument_list|,
name|i915_irq_emit
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_IRQ_WAIT
argument_list|,
name|i915_irq_wait
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GETPARAM
argument_list|,
name|i915_getparam
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_SETPARAM
argument_list|,
name|i915_setparam
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_ALLOC
argument_list|,
name|drm_noop
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_FREE
argument_list|,
name|drm_noop
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_INIT_HEAP
argument_list|,
name|drm_noop
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_CMDBUFFER
argument_list|,
name|i915_cmdbuffer
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_DESTROY_HEAP
argument_list|,
name|drm_noop
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_SET_VBLANK_PIPE
argument_list|,
name|drm_noop
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GET_VBLANK_PIPE
argument_list|,
name|i915_vblank_pipe_get
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_VBLANK_SWAP
argument_list|,
name|i915_vblank_swap
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_HWS_ADDR
argument_list|,
name|i915_set_status_page
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_INIT
argument_list|,
name|i915_gem_init_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_EXECBUFFER
argument_list|,
name|i915_gem_execbuffer
argument_list|,
name|DRM_AUTH
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_EXECBUFFER2
argument_list|,
name|i915_gem_execbuffer2
argument_list|,
name|DRM_AUTH
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_PIN
argument_list|,
name|i915_gem_pin_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_ROOT_ONLY
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_UNPIN
argument_list|,
name|i915_gem_unpin_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_ROOT_ONLY
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_BUSY
argument_list|,
name|i915_gem_busy_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_SET_CACHING
argument_list|,
name|i915_gem_set_caching_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_GET_CACHING
argument_list|,
name|i915_gem_get_caching_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_THROTTLE
argument_list|,
name|i915_gem_throttle_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_ENTERVT
argument_list|,
name|i915_gem_entervt_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_LEAVEVT
argument_list|,
name|i915_gem_leavevt_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_CREATE
argument_list|,
name|i915_gem_create_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_PREAD
argument_list|,
name|i915_gem_pread_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_PWRITE
argument_list|,
name|i915_gem_pwrite_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_MMAP
argument_list|,
name|i915_gem_mmap_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_MMAP_GTT
argument_list|,
name|i915_gem_mmap_gtt_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_SET_DOMAIN
argument_list|,
name|i915_gem_set_domain_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_SW_FINISH
argument_list|,
name|i915_gem_sw_finish_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_SET_TILING
argument_list|,
name|i915_gem_set_tiling
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_GET_TILING
argument_list|,
name|i915_gem_get_tiling
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_GET_APERTURE
argument_list|,
name|i915_gem_get_aperture_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GET_PIPE_FROM_CRTC_ID
argument_list|,
name|intel_get_pipe_from_crtc_id
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_MADVISE
argument_list|,
name|i915_gem_madvise_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_OVERLAY_PUT_IMAGE
argument_list|,
name|intel_overlay_put_image
argument_list|,
name|DRM_MASTER
operator||
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_OVERLAY_ATTRS
argument_list|,
name|intel_overlay_attrs
argument_list|,
name|DRM_MASTER
operator||
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_SET_SPRITE_COLORKEY
argument_list|,
name|intel_sprite_set_colorkey
argument_list|,
name|DRM_MASTER
operator||
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GET_SPRITE_COLORKEY
argument_list|,
name|intel_sprite_get_colorkey
argument_list|,
name|DRM_MASTER
operator||
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_WAIT
argument_list|,
name|i915_gem_wait_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_CONTEXT_CREATE
argument_list|,
name|i915_gem_context_create_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_GEM_CONTEXT_DESTROY
argument_list|,
name|i915_gem_context_destroy_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF_DRV
argument_list|(
name|I915_REG_READ
argument_list|,
name|i915_reg_read_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i915_max_ioctl
init|=
name|DRM_ARRAY_SIZE
argument_list|(
name|i915_ioctls
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is really ugly: Because old userspace abused the linux agp interface to  * manage the gtt, we need to claim that all intel devices are agp.  For  * otherwise the drm core refuses to initialize the agp support code.  */
end_comment

begin_function
name|int
name|i915_driver_device_is_agp
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

end_unit

