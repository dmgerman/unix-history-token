begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008 Intel Corporation<hong.liu@intel.com>  * Copyright 2008 Red Hat<mjg@redhat.com>  *  * Permission is hereby granted, free of charge, to any person obtaining  * a copy of this software and associated documentation files (the  * "Software"), to deal in the Software without restriction, including  * without limitation the rights to use, copy, modify, merge, publish,  * distribute, sub license, and/or sell copies of the Software, and to  * permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial  * portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NON-INFRINGEMENT.  IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE  * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_define
define|#
directive|define
name|PCI_ASLE
value|0xe4
end_define

begin_define
define|#
directive|define
name|PCI_ASLS
value|0xfc
end_define

begin_define
define|#
directive|define
name|OPREGION_HEADER_OFFSET
value|0
end_define

begin_define
define|#
directive|define
name|OPREGION_ACPI_OFFSET
value|0x100
end_define

begin_define
define|#
directive|define
name|ACPI_CLID
value|0x01ac
end_define

begin_comment
comment|/* current lid state indicator */
end_comment

begin_define
define|#
directive|define
name|ACPI_CDCK
value|0x01b0
end_define

begin_comment
comment|/* current docking state indicator */
end_comment

begin_define
define|#
directive|define
name|OPREGION_SWSCI_OFFSET
value|0x200
end_define

begin_define
define|#
directive|define
name|OPREGION_ASLE_OFFSET
value|0x300
end_define

begin_define
define|#
directive|define
name|OPREGION_VBT_OFFSET
value|0x400
end_define

begin_define
define|#
directive|define
name|OPREGION_SIGNATURE
value|"IntelGraphicsMem"
end_define

begin_define
define|#
directive|define
name|MBOX_ACPI
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|MBOX_SWSCI
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|MBOX_ASLE
value|(1<<2)
end_define

begin_struct
struct|struct
name|opregion_header
block|{
name|u8
name|signature
index|[
literal|16
index|]
decl_stmt|;
name|u32
name|size
decl_stmt|;
name|u32
name|opregion_ver
decl_stmt|;
name|u8
name|bios_ver
index|[
literal|32
index|]
decl_stmt|;
name|u8
name|vbios_ver
index|[
literal|16
index|]
decl_stmt|;
name|u8
name|driver_ver
index|[
literal|16
index|]
decl_stmt|;
name|u32
name|mboxes
decl_stmt|;
name|u8
name|reserved
index|[
literal|164
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* OpRegion mailbox #1: public ACPI methods */
end_comment

begin_struct
struct|struct
name|opregion_acpi
block|{
name|u32
name|drdy
decl_stmt|;
comment|/* driver readiness */
name|u32
name|csts
decl_stmt|;
comment|/* notification status */
name|u32
name|cevt
decl_stmt|;
comment|/* current event */
name|u8
name|rsvd1
index|[
literal|20
index|]
decl_stmt|;
name|u32
name|didl
index|[
literal|8
index|]
decl_stmt|;
comment|/* supported display devices ID list */
name|u32
name|cpdl
index|[
literal|8
index|]
decl_stmt|;
comment|/* currently presented display list */
name|u32
name|cadl
index|[
literal|8
index|]
decl_stmt|;
comment|/* currently active display list */
name|u32
name|nadl
index|[
literal|8
index|]
decl_stmt|;
comment|/* next active devices list */
name|u32
name|aslp
decl_stmt|;
comment|/* ASL sleep time-out */
name|u32
name|tidx
decl_stmt|;
comment|/* toggle table index */
name|u32
name|chpd
decl_stmt|;
comment|/* current hotplug enable indicator */
name|u32
name|clid
decl_stmt|;
comment|/* current lid state*/
name|u32
name|cdck
decl_stmt|;
comment|/* current docking state */
name|u32
name|sxsw
decl_stmt|;
comment|/* Sx state resume */
name|u32
name|evts
decl_stmt|;
comment|/* ASL supported events */
name|u32
name|cnot
decl_stmt|;
comment|/* current OS notification */
name|u32
name|nrdy
decl_stmt|;
comment|/* driver status */
name|u8
name|rsvd2
index|[
literal|60
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* OpRegion mailbox #2: SWSCI */
end_comment

begin_struct
struct|struct
name|opregion_swsci
block|{
name|u32
name|scic
decl_stmt|;
comment|/* SWSCI command|status|data */
name|u32
name|parm
decl_stmt|;
comment|/* command parameters */
name|u32
name|dslp
decl_stmt|;
comment|/* driver sleep time-out */
name|u8
name|rsvd
index|[
literal|244
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* OpRegion mailbox #3: ASLE */
end_comment

begin_struct
struct|struct
name|opregion_asle
block|{
name|u32
name|ardy
decl_stmt|;
comment|/* driver readiness */
name|u32
name|aslc
decl_stmt|;
comment|/* ASLE interrupt command */
name|u32
name|tche
decl_stmt|;
comment|/* technology enabled indicator */
name|u32
name|alsi
decl_stmt|;
comment|/* current ALS illuminance reading */
name|u32
name|bclp
decl_stmt|;
comment|/* backlight brightness to set */
name|u32
name|pfit
decl_stmt|;
comment|/* panel fitting state */
name|u32
name|cblv
decl_stmt|;
comment|/* current brightness level */
name|u16
name|bclm
index|[
literal|20
index|]
decl_stmt|;
comment|/* backlight level duty cycle mapping table */
name|u32
name|cpfm
decl_stmt|;
comment|/* current panel fitting mode */
name|u32
name|epfm
decl_stmt|;
comment|/* enabled panel fitting modes */
name|u8
name|plut
index|[
literal|74
index|]
decl_stmt|;
comment|/* panel LUT and identifier */
name|u32
name|pfmb
decl_stmt|;
comment|/* PWM freq and min brightness */
name|u8
name|rsvd
index|[
literal|102
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* ASLE irq request bits */
end_comment

begin_define
define|#
directive|define
name|ASLE_SET_ALS_ILLUM
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|ASLE_SET_BACKLIGHT
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|ASLE_SET_PFIT
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|ASLE_SET_PWM_FREQ
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|ASLE_REQ_MSK
value|0xf
end_define

begin_comment
comment|/* response bits of ASLE irq request */
end_comment

begin_define
define|#
directive|define
name|ASLE_ALS_ILLUM_FAILED
value|(1<<10)
end_define

begin_define
define|#
directive|define
name|ASLE_BACKLIGHT_FAILED
value|(1<<12)
end_define

begin_define
define|#
directive|define
name|ASLE_PFIT_FAILED
value|(1<<14)
end_define

begin_define
define|#
directive|define
name|ASLE_PWM_FREQ_FAILED
value|(1<<16)
end_define

begin_comment
comment|/* ASLE backlight brightness to set */
end_comment

begin_define
define|#
directive|define
name|ASLE_BCLP_VALID
value|(1<<31)
end_define

begin_define
define|#
directive|define
name|ASLE_BCLP_MSK
value|(~(1<<31))
end_define

begin_comment
comment|/* ASLE panel fitting request */
end_comment

begin_define
define|#
directive|define
name|ASLE_PFIT_VALID
value|(1<<31)
end_define

begin_define
define|#
directive|define
name|ASLE_PFIT_CENTER
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|ASLE_PFIT_STRETCH_TEXT
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|ASLE_PFIT_STRETCH_GFX
value|(1<<2)
end_define

begin_comment
comment|/* PWM frequency and minimum brightness */
end_comment

begin_define
define|#
directive|define
name|ASLE_PFMB_BRIGHTNESS_MASK
value|(0xff)
end_define

begin_define
define|#
directive|define
name|ASLE_PFMB_BRIGHTNESS_VALID
value|(1<<8)
end_define

begin_define
define|#
directive|define
name|ASLE_PFMB_PWM_MASK
value|(0x7ffffe00)
end_define

begin_define
define|#
directive|define
name|ASLE_PFMB_PWM_VALID
value|(1<<31)
end_define

begin_define
define|#
directive|define
name|ASLE_CBLV_VALID
value|(1<<31)
end_define

begin_define
define|#
directive|define
name|ACPI_OTHER_OUTPUT
value|(0<<8)
end_define

begin_define
define|#
directive|define
name|ACPI_VGA_OUTPUT
value|(1<<8)
end_define

begin_define
define|#
directive|define
name|ACPI_TV_OUTPUT
value|(2<<8)
end_define

begin_define
define|#
directive|define
name|ACPI_DIGITAL_OUTPUT
value|(3<<8)
end_define

begin_define
define|#
directive|define
name|ACPI_LVDS_OUTPUT
value|(4<<8)
end_define

begin_if
if|#
directive|if
literal|1
end_if

begin_function
specifier|static
name|u32
name|asle_set_backlight
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|u32
name|bclp
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|opregion_asle
modifier|*
name|asle
init|=
name|dev_priv
operator|->
name|opregion
operator|.
name|asle
decl_stmt|;
name|u32
name|max
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|bclp
operator|&
name|ASLE_BCLP_VALID
operator|)
condition|)
return|return
name|ASLE_BACKLIGHT_FAILED
return|;
name|bclp
operator|&=
name|ASLE_BCLP_MSK
expr_stmt|;
if|if
condition|(
name|bclp
operator|>
literal|255
condition|)
return|return
name|ASLE_BACKLIGHT_FAILED
return|;
name|max
operator|=
name|intel_panel_get_max_backlight
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_panel_set_backlight
argument_list|(
name|dev
argument_list|,
name|bclp
operator|*
name|max
operator|/
literal|255
argument_list|)
expr_stmt|;
name|asle
operator|->
name|cblv
operator|=
operator|(
name|bclp
operator|*
literal|0x64
operator|)
operator|/
literal|0xff
operator||
name|ASLE_CBLV_VALID
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|asle_set_als_illum
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|u32
name|alsi
parameter_list|)
block|{
comment|/* alsi is the current ALS reading in lux. 0 indicates below sensor 	   range, 0xffff indicates above sensor range. 1-0xfffe are valid */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|asle_set_pwm_freq
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|u32
name|pfmb
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|pfmb
operator|&
name|ASLE_PFMB_PWM_VALID
condition|)
block|{
name|u32
name|blc_pwm_ctl
init|=
name|I915_READ
argument_list|(
name|BLC_PWM_CTL
argument_list|)
decl_stmt|;
name|u32
name|pwm
init|=
name|pfmb
operator|&
name|ASLE_PFMB_PWM_MASK
decl_stmt|;
name|blc_pwm_ctl
operator|&=
name|BACKLIGHT_DUTY_CYCLE_MASK
expr_stmt|;
name|pwm
operator|=
name|pwm
operator|>>
literal|9
expr_stmt|;
comment|/* FIXME - what do we do with the PWM? */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|asle_set_pfit
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|u32
name|pfit
parameter_list|)
block|{
comment|/* Panel fitting is currently controlled by the X code, so this is a 	   noop until modesetting support works fully */
if|if
condition|(
operator|!
operator|(
name|pfit
operator|&
name|ASLE_PFIT_VALID
operator|)
condition|)
return|return
name|ASLE_PFIT_FAILED
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|intel_opregion_asle_intr
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|opregion_asle
modifier|*
name|asle
init|=
name|dev_priv
operator|->
name|opregion
operator|.
name|asle
decl_stmt|;
name|u32
name|asle_stat
init|=
literal|0
decl_stmt|;
name|u32
name|asle_req
decl_stmt|;
if|if
condition|(
operator|!
name|asle
condition|)
return|return;
name|asle_req
operator|=
name|asle
operator|->
name|aslc
operator|&
name|ASLE_REQ_MSK
expr_stmt|;
if|if
condition|(
operator|!
name|asle_req
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"non asle set request??\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asle_req
operator|&
name|ASLE_SET_ALS_ILLUM
condition|)
name|asle_stat
operator||=
name|asle_set_als_illum
argument_list|(
name|dev
argument_list|,
name|asle
operator|->
name|alsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|asle_req
operator|&
name|ASLE_SET_BACKLIGHT
condition|)
name|asle_stat
operator||=
name|asle_set_backlight
argument_list|(
name|dev
argument_list|,
name|asle
operator|->
name|bclp
argument_list|)
expr_stmt|;
if|if
condition|(
name|asle_req
operator|&
name|ASLE_SET_PFIT
condition|)
name|asle_stat
operator||=
name|asle_set_pfit
argument_list|(
name|dev
argument_list|,
name|asle
operator|->
name|pfit
argument_list|)
expr_stmt|;
if|if
condition|(
name|asle_req
operator|&
name|ASLE_SET_PWM_FREQ
condition|)
name|asle_stat
operator||=
name|asle_set_pwm_freq
argument_list|(
name|dev
argument_list|,
name|asle
operator|->
name|pfmb
argument_list|)
expr_stmt|;
name|asle
operator|->
name|aslc
operator|=
name|asle_stat
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_opregion_gse_intr
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|opregion_asle
modifier|*
name|asle
init|=
name|dev_priv
operator|->
name|opregion
operator|.
name|asle
decl_stmt|;
name|u32
name|asle_stat
init|=
literal|0
decl_stmt|;
name|u32
name|asle_req
decl_stmt|;
if|if
condition|(
operator|!
name|asle
condition|)
return|return;
name|asle_req
operator|=
name|asle
operator|->
name|aslc
operator|&
name|ASLE_REQ_MSK
expr_stmt|;
if|if
condition|(
operator|!
name|asle_req
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"non asle set request??\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asle_req
operator|&
name|ASLE_SET_ALS_ILLUM
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Illum is not supported\n"
argument_list|)
expr_stmt|;
name|asle_stat
operator||=
name|ASLE_ALS_ILLUM_FAILED
expr_stmt|;
block|}
if|if
condition|(
name|asle_req
operator|&
name|ASLE_SET_BACKLIGHT
condition|)
name|asle_stat
operator||=
name|asle_set_backlight
argument_list|(
name|dev
argument_list|,
name|asle
operator|->
name|bclp
argument_list|)
expr_stmt|;
if|if
condition|(
name|asle_req
operator|&
name|ASLE_SET_PFIT
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Pfit is not supported\n"
argument_list|)
expr_stmt|;
name|asle_stat
operator||=
name|ASLE_PFIT_FAILED
expr_stmt|;
block|}
if|if
condition|(
name|asle_req
operator|&
name|ASLE_SET_PWM_FREQ
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"PWM freq is not supported\n"
argument_list|)
expr_stmt|;
name|asle_stat
operator||=
name|ASLE_PWM_FREQ_FAILED
expr_stmt|;
block|}
name|asle
operator|->
name|aslc
operator|=
name|asle_stat
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ASLE_ALS_EN
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|ASLE_BLC_EN
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|ASLE_PFIT_EN
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|ASLE_PFMB_EN
value|(1<<3)
end_define

begin_function
name|void
name|intel_opregion_enable_asle
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|opregion_asle
modifier|*
name|asle
init|=
name|dev_priv
operator|->
name|opregion
operator|.
name|asle
decl_stmt|;
if|if
condition|(
name|asle
condition|)
block|{
if|if
condition|(
name|IS_MOBILE
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_enable_asle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|asle
operator|->
name|tche
operator|=
name|ASLE_ALS_EN
operator||
name|ASLE_BLC_EN
operator||
name|ASLE_PFIT_EN
operator||
name|ASLE_PFMB_EN
expr_stmt|;
name|asle
operator|->
name|ardy
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ACPI_EV_DISPLAY_SWITCH
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|ACPI_EV_LID
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|ACPI_EV_DOCK
value|(1<<2)
end_define

begin_decl_stmt
specifier|static
name|struct
name|intel_opregion
modifier|*
name|system_opregion
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int intel_opregion_video_event(struct notifier_block *nb, 				      unsigned long val, void *data) {
comment|/* The only video events relevant to opregion are 0x80. These indicate 	   either a docking event, lid switch or display switch request. In 	   Linux, these are handled by the dock, button and video drivers. 	*/
end_comment

begin_endif
unit|struct opregion_acpi *acpi; 	struct acpi_bus_event *event = data; 	int ret = NOTIFY_OK;  	if (strcmp(event->device_class, ACPI_VIDEO_CLASS) != 0) 		return NOTIFY_DONE;  	if (!system_opregion) 		return NOTIFY_DONE;  	acpi = system_opregion->acpi;  	if (event->type == 0x80&& !(acpi->cevt& 0x1)) 		ret = NOTIFY_BAD;  	acpi->csts = 0;  	return ret; }  static struct notifier_block intel_opregion_notifier = { 	.notifier_call = intel_opregion_video_event, };
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initialise the DIDL field in opregion. This passes a list of devices to  * the firmware. Values are defined by section B.4.2 of the ACPI specification  * (version 3)  */
end_comment

begin_function
specifier|static
name|int
name|acpi_is_video_device
parameter_list|(
name|ACPI_HANDLE
name|devh
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiGetHandle
argument_list|(
name|devh
argument_list|,
literal|"_DOD"
argument_list|,
operator|&
name|h
argument_list|)
argument_list|)
operator|||
name|ACPI_FAILURE
argument_list|(
name|AcpiGetHandle
argument_list|(
name|devh
argument_list|,
literal|"_DOS"
argument_list|,
operator|&
name|h
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_didl_outputs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_opregion
modifier|*
name|opregion
init|=
operator|&
name|dev_priv
operator|->
name|opregion
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|u32
name|device_id
decl_stmt|;
name|ACPI_HANDLE
name|handle
decl_stmt|,
name|acpi_video_bus
decl_stmt|,
name|acpi_cdev
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
condition|)
return|return;
if|if
condition|(
name|acpi_is_video_device
argument_list|(
name|handle
argument_list|)
condition|)
name|acpi_video_bus
operator|=
name|handle
expr_stmt|;
else|else
block|{
name|acpi_cdev
operator|=
name|NULL
expr_stmt|;
name|acpi_video_bus
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|AcpiGetNextObject
argument_list|(
name|ACPI_TYPE_DEVICE
argument_list|,
name|handle
argument_list|,
name|acpi_cdev
argument_list|,
operator|&
name|acpi_cdev
argument_list|)
operator|!=
name|AE_NOT_FOUND
condition|)
block|{
if|if
condition|(
name|acpi_is_video_device
argument_list|(
name|acpi_cdev
argument_list|)
condition|)
block|{
name|acpi_video_bus
operator|=
name|acpi_cdev
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
literal|0
block|list_for_each_entry(acpi_cdev,&acpi_dev->children, node) { 			if (acpi_is_video_device(acpi_cdev)) { 				acpi_video_bus = acpi_cdev; 				break; 			} 		}
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|acpi_video_bus
condition|)
block|{
name|device_printf
argument_list|(
name|dev
operator|->
name|device
argument_list|,
literal|"No ACPI video bus found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|acpi_cdev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|AcpiGetNextObject
argument_list|(
name|ACPI_TYPE_DEVICE
argument_list|,
name|acpi_video_bus
argument_list|,
name|acpi_cdev
argument_list|,
operator|&
name|acpi_cdev
argument_list|)
operator|!=
name|AE_NOT_FOUND
condition|)
block|{
if|if
condition|(
name|i
operator|>=
literal|8
condition|)
block|{
name|device_printf
argument_list|(
name|dev
operator|->
name|device
argument_list|,
literal|"More than 8 outputs detected\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|status
operator|=
name|acpi_GetInteger
argument_list|(
name|acpi_cdev
argument_list|,
literal|"_ADR"
argument_list|,
operator|&
name|device_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|device_id
condition|)
goto|goto
name|blind_set
goto|;
name|opregion
operator|->
name|acpi
operator|->
name|didl
index|[
name|i
index|]
operator|=
call|(
name|u32
call|)
argument_list|(
name|device_id
operator|&
literal|0x0f0f
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|list_for_each_entry(acpi_cdev,&acpi_video_bus->children, node) { 		if (i>= 8) { 			dev_printk(KERN_ERR,&dev->pdev->dev, 				    "More than 8 outputs detected\n"); 			return; 		} 		status = 			acpi_evaluate_integer(acpi_cdev->handle, "_ADR", 						NULL,&device_id); 		if (ACPI_SUCCESS(status)) { 			if (!device_id) 				goto blind_set; 			opregion->acpi->didl[i] = (u32)(device_id& 0x0f0f); 			i++; 		} 	}
endif|#
directive|endif
name|end
label|:
comment|/* If fewer than 8 outputs, the list must be null terminated */
if|if
condition|(
name|i
operator|<
literal|8
condition|)
name|opregion
operator|->
name|acpi
operator|->
name|didl
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return;
name|blind_set
label|:
name|i
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
name|int
name|output_type
init|=
name|ACPI_OTHER_OUTPUT
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|8
condition|)
block|{
name|device_printf
argument_list|(
name|dev
operator|->
name|device
argument_list|,
literal|"More than 8 outputs detected\n"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|connector
operator|->
name|connector_type
condition|)
block|{
case|case
name|DRM_MODE_CONNECTOR_VGA
case|:
case|case
name|DRM_MODE_CONNECTOR_DVIA
case|:
name|output_type
operator|=
name|ACPI_VGA_OUTPUT
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_Composite
case|:
case|case
name|DRM_MODE_CONNECTOR_SVIDEO
case|:
case|case
name|DRM_MODE_CONNECTOR_Component
case|:
case|case
name|DRM_MODE_CONNECTOR_9PinDIN
case|:
name|output_type
operator|=
name|ACPI_TV_OUTPUT
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_DVII
case|:
case|case
name|DRM_MODE_CONNECTOR_DVID
case|:
case|case
name|DRM_MODE_CONNECTOR_DisplayPort
case|:
case|case
name|DRM_MODE_CONNECTOR_HDMIA
case|:
case|case
name|DRM_MODE_CONNECTOR_HDMIB
case|:
name|output_type
operator|=
name|ACPI_DIGITAL_OUTPUT
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_LVDS
case|:
name|output_type
operator|=
name|ACPI_LVDS_OUTPUT
expr_stmt|;
break|break;
block|}
name|opregion
operator|->
name|acpi
operator|->
name|didl
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|31
operator|)
operator||
name|output_type
operator||
name|i
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
goto|goto
name|end
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_setup_cadls
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_opregion
modifier|*
name|opregion
init|=
operator|&
name|dev_priv
operator|->
name|opregion
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|u32
name|disp_id
decl_stmt|;
comment|/* Initialize the CADL field by duplicating the DIDL values. 	 * Technically, this is not always correct as display outputs may exist, 	 * but not active. This initialization is necessary for some Clevo 	 * laptops that check this field before processing the brightness and 	 * display switching hotkeys. Just like DIDL, CADL is NULL-terminated if 	 * there are less than eight devices. */
do|do
block|{
name|disp_id
operator|=
name|opregion
operator|->
name|acpi
operator|->
name|didl
index|[
name|i
index|]
expr_stmt|;
name|opregion
operator|->
name|acpi
operator|->
name|cadl
index|[
name|i
index|]
operator|=
name|disp_id
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
literal|8
operator|&&
name|disp_id
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_function
name|void
name|intel_opregion_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_opregion
modifier|*
name|opregion
init|=
operator|&
name|dev_priv
operator|->
name|opregion
decl_stmt|;
if|if
condition|(
operator|!
name|opregion
operator|->
name|header
condition|)
return|return;
if|if
condition|(
name|opregion
operator|->
name|acpi
condition|)
block|{
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
block|{
name|intel_didl_outputs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_setup_cadls
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Notify BIOS we are ready to handle ACPI video ext notifs. 		 * Right now, all the events are handled by the ACPI video module. 		 * We don't actually need to do anything with them. */
name|opregion
operator|->
name|acpi
operator|->
name|csts
operator|=
literal|0
expr_stmt|;
name|opregion
operator|->
name|acpi
operator|->
name|drdy
operator|=
literal|1
expr_stmt|;
name|system_opregion
operator|=
name|opregion
expr_stmt|;
if|#
directive|if
literal|0
block|register_acpi_notifier(&intel_opregion_notifier);
endif|#
directive|endif
block|}
if|if
condition|(
name|opregion
operator|->
name|asle
condition|)
name|intel_opregion_enable_asle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_opregion_fini
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_opregion
modifier|*
name|opregion
init|=
operator|&
name|dev_priv
operator|->
name|opregion
decl_stmt|;
if|if
condition|(
operator|!
name|opregion
operator|->
name|header
condition|)
return|return;
if|if
condition|(
name|opregion
operator|->
name|acpi
condition|)
block|{
name|opregion
operator|->
name|acpi
operator|->
name|drdy
operator|=
literal|0
expr_stmt|;
name|system_opregion
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
block|unregister_acpi_notifier(&intel_opregion_notifier);
endif|#
directive|endif
block|}
comment|/* just clear all opregion memory pointers now */
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|opregion
operator|->
name|header
argument_list|,
name|OPREGION_SIZE
argument_list|)
expr_stmt|;
name|opregion
operator|->
name|header
operator|=
name|NULL
expr_stmt|;
name|opregion
operator|->
name|acpi
operator|=
name|NULL
expr_stmt|;
name|opregion
operator|->
name|swsci
operator|=
name|NULL
expr_stmt|;
name|opregion
operator|->
name|asle
operator|=
name|NULL
expr_stmt|;
name|opregion
operator|->
name|vbt
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|intel_opregion_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|intel_opregion_fini
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|intel_opregion
modifier|*
name|opregion
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|opregion
operator|=
operator|&
name|dev_priv
operator|->
name|opregion
expr_stmt|;
if|if
condition|(
name|opregion
operator|->
name|header
operator|==
name|NULL
condition|)
return|return;
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|opregion
operator|->
name|header
argument_list|,
name|OPREGION_SIZE
argument_list|)
expr_stmt|;
name|opregion
operator|->
name|header
operator|=
name|NULL
expr_stmt|;
name|opregion
operator|->
name|acpi
operator|=
name|NULL
expr_stmt|;
name|opregion
operator|->
name|swsci
operator|=
name|NULL
expr_stmt|;
name|opregion
operator|->
name|asle
operator|=
name|NULL
expr_stmt|;
name|opregion
operator|->
name|vbt
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|intel_opregion_setup
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_opregion
modifier|*
name|opregion
init|=
operator|&
name|dev_priv
operator|->
name|opregion
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|u32
name|asls
decl_stmt|,
name|mboxes
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|asls
operator|=
name|pci_read_config
argument_list|(
name|dev
operator|->
name|device
argument_list|,
name|PCI_ASLS
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"graphic opregion physical addr: 0x%x\n"
argument_list|,
name|asls
argument_list|)
expr_stmt|;
if|if
condition|(
name|asls
operator|==
literal|0
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"ACPI OpRegion not supported!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOTSUP
return|;
block|}
name|base
operator|=
operator|(
name|void
operator|*
operator|)
name|pmap_mapbios
argument_list|(
name|asls
argument_list|,
name|OPREGION_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
return|return
operator|-
name|ENOMEM
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|base
argument_list|,
name|OPREGION_SIGNATURE
argument_list|,
literal|16
argument_list|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"opregion signature mismatch\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|opregion
operator|->
name|header
operator|=
operator|(
expr|struct
name|opregion_header
operator|*
operator|)
name|base
expr_stmt|;
name|opregion
operator|->
name|vbt
operator|=
name|base
operator|+
name|OPREGION_VBT_OFFSET
expr_stmt|;
name|opregion
operator|->
name|lid_state
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
name|base
operator|+
name|ACPI_CLID
operator|)
expr_stmt|;
name|mboxes
operator|=
name|opregion
operator|->
name|header
operator|->
name|mboxes
expr_stmt|;
if|if
condition|(
name|mboxes
operator|&
name|MBOX_ACPI
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Public ACPI methods supported\n"
argument_list|)
expr_stmt|;
name|opregion
operator|->
name|acpi
operator|=
operator|(
expr|struct
name|opregion_acpi
operator|*
operator|)
operator|(
name|base
operator|+
name|OPREGION_ACPI_OFFSET
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|mboxes
operator|&
name|MBOX_SWSCI
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"SWSCI supported\n"
argument_list|)
expr_stmt|;
name|opregion
operator|->
name|swsci
operator|=
operator|(
expr|struct
name|opregion_swsci
operator|*
operator|)
operator|(
name|base
operator|+
name|OPREGION_SWSCI_OFFSET
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|mboxes
operator|&
name|MBOX_ASLE
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"ASLE supported\n"
argument_list|)
expr_stmt|;
name|opregion
operator|->
name|asle
operator|=
operator|(
expr|struct
name|opregion_asle
operator|*
operator|)
operator|(
name|base
operator|+
name|OPREGION_ASLE_OFFSET
operator|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|err_out
label|:
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|base
argument_list|,
name|OPREGION_SIZE
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

