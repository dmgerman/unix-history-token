begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* i915_drv.c -- i830,i845,i855,i865,i915 driver -*- linux-c -*-  */
end_comment

begin_comment
comment|/*  *  * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the  * "Software"), to deal in the Software without restriction, including  * without limitation the rights to use, copy, modify, merge, publish,  * distribute, sub license, and/or sell copies of the Software, and to  * permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_pciids.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|"dev/drm2/i915/i915_drv.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|"dev/drm2/i915/i915_trace.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dev/drm2/i915/intel_drv.h"
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc_helper.h>
end_include

begin_include
include|#
directive|include
file|"fb_if.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|i915_modeset
name|__read_mostly
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.modeset"
argument_list|,
operator|&
name|i915_modeset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|modeset
argument_list|,
name|i915_modeset
argument_list|,
name|int
argument_list|,
literal|0400
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|modeset
argument_list|,
literal|"Use kernel modesetting [KMS] (0=DRM_I915_KMS from .config, "
literal|"1=on, -1=force vga console preference [default])"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_decl_stmt
name|unsigned
name|int
name|i915_fbpercrtc
name|__always_unused
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|fbpercrtc
argument_list|,
name|i915_fbpercrtc
argument_list|,
name|int
argument_list|,
literal|0400
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|i915_panel_ignore_lid
name|__read_mostly
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.panel_ignore_lid"
argument_list|,
operator|&
name|i915_panel_ignore_lid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|panel_ignore_lid
argument_list|,
name|i915_panel_ignore_lid
argument_list|,
name|int
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|panel_ignore_lid
argument_list|,
literal|"Override lid status (0=autodetect, 1=autodetect disabled [default], "
literal|"-1=force lid closed, -2=force lid open)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|int
name|i915_powersave
name|__read_mostly
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.powersave"
argument_list|,
operator|&
name|i915_powersave
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|powersave
argument_list|,
name|i915_powersave
argument_list|,
name|int
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|powersave
argument_list|,
literal|"Enable powersavings, fbc, downclocking, etc. (default: true)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|i915_semaphores
name|__read_mostly
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.semaphores"
argument_list|,
operator|&
name|i915_semaphores
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|semaphores
argument_list|,
name|i915_semaphores
argument_list|,
name|int
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|semaphores
argument_list|,
literal|"Use semaphores for inter-ring sync (default: -1 (use per-chip defaults))"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|i915_enable_rc6
name|__read_mostly
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.enable_rc6"
argument_list|,
operator|&
name|i915_enable_rc6
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|i915_enable_rc6
argument_list|,
name|i915_enable_rc6
argument_list|,
name|int
argument_list|,
literal|0400
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|i915_enable_rc6
argument_list|,
literal|"Enable power-saving render C-state 6. "
literal|"Different stages can be selected via bitmask values "
literal|"(0 = disable; 1 = enable rc6; 2 = enable deep rc6; 4 = enable deepest rc6). "
literal|"For example, 3 would enable rc6 and deep rc6, and 7 would enable everything. "
literal|"default: -1 (use per-chip default)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|i915_enable_fbc
name|__read_mostly
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.enable_fbc"
argument_list|,
operator|&
name|i915_enable_fbc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|i915_enable_fbc
argument_list|,
name|i915_enable_fbc
argument_list|,
name|int
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|i915_enable_fbc
argument_list|,
literal|"Enable frame buffer compression for power savings "
literal|"(default: -1 (use per-chip default))"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|int
name|i915_lvds_downclock
name|__read_mostly
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.lvds_downclock"
argument_list|,
operator|&
name|i915_lvds_downclock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|lvds_downclock
argument_list|,
name|i915_lvds_downclock
argument_list|,
name|int
argument_list|,
literal|0400
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|lvds_downclock
argument_list|,
literal|"Use panel (LVDS/eDP) downclocking for power savings "
literal|"(default: false)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|i915_lvds_channel_mode
name|__read_mostly
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.lvds_channel_mode"
argument_list|,
operator|&
name|i915_lvds_channel_mode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|lvds_channel_mode
argument_list|,
name|i915_lvds_channel_mode
argument_list|,
name|int
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|lvds_channel_mode
argument_list|,
literal|"Specify LVDS channel mode "
literal|"(0=probe BIOS [default], 1=single-channel, 2=dual-channel)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|i915_panel_use_ssc
name|__read_mostly
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.panel_use_ssc"
argument_list|,
operator|&
name|i915_panel_use_ssc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|lvds_use_ssc
argument_list|,
name|i915_panel_use_ssc
argument_list|,
name|int
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|lvds_use_ssc
argument_list|,
literal|"Use Spread Spectrum Clock with panels [LVDS/eDP] "
literal|"(default: auto from VBT)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|i915_vbt_sdvo_panel_type
name|__read_mostly
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.vbt_sdvo_panel_type"
argument_list|,
operator|&
name|i915_vbt_sdvo_panel_type
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|vbt_sdvo_panel_type
argument_list|,
name|i915_vbt_sdvo_panel_type
argument_list|,
name|int
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|vbt_sdvo_panel_type
argument_list|,
literal|"Override/Ignore selection of SDVO panel mode in the VBT "
literal|"(-2=ignore, -1=auto [default], index in VBT BIOS table)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|i915_try_reset
name|__read_mostly
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.try_reset"
argument_list|,
operator|&
name|i915_try_reset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|reset
argument_list|,
name|i915_try_reset
argument_list|,
name|bool
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|reset
argument_list|,
literal|"Attempt GPU resets (default: true)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|i915_enable_hangcheck
name|__read_mostly
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.enable_hangcheck"
argument_list|,
operator|&
name|i915_enable_hangcheck
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|enable_hangcheck
argument_list|,
name|i915_enable_hangcheck
argument_list|,
name|bool
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|enable_hangcheck
argument_list|,
literal|"Periodically check GPU activity for detecting hangs. "
literal|"WARNING: Disabling this can cause system wide hangs. "
literal|"(default: true)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|i915_enable_ppgtt
name|__read_mostly
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.enable_ppgtt"
argument_list|,
operator|&
name|i915_enable_ppgtt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|i915_enable_ppgtt
argument_list|,
name|i915_enable_ppgtt
argument_list|,
name|int
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|i915_enable_ppgtt
argument_list|,
literal|"Enable PPGTT (default: true)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|int
name|i915_preliminary_hw_support
name|__read_mostly
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.enable_unsupported"
argument_list|,
operator|&
name|i915_preliminary_hw_support
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|preliminary_hw_support
argument_list|,
name|i915_preliminary_hw_support
argument_list|,
name|int
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|preliminary_hw_support
argument_list|,
literal|"Enable preliminary hardware support. "
literal|"Enable Haswell and ValleyView Support. "
literal|"(default: false)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|intel_iommu_gfx_mapped
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"drm.i915.intel_iommu_gfx_mapped"
argument_list|,
operator|&
name|intel_iommu_gfx_mapped
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|drm_driver
name|driver
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|intel_agp_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On FreeBSD, agp is a required dependency. */
end_comment

begin_define
define|#
directive|define
name|INTEL_VGA_DEVICE
parameter_list|(
name|id
parameter_list|,
name|info_
parameter_list|)
value|{		\ 	.device = id,				\ 	.info = info_,				\ }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_i830_info
init|=
block|{
operator|.
name|gen
operator|=
literal|2
block|,
operator|.
name|is_mobile
operator|=
literal|1
block|,
operator|.
name|cursor_needs_physical
operator|=
literal|1
block|,
operator|.
name|has_overlay
operator|=
literal|1
block|,
operator|.
name|overlay_needs_physical
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_845g_info
init|=
block|{
operator|.
name|gen
operator|=
literal|2
block|,
operator|.
name|has_overlay
operator|=
literal|1
block|,
operator|.
name|overlay_needs_physical
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_i85x_info
init|=
block|{
operator|.
name|gen
operator|=
literal|2
block|,
operator|.
name|is_i85x
operator|=
literal|1
block|,
operator|.
name|is_mobile
operator|=
literal|1
block|,
operator|.
name|cursor_needs_physical
operator|=
literal|1
block|,
operator|.
name|has_overlay
operator|=
literal|1
block|,
operator|.
name|overlay_needs_physical
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_i865g_info
init|=
block|{
operator|.
name|gen
operator|=
literal|2
block|,
operator|.
name|has_overlay
operator|=
literal|1
block|,
operator|.
name|overlay_needs_physical
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_i915g_info
init|=
block|{
operator|.
name|gen
operator|=
literal|3
block|,
operator|.
name|is_i915g
operator|=
literal|1
block|,
operator|.
name|cursor_needs_physical
operator|=
literal|1
block|,
operator|.
name|has_overlay
operator|=
literal|1
block|,
operator|.
name|overlay_needs_physical
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_i915gm_info
init|=
block|{
operator|.
name|gen
operator|=
literal|3
block|,
operator|.
name|is_mobile
operator|=
literal|1
block|,
operator|.
name|cursor_needs_physical
operator|=
literal|1
block|,
operator|.
name|has_overlay
operator|=
literal|1
block|,
operator|.
name|overlay_needs_physical
operator|=
literal|1
block|,
operator|.
name|supports_tv
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_i945g_info
init|=
block|{
operator|.
name|gen
operator|=
literal|3
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|cursor_needs_physical
operator|=
literal|1
block|,
operator|.
name|has_overlay
operator|=
literal|1
block|,
operator|.
name|overlay_needs_physical
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_i945gm_info
init|=
block|{
operator|.
name|gen
operator|=
literal|3
block|,
operator|.
name|is_i945gm
operator|=
literal|1
block|,
operator|.
name|is_mobile
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|cursor_needs_physical
operator|=
literal|1
block|,
operator|.
name|has_overlay
operator|=
literal|1
block|,
operator|.
name|overlay_needs_physical
operator|=
literal|1
block|,
operator|.
name|supports_tv
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_i965g_info
init|=
block|{
operator|.
name|gen
operator|=
literal|4
block|,
operator|.
name|is_broadwater
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_overlay
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_i965gm_info
init|=
block|{
operator|.
name|gen
operator|=
literal|4
block|,
operator|.
name|is_crestline
operator|=
literal|1
block|,
operator|.
name|is_mobile
operator|=
literal|1
block|,
operator|.
name|has_fbc
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_overlay
operator|=
literal|1
block|,
operator|.
name|supports_tv
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_g33_info
init|=
block|{
operator|.
name|gen
operator|=
literal|3
block|,
operator|.
name|is_g33
operator|=
literal|1
block|,
operator|.
name|need_gfx_hws
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_overlay
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_g45_info
init|=
block|{
operator|.
name|gen
operator|=
literal|4
block|,
operator|.
name|is_g4x
operator|=
literal|1
block|,
operator|.
name|need_gfx_hws
operator|=
literal|1
block|,
operator|.
name|has_pipe_cxsr
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_bsd_ring
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_gm45_info
init|=
block|{
operator|.
name|gen
operator|=
literal|4
block|,
operator|.
name|is_g4x
operator|=
literal|1
block|,
operator|.
name|is_mobile
operator|=
literal|1
block|,
operator|.
name|need_gfx_hws
operator|=
literal|1
block|,
operator|.
name|has_fbc
operator|=
literal|1
block|,
operator|.
name|has_pipe_cxsr
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|supports_tv
operator|=
literal|1
block|,
operator|.
name|has_bsd_ring
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_pineview_info
init|=
block|{
operator|.
name|gen
operator|=
literal|3
block|,
operator|.
name|is_g33
operator|=
literal|1
block|,
operator|.
name|is_pineview
operator|=
literal|1
block|,
operator|.
name|is_mobile
operator|=
literal|1
block|,
operator|.
name|need_gfx_hws
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_overlay
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_ironlake_d_info
init|=
block|{
operator|.
name|gen
operator|=
literal|5
block|,
operator|.
name|need_gfx_hws
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_bsd_ring
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_ironlake_m_info
init|=
block|{
operator|.
name|gen
operator|=
literal|5
block|,
operator|.
name|is_mobile
operator|=
literal|1
block|,
operator|.
name|need_gfx_hws
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_fbc
operator|=
literal|1
block|,
operator|.
name|has_bsd_ring
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_sandybridge_d_info
init|=
block|{
operator|.
name|gen
operator|=
literal|6
block|,
operator|.
name|need_gfx_hws
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_bsd_ring
operator|=
literal|1
block|,
operator|.
name|has_blt_ring
operator|=
literal|1
block|,
operator|.
name|has_llc
operator|=
literal|1
block|,
operator|.
name|has_force_wake
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_sandybridge_m_info
init|=
block|{
operator|.
name|gen
operator|=
literal|6
block|,
operator|.
name|is_mobile
operator|=
literal|1
block|,
operator|.
name|need_gfx_hws
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_fbc
operator|=
literal|1
block|,
operator|.
name|has_bsd_ring
operator|=
literal|1
block|,
operator|.
name|has_blt_ring
operator|=
literal|1
block|,
operator|.
name|has_llc
operator|=
literal|1
block|,
operator|.
name|has_force_wake
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_ivybridge_d_info
init|=
block|{
operator|.
name|is_ivybridge
operator|=
literal|1
block|,
operator|.
name|gen
operator|=
literal|7
block|,
operator|.
name|need_gfx_hws
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_bsd_ring
operator|=
literal|1
block|,
operator|.
name|has_blt_ring
operator|=
literal|1
block|,
operator|.
name|has_llc
operator|=
literal|1
block|,
operator|.
name|has_force_wake
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_ivybridge_m_info
init|=
block|{
operator|.
name|is_ivybridge
operator|=
literal|1
block|,
operator|.
name|gen
operator|=
literal|7
block|,
operator|.
name|is_mobile
operator|=
literal|1
block|,
operator|.
name|need_gfx_hws
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_fbc
operator|=
literal|0
block|,
comment|/* FBC is not enabled on Ivybridge mobile yet */
operator|.
name|has_bsd_ring
operator|=
literal|1
block|,
operator|.
name|has_blt_ring
operator|=
literal|1
block|,
operator|.
name|has_llc
operator|=
literal|1
block|,
operator|.
name|has_force_wake
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_valleyview_m_info
init|=
block|{
operator|.
name|gen
operator|=
literal|7
block|,
operator|.
name|is_mobile
operator|=
literal|1
block|,
operator|.
name|need_gfx_hws
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_fbc
operator|=
literal|0
block|,
operator|.
name|has_bsd_ring
operator|=
literal|1
block|,
operator|.
name|has_blt_ring
operator|=
literal|1
block|,
operator|.
name|is_valleyview
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_valleyview_d_info
init|=
block|{
operator|.
name|gen
operator|=
literal|7
block|,
operator|.
name|need_gfx_hws
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_fbc
operator|=
literal|0
block|,
operator|.
name|has_bsd_ring
operator|=
literal|1
block|,
operator|.
name|has_blt_ring
operator|=
literal|1
block|,
operator|.
name|is_valleyview
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_haswell_d_info
init|=
block|{
operator|.
name|is_haswell
operator|=
literal|1
block|,
operator|.
name|gen
operator|=
literal|7
block|,
operator|.
name|need_gfx_hws
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_bsd_ring
operator|=
literal|1
block|,
operator|.
name|has_blt_ring
operator|=
literal|1
block|,
operator|.
name|has_llc
operator|=
literal|1
block|,
operator|.
name|has_force_wake
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_device_info
name|intel_haswell_m_info
init|=
block|{
operator|.
name|is_haswell
operator|=
literal|1
block|,
operator|.
name|gen
operator|=
literal|7
block|,
operator|.
name|is_mobile
operator|=
literal|1
block|,
operator|.
name|need_gfx_hws
operator|=
literal|1
block|,
operator|.
name|has_hotplug
operator|=
literal|1
block|,
operator|.
name|has_bsd_ring
operator|=
literal|1
block|,
operator|.
name|has_blt_ring
operator|=
literal|1
block|,
operator|.
name|has_llc
operator|=
literal|1
block|,
operator|.
name|has_force_wake
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* drv_PCI_IDs comes from drm_pciids.h, generated from drm_pciids.txt. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|drm_pci_id_list_t
name|pciidlist
index|[]
init|=
block|{
name|i915_PCI_IDS
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
name|intel_gfx_device_id
block|{
name|int
name|device
decl_stmt|;
specifier|const
name|struct
name|intel_device_info
modifier|*
name|info
decl_stmt|;
block|}
name|i915_infolist
index|[]
init|=
block|{
comment|/* aka */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x3577
argument_list|,
operator|&
name|intel_i830_info
argument_list|)
block|,
comment|/* I830_M */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2562
argument_list|,
operator|&
name|intel_845g_info
argument_list|)
block|,
comment|/* 845_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x3582
argument_list|,
operator|&
name|intel_i85x_info
argument_list|)
block|,
comment|/* I855_GM */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x358e
argument_list|,
operator|&
name|intel_i85x_info
argument_list|)
block|,
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2572
argument_list|,
operator|&
name|intel_i865g_info
argument_list|)
block|,
comment|/* I865_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2582
argument_list|,
operator|&
name|intel_i915g_info
argument_list|)
block|,
comment|/* I915_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x258a
argument_list|,
operator|&
name|intel_i915g_info
argument_list|)
block|,
comment|/* E7221_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2592
argument_list|,
operator|&
name|intel_i915gm_info
argument_list|)
block|,
comment|/* I915_GM */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2772
argument_list|,
operator|&
name|intel_i945g_info
argument_list|)
block|,
comment|/* I945_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x27a2
argument_list|,
operator|&
name|intel_i945gm_info
argument_list|)
block|,
comment|/* I945_GM */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x27ae
argument_list|,
operator|&
name|intel_i945gm_info
argument_list|)
block|,
comment|/* I945_GME */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2972
argument_list|,
operator|&
name|intel_i965g_info
argument_list|)
block|,
comment|/* I946_GZ */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2982
argument_list|,
operator|&
name|intel_i965g_info
argument_list|)
block|,
comment|/* G35_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2992
argument_list|,
operator|&
name|intel_i965g_info
argument_list|)
block|,
comment|/* I965_Q */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x29a2
argument_list|,
operator|&
name|intel_i965g_info
argument_list|)
block|,
comment|/* I965_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x29b2
argument_list|,
operator|&
name|intel_g33_info
argument_list|)
block|,
comment|/* Q35_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x29c2
argument_list|,
operator|&
name|intel_g33_info
argument_list|)
block|,
comment|/* G33_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x29d2
argument_list|,
operator|&
name|intel_g33_info
argument_list|)
block|,
comment|/* Q33_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2a02
argument_list|,
operator|&
name|intel_i965gm_info
argument_list|)
block|,
comment|/* I965_GM */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2a12
argument_list|,
operator|&
name|intel_i965gm_info
argument_list|)
block|,
comment|/* I965_GME */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2a42
argument_list|,
operator|&
name|intel_gm45_info
argument_list|)
block|,
comment|/* GM45_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2e02
argument_list|,
operator|&
name|intel_g45_info
argument_list|)
block|,
comment|/* IGD_E_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2e12
argument_list|,
operator|&
name|intel_g45_info
argument_list|)
block|,
comment|/* Q45_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2e22
argument_list|,
operator|&
name|intel_g45_info
argument_list|)
block|,
comment|/* G45_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2e32
argument_list|,
operator|&
name|intel_g45_info
argument_list|)
block|,
comment|/* G41_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2e42
argument_list|,
operator|&
name|intel_g45_info
argument_list|)
block|,
comment|/* B43_G */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x2e92
argument_list|,
operator|&
name|intel_g45_info
argument_list|)
block|,
comment|/* B43_G.1 */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0xa001
argument_list|,
operator|&
name|intel_pineview_info
argument_list|)
block|,
name|INTEL_VGA_DEVICE
argument_list|(
literal|0xa011
argument_list|,
operator|&
name|intel_pineview_info
argument_list|)
block|,
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0042
argument_list|,
operator|&
name|intel_ironlake_d_info
argument_list|)
block|,
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0046
argument_list|,
operator|&
name|intel_ironlake_m_info
argument_list|)
block|,
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0102
argument_list|,
operator|&
name|intel_sandybridge_d_info
argument_list|)
block|,
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0112
argument_list|,
operator|&
name|intel_sandybridge_d_info
argument_list|)
block|,
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0122
argument_list|,
operator|&
name|intel_sandybridge_d_info
argument_list|)
block|,
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0106
argument_list|,
operator|&
name|intel_sandybridge_m_info
argument_list|)
block|,
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0116
argument_list|,
operator|&
name|intel_sandybridge_m_info
argument_list|)
block|,
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0126
argument_list|,
operator|&
name|intel_sandybridge_m_info
argument_list|)
block|,
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x010A
argument_list|,
operator|&
name|intel_sandybridge_d_info
argument_list|)
block|,
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0156
argument_list|,
operator|&
name|intel_ivybridge_m_info
argument_list|)
block|,
comment|/* GT1 mobile */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0166
argument_list|,
operator|&
name|intel_ivybridge_m_info
argument_list|)
block|,
comment|/* GT2 mobile */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0152
argument_list|,
operator|&
name|intel_ivybridge_d_info
argument_list|)
block|,
comment|/* GT1 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0162
argument_list|,
operator|&
name|intel_ivybridge_d_info
argument_list|)
block|,
comment|/* GT2 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x015a
argument_list|,
operator|&
name|intel_ivybridge_d_info
argument_list|)
block|,
comment|/* GT1 server */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x016a
argument_list|,
operator|&
name|intel_ivybridge_d_info
argument_list|)
block|,
comment|/* GT2 server */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0402
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* GT1 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0412
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* GT2 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x041e
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* GT2 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0422
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* GT2 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x040a
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* GT1 server */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x041a
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* GT2 server */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x042a
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* GT2 server */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0406
argument_list|,
operator|&
name|intel_haswell_m_info
argument_list|)
block|,
comment|/* GT1 mobile */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0416
argument_list|,
operator|&
name|intel_haswell_m_info
argument_list|)
block|,
comment|/* GT2 mobile */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0426
argument_list|,
operator|&
name|intel_haswell_m_info
argument_list|)
block|,
comment|/* GT2 mobile */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0C02
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* SDV GT1 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0C12
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* SDV GT2 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0C22
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* SDV GT2 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0C0A
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* SDV GT1 server */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0C1A
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* SDV GT2 server */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0C2A
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* SDV GT2 server */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0C06
argument_list|,
operator|&
name|intel_haswell_m_info
argument_list|)
block|,
comment|/* SDV GT1 mobile */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0C16
argument_list|,
operator|&
name|intel_haswell_m_info
argument_list|)
block|,
comment|/* SDV GT2 mobile */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0C26
argument_list|,
operator|&
name|intel_haswell_m_info
argument_list|)
block|,
comment|/* SDV GT2 mobile */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0A02
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* ULT GT1 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0A12
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* ULT GT2 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0A22
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* ULT GT2 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0A0A
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* ULT GT1 server */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0A1A
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* ULT GT2 server */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0A2A
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* ULT GT2 server */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0A06
argument_list|,
operator|&
name|intel_haswell_m_info
argument_list|)
block|,
comment|/* ULT GT1 mobile */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0A16
argument_list|,
operator|&
name|intel_haswell_m_info
argument_list|)
block|,
comment|/* ULT GT2 mobile */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0A26
argument_list|,
operator|&
name|intel_haswell_m_info
argument_list|)
block|,
comment|/* ULT GT2 mobile */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0D02
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* CRW GT1 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0D12
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* CRW GT2 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0D22
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* CRW GT2 desktop */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0D0A
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* CRW GT1 server */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0D1A
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* CRW GT2 server */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0D2A
argument_list|,
operator|&
name|intel_haswell_d_info
argument_list|)
block|,
comment|/* CRW GT2 server */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0D06
argument_list|,
operator|&
name|intel_haswell_m_info
argument_list|)
block|,
comment|/* CRW GT1 mobile */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0D16
argument_list|,
operator|&
name|intel_haswell_m_info
argument_list|)
block|,
comment|/* CRW GT2 mobile */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0D26
argument_list|,
operator|&
name|intel_haswell_m_info
argument_list|)
block|,
comment|/* CRW GT2 mobile */
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0f30
argument_list|,
operator|&
name|intel_valleyview_m_info
argument_list|)
block|,
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0157
argument_list|,
operator|&
name|intel_valleyview_m_info
argument_list|)
block|,
name|INTEL_VGA_DEVICE
argument_list|(
literal|0x0155
argument_list|,
operator|&
name|intel_valleyview_d_info
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DRM_I915_KMS
argument_list|)
end_if

begin_expr_stmt
name|MODULE_DEVICE_TABLE
argument_list|(
name|pci
argument_list|,
name|pciidlist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|intel_detect_pch
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|device_t
name|pch
decl_stmt|;
comment|/* 	 * The reason to probe ISA bridge instead of Dev31:Fun0 is to 	 * make graphics device passthrough work easy for VMM, that only 	 * need to expose ISA bridge to let driver know the real hardware 	 * underneath. This is a requirement from virtualization team. 	 */
name|pch
operator|=
name|pci_find_class
argument_list|(
name|PCIC_BRIDGE
argument_list|,
name|PCIS_BRIDGE_ISA
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch
condition|)
block|{
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|pch
argument_list|)
operator|==
name|PCI_VENDOR_ID_INTEL
condition|)
block|{
name|unsigned
name|short
name|id
decl_stmt|;
name|id
operator|=
name|pci_get_device
argument_list|(
name|pch
argument_list|)
operator|&
name|INTEL_PCH_DEVICE_ID_MASK
expr_stmt|;
name|dev_priv
operator|->
name|pch_id
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|INTEL_PCH_IBX_DEVICE_ID_TYPE
condition|)
block|{
name|dev_priv
operator|->
name|pch_type
operator|=
name|PCH_IBX
expr_stmt|;
name|dev_priv
operator|->
name|num_pch_pll
operator|=
literal|2
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Found Ibex Peak PCH\n"
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
operator|!
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|INTEL_PCH_CPT_DEVICE_ID_TYPE
condition|)
block|{
name|dev_priv
operator|->
name|pch_type
operator|=
name|PCH_CPT
expr_stmt|;
name|dev_priv
operator|->
name|num_pch_pll
operator|=
literal|2
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Found CougarPoint PCH\n"
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
operator|!
operator|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|INTEL_PCH_PPT_DEVICE_ID_TYPE
condition|)
block|{
comment|/* PantherPoint is CPT compatible */
name|dev_priv
operator|->
name|pch_type
operator|=
name|PCH_CPT
expr_stmt|;
name|dev_priv
operator|->
name|num_pch_pll
operator|=
literal|2
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Found PatherPoint PCH\n"
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
operator|!
operator|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|INTEL_PCH_LPT_DEVICE_ID_TYPE
condition|)
block|{
name|dev_priv
operator|->
name|pch_type
operator|=
name|PCH_LPT
expr_stmt|;
name|dev_priv
operator|->
name|num_pch_pll
operator|=
literal|0
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Found LynxPoint PCH\n"
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
operator|!
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|INTEL_PCH_LPT_LP_DEVICE_ID_TYPE
condition|)
block|{
name|dev_priv
operator|->
name|pch_type
operator|=
name|PCH_LPT
expr_stmt|;
name|dev_priv
operator|->
name|num_pch_pll
operator|=
literal|0
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Found LynxPoint LP PCH\n"
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
operator|!
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BUG_ON
argument_list|(
name|dev_priv
operator|->
name|num_pch_pll
operator|>
name|I915_NUM_PLLS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|bool
name|i915_semaphore_is_enabled
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|6
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|i915_semaphores
operator|>=
literal|0
condition|)
return|return
name|i915_semaphores
return|;
ifdef|#
directive|ifdef
name|CONFIG_INTEL_IOMMU
comment|/* Enable semaphores on SNB when IO remapping is off */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|==
literal|6
operator|&&
name|intel_iommu_gfx_mapped
condition|)
return|return
name|false
return|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_drm_freeze
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_kms_helper_poll_disable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|pci_save_state
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If KMS is active, we do the leavevt stuff here */
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
block|{
name|int
name|error
init|=
name|i915_gem_idle
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dev_err
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
literal|"GEM idle failed, resume might fail\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|taskqueue_cancel_timeout
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|delayed_resume_work
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|intel_modeset_disable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|drm_irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|i915_save_state
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_opregion_fini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Modeset on resume, not lid events */
name|dev_priv
operator|->
name|modeset_on_lid
operator|=
literal|0
expr_stmt|;
name|console_lock
argument_list|()
expr_stmt|;
name|intel_fbdev_set_suspend
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|console_unlock
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_suspend
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|pm_message_t
name|state
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|||
operator|!
name|dev
operator|->
name|dev_private
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"dev: %p\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"DRM not initialized, aborting suspend.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
if|if
condition|(
name|state
operator|.
name|event
operator|==
name|PM_EVENT_PRETHAW
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dev
operator|->
name|switch_power_state
operator|==
name|DRM_SWITCH_POWER_OFF
condition|)
return|return
literal|0
return|;
name|error
operator|=
name|i915_drm_freeze
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|state
operator|.
name|event
operator|==
name|PM_EVENT_SUSPEND
condition|)
block|{
ifdef|#
directive|ifdef
name|__linux__
comment|/* Shut down the device */
name|pci_disable_device
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
expr_stmt|;
name|pci_set_power_state
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|PCI_D3hot
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|intel_console_resume
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|arg
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|dev_priv
operator|->
name|dev
decl_stmt|;
name|console_lock
argument_list|()
expr_stmt|;
name|intel_fbdev_set_suspend
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|console_unlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|__i915_drm_thaw
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|i915_restore_state
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_opregion_setup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* KMS EnterVT equivalent */
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
block|{
name|intel_init_pch_refclk
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|i915_gem_init_hw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_modeset_init_hw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_modeset_setup_hw_state
argument_list|(
name|dev
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|drm_irq_install
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|intel_opregion_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|modeset_on_lid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The console lock can be pretty contented on resume due 	 * to all the printk activity.  Try to keep it out of the hot 	 * path of resume if possible. 	 */
if|if
condition|(
name|console_trylock
argument_list|()
condition|)
block|{
name|intel_fbdev_set_suspend
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|console_unlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|taskqueue_enqueue
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|console_resume_work
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_function
specifier|static
name|int
name|i915_drm_thaw
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|intel_gt_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
block|{
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_restore_gtt_mappings
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|__i915_drm_thaw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|i915_resume
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|switch_power_state
operator|==
name|DRM_SWITCH_POWER_OFF
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|__linux__
if|if
condition|(
name|pci_enable_device
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
name|pci_set_master
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|intel_gt_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Platforms with opregion should have sane BIOS, older ones (gen3 and 	 * earlier) need this since the BIOS might clear all our scratch PTEs. 	 */
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
operator|&&
operator|!
name|dev_priv
operator|->
name|opregion
operator|.
name|header
condition|)
block|{
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_restore_gtt_mappings
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|__i915_drm_thaw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|drm_kms_helper_poll_enable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i8xx_do_reset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|onems
decl_stmt|;
if|if
condition|(
name|IS_I85X
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
name|onems
operator|=
name|hz
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|onems
operator|==
literal|0
condition|)
name|onems
operator|=
literal|1
expr_stmt|;
name|I915_WRITE
argument_list|(
name|D_STATE
argument_list|,
name|I915_READ
argument_list|(
name|D_STATE
argument_list|)
operator||
name|DSTATE_GFX_RESET_I830
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|D_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_I830
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_845G
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|DEBUG_RESET_I830
argument_list|,
name|DEBUG_RESET_DISPLAY
operator||
name|DEBUG_RESET_RENDER
operator||
name|DEBUG_RESET_FULL
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DEBUG_RESET_I830
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"i8xxrst1"
argument_list|,
name|onems
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEBUG_RESET_I830
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DEBUG_RESET_I830
argument_list|)
expr_stmt|;
block|}
name|pause
argument_list|(
literal|"i8xxrst2"
argument_list|,
name|onems
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|D_STATE
argument_list|,
name|I915_READ
argument_list|(
name|D_STATE
argument_list|)
operator|&
operator|~
name|DSTATE_GFX_RESET_I830
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|D_STATE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i965_reset_complete
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|u8
name|gdrst
decl_stmt|;
name|pci_read_config_byte
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|I965_GDRST
argument_list|,
operator|&
name|gdrst
argument_list|)
expr_stmt|;
return|return
operator|(
name|gdrst
operator|&
name|GRDOM_RESET_ENABLE
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i965_do_reset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u8
name|gdrst
decl_stmt|;
comment|/* 	 * Set the domains we want to reset (GRDOM/bits 2 and 3) as 	 * well as the reset bit (GR/bit 0).  Setting the GR bit 	 * triggers the reset; when done, the hardware will clear it. 	 */
name|pci_read_config_byte
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|I965_GDRST
argument_list|,
operator|&
name|gdrst
argument_list|)
expr_stmt|;
name|pci_write_config_byte
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|I965_GDRST
argument_list|,
name|gdrst
operator||
name|GRDOM_RENDER
operator||
name|GRDOM_RESET_ENABLE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|wait_for
argument_list|(
name|i965_reset_complete
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|500
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* We can't reset render&media without also resetting display ... */
name|pci_read_config_byte
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|I965_GDRST
argument_list|,
operator|&
name|gdrst
argument_list|)
expr_stmt|;
name|pci_write_config_byte
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|I965_GDRST
argument_list|,
name|gdrst
operator||
name|GRDOM_MEDIA
operator||
name|GRDOM_RESET_ENABLE
argument_list|)
expr_stmt|;
return|return
name|wait_for
argument_list|(
name|i965_reset_complete
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|500
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ironlake_do_reset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|gdrst
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|gdrst
operator|=
name|I915_READ
argument_list|(
name|MCHBAR_MIRROR_BASE
operator|+
name|ILK_GDSR
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|MCHBAR_MIRROR_BASE
operator|+
name|ILK_GDSR
argument_list|,
name|gdrst
operator||
name|GRDOM_RENDER
operator||
name|GRDOM_RESET_ENABLE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|wait_for
argument_list|(
name|I915_READ
argument_list|(
name|MCHBAR_MIRROR_BASE
operator|+
name|ILK_GDSR
argument_list|)
operator|&
literal|0x1
argument_list|,
literal|500
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* We can't reset render&media without also resetting display ... */
name|gdrst
operator|=
name|I915_READ
argument_list|(
name|MCHBAR_MIRROR_BASE
operator|+
name|ILK_GDSR
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|MCHBAR_MIRROR_BASE
operator|+
name|ILK_GDSR
argument_list|,
name|gdrst
operator||
name|GRDOM_MEDIA
operator||
name|GRDOM_RESET_ENABLE
argument_list|)
expr_stmt|;
return|return
name|wait_for
argument_list|(
name|I915_READ
argument_list|(
name|MCHBAR_MIRROR_BASE
operator|+
name|ILK_GDSR
argument_list|)
operator|&
literal|0x1
argument_list|,
literal|500
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gen6_do_reset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Hold gt_lock across reset to prevent any register access 	 * with forcewake not set correctly 	 */
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|gt_lock
argument_list|)
expr_stmt|;
comment|/* Reset the chip */
comment|/* GEN6_GDRST is not in the gt power well, no need to check 	 * for fifo space for the write or forcewake the chip for 	 * the read 	 */
name|I915_WRITE_NOTRACE
argument_list|(
name|GEN6_GDRST
argument_list|,
name|GEN6_GRDOM_FULL
argument_list|)
expr_stmt|;
comment|/* Spin waiting for the device to ack the reset request */
comment|/* 	 * NOTE Linux<->FreeBSD: We use _intel_wait_for() instead of 	 * wait_for(), because we want to set the 4th argument to 0. 	 * This allows us to use a struct mtx for dev_priv->gt_lock and 	 * avoid a LOR. 	 */
name|ret
operator|=
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
operator|(
name|I915_READ_NOTRACE
argument_list|(
name|GEN6_GDRST
argument_list|)
operator|&
name|GEN6_GRDOM_FULL
operator|)
operator|==
literal|0
argument_list|,
literal|500
argument_list|,
literal|0
argument_list|,
literal|"915rst"
argument_list|)
expr_stmt|;
comment|/* If reset with a user forcewake, try to restore, otherwise turn it off */
if|if
condition|(
name|dev_priv
operator|->
name|forcewake_count
condition|)
name|dev_priv
operator|->
name|gt
operator|.
name|force_wake_get
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
else|else
name|dev_priv
operator|->
name|gt
operator|.
name|force_wake_put
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* Restore fifo count */
name|dev_priv
operator|->
name|gt_fifo_count
operator|=
name|I915_READ_NOTRACE
argument_list|(
name|GT_FIFO_FREE_ENTRIES
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|gt_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|intel_gpu_reset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
init|=
operator|-
name|ENODEV
decl_stmt|;
switch|switch
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
condition|)
block|{
case|case
literal|7
case|:
case|case
literal|6
case|:
name|ret
operator|=
name|gen6_do_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|ret
operator|=
name|ironlake_do_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ret
operator|=
name|i965_do_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ret
operator|=
name|i8xx_do_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Also reset the gpu hangman. */
if|if
condition|(
name|dev_priv
operator|->
name|stop_rings
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Simulated gpu hang, resetting stop_rings\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|stop_rings
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|ENODEV
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Reset not implemented, but ignoring "
literal|"error for simulated gpu hangs\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * i915_reset - reset chip after a hang  * @dev: drm device to reset  *  * Reset the chip.  Useful if a hang is detected. Returns zero on successful  * reset or otherwise an error code.  *  * Procedure is fairly simple:  *   - reset the chip using the reset reg  *   - re-init context state  *   - re-init hardware status page  *   - re-init ring buffer  *   - re-init interrupt state  *   - re-init display  */
end_comment

begin_function
name|int
name|i915_reset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|i915_try_reset
condition|)
return|return
literal|0
return|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ENODEV
expr_stmt|;
if|if
condition|(
name|get_seconds
argument_list|()
operator|-
name|dev_priv
operator|->
name|last_gpu_reset
operator|<
literal|5
condition|)
name|DRM_ERROR
argument_list|(
literal|"GPU hanging too fast, declaring wedged!\n"
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|intel_gpu_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|last_gpu_reset
operator|=
name|get_seconds
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed to reset chip.\n"
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* Ok, now get things going again... */
comment|/* 	 * Everything depends on having the GTT running, so we need to start 	 * there.  Fortunately we don't need to do this unless we reset the 	 * chip at a PCI level. 	 * 	 * Next we need to restore the context, but we don't use those 	 * yet either... 	 * 	 * Ring buffer needs to be re-initialized in the KMS case, or if X 	 * was running at the time of the reset (i.e. we weren't VT 	 * switched away). 	 */
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
operator|||
operator|!
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
condition|)
block|{
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
operator|=
literal|0
expr_stmt|;
name|i915_gem_init_swizzling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
name|ring
operator|->
name|init
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|i915_gem_context_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_init_ppgtt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 		 * It would make sense to re-init all the other hw state, at 		 * least the rps/rc6/emon init done within modeset_init_hw. For 		 * some unknown reason, this blows up my ilk, so don't. 		 */
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|drm_irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|drm_irq_install
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|intel_device_info
modifier|*
name|i915_get_device_id
parameter_list|(
name|int
name|device
parameter_list|)
block|{
specifier|const
name|struct
name|intel_gfx_device_id
modifier|*
name|did
decl_stmt|;
for|for
control|(
name|did
operator|=
operator|&
name|i915_infolist
index|[
literal|0
index|]
init|;
name|did
operator|->
name|device
operator|!=
literal|0
condition|;
name|did
operator|++
control|)
block|{
if|if
condition|(
name|did
operator|->
name|device
operator|!=
name|device
condition|)
continue|continue;
return|return
operator|(
name|did
operator|->
name|info
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_probe
parameter_list|(
name|device_t
name|kdev
parameter_list|)
block|{
specifier|const
name|struct
name|intel_device_info
modifier|*
name|intel_info
init|=
name|i915_get_device_id
argument_list|(
name|pci_get_device
argument_list|(
name|kdev
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|intel_info
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|intel_info
operator|->
name|is_valleyview
condition|)
if|if
condition|(
operator|!
name|i915_preliminary_hw_support
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Preliminary hardware support disabled\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Only bind to function 0 of the device. Early generations 	 * used function 1 as a placeholder for multi-head. This causes 	 * us confusion instead, especially on the systems where both 	 * functions have the same PCI-ID! 	 */
if|if
condition|(
name|pci_get_function
argument_list|(
name|kdev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* We've managed to ship a kms-enabled ddx that shipped with an XvMC 	 * implementation for gen3 (and only gen3) that used legacy drm maps 	 * (gasp!) to share buffers between X and the client. Hence we need to 	 * keep around the fake agp stuff for gen3, even when kms is enabled. */
if|if
condition|(
name|intel_info
operator|->
name|gen
operator|!=
literal|3
condition|)
block|{
name|driver
operator|.
name|driver_features
operator|&=
operator|~
operator|(
name|DRIVER_USE_AGP
operator||
name|DRIVER_REQUIRE_AGP
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|intel_agp_enabled
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"drm/i915 can't work without intel_agp module!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|-
name|drm_probe_helper
argument_list|(
name|kdev
argument_list|,
name|pciidlist
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_function
specifier|static
name|void
name|i915_pci_remove
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|drm_put_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_pm_suspend
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|pci_dev
modifier|*
name|pdev
init|=
name|to_pci_dev
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|drm_dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|drm_dev
operator|||
operator|!
name|drm_dev
operator|->
name|dev_private
condition|)
block|{
name|dev_err
argument_list|(
name|dev
argument_list|,
literal|"DRM not initialized, aborting suspend.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
if|if
condition|(
name|drm_dev
operator|->
name|switch_power_state
operator|==
name|DRM_SWITCH_POWER_OFF
condition|)
return|return
literal|0
return|;
name|error
operator|=
name|i915_drm_freeze
argument_list|(
name|drm_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_set_power_state
argument_list|(
name|pdev
argument_list|,
name|PCI_D3hot
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_pm_resume
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|pci_dev
modifier|*
name|pdev
init|=
name|to_pci_dev
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|drm_dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
return|return
name|i915_resume
argument_list|(
name|drm_dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_pm_freeze
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|pci_dev
modifier|*
name|pdev
init|=
name|to_pci_dev
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|drm_dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|drm_dev
operator|||
operator|!
name|drm_dev
operator|->
name|dev_private
condition|)
block|{
name|dev_err
argument_list|(
name|dev
argument_list|,
literal|"DRM not initialized, aborting suspend.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
return|return
name|i915_drm_freeze
argument_list|(
name|drm_dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_pm_thaw
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|pci_dev
modifier|*
name|pdev
init|=
name|to_pci_dev
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|drm_dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
return|return
name|i915_drm_thaw
argument_list|(
name|drm_dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_pm_poweroff
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|pci_dev
modifier|*
name|pdev
init|=
name|to_pci_dev
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|drm_dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
return|return
name|i915_drm_freeze
argument_list|(
name|drm_dev
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|dev_pm_ops
name|i915_pm_ops
init|=
block|{
operator|.
name|suspend
operator|=
name|i915_pm_suspend
block|,
operator|.
name|resume
operator|=
name|i915_pm_resume
block|,
operator|.
name|freeze
operator|=
name|i915_pm_freeze
block|,
operator|.
name|thaw
operator|=
name|i915_pm_thaw
block|,
operator|.
name|poweroff
operator|=
name|i915_pm_poweroff
block|,
operator|.
name|restore
operator|=
name|i915_pm_resume
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|vm_operations_struct
name|i915_gem_vm_ops
init|=
block|{
operator|.
name|fault
operator|=
name|i915_gem_fault
block|,
operator|.
name|open
operator|=
name|drm_gem_vm_open
block|,
operator|.
name|close
operator|=
name|drm_gem_vm_close
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|file_operations
name|i915_driver_fops
init|=
block|{
operator|.
name|owner
operator|=
name|THIS_MODULE
block|,
operator|.
name|open
operator|=
name|drm_open
block|,
operator|.
name|release
operator|=
name|drm_release
block|,
operator|.
name|unlocked_ioctl
operator|=
name|drm_ioctl
block|,
operator|.
name|mmap
operator|=
name|drm_gem_mmap
block|,
operator|.
name|poll
operator|=
name|drm_poll
block|,
operator|.
name|fasync
operator|=
name|drm_fasync
block|,
operator|.
name|read
operator|=
name|drm_read
block|,
ifdef|#
directive|ifdef
name|CONFIG_COMPAT
operator|.
name|compat_ioctl
operator|=
name|i915_compat_ioctl
block|,
endif|#
directive|endif
operator|.
name|llseek
operator|=
name|noop_llseek
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __linux__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|drm_ioctl_desc
name|i915_compat_ioctls
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|i915_compat_ioctls_nr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|drm_driver
name|driver
init|=
block|{
comment|/* Don't use MTRRs here; the Xserver or userspace app should 	 * deal with them for Intel hardware. 	 */
operator|.
name|driver_features
operator|=
name|DRIVER_USE_AGP
operator||
name|DRIVER_REQUIRE_AGP
operator||
comment|/* DRIVER_USE_MTRR |*/
name|DRIVER_HAVE_IRQ
operator||
name|DRIVER_IRQ_SHARED
operator||
name|DRIVER_GEM
operator||
name|DRIVER_PRIME
block|,
operator|.
name|load
operator|=
name|i915_driver_load
block|,
operator|.
name|unload
operator|=
name|i915_driver_unload
block|,
operator|.
name|open
operator|=
name|i915_driver_open
block|,
operator|.
name|lastclose
operator|=
name|i915_driver_lastclose
block|,
operator|.
name|preclose
operator|=
name|i915_driver_preclose
block|,
operator|.
name|postclose
operator|=
name|i915_driver_postclose
block|,
comment|/* Used in place of i915_pm_ops for non-DRIVER_MODESET */
operator|.
name|suspend
operator|=
name|i915_suspend
block|,
operator|.
name|resume
operator|=
name|i915_resume
block|,
operator|.
name|device_is_agp
operator|=
name|i915_driver_device_is_agp
block|,
operator|.
name|master_create
operator|=
name|i915_master_create
block|,
operator|.
name|master_destroy
operator|=
name|i915_master_destroy
block|,
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DEBUG_FS
argument_list|)
operator|.
name|debugfs_init
operator|=
name|i915_debugfs_init
block|,
operator|.
name|debugfs_cleanup
operator|=
name|i915_debugfs_cleanup
block|,
endif|#
directive|endif
operator|.
name|gem_init_object
operator|=
name|i915_gem_init_object
block|,
operator|.
name|gem_free_object
operator|=
name|i915_gem_free_object
block|,
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|.
name|gem_vm_ops
operator|=
operator|&
name|i915_gem_vm_ops
block|,
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|.
name|gem_pager_ops
operator|=
operator|&
name|i915_gem_pager_ops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FREEBSD_WIP
operator|.
name|prime_handle_to_fd
operator|=
name|drm_gem_prime_handle_to_fd
block|,
operator|.
name|prime_fd_to_handle
operator|=
name|drm_gem_prime_fd_to_handle
block|,
operator|.
name|gem_prime_export
operator|=
name|i915_gem_prime_export
block|,
operator|.
name|gem_prime_import
operator|=
name|i915_gem_prime_import
block|,
endif|#
directive|endif
comment|/* FREEBSD_WIP */
operator|.
name|dumb_create
operator|=
name|i915_gem_dumb_create
block|,
operator|.
name|dumb_map_offset
operator|=
name|i915_gem_mmap_gtt
block|,
operator|.
name|dumb_destroy
operator|=
name|i915_gem_dumb_destroy
block|,
operator|.
name|ioctls
operator|=
name|i915_ioctls
block|,
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
operator|.
name|compat_ioctls
operator|=
name|i915_compat_ioctls
block|,
operator|.
name|num_compat_ioctls
operator|=
operator|&
name|i915_compat_ioctls_nr
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__linux__
operator|.
name|fops
operator|=
operator|&
name|i915_driver_fops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__FreeBSD__
operator|.
name|sysctl_init
operator|=
name|i915_sysctl_init
block|,
operator|.
name|sysctl_cleanup
operator|=
name|i915_sysctl_cleanup
block|,
endif|#
directive|endif
operator|.
name|name
operator|=
name|DRIVER_NAME
block|,
operator|.
name|desc
operator|=
name|DRIVER_DESC
block|,
operator|.
name|date
operator|=
name|DRIVER_DATE
block|,
operator|.
name|major
operator|=
name|DRIVER_MAJOR
block|,
operator|.
name|minor
operator|=
name|DRIVER_MINOR
block|,
operator|.
name|patchlevel
operator|=
name|DRIVER_PATCHLEVEL
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|pci_driver
name|i915_pci_driver
init|=
block|{
operator|.
name|name
operator|=
name|DRIVER_NAME
block|,
operator|.
name|id_table
operator|=
name|pciidlist
block|,
operator|.
name|probe
operator|=
name|i915_pci_probe
block|,
operator|.
name|remove
operator|=
name|i915_pci_remove
block|,
operator|.
name|driver
operator|.
name|pm
operator|=
operator|&
name|i915_pm_ops
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|__init
name|i915_attach
parameter_list|(
name|device_t
name|kdev
parameter_list|)
block|{
name|driver
operator|.
name|num_ioctls
operator|=
name|i915_max_ioctl
expr_stmt|;
comment|/* 	 * If CONFIG_DRM_I915_KMS is set, default to KMS unless 	 * explicitly disabled with the module pararmeter. 	 * 	 * Otherwise, just follow the parameter (defaulting to off). 	 * 	 * Allow optional vga_text_mode_force boot option to override 	 * the default behavior. 	 */
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DRM_I915_KMS
argument_list|)
if|if
condition|(
name|i915_modeset
operator|!=
literal|0
condition|)
name|driver
operator|.
name|driver_features
operator||=
name|DRIVER_MODESET
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i915_modeset
operator|==
literal|1
condition|)
name|driver
operator|.
name|driver_features
operator||=
name|DRIVER_MODESET
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_VGA_CONSOLE
if|if
condition|(
name|vgacon_text_force
argument_list|()
operator|&&
name|i915_modeset
operator|==
operator|-
literal|1
condition|)
name|driver
operator|.
name|driver_features
operator|&=
operator|~
name|DRIVER_MODESET
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|driver
operator|.
name|driver_features
operator|&
name|DRIVER_MODESET
operator|)
condition|)
name|driver
operator|.
name|get_vblank_timestamp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
name|drm_attach_helper
argument_list|(
name|kdev
argument_list|,
name|pciidlist
argument_list|,
operator|&
name|driver
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|fb_info
modifier|*
name|i915_fb_helper_getinfo
parameter_list|(
name|device_t
name|kdev
parameter_list|)
block|{
name|struct
name|intel_fbdev
modifier|*
name|ifbdev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|fb_info
modifier|*
name|info
decl_stmt|;
name|dev
operator|=
name|device_get_softc
argument_list|(
name|kdev
argument_list|)
expr_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|ifbdev
operator|=
name|dev_priv
operator|->
name|fbdev
expr_stmt|;
if|if
condition|(
name|ifbdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|info
operator|=
name|ifbdev
operator|->
name|helper
operator|.
name|fbdev
expr_stmt|;
return|return
operator|(
name|info
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|i915_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|i915_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|i915_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|drm_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|drm_generic_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|drm_generic_detach
argument_list|)
block|,
comment|/* Framebuffer service methods */
name|DEVMETHOD
argument_list|(
name|fb_getinfo
argument_list|,
name|i915_fb_helper_getinfo
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|i915_driver
init|=
block|{
literal|"drmn"
block|,
name|i915_methods
block|,
expr|sizeof
operator|(
expr|struct
name|drm_device
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
name|DRIVER_AUTHOR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
name|DRIVER_DESC
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"GPL and additional rights"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|devclass_t
name|drm_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE_ORDERED
argument_list|(
name|i915kms
argument_list|,
name|vgapci
argument_list|,
name|i915_driver
argument_list|,
name|drm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|i915kms
argument_list|,
name|drmn
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|i915kms
argument_list|,
name|agp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|i915kms
argument_list|,
name|iicbus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|i915kms
argument_list|,
name|iic
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|i915kms
argument_list|,
name|iicbb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PNP_INFO
argument_list|(
literal|"U32:vendor;U32:device;P;D:human"
argument_list|,
name|vgapci
argument_list|,
name|i915
argument_list|,
name|pciidlist
argument_list|,
sizeof|sizeof
argument_list|(
name|pciidlist
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|nitems
argument_list|(
name|pciidlist
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* We give fast paths for the really cool registers */
end_comment

begin_define
define|#
directive|define
name|NEEDS_FORCE_WAKE
parameter_list|(
name|dev_priv
parameter_list|,
name|reg
parameter_list|)
define|\
value|((HAS_FORCE_WAKE((dev_priv)->dev))&& \ 	 ((reg)< 0x40000)&&            \ 	 ((reg) != FORCEWAKE))
end_define

begin_function
specifier|static
name|bool
name|IS_DISPLAYREG
parameter_list|(
name|u32
name|reg
parameter_list|)
block|{
comment|/* 	 * This should make it easier to transition modules over to the 	 * new register block scheme, since we can do it incrementally. 	 */
if|if
condition|(
name|reg
operator|>=
name|VLV_DISPLAY_BASE
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|>=
name|RENDER_RING_BASE
operator|&&
name|reg
operator|<
name|RENDER_RING_BASE
operator|+
literal|0xff
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|>=
name|GEN6_BSD_RING_BASE
operator|&&
name|reg
operator|<
name|GEN6_BSD_RING_BASE
operator|+
literal|0xff
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|>=
name|BLT_RING_BASE
operator|&&
name|reg
operator|<
name|BLT_RING_BASE
operator|+
literal|0xff
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|==
name|PGTBL_ER
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|>=
name|IPEIR_I965
operator|&&
name|reg
operator|<
name|HWSTAM
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|==
name|MI_MODE
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|==
name|GFX_MODE_GEN7
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|==
name|RENDER_HWS_PGA_GEN7
operator|||
name|reg
operator|==
name|BSD_HWS_PGA_GEN7
operator|||
name|reg
operator|==
name|BLT_HWS_PGA_GEN7
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|==
name|GEN6_BSD_SLEEP_PSMI_CONTROL
operator|||
name|reg
operator|==
name|GEN6_BSD_RNCID
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|==
name|GEN6_BLITTER_ECOSKPD
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|>=
literal|0x4000c
operator|&&
name|reg
operator|<=
literal|0x4002c
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|>=
literal|0x4f000
operator|&&
name|reg
operator|<=
literal|0x4f08f
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|>=
literal|0x4f100
operator|&&
name|reg
operator|<=
literal|0x4f11f
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|>=
name|VLV_MASTER_IER
operator|&&
name|reg
operator|<=
name|GEN6_PMIER
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|>=
name|FENCE_REG_SANDYBRIDGE_0
operator|&&
name|reg
operator|<
operator|(
name|FENCE_REG_SANDYBRIDGE_0
operator|+
operator|(
literal|16
operator|*
literal|8
operator|)
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|>=
name|VLV_IIR_RW
operator|&&
name|reg
operator|<=
name|VLV_ISR
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|==
name|FORCEWAKE_VLV
operator|||
name|reg
operator|==
name|FORCEWAKE_ACK_VLV
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg
operator|==
name|GEN6_GDRST
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|_3D_CHICKEN3
case|:
case|case
name|IVB_CHICKEN3
case|:
case|case
name|GEN7_COMMON_SLICE_CHICKEN1
case|:
case|case
name|GEN7_L3CNTLREG1
case|:
case|case
name|GEN7_L3_CHICKEN_MODE_REGISTER
case|:
case|case
name|GEN7_ROW_CHICKEN2
case|:
case|case
name|GEN7_L3SQCREG4
case|:
case|case
name|GEN7_SQ_CHICKEN_MBCUNIT_CONFIG
case|:
case|case
name|GEN7_HALF_SLICE_CHICKEN1
case|:
case|case
name|GEN6_MBCTL
case|:
case|case
name|GEN6_UCGCTL2
case|:
return|return
name|false
return|;
default|default:
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ilk_dummy_write
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
comment|/* WaIssueDummyWriteToWakeupFromRC6: Issue a dummy write to wake up the 	 * chip from rc6 before touching it for real. MI_MODE is masked, hence 	 * harmless to write 0 into. */
name|I915_WRITE_NOTRACE
argument_list|(
name|MI_MODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|__i915_read
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \ 	u##x val = 0; \ 	if (IS_GEN5(dev_priv->dev)) \ 		ilk_dummy_write(dev_priv); \ 	if (NEEDS_FORCE_WAKE((dev_priv), (reg))) { \ 		mtx_lock(&dev_priv->gt_lock); \ 		if (dev_priv->forcewake_count == 0) \ 			dev_priv->gt.force_wake_get(dev_priv); \ 		val = DRM_READ##x(dev_priv->mmio_map, reg); \ 		if (dev_priv->forcewake_count == 0) \ 			dev_priv->gt.force_wake_put(dev_priv); \ 		mtx_unlock(&dev_priv->gt_lock); \ 	} else if (IS_VALLEYVIEW(dev_priv->dev)&& IS_DISPLAYREG(reg)) { \ 		val = DRM_READ##x(dev_priv->mmio_map, reg + 0x180000);		\ 	} else { \ 		val = DRM_READ##x(dev_priv->mmio_map, reg); \ 	} \ 	trace_i915_reg_rw(false, reg, val, sizeof(val)); \ 	return val; \ }
end_define

begin_macro
name|__i915_read
argument_list|(
literal|8
argument_list|,
argument|b
argument_list|)
end_macro

begin_macro
name|__i915_read
argument_list|(
literal|16
argument_list|,
argument|w
argument_list|)
end_macro

begin_macro
name|__i915_read
argument_list|(
literal|32
argument_list|,
argument|l
argument_list|)
end_macro

begin_macro
name|__i915_read
argument_list|(
literal|64
argument_list|,
argument|q
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|__i915_read
end_undef

begin_define
define|#
directive|define
name|__i915_write
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|void i915_write##x(struct drm_i915_private *dev_priv, u32 reg, u##x val) { \ 	u32 __fifo_ret = 0; \ 	trace_i915_reg_rw(true, reg, val, sizeof(val)); \ 	if (NEEDS_FORCE_WAKE((dev_priv), (reg))) { \ 		__fifo_ret = __gen6_gt_wait_for_fifo(dev_priv); \ 	} \ 	if (IS_GEN5(dev_priv->dev)) \ 		ilk_dummy_write(dev_priv); \ 	if (IS_HASWELL(dev_priv->dev)&& (I915_READ_NOTRACE(GEN7_ERR_INT)& ERR_INT_MMIO_UNCLAIMED)) { \ 		DRM_ERROR("Unknown unclaimed register before writing to %x\n", reg); \ 		I915_WRITE_NOTRACE(GEN7_ERR_INT, ERR_INT_MMIO_UNCLAIMED); \ 	} \ 	if (IS_VALLEYVIEW(dev_priv->dev)&& IS_DISPLAYREG(reg)) { \ 		DRM_WRITE##x(dev_priv->mmio_map, reg + 0x180000, val);		\ 	} else {							\ 		DRM_WRITE##x(dev_priv->mmio_map, reg, val);			\ 	}								\ 	if (unlikely(__fifo_ret)) { \ 		gen6_gt_check_fifodbg(dev_priv); \ 	} \ 	if (IS_HASWELL(dev_priv->dev)&& (I915_READ_NOTRACE(GEN7_ERR_INT)& ERR_INT_MMIO_UNCLAIMED)) { \ 		DRM_ERROR("Unclaimed write to %x\n", reg); \ 		DRM_WRITE32(dev_priv->mmio_map, GEN7_ERR_INT, ERR_INT_MMIO_UNCLAIMED);	\ 	} \ }
end_define

begin_macro
name|__i915_write
argument_list|(
literal|8
argument_list|,
argument|b
argument_list|)
end_macro

begin_macro
name|__i915_write
argument_list|(
literal|16
argument_list|,
argument|w
argument_list|)
end_macro

begin_macro
name|__i915_write
argument_list|(
literal|32
argument_list|,
argument|l
argument_list|)
end_macro

begin_macro
name|__i915_write
argument_list|(
literal|64
argument_list|,
argument|q
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|__i915_write
end_undef

begin_struct
specifier|static
specifier|const
struct|struct
name|register_whitelist
block|{
name|uint64_t
name|offset
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|uint32_t
name|gen_bitmask
decl_stmt|;
comment|/* support gens, 0x10 for 4, 0x30 for 4 and 5, etc. */
block|}
name|whitelist
index|[]
init|=
block|{
block|{
name|RING_TIMESTAMP
argument_list|(
name|RENDER_RING_BASE
argument_list|)
block|,
literal|8
block|,
literal|0xF0
block|}
block|, }
struct|;
end_struct

begin_function
name|int
name|i915_reg_read_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_reg_read
modifier|*
name|reg
init|=
name|data
decl_stmt|;
name|struct
name|register_whitelist
specifier|const
modifier|*
name|entry
init|=
name|whitelist
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|whitelist
argument_list|)
condition|;
name|i
operator|++
operator|,
name|entry
operator|++
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|offset
operator|==
name|reg
operator|->
name|offset
operator|&&
operator|(
literal|1
operator|<<
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|&
name|entry
operator|->
name|gen_bitmask
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|ARRAY_SIZE
argument_list|(
name|whitelist
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
switch|switch
condition|(
name|entry
operator|->
name|size
condition|)
block|{
case|case
literal|8
case|:
name|reg
operator|->
name|val
operator|=
name|I915_READ64
argument_list|(
name|reg
operator|->
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|reg
operator|->
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
operator|->
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|reg
operator|->
name|val
operator|=
name|I915_READ16
argument_list|(
name|reg
operator|->
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|reg
operator|->
name|val
operator|=
name|I915_READ8
argument_list|(
name|reg
operator|->
name|offset
argument_list|)
expr_stmt|;
break|break;
default|default:
name|WARN_ON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

