begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Â© 2006-2010 Intel Corporation  * Copyright (c) 2006 Dave Airlie<airlied@linux.ie>  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Authors:  *	Eric Anholt<eric@anholt.net>  *      Dave Airlie<airlied@linux.ie>  *      Jesse Barnes<jesse.barnes@intel.com>  *      Chris Wilson<chris@chris-wilson.co.uk>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_define
define|#
directive|define
name|PCI_LBPC
value|0xf4
end_define

begin_comment
comment|/* legacy/combination backlight modes */
end_comment

begin_function
name|void
name|intel_fixed_panel_mode
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|fixed_mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|adjusted_mode
operator|->
name|hdisplay
operator|=
name|fixed_mode
operator|->
name|hdisplay
expr_stmt|;
name|adjusted_mode
operator|->
name|hsync_start
operator|=
name|fixed_mode
operator|->
name|hsync_start
expr_stmt|;
name|adjusted_mode
operator|->
name|hsync_end
operator|=
name|fixed_mode
operator|->
name|hsync_end
expr_stmt|;
name|adjusted_mode
operator|->
name|htotal
operator|=
name|fixed_mode
operator|->
name|htotal
expr_stmt|;
name|adjusted_mode
operator|->
name|vdisplay
operator|=
name|fixed_mode
operator|->
name|vdisplay
expr_stmt|;
name|adjusted_mode
operator|->
name|vsync_start
operator|=
name|fixed_mode
operator|->
name|vsync_start
expr_stmt|;
name|adjusted_mode
operator|->
name|vsync_end
operator|=
name|fixed_mode
operator|->
name|vsync_end
expr_stmt|;
name|adjusted_mode
operator|->
name|vtotal
operator|=
name|fixed_mode
operator|->
name|vtotal
expr_stmt|;
name|adjusted_mode
operator|->
name|clock
operator|=
name|fixed_mode
operator|->
name|clock
expr_stmt|;
block|}
end_function

begin_comment
comment|/* adjusted_mode has been preset to be the panel's fixed mode */
end_comment

begin_function
name|void
name|intel_pch_panel_fitting
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|fitting_mode
parameter_list|,
specifier|const
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
name|x
operator|=
name|y
operator|=
name|width
operator|=
name|height
operator|=
literal|0
expr_stmt|;
comment|/* Native modes don't need fitting */
if|if
condition|(
name|adjusted_mode
operator|->
name|hdisplay
operator|==
name|mode
operator|->
name|hdisplay
operator|&&
name|adjusted_mode
operator|->
name|vdisplay
operator|==
name|mode
operator|->
name|vdisplay
condition|)
goto|goto
name|done
goto|;
switch|switch
condition|(
name|fitting_mode
condition|)
block|{
case|case
name|DRM_MODE_SCALE_CENTER
case|:
name|width
operator|=
name|mode
operator|->
name|hdisplay
expr_stmt|;
name|height
operator|=
name|mode
operator|->
name|vdisplay
expr_stmt|;
name|x
operator|=
operator|(
name|adjusted_mode
operator|->
name|hdisplay
operator|-
name|width
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|y
operator|=
operator|(
name|adjusted_mode
operator|->
name|vdisplay
operator|-
name|height
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
case|case
name|DRM_MODE_SCALE_ASPECT
case|:
comment|/* Scale but preserve the aspect ratio */
block|{
name|u32
name|scaled_width
init|=
name|adjusted_mode
operator|->
name|hdisplay
operator|*
name|mode
operator|->
name|vdisplay
decl_stmt|;
name|u32
name|scaled_height
init|=
name|mode
operator|->
name|hdisplay
operator|*
name|adjusted_mode
operator|->
name|vdisplay
decl_stmt|;
if|if
condition|(
name|scaled_width
operator|>
name|scaled_height
condition|)
block|{
comment|/* pillar */
name|width
operator|=
name|scaled_height
operator|/
name|mode
operator|->
name|vdisplay
expr_stmt|;
if|if
condition|(
name|width
operator|&
literal|1
condition|)
name|width
operator|++
expr_stmt|;
name|x
operator|=
operator|(
name|adjusted_mode
operator|->
name|hdisplay
operator|-
name|width
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|y
operator|=
literal|0
expr_stmt|;
name|height
operator|=
name|adjusted_mode
operator|->
name|vdisplay
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scaled_width
operator|<
name|scaled_height
condition|)
block|{
comment|/* letter */
name|height
operator|=
name|scaled_width
operator|/
name|mode
operator|->
name|hdisplay
expr_stmt|;
if|if
condition|(
name|height
operator|&
literal|1
condition|)
name|height
operator|++
expr_stmt|;
name|y
operator|=
operator|(
name|adjusted_mode
operator|->
name|vdisplay
operator|-
name|height
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
name|width
operator|=
name|adjusted_mode
operator|->
name|hdisplay
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|y
operator|=
literal|0
expr_stmt|;
name|width
operator|=
name|adjusted_mode
operator|->
name|hdisplay
expr_stmt|;
name|height
operator|=
name|adjusted_mode
operator|->
name|vdisplay
expr_stmt|;
block|}
block|}
break|break;
default|default:
case|case
name|DRM_MODE_SCALE_FULLSCREEN
case|:
name|x
operator|=
name|y
operator|=
literal|0
expr_stmt|;
name|width
operator|=
name|adjusted_mode
operator|->
name|hdisplay
expr_stmt|;
name|height
operator|=
name|adjusted_mode
operator|->
name|vdisplay
expr_stmt|;
break|break;
block|}
name|done
label|:
name|dev_priv
operator|->
name|pch_pf_pos
operator|=
operator|(
name|x
operator|<<
literal|16
operator|)
operator||
name|y
expr_stmt|;
name|dev_priv
operator|->
name|pch_pf_size
operator|=
operator|(
name|width
operator|<<
literal|16
operator|)
operator||
name|height
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_backlight_combination_mode
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
condition|)
return|return
name|I915_READ
argument_list|(
name|BLC_PWM_CTL2
argument_list|)
operator|&
name|BLM_COMBINATION_MODE
return|;
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|I915_READ
argument_list|(
name|BLC_PWM_CTL
argument_list|)
operator|&
name|BLM_LEGACY_MODE
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|i915_read_blc_pwm_ctl
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
comment|/* Restore the CTL value if it lost, e.g. GPU reset */
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
block|{
name|val
operator|=
name|I915_READ
argument_list|(
name|BLC_PWM_PCH_CTL2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|saveBLC_PWM_CTL2
operator|==
literal|0
condition|)
block|{
name|dev_priv
operator|->
name|saveBLC_PWM_CTL2
operator|=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|I915_WRITE
argument_list|(
name|BLC_PWM_PCH_CTL2
argument_list|,
name|dev_priv
operator|->
name|saveBLC_PWM_CTL2
argument_list|)
expr_stmt|;
name|val
operator|=
name|dev_priv
operator|->
name|saveBLC_PWM_CTL2
expr_stmt|;
block|}
block|}
else|else
block|{
name|val
operator|=
name|I915_READ
argument_list|(
name|BLC_PWM_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|saveBLC_PWM_CTL
operator|==
literal|0
condition|)
block|{
name|dev_priv
operator|->
name|saveBLC_PWM_CTL
operator|=
name|val
expr_stmt|;
name|dev_priv
operator|->
name|saveBLC_PWM_CTL2
operator|=
name|I915_READ
argument_list|(
name|BLC_PWM_CTL2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|I915_WRITE
argument_list|(
name|BLC_PWM_CTL
argument_list|,
name|dev_priv
operator|->
name|saveBLC_PWM_CTL
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|BLC_PWM_CTL2
argument_list|,
name|dev_priv
operator|->
name|saveBLC_PWM_CTL2
argument_list|)
expr_stmt|;
name|val
operator|=
name|dev_priv
operator|->
name|saveBLC_PWM_CTL
expr_stmt|;
block|}
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
name|u32
name|intel_panel_get_max_backlight
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|max
decl_stmt|;
name|max
operator|=
name|i915_read_blc_pwm_ctl
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|==
literal|0
condition|)
block|{
comment|/* XXX add code here to query mode clock or hardware clock 		 * and program max PWM appropriately. 		 */
if|#
directive|if
literal|0
block|printf("fixme: max PWM is zero.\n");
endif|#
directive|endif
return|return
literal|1
return|;
block|}
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|max
operator|>>=
literal|16
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
condition|)
name|max
operator|>>=
literal|17
expr_stmt|;
else|else
name|max
operator|>>=
literal|16
expr_stmt|;
if|if
condition|(
name|is_backlight_combination_mode
argument_list|(
name|dev
argument_list|)
condition|)
name|max
operator|*=
literal|0xff
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"max backlight PWM = %d\n"
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
name|max
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|intel_panel_compute_brightness
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|i915_panel_invert_brightness
operator|<
literal|0
condition|)
return|return
name|val
return|;
if|if
condition|(
name|i915_panel_invert_brightness
operator|>
literal|0
operator|||
name|dev_priv
operator|->
name|quirks
operator|&
name|QUIRK_INVERT_BRIGHTNESS
condition|)
return|return
name|intel_panel_get_max_backlight
argument_list|(
name|dev
argument_list|)
operator|-
name|val
return|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|u32
name|intel_panel_get_backlight
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|val
decl_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|val
operator|=
name|I915_READ
argument_list|(
name|BLC_PWM_CPU_CTL
argument_list|)
operator|&
name|BACKLIGHT_DUTY_CYCLE_MASK
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|I915_READ
argument_list|(
name|BLC_PWM_CTL
argument_list|)
operator|&
name|BACKLIGHT_DUTY_CYCLE_MASK
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
condition|)
name|val
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|is_backlight_combination_mode
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|u8
name|lbpc
decl_stmt|;
name|lbpc
operator|=
name|pci_read_config
argument_list|(
name|dev
operator|->
name|device
argument_list|,
name|PCI_LBPC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|*=
name|lbpc
expr_stmt|;
block|}
block|}
name|val
operator|=
name|intel_panel_compute_brightness
argument_list|(
name|dev
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"get backlight PWM = %d\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_pch_panel_set_backlight
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|u32
name|level
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|val
init|=
name|I915_READ
argument_list|(
name|BLC_PWM_CPU_CTL
argument_list|)
operator|&
operator|~
name|BACKLIGHT_DUTY_CYCLE_MASK
decl_stmt|;
name|I915_WRITE
argument_list|(
name|BLC_PWM_CPU_CTL
argument_list|,
name|val
operator||
name|level
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_panel_actually_set_backlight
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|u32
name|level
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|tmp
decl_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"set backlight PWM = %d\n"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|level
operator|=
name|intel_panel_compute_brightness
argument_list|(
name|dev
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|intel_pch_panel_set_backlight
argument_list|(
name|dev
argument_list|,
name|level
argument_list|)
return|;
if|if
condition|(
name|is_backlight_combination_mode
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|u32
name|max
init|=
name|intel_panel_get_max_backlight
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u8
name|lbpc
decl_stmt|;
name|lbpc
operator|=
name|level
operator|*
literal|0xfe
operator|/
name|max
operator|+
literal|1
expr_stmt|;
name|level
operator|/=
name|lbpc
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
operator|->
name|device
argument_list|,
name|PCI_LBPC
argument_list|,
name|lbpc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|I915_READ
argument_list|(
name|BLC_PWM_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|4
condition|)
name|level
operator|<<=
literal|1
expr_stmt|;
name|tmp
operator|&=
operator|~
name|BACKLIGHT_DUTY_CYCLE_MASK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|BLC_PWM_CTL
argument_list|,
name|tmp
operator||
name|level
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_panel_set_backlight
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|u32
name|level
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|backlight_level
operator|=
name|level
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|backlight_enabled
condition|)
name|intel_panel_actually_set_backlight
argument_list|(
name|dev
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_panel_disable_backlight
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|backlight_enabled
operator|=
name|false
expr_stmt|;
name|intel_panel_actually_set_backlight
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_panel_enable_backlight
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|backlight_level
operator|==
literal|0
condition|)
name|dev_priv
operator|->
name|backlight_level
operator|=
name|intel_panel_get_max_backlight
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|backlight_enabled
operator|=
name|true
expr_stmt|;
name|intel_panel_actually_set_backlight
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|backlight_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_panel_init_backlight
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|backlight_level
operator|=
name|intel_panel_get_backlight
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|backlight_enabled
operator|=
name|dev_priv
operator|->
name|backlight_level
operator|!=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|drm_connector_status
name|intel_panel_detect
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct drm_i915_private *dev_priv = dev->dev_private;
endif|#
directive|endif
if|if
condition|(
name|i915_panel_ignore_lid
condition|)
return|return
name|i915_panel_ignore_lid
operator|>
literal|0
condition|?
name|connector_status_connected
else|:
name|connector_status_disconnected
return|;
comment|/* opregion lid state on HP 2540p is wrong at boot up, 	 * appears to be either the BIOS or Linux ACPI fault */
if|#
directive|if
literal|0
comment|/* Assume that the BIOS does not lie through the OpRegion... */
block|if (dev_priv->opregion.lid_state) 		return ioread32(dev_priv->opregion.lid_state)& 0x1 ? 			connector_status_connected : 			connector_status_disconnected;
endif|#
directive|endif
return|return
name|connector_status_unknown
return|;
block|}
end_function

begin_function
name|int
name|intel_panel_setup_backlight
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|intel_panel_init_backlight
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|intel_panel_destroy_backlight
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return;
block|}
end_function

end_unit

