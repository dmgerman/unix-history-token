begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Â© 2008 Intel Corporation  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  *  * Authors:  *    Keith Packard<keithp@keithp.com>  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc_helper.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_dp_helper.h>
end_include

begin_define
define|#
directive|define
name|DP_RECEIVER_CAP_SIZE
value|0xf
end_define

begin_define
define|#
directive|define
name|DP_LINK_STATUS_SIZE
value|6
end_define

begin_define
define|#
directive|define
name|DP_LINK_CHECK_TIMEOUT
value|(10 * 1000)
end_define

begin_define
define|#
directive|define
name|DP_LINK_CONFIGURATION_SIZE
value|9
end_define

begin_struct
struct|struct
name|intel_dp
block|{
name|struct
name|intel_encoder
name|base
decl_stmt|;
name|uint32_t
name|output_reg
decl_stmt|;
name|uint32_t
name|DP
decl_stmt|;
name|uint8_t
name|link_configuration
index|[
name|DP_LINK_CONFIGURATION_SIZE
index|]
decl_stmt|;
name|bool
name|has_audio
decl_stmt|;
name|enum
name|hdmi_force_audio
name|force_audio
decl_stmt|;
name|uint32_t
name|color_range
decl_stmt|;
name|int
name|dpms_mode
decl_stmt|;
name|uint8_t
name|link_bw
decl_stmt|;
name|uint8_t
name|lane_count
decl_stmt|;
name|uint8_t
name|dpcd
index|[
name|DP_RECEIVER_CAP_SIZE
index|]
decl_stmt|;
name|device_t
name|dp_iic_bus
decl_stmt|;
name|device_t
name|adapter
decl_stmt|;
name|bool
name|is_pch_edp
decl_stmt|;
name|uint8_t
name|train_set
index|[
literal|4
index|]
decl_stmt|;
name|int
name|panel_power_up_delay
decl_stmt|;
name|int
name|panel_power_down_delay
decl_stmt|;
name|int
name|panel_power_cycle_delay
decl_stmt|;
name|int
name|backlight_on_delay
decl_stmt|;
name|int
name|backlight_off_delay
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|panel_fixed_mode
decl_stmt|;
comment|/* for eDP */
name|struct
name|timeout_task
name|panel_vdd_task
decl_stmt|;
name|bool
name|want_panel_vdd
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * is_edp - is the given port attached to an eDP panel (either CPU or PCH)  * @intel_dp: DP struct  *  * If a CPU or PCH DP output is attached to an eDP panel, this function  * will return true, and false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|is_edp
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
return|return
name|intel_dp
operator|->
name|base
operator|.
name|type
operator|==
name|INTEL_OUTPUT_EDP
return|;
block|}
end_function

begin_comment
comment|/**  * is_pch_edp - is the port on the PCH and attached to an eDP panel?  * @intel_dp: DP struct  *  * Returns true if the given DP struct corresponds to a PCH DP port attached  * to an eDP panel, false otherwise.  Helpful for determining whether we  * may need FDI resources for a given DP output or not.  */
end_comment

begin_function
specifier|static
name|bool
name|is_pch_edp
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
return|return
name|intel_dp
operator|->
name|is_pch_edp
return|;
block|}
end_function

begin_comment
comment|/**  * is_cpu_edp - is the port on the CPU and attached to an eDP panel?  * @intel_dp: DP struct  *  * Returns true if the given DP struct corresponds to a CPU eDP port.  */
end_comment

begin_function
specifier|static
name|bool
name|is_cpu_edp
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
return|return
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
operator|&&
operator|!
name|is_pch_edp
argument_list|(
name|intel_dp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|intel_dp
modifier|*
name|enc_to_intel_dp
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
return|return
name|container_of
argument_list|(
name|encoder
argument_list|,
expr|struct
name|intel_dp
argument_list|,
name|base
operator|.
name|base
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|intel_dp
modifier|*
name|intel_attached_dp
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
return|return
name|container_of
argument_list|(
name|intel_attached_encoder
argument_list|(
name|connector
argument_list|)
argument_list|,
expr|struct
name|intel_dp
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * intel_encoder_is_pch_edp - is the given encoder a PCH attached eDP?  * @encoder: DRM encoder  *  * Return true if @encoder corresponds to a PCH attached eDP panel.  Needed  * by intel_display.c.  */
end_comment

begin_function
name|bool
name|intel_encoder_is_pch_edp
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
decl_stmt|;
if|if
condition|(
operator|!
name|encoder
condition|)
return|return
name|false
return|;
name|intel_dp
operator|=
name|enc_to_intel_dp
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
return|return
name|is_pch_edp
argument_list|(
name|intel_dp
argument_list|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|intel_dp_start_link_train
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_dp_complete_link_train
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_dp_link_down
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|intel_edp_link_config
parameter_list|(
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
parameter_list|,
name|int
modifier|*
name|lane_num
parameter_list|,
name|int
modifier|*
name|link_bw
parameter_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|container_of
argument_list|(
name|intel_encoder
argument_list|,
expr|struct
name|intel_dp
argument_list|,
name|base
argument_list|)
decl_stmt|;
operator|*
name|lane_num
operator|=
name|intel_dp
operator|->
name|lane_count
expr_stmt|;
if|if
condition|(
name|intel_dp
operator|->
name|link_bw
operator|==
name|DP_LINK_BW_1_62
condition|)
operator|*
name|link_bw
operator|=
literal|162000
expr_stmt|;
elseif|else
if|if
condition|(
name|intel_dp
operator|->
name|link_bw
operator|==
name|DP_LINK_BW_2_7
condition|)
operator|*
name|link_bw
operator|=
literal|270000
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_dp_max_lane_count
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|int
name|max_lane_count
init|=
name|intel_dp
operator|->
name|dpcd
index|[
name|DP_MAX_LANE_COUNT
index|]
operator|&
literal|0x1f
decl_stmt|;
switch|switch
condition|(
name|max_lane_count
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
break|break;
default|default:
name|max_lane_count
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|max_lane_count
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_dp_max_link_bw
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|int
name|max_link_bw
init|=
name|intel_dp
operator|->
name|dpcd
index|[
name|DP_MAX_LINK_RATE
index|]
decl_stmt|;
switch|switch
condition|(
name|max_link_bw
condition|)
block|{
case|case
name|DP_LINK_BW_1_62
case|:
case|case
name|DP_LINK_BW_2_7
case|:
break|break;
default|default:
name|max_link_bw
operator|=
name|DP_LINK_BW_1_62
expr_stmt|;
break|break;
block|}
return|return
name|max_link_bw
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_dp_link_clock
parameter_list|(
name|uint8_t
name|link_bw
parameter_list|)
block|{
if|if
condition|(
name|link_bw
operator|==
name|DP_LINK_BW_2_7
condition|)
return|return
literal|270000
return|;
else|else
return|return
literal|162000
return|;
block|}
end_function

begin_comment
comment|/*  * The units on the numbers in the next two are... bizarre.  Examples will  * make it clearer; this one parallels an example in the eDP spec.  *  * intel_dp_max_data_rate for one lane of 2.7GHz evaluates as:  *  *     270000 * 1 * 8 / 10 == 216000  *  * The actual data capacity of that configuration is 2.16Gbit/s, so the  * units are decakilobits.  ->clock in a drm_display_mode is in kilohertz -  * or equivalently, kilopixels per second - so for 1680x1050R it'd be  * 119000.  At 18bpp that's 2142000 kilobits per second.  *  * Thus the strange-looking division by 10 in intel_dp_link_required, to  * get the result in decakilobits instead of kilobits.  */
end_comment

begin_function
specifier|static
name|int
name|intel_dp_link_required
parameter_list|(
name|int
name|pixel_clock
parameter_list|,
name|int
name|bpp
parameter_list|)
block|{
return|return
operator|(
name|pixel_clock
operator|*
name|bpp
operator|+
literal|9
operator|)
operator|/
literal|10
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_dp_max_data_rate
parameter_list|(
name|int
name|max_link_clock
parameter_list|,
name|int
name|max_lanes
parameter_list|)
block|{
return|return
operator|(
name|max_link_clock
operator|*
name|max_lanes
operator|*
literal|8
operator|)
operator|/
literal|10
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_dp_adjust_dithering
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
specifier|const
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|int
name|max_link_clock
init|=
name|intel_dp_link_clock
argument_list|(
name|intel_dp_max_link_bw
argument_list|(
name|intel_dp
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|max_lanes
init|=
name|intel_dp_max_lane_count
argument_list|(
name|intel_dp
argument_list|)
decl_stmt|;
name|int
name|max_rate
decl_stmt|,
name|mode_rate
decl_stmt|;
name|mode_rate
operator|=
name|intel_dp_link_required
argument_list|(
name|mode
operator|->
name|clock
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|max_rate
operator|=
name|intel_dp_max_data_rate
argument_list|(
name|max_link_clock
argument_list|,
name|max_lanes
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_rate
operator|>
name|max_rate
condition|)
block|{
name|mode_rate
operator|=
name|intel_dp_link_required
argument_list|(
name|mode
operator|->
name|clock
argument_list|,
literal|18
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_rate
operator|>
name|max_rate
condition|)
return|return
name|false
return|;
if|if
condition|(
name|adjusted_mode
condition|)
name|adjusted_mode
operator|->
name|private_flags
operator||=
name|INTEL_MODE_DP_FORCE_6BPC
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_dp_mode_valid
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|intel_attached_dp
argument_list|(
name|connector
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
operator|&&
name|intel_dp
operator|->
name|panel_fixed_mode
condition|)
block|{
if|if
condition|(
name|mode
operator|->
name|hdisplay
operator|>
name|intel_dp
operator|->
name|panel_fixed_mode
operator|->
name|hdisplay
condition|)
return|return
name|MODE_PANEL
return|;
if|if
condition|(
name|mode
operator|->
name|vdisplay
operator|>
name|intel_dp
operator|->
name|panel_fixed_mode
operator|->
name|vdisplay
condition|)
return|return
name|MODE_PANEL
return|;
block|}
if|if
condition|(
operator|!
name|intel_dp_adjust_dithering
argument_list|(
name|intel_dp
argument_list|,
name|mode
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|MODE_CLOCK_HIGH
return|;
if|if
condition|(
name|mode
operator|->
name|clock
operator|<
literal|10000
condition|)
return|return
name|MODE_CLOCK_LOW
return|;
return|return
name|MODE_OK
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|pack_aux
parameter_list|(
name|uint8_t
modifier|*
name|src
parameter_list|,
name|int
name|src_bytes
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|v
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|src_bytes
operator|>
literal|4
condition|)
name|src_bytes
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src_bytes
condition|;
name|i
operator|++
control|)
name|v
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|src
index|[
name|i
index|]
operator|)
operator|<<
operator|(
operator|(
literal|3
operator|-
name|i
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unpack_aux
parameter_list|(
name|uint32_t
name|src
parameter_list|,
name|uint8_t
modifier|*
name|dst
parameter_list|,
name|int
name|dst_bytes
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dst_bytes
operator|>
literal|4
condition|)
name|dst_bytes
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dst_bytes
condition|;
name|i
operator|++
control|)
name|dst
index|[
name|i
index|]
operator|=
name|src
operator|>>
operator|(
operator|(
literal|3
operator|-
name|i
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* hrawclock is 1/4 the FSB frequency */
end_comment

begin_function
specifier|static
name|int
name|intel_hrawclk
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|clkcfg
decl_stmt|;
name|clkcfg
operator|=
name|I915_READ
argument_list|(
name|CLKCFG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|clkcfg
operator|&
name|CLKCFG_FSB_MASK
condition|)
block|{
case|case
name|CLKCFG_FSB_400
case|:
return|return
literal|100
return|;
case|case
name|CLKCFG_FSB_533
case|:
return|return
literal|133
return|;
case|case
name|CLKCFG_FSB_667
case|:
return|return
literal|166
return|;
case|case
name|CLKCFG_FSB_800
case|:
return|return
literal|200
return|;
case|case
name|CLKCFG_FSB_1067
case|:
return|return
literal|266
return|;
case|case
name|CLKCFG_FSB_1333
case|:
return|return
literal|333
return|;
comment|/* these two are just a guess; one of them might be right */
case|case
name|CLKCFG_FSB_1600
case|:
case|case
name|CLKCFG_FSB_1600_ALT
case|:
return|return
literal|400
return|;
default|default:
return|return
literal|133
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|ironlake_edp_have_panel_power
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
operator|(
name|I915_READ
argument_list|(
name|PCH_PP_STATUS
argument_list|)
operator|&
name|PP_ON
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ironlake_edp_have_panel_vdd
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
operator|(
name|I915_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
operator|&
name|EDP_FORCE_VDD
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_dp_check_edp
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|ironlake_edp_have_panel_power
argument_list|(
name|intel_dp
argument_list|)
operator|&&
operator|!
name|ironlake_edp_have_panel_vdd
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"eDP powered off while attempting aux channel communication.\n"
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Status 0x%08x Control 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|PCH_PP_STATUS
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|intel_dp_aux_ch
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|uint8_t
modifier|*
name|send
parameter_list|,
name|int
name|send_bytes
parameter_list|,
name|uint8_t
modifier|*
name|recv
parameter_list|,
name|int
name|recv_size
parameter_list|)
block|{
name|uint32_t
name|output_reg
init|=
name|intel_dp
operator|->
name|output_reg
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|ch_ctl
init|=
name|output_reg
operator|+
literal|0x10
decl_stmt|;
name|uint32_t
name|ch_data
init|=
name|ch_ctl
operator|+
literal|4
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|recv_bytes
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|aux_clock_divider
decl_stmt|;
name|int
name|try
decl_stmt|,
name|precharge
init|=
literal|5
decl_stmt|;
name|intel_dp_check_edp
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
comment|/* The clock divider is based off the hrawclk, 	 * and would like to run at 2MHz. So, take the 	 * hrawclk value and divide by 2 and use that 	 * 	 * Note that PCH attached eDP panels should use a 125MHz input 	 * clock divider. 	 */
if|if
condition|(
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
condition|)
name|aux_clock_divider
operator|=
literal|200
expr_stmt|;
comment|/* SNB& IVB eDP input clock at 400Mhz */
else|else
name|aux_clock_divider
operator|=
literal|225
expr_stmt|;
comment|/* eDP input clock at 450Mhz */
block|}
elseif|else
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|aux_clock_divider
operator|=
literal|63
expr_stmt|;
comment|/* IRL input clock fixed at 125Mhz */
else|else
name|aux_clock_divider
operator|=
name|intel_hrawclk
argument_list|(
name|dev
argument_list|)
operator|/
literal|2
expr_stmt|;
comment|/* Try to wait for any previous AUX channel activity */
for|for
control|(
name|try
operator|=
literal|0
init|;
name|try
operator|<
literal|3
condition|;
name|try
operator|++
control|)
block|{
name|status
operator|=
name|I915_READ
argument_list|(
name|ch_ctl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|DP_AUX_CH_CTL_SEND_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
name|drm_msleep
argument_list|(
literal|1
argument_list|,
literal|"915ach"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|try
operator|==
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"dp_aux_ch not started status 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|ch_ctl
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
comment|/* Must try at least 3 times according to DP spec */
for|for
control|(
name|try
operator|=
literal|0
init|;
name|try
operator|<
literal|5
condition|;
name|try
operator|++
control|)
block|{
comment|/* Load the send data into the aux channel data registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|send_bytes
condition|;
name|i
operator|+=
literal|4
control|)
name|I915_WRITE
argument_list|(
name|ch_data
operator|+
name|i
argument_list|,
name|pack_aux
argument_list|(
name|send
operator|+
name|i
argument_list|,
name|send_bytes
operator|-
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send the command and wait for it to complete */
name|I915_WRITE
argument_list|(
name|ch_ctl
argument_list|,
name|DP_AUX_CH_CTL_SEND_BUSY
operator||
name|DP_AUX_CH_CTL_TIME_OUT_400us
operator||
operator|(
name|send_bytes
operator|<<
name|DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT
operator|)
operator||
operator|(
name|precharge
operator|<<
name|DP_AUX_CH_CTL_PRECHARGE_2US_SHIFT
operator|)
operator||
operator|(
name|aux_clock_divider
operator|<<
name|DP_AUX_CH_CTL_BIT_CLOCK_2X_SHIFT
operator|)
operator||
name|DP_AUX_CH_CTL_DONE
operator||
name|DP_AUX_CH_CTL_TIME_OUT_ERROR
operator||
name|DP_AUX_CH_CTL_RECEIVE_ERROR
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|status
operator|=
name|I915_READ
argument_list|(
name|ch_ctl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|DP_AUX_CH_CTL_SEND_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* Clear done status and any errors */
name|I915_WRITE
argument_list|(
name|ch_ctl
argument_list|,
name|status
operator||
name|DP_AUX_CH_CTL_DONE
operator||
name|DP_AUX_CH_CTL_TIME_OUT_ERROR
operator||
name|DP_AUX_CH_CTL_RECEIVE_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
name|DP_AUX_CH_CTL_TIME_OUT_ERROR
operator||
name|DP_AUX_CH_CTL_RECEIVE_ERROR
operator|)
condition|)
continue|continue;
if|if
condition|(
name|status
operator|&
name|DP_AUX_CH_CTL_DONE
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|DP_AUX_CH_CTL_DONE
operator|)
operator|==
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"dp_aux_ch not done status 0x%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
comment|/* Check for timeout or receive error. 	 * Timeouts occur when the sink is not connected 	 */
if|if
condition|(
name|status
operator|&
name|DP_AUX_CH_CTL_RECEIVE_ERROR
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"dp_aux_ch receive error status 0x%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
comment|/* Timeouts occur when the device isn't connected, so they're 	 * "normal" -- don't fill the kernel log with these */
if|if
condition|(
name|status
operator|&
name|DP_AUX_CH_CTL_TIME_OUT_ERROR
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"dp_aux_ch timeout status 0x%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|-
name|ETIMEDOUT
return|;
block|}
comment|/* Unload any bytes sent back from the other side */
name|recv_bytes
operator|=
operator|(
operator|(
name|status
operator|&
name|DP_AUX_CH_CTL_MESSAGE_SIZE_MASK
operator|)
operator|>>
name|DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|recv_bytes
operator|>
name|recv_size
condition|)
name|recv_bytes
operator|=
name|recv_size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recv_bytes
condition|;
name|i
operator|+=
literal|4
control|)
name|unpack_aux
argument_list|(
name|I915_READ
argument_list|(
name|ch_data
operator|+
name|i
argument_list|)
argument_list|,
name|recv
operator|+
name|i
argument_list|,
name|recv_bytes
operator|-
name|i
argument_list|)
expr_stmt|;
return|return
name|recv_bytes
return|;
block|}
end_function

begin_comment
comment|/* Write data to the aux channel in native mode */
end_comment

begin_function
specifier|static
name|int
name|intel_dp_aux_native_write
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|uint16_t
name|address
parameter_list|,
name|uint8_t
modifier|*
name|send
parameter_list|,
name|int
name|send_bytes
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uint8_t
name|msg
index|[
literal|20
index|]
decl_stmt|;
name|int
name|msg_bytes
decl_stmt|;
name|uint8_t
name|ack
decl_stmt|;
name|intel_dp_check_edp
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_bytes
operator|>
literal|16
condition|)
return|return
operator|-
literal|1
return|;
name|msg
index|[
literal|0
index|]
operator|=
name|AUX_NATIVE_WRITE
operator|<<
literal|4
expr_stmt|;
name|msg
index|[
literal|1
index|]
operator|=
name|address
operator|>>
literal|8
expr_stmt|;
name|msg
index|[
literal|2
index|]
operator|=
name|address
operator|&
literal|0xff
expr_stmt|;
name|msg
index|[
literal|3
index|]
operator|=
name|send_bytes
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|msg
index|[
literal|4
index|]
argument_list|,
name|send
argument_list|,
name|send_bytes
argument_list|)
expr_stmt|;
name|msg_bytes
operator|=
name|send_bytes
operator|+
literal|4
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ret
operator|=
name|intel_dp_aux_ch
argument_list|(
name|intel_dp
argument_list|,
name|msg
argument_list|,
name|msg_bytes
argument_list|,
operator|&
name|ack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|ack
operator|&
name|AUX_NATIVE_REPLY_MASK
operator|)
operator|==
name|AUX_NATIVE_REPLY_ACK
condition|)
break|break;
elseif|else
if|if
condition|(
operator|(
name|ack
operator|&
name|AUX_NATIVE_REPLY_MASK
operator|)
operator|==
name|AUX_NATIVE_REPLY_DEFER
condition|)
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
name|EIO
return|;
block|}
return|return
name|send_bytes
return|;
block|}
end_function

begin_comment
comment|/* Write a single byte to the aux channel in native mode */
end_comment

begin_function
specifier|static
name|int
name|intel_dp_aux_native_write_1
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|uint16_t
name|address
parameter_list|,
name|uint8_t
name|byte
parameter_list|)
block|{
return|return
name|intel_dp_aux_native_write
argument_list|(
name|intel_dp
argument_list|,
name|address
argument_list|,
operator|&
name|byte
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* read bytes from a native aux channel */
end_comment

begin_function
specifier|static
name|int
name|intel_dp_aux_native_read
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|uint16_t
name|address
parameter_list|,
name|uint8_t
modifier|*
name|recv
parameter_list|,
name|int
name|recv_bytes
parameter_list|)
block|{
name|uint8_t
name|msg
index|[
literal|4
index|]
decl_stmt|;
name|int
name|msg_bytes
decl_stmt|;
name|uint8_t
name|reply
index|[
literal|20
index|]
decl_stmt|;
name|int
name|reply_bytes
decl_stmt|;
name|uint8_t
name|ack
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|intel_dp_check_edp
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|=
name|AUX_NATIVE_READ
operator|<<
literal|4
expr_stmt|;
name|msg
index|[
literal|1
index|]
operator|=
name|address
operator|>>
literal|8
expr_stmt|;
name|msg
index|[
literal|2
index|]
operator|=
name|address
operator|&
literal|0xff
expr_stmt|;
name|msg
index|[
literal|3
index|]
operator|=
name|recv_bytes
operator|-
literal|1
expr_stmt|;
name|msg_bytes
operator|=
literal|4
expr_stmt|;
name|reply_bytes
operator|=
name|recv_bytes
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ret
operator|=
name|intel_dp_aux_ch
argument_list|(
name|intel_dp
argument_list|,
name|msg
argument_list|,
name|msg_bytes
argument_list|,
name|reply
argument_list|,
name|reply_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
operator|-
name|EPROTO
return|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
name|ack
operator|=
name|reply
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ack
operator|&
name|AUX_NATIVE_REPLY_MASK
operator|)
operator|==
name|AUX_NATIVE_REPLY_ACK
condition|)
block|{
name|memcpy
argument_list|(
name|recv
argument_list|,
name|reply
operator|+
literal|1
argument_list|,
name|ret
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|ret
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ack
operator|&
name|AUX_NATIVE_REPLY_MASK
operator|)
operator|==
name|AUX_NATIVE_REPLY_DEFER
condition|)
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
name|EIO
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|intel_dp_i2c_aux_ch
parameter_list|(
name|device_t
name|idev
parameter_list|,
name|int
name|mode
parameter_list|,
name|uint8_t
name|write_byte
parameter_list|,
name|uint8_t
modifier|*
name|read_byte
parameter_list|)
block|{
name|struct
name|iic_dp_aux_data
modifier|*
name|data
decl_stmt|;
name|struct
name|intel_dp
modifier|*
name|intel_dp
decl_stmt|;
name|uint16_t
name|address
decl_stmt|;
name|uint8_t
name|msg
index|[
literal|5
index|]
decl_stmt|;
name|uint8_t
name|reply
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|retry
decl_stmt|;
name|int
name|msg_bytes
decl_stmt|;
name|int
name|reply_bytes
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|data
operator|=
name|device_get_softc
argument_list|(
name|idev
argument_list|)
expr_stmt|;
name|intel_dp
operator|=
name|data
operator|->
name|priv
expr_stmt|;
name|address
operator|=
name|data
operator|->
name|address
expr_stmt|;
name|intel_dp_check_edp
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
comment|/* Set up the command byte */
if|if
condition|(
name|mode
operator|&
name|MODE_I2C_READ
condition|)
name|msg
index|[
literal|0
index|]
operator|=
name|AUX_I2C_READ
operator|<<
literal|4
expr_stmt|;
else|else
name|msg
index|[
literal|0
index|]
operator|=
name|AUX_I2C_WRITE
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|MODE_I2C_STOP
operator|)
condition|)
name|msg
index|[
literal|0
index|]
operator||=
name|AUX_I2C_MOT
operator|<<
literal|4
expr_stmt|;
name|msg
index|[
literal|1
index|]
operator|=
name|address
operator|>>
literal|8
expr_stmt|;
name|msg
index|[
literal|2
index|]
operator|=
name|address
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_I2C_WRITE
case|:
name|msg
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|msg
index|[
literal|4
index|]
operator|=
name|write_byte
expr_stmt|;
name|msg_bytes
operator|=
literal|5
expr_stmt|;
name|reply_bytes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MODE_I2C_READ
case|:
name|msg
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|msg_bytes
operator|=
literal|4
expr_stmt|;
name|reply_bytes
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|msg_bytes
operator|=
literal|3
expr_stmt|;
name|reply_bytes
operator|=
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
literal|5
condition|;
name|retry
operator|++
control|)
block|{
name|ret
operator|=
name|intel_dp_aux_ch
argument_list|(
name|intel_dp
argument_list|,
name|msg
argument_list|,
name|msg_bytes
argument_list|,
name|reply
argument_list|,
name|reply_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"aux_ch failed %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ret
operator|)
return|;
block|}
switch|switch
condition|(
name|reply
index|[
literal|0
index|]
operator|&
name|AUX_NATIVE_REPLY_MASK
condition|)
block|{
case|case
name|AUX_NATIVE_REPLY_ACK
case|:
comment|/* I2C-over-AUX Reply field is only valid 			 * when paired with AUX ACK. 			 */
break|break;
case|case
name|AUX_NATIVE_REPLY_NACK
case|:
name|DRM_DEBUG_KMS
argument_list|(
literal|"aux_ch native nack\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EREMOTEIO
operator|)
return|;
case|case
name|AUX_NATIVE_REPLY_DEFER
case|:
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|DRM_ERROR
argument_list|(
literal|"aux_ch invalid native reply 0x%02x\n"
argument_list|,
name|reply
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EREMOTEIO
operator|)
return|;
block|}
switch|switch
condition|(
name|reply
index|[
literal|0
index|]
operator|&
name|AUX_I2C_REPLY_MASK
condition|)
block|{
case|case
name|AUX_I2C_REPLY_ACK
case|:
if|if
condition|(
name|mode
operator|==
name|MODE_I2C_READ
condition|)
block|{
operator|*
name|read_byte
operator|=
name|reply
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|0
comment|/*reply_bytes - 1*/
operator|)
return|;
case|case
name|AUX_I2C_REPLY_NACK
case|:
name|DRM_DEBUG_KMS
argument_list|(
literal|"aux_i2c nack\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EREMOTEIO
operator|)
return|;
case|case
name|AUX_I2C_REPLY_DEFER
case|:
name|DRM_DEBUG_KMS
argument_list|(
literal|"aux_i2c defer\n"
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"aux_i2c invalid reply 0x%02x\n"
argument_list|,
name|reply
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EREMOTEIO
operator|)
return|;
block|}
block|}
name|DRM_ERROR
argument_list|(
literal|"too many retries, giving up\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EREMOTEIO
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|ironlake_edp_panel_vdd_on
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ironlake_edp_panel_vdd_off
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|bool
name|sync
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|intel_dp_i2c_init
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|struct
name|intel_connector
modifier|*
name|intel_connector
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"i2c_init %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_vdd_on
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iic_dp_aux_add_bus
argument_list|(
name|intel_connector
operator|->
name|base
operator|.
name|dev
operator|->
name|device
argument_list|,
name|name
argument_list|,
name|intel_dp_i2c_aux_ch
argument_list|,
name|intel_dp
argument_list|,
operator|&
name|intel_dp
operator|->
name|dp_iic_bus
argument_list|,
operator|&
name|intel_dp
operator|->
name|adapter
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_vdd_off
argument_list|(
name|intel_dp
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_dp_mode_fixup
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|enc_to_intel_dp
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|int
name|lane_count
decl_stmt|,
name|clock
decl_stmt|;
name|int
name|max_lane_count
init|=
name|intel_dp_max_lane_count
argument_list|(
name|intel_dp
argument_list|)
decl_stmt|;
name|int
name|max_clock
init|=
name|intel_dp_max_link_bw
argument_list|(
name|intel_dp
argument_list|)
operator|==
name|DP_LINK_BW_2_7
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|bpp
decl_stmt|,
name|mode_rate
decl_stmt|;
specifier|static
name|int
name|bws
index|[
literal|2
index|]
init|=
block|{
name|DP_LINK_BW_1_62
block|,
name|DP_LINK_BW_2_7
block|}
decl_stmt|;
if|if
condition|(
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
operator|&&
name|intel_dp
operator|->
name|panel_fixed_mode
condition|)
block|{
name|intel_fixed_panel_mode
argument_list|(
name|intel_dp
operator|->
name|panel_fixed_mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
name|intel_pch_panel_fitting
argument_list|(
name|dev
argument_list|,
name|DRM_MODE_SCALE_FULLSCREEN
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
comment|/* 		 * the mode->clock is used to calculate the Data&Link M/N 		 * of the pipe. For the eDP the fixed clock should be used. 		 */
name|mode
operator|->
name|clock
operator|=
name|intel_dp
operator|->
name|panel_fixed_mode
operator|->
name|clock
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"DP link computation with max lane count %i "
literal|"max bw %02x pixel clock %iKHz\n"
argument_list|,
name|max_lane_count
argument_list|,
name|bws
index|[
name|max_clock
index|]
argument_list|,
name|mode
operator|->
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_dp_adjust_dithering
argument_list|(
name|intel_dp
argument_list|,
name|adjusted_mode
argument_list|,
name|adjusted_mode
argument_list|)
condition|)
return|return
name|false
return|;
name|bpp
operator|=
name|adjusted_mode
operator|->
name|private_flags
operator|&
name|INTEL_MODE_DP_FORCE_6BPC
condition|?
literal|18
else|:
literal|24
expr_stmt|;
name|mode_rate
operator|=
name|intel_dp_link_required
argument_list|(
name|mode
operator|->
name|clock
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
for|for
control|(
name|lane_count
operator|=
literal|1
init|;
name|lane_count
operator|<=
name|max_lane_count
condition|;
name|lane_count
operator|<<=
literal|1
control|)
block|{
for|for
control|(
name|clock
operator|=
literal|0
init|;
name|clock
operator|<=
name|max_clock
condition|;
name|clock
operator|++
control|)
block|{
name|int
name|link_avail
init|=
name|intel_dp_max_data_rate
argument_list|(
name|intel_dp_link_clock
argument_list|(
name|bws
index|[
name|clock
index|]
argument_list|)
argument_list|,
name|lane_count
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode_rate
operator|<=
name|link_avail
condition|)
block|{
name|intel_dp
operator|->
name|link_bw
operator|=
name|bws
index|[
name|clock
index|]
expr_stmt|;
name|intel_dp
operator|->
name|lane_count
operator|=
name|lane_count
expr_stmt|;
name|adjusted_mode
operator|->
name|clock
operator|=
name|intel_dp_link_clock
argument_list|(
name|intel_dp
operator|->
name|link_bw
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"DP link bw %02x lane "
literal|"count %d clock %d bpp %d\n"
argument_list|,
name|intel_dp
operator|->
name|link_bw
argument_list|,
name|intel_dp
operator|->
name|lane_count
argument_list|,
name|adjusted_mode
operator|->
name|clock
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"DP link bw required %i available %i\n"
argument_list|,
name|mode_rate
argument_list|,
name|link_avail
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_struct
struct|struct
name|intel_dp_m_n
block|{
name|uint32_t
name|tu
decl_stmt|;
name|uint32_t
name|gmch_m
decl_stmt|;
name|uint32_t
name|gmch_n
decl_stmt|;
name|uint32_t
name|link_m
decl_stmt|;
name|uint32_t
name|link_n
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|intel_reduce_ratio
parameter_list|(
name|uint32_t
modifier|*
name|num
parameter_list|,
name|uint32_t
modifier|*
name|den
parameter_list|)
block|{
while|while
condition|(
operator|*
name|num
operator|>
literal|0xffffff
operator|||
operator|*
name|den
operator|>
literal|0xffffff
condition|)
block|{
operator|*
name|num
operator|>>=
literal|1
expr_stmt|;
operator|*
name|den
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_dp_compute_m_n
parameter_list|(
name|int
name|bpp
parameter_list|,
name|int
name|nlanes
parameter_list|,
name|int
name|pixel_clock
parameter_list|,
name|int
name|link_clock
parameter_list|,
name|struct
name|intel_dp_m_n
modifier|*
name|m_n
parameter_list|)
block|{
name|m_n
operator|->
name|tu
operator|=
literal|64
expr_stmt|;
name|m_n
operator|->
name|gmch_m
operator|=
operator|(
name|pixel_clock
operator|*
name|bpp
operator|)
operator|>>
literal|3
expr_stmt|;
name|m_n
operator|->
name|gmch_n
operator|=
name|link_clock
operator|*
name|nlanes
expr_stmt|;
name|intel_reduce_ratio
argument_list|(
operator|&
name|m_n
operator|->
name|gmch_m
argument_list|,
operator|&
name|m_n
operator|->
name|gmch_n
argument_list|)
expr_stmt|;
name|m_n
operator|->
name|link_m
operator|=
name|pixel_clock
expr_stmt|;
name|m_n
operator|->
name|link_n
operator|=
name|link_clock
expr_stmt|;
name|intel_reduce_ratio
argument_list|(
operator|&
name|m_n
operator|->
name|link_m
argument_list|,
operator|&
name|m_n
operator|->
name|link_n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_dp_set_m_n
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|lane_count
init|=
literal|4
decl_stmt|;
name|struct
name|intel_dp_m_n
name|m_n
decl_stmt|;
name|int
name|pipe
init|=
name|intel_crtc
operator|->
name|pipe
decl_stmt|;
comment|/* 	 * Find the lane count in the intel_encoder private 	 */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|head
argument_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
decl_stmt|;
if|if
condition|(
name|encoder
operator|->
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
name|intel_dp
operator|=
name|enc_to_intel_dp
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_dp
operator|->
name|base
operator|.
name|type
operator|==
name|INTEL_OUTPUT_DISPLAYPORT
operator|||
name|intel_dp
operator|->
name|base
operator|.
name|type
operator|==
name|INTEL_OUTPUT_EDP
condition|)
block|{
name|lane_count
operator|=
name|intel_dp
operator|->
name|lane_count
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Compute the GMCH and Link ratios. The '3' here is 	 * the number of bytes_per_pixel post-LUT, which we always 	 * set up for 8-bits of R/G/B, or 3 bytes total. 	 */
name|intel_dp_compute_m_n
argument_list|(
name|intel_crtc
operator|->
name|bpp
argument_list|,
name|lane_count
argument_list|,
name|mode
operator|->
name|clock
argument_list|,
name|adjusted_mode
operator|->
name|clock
argument_list|,
operator|&
name|m_n
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|TRANSDATA_M1
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
operator|(
name|m_n
operator|.
name|tu
operator|-
literal|1
operator|)
operator|<<
name|PIPE_GMCH_DATA_M_TU_SIZE_SHIFT
operator|)
operator||
name|m_n
operator|.
name|gmch_m
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDATA_N1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|m_n
operator|.
name|gmch_n
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDPLINK_M1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|m_n
operator|.
name|link_m
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANSDPLINK_N1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|m_n
operator|.
name|link_n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|I915_WRITE
argument_list|(
name|PIPE_GMCH_DATA_M
argument_list|(
name|pipe
argument_list|)
argument_list|,
operator|(
operator|(
name|m_n
operator|.
name|tu
operator|-
literal|1
operator|)
operator|<<
name|PIPE_GMCH_DATA_M_TU_SIZE_SHIFT
operator|)
operator||
name|m_n
operator|.
name|gmch_m
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_GMCH_DATA_N
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|m_n
operator|.
name|gmch_n
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_DP_LINK_M
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|m_n
operator|.
name|link_m
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PIPE_DP_LINK_N
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|m_n
operator|.
name|link_n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|void
name|ironlake_edp_pll_on
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ironlake_edp_pll_off
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|intel_dp_mode_set
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|enc_to_intel_dp
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|crtc
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
comment|/* Turn on the eDP PLL if needed */
if|if
condition|(
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|is_pch_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
name|ironlake_edp_pll_on
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
else|else
name|ironlake_edp_pll_off
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * There are four kinds of DP registers: 	 * 	 * 	IBX PCH 	 * 	SNB CPU 	 *	IVB CPU 	 * 	CPT PCH 	 * 	 * IBX PCH and CPU are the same for almost everything, 	 * except that the CPU DP PLL is configured in this 	 * register 	 * 	 * CPT PCH is quite different, having many bits moved 	 * to the TRANS_DP_CTL register instead. That 	 * configuration happens (oddly) in ironlake_pch_enable 	 */
comment|/* Preserve the BIOS-computed detected bit. This is 	 * supposed to be read-only. 	 */
name|intel_dp
operator|->
name|DP
operator|=
name|I915_READ
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|)
operator|&
name|DP_DETECTED
expr_stmt|;
name|intel_dp
operator|->
name|DP
operator||=
name|DP_VOLTAGE_0_4
operator||
name|DP_PRE_EMPHASIS_0
expr_stmt|;
comment|/* Handle DP bits in common between all three register formats */
name|intel_dp
operator|->
name|DP
operator||=
name|DP_VOLTAGE_0_4
operator||
name|DP_PRE_EMPHASIS_0
expr_stmt|;
switch|switch
condition|(
name|intel_dp
operator|->
name|lane_count
condition|)
block|{
case|case
literal|1
case|:
name|intel_dp
operator|->
name|DP
operator||=
name|DP_PORT_WIDTH_1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|intel_dp
operator|->
name|DP
operator||=
name|DP_PORT_WIDTH_2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|intel_dp
operator|->
name|DP
operator||=
name|DP_PORT_WIDTH_4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|intel_dp
operator|->
name|has_audio
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Enabling DP audio on pipe %c\n"
argument_list|,
name|pipe_name
argument_list|(
name|intel_crtc
operator|->
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|intel_dp
operator|->
name|DP
operator||=
name|DP_AUDIO_OUTPUT_ENABLE
expr_stmt|;
name|intel_write_eld
argument_list|(
name|encoder
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|intel_dp
operator|->
name|link_configuration
argument_list|,
literal|0
argument_list|,
name|DP_LINK_CONFIGURATION_SIZE
argument_list|)
expr_stmt|;
name|intel_dp
operator|->
name|link_configuration
index|[
literal|0
index|]
operator|=
name|intel_dp
operator|->
name|link_bw
expr_stmt|;
name|intel_dp
operator|->
name|link_configuration
index|[
literal|1
index|]
operator|=
name|intel_dp
operator|->
name|lane_count
expr_stmt|;
comment|/* 	 * Check for DPCD version> 1.1 and enhanced framing support 	 */
if|if
condition|(
name|intel_dp
operator|->
name|dpcd
index|[
name|DP_DPCD_REV
index|]
operator|>=
literal|0x11
operator|&&
operator|(
name|intel_dp
operator|->
name|dpcd
index|[
name|DP_MAX_LANE_COUNT
index|]
operator|&
name|DP_ENHANCED_FRAME_CAP
operator|)
condition|)
block|{
name|intel_dp
operator|->
name|link_configuration
index|[
literal|1
index|]
operator||=
name|DP_LANE_COUNT_ENHANCED_FRAME_EN
expr_stmt|;
block|}
comment|/* Split out the IBX/CPU vs CPT settings */
if|if
condition|(
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
operator|&&
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_PHSYNC
condition|)
name|intel_dp
operator|->
name|DP
operator||=
name|DP_SYNC_HS_HIGH
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_PVSYNC
condition|)
name|intel_dp
operator|->
name|DP
operator||=
name|DP_SYNC_VS_HIGH
expr_stmt|;
name|intel_dp
operator|->
name|DP
operator||=
name|DP_LINK_TRAIN_OFF_CPT
expr_stmt|;
if|if
condition|(
name|intel_dp
operator|->
name|link_configuration
index|[
literal|1
index|]
operator|&
name|DP_LANE_COUNT_ENHANCED_FRAME_EN
condition|)
name|intel_dp
operator|->
name|DP
operator||=
name|DP_ENHANCED_FRAMING
expr_stmt|;
name|intel_dp
operator|->
name|DP
operator||=
name|intel_crtc
operator|->
name|pipe
operator|<<
literal|29
expr_stmt|;
comment|/* don't miss out required setting for eDP */
name|intel_dp
operator|->
name|DP
operator||=
name|DP_PLL_ENABLE
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|clock
operator|<
literal|200000
condition|)
name|intel_dp
operator|->
name|DP
operator||=
name|DP_PLL_FREQ_160MHZ
expr_stmt|;
else|else
name|intel_dp
operator|->
name|DP
operator||=
name|DP_PLL_FREQ_270MHZ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
operator|||
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|intel_dp
operator|->
name|DP
operator||=
name|intel_dp
operator|->
name|color_range
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_PHSYNC
condition|)
name|intel_dp
operator|->
name|DP
operator||=
name|DP_SYNC_HS_HIGH
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_PVSYNC
condition|)
name|intel_dp
operator|->
name|DP
operator||=
name|DP_SYNC_VS_HIGH
expr_stmt|;
name|intel_dp
operator|->
name|DP
operator||=
name|DP_LINK_TRAIN_OFF
expr_stmt|;
if|if
condition|(
name|intel_dp
operator|->
name|link_configuration
index|[
literal|1
index|]
operator|&
name|DP_LANE_COUNT_ENHANCED_FRAME_EN
condition|)
name|intel_dp
operator|->
name|DP
operator||=
name|DP_ENHANCED_FRAMING
expr_stmt|;
if|if
condition|(
name|intel_crtc
operator|->
name|pipe
operator|==
literal|1
condition|)
name|intel_dp
operator|->
name|DP
operator||=
name|DP_PIPEB_SELECT
expr_stmt|;
if|if
condition|(
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
comment|/* don't miss out required setting for eDP */
name|intel_dp
operator|->
name|DP
operator||=
name|DP_PLL_ENABLE
expr_stmt|;
if|if
condition|(
name|adjusted_mode
operator|->
name|clock
operator|<
literal|200000
condition|)
name|intel_dp
operator|->
name|DP
operator||=
name|DP_PLL_FREQ_160MHZ
expr_stmt|;
else|else
name|intel_dp
operator|->
name|DP
operator||=
name|DP_PLL_FREQ_270MHZ
expr_stmt|;
block|}
block|}
else|else
block|{
name|intel_dp
operator|->
name|DP
operator||=
name|DP_LINK_TRAIN_OFF_CPT
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|IDLE_ON_MASK
value|(PP_ON | 0 	  | PP_SEQUENCE_MASK | 0                     | PP_SEQUENCE_STATE_MASK)
end_define

begin_define
define|#
directive|define
name|IDLE_ON_VALUE
value|(PP_ON | 0 	  | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_ON_IDLE)
end_define

begin_define
define|#
directive|define
name|IDLE_OFF_MASK
value|(PP_ON | 0        | PP_SEQUENCE_MASK | 0                     | PP_SEQUENCE_STATE_MASK)
end_define

begin_define
define|#
directive|define
name|IDLE_OFF_VALUE
value|(0     | 0        | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_OFF_IDLE)
end_define

begin_define
define|#
directive|define
name|IDLE_CYCLE_MASK
value|(PP_ON | 0        | PP_SEQUENCE_MASK | PP_CYCLE_DELAY_ACTIVE | PP_SEQUENCE_STATE_MASK)
end_define

begin_define
define|#
directive|define
name|IDLE_CYCLE_VALUE
value|(0     | 0        | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_OFF_IDLE)
end_define

begin_function
specifier|static
name|void
name|ironlake_wait_panel_status
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|u32
name|mask
parameter_list|,
name|u32
name|value
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"mask %08x value %08x status %08x control %08x\n"
argument_list|,
name|mask
argument_list|,
name|value
argument_list|,
name|I915_READ
argument_list|(
name|PCH_PP_STATUS
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_intel_wait_for
argument_list|(
name|dev
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|PCH_PP_STATUS
argument_list|)
operator|&
name|mask
operator|)
operator|==
name|value
argument_list|,
literal|5000
argument_list|,
literal|10
argument_list|,
literal|"915iwp"
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Panel status timeout: status %08x control %08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|PCH_PP_STATUS
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_wait_panel_on
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Wait for panel power on\n"
argument_list|)
expr_stmt|;
name|ironlake_wait_panel_status
argument_list|(
name|intel_dp
argument_list|,
name|IDLE_ON_MASK
argument_list|,
name|IDLE_ON_VALUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_wait_panel_off
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Wait for panel power off time\n"
argument_list|)
expr_stmt|;
name|ironlake_wait_panel_status
argument_list|(
name|intel_dp
argument_list|,
name|IDLE_OFF_MASK
argument_list|,
name|IDLE_OFF_VALUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_wait_panel_power_cycle
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Wait for panel power cycle\n"
argument_list|)
expr_stmt|;
name|ironlake_wait_panel_status
argument_list|(
name|intel_dp
argument_list|,
name|IDLE_CYCLE_MASK
argument_list|,
name|IDLE_CYCLE_VALUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the current pp_control value, unlocking the register if it  * is locked  */
end_comment

begin_function
specifier|static
name|u32
name|ironlake_get_pp_control
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|control
init|=
name|I915_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
decl_stmt|;
name|control
operator|&=
operator|~
name|PANEL_UNLOCK_MASK
expr_stmt|;
name|control
operator||=
name|PANEL_UNLOCK_REGS
expr_stmt|;
return|return
name|control
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_edp_panel_vdd_on
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|pp
decl_stmt|;
if|if
condition|(
operator|!
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
return|return;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Turn eDP VDD on\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_dp
operator|->
name|want_panel_vdd
condition|)
name|printf
argument_list|(
literal|"eDP VDD already requested on\n"
argument_list|)
expr_stmt|;
name|intel_dp
operator|->
name|want_panel_vdd
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|ironlake_edp_have_panel_vdd
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"eDP VDD already on\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ironlake_edp_have_panel_power
argument_list|(
name|intel_dp
argument_list|)
condition|)
name|ironlake_wait_panel_power_cycle
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|pp
operator|=
name|ironlake_get_pp_control
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|pp
operator||=
name|EDP_FORCE_VDD
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_PP_CONTROL
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"PCH_PP_STATUS: 0x%08x PCH_PP_CONTROL: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|PCH_PP_STATUS
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the panel wasn't on, delay before accessing aux channel 	 */
if|if
condition|(
operator|!
name|ironlake_edp_have_panel_power
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"eDP was not running\n"
argument_list|)
expr_stmt|;
name|drm_msleep
argument_list|(
name|intel_dp
operator|->
name|panel_power_up_delay
argument_list|,
literal|"915edpon"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_panel_vdd_off_sync
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|pp
decl_stmt|;
if|if
condition|(
operator|!
name|intel_dp
operator|->
name|want_panel_vdd
operator|&&
name|ironlake_edp_have_panel_vdd
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|pp
operator|=
name|ironlake_get_pp_control
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|pp
operator|&=
operator|~
name|EDP_FORCE_VDD
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_PP_CONTROL
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
expr_stmt|;
comment|/* Make sure sequencer is idle before allowing subsequent activity */
name|DRM_DEBUG_KMS
argument_list|(
literal|"PCH_PP_STATUS: 0x%08x PCH_PP_CONTROL: 0x%08x\n"
argument_list|,
name|I915_READ
argument_list|(
name|PCH_PP_STATUS
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|drm_msleep
argument_list|(
name|intel_dp
operator|->
name|panel_power_down_delay
argument_list|,
literal|"915vddo"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_panel_vdd_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|arg
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|ironlake_panel_vdd_off_sync
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_edp_panel_vdd_off
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|bool
name|sync
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
return|return;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Turn eDP VDD off %d\n"
argument_list|,
name|intel_dp
operator|->
name|want_panel_vdd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_dp
operator|->
name|want_panel_vdd
condition|)
name|printf
argument_list|(
literal|"eDP VDD not forced on\n"
argument_list|)
expr_stmt|;
name|intel_dp
operator|->
name|want_panel_vdd
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|sync
condition|)
block|{
name|ironlake_panel_vdd_off_sync
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Queue the timer to fire a long 		 * time from now (relative to the power down delay) 		 * to keep the panel power up across a sequence of operations 		 */
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|taskqueue_enqueue_timeout
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|intel_dp
operator|->
name|panel_vdd_task
argument_list|,
name|msecs_to_jiffies
argument_list|(
name|intel_dp
operator|->
name|panel_power_cycle_delay
operator|*
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_edp_panel_on
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|pp
decl_stmt|;
if|if
condition|(
operator|!
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
return|return;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Turn eDP power on\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ironlake_edp_have_panel_power
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"eDP power already on\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ironlake_wait_panel_power_cycle
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|pp
operator|=
name|ironlake_get_pp_control
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* ILK workaround: disable reset around power sequence */
name|pp
operator|&=
operator|~
name|PANEL_POWER_RESET
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_PP_CONTROL
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
expr_stmt|;
block|}
name|pp
operator||=
name|POWER_TARGET_ON
expr_stmt|;
if|if
condition|(
operator|!
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
name|pp
operator||=
name|PANEL_POWER_RESET
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_PP_CONTROL
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
expr_stmt|;
name|ironlake_wait_panel_on
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|pp
operator||=
name|PANEL_POWER_RESET
expr_stmt|;
comment|/* restore panel reset bit */
name|I915_WRITE
argument_list|(
name|PCH_PP_CONTROL
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_edp_panel_off
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|pp
decl_stmt|;
if|if
condition|(
operator|!
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
return|return;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Turn eDP power off\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_dp
operator|->
name|want_panel_vdd
condition|)
name|printf
argument_list|(
literal|"Cannot turn power off while VDD is on\n"
argument_list|)
expr_stmt|;
name|ironlake_panel_vdd_off_sync
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
comment|/* finish any pending work */
name|pp
operator|=
name|ironlake_get_pp_control
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|pp
operator|&=
operator|~
operator|(
name|POWER_TARGET_ON
operator||
name|EDP_FORCE_VDD
operator||
name|PANEL_POWER_RESET
operator||
name|EDP_BLC_ENABLE
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_PP_CONTROL
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
expr_stmt|;
name|ironlake_wait_panel_off
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_edp_backlight_on
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|pp
decl_stmt|;
if|if
condition|(
operator|!
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
return|return;
name|DRM_DEBUG_KMS
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	 * If we enable the backlight right away following a panel power 	 * on, we may see slight flicker as the panel syncs with the eDP 	 * link.  So delay a bit to make sure the image is solid before 	 * allowing it to appear. 	 */
name|drm_msleep
argument_list|(
name|intel_dp
operator|->
name|backlight_on_delay
argument_list|,
literal|"915ebo"
argument_list|)
expr_stmt|;
name|pp
operator|=
name|ironlake_get_pp_control
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|pp
operator||=
name|EDP_BLC_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_PP_CONTROL
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_edp_backlight_off
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|pp
decl_stmt|;
if|if
condition|(
operator|!
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
return|return;
name|DRM_DEBUG_KMS
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|pp
operator|=
name|ironlake_get_pp_control
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|pp
operator|&=
operator|~
name|EDP_BLC_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_PP_CONTROL
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PCH_PP_CONTROL
argument_list|)
expr_stmt|;
name|drm_msleep
argument_list|(
name|intel_dp
operator|->
name|backlight_off_delay
argument_list|,
literal|"915bo1"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_edp_pll_on
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|dpa_ctl
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|dpa_ctl
operator|=
name|I915_READ
argument_list|(
name|DP_A
argument_list|)
expr_stmt|;
name|dpa_ctl
operator||=
name|DP_PLL_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DP_A
argument_list|,
name|dpa_ctl
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DP_A
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_edp_pll_off
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|dpa_ctl
decl_stmt|;
name|dpa_ctl
operator|=
name|I915_READ
argument_list|(
name|DP_A
argument_list|)
expr_stmt|;
name|dpa_ctl
operator|&=
operator|~
name|DP_PLL_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DP_A
argument_list|,
name|dpa_ctl
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|DP_A
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the sink supports it, try to set the power state appropriately */
end_comment

begin_function
specifier|static
name|void
name|intel_dp_sink_dpms
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
comment|/* Should have a valid DPCD by this point */
if|if
condition|(
name|intel_dp
operator|->
name|dpcd
index|[
name|DP_DPCD_REV
index|]
operator|<
literal|0x11
condition|)
return|return;
if|if
condition|(
name|mode
operator|!=
name|DRM_MODE_DPMS_ON
condition|)
block|{
name|ret
operator|=
name|intel_dp_aux_native_write_1
argument_list|(
name|intel_dp
argument_list|,
name|DP_SET_POWER
argument_list|,
name|DP_SET_POWER_D3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
name|DRM_DEBUG
argument_list|(
literal|"failed to write sink power state\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * When turning on, we need to retry for 1ms to give the sink 		 * time to wake up. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|intel_dp_aux_native_write_1
argument_list|(
name|intel_dp
argument_list|,
name|DP_SET_POWER
argument_list|,
name|DP_SET_POWER_D0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
break|break;
name|drm_msleep
argument_list|(
literal|1
argument_list|,
literal|"915dps"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_dp_prepare
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|enc_to_intel_dp
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|ironlake_edp_backlight_off
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_off
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
comment|/* Wake up the sink first */
name|ironlake_edp_panel_vdd_on
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|intel_dp_sink_dpms
argument_list|(
name|intel_dp
argument_list|,
name|DRM_MODE_DPMS_ON
argument_list|)
expr_stmt|;
name|intel_dp_link_down
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_vdd_off
argument_list|(
name|intel_dp
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Make sure the panel is off before trying to 	 * change the mode 	 */
block|}
end_function

begin_function
specifier|static
name|void
name|intel_dp_commit
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|enc_to_intel_dp
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|crtc
argument_list|)
decl_stmt|;
name|ironlake_edp_panel_vdd_on
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|intel_dp_sink_dpms
argument_list|(
name|intel_dp
argument_list|,
name|DRM_MODE_DPMS_ON
argument_list|)
expr_stmt|;
name|intel_dp_start_link_train
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_on
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_vdd_off
argument_list|(
name|intel_dp
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|intel_dp_complete_link_train
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|ironlake_edp_backlight_on
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|intel_dp
operator|->
name|dpms_mode
operator|=
name|DRM_MODE_DPMS_ON
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_cpt_verify_modeset
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_dp_dpms
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|enc_to_intel_dp
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|dp_reg
init|=
name|I915_READ
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|DRM_MODE_DPMS_ON
condition|)
block|{
name|ironlake_edp_backlight_off
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_off
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_vdd_on
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|intel_dp_sink_dpms
argument_list|(
name|intel_dp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|intel_dp_link_down
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_vdd_off
argument_list|(
name|intel_dp
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
name|ironlake_edp_pll_off
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
name|ironlake_edp_pll_on
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_vdd_on
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|intel_dp_sink_dpms
argument_list|(
name|intel_dp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dp_reg
operator|&
name|DP_PORT_EN
operator|)
condition|)
block|{
name|intel_dp_start_link_train
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_on
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_vdd_off
argument_list|(
name|intel_dp
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|intel_dp_complete_link_train
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
block|}
else|else
name|ironlake_edp_panel_vdd_off
argument_list|(
name|intel_dp
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|ironlake_edp_backlight_on
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
block|}
name|intel_dp
operator|->
name|dpms_mode
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Native read with retry for link status and receiver capability reads for  * cases where the sink may still be asleep.  */
end_comment

begin_function
specifier|static
name|bool
name|intel_dp_aux_native_read_retry
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|uint16_t
name|address
parameter_list|,
name|uint8_t
modifier|*
name|recv
parameter_list|,
name|int
name|recv_bytes
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Sinks are *supposed* to come up within 1ms from an off state, 	 * but we're also supposed to retry 3 times per the spec. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|intel_dp_aux_native_read
argument_list|(
name|intel_dp
argument_list|,
name|address
argument_list|,
name|recv
argument_list|,
name|recv_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|recv_bytes
condition|)
return|return
name|true
return|;
name|drm_msleep
argument_list|(
literal|1
argument_list|,
literal|"915dpl"
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch AUX CH registers 0x202 - 0x207 which contain  * link status information  */
end_comment

begin_function
specifier|static
name|bool
name|intel_dp_get_link_status
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|uint8_t
name|link_status
index|[
name|DP_LINK_STATUS_SIZE
index|]
parameter_list|)
block|{
return|return
name|intel_dp_aux_native_read_retry
argument_list|(
name|intel_dp
argument_list|,
name|DP_LANE0_1_STATUS
argument_list|,
name|link_status
argument_list|,
name|DP_LINK_STATUS_SIZE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|intel_dp_link_status
parameter_list|(
name|uint8_t
name|link_status
index|[
name|DP_LINK_STATUS_SIZE
index|]
parameter_list|,
name|int
name|r
parameter_list|)
block|{
return|return
name|link_status
index|[
name|r
operator|-
name|DP_LANE0_1_STATUS
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|intel_get_adjust_request_voltage
parameter_list|(
name|uint8_t
name|adjust_request
index|[
literal|2
index|]
parameter_list|,
name|int
name|lane
parameter_list|)
block|{
name|int
name|s
init|=
operator|(
operator|(
name|lane
operator|&
literal|1
operator|)
condition|?
name|DP_ADJUST_VOLTAGE_SWING_LANE1_SHIFT
else|:
name|DP_ADJUST_VOLTAGE_SWING_LANE0_SHIFT
operator|)
decl_stmt|;
name|uint8_t
name|l
init|=
name|adjust_request
index|[
name|lane
operator|>>
literal|1
index|]
decl_stmt|;
return|return
operator|(
operator|(
name|l
operator|>>
name|s
operator|)
operator|&
literal|3
operator|)
operator|<<
name|DP_TRAIN_VOLTAGE_SWING_SHIFT
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|intel_get_adjust_request_pre_emphasis
parameter_list|(
name|uint8_t
name|adjust_request
index|[
literal|2
index|]
parameter_list|,
name|int
name|lane
parameter_list|)
block|{
name|int
name|s
init|=
operator|(
operator|(
name|lane
operator|&
literal|1
operator|)
condition|?
name|DP_ADJUST_PRE_EMPHASIS_LANE1_SHIFT
else|:
name|DP_ADJUST_PRE_EMPHASIS_LANE0_SHIFT
operator|)
decl_stmt|;
name|uint8_t
name|l
init|=
name|adjust_request
index|[
name|lane
operator|>>
literal|1
index|]
decl_stmt|;
return|return
operator|(
operator|(
name|l
operator|>>
name|s
operator|)
operator|&
literal|3
operator|)
operator|<<
name|DP_TRAIN_PRE_EMPHASIS_SHIFT
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char	*voltage_names[] = { 	"0.4V", "0.6V", "0.8V", "1.2V" }; static char	*pre_emph_names[] = { 	"0dB", "3.5dB", "6dB", "9.5dB" }; static char	*link_train_names[] = { 	"pattern 1", "pattern 2", "idle", "off" };
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * These are source-specific values; current Intel hardware supports  * a maximum voltage of 800mV and a maximum pre-emphasis of 6dB  */
end_comment

begin_function
specifier|static
name|uint8_t
name|intel_dp_voltage_max
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
if|if
condition|(
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|&&
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
return|return
name|DP_TRAIN_VOLTAGE_SWING_800
return|;
elseif|else
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
operator|&&
operator|!
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
return|return
name|DP_TRAIN_VOLTAGE_SWING_1200
return|;
else|else
return|return
name|DP_TRAIN_VOLTAGE_SWING_800
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|intel_dp_pre_emphasis_max
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|uint8_t
name|voltage_swing
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
if|if
condition|(
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|&&
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|voltage_swing
operator|&
name|DP_TRAIN_VOLTAGE_SWING_MASK
condition|)
block|{
case|case
name|DP_TRAIN_VOLTAGE_SWING_400
case|:
return|return
name|DP_TRAIN_PRE_EMPHASIS_6
return|;
case|case
name|DP_TRAIN_VOLTAGE_SWING_600
case|:
case|case
name|DP_TRAIN_VOLTAGE_SWING_800
case|:
return|return
name|DP_TRAIN_PRE_EMPHASIS_3_5
return|;
default|default:
return|return
name|DP_TRAIN_PRE_EMPHASIS_0
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|voltage_swing
operator|&
name|DP_TRAIN_VOLTAGE_SWING_MASK
condition|)
block|{
case|case
name|DP_TRAIN_VOLTAGE_SWING_400
case|:
return|return
name|DP_TRAIN_PRE_EMPHASIS_6
return|;
case|case
name|DP_TRAIN_VOLTAGE_SWING_600
case|:
return|return
name|DP_TRAIN_PRE_EMPHASIS_6
return|;
case|case
name|DP_TRAIN_VOLTAGE_SWING_800
case|:
return|return
name|DP_TRAIN_PRE_EMPHASIS_3_5
return|;
case|case
name|DP_TRAIN_VOLTAGE_SWING_1200
case|:
default|default:
return|return
name|DP_TRAIN_PRE_EMPHASIS_0
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_get_adjust_train
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|uint8_t
name|link_status
index|[
name|DP_LINK_STATUS_SIZE
index|]
parameter_list|)
block|{
name|uint8_t
name|v
init|=
literal|0
decl_stmt|;
name|uint8_t
name|p
init|=
literal|0
decl_stmt|;
name|int
name|lane
decl_stmt|;
name|uint8_t
modifier|*
name|adjust_request
init|=
name|link_status
operator|+
operator|(
name|DP_ADJUST_REQUEST_LANE0_1
operator|-
name|DP_LANE0_1_STATUS
operator|)
decl_stmt|;
name|uint8_t
name|voltage_max
decl_stmt|;
name|uint8_t
name|preemph_max
decl_stmt|;
for|for
control|(
name|lane
operator|=
literal|0
init|;
name|lane
operator|<
name|intel_dp
operator|->
name|lane_count
condition|;
name|lane
operator|++
control|)
block|{
name|uint8_t
name|this_v
init|=
name|intel_get_adjust_request_voltage
argument_list|(
name|adjust_request
argument_list|,
name|lane
argument_list|)
decl_stmt|;
name|uint8_t
name|this_p
init|=
name|intel_get_adjust_request_pre_emphasis
argument_list|(
name|adjust_request
argument_list|,
name|lane
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_v
operator|>
name|v
condition|)
name|v
operator|=
name|this_v
expr_stmt|;
if|if
condition|(
name|this_p
operator|>
name|p
condition|)
name|p
operator|=
name|this_p
expr_stmt|;
block|}
name|voltage_max
operator|=
name|intel_dp_voltage_max
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|>=
name|voltage_max
condition|)
name|v
operator|=
name|voltage_max
operator||
name|DP_TRAIN_MAX_SWING_REACHED
expr_stmt|;
name|preemph_max
operator|=
name|intel_dp_pre_emphasis_max
argument_list|(
name|intel_dp
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|preemph_max
condition|)
name|p
operator|=
name|preemph_max
operator||
name|DP_TRAIN_MAX_PRE_EMPHASIS_REACHED
expr_stmt|;
for|for
control|(
name|lane
operator|=
literal|0
init|;
name|lane
operator|<
literal|4
condition|;
name|lane
operator|++
control|)
name|intel_dp
operator|->
name|train_set
index|[
name|lane
index|]
operator|=
name|v
operator||
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|intel_dp_signal_levels
parameter_list|(
name|uint8_t
name|train_set
parameter_list|)
block|{
name|uint32_t
name|signal_levels
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|train_set
operator|&
name|DP_TRAIN_VOLTAGE_SWING_MASK
condition|)
block|{
case|case
name|DP_TRAIN_VOLTAGE_SWING_400
case|:
default|default:
name|signal_levels
operator||=
name|DP_VOLTAGE_0_4
expr_stmt|;
break|break;
case|case
name|DP_TRAIN_VOLTAGE_SWING_600
case|:
name|signal_levels
operator||=
name|DP_VOLTAGE_0_6
expr_stmt|;
break|break;
case|case
name|DP_TRAIN_VOLTAGE_SWING_800
case|:
name|signal_levels
operator||=
name|DP_VOLTAGE_0_8
expr_stmt|;
break|break;
case|case
name|DP_TRAIN_VOLTAGE_SWING_1200
case|:
name|signal_levels
operator||=
name|DP_VOLTAGE_1_2
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|train_set
operator|&
name|DP_TRAIN_PRE_EMPHASIS_MASK
condition|)
block|{
case|case
name|DP_TRAIN_PRE_EMPHASIS_0
case|:
default|default:
name|signal_levels
operator||=
name|DP_PRE_EMPHASIS_0
expr_stmt|;
break|break;
case|case
name|DP_TRAIN_PRE_EMPHASIS_3_5
case|:
name|signal_levels
operator||=
name|DP_PRE_EMPHASIS_3_5
expr_stmt|;
break|break;
case|case
name|DP_TRAIN_PRE_EMPHASIS_6
case|:
name|signal_levels
operator||=
name|DP_PRE_EMPHASIS_6
expr_stmt|;
break|break;
case|case
name|DP_TRAIN_PRE_EMPHASIS_9_5
case|:
name|signal_levels
operator||=
name|DP_PRE_EMPHASIS_9_5
expr_stmt|;
break|break;
block|}
return|return
name|signal_levels
return|;
block|}
end_function

begin_comment
comment|/* Gen6's DP voltage swing and pre-emphasis control */
end_comment

begin_function
specifier|static
name|uint32_t
name|intel_gen6_edp_signal_levels
parameter_list|(
name|uint8_t
name|train_set
parameter_list|)
block|{
name|int
name|signal_levels
init|=
name|train_set
operator|&
operator|(
name|DP_TRAIN_VOLTAGE_SWING_MASK
operator||
name|DP_TRAIN_PRE_EMPHASIS_MASK
operator|)
decl_stmt|;
switch|switch
condition|(
name|signal_levels
condition|)
block|{
case|case
name|DP_TRAIN_VOLTAGE_SWING_400
operator||
name|DP_TRAIN_PRE_EMPHASIS_0
case|:
case|case
name|DP_TRAIN_VOLTAGE_SWING_600
operator||
name|DP_TRAIN_PRE_EMPHASIS_0
case|:
return|return
name|EDP_LINK_TRAIN_400_600MV_0DB_SNB_B
return|;
case|case
name|DP_TRAIN_VOLTAGE_SWING_400
operator||
name|DP_TRAIN_PRE_EMPHASIS_3_5
case|:
return|return
name|EDP_LINK_TRAIN_400MV_3_5DB_SNB_B
return|;
case|case
name|DP_TRAIN_VOLTAGE_SWING_400
operator||
name|DP_TRAIN_PRE_EMPHASIS_6
case|:
case|case
name|DP_TRAIN_VOLTAGE_SWING_600
operator||
name|DP_TRAIN_PRE_EMPHASIS_6
case|:
return|return
name|EDP_LINK_TRAIN_400_600MV_6DB_SNB_B
return|;
case|case
name|DP_TRAIN_VOLTAGE_SWING_600
operator||
name|DP_TRAIN_PRE_EMPHASIS_3_5
case|:
case|case
name|DP_TRAIN_VOLTAGE_SWING_800
operator||
name|DP_TRAIN_PRE_EMPHASIS_3_5
case|:
return|return
name|EDP_LINK_TRAIN_600_800MV_3_5DB_SNB_B
return|;
case|case
name|DP_TRAIN_VOLTAGE_SWING_800
operator||
name|DP_TRAIN_PRE_EMPHASIS_0
case|:
case|case
name|DP_TRAIN_VOLTAGE_SWING_1200
operator||
name|DP_TRAIN_PRE_EMPHASIS_0
case|:
return|return
name|EDP_LINK_TRAIN_800_1200MV_0DB_SNB_B
return|;
default|default:
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unsupported voltage swing/pre-emphasis level:"
literal|"0x%x\n"
argument_list|,
name|signal_levels
argument_list|)
expr_stmt|;
return|return
name|EDP_LINK_TRAIN_400_600MV_0DB_SNB_B
return|;
block|}
block|}
end_function

begin_comment
comment|/* Gen7's DP voltage swing and pre-emphasis control */
end_comment

begin_function
specifier|static
name|uint32_t
name|intel_gen7_edp_signal_levels
parameter_list|(
name|uint8_t
name|train_set
parameter_list|)
block|{
name|int
name|signal_levels
init|=
name|train_set
operator|&
operator|(
name|DP_TRAIN_VOLTAGE_SWING_MASK
operator||
name|DP_TRAIN_PRE_EMPHASIS_MASK
operator|)
decl_stmt|;
switch|switch
condition|(
name|signal_levels
condition|)
block|{
case|case
name|DP_TRAIN_VOLTAGE_SWING_400
operator||
name|DP_TRAIN_PRE_EMPHASIS_0
case|:
return|return
name|EDP_LINK_TRAIN_400MV_0DB_IVB
return|;
case|case
name|DP_TRAIN_VOLTAGE_SWING_400
operator||
name|DP_TRAIN_PRE_EMPHASIS_3_5
case|:
return|return
name|EDP_LINK_TRAIN_400MV_3_5DB_IVB
return|;
case|case
name|DP_TRAIN_VOLTAGE_SWING_400
operator||
name|DP_TRAIN_PRE_EMPHASIS_6
case|:
return|return
name|EDP_LINK_TRAIN_400MV_6DB_IVB
return|;
case|case
name|DP_TRAIN_VOLTAGE_SWING_600
operator||
name|DP_TRAIN_PRE_EMPHASIS_0
case|:
return|return
name|EDP_LINK_TRAIN_600MV_0DB_IVB
return|;
case|case
name|DP_TRAIN_VOLTAGE_SWING_600
operator||
name|DP_TRAIN_PRE_EMPHASIS_3_5
case|:
return|return
name|EDP_LINK_TRAIN_600MV_3_5DB_IVB
return|;
case|case
name|DP_TRAIN_VOLTAGE_SWING_800
operator||
name|DP_TRAIN_PRE_EMPHASIS_0
case|:
return|return
name|EDP_LINK_TRAIN_800MV_0DB_IVB
return|;
case|case
name|DP_TRAIN_VOLTAGE_SWING_800
operator||
name|DP_TRAIN_PRE_EMPHASIS_3_5
case|:
return|return
name|EDP_LINK_TRAIN_800MV_3_5DB_IVB
return|;
default|default:
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unsupported voltage swing/pre-emphasis level:"
literal|"0x%x\n"
argument_list|,
name|signal_levels
argument_list|)
expr_stmt|;
return|return
name|EDP_LINK_TRAIN_500MV_0DB_IVB
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|intel_get_lane_status
parameter_list|(
name|uint8_t
name|link_status
index|[
name|DP_LINK_STATUS_SIZE
index|]
parameter_list|,
name|int
name|lane
parameter_list|)
block|{
name|int
name|s
init|=
operator|(
name|lane
operator|&
literal|1
operator|)
operator|*
literal|4
decl_stmt|;
name|uint8_t
name|l
init|=
name|link_status
index|[
name|lane
operator|>>
literal|1
index|]
decl_stmt|;
return|return
operator|(
name|l
operator|>>
name|s
operator|)
operator|&
literal|0xf
return|;
block|}
end_function

begin_comment
comment|/* Check for clock recovery is done on all channels */
end_comment

begin_function
specifier|static
name|bool
name|intel_clock_recovery_ok
parameter_list|(
name|uint8_t
name|link_status
index|[
name|DP_LINK_STATUS_SIZE
index|]
parameter_list|,
name|int
name|lane_count
parameter_list|)
block|{
name|int
name|lane
decl_stmt|;
name|uint8_t
name|lane_status
decl_stmt|;
for|for
control|(
name|lane
operator|=
literal|0
init|;
name|lane
operator|<
name|lane_count
condition|;
name|lane
operator|++
control|)
block|{
name|lane_status
operator|=
name|intel_get_lane_status
argument_list|(
name|link_status
argument_list|,
name|lane
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lane_status
operator|&
name|DP_LANE_CR_DONE
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Check to see if channel eq is done on all channels */
end_comment

begin_define
define|#
directive|define
name|CHANNEL_EQ_BITS
value|(DP_LANE_CR_DONE|\ 			 DP_LANE_CHANNEL_EQ_DONE|\ 			 DP_LANE_SYMBOL_LOCKED)
end_define

begin_function
specifier|static
name|bool
name|intel_channel_eq_ok
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|uint8_t
name|link_status
index|[
name|DP_LINK_STATUS_SIZE
index|]
parameter_list|)
block|{
name|uint8_t
name|lane_align
decl_stmt|;
name|uint8_t
name|lane_status
decl_stmt|;
name|int
name|lane
decl_stmt|;
name|lane_align
operator|=
name|intel_dp_link_status
argument_list|(
name|link_status
argument_list|,
name|DP_LANE_ALIGN_STATUS_UPDATED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lane_align
operator|&
name|DP_INTERLANE_ALIGN_DONE
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
for|for
control|(
name|lane
operator|=
literal|0
init|;
name|lane
operator|<
name|intel_dp
operator|->
name|lane_count
condition|;
name|lane
operator|++
control|)
block|{
name|lane_status
operator|=
name|intel_get_lane_status
argument_list|(
name|link_status
argument_list|,
name|lane
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lane_status
operator|&
name|CHANNEL_EQ_BITS
operator|)
operator|!=
name|CHANNEL_EQ_BITS
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_dp_set_link_train
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|uint32_t
name|dp_reg_value
parameter_list|,
name|uint8_t
name|dp_train_pat
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|I915_WRITE
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|,
name|dp_reg_value
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|)
expr_stmt|;
name|intel_dp_aux_native_write_1
argument_list|(
name|intel_dp
argument_list|,
name|DP_TRAINING_PATTERN_SET
argument_list|,
name|dp_train_pat
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_dp_aux_native_write
argument_list|(
name|intel_dp
argument_list|,
name|DP_TRAINING_LANE0_SET
argument_list|,
name|intel_dp
operator|->
name|train_set
argument_list|,
name|intel_dp
operator|->
name|lane_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|intel_dp
operator|->
name|lane_count
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Enable corresponding port and start training pattern 1 */
end_comment

begin_function
specifier|static
name|void
name|intel_dp_start_link_train
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|crtc
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint8_t
name|voltage
decl_stmt|;
name|bool
name|clock_recovery
init|=
name|false
decl_stmt|;
name|int
name|voltage_tries
decl_stmt|,
name|loop_tries
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|uint32_t
name|DP
init|=
name|intel_dp
operator|->
name|DP
decl_stmt|;
comment|/* Enable output, wait for it to become active */
name|I915_WRITE
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|,
name|intel_dp
operator|->
name|DP
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|)
expr_stmt|;
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|intel_crtc
operator|->
name|pipe
argument_list|)
expr_stmt|;
comment|/* Write the link configuration data */
name|intel_dp_aux_native_write
argument_list|(
name|intel_dp
argument_list|,
name|DP_LINK_BW_SET
argument_list|,
name|intel_dp
operator|->
name|link_configuration
argument_list|,
name|DP_LINK_CONFIGURATION_SIZE
argument_list|)
expr_stmt|;
name|DP
operator||=
name|DP_PORT_EN
expr_stmt|;
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|||
operator|!
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
operator|)
condition|)
name|DP
operator|&=
operator|~
name|DP_LINK_TRAIN_MASK_CPT
expr_stmt|;
else|else
name|DP
operator|&=
operator|~
name|DP_LINK_TRAIN_MASK
expr_stmt|;
name|memset
argument_list|(
name|intel_dp
operator|->
name|train_set
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|voltage
operator|=
literal|0xff
expr_stmt|;
name|voltage_tries
operator|=
literal|0
expr_stmt|;
name|loop_tries
operator|=
literal|0
expr_stmt|;
name|clock_recovery
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Use intel_dp->train_set[0] to set the voltage and pre emphasis values */
name|uint8_t
name|link_status
index|[
name|DP_LINK_STATUS_SIZE
index|]
decl_stmt|;
name|uint32_t
name|signal_levels
decl_stmt|;
if|if
condition|(
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|&&
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|signal_levels
operator|=
name|intel_gen7_edp_signal_levels
argument_list|(
name|intel_dp
operator|->
name|train_set
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DP
operator|=
operator|(
name|DP
operator|&
operator|~
name|EDP_LINK_TRAIN_VOL_EMP_MASK_IVB
operator|)
operator||
name|signal_levels
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|&&
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|signal_levels
operator|=
name|intel_gen6_edp_signal_levels
argument_list|(
name|intel_dp
operator|->
name|train_set
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DP
operator|=
operator|(
name|DP
operator|&
operator|~
name|EDP_LINK_TRAIN_VOL_EMP_MASK_SNB
operator|)
operator||
name|signal_levels
expr_stmt|;
block|}
else|else
block|{
name|signal_levels
operator|=
name|intel_dp_signal_levels
argument_list|(
name|intel_dp
operator|->
name|train_set
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"training pattern 1 signal levels %08x\n"
argument_list|,
name|signal_levels
argument_list|)
expr_stmt|;
name|DP
operator|=
operator|(
name|DP
operator|&
operator|~
operator|(
name|DP_VOLTAGE_MASK
operator||
name|DP_PRE_EMPHASIS_MASK
operator|)
operator|)
operator||
name|signal_levels
expr_stmt|;
block|}
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|||
operator|!
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
operator|)
condition|)
name|reg
operator|=
name|DP
operator||
name|DP_LINK_TRAIN_PAT_1_CPT
expr_stmt|;
else|else
name|reg
operator|=
name|DP
operator||
name|DP_LINK_TRAIN_PAT_1
expr_stmt|;
if|if
condition|(
operator|!
name|intel_dp_set_link_train
argument_list|(
name|intel_dp
argument_list|,
name|reg
argument_list|,
name|DP_TRAINING_PATTERN_1
argument_list|)
condition|)
break|break;
comment|/* Set training pattern 1 */
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_dp_get_link_status
argument_list|(
name|intel_dp
argument_list|,
name|link_status
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to get link status\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|intel_clock_recovery_ok
argument_list|(
name|link_status
argument_list|,
name|intel_dp
operator|->
name|lane_count
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"clock recovery OK\n"
argument_list|)
expr_stmt|;
name|clock_recovery
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|/* Check to see if we've tried the max voltage */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|intel_dp
operator|->
name|lane_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|intel_dp
operator|->
name|train_set
index|[
name|i
index|]
operator|&
name|DP_TRAIN_MAX_SWING_REACHED
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|intel_dp
operator|->
name|lane_count
condition|)
block|{
operator|++
name|loop_tries
expr_stmt|;
if|if
condition|(
name|loop_tries
operator|==
literal|5
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"too many full retries, give up\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|memset
argument_list|(
name|intel_dp
operator|->
name|train_set
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|voltage_tries
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Check to see if we've tried the same voltage 5 times */
if|if
condition|(
operator|(
name|intel_dp
operator|->
name|train_set
index|[
literal|0
index|]
operator|&
name|DP_TRAIN_VOLTAGE_SWING_MASK
operator|)
operator|==
name|voltage
condition|)
block|{
operator|++
name|voltage_tries
expr_stmt|;
if|if
condition|(
name|voltage_tries
operator|==
literal|5
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"too many voltage retries, give up\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|voltage_tries
operator|=
literal|0
expr_stmt|;
name|voltage
operator|=
name|intel_dp
operator|->
name|train_set
index|[
literal|0
index|]
operator|&
name|DP_TRAIN_VOLTAGE_SWING_MASK
expr_stmt|;
comment|/* Compute new intel_dp->train_set as requested by target */
name|intel_get_adjust_train
argument_list|(
name|intel_dp
argument_list|,
name|link_status
argument_list|)
expr_stmt|;
block|}
name|intel_dp
operator|->
name|DP
operator|=
name|DP
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_dp_complete_link_train
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|bool
name|channel_eq
init|=
name|false
decl_stmt|;
name|int
name|tries
decl_stmt|,
name|cr_tries
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|uint32_t
name|DP
init|=
name|intel_dp
operator|->
name|DP
decl_stmt|;
comment|/* channel equalization */
name|tries
operator|=
literal|0
expr_stmt|;
name|cr_tries
operator|=
literal|0
expr_stmt|;
name|channel_eq
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Use intel_dp->train_set[0] to set the voltage and pre emphasis values */
name|uint32_t
name|signal_levels
decl_stmt|;
name|uint8_t
name|link_status
index|[
name|DP_LINK_STATUS_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|cr_tries
operator|>
literal|5
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to train DP, aborting\n"
argument_list|)
expr_stmt|;
name|intel_dp_link_down
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|&&
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|signal_levels
operator|=
name|intel_gen7_edp_signal_levels
argument_list|(
name|intel_dp
operator|->
name|train_set
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DP
operator|=
operator|(
name|DP
operator|&
operator|~
name|EDP_LINK_TRAIN_VOL_EMP_MASK_IVB
operator|)
operator||
name|signal_levels
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|&&
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|signal_levels
operator|=
name|intel_gen6_edp_signal_levels
argument_list|(
name|intel_dp
operator|->
name|train_set
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DP
operator|=
operator|(
name|DP
operator|&
operator|~
name|EDP_LINK_TRAIN_VOL_EMP_MASK_SNB
operator|)
operator||
name|signal_levels
expr_stmt|;
block|}
else|else
block|{
name|signal_levels
operator|=
name|intel_dp_signal_levels
argument_list|(
name|intel_dp
operator|->
name|train_set
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DP
operator|=
operator|(
name|DP
operator|&
operator|~
operator|(
name|DP_VOLTAGE_MASK
operator||
name|DP_PRE_EMPHASIS_MASK
operator|)
operator|)
operator||
name|signal_levels
expr_stmt|;
block|}
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|||
operator|!
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
operator|)
condition|)
name|reg
operator|=
name|DP
operator||
name|DP_LINK_TRAIN_PAT_2_CPT
expr_stmt|;
else|else
name|reg
operator|=
name|DP
operator||
name|DP_LINK_TRAIN_PAT_2
expr_stmt|;
comment|/* channel eq pattern */
if|if
condition|(
operator|!
name|intel_dp_set_link_train
argument_list|(
name|intel_dp
argument_list|,
name|reg
argument_list|,
name|DP_TRAINING_PATTERN_2
argument_list|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|400
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_dp_get_link_status
argument_list|(
name|intel_dp
argument_list|,
name|link_status
argument_list|)
condition|)
break|break;
comment|/* Make sure clock is still ok */
if|if
condition|(
operator|!
name|intel_clock_recovery_ok
argument_list|(
name|link_status
argument_list|,
name|intel_dp
operator|->
name|lane_count
argument_list|)
condition|)
block|{
name|intel_dp_start_link_train
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|cr_tries
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|intel_channel_eq_ok
argument_list|(
name|intel_dp
argument_list|,
name|link_status
argument_list|)
condition|)
block|{
name|channel_eq
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|/* Try 5 times, then try clock recovery if that fails */
if|if
condition|(
name|tries
operator|>
literal|5
condition|)
block|{
name|intel_dp_link_down
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|intel_dp_start_link_train
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|tries
operator|=
literal|0
expr_stmt|;
name|cr_tries
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Compute new intel_dp->train_set as requested by target */
name|intel_get_adjust_train
argument_list|(
name|intel_dp
argument_list|,
name|link_status
argument_list|)
expr_stmt|;
operator|++
name|tries
expr_stmt|;
block|}
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|||
operator|!
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
operator|)
condition|)
name|reg
operator|=
name|DP
operator||
name|DP_LINK_TRAIN_OFF_CPT
expr_stmt|;
else|else
name|reg
operator|=
name|DP
operator||
name|DP_LINK_TRAIN_OFF
expr_stmt|;
name|I915_WRITE
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|)
expr_stmt|;
name|intel_dp_aux_native_write_1
argument_list|(
name|intel_dp
argument_list|,
name|DP_TRAINING_PATTERN_SET
argument_list|,
name|DP_TRAINING_PATTERN_DISABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_dp_link_down
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|DP
init|=
name|intel_dp
operator|->
name|DP
decl_stmt|;
if|if
condition|(
operator|(
name|I915_READ
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|)
operator|&
name|DP_PORT_EN
operator|)
operator|==
literal|0
condition|)
return|return;
name|DRM_DEBUG_KMS
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|DP
operator|&=
operator|~
name|DP_PLL_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|,
name|DP
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|||
operator|!
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
operator|)
condition|)
block|{
name|DP
operator|&=
operator|~
name|DP_LINK_TRAIN_MASK_CPT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|,
name|DP
operator||
name|DP_LINK_TRAIN_PAT_IDLE_CPT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DP
operator|&=
operator|~
name|DP_LINK_TRAIN_MASK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|,
name|DP
operator||
name|DP_LINK_TRAIN_PAT_IDLE
argument_list|)
expr_stmt|;
block|}
name|POSTING_READ
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|)
expr_stmt|;
name|drm_msleep
argument_list|(
literal|17
argument_list|,
literal|"915dlo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
if|if
condition|(
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|||
operator|!
name|is_cpu_edp
argument_list|(
name|intel_dp
argument_list|)
operator|)
condition|)
name|DP
operator||=
name|DP_LINK_TRAIN_OFF_CPT
expr_stmt|;
else|else
name|DP
operator||=
name|DP_LINK_TRAIN_OFF
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|HAS_PCH_CPT
argument_list|(
name|dev
argument_list|)
operator|&&
name|I915_READ
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|)
operator|&
name|DP_PIPEB_SELECT
condition|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|crtc
decl_stmt|;
comment|/* Hardware workaround: leaving our transcoder select 		 * set to transcoder B while it's off will prevent the 		 * corresponding HDMI output on transcoder A. 		 * 		 * Combine this with another hardware workaround: 		 * transcoder select bit can only be cleared while the 		 * port is enabled. 		 */
name|DP
operator|&=
operator|~
name|DP_PIPEB_SELECT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|,
name|DP
argument_list|)
expr_stmt|;
comment|/* Changes to enable or select take place the vblank 		 * after being written. 		 */
if|if
condition|(
name|crtc
operator|==
name|NULL
condition|)
block|{
comment|/* We can arrive here never having been attached 			 * to a CRTC, for instance, due to inheriting 			 * random state from the BIOS. 			 * 			 * If the pipe is not running, play safe and 			 * wait for the clocks to stabilise before 			 * continuing. 			 */
name|POSTING_READ
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|)
expr_stmt|;
name|drm_msleep
argument_list|(
literal|50
argument_list|,
literal|"915dla"
argument_list|)
expr_stmt|;
block|}
else|else
name|intel_wait_for_vblank
argument_list|(
name|dev
argument_list|,
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
name|DP
operator|&=
operator|~
name|DP_AUDIO_OUTPUT_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|,
name|DP
operator|&
operator|~
name|DP_PORT_EN
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|intel_dp
operator|->
name|output_reg
argument_list|)
expr_stmt|;
name|drm_msleep
argument_list|(
name|intel_dp
operator|->
name|panel_power_down_delay
argument_list|,
literal|"915ldo"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_dp_get_dpcd
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
if|if
condition|(
name|intel_dp_aux_native_read_retry
argument_list|(
name|intel_dp
argument_list|,
literal|0x000
argument_list|,
name|intel_dp
operator|->
name|dpcd
argument_list|,
sizeof|sizeof
argument_list|(
name|intel_dp
operator|->
name|dpcd
argument_list|)
argument_list|)
operator|&&
operator|(
name|intel_dp
operator|->
name|dpcd
index|[
name|DP_DPCD_REV
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_dp_probe_oui
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|u8
name|buf
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|intel_dp
operator|->
name|dpcd
index|[
name|DP_DOWN_STREAM_PORT_COUNT
index|]
operator|&
name|DP_OUI_SUPPORT
operator|)
condition|)
return|return;
if|if
condition|(
name|intel_dp_aux_native_read_retry
argument_list|(
name|intel_dp
argument_list|,
name|DP_SINK_OUI
argument_list|,
name|buf
argument_list|,
literal|3
argument_list|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"Sink OUI: %02x%02x%02x\n"
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_dp_aux_native_read_retry
argument_list|(
name|intel_dp
argument_list|,
name|DP_BRANCH_OUI
argument_list|,
name|buf
argument_list|,
literal|3
argument_list|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"Branch OUI: %02x%02x%02x\n"
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_dp_get_sink_irq
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|u8
modifier|*
name|sink_irq_vector
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|intel_dp_aux_native_read_retry
argument_list|(
name|intel_dp
argument_list|,
name|DP_DEVICE_SERVICE_IRQ_VECTOR
argument_list|,
name|sink_irq_vector
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_dp_handle_test_request
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
comment|/* NAK by default */
name|intel_dp_aux_native_write_1
argument_list|(
name|intel_dp
argument_list|,
name|DP_TEST_RESPONSE
argument_list|,
name|DP_TEST_ACK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * According to DP spec  * 5.1.2:  *  1. Read DPCD  *  2. Configure link according to Receiver Capabilities  *  3. Use Link Training from 2.5.3.3 and 3.5.1.3  *  4. Check link status on receipt of hot-plug interrupt  */
end_comment

begin_function
specifier|static
name|void
name|intel_dp_check_link_status
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|u8
name|sink_irq_vector
decl_stmt|;
name|u8
name|link_status
index|[
name|DP_LINK_STATUS_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|intel_dp
operator|->
name|dpms_mode
operator|!=
name|DRM_MODE_DPMS_ON
condition|)
return|return;
if|if
condition|(
operator|!
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|crtc
condition|)
return|return;
comment|/* Try to read receiver status if the link appears to be up */
if|if
condition|(
operator|!
name|intel_dp_get_link_status
argument_list|(
name|intel_dp
argument_list|,
name|link_status
argument_list|)
condition|)
block|{
name|intel_dp_link_down
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now read the DPCD to see if it's actually running */
if|if
condition|(
operator|!
name|intel_dp_get_dpcd
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|intel_dp_link_down
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try to read the source of the interrupt */
if|if
condition|(
name|intel_dp
operator|->
name|dpcd
index|[
name|DP_DPCD_REV
index|]
operator|>=
literal|0x11
operator|&&
name|intel_dp_get_sink_irq
argument_list|(
name|intel_dp
argument_list|,
operator|&
name|sink_irq_vector
argument_list|)
condition|)
block|{
comment|/* Clear interrupt source */
name|intel_dp_aux_native_write_1
argument_list|(
name|intel_dp
argument_list|,
name|DP_DEVICE_SERVICE_IRQ_VECTOR
argument_list|,
name|sink_irq_vector
argument_list|)
expr_stmt|;
if|if
condition|(
name|sink_irq_vector
operator|&
name|DP_AUTOMATED_TEST_REQUEST
condition|)
name|intel_dp_handle_test_request
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sink_irq_vector
operator|&
operator|(
name|DP_CP_IRQ
operator||
name|DP_SINK_SPECIFIC_IRQ
operator|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"CP or sink specific irq unhandled\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|intel_channel_eq_ok
argument_list|(
name|intel_dp
argument_list|,
name|link_status
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"%s: channel EQ not ok, retraining\n"
argument_list|,
name|drm_get_encoder_name
argument_list|(
operator|&
name|intel_dp
operator|->
name|base
operator|.
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|intel_dp_start_link_train
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|intel_dp_complete_link_train
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|drm_connector_status
name|intel_dp_detect_dpcd
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
if|if
condition|(
name|intel_dp_get_dpcd
argument_list|(
name|intel_dp
argument_list|)
condition|)
return|return
name|connector_status_connected
return|;
return|return
name|connector_status_disconnected
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|drm_connector_status
name|ironlake_dp_detect
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|enum
name|drm_connector_status
name|status
decl_stmt|;
comment|/* Can't disconnect eDP, but you can close the lid... */
if|if
condition|(
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|status
operator|=
name|intel_panel_detect
argument_list|(
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|connector_status_unknown
condition|)
name|status
operator|=
name|connector_status_connected
expr_stmt|;
return|return
name|status
return|;
block|}
return|return
name|intel_dp_detect_dpcd
argument_list|(
name|intel_dp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|drm_connector_status
name|g4x_dp_detect
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|,
name|bit
decl_stmt|;
switch|switch
condition|(
name|intel_dp
operator|->
name|output_reg
condition|)
block|{
case|case
name|DP_B
case|:
name|bit
operator|=
name|DPB_HOTPLUG_INT_STATUS
expr_stmt|;
break|break;
case|case
name|DP_C
case|:
name|bit
operator|=
name|DPC_HOTPLUG_INT_STATUS
expr_stmt|;
break|break;
case|case
name|DP_D
case|:
name|bit
operator|=
name|DPD_HOTPLUG_INT_STATUS
expr_stmt|;
break|break;
default|default:
return|return
name|connector_status_unknown
return|;
block|}
name|temp
operator|=
name|I915_READ
argument_list|(
name|PORT_HOTPLUG_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|&
name|bit
operator|)
operator|==
literal|0
condition|)
return|return
name|connector_status_disconnected
return|;
return|return
name|intel_dp_detect_dpcd
argument_list|(
name|intel_dp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|edid
modifier|*
name|intel_dp_get_edid
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|device_t
name|adapter
parameter_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|intel_attached_dp
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|edid
modifier|*
name|edid
decl_stmt|;
name|ironlake_edp_panel_vdd_on
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|edid
operator|=
name|drm_get_edid
argument_list|(
name|connector
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_vdd_off
argument_list|(
name|intel_dp
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|edid
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_dp_get_edid_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|device_t
name|adapter
parameter_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|intel_attached_dp
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ironlake_edp_panel_vdd_on
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_ddc_get_modes
argument_list|(
name|connector
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_vdd_off
argument_list|(
name|intel_dp
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Uses CRT_HOTPLUG_EN and CRT_HOTPLUG_STAT to detect DP connection.  *  * \return true if DP port is connected.  * \return false if DP port is disconnected.  */
end_comment

begin_function
specifier|static
name|enum
name|drm_connector_status
name|intel_dp_detect
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|intel_attached_dp
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|enum
name|drm_connector_status
name|status
decl_stmt|;
name|struct
name|edid
modifier|*
name|edid
init|=
name|NULL
decl_stmt|;
name|intel_dp
operator|->
name|has_audio
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
name|status
operator|=
name|ironlake_dp_detect
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|g4x_dp_detect
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|connector_status_connected
condition|)
return|return
name|status
return|;
name|intel_dp_probe_oui
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_dp
operator|->
name|force_audio
operator|!=
name|HDMI_AUDIO_AUTO
condition|)
block|{
name|intel_dp
operator|->
name|has_audio
operator|=
operator|(
name|intel_dp
operator|->
name|force_audio
operator|==
name|HDMI_AUDIO_ON
operator|)
expr_stmt|;
block|}
else|else
block|{
name|edid
operator|=
name|intel_dp_get_edid
argument_list|(
name|connector
argument_list|,
name|intel_dp
operator|->
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
condition|)
block|{
name|intel_dp
operator|->
name|has_audio
operator|=
name|drm_detect_monitor_audio
argument_list|(
name|edid
argument_list|)
expr_stmt|;
name|connector
operator|->
name|display_info
operator|.
name|raw_edid
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|edid
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|connector_status_connected
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_dp_get_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|intel_attached_dp
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* We should parse the EDID data and find out if it has an audio sink 	 */
name|ret
operator|=
name|intel_dp_get_edid_modes
argument_list|(
name|connector
argument_list|,
name|intel_dp
operator|->
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
operator|&&
operator|!
name|intel_dp
operator|->
name|panel_fixed_mode
condition|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|newmode
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|newmode
argument_list|,
argument|&connector->probed_modes
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|(
name|newmode
operator|->
name|type
operator|&
name|DRM_MODE_TYPE_PREFERRED
operator|)
condition|)
block|{
name|intel_dp
operator|->
name|panel_fixed_mode
operator|=
name|drm_mode_duplicate
argument_list|(
name|dev
argument_list|,
name|newmode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
comment|/* if eDP has no EDID, try to use fixed panel mode from VBT */
if|if
condition|(
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
comment|/* initialize panel mode from VBT if available for eDP */
if|if
condition|(
name|intel_dp
operator|->
name|panel_fixed_mode
operator|==
name|NULL
operator|&&
name|dev_priv
operator|->
name|lfp_lvds_vbt_mode
operator|!=
name|NULL
condition|)
block|{
name|intel_dp
operator|->
name|panel_fixed_mode
operator|=
name|drm_mode_duplicate
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|lfp_lvds_vbt_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_dp
operator|->
name|panel_fixed_mode
condition|)
block|{
name|intel_dp
operator|->
name|panel_fixed_mode
operator|->
name|type
operator||=
name|DRM_MODE_TYPE_PREFERRED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|intel_dp
operator|->
name|panel_fixed_mode
condition|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|mode
operator|=
name|drm_mode_duplicate
argument_list|(
name|dev
argument_list|,
name|intel_dp
operator|->
name|panel_fixed_mode
argument_list|)
expr_stmt|;
name|drm_mode_probed_add
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_dp_detect_audio
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|intel_attached_dp
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|edid
modifier|*
name|edid
decl_stmt|;
name|bool
name|has_audio
init|=
name|false
decl_stmt|;
name|edid
operator|=
name|intel_dp_get_edid
argument_list|(
name|connector
argument_list|,
name|intel_dp
operator|->
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
condition|)
block|{
name|has_audio
operator|=
name|drm_detect_monitor_audio
argument_list|(
name|edid
argument_list|)
expr_stmt|;
name|connector
operator|->
name|display_info
operator|.
name|raw_edid
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|edid
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
return|return
name|has_audio
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_dp_set_property
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_property
modifier|*
name|property
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|connector
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|intel_attached_dp
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|drm_connector_property_set_value
argument_list|(
name|connector
argument_list|,
name|property
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|property
operator|==
name|dev_priv
operator|->
name|force_audio_property
condition|)
block|{
name|int
name|i
init|=
name|val
decl_stmt|;
name|bool
name|has_audio
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|intel_dp
operator|->
name|force_audio
condition|)
return|return
literal|0
return|;
name|intel_dp
operator|->
name|force_audio
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|HDMI_AUDIO_AUTO
condition|)
name|has_audio
operator|=
name|intel_dp_detect_audio
argument_list|(
name|connector
argument_list|)
expr_stmt|;
else|else
name|has_audio
operator|=
operator|(
name|i
operator|==
name|HDMI_AUDIO_ON
operator|)
expr_stmt|;
if|if
condition|(
name|has_audio
operator|==
name|intel_dp
operator|->
name|has_audio
condition|)
return|return
literal|0
return|;
name|intel_dp
operator|->
name|has_audio
operator|=
name|has_audio
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|property
operator|==
name|dev_priv
operator|->
name|broadcast_rgb_property
condition|)
block|{
if|if
condition|(
name|val
operator|==
operator|!
operator|!
name|intel_dp
operator|->
name|color_range
condition|)
return|return
literal|0
return|;
name|intel_dp
operator|->
name|color_range
operator|=
name|val
condition|?
name|DP_COLOR_RANGE_16_235
else|:
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
return|return
operator|-
name|EINVAL
return|;
name|done
label|:
if|if
condition|(
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|crtc
condition|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|crtc
decl_stmt|;
name|drm_crtc_helper_set_mode
argument_list|(
name|crtc
argument_list|,
operator|&
name|crtc
operator|->
name|mode
argument_list|,
name|crtc
operator|->
name|x
argument_list|,
name|crtc
operator|->
name|y
argument_list|,
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_dp_destroy
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|intel_dpd_is_edp
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_panel_destroy_backlight
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|drm_sysfs_connector_remove(connector);
endif|#
directive|endif
name|drm_connector_cleanup
argument_list|(
name|connector
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|connector
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_dp_encoder_destroy
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|intel_dp
modifier|*
name|intel_dp
decl_stmt|;
name|intel_dp
operator|=
name|enc_to_intel_dp
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|dev
operator|=
name|encoder
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|intel_dp
operator|->
name|dp_iic_bus
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|intel_dp
operator|->
name|adapter
operator|!=
name|NULL
condition|)
block|{
name|device_delete_child
argument_list|(
name|intel_dp
operator|->
name|dp_iic_bus
argument_list|,
name|intel_dp
operator|->
name|adapter
argument_list|)
expr_stmt|;
block|}
name|device_delete_child
argument_list|(
name|dev
operator|->
name|device
argument_list|,
name|intel_dp
operator|->
name|dp_iic_bus
argument_list|)
expr_stmt|;
block|}
name|drm_encoder_cleanup
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|intel_dp
operator|->
name|base
operator|.
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|taskqueue_cancel_timeout
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|intel_dp
operator|->
name|panel_vdd_task
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|taskqueue_drain_timeout
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|intel_dp
operator|->
name|panel_vdd_task
argument_list|)
expr_stmt|;
name|ironlake_panel_vdd_off_sync
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|intel_dp
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_encoder_helper_funcs
name|intel_dp_helper_funcs
init|=
block|{
operator|.
name|dpms
operator|=
name|intel_dp_dpms
block|,
operator|.
name|mode_fixup
operator|=
name|intel_dp_mode_fixup
block|,
operator|.
name|prepare
operator|=
name|intel_dp_prepare
block|,
operator|.
name|mode_set
operator|=
name|intel_dp_mode_set
block|,
operator|.
name|commit
operator|=
name|intel_dp_commit
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_connector_funcs
name|intel_dp_connector_funcs
init|=
block|{
operator|.
name|dpms
operator|=
name|drm_helper_connector_dpms
block|,
operator|.
name|detect
operator|=
name|intel_dp_detect
block|,
operator|.
name|fill_modes
operator|=
name|drm_helper_probe_single_connector_modes
block|,
operator|.
name|set_property
operator|=
name|intel_dp_set_property
block|,
operator|.
name|destroy
operator|=
name|intel_dp_destroy
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_connector_helper_funcs
name|intel_dp_connector_helper_funcs
init|=
block|{
operator|.
name|get_modes
operator|=
name|intel_dp_get_modes
block|,
operator|.
name|mode_valid
operator|=
name|intel_dp_mode_valid
block|,
operator|.
name|best_encoder
operator|=
name|intel_best_encoder
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_encoder_funcs
name|intel_dp_enc_funcs
init|=
block|{
operator|.
name|destroy
operator|=
name|intel_dp_encoder_destroy
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|intel_dp_hot_plug
parameter_list|(
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
parameter_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
init|=
name|container_of
argument_list|(
name|intel_encoder
argument_list|,
expr|struct
name|intel_dp
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|intel_dp_check_link_status
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return which DP Port should be selected for Transcoder DP control */
end_comment

begin_function
name|int
name|intel_trans_dp_port_sel
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|mode_config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&mode_config->encoder_list
argument_list|,
argument|head
argument_list|)
block|{
name|struct
name|intel_dp
modifier|*
name|intel_dp
decl_stmt|;
if|if
condition|(
name|encoder
operator|->
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
name|intel_dp
operator|=
name|enc_to_intel_dp
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_dp
operator|->
name|base
operator|.
name|type
operator|==
name|INTEL_OUTPUT_DISPLAYPORT
operator|||
name|intel_dp
operator|->
name|base
operator|.
name|type
operator|==
name|INTEL_OUTPUT_EDP
condition|)
return|return
name|intel_dp
operator|->
name|output_reg
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* check the VBT to see whether the eDP is on DP-D port */
end_comment

begin_function
name|bool
name|intel_dpd_is_edp
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|child_device_config
modifier|*
name|p_child
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|child_dev_num
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|child_dev_num
condition|;
name|i
operator|++
control|)
block|{
name|p_child
operator|=
name|dev_priv
operator|->
name|child_dev
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|p_child
operator|->
name|dvo_port
operator|==
name|PORT_IDPD
operator|&&
name|p_child
operator|->
name|device_type
operator|==
name|DEVICE_TYPE_eDP
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_dp_add_properties
parameter_list|(
name|struct
name|intel_dp
modifier|*
name|intel_dp
parameter_list|,
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|intel_attach_force_audio_property
argument_list|(
name|connector
argument_list|)
expr_stmt|;
name|intel_attach_broadcast_rgb_property
argument_list|(
name|connector
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_dp_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|output_reg
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|intel_dp
modifier|*
name|intel_dp
decl_stmt|;
name|struct
name|intel_encoder
modifier|*
name|intel_encoder
decl_stmt|;
name|struct
name|intel_connector
modifier|*
name|intel_connector
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|int
name|type
decl_stmt|;
name|intel_dp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intel_dp
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|intel_dp
operator|->
name|output_reg
operator|=
name|output_reg
expr_stmt|;
name|intel_dp
operator|->
name|dpms_mode
operator|=
operator|-
literal|1
expr_stmt|;
name|intel_connector
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intel_connector
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|intel_encoder
operator|=
operator|&
name|intel_dp
operator|->
name|base
expr_stmt|;
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
operator|&&
name|output_reg
operator|==
name|PCH_DP_D
condition|)
if|if
condition|(
name|intel_dpd_is_edp
argument_list|(
name|dev
argument_list|)
condition|)
name|intel_dp
operator|->
name|is_pch_edp
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|output_reg
operator|==
name|DP_A
operator|||
name|is_pch_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|type
operator|=
name|DRM_MODE_CONNECTOR_eDP
expr_stmt|;
name|intel_encoder
operator|->
name|type
operator|=
name|INTEL_OUTPUT_EDP
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|DRM_MODE_CONNECTOR_DisplayPort
expr_stmt|;
name|intel_encoder
operator|->
name|type
operator|=
name|INTEL_OUTPUT_DISPLAYPORT
expr_stmt|;
block|}
name|connector
operator|=
operator|&
name|intel_connector
operator|->
name|base
expr_stmt|;
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
name|connector
argument_list|,
operator|&
name|intel_dp_connector_funcs
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
name|connector
argument_list|,
operator|&
name|intel_dp_connector_helper_funcs
argument_list|)
expr_stmt|;
name|connector
operator|->
name|polled
operator|=
name|DRM_CONNECTOR_POLL_HPD
expr_stmt|;
if|if
condition|(
name|output_reg
operator|==
name|DP_B
operator|||
name|output_reg
operator|==
name|PCH_DP_B
condition|)
name|intel_encoder
operator|->
name|clone_mask
operator|=
operator|(
literal|1
operator|<<
name|INTEL_DP_B_CLONE_BIT
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|output_reg
operator|==
name|DP_C
operator|||
name|output_reg
operator|==
name|PCH_DP_C
condition|)
name|intel_encoder
operator|->
name|clone_mask
operator|=
operator|(
literal|1
operator|<<
name|INTEL_DP_C_CLONE_BIT
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|output_reg
operator|==
name|DP_D
operator|||
name|output_reg
operator|==
name|PCH_DP_D
condition|)
name|intel_encoder
operator|->
name|clone_mask
operator|=
operator|(
literal|1
operator|<<
name|INTEL_DP_D_CLONE_BIT
operator|)
expr_stmt|;
if|if
condition|(
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|intel_encoder
operator|->
name|clone_mask
operator|=
operator|(
literal|1
operator|<<
name|INTEL_EDP_CLONE_BIT
operator|)
expr_stmt|;
name|TIMEOUT_TASK_INIT
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|intel_dp
operator|->
name|panel_vdd_task
argument_list|,
literal|0
argument_list|,
name|ironlake_panel_vdd_work
argument_list|,
name|intel_dp
argument_list|)
expr_stmt|;
block|}
name|intel_encoder
operator|->
name|crtc_mask
operator|=
operator|(
literal|1
operator|<<
literal|0
operator|)
operator||
operator|(
literal|1
operator|<<
literal|1
operator|)
operator||
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
name|connector
operator|->
name|interlace_allowed
operator|=
name|true
expr_stmt|;
name|connector
operator|->
name|doublescan_allowed
operator|=
literal|0
expr_stmt|;
name|drm_encoder_init
argument_list|(
name|dev
argument_list|,
operator|&
name|intel_encoder
operator|->
name|base
argument_list|,
operator|&
name|intel_dp_enc_funcs
argument_list|,
name|DRM_MODE_ENCODER_TMDS
argument_list|)
expr_stmt|;
name|drm_encoder_helper_add
argument_list|(
operator|&
name|intel_encoder
operator|->
name|base
argument_list|,
operator|&
name|intel_dp_helper_funcs
argument_list|)
expr_stmt|;
name|intel_connector_attach_encoder
argument_list|(
name|intel_connector
argument_list|,
name|intel_encoder
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|drm_sysfs_connector_add(connector);
endif|#
directive|endif
comment|/* Set up the DDC bus. */
switch|switch
condition|(
name|output_reg
condition|)
block|{
case|case
name|DP_A
case|:
name|name
operator|=
literal|"DPDDC-A"
expr_stmt|;
break|break;
case|case
name|DP_B
case|:
case|case
name|PCH_DP_B
case|:
name|dev_priv
operator|->
name|hotplug_supported_mask
operator||=
name|HDMIB_HOTPLUG_INT_STATUS
expr_stmt|;
name|name
operator|=
literal|"DPDDC-B"
expr_stmt|;
break|break;
case|case
name|DP_C
case|:
case|case
name|PCH_DP_C
case|:
name|dev_priv
operator|->
name|hotplug_supported_mask
operator||=
name|HDMIC_HOTPLUG_INT_STATUS
expr_stmt|;
name|name
operator|=
literal|"DPDDC-C"
expr_stmt|;
break|break;
case|case
name|DP_D
case|:
case|case
name|PCH_DP_D
case|:
name|dev_priv
operator|->
name|hotplug_supported_mask
operator||=
name|HDMID_HOTPLUG_INT_STATUS
expr_stmt|;
name|name
operator|=
literal|"DPDDC-D"
expr_stmt|;
break|break;
block|}
comment|/* Cache some DPCD data in the eDP case */
if|if
condition|(
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|bool
name|ret
decl_stmt|;
name|struct
name|edp_power_seq
name|cur
decl_stmt|,
name|vbt
decl_stmt|;
name|u32
name|pp_on
decl_stmt|,
name|pp_off
decl_stmt|,
name|pp_div
decl_stmt|;
name|pp_on
operator|=
name|I915_READ
argument_list|(
name|PCH_PP_ON_DELAYS
argument_list|)
expr_stmt|;
name|pp_off
operator|=
name|I915_READ
argument_list|(
name|PCH_PP_OFF_DELAYS
argument_list|)
expr_stmt|;
name|pp_div
operator|=
name|I915_READ
argument_list|(
name|PCH_PP_DIVISOR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pp_on
operator|||
operator|!
name|pp_off
operator|||
operator|!
name|pp_div
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"bad panel power sequencing delays, disabling panel\n"
argument_list|)
expr_stmt|;
name|intel_dp_encoder_destroy
argument_list|(
operator|&
name|intel_dp
operator|->
name|base
operator|.
name|base
argument_list|)
expr_stmt|;
name|intel_dp_destroy
argument_list|(
operator|&
name|intel_connector
operator|->
name|base
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Pull timing values out of registers */
name|cur
operator|.
name|t1_t3
operator|=
operator|(
name|pp_on
operator|&
name|PANEL_POWER_UP_DELAY_MASK
operator|)
operator|>>
name|PANEL_POWER_UP_DELAY_SHIFT
expr_stmt|;
name|cur
operator|.
name|t8
operator|=
operator|(
name|pp_on
operator|&
name|PANEL_LIGHT_ON_DELAY_MASK
operator|)
operator|>>
name|PANEL_LIGHT_ON_DELAY_SHIFT
expr_stmt|;
name|cur
operator|.
name|t9
operator|=
operator|(
name|pp_off
operator|&
name|PANEL_LIGHT_OFF_DELAY_MASK
operator|)
operator|>>
name|PANEL_LIGHT_OFF_DELAY_SHIFT
expr_stmt|;
name|cur
operator|.
name|t10
operator|=
operator|(
name|pp_off
operator|&
name|PANEL_POWER_DOWN_DELAY_MASK
operator|)
operator|>>
name|PANEL_POWER_DOWN_DELAY_SHIFT
expr_stmt|;
name|cur
operator|.
name|t11_t12
operator|=
operator|(
operator|(
name|pp_div
operator|&
name|PANEL_POWER_CYCLE_DELAY_MASK
operator|)
operator|>>
name|PANEL_POWER_CYCLE_DELAY_SHIFT
operator|)
operator|*
literal|1000
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"cur t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\n"
argument_list|,
name|cur
operator|.
name|t1_t3
argument_list|,
name|cur
operator|.
name|t8
argument_list|,
name|cur
operator|.
name|t9
argument_list|,
name|cur
operator|.
name|t10
argument_list|,
name|cur
operator|.
name|t11_t12
argument_list|)
expr_stmt|;
name|vbt
operator|=
name|dev_priv
operator|->
name|edp
operator|.
name|pps
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"vbt t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\n"
argument_list|,
name|vbt
operator|.
name|t1_t3
argument_list|,
name|vbt
operator|.
name|t8
argument_list|,
name|vbt
operator|.
name|t9
argument_list|,
name|vbt
operator|.
name|t10
argument_list|,
name|vbt
operator|.
name|t11_t12
argument_list|)
expr_stmt|;
define|#
directive|define
name|get_delay
parameter_list|(
name|field
parameter_list|)
value|((max(cur.field, vbt.field) + 9) / 10)
name|intel_dp
operator|->
name|panel_power_up_delay
operator|=
name|get_delay
argument_list|(
name|t1_t3
argument_list|)
expr_stmt|;
name|intel_dp
operator|->
name|backlight_on_delay
operator|=
name|get_delay
argument_list|(
name|t8
argument_list|)
expr_stmt|;
name|intel_dp
operator|->
name|backlight_off_delay
operator|=
name|get_delay
argument_list|(
name|t9
argument_list|)
expr_stmt|;
name|intel_dp
operator|->
name|panel_power_down_delay
operator|=
name|get_delay
argument_list|(
name|t10
argument_list|)
expr_stmt|;
name|intel_dp
operator|->
name|panel_power_cycle_delay
operator|=
name|get_delay
argument_list|(
name|t11_t12
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"panel power up delay %d, power down delay %d, power cycle delay %d\n"
argument_list|,
name|intel_dp
operator|->
name|panel_power_up_delay
argument_list|,
name|intel_dp
operator|->
name|panel_power_down_delay
argument_list|,
name|intel_dp
operator|->
name|panel_power_cycle_delay
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"backlight on delay %d, off delay %d\n"
argument_list|,
name|intel_dp
operator|->
name|backlight_on_delay
argument_list|,
name|intel_dp
operator|->
name|backlight_off_delay
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_vdd_on
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_dp_get_dpcd
argument_list|(
name|intel_dp
argument_list|)
expr_stmt|;
name|ironlake_edp_panel_vdd_off
argument_list|(
name|intel_dp
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|intel_dp
operator|->
name|dpcd
index|[
name|DP_DPCD_REV
index|]
operator|>=
literal|0x11
condition|)
name|dev_priv
operator|->
name|no_aux_handshake
operator|=
name|intel_dp
operator|->
name|dpcd
index|[
name|DP_MAX_DOWNSPREAD
index|]
operator|&
name|DP_NO_AUX_HANDSHAKE_LINK_TRAINING
expr_stmt|;
block|}
else|else
block|{
comment|/* if this fails, presume the device is a ghost */
name|DRM_INFO
argument_list|(
literal|"failed to retrieve link info, disabling eDP\n"
argument_list|)
expr_stmt|;
name|intel_dp_encoder_destroy
argument_list|(
operator|&
name|intel_dp
operator|->
name|base
operator|.
name|base
argument_list|)
expr_stmt|;
name|intel_dp_destroy
argument_list|(
operator|&
name|intel_connector
operator|->
name|base
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|intel_dp_i2c_init
argument_list|(
name|intel_dp
argument_list|,
name|intel_connector
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|intel_encoder
operator|->
name|hot_plug
operator|=
name|intel_dp_hot_plug
expr_stmt|;
if|if
condition|(
name|is_edp
argument_list|(
name|intel_dp
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|int_edp_connector
operator|=
name|connector
expr_stmt|;
name|intel_panel_setup_backlight
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|intel_dp_add_properties
argument_list|(
name|intel_dp
argument_list|,
name|connector
argument_list|)
expr_stmt|;
comment|/* For G4X desktop chip, PEG_BAND_GAP_DATA 3:0 must first be written 	 * 0xd.  Failure to do so will result in spurious interrupts being 	 * generated on the port when a cable is not attached. 	 */
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
operator|&&
operator|!
name|IS_GM45
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|u32
name|temp
init|=
name|I915_READ
argument_list|(
name|PEG_BAND_GAP_DATA
argument_list|)
decl_stmt|;
name|I915_WRITE
argument_list|(
name|PEG_BAND_GAP_DATA
argument_list|,
operator|(
name|temp
operator|&
operator|~
literal|0xf
operator|)
operator||
literal|0xd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

