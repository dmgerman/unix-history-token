begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Â© 2012 Intel Corporation  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  *  * Authors:  *    Eugeni Dodonov<eugeni.dodonov@intel.com>  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_define
define|#
directive|define
name|FORCEWAKE_ACK_TIMEOUT_MS
value|2
end_define

begin_comment
comment|/* FBC, or Frame Buffer Compression, is a technique employed to compress the  * framebuffer contents in-memory, aiming at reducing the required bandwidth  * during in-memory transfers and, therefore, reduce the power packet.  *  * The benefits of FBC are mostly visible with solid backgrounds and  * variation-less patterns.  *  * FBC-related functionality can be enabled by the means of the  * i915.i915_enable_fbc parameter  */
end_comment

begin_function
specifier|static
name|bool
name|intel_crtc_active
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
comment|/* Be paranoid as we can arrive here with only partial 	 * state retrieved from the hardware during setup. 	 */
return|return
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
operator|->
name|active
operator|&&
name|crtc
operator|->
name|fb
operator|&&
name|crtc
operator|->
name|mode
operator|.
name|clock
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i8xx_disable_fbc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|fbc_ctl
decl_stmt|;
comment|/* Disable compression */
name|fbc_ctl
operator|=
name|I915_READ
argument_list|(
name|FBC_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fbc_ctl
operator|&
name|FBC_CTL_EN
operator|)
operator|==
literal|0
condition|)
return|return;
name|fbc_ctl
operator|&=
operator|~
name|FBC_CTL_EN
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FBC_CONTROL
argument_list|,
name|fbc_ctl
argument_list|)
expr_stmt|;
comment|/* Wait for compressing bit to clear */
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|FBC_STATUS
argument_list|)
operator|&
name|FBC_STAT_COMPRESSING
operator|)
operator|==
literal|0
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"FBC idle timed out\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabled FBC\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i8xx_enable_fbc
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|unsigned
name|long
name|interval
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
init|=
name|crtc
operator|->
name|fb
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
init|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|intel_fb
operator|->
name|obj
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|cfb_pitch
decl_stmt|;
name|int
name|plane
decl_stmt|,
name|i
decl_stmt|;
name|u32
name|fbc_ctl
decl_stmt|,
name|fbc_ctl2
decl_stmt|;
name|cfb_pitch
operator|=
name|dev_priv
operator|->
name|cfb_size
operator|/
name|FBC_LL_SIZE
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|<
name|cfb_pitch
condition|)
name|cfb_pitch
operator|=
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
expr_stmt|;
comment|/* FBC_CTL wants 64B units */
name|cfb_pitch
operator|=
operator|(
name|cfb_pitch
operator|/
literal|64
operator|)
operator|-
literal|1
expr_stmt|;
name|plane
operator|=
name|intel_crtc
operator|->
name|plane
operator|==
literal|0
condition|?
name|FBC_CTL_PLANEA
else|:
name|FBC_CTL_PLANEB
expr_stmt|;
comment|/* Clear old tags */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|FBC_LL_SIZE
operator|/
literal|32
operator|)
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|FBC_TAG
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set it up... */
name|fbc_ctl2
operator|=
name|FBC_CTL_FENCE_DBL
operator||
name|FBC_CTL_IDLE_IMM
operator||
name|FBC_CTL_CPU_FENCE
expr_stmt|;
name|fbc_ctl2
operator||=
name|plane
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FBC_CONTROL2
argument_list|,
name|fbc_ctl2
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FBC_FENCE_OFF
argument_list|,
name|crtc
operator|->
name|y
argument_list|)
expr_stmt|;
comment|/* enable it... */
name|fbc_ctl
operator|=
name|FBC_CTL_EN
operator||
name|FBC_CTL_PERIODIC
expr_stmt|;
if|if
condition|(
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
condition|)
name|fbc_ctl
operator||=
name|FBC_CTL_C3_IDLE
expr_stmt|;
comment|/* 945 needs special SR handling */
name|fbc_ctl
operator||=
operator|(
name|cfb_pitch
operator|&
literal|0xff
operator|)
operator|<<
name|FBC_CTL_STRIDE_SHIFT
expr_stmt|;
name|fbc_ctl
operator||=
operator|(
name|interval
operator|&
literal|0x2fff
operator|)
operator|<<
name|FBC_CTL_INTERVAL_SHIFT
expr_stmt|;
name|fbc_ctl
operator||=
name|obj
operator|->
name|fence_reg
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FBC_CONTROL
argument_list|,
name|fbc_ctl
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"enabled FBC, pitch %d, yoff %d, plane %d, "
argument_list|,
name|cfb_pitch
argument_list|,
name|crtc
operator|->
name|y
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|i8xx_fbc_enabled
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
name|I915_READ
argument_list|(
name|FBC_CONTROL
argument_list|)
operator|&
name|FBC_CTL_EN
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g4x_enable_fbc
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|unsigned
name|long
name|interval
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
init|=
name|crtc
operator|->
name|fb
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
init|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|intel_fb
operator|->
name|obj
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
operator|==
literal|0
condition|?
name|DPFC_CTL_PLANEA
else|:
name|DPFC_CTL_PLANEB
decl_stmt|;
name|unsigned
name|long
name|stall_watermark
init|=
literal|200
decl_stmt|;
name|u32
name|dpfc_ctl
decl_stmt|;
name|dpfc_ctl
operator|=
name|plane
operator||
name|DPFC_SR_EN
operator||
name|DPFC_CTL_LIMIT_1X
expr_stmt|;
name|dpfc_ctl
operator||=
name|DPFC_CTL_FENCE_EN
operator||
name|obj
operator|->
name|fence_reg
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPFC_CHICKEN
argument_list|,
name|DPFC_HT_MODIFY
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPFC_RECOMP_CTL
argument_list|,
name|DPFC_RECOMP_STALL_EN
operator||
operator|(
name|stall_watermark
operator|<<
name|DPFC_RECOMP_STALL_WM_SHIFT
operator|)
operator||
operator|(
name|interval
operator|<<
name|DPFC_RECOMP_TIMER_COUNT_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPFC_FENCE_YOFF
argument_list|,
name|crtc
operator|->
name|y
argument_list|)
expr_stmt|;
comment|/* enable it... */
name|I915_WRITE
argument_list|(
name|DPFC_CONTROL
argument_list|,
name|I915_READ
argument_list|(
name|DPFC_CONTROL
argument_list|)
operator||
name|DPFC_CTL_EN
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"enabled fbc on plane %d\n"
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g4x_disable_fbc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|dpfc_ctl
decl_stmt|;
comment|/* Disable compression */
name|dpfc_ctl
operator|=
name|I915_READ
argument_list|(
name|DPFC_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpfc_ctl
operator|&
name|DPFC_CTL_EN
condition|)
block|{
name|dpfc_ctl
operator|&=
operator|~
name|DPFC_CTL_EN
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPFC_CONTROL
argument_list|,
name|dpfc_ctl
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabled FBC\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|g4x_fbc_enabled
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
name|I915_READ
argument_list|(
name|DPFC_CONTROL
argument_list|)
operator|&
name|DPFC_CTL_EN
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sandybridge_blit_fbc_update
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|blt_ecoskpd
decl_stmt|;
comment|/* Make sure blitter notifies FBC of writes */
name|gen6_gt_force_wake_get
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|blt_ecoskpd
operator|=
name|I915_READ
argument_list|(
name|GEN6_BLITTER_ECOSKPD
argument_list|)
expr_stmt|;
name|blt_ecoskpd
operator||=
name|GEN6_BLITTER_FBC_NOTIFY
operator|<<
name|GEN6_BLITTER_LOCK_SHIFT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_BLITTER_ECOSKPD
argument_list|,
name|blt_ecoskpd
argument_list|)
expr_stmt|;
name|blt_ecoskpd
operator||=
name|GEN6_BLITTER_FBC_NOTIFY
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_BLITTER_ECOSKPD
argument_list|,
name|blt_ecoskpd
argument_list|)
expr_stmt|;
name|blt_ecoskpd
operator|&=
operator|~
operator|(
name|GEN6_BLITTER_FBC_NOTIFY
operator|<<
name|GEN6_BLITTER_LOCK_SHIFT
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_BLITTER_ECOSKPD
argument_list|,
name|blt_ecoskpd
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|GEN6_BLITTER_ECOSKPD
argument_list|)
expr_stmt|;
name|gen6_gt_force_wake_put
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_enable_fbc
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|unsigned
name|long
name|interval
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
init|=
name|crtc
operator|->
name|fb
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
init|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|intel_fb
operator|->
name|obj
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
init|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|int
name|plane
init|=
name|intel_crtc
operator|->
name|plane
operator|==
literal|0
condition|?
name|DPFC_CTL_PLANEA
else|:
name|DPFC_CTL_PLANEB
decl_stmt|;
name|unsigned
name|long
name|stall_watermark
init|=
literal|200
decl_stmt|;
name|u32
name|dpfc_ctl
decl_stmt|;
name|dpfc_ctl
operator|=
name|I915_READ
argument_list|(
name|ILK_DPFC_CONTROL
argument_list|)
expr_stmt|;
name|dpfc_ctl
operator|&=
name|DPFC_RESERVED
expr_stmt|;
name|dpfc_ctl
operator||=
operator|(
name|plane
operator||
name|DPFC_CTL_LIMIT_1X
operator|)
expr_stmt|;
comment|/* Set persistent mode for front-buffer rendering, ala X. */
name|dpfc_ctl
operator||=
name|DPFC_CTL_PERSISTENT_MODE
expr_stmt|;
name|dpfc_ctl
operator||=
operator|(
name|DPFC_CTL_FENCE_EN
operator||
name|obj
operator|->
name|fence_reg
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DPFC_CHICKEN
argument_list|,
name|DPFC_HT_MODIFY
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DPFC_RECOMP_CTL
argument_list|,
name|DPFC_RECOMP_STALL_EN
operator||
operator|(
name|stall_watermark
operator|<<
name|DPFC_RECOMP_STALL_WM_SHIFT
operator|)
operator||
operator|(
name|interval
operator|<<
name|DPFC_RECOMP_TIMER_COUNT_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DPFC_FENCE_YOFF
argument_list|,
name|crtc
operator|->
name|y
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_FBC_RT_BASE
argument_list|,
name|obj
operator|->
name|gtt_offset
operator||
name|ILK_FBC_RT_VALID
argument_list|)
expr_stmt|;
comment|/* enable it... */
name|I915_WRITE
argument_list|(
name|ILK_DPFC_CONTROL
argument_list|,
name|dpfc_ctl
operator||
name|DPFC_CTL_EN
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|SNB_DPFC_CTL_SA
argument_list|,
name|SNB_CPU_FENCE_ENABLE
operator||
name|obj
operator|->
name|fence_reg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DPFC_CPU_FENCE_OFFSET
argument_list|,
name|crtc
operator|->
name|y
argument_list|)
expr_stmt|;
name|sandybridge_blit_fbc_update
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"enabled fbc on plane %d\n"
argument_list|,
name|intel_crtc
operator|->
name|plane
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_disable_fbc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|dpfc_ctl
decl_stmt|;
comment|/* Disable compression */
name|dpfc_ctl
operator|=
name|I915_READ
argument_list|(
name|ILK_DPFC_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpfc_ctl
operator|&
name|DPFC_CTL_EN
condition|)
block|{
name|dpfc_ctl
operator|&=
operator|~
name|DPFC_CTL_EN
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DPFC_CONTROL
argument_list|,
name|dpfc_ctl
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabled FBC\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|ironlake_fbc_enabled
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
name|I915_READ
argument_list|(
name|ILK_DPFC_CONTROL
argument_list|)
operator|&
name|DPFC_CTL_EN
return|;
block|}
end_function

begin_function
name|bool
name|intel_fbc_enabled
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|display
operator|.
name|fbc_enabled
condition|)
return|return
name|false
return|;
return|return
name|dev_priv
operator|->
name|display
operator|.
name|fbc_enabled
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_fbc_work_fn
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|intel_fbc_work
modifier|*
name|work
init|=
name|arg
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|work
operator|->
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|dev_priv
operator|->
name|fbc_work
condition|)
block|{
comment|/* Double check that we haven't switched fb without cancelling 		 * the prior work. 		 */
if|if
condition|(
name|work
operator|->
name|crtc
operator|->
name|fb
operator|==
name|work
operator|->
name|fb
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|enable_fbc
argument_list|(
name|work
operator|->
name|crtc
argument_list|,
name|work
operator|->
name|interval
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|cfb_plane
operator|=
name|to_intel_crtc
argument_list|(
name|work
operator|->
name|crtc
argument_list|)
operator|->
name|plane
expr_stmt|;
name|dev_priv
operator|->
name|cfb_fb
operator|=
name|work
operator|->
name|crtc
operator|->
name|fb
operator|->
name|base
operator|.
name|id
expr_stmt|;
name|dev_priv
operator|->
name|cfb_y
operator|=
name|work
operator|->
name|crtc
operator|->
name|y
expr_stmt|;
block|}
name|dev_priv
operator|->
name|fbc_work
operator|=
name|NULL
expr_stmt|;
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_cancel_fbc_work
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|fbc_work
operator|==
name|NULL
condition|)
return|return;
name|DRM_DEBUG_KMS
argument_list|(
literal|"cancelling pending FBC enable\n"
argument_list|)
expr_stmt|;
comment|/* Synchronisation is provided by struct_mutex and checking of 	 * dev_priv->fbc_work, so we can perform the cancellation 	 * entirely asynchronously. 	 */
if|if
condition|(
name|taskqueue_cancel_timeout
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|fbc_work
operator|->
name|work
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
comment|/* tasklet was killed before being run, clean up */
name|free
argument_list|(
name|dev_priv
operator|->
name|fbc_work
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
comment|/* Mark the work as no longer wanted so that if it does 	 * wake-up (because the work was already running and waiting 	 * for our mutex), it will discover that is no longer 	 * necessary to run. 	 */
name|dev_priv
operator|->
name|fbc_work
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_enable_fbc
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|unsigned
name|long
name|interval
parameter_list|)
block|{
name|struct
name|intel_fbc_work
modifier|*
name|work
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|display
operator|.
name|enable_fbc
condition|)
return|return;
name|intel_cancel_fbc_work
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|work
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|work
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|NULL
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|enable_fbc
argument_list|(
name|crtc
argument_list|,
name|interval
argument_list|)
expr_stmt|;
return|return;
block|}
name|work
operator|->
name|crtc
operator|=
name|crtc
expr_stmt|;
name|work
operator|->
name|fb
operator|=
name|crtc
operator|->
name|fb
expr_stmt|;
name|work
operator|->
name|interval
operator|=
name|interval
expr_stmt|;
name|TIMEOUT_TASK_INIT
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|work
operator|->
name|work
argument_list|,
literal|0
argument_list|,
name|intel_fbc_work_fn
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|fbc_work
operator|=
name|work
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"scheduling delayed FBC enable\n"
argument_list|)
expr_stmt|;
comment|/* Delay the actual enabling to let pageflipping cease and the 	 * display to settle before starting the compression. Note that 	 * this delay also serves a second purpose: it allows for a 	 * vblank to pass after disabling the FBC before we attempt 	 * to modify the control registers. 	 * 	 * A more complicated solution would involve tracking vblanks 	 * following the termination of the page-flipping sequence 	 * and indeed performing the enable as a co-routine and not 	 * waiting synchronously upon the vblank. 	 */
name|taskqueue_enqueue_timeout
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|work
operator|->
name|work
argument_list|,
name|msecs_to_jiffies
argument_list|(
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_disable_fbc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|intel_cancel_fbc_work
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|display
operator|.
name|disable_fbc
condition|)
return|return;
name|dev_priv
operator|->
name|display
operator|.
name|disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|cfb_plane
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_update_fbc - enable/disable FBC as needed  * @dev: the drm_device  *  * Set up the framebuffer compression hardware at mode set time.  We  * enable it if possible:  *   - plane A only (on pre-965)  *   - no pixel mulitply/line duplication  *   - no alpha buffer discard  *   - no dual wide  *   - framebuffer<= 2048 in width, 1536 in height  *  * We can't assume that any compression will take place (worst case),  * so the compressed buffer has to be the same size as the uncompressed  * one.  It also must reside (along with the line length buffer) in  * stolen memory.  *  * We need to enable/disable FBC on a global basis.  */
end_comment

begin_function
name|void
name|intel_update_fbc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmp_crtc
decl_stmt|;
name|struct
name|intel_crtc
modifier|*
name|intel_crtc
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|;
name|struct
name|intel_framebuffer
modifier|*
name|intel_fb
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|enable_fbc
decl_stmt|;
if|if
condition|(
operator|!
name|i915_powersave
condition|)
return|return;
if|if
condition|(
operator|!
name|I915_HAS_FBC
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
comment|/* 	 * If FBC is already on, we just have to verify that we can 	 * keep it that way... 	 * Need to disable if: 	 *   - more than one pipe is active 	 *   - changing FBC params (stride, fence, mode) 	 *   - new fb is too large to fit in compressed buffer 	 *   - going to an unsupported config (interlace, pixel multiply, etc.) 	 */
name|list_for_each_entry
argument_list|(
argument|tmp_crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|intel_crtc_active
argument_list|(
name|tmp_crtc
argument_list|)
operator|&&
operator|!
name|to_intel_crtc
argument_list|(
name|tmp_crtc
argument_list|)
operator|->
name|primary_disabled
condition|)
block|{
if|if
condition|(
name|crtc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"more than one pipe active, disabling compression\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_MULTIPLE_PIPES
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
name|crtc
operator|=
name|tmp_crtc
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|crtc
operator|||
name|crtc
operator|->
name|fb
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"no output, disabling\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_NO_OUTPUT
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
name|intel_crtc
operator|=
name|to_intel_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|fb
operator|=
name|crtc
operator|->
name|fb
expr_stmt|;
name|intel_fb
operator|=
name|to_intel_framebuffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|obj
operator|=
name|intel_fb
operator|->
name|obj
expr_stmt|;
name|enable_fbc
operator|=
name|i915_enable_fbc
expr_stmt|;
if|if
condition|(
name|enable_fbc
operator|<
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"fbc set to per-chip default\n"
argument_list|)
expr_stmt|;
name|enable_fbc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<=
literal|6
condition|)
name|enable_fbc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|enable_fbc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"fbc disabled per module param\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_MODULE_PARAM
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
if|if
condition|(
name|intel_fb
operator|->
name|obj
operator|->
name|base
operator|.
name|size
operator|>
name|dev_priv
operator|->
name|cfb_size
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"framebuffer too large, disabling "
literal|"compression\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_STOLEN_TOO_SMALL
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
if|if
condition|(
operator|(
name|crtc
operator|->
name|mode
operator|.
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
operator|)
operator|||
operator|(
name|crtc
operator|->
name|mode
operator|.
name|flags
operator|&
name|DRM_MODE_FLAG_DBLSCAN
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"mode incompatible with compression, "
literal|"disabling\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_UNSUPPORTED_MODE
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
if|if
condition|(
operator|(
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
operator|>
literal|2048
operator|)
operator|||
operator|(
name|crtc
operator|->
name|mode
operator|.
name|vdisplay
operator|>
literal|1536
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"mode too large for compression, disabling\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_MODE_TOO_LARGE
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
if|if
condition|(
operator|(
name|IS_I915GM
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
name|intel_crtc
operator|->
name|plane
operator|!=
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"plane not 0, disabling compression\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_BAD_PLANE
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
comment|/* The use of a CPU fence is mandatory in order to detect writes 	 * by the CPU to the scanout and trigger updates to the FBC. 	 */
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_X
operator|||
name|obj
operator|->
name|fence_reg
operator|==
name|I915_FENCE_REG_NONE
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"framebuffer not tiled or fenced, disabling compression\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|no_fbc_reason
operator|=
name|FBC_NOT_TILED
expr_stmt|;
goto|goto
name|out_disable
goto|;
block|}
comment|/* If the kernel debugger is active, always disable compression */
if|if
condition|(
name|kdb_active
condition|)
goto|goto
name|out_disable
goto|;
comment|/* If the scanout has not changed, don't modify the FBC settings. 	 * Note that we make the fundamental assumption that the fb->obj 	 * cannot be unpinned (and have its GTT offset and fence revoked) 	 * without first being decoupled from the scanout and FBC disabled. 	 */
if|if
condition|(
name|dev_priv
operator|->
name|cfb_plane
operator|==
name|intel_crtc
operator|->
name|plane
operator|&&
name|dev_priv
operator|->
name|cfb_fb
operator|==
name|fb
operator|->
name|base
operator|.
name|id
operator|&&
name|dev_priv
operator|->
name|cfb_y
operator|==
name|crtc
operator|->
name|y
condition|)
return|return;
if|if
condition|(
name|intel_fbc_enabled
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* We update FBC along two paths, after changing fb/crtc 		 * configuration (modeswitching) and after page-flipping 		 * finishes. For the latter, we know that not only did 		 * we disable the FBC at the start of the page-flip 		 * sequence, but also more than one vblank has passed. 		 * 		 * For the former case of modeswitching, it is possible 		 * to switch between two FBC valid configurations 		 * instantaneously so we do need to disable the FBC 		 * before we can modify its control registers. We also 		 * have to wait for the next vblank for that to take 		 * effect. However, since we delay enabling FBC we can 		 * assume that a vblank has passed since disabling and 		 * that we can safely alter the registers in the deferred 		 * callback. 		 * 		 * In the scenario that we go from a valid to invalid 		 * and then back to valid FBC configuration we have 		 * no strict enforcement that a vblank occurred since 		 * disabling the FBC. However, along all current pipe 		 * disabling paths we do need to wait for a vblank at 		 * some point. And we wait before enabling FBC anyway. 		 */
name|DRM_DEBUG_KMS
argument_list|(
literal|"disabling active FBC for update\n"
argument_list|)
expr_stmt|;
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|intel_enable_fbc
argument_list|(
name|crtc
argument_list|,
literal|500
argument_list|)
expr_stmt|;
return|return;
name|out_disable
label|:
comment|/* Multiple disables should be harmless */
if|if
condition|(
name|intel_fbc_enabled
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"unsupported config, disabling FBC\n"
argument_list|)
expr_stmt|;
name|intel_disable_fbc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i915_pineview_get_mem_freq
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|tmp
decl_stmt|;
name|tmp
operator|=
name|I915_READ
argument_list|(
name|CLKCFG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tmp
operator|&
name|CLKCFG_FSB_MASK
condition|)
block|{
case|case
name|CLKCFG_FSB_533
case|:
name|dev_priv
operator|->
name|fsb_freq
operator|=
literal|533
expr_stmt|;
comment|/* 133*4 */
break|break;
case|case
name|CLKCFG_FSB_800
case|:
name|dev_priv
operator|->
name|fsb_freq
operator|=
literal|800
expr_stmt|;
comment|/* 200*4 */
break|break;
case|case
name|CLKCFG_FSB_667
case|:
name|dev_priv
operator|->
name|fsb_freq
operator|=
literal|667
expr_stmt|;
comment|/* 167*4 */
break|break;
case|case
name|CLKCFG_FSB_400
case|:
name|dev_priv
operator|->
name|fsb_freq
operator|=
literal|400
expr_stmt|;
comment|/* 100*4 */
break|break;
block|}
switch|switch
condition|(
name|tmp
operator|&
name|CLKCFG_MEM_MASK
condition|)
block|{
case|case
name|CLKCFG_MEM_533
case|:
name|dev_priv
operator|->
name|mem_freq
operator|=
literal|533
expr_stmt|;
break|break;
case|case
name|CLKCFG_MEM_667
case|:
name|dev_priv
operator|->
name|mem_freq
operator|=
literal|667
expr_stmt|;
break|break;
case|case
name|CLKCFG_MEM_800
case|:
name|dev_priv
operator|->
name|mem_freq
operator|=
literal|800
expr_stmt|;
break|break;
block|}
comment|/* detect pineview DDR3 setting */
name|tmp
operator|=
name|I915_READ
argument_list|(
name|CSHRDDR3CTL
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|is_ddr3
operator|=
operator|(
name|tmp
operator|&
name|CSHRDDR3CTL_DDR3
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_ironlake_get_mem_freq
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u16
name|ddrpll
decl_stmt|,
name|csipll
decl_stmt|;
name|ddrpll
operator|=
name|I915_READ16
argument_list|(
name|DDRMPLL1
argument_list|)
expr_stmt|;
name|csipll
operator|=
name|I915_READ16
argument_list|(
name|CSIPLL0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ddrpll
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0xc
case|:
name|dev_priv
operator|->
name|mem_freq
operator|=
literal|800
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
name|dev_priv
operator|->
name|mem_freq
operator|=
literal|1066
expr_stmt|;
break|break;
case|case
literal|0x14
case|:
name|dev_priv
operator|->
name|mem_freq
operator|=
literal|1333
expr_stmt|;
break|break;
case|case
literal|0x18
case|:
name|dev_priv
operator|->
name|mem_freq
operator|=
literal|1600
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"unknown memory frequency 0x%02x\n"
argument_list|,
name|ddrpll
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mem_freq
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|dev_priv
operator|->
name|ips
operator|.
name|r_t
operator|=
name|dev_priv
operator|->
name|mem_freq
expr_stmt|;
switch|switch
condition|(
name|csipll
operator|&
literal|0x3ff
condition|)
block|{
case|case
literal|0x00c
case|:
name|dev_priv
operator|->
name|fsb_freq
operator|=
literal|3200
expr_stmt|;
break|break;
case|case
literal|0x00e
case|:
name|dev_priv
operator|->
name|fsb_freq
operator|=
literal|3733
expr_stmt|;
break|break;
case|case
literal|0x010
case|:
name|dev_priv
operator|->
name|fsb_freq
operator|=
literal|4266
expr_stmt|;
break|break;
case|case
literal|0x012
case|:
name|dev_priv
operator|->
name|fsb_freq
operator|=
literal|4800
expr_stmt|;
break|break;
case|case
literal|0x014
case|:
name|dev_priv
operator|->
name|fsb_freq
operator|=
literal|5333
expr_stmt|;
break|break;
case|case
literal|0x016
case|:
name|dev_priv
operator|->
name|fsb_freq
operator|=
literal|5866
expr_stmt|;
break|break;
case|case
literal|0x018
case|:
name|dev_priv
operator|->
name|fsb_freq
operator|=
literal|6400
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"unknown fsb frequency 0x%04x\n"
argument_list|,
name|csipll
operator|&
literal|0x3ff
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|fsb_freq
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|fsb_freq
operator|==
literal|3200
condition|)
block|{
name|dev_priv
operator|->
name|ips
operator|.
name|c_m
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dev_priv
operator|->
name|fsb_freq
operator|>
literal|3200
operator|&&
name|dev_priv
operator|->
name|fsb_freq
operator|<=
literal|4800
condition|)
block|{
name|dev_priv
operator|->
name|ips
operator|.
name|c_m
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|ips
operator|.
name|c_m
operator|=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|cxsr_latency
name|cxsr_latency_table
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|0
block|,
literal|800
block|,
literal|400
block|,
literal|3382
block|,
literal|33382
block|,
literal|3983
block|,
literal|33983
block|}
block|,
comment|/* DDR2-400 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|800
block|,
literal|667
block|,
literal|3354
block|,
literal|33354
block|,
literal|3807
block|,
literal|33807
block|}
block|,
comment|/* DDR2-667 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|800
block|,
literal|800
block|,
literal|3347
block|,
literal|33347
block|,
literal|3763
block|,
literal|33763
block|}
block|,
comment|/* DDR2-800 SC */
block|{
literal|1
block|,
literal|1
block|,
literal|800
block|,
literal|667
block|,
literal|6420
block|,
literal|36420
block|,
literal|6873
block|,
literal|36873
block|}
block|,
comment|/* DDR3-667 SC */
block|{
literal|1
block|,
literal|1
block|,
literal|800
block|,
literal|800
block|,
literal|5902
block|,
literal|35902
block|,
literal|6318
block|,
literal|36318
block|}
block|,
comment|/* DDR3-800 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|667
block|,
literal|400
block|,
literal|3400
block|,
literal|33400
block|,
literal|4021
block|,
literal|34021
block|}
block|,
comment|/* DDR2-400 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|667
block|,
literal|667
block|,
literal|3372
block|,
literal|33372
block|,
literal|3845
block|,
literal|33845
block|}
block|,
comment|/* DDR2-667 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|667
block|,
literal|800
block|,
literal|3386
block|,
literal|33386
block|,
literal|3822
block|,
literal|33822
block|}
block|,
comment|/* DDR2-800 SC */
block|{
literal|1
block|,
literal|1
block|,
literal|667
block|,
literal|667
block|,
literal|6438
block|,
literal|36438
block|,
literal|6911
block|,
literal|36911
block|}
block|,
comment|/* DDR3-667 SC */
block|{
literal|1
block|,
literal|1
block|,
literal|667
block|,
literal|800
block|,
literal|5941
block|,
literal|35941
block|,
literal|6377
block|,
literal|36377
block|}
block|,
comment|/* DDR3-800 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|400
block|,
literal|400
block|,
literal|3472
block|,
literal|33472
block|,
literal|4173
block|,
literal|34173
block|}
block|,
comment|/* DDR2-400 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|400
block|,
literal|667
block|,
literal|3443
block|,
literal|33443
block|,
literal|3996
block|,
literal|33996
block|}
block|,
comment|/* DDR2-667 SC */
block|{
literal|1
block|,
literal|0
block|,
literal|400
block|,
literal|800
block|,
literal|3430
block|,
literal|33430
block|,
literal|3946
block|,
literal|33946
block|}
block|,
comment|/* DDR2-800 SC */
block|{
literal|1
block|,
literal|1
block|,
literal|400
block|,
literal|667
block|,
literal|6509
block|,
literal|36509
block|,
literal|7062
block|,
literal|37062
block|}
block|,
comment|/* DDR3-667 SC */
block|{
literal|1
block|,
literal|1
block|,
literal|400
block|,
literal|800
block|,
literal|5985
block|,
literal|35985
block|,
literal|6501
block|,
literal|36501
block|}
block|,
comment|/* DDR3-800 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|800
block|,
literal|400
block|,
literal|3438
block|,
literal|33438
block|,
literal|4065
block|,
literal|34065
block|}
block|,
comment|/* DDR2-400 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|800
block|,
literal|667
block|,
literal|3410
block|,
literal|33410
block|,
literal|3889
block|,
literal|33889
block|}
block|,
comment|/* DDR2-667 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|800
block|,
literal|800
block|,
literal|3403
block|,
literal|33403
block|,
literal|3845
block|,
literal|33845
block|}
block|,
comment|/* DDR2-800 SC */
block|{
literal|0
block|,
literal|1
block|,
literal|800
block|,
literal|667
block|,
literal|6476
block|,
literal|36476
block|,
literal|6955
block|,
literal|36955
block|}
block|,
comment|/* DDR3-667 SC */
block|{
literal|0
block|,
literal|1
block|,
literal|800
block|,
literal|800
block|,
literal|5958
block|,
literal|35958
block|,
literal|6400
block|,
literal|36400
block|}
block|,
comment|/* DDR3-800 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|667
block|,
literal|400
block|,
literal|3456
block|,
literal|33456
block|,
literal|4103
block|,
literal|34106
block|}
block|,
comment|/* DDR2-400 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|667
block|,
literal|667
block|,
literal|3428
block|,
literal|33428
block|,
literal|3927
block|,
literal|33927
block|}
block|,
comment|/* DDR2-667 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|667
block|,
literal|800
block|,
literal|3443
block|,
literal|33443
block|,
literal|3905
block|,
literal|33905
block|}
block|,
comment|/* DDR2-800 SC */
block|{
literal|0
block|,
literal|1
block|,
literal|667
block|,
literal|667
block|,
literal|6494
block|,
literal|36494
block|,
literal|6993
block|,
literal|36993
block|}
block|,
comment|/* DDR3-667 SC */
block|{
literal|0
block|,
literal|1
block|,
literal|667
block|,
literal|800
block|,
literal|5998
block|,
literal|35998
block|,
literal|6460
block|,
literal|36460
block|}
block|,
comment|/* DDR3-800 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|400
block|,
literal|400
block|,
literal|3528
block|,
literal|33528
block|,
literal|4255
block|,
literal|34255
block|}
block|,
comment|/* DDR2-400 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|400
block|,
literal|667
block|,
literal|3500
block|,
literal|33500
block|,
literal|4079
block|,
literal|34079
block|}
block|,
comment|/* DDR2-667 SC */
block|{
literal|0
block|,
literal|0
block|,
literal|400
block|,
literal|800
block|,
literal|3487
block|,
literal|33487
block|,
literal|4029
block|,
literal|34029
block|}
block|,
comment|/* DDR2-800 SC */
block|{
literal|0
block|,
literal|1
block|,
literal|400
block|,
literal|667
block|,
literal|6566
block|,
literal|36566
block|,
literal|7145
block|,
literal|37145
block|}
block|,
comment|/* DDR3-667 SC */
block|{
literal|0
block|,
literal|1
block|,
literal|400
block|,
literal|800
block|,
literal|6042
block|,
literal|36042
block|,
literal|6584
block|,
literal|36584
block|}
block|,
comment|/* DDR3-800 SC */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|cxsr_latency
modifier|*
name|intel_get_cxsr_latency
parameter_list|(
name|int
name|is_desktop
parameter_list|,
name|int
name|is_ddr3
parameter_list|,
name|int
name|fsb
parameter_list|,
name|int
name|mem
parameter_list|)
block|{
specifier|const
name|struct
name|cxsr_latency
modifier|*
name|latency
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fsb
operator|==
literal|0
operator|||
name|mem
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|cxsr_latency_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|latency
operator|=
operator|&
name|cxsr_latency_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|is_desktop
operator|==
name|latency
operator|->
name|is_desktop
operator|&&
name|is_ddr3
operator|==
name|latency
operator|->
name|is_ddr3
operator|&&
name|fsb
operator|==
name|latency
operator|->
name|fsb_freq
operator|&&
name|mem
operator|==
name|latency
operator|->
name|mem_freq
condition|)
return|return
name|latency
return|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unknown FSB/MEM found, disable CxSR\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pineview_disable_cxsr
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* deactivate cxsr */
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
name|I915_READ
argument_list|(
name|DSPFW3
argument_list|)
operator|&
operator|~
name|PINEVIEW_SELF_REFRESH_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Latency for FIFO fetches is dependent on several factors:  *   - memory configuration (speed, channels)  *   - chipset  *   - current MCH state  * It can be fairly high in some situations, so here we assume a fairly  * pessimal value.  It's a tradeoff between extra memory fetches (if we  * set this value too high, the FIFO will fetch frequently to stay full)  * and power consumption (set it too low to save power and we might see  * FIFO underruns and display "flicker").  *  * A value of 5us seems to be a good balance; safe for very low end  * platforms but not overly aggressive on lower latency configs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|latency_ns
init|=
literal|5000
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i9xx_get_fifo_size
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|dsparb
init|=
name|I915_READ
argument_list|(
name|DSPARB
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
name|dsparb
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|plane
condition|)
name|size
operator|=
operator|(
operator|(
name|dsparb
operator|>>
name|DSPARB_CSTART_SHIFT
operator|)
operator|&
literal|0x7f
operator|)
operator|-
name|size
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO size - (0x%08x) %s: %d\n"
argument_list|,
name|dsparb
argument_list|,
name|plane
condition|?
literal|"B"
else|:
literal|"A"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i85x_get_fifo_size
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|dsparb
init|=
name|I915_READ
argument_list|(
name|DSPARB
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
name|dsparb
operator|&
literal|0x1ff
expr_stmt|;
if|if
condition|(
name|plane
condition|)
name|size
operator|=
operator|(
operator|(
name|dsparb
operator|>>
name|DSPARB_BEND_SHIFT
operator|)
operator|&
literal|0x1ff
operator|)
operator|-
name|size
expr_stmt|;
name|size
operator|>>=
literal|1
expr_stmt|;
comment|/* Convert to cachelines */
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO size - (0x%08x) %s: %d\n"
argument_list|,
name|dsparb
argument_list|,
name|plane
condition|?
literal|"B"
else|:
literal|"A"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i845_get_fifo_size
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|dsparb
init|=
name|I915_READ
argument_list|(
name|DSPARB
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
name|dsparb
operator|&
literal|0x7f
expr_stmt|;
name|size
operator|>>=
literal|2
expr_stmt|;
comment|/* Convert to cachelines */
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO size - (0x%08x) %s: %d\n"
argument_list|,
name|dsparb
argument_list|,
name|plane
condition|?
literal|"B"
else|:
literal|"A"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i830_get_fifo_size
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|dsparb
init|=
name|I915_READ
argument_list|(
name|DSPARB
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
name|dsparb
operator|&
literal|0x7f
expr_stmt|;
name|size
operator|>>=
literal|1
expr_stmt|;
comment|/* Convert to cachelines */
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO size - (0x%08x) %s: %d\n"
argument_list|,
name|dsparb
argument_list|,
name|plane
condition|?
literal|"B"
else|:
literal|"A"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Pineview has different values for various configs */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|pineview_display_wm
init|=
block|{
name|PINEVIEW_DISPLAY_FIFO
block|,
name|PINEVIEW_MAX_WM
block|,
name|PINEVIEW_DFT_WM
block|,
name|PINEVIEW_GUARD_WM
block|,
name|PINEVIEW_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|pineview_display_hplloff_wm
init|=
block|{
name|PINEVIEW_DISPLAY_FIFO
block|,
name|PINEVIEW_MAX_WM
block|,
name|PINEVIEW_DFT_HPLLOFF_WM
block|,
name|PINEVIEW_GUARD_WM
block|,
name|PINEVIEW_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|pineview_cursor_wm
init|=
block|{
name|PINEVIEW_CURSOR_FIFO
block|,
name|PINEVIEW_CURSOR_MAX_WM
block|,
name|PINEVIEW_CURSOR_DFT_WM
block|,
name|PINEVIEW_CURSOR_GUARD_WM
block|,
name|PINEVIEW_FIFO_LINE_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|pineview_cursor_hplloff_wm
init|=
block|{
name|PINEVIEW_CURSOR_FIFO
block|,
name|PINEVIEW_CURSOR_MAX_WM
block|,
name|PINEVIEW_CURSOR_DFT_WM
block|,
name|PINEVIEW_CURSOR_GUARD_WM
block|,
name|PINEVIEW_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|g4x_wm_info
init|=
block|{
name|G4X_FIFO_SIZE
block|,
name|G4X_MAX_WM
block|,
name|G4X_MAX_WM
block|,
literal|2
block|,
name|G4X_FIFO_LINE_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|g4x_cursor_wm_info
init|=
block|{
name|I965_CURSOR_FIFO
block|,
name|I965_CURSOR_MAX_WM
block|,
name|I965_CURSOR_DFT_WM
block|,
literal|2
block|,
name|G4X_FIFO_LINE_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|valleyview_wm_info
init|=
block|{
name|VALLEYVIEW_FIFO_SIZE
block|,
name|VALLEYVIEW_MAX_WM
block|,
name|VALLEYVIEW_MAX_WM
block|,
literal|2
block|,
name|G4X_FIFO_LINE_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|valleyview_cursor_wm_info
init|=
block|{
name|I965_CURSOR_FIFO
block|,
name|VALLEYVIEW_CURSOR_MAX_WM
block|,
name|I965_CURSOR_DFT_WM
block|,
literal|2
block|,
name|G4X_FIFO_LINE_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|i965_cursor_wm_info
init|=
block|{
name|I965_CURSOR_FIFO
block|,
name|I965_CURSOR_MAX_WM
block|,
name|I965_CURSOR_DFT_WM
block|,
literal|2
block|,
name|I915_FIFO_LINE_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|i945_wm_info
init|=
block|{
name|I945_FIFO_SIZE
block|,
name|I915_MAX_WM
block|,
literal|1
block|,
literal|2
block|,
name|I915_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|i915_wm_info
init|=
block|{
name|I915_FIFO_SIZE
block|,
name|I915_MAX_WM
block|,
literal|1
block|,
literal|2
block|,
name|I915_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|i855_wm_info
init|=
block|{
name|I855GM_FIFO_SIZE
block|,
name|I915_MAX_WM
block|,
literal|1
block|,
literal|2
block|,
name|I830_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|i830_wm_info
init|=
block|{
name|I830_FIFO_SIZE
block|,
name|I915_MAX_WM
block|,
literal|1
block|,
literal|2
block|,
name|I830_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|ironlake_display_wm_info
init|=
block|{
name|ILK_DISPLAY_FIFO
block|,
name|ILK_DISPLAY_MAXWM
block|,
name|ILK_DISPLAY_DFTWM
block|,
literal|2
block|,
name|ILK_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|ironlake_cursor_wm_info
init|=
block|{
name|ILK_CURSOR_FIFO
block|,
name|ILK_CURSOR_MAXWM
block|,
name|ILK_CURSOR_DFTWM
block|,
literal|2
block|,
name|ILK_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|ironlake_display_srwm_info
init|=
block|{
name|ILK_DISPLAY_SR_FIFO
block|,
name|ILK_DISPLAY_MAX_SRWM
block|,
name|ILK_DISPLAY_DFT_SRWM
block|,
literal|2
block|,
name|ILK_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|ironlake_cursor_srwm_info
init|=
block|{
name|ILK_CURSOR_SR_FIFO
block|,
name|ILK_CURSOR_MAX_SRWM
block|,
name|ILK_CURSOR_DFT_SRWM
block|,
literal|2
block|,
name|ILK_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|sandybridge_display_wm_info
init|=
block|{
name|SNB_DISPLAY_FIFO
block|,
name|SNB_DISPLAY_MAXWM
block|,
name|SNB_DISPLAY_DFTWM
block|,
literal|2
block|,
name|SNB_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|sandybridge_cursor_wm_info
init|=
block|{
name|SNB_CURSOR_FIFO
block|,
name|SNB_CURSOR_MAXWM
block|,
name|SNB_CURSOR_DFTWM
block|,
literal|2
block|,
name|SNB_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|sandybridge_display_srwm_info
init|=
block|{
name|SNB_DISPLAY_SR_FIFO
block|,
name|SNB_DISPLAY_MAX_SRWM
block|,
name|SNB_DISPLAY_DFT_SRWM
block|,
literal|2
block|,
name|SNB_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intel_watermark_params
name|sandybridge_cursor_srwm_info
init|=
block|{
name|SNB_CURSOR_SR_FIFO
block|,
name|SNB_CURSOR_MAX_SRWM
block|,
name|SNB_CURSOR_DFT_SRWM
block|,
literal|2
block|,
name|SNB_FIFO_LINE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * intel_calculate_wm - calculate watermark level  * @clock_in_khz: pixel clock  * @wm: chip FIFO params  * @pixel_size: display pixel size  * @latency_ns: memory latency for the platform  *  * Calculate the watermark level (the level at which the display plane will  * start fetching from memory again).  Each chip has a different display  * FIFO size and allocation, so the caller needs to figure that out and pass  * in the correct intel_watermark_params structure.  *  * As the pixel clock runs, the FIFO will be drained at a rate that depends  * on the pixel size.  When it reaches the watermark level, it'll start  * fetching FIFO line sized based chunks from memory until the FIFO fills  * past the watermark point.  If the FIFO drains completely, a FIFO underrun  * will occur, and a display engine hang could result.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|intel_calculate_wm
parameter_list|(
name|unsigned
name|long
name|clock_in_khz
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|wm
parameter_list|,
name|int
name|fifo_size
parameter_list|,
name|int
name|pixel_size
parameter_list|,
name|unsigned
name|long
name|latency_ns
parameter_list|)
block|{
name|long
name|entries_required
decl_stmt|,
name|wm_size
decl_stmt|;
comment|/* 	 * Note: we need to make sure we don't overflow for various clock& 	 * latency values. 	 * clocks go from a few thousand to several hundred thousand. 	 * latency is usually a few thousand 	 */
name|entries_required
operator|=
operator|(
operator|(
name|clock_in_khz
operator|/
literal|1000
operator|)
operator|*
name|pixel_size
operator|*
name|latency_ns
operator|)
operator|/
literal|1000
expr_stmt|;
name|entries_required
operator|=
name|DIV_ROUND_UP
argument_list|(
name|entries_required
argument_list|,
name|wm
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO entries required for mode: %ld\n"
argument_list|,
name|entries_required
argument_list|)
expr_stmt|;
name|wm_size
operator|=
name|fifo_size
operator|-
operator|(
name|entries_required
operator|+
name|wm
operator|->
name|guard_size
operator|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermark level: %ld\n"
argument_list|,
name|wm_size
argument_list|)
expr_stmt|;
comment|/* Don't promote wm_size to unsigned... */
if|if
condition|(
name|wm_size
operator|>
operator|(
name|long
operator|)
name|wm
operator|->
name|max_wm
condition|)
name|wm_size
operator|=
name|wm
operator|->
name|max_wm
expr_stmt|;
if|if
condition|(
name|wm_size
operator|<=
literal|0
condition|)
name|wm_size
operator|=
name|wm
operator|->
name|default_wm
expr_stmt|;
return|return
name|wm_size
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_crtc
modifier|*
name|single_enabled_crtc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|,
modifier|*
name|enabled
init|=
name|NULL
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|intel_crtc_active
argument_list|(
name|crtc
argument_list|)
condition|)
block|{
if|if
condition|(
name|enabled
condition|)
return|return
name|NULL
return|;
name|enabled
operator|=
name|crtc
expr_stmt|;
block|}
block|}
return|return
name|enabled
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pineview_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
specifier|const
name|struct
name|cxsr_latency
modifier|*
name|latency
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|unsigned
name|long
name|wm
decl_stmt|;
name|latency
operator|=
name|intel_get_cxsr_latency
argument_list|(
name|IS_PINEVIEW_G
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev_priv
operator|->
name|is_ddr3
argument_list|,
name|dev_priv
operator|->
name|fsb_freq
argument_list|,
name|dev_priv
operator|->
name|mem_freq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|latency
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unknown FSB/MEM found, disable CxSR\n"
argument_list|)
expr_stmt|;
name|pineview_disable_cxsr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
name|crtc
operator|=
name|single_enabled_crtc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
condition|)
block|{
name|int
name|clock
init|=
name|crtc
operator|->
name|mode
operator|.
name|clock
decl_stmt|;
name|int
name|pixel_size
init|=
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
decl_stmt|;
comment|/* Display SR */
name|wm
operator|=
name|intel_calculate_wm
argument_list|(
name|clock
argument_list|,
operator|&
name|pineview_display_wm
argument_list|,
name|pineview_display_wm
operator|.
name|fifo_size
argument_list|,
name|pixel_size
argument_list|,
name|latency
operator|->
name|display_sr
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I915_READ
argument_list|(
name|DSPFW1
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|DSPFW_SR_MASK
expr_stmt|;
name|reg
operator||=
name|wm
operator|<<
name|DSPFW_SR_SHIFT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"DSPFW1 register is %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* cursor SR */
name|wm
operator|=
name|intel_calculate_wm
argument_list|(
name|clock
argument_list|,
operator|&
name|pineview_cursor_wm
argument_list|,
name|pineview_display_wm
operator|.
name|fifo_size
argument_list|,
name|pixel_size
argument_list|,
name|latency
operator|->
name|cursor_sr
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I915_READ
argument_list|(
name|DSPFW3
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|DSPFW_CURSOR_SR_MASK
expr_stmt|;
name|reg
operator||=
operator|(
name|wm
operator|&
literal|0x3f
operator|)
operator|<<
name|DSPFW_CURSOR_SR_SHIFT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Display HPLL off SR */
name|wm
operator|=
name|intel_calculate_wm
argument_list|(
name|clock
argument_list|,
operator|&
name|pineview_display_hplloff_wm
argument_list|,
name|pineview_display_hplloff_wm
operator|.
name|fifo_size
argument_list|,
name|pixel_size
argument_list|,
name|latency
operator|->
name|display_hpll_disable
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I915_READ
argument_list|(
name|DSPFW3
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|DSPFW_HPLL_SR_MASK
expr_stmt|;
name|reg
operator||=
name|wm
operator|&
name|DSPFW_HPLL_SR_MASK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* cursor HPLL off SR */
name|wm
operator|=
name|intel_calculate_wm
argument_list|(
name|clock
argument_list|,
operator|&
name|pineview_cursor_hplloff_wm
argument_list|,
name|pineview_display_hplloff_wm
operator|.
name|fifo_size
argument_list|,
name|pixel_size
argument_list|,
name|latency
operator|->
name|cursor_hpll_disable
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I915_READ
argument_list|(
name|DSPFW3
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|DSPFW_HPLL_CURSOR_MASK
expr_stmt|;
name|reg
operator||=
operator|(
name|wm
operator|&
literal|0x3f
operator|)
operator|<<
name|DSPFW_HPLL_CURSOR_SHIFT
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"DSPFW3 register is %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* activate cxsr */
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
name|I915_READ
argument_list|(
name|DSPFW3
argument_list|)
operator||
name|PINEVIEW_SELF_REFRESH_EN
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Self-refresh is enabled\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pineview_disable_cxsr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Self-refresh is disabled\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|g4x_compute_wm0
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|display
parameter_list|,
name|int
name|display_latency_ns
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|cursor
parameter_list|,
name|int
name|cursor_latency_ns
parameter_list|,
name|int
modifier|*
name|plane_wm
parameter_list|,
name|int
modifier|*
name|cursor_wm
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|int
name|htotal
decl_stmt|,
name|hdisplay
decl_stmt|,
name|clock
decl_stmt|,
name|pixel_size
decl_stmt|;
name|int
name|line_time_us
decl_stmt|,
name|line_count
decl_stmt|;
name|int
name|entries
decl_stmt|,
name|tlb_miss
decl_stmt|;
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
name|plane
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_crtc_active
argument_list|(
name|crtc
argument_list|)
condition|)
block|{
operator|*
name|cursor_wm
operator|=
name|cursor
operator|->
name|guard_size
expr_stmt|;
operator|*
name|plane_wm
operator|=
name|display
operator|->
name|guard_size
expr_stmt|;
return|return
name|false
return|;
block|}
name|htotal
operator|=
name|crtc
operator|->
name|mode
operator|.
name|htotal
expr_stmt|;
name|hdisplay
operator|=
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
expr_stmt|;
name|clock
operator|=
name|crtc
operator|->
name|mode
operator|.
name|clock
expr_stmt|;
name|pixel_size
operator|=
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
expr_stmt|;
comment|/* Use the small buffer method to calculate plane watermark */
name|entries
operator|=
operator|(
operator|(
name|clock
operator|*
name|pixel_size
operator|/
literal|1000
operator|)
operator|*
name|display_latency_ns
operator|)
operator|/
literal|1000
expr_stmt|;
name|tlb_miss
operator|=
name|display
operator|->
name|fifo_size
operator|*
name|display
operator|->
name|cacheline_size
operator|-
name|hdisplay
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|tlb_miss
operator|>
literal|0
condition|)
name|entries
operator|+=
name|tlb_miss
expr_stmt|;
name|entries
operator|=
name|DIV_ROUND_UP
argument_list|(
name|entries
argument_list|,
name|display
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|plane_wm
operator|=
name|entries
operator|+
name|display
operator|->
name|guard_size
expr_stmt|;
if|if
condition|(
operator|*
name|plane_wm
operator|>
operator|(
name|int
operator|)
name|display
operator|->
name|max_wm
condition|)
operator|*
name|plane_wm
operator|=
name|display
operator|->
name|max_wm
expr_stmt|;
comment|/* Use the large buffer method to calculate cursor watermark */
name|line_time_us
operator|=
operator|(
operator|(
name|htotal
operator|*
literal|1000
operator|)
operator|/
name|clock
operator|)
expr_stmt|;
name|line_count
operator|=
operator|(
name|cursor_latency_ns
operator|/
name|line_time_us
operator|+
literal|1000
operator|)
operator|/
literal|1000
expr_stmt|;
name|entries
operator|=
name|line_count
operator|*
literal|64
operator|*
name|pixel_size
expr_stmt|;
name|tlb_miss
operator|=
name|cursor
operator|->
name|fifo_size
operator|*
name|cursor
operator|->
name|cacheline_size
operator|-
name|hdisplay
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|tlb_miss
operator|>
literal|0
condition|)
name|entries
operator|+=
name|tlb_miss
expr_stmt|;
name|entries
operator|=
name|DIV_ROUND_UP
argument_list|(
name|entries
argument_list|,
name|cursor
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|cursor_wm
operator|=
name|entries
operator|+
name|cursor
operator|->
name|guard_size
expr_stmt|;
if|if
condition|(
operator|*
name|cursor_wm
operator|>
operator|(
name|int
operator|)
name|cursor
operator|->
name|max_wm
condition|)
operator|*
name|cursor_wm
operator|=
operator|(
name|int
operator|)
name|cursor
operator|->
name|max_wm
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * Check the wm result.  *  * If any calculated watermark values is larger than the maximum value that  * can be programmed into the associated watermark register, that watermark  * must be disabled.  */
end_comment

begin_function
specifier|static
name|bool
name|g4x_check_srwm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|display_wm
parameter_list|,
name|int
name|cursor_wm
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|display
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|cursor
parameter_list|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"SR watermark: display plane %d, cursor %d\n"
argument_list|,
name|display_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
if|if
condition|(
name|display_wm
operator|>
name|display
operator|->
name|max_wm
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"display watermark is too large(%d/%ld), disabling\n"
argument_list|,
name|display_wm
argument_list|,
name|display
operator|->
name|max_wm
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|cursor_wm
operator|>
name|cursor
operator|->
name|max_wm
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"cursor watermark is too large(%d/%ld), disabling\n"
argument_list|,
name|cursor_wm
argument_list|,
name|cursor
operator|->
name|max_wm
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|display_wm
operator|||
name|cursor_wm
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"SR latency is 0, disabling\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|g4x_compute_srwm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|,
name|int
name|latency_ns
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|display
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|cursor
parameter_list|,
name|int
modifier|*
name|display_wm
parameter_list|,
name|int
modifier|*
name|cursor_wm
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|int
name|hdisplay
decl_stmt|,
name|htotal
decl_stmt|,
name|pixel_size
decl_stmt|,
name|clock
decl_stmt|;
name|unsigned
name|long
name|line_time_us
decl_stmt|;
name|int
name|line_count
decl_stmt|,
name|line_size
decl_stmt|;
name|int
name|small
decl_stmt|,
name|large
decl_stmt|;
name|int
name|entries
decl_stmt|;
if|if
condition|(
operator|!
name|latency_ns
condition|)
block|{
operator|*
name|display_wm
operator|=
operator|*
name|cursor_wm
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|hdisplay
operator|=
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
expr_stmt|;
name|htotal
operator|=
name|crtc
operator|->
name|mode
operator|.
name|htotal
expr_stmt|;
name|clock
operator|=
name|crtc
operator|->
name|mode
operator|.
name|clock
expr_stmt|;
name|pixel_size
operator|=
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
expr_stmt|;
name|line_time_us
operator|=
operator|(
name|htotal
operator|*
literal|1000
operator|)
operator|/
name|clock
expr_stmt|;
name|line_count
operator|=
operator|(
name|latency_ns
operator|/
name|line_time_us
operator|+
literal|1000
operator|)
operator|/
literal|1000
expr_stmt|;
name|line_size
operator|=
name|hdisplay
operator|*
name|pixel_size
expr_stmt|;
comment|/* Use the minimum of the small and large buffer method for primary */
name|small
operator|=
operator|(
operator|(
name|clock
operator|*
name|pixel_size
operator|/
literal|1000
operator|)
operator|*
name|latency_ns
operator|)
operator|/
literal|1000
expr_stmt|;
name|large
operator|=
name|line_count
operator|*
name|line_size
expr_stmt|;
name|entries
operator|=
name|DIV_ROUND_UP
argument_list|(
name|min
argument_list|(
name|small
argument_list|,
name|large
argument_list|)
argument_list|,
name|display
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|display_wm
operator|=
name|entries
operator|+
name|display
operator|->
name|guard_size
expr_stmt|;
comment|/* calculate the self-refresh watermark for display cursor */
name|entries
operator|=
name|line_count
operator|*
name|pixel_size
operator|*
literal|64
expr_stmt|;
name|entries
operator|=
name|DIV_ROUND_UP
argument_list|(
name|entries
argument_list|,
name|cursor
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|cursor_wm
operator|=
name|entries
operator|+
name|cursor
operator|->
name|guard_size
expr_stmt|;
return|return
name|g4x_check_srwm
argument_list|(
name|dev
argument_list|,
operator|*
name|display_wm
argument_list|,
operator|*
name|cursor_wm
argument_list|,
name|display
argument_list|,
name|cursor
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|vlv_compute_drain_latency
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|,
name|int
modifier|*
name|plane_prec_mult
parameter_list|,
name|int
modifier|*
name|plane_dl
parameter_list|,
name|int
modifier|*
name|cursor_prec_mult
parameter_list|,
name|int
modifier|*
name|cursor_dl
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|int
name|clock
decl_stmt|,
name|pixel_size
decl_stmt|;
name|int
name|entries
decl_stmt|;
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
name|plane
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_crtc_active
argument_list|(
name|crtc
argument_list|)
condition|)
return|return
name|false
return|;
name|clock
operator|=
name|crtc
operator|->
name|mode
operator|.
name|clock
expr_stmt|;
comment|/* VESA DOT Clock */
name|pixel_size
operator|=
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
expr_stmt|;
comment|/* BPP */
name|entries
operator|=
operator|(
name|clock
operator|/
literal|1000
operator|)
operator|*
name|pixel_size
expr_stmt|;
operator|*
name|plane_prec_mult
operator|=
operator|(
name|entries
operator|>
literal|256
operator|)
condition|?
name|DRAIN_LATENCY_PRECISION_32
else|:
name|DRAIN_LATENCY_PRECISION_16
expr_stmt|;
operator|*
name|plane_dl
operator|=
operator|(
literal|64
operator|*
operator|(
operator|*
name|plane_prec_mult
operator|)
operator|*
literal|4
operator|)
operator|/
operator|(
operator|(
name|clock
operator|/
literal|1000
operator|)
operator|*
name|pixel_size
operator|)
expr_stmt|;
name|entries
operator|=
operator|(
name|clock
operator|/
literal|1000
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* BPP is always 4 for cursor */
operator|*
name|cursor_prec_mult
operator|=
operator|(
name|entries
operator|>
literal|256
operator|)
condition|?
name|DRAIN_LATENCY_PRECISION_32
else|:
name|DRAIN_LATENCY_PRECISION_16
expr_stmt|;
operator|*
name|cursor_dl
operator|=
operator|(
literal|64
operator|*
operator|(
operator|*
name|cursor_prec_mult
operator|)
operator|*
literal|4
operator|)
operator|/
operator|(
operator|(
name|clock
operator|/
literal|1000
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * Update drain latency registers of memory arbiter  *  * Valleyview SoC has a new memory arbiter and needs drain latency registers  * to be programmed. Each plane has a drain latency multiplier and a drain  * latency value.  */
end_comment

begin_function
specifier|static
name|void
name|vlv_update_drain_latency
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|planea_prec
decl_stmt|,
name|planea_dl
decl_stmt|,
name|planeb_prec
decl_stmt|,
name|planeb_dl
decl_stmt|;
name|int
name|cursora_prec
decl_stmt|,
name|cursora_dl
decl_stmt|,
name|cursorb_prec
decl_stmt|,
name|cursorb_dl
decl_stmt|;
name|int
name|plane_prec_mult
decl_stmt|,
name|cursor_prec_mult
decl_stmt|;
comment|/* Precision multiplier is 							either 16 or 32 */
comment|/* For plane A, Cursor A */
if|if
condition|(
name|vlv_compute_drain_latency
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|plane_prec_mult
argument_list|,
operator|&
name|planea_dl
argument_list|,
operator|&
name|cursor_prec_mult
argument_list|,
operator|&
name|cursora_dl
argument_list|)
condition|)
block|{
name|cursora_prec
operator|=
operator|(
name|cursor_prec_mult
operator|==
name|DRAIN_LATENCY_PRECISION_32
operator|)
condition|?
name|DDL_CURSORA_PRECISION_32
else|:
name|DDL_CURSORA_PRECISION_16
expr_stmt|;
name|planea_prec
operator|=
operator|(
name|plane_prec_mult
operator|==
name|DRAIN_LATENCY_PRECISION_32
operator|)
condition|?
name|DDL_PLANEA_PRECISION_32
else|:
name|DDL_PLANEA_PRECISION_16
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VLV_DDL1
argument_list|,
name|cursora_prec
operator||
operator|(
name|cursora_dl
operator|<<
name|DDL_CURSORA_SHIFT
operator|)
operator||
name|planea_prec
operator||
name|planea_dl
argument_list|)
expr_stmt|;
block|}
comment|/* For plane B, Cursor B */
if|if
condition|(
name|vlv_compute_drain_latency
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
operator|&
name|plane_prec_mult
argument_list|,
operator|&
name|planeb_dl
argument_list|,
operator|&
name|cursor_prec_mult
argument_list|,
operator|&
name|cursorb_dl
argument_list|)
condition|)
block|{
name|cursorb_prec
operator|=
operator|(
name|cursor_prec_mult
operator|==
name|DRAIN_LATENCY_PRECISION_32
operator|)
condition|?
name|DDL_CURSORB_PRECISION_32
else|:
name|DDL_CURSORB_PRECISION_16
expr_stmt|;
name|planeb_prec
operator|=
operator|(
name|plane_prec_mult
operator|==
name|DRAIN_LATENCY_PRECISION_32
operator|)
condition|?
name|DDL_PLANEB_PRECISION_32
else|:
name|DDL_PLANEB_PRECISION_16
expr_stmt|;
name|I915_WRITE
argument_list|(
name|VLV_DDL2
argument_list|,
name|cursorb_prec
operator||
operator|(
name|cursorb_dl
operator|<<
name|DDL_CURSORB_SHIFT
operator|)
operator||
name|planeb_prec
operator||
name|planeb_dl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|single_plane_enabled
parameter_list|(
name|mask
parameter_list|)
value|((mask) != 0&& powerof2(mask))
end_define

begin_function
specifier|static
name|void
name|valleyview_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|sr_latency_ns
init|=
literal|12000
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|planea_wm
decl_stmt|,
name|planeb_wm
decl_stmt|,
name|cursora_wm
decl_stmt|,
name|cursorb_wm
decl_stmt|;
name|int
name|plane_sr
decl_stmt|,
name|cursor_sr
decl_stmt|;
name|int
name|ignore_plane_sr
decl_stmt|,
name|ignore_cursor_sr
decl_stmt|;
name|unsigned
name|int
name|enabled
init|=
literal|0
decl_stmt|;
name|vlv_update_drain_latency
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|valleyview_wm_info
argument_list|,
name|latency_ns
argument_list|,
operator|&
name|valleyview_cursor_wm_info
argument_list|,
name|latency_ns
argument_list|,
operator|&
name|planea_wm
argument_list|,
operator|&
name|cursora_wm
argument_list|)
condition|)
name|enabled
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
operator|&
name|valleyview_wm_info
argument_list|,
name|latency_ns
argument_list|,
operator|&
name|valleyview_cursor_wm_info
argument_list|,
name|latency_ns
argument_list|,
operator|&
name|planeb_wm
argument_list|,
operator|&
name|cursorb_wm
argument_list|)
condition|)
name|enabled
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|single_plane_enabled
argument_list|(
name|enabled
argument_list|)
operator|&&
name|g4x_compute_srwm
argument_list|(
name|dev
argument_list|,
name|ffs
argument_list|(
name|enabled
argument_list|)
operator|-
literal|1
argument_list|,
name|sr_latency_ns
argument_list|,
operator|&
name|valleyview_wm_info
argument_list|,
operator|&
name|valleyview_cursor_wm_info
argument_list|,
operator|&
name|plane_sr
argument_list|,
operator|&
name|ignore_cursor_sr
argument_list|)
operator|&&
name|g4x_compute_srwm
argument_list|(
name|dev
argument_list|,
name|ffs
argument_list|(
name|enabled
argument_list|)
operator|-
literal|1
argument_list|,
literal|2
operator|*
name|sr_latency_ns
argument_list|,
operator|&
name|valleyview_wm_info
argument_list|,
operator|&
name|valleyview_cursor_wm_info
argument_list|,
operator|&
name|ignore_plane_sr
argument_list|,
operator|&
name|cursor_sr
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF_VLV
argument_list|,
name|FW_CSPWRDWNEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF_VLV
argument_list|,
name|I915_READ
argument_list|(
name|FW_BLC_SELF_VLV
argument_list|)
operator|&
operator|~
name|FW_CSPWRDWNEN
argument_list|)
expr_stmt|;
name|plane_sr
operator|=
name|cursor_sr
operator|=
literal|0
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"Setting FIFO watermarks - A: plane=%d, cursor=%d, B: plane=%d, cursor=%d, SR: plane=%d, cursor=%d\n"
argument_list|,
name|planea_wm
argument_list|,
name|cursora_wm
argument_list|,
name|planeb_wm
argument_list|,
name|cursorb_wm
argument_list|,
name|plane_sr
argument_list|,
name|cursor_sr
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW1
argument_list|,
operator|(
name|plane_sr
operator|<<
name|DSPFW_SR_SHIFT
operator|)
operator||
operator|(
name|cursorb_wm
operator|<<
name|DSPFW_CURSORB_SHIFT
operator|)
operator||
operator|(
name|planeb_wm
operator|<<
name|DSPFW_PLANEB_SHIFT
operator|)
operator||
name|planea_wm
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW2
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|DSPFW2
argument_list|)
operator|&
operator|~
name|DSPFW_CURSORA_MASK
operator|)
operator||
operator|(
name|cursora_wm
operator|<<
name|DSPFW_CURSORA_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|DSPFW3
argument_list|)
operator|&
operator|~
name|DSPFW_CURSOR_SR_MASK
operator|)
operator||
operator|(
name|cursor_sr
operator|<<
name|DSPFW_CURSOR_SR_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g4x_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|sr_latency_ns
init|=
literal|12000
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|planea_wm
decl_stmt|,
name|planeb_wm
decl_stmt|,
name|cursora_wm
decl_stmt|,
name|cursorb_wm
decl_stmt|;
name|int
name|plane_sr
decl_stmt|,
name|cursor_sr
decl_stmt|;
name|unsigned
name|int
name|enabled
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|g4x_wm_info
argument_list|,
name|latency_ns
argument_list|,
operator|&
name|g4x_cursor_wm_info
argument_list|,
name|latency_ns
argument_list|,
operator|&
name|planea_wm
argument_list|,
operator|&
name|cursora_wm
argument_list|)
condition|)
name|enabled
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
operator|&
name|g4x_wm_info
argument_list|,
name|latency_ns
argument_list|,
operator|&
name|g4x_cursor_wm_info
argument_list|,
name|latency_ns
argument_list|,
operator|&
name|planeb_wm
argument_list|,
operator|&
name|cursorb_wm
argument_list|)
condition|)
name|enabled
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|single_plane_enabled
argument_list|(
name|enabled
argument_list|)
operator|&&
name|g4x_compute_srwm
argument_list|(
name|dev
argument_list|,
name|ffs
argument_list|(
name|enabled
argument_list|)
operator|-
literal|1
argument_list|,
name|sr_latency_ns
argument_list|,
operator|&
name|g4x_wm_info
argument_list|,
operator|&
name|g4x_cursor_wm_info
argument_list|,
operator|&
name|plane_sr
argument_list|,
operator|&
name|cursor_sr
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|FW_BLC_SELF_EN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|I915_READ
argument_list|(
name|FW_BLC_SELF
argument_list|)
operator|&
operator|~
name|FW_BLC_SELF_EN
argument_list|)
expr_stmt|;
name|plane_sr
operator|=
name|cursor_sr
operator|=
literal|0
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"Setting FIFO watermarks - A: plane=%d, cursor=%d, B: plane=%d, cursor=%d, SR: plane=%d, cursor=%d\n"
argument_list|,
name|planea_wm
argument_list|,
name|cursora_wm
argument_list|,
name|planeb_wm
argument_list|,
name|cursorb_wm
argument_list|,
name|plane_sr
argument_list|,
name|cursor_sr
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW1
argument_list|,
operator|(
name|plane_sr
operator|<<
name|DSPFW_SR_SHIFT
operator|)
operator||
operator|(
name|cursorb_wm
operator|<<
name|DSPFW_CURSORB_SHIFT
operator|)
operator||
operator|(
name|planeb_wm
operator|<<
name|DSPFW_PLANEB_SHIFT
operator|)
operator||
name|planea_wm
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW2
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|DSPFW2
argument_list|)
operator|&
operator|~
name|DSPFW_CURSORA_MASK
operator|)
operator||
operator|(
name|cursora_wm
operator|<<
name|DSPFW_CURSORA_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* HPLL off in SR has some issues on G4x... disable it */
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|DSPFW3
argument_list|)
operator|&
operator|~
operator|(
name|DSPFW_HPLL_SR_EN
operator||
name|DSPFW_CURSOR_SR_MASK
operator|)
operator|)
operator||
operator|(
name|cursor_sr
operator|<<
name|DSPFW_CURSOR_SR_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i965_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|int
name|srwm
init|=
literal|1
decl_stmt|;
name|int
name|cursor_sr
init|=
literal|16
decl_stmt|;
comment|/* Calc sr entries for one plane configs */
name|crtc
operator|=
name|single_enabled_crtc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
condition|)
block|{
comment|/* self-refresh has much higher latency */
specifier|static
specifier|const
name|int
name|sr_latency_ns
init|=
literal|12000
decl_stmt|;
name|int
name|clock
init|=
name|crtc
operator|->
name|mode
operator|.
name|clock
decl_stmt|;
name|int
name|htotal
init|=
name|crtc
operator|->
name|mode
operator|.
name|htotal
decl_stmt|;
name|int
name|hdisplay
init|=
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
decl_stmt|;
name|int
name|pixel_size
init|=
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
decl_stmt|;
name|unsigned
name|long
name|line_time_us
decl_stmt|;
name|int
name|entries
decl_stmt|;
name|line_time_us
operator|=
operator|(
operator|(
name|htotal
operator|*
literal|1000
operator|)
operator|/
name|clock
operator|)
expr_stmt|;
comment|/* Use ns/us then divide to preserve precision */
name|entries
operator|=
operator|(
operator|(
operator|(
name|sr_latency_ns
operator|/
name|line_time_us
operator|)
operator|+
literal|1000
operator|)
operator|/
literal|1000
operator|)
operator|*
name|pixel_size
operator|*
name|hdisplay
expr_stmt|;
name|entries
operator|=
name|DIV_ROUND_UP
argument_list|(
name|entries
argument_list|,
name|I915_FIFO_LINE_SIZE
argument_list|)
expr_stmt|;
name|srwm
operator|=
name|I965_FIFO_SIZE
operator|-
name|entries
expr_stmt|;
if|if
condition|(
name|srwm
operator|<
literal|0
condition|)
name|srwm
operator|=
literal|1
expr_stmt|;
name|srwm
operator|&=
literal|0x1ff
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"self-refresh entries: %d, wm: %d\n"
argument_list|,
name|entries
argument_list|,
name|srwm
argument_list|)
expr_stmt|;
name|entries
operator|=
operator|(
operator|(
operator|(
name|sr_latency_ns
operator|/
name|line_time_us
operator|)
operator|+
literal|1000
operator|)
operator|/
literal|1000
operator|)
operator|*
name|pixel_size
operator|*
literal|64
expr_stmt|;
name|entries
operator|=
name|DIV_ROUND_UP
argument_list|(
name|entries
argument_list|,
name|i965_cursor_wm_info
operator|.
name|cacheline_size
argument_list|)
expr_stmt|;
name|cursor_sr
operator|=
name|i965_cursor_wm_info
operator|.
name|fifo_size
operator|-
operator|(
name|entries
operator|+
name|i965_cursor_wm_info
operator|.
name|guard_size
operator|)
expr_stmt|;
if|if
condition|(
name|cursor_sr
operator|>
name|i965_cursor_wm_info
operator|.
name|max_wm
condition|)
name|cursor_sr
operator|=
name|i965_cursor_wm_info
operator|.
name|max_wm
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"self-refresh watermark: display plane %d "
literal|"cursor %d\n"
argument_list|,
name|srwm
argument_list|,
name|cursor_sr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CRESTLINE
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|FW_BLC_SELF_EN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Turn off self refresh if both pipes are enabled */
if|if
condition|(
name|IS_CRESTLINE
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|I915_READ
argument_list|(
name|FW_BLC_SELF
argument_list|)
operator|&
operator|~
name|FW_BLC_SELF_EN
argument_list|)
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"Setting FIFO watermarks - A: 8, B: 8, C: 8, SR %d\n"
argument_list|,
name|srwm
argument_list|)
expr_stmt|;
comment|/* 965 has limitations... */
name|I915_WRITE
argument_list|(
name|DSPFW1
argument_list|,
operator|(
name|srwm
operator|<<
name|DSPFW_SR_SHIFT
operator|)
operator||
operator|(
literal|8
operator|<<
literal|16
operator|)
operator||
operator|(
literal|8
operator|<<
literal|8
operator|)
operator||
operator|(
literal|8
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPFW2
argument_list|,
operator|(
literal|8
operator|<<
literal|8
operator|)
operator||
operator|(
literal|8
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* update cursor SR watermark */
name|I915_WRITE
argument_list|(
name|DSPFW3
argument_list|,
operator|(
name|cursor_sr
operator|<<
name|DSPFW_CURSOR_SR_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i9xx_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|wm_info
decl_stmt|;
name|uint32_t
name|fwater_lo
decl_stmt|;
name|uint32_t
name|fwater_hi
decl_stmt|;
name|int
name|cwm
decl_stmt|,
name|srwm
init|=
literal|1
decl_stmt|;
name|int
name|fifo_size
decl_stmt|;
name|int
name|planea_wm
decl_stmt|,
name|planeb_wm
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|,
modifier|*
name|enabled
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
condition|)
name|wm_info
operator|=
operator|&
name|i945_wm_info
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|wm_info
operator|=
operator|&
name|i915_wm_info
expr_stmt|;
else|else
name|wm_info
operator|=
operator|&
name|i855_wm_info
expr_stmt|;
name|fifo_size
operator|=
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_crtc_active
argument_list|(
name|crtc
argument_list|)
condition|)
block|{
name|int
name|cpp
init|=
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|cpp
operator|=
literal|4
expr_stmt|;
name|planea_wm
operator|=
name|intel_calculate_wm
argument_list|(
name|crtc
operator|->
name|mode
operator|.
name|clock
argument_list|,
name|wm_info
argument_list|,
name|fifo_size
argument_list|,
name|cpp
argument_list|,
name|latency_ns
argument_list|)
expr_stmt|;
name|enabled
operator|=
name|crtc
expr_stmt|;
block|}
else|else
name|planea_wm
operator|=
name|fifo_size
operator|-
name|wm_info
operator|->
name|guard_size
expr_stmt|;
name|fifo_size
operator|=
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_crtc_active
argument_list|(
name|crtc
argument_list|)
condition|)
block|{
name|int
name|cpp
init|=
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|IS_GEN2
argument_list|(
name|dev
argument_list|)
condition|)
name|cpp
operator|=
literal|4
expr_stmt|;
name|planeb_wm
operator|=
name|intel_calculate_wm
argument_list|(
name|crtc
operator|->
name|mode
operator|.
name|clock
argument_list|,
name|wm_info
argument_list|,
name|fifo_size
argument_list|,
name|cpp
argument_list|,
name|latency_ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabled
operator|==
name|NULL
condition|)
name|enabled
operator|=
name|crtc
expr_stmt|;
else|else
name|enabled
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|planeb_wm
operator|=
name|fifo_size
operator|-
name|wm_info
operator|->
name|guard_size
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermarks - A: %d, B: %d\n"
argument_list|,
name|planea_wm
argument_list|,
name|planeb_wm
argument_list|)
expr_stmt|;
comment|/* 	 * Overlay gets an aggressive default since video jitter is bad. 	 */
name|cwm
operator|=
literal|2
expr_stmt|;
comment|/* Play safe and disable self-refresh before adjusting watermarks. */
if|if
condition|(
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|FW_BLC_SELF_EN_MASK
operator||
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I915GM
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|INSTPM
argument_list|,
name|I915_READ
argument_list|(
name|INSTPM
argument_list|)
operator|&
operator|~
name|INSTPM_SELF_EN
argument_list|)
expr_stmt|;
comment|/* Calc sr entries for one plane configs */
if|if
condition|(
name|HAS_FW_BLC
argument_list|(
name|dev
argument_list|)
operator|&&
name|enabled
condition|)
block|{
comment|/* self-refresh has much higher latency */
specifier|static
specifier|const
name|int
name|sr_latency_ns
init|=
literal|6000
decl_stmt|;
name|int
name|clock
init|=
name|enabled
operator|->
name|mode
operator|.
name|clock
decl_stmt|;
name|int
name|htotal
init|=
name|enabled
operator|->
name|mode
operator|.
name|htotal
decl_stmt|;
name|int
name|hdisplay
init|=
name|enabled
operator|->
name|mode
operator|.
name|hdisplay
decl_stmt|;
name|int
name|pixel_size
init|=
name|enabled
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
decl_stmt|;
name|unsigned
name|long
name|line_time_us
decl_stmt|;
name|int
name|entries
decl_stmt|;
name|line_time_us
operator|=
operator|(
name|htotal
operator|*
literal|1000
operator|)
operator|/
name|clock
expr_stmt|;
comment|/* Use ns/us then divide to preserve precision */
name|entries
operator|=
operator|(
operator|(
operator|(
name|sr_latency_ns
operator|/
name|line_time_us
operator|)
operator|+
literal|1000
operator|)
operator|/
literal|1000
operator|)
operator|*
name|pixel_size
operator|*
name|hdisplay
expr_stmt|;
name|entries
operator|=
name|DIV_ROUND_UP
argument_list|(
name|entries
argument_list|,
name|wm_info
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"self-refresh entries: %d\n"
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|srwm
operator|=
name|wm_info
operator|->
name|fifo_size
operator|-
name|entries
expr_stmt|;
if|if
condition|(
name|srwm
operator|<
literal|0
condition|)
name|srwm
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|FW_BLC_SELF_FIFO_MASK
operator||
operator|(
name|srwm
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I915GM
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|srwm
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"Setting FIFO watermarks - A: %d, B: %d, C: %d, SR %d\n"
argument_list|,
name|planea_wm
argument_list|,
name|planeb_wm
argument_list|,
name|cwm
argument_list|,
name|srwm
argument_list|)
expr_stmt|;
name|fwater_lo
operator|=
operator|(
operator|(
name|planeb_wm
operator|&
literal|0x3f
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|planea_wm
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|fwater_hi
operator|=
operator|(
name|cwm
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* Set request length to 8 cachelines per fetch */
name|fwater_lo
operator|=
name|fwater_lo
operator||
operator|(
literal|1
operator|<<
literal|24
operator|)
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|fwater_hi
operator|=
name|fwater_hi
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FW_BLC
argument_list|,
name|fwater_lo
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FW_BLC2
argument_list|,
name|fwater_hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FW_BLC
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|enabled
condition|)
block|{
if|if
condition|(
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|FW_BLC_SELF
argument_list|,
name|FW_BLC_SELF_EN_MASK
operator||
name|FW_BLC_SELF_EN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_I915GM
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|INSTPM
argument_list|,
name|I915_READ
argument_list|(
name|INSTPM
argument_list|)
operator||
name|INSTPM_SELF_EN
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"memory self refresh enabled\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|DRM_DEBUG_KMS
argument_list|(
literal|"memory self refresh disabled\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i830_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|uint32_t
name|fwater_lo
decl_stmt|;
name|int
name|planea_wm
decl_stmt|;
name|crtc
operator|=
name|single_enabled_crtc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|==
name|NULL
condition|)
return|return;
name|planea_wm
operator|=
name|intel_calculate_wm
argument_list|(
name|crtc
operator|->
name|mode
operator|.
name|clock
argument_list|,
operator|&
name|i830_wm_info
argument_list|,
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|,
name|latency_ns
argument_list|)
expr_stmt|;
name|fwater_lo
operator|=
name|I915_READ
argument_list|(
name|FW_BLC
argument_list|)
operator|&
operator|~
literal|0xfff
expr_stmt|;
name|fwater_lo
operator||=
operator|(
literal|3
operator|<<
literal|8
operator|)
operator||
name|planea_wm
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Setting FIFO watermarks - A: %d\n"
argument_list|,
name|planea_wm
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FW_BLC
argument_list|,
name|fwater_lo
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ILK_LP0_PLANE_LATENCY
value|700
end_define

begin_define
define|#
directive|define
name|ILK_LP0_CURSOR_LATENCY
value|1300
end_define

begin_comment
comment|/*  * Check the wm result.  *  * If any calculated watermark values is larger than the maximum value that  * can be programmed into the associated watermark register, that watermark  * must be disabled.  */
end_comment

begin_function
specifier|static
name|bool
name|ironlake_check_srwm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|fbc_wm
parameter_list|,
name|int
name|display_wm
parameter_list|,
name|int
name|cursor_wm
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|display
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|cursor
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"watermark %d: display plane %d, fbc lines %d,"
literal|" cursor %d\n"
argument_list|,
name|level
argument_list|,
name|display_wm
argument_list|,
name|fbc_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
if|if
condition|(
name|fbc_wm
operator|>
name|SNB_FBC_MAX_SRWM
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"fbc watermark(%d) is too large(%d), disabling wm%d+\n"
argument_list|,
name|fbc_wm
argument_list|,
name|SNB_FBC_MAX_SRWM
argument_list|,
name|level
argument_list|)
expr_stmt|;
comment|/* fbc has it's own way to disable FBC WM */
name|I915_WRITE
argument_list|(
name|DISP_ARB_CTL
argument_list|,
name|I915_READ
argument_list|(
name|DISP_ARB_CTL
argument_list|)
operator||
name|DISP_FBC_WM_DIS
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|display_wm
operator|>
name|display
operator|->
name|max_wm
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"display watermark(%d) is too large(%d), disabling wm%d+\n"
argument_list|,
name|display_wm
argument_list|,
name|SNB_DISPLAY_MAX_SRWM
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|cursor_wm
operator|>
name|cursor
operator|->
name|max_wm
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"cursor watermark(%d) is too large(%d), disabling wm%d+\n"
argument_list|,
name|cursor_wm
argument_list|,
name|SNB_CURSOR_MAX_SRWM
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|fbc_wm
operator|||
name|display_wm
operator|||
name|cursor_wm
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"latency %d is 0, disabling wm%d+\n"
argument_list|,
name|level
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * Compute watermark values of WM[1-3],  */
end_comment

begin_function
specifier|static
name|bool
name|ironlake_compute_srwm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|plane
parameter_list|,
name|int
name|latency_ns
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|display
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|cursor
parameter_list|,
name|int
modifier|*
name|fbc_wm
parameter_list|,
name|int
modifier|*
name|display_wm
parameter_list|,
name|int
modifier|*
name|cursor_wm
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|unsigned
name|long
name|line_time_us
decl_stmt|;
name|int
name|hdisplay
decl_stmt|,
name|htotal
decl_stmt|,
name|pixel_size
decl_stmt|,
name|clock
decl_stmt|;
name|int
name|line_count
decl_stmt|,
name|line_size
decl_stmt|;
name|int
name|small
decl_stmt|,
name|large
decl_stmt|;
name|int
name|entries
decl_stmt|;
if|if
condition|(
operator|!
name|latency_ns
condition|)
block|{
operator|*
name|fbc_wm
operator|=
operator|*
name|display_wm
operator|=
operator|*
name|cursor_wm
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|hdisplay
operator|=
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
expr_stmt|;
name|htotal
operator|=
name|crtc
operator|->
name|mode
operator|.
name|htotal
expr_stmt|;
name|clock
operator|=
name|crtc
operator|->
name|mode
operator|.
name|clock
expr_stmt|;
name|pixel_size
operator|=
name|crtc
operator|->
name|fb
operator|->
name|bits_per_pixel
operator|/
literal|8
expr_stmt|;
name|line_time_us
operator|=
operator|(
name|htotal
operator|*
literal|1000
operator|)
operator|/
name|clock
expr_stmt|;
name|line_count
operator|=
operator|(
name|latency_ns
operator|/
name|line_time_us
operator|+
literal|1000
operator|)
operator|/
literal|1000
expr_stmt|;
name|line_size
operator|=
name|hdisplay
operator|*
name|pixel_size
expr_stmt|;
comment|/* Use the minimum of the small and large buffer method for primary */
name|small
operator|=
operator|(
operator|(
name|clock
operator|*
name|pixel_size
operator|/
literal|1000
operator|)
operator|*
name|latency_ns
operator|)
operator|/
literal|1000
expr_stmt|;
name|large
operator|=
name|line_count
operator|*
name|line_size
expr_stmt|;
name|entries
operator|=
name|DIV_ROUND_UP
argument_list|(
name|min
argument_list|(
name|small
argument_list|,
name|large
argument_list|)
argument_list|,
name|display
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|display_wm
operator|=
name|entries
operator|+
name|display
operator|->
name|guard_size
expr_stmt|;
comment|/* 	 * Spec says: 	 * FBC WM = ((Final Primary WM * 64) / number of bytes per line) + 2 	 */
operator|*
name|fbc_wm
operator|=
name|DIV_ROUND_UP
argument_list|(
operator|*
name|display_wm
operator|*
literal|64
argument_list|,
name|line_size
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* calculate the self-refresh watermark for display cursor */
name|entries
operator|=
name|line_count
operator|*
name|pixel_size
operator|*
literal|64
expr_stmt|;
name|entries
operator|=
name|DIV_ROUND_UP
argument_list|(
name|entries
argument_list|,
name|cursor
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|cursor_wm
operator|=
name|entries
operator|+
name|cursor
operator|->
name|guard_size
expr_stmt|;
return|return
name|ironlake_check_srwm
argument_list|(
name|dev
argument_list|,
name|level
argument_list|,
operator|*
name|fbc_wm
argument_list|,
operator|*
name|display_wm
argument_list|,
operator|*
name|cursor_wm
argument_list|,
name|display
argument_list|,
name|cursor
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|fbc_wm
decl_stmt|,
name|plane_wm
decl_stmt|,
name|cursor_wm
decl_stmt|;
name|unsigned
name|int
name|enabled
decl_stmt|;
name|enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|ironlake_display_wm_info
argument_list|,
name|ILK_LP0_PLANE_LATENCY
argument_list|,
operator|&
name|ironlake_cursor_wm_info
argument_list|,
name|ILK_LP0_CURSOR_LATENCY
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|WM0_PIPEA_ILK
argument_list|,
operator|(
name|plane_wm
operator|<<
name|WM0_PIPE_PLANE_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermarks For pipe A -"
literal|" plane %d, "
literal|"cursor: %d\n"
argument_list|,
name|plane_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
name|enabled
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
operator|&
name|ironlake_display_wm_info
argument_list|,
name|ILK_LP0_PLANE_LATENCY
argument_list|,
operator|&
name|ironlake_cursor_wm_info
argument_list|,
name|ILK_LP0_CURSOR_LATENCY
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|WM0_PIPEB_ILK
argument_list|,
operator|(
name|plane_wm
operator|<<
name|WM0_PIPE_PLANE_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermarks For pipe B -"
literal|" plane %d, cursor: %d\n"
argument_list|,
name|plane_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
name|enabled
operator||=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Calculate and update the self-refresh watermark only when one 	 * display plane is used. 	 */
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|single_plane_enabled
argument_list|(
name|enabled
argument_list|)
condition|)
return|return;
name|enabled
operator|=
name|ffs
argument_list|(
name|enabled
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* WM1 */
if|if
condition|(
operator|!
name|ironlake_compute_srwm
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
name|enabled
argument_list|,
name|ILK_READ_WM1_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|ironlake_display_srwm_info
argument_list|,
operator|&
name|ironlake_cursor_srwm_info
argument_list|,
operator|&
name|fbc_wm
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
name|WM1_LP_SR_EN
operator||
operator|(
name|ILK_READ_WM1_LATENCY
argument_list|()
operator|<<
name|WM1_LP_LATENCY_SHIFT
operator|)
operator||
operator|(
name|fbc_wm
operator|<<
name|WM1_LP_FBC_SHIFT
operator|)
operator||
operator|(
name|plane_wm
operator|<<
name|WM1_LP_SR_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
comment|/* WM2 */
if|if
condition|(
operator|!
name|ironlake_compute_srwm
argument_list|(
name|dev
argument_list|,
literal|2
argument_list|,
name|enabled
argument_list|,
name|ILK_READ_WM2_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|ironlake_display_srwm_info
argument_list|,
operator|&
name|ironlake_cursor_srwm_info
argument_list|,
operator|&
name|fbc_wm
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
name|WM2_LP_EN
operator||
operator|(
name|ILK_READ_WM2_LATENCY
argument_list|()
operator|<<
name|WM1_LP_LATENCY_SHIFT
operator|)
operator||
operator|(
name|fbc_wm
operator|<<
name|WM1_LP_FBC_SHIFT
operator|)
operator||
operator|(
name|plane_wm
operator|<<
name|WM1_LP_SR_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
comment|/* 	 * WM3 is unsupported on ILK, probably because we don't have latency 	 * data for that power state 	 */
block|}
end_function

begin_function
specifier|static
name|void
name|sandybridge_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|latency
init|=
name|SNB_READ_WM0_LATENCY
argument_list|()
operator|*
literal|100
decl_stmt|;
comment|/* In unit 0.1us */
name|u32
name|val
decl_stmt|;
name|int
name|fbc_wm
decl_stmt|,
name|plane_wm
decl_stmt|,
name|cursor_wm
decl_stmt|;
name|unsigned
name|int
name|enabled
decl_stmt|;
name|enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|sandybridge_display_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|sandybridge_cursor_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
block|{
name|val
operator|=
name|I915_READ
argument_list|(
name|WM0_PIPEA_ILK
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|WM0_PIPE_PLANE_MASK
operator||
name|WM0_PIPE_CURSOR_MASK
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM0_PIPEA_ILK
argument_list|,
name|val
operator||
operator|(
operator|(
name|plane_wm
operator|<<
name|WM0_PIPE_PLANE_SHIFT
operator|)
operator||
name|cursor_wm
operator|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermarks For pipe A -"
literal|" plane %d, "
literal|"cursor: %d\n"
argument_list|,
name|plane_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
name|enabled
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
operator|&
name|sandybridge_display_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|sandybridge_cursor_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
block|{
name|val
operator|=
name|I915_READ
argument_list|(
name|WM0_PIPEB_ILK
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|WM0_PIPE_PLANE_MASK
operator||
name|WM0_PIPE_CURSOR_MASK
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM0_PIPEB_ILK
argument_list|,
name|val
operator||
operator|(
operator|(
name|plane_wm
operator|<<
name|WM0_PIPE_PLANE_SHIFT
operator|)
operator||
name|cursor_wm
operator|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermarks For pipe B -"
literal|" plane %d, cursor: %d\n"
argument_list|,
name|plane_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
name|enabled
operator||=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Calculate and update the self-refresh watermark only when one 	 * display plane is used. 	 * 	 * SNB support 3 levels of watermark. 	 * 	 * WM1/WM2/WM2 watermarks have to be enabled in the ascending order, 	 * and disabled in the descending order 	 * 	 */
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|single_plane_enabled
argument_list|(
name|enabled
argument_list|)
operator|||
name|dev_priv
operator|->
name|sprite_scaling_enabled
condition|)
return|return;
name|enabled
operator|=
name|ffs
argument_list|(
name|enabled
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* WM1 */
if|if
condition|(
operator|!
name|ironlake_compute_srwm
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
name|enabled
argument_list|,
name|SNB_READ_WM1_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
operator|&
name|sandybridge_cursor_srwm_info
argument_list|,
operator|&
name|fbc_wm
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
name|WM1_LP_SR_EN
operator||
operator|(
name|SNB_READ_WM1_LATENCY
argument_list|()
operator|<<
name|WM1_LP_LATENCY_SHIFT
operator|)
operator||
operator|(
name|fbc_wm
operator|<<
name|WM1_LP_FBC_SHIFT
operator|)
operator||
operator|(
name|plane_wm
operator|<<
name|WM1_LP_SR_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
comment|/* WM2 */
if|if
condition|(
operator|!
name|ironlake_compute_srwm
argument_list|(
name|dev
argument_list|,
literal|2
argument_list|,
name|enabled
argument_list|,
name|SNB_READ_WM2_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
operator|&
name|sandybridge_cursor_srwm_info
argument_list|,
operator|&
name|fbc_wm
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
name|WM2_LP_EN
operator||
operator|(
name|SNB_READ_WM2_LATENCY
argument_list|()
operator|<<
name|WM1_LP_LATENCY_SHIFT
operator|)
operator||
operator|(
name|fbc_wm
operator|<<
name|WM1_LP_FBC_SHIFT
operator|)
operator||
operator|(
name|plane_wm
operator|<<
name|WM1_LP_SR_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
comment|/* WM3 */
if|if
condition|(
operator|!
name|ironlake_compute_srwm
argument_list|(
name|dev
argument_list|,
literal|3
argument_list|,
name|enabled
argument_list|,
name|SNB_READ_WM3_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
operator|&
name|sandybridge_cursor_srwm_info
argument_list|,
operator|&
name|fbc_wm
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
name|WM3_LP_EN
operator||
operator|(
name|SNB_READ_WM3_LATENCY
argument_list|()
operator|<<
name|WM1_LP_LATENCY_SHIFT
operator|)
operator||
operator|(
name|fbc_wm
operator|<<
name|WM1_LP_FBC_SHIFT
operator|)
operator||
operator|(
name|plane_wm
operator|<<
name|WM1_LP_SR_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ivybridge_update_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|latency
init|=
name|SNB_READ_WM0_LATENCY
argument_list|()
operator|*
literal|100
decl_stmt|;
comment|/* In unit 0.1us */
name|u32
name|val
decl_stmt|;
name|int
name|fbc_wm
decl_stmt|,
name|plane_wm
decl_stmt|,
name|cursor_wm
decl_stmt|;
name|int
name|ignore_fbc_wm
decl_stmt|,
name|ignore_plane_wm
decl_stmt|,
name|ignore_cursor_wm
decl_stmt|;
name|unsigned
name|int
name|enabled
decl_stmt|;
name|enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|sandybridge_display_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|sandybridge_cursor_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
block|{
name|val
operator|=
name|I915_READ
argument_list|(
name|WM0_PIPEA_ILK
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|WM0_PIPE_PLANE_MASK
operator||
name|WM0_PIPE_CURSOR_MASK
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM0_PIPEA_ILK
argument_list|,
name|val
operator||
operator|(
operator|(
name|plane_wm
operator|<<
name|WM0_PIPE_PLANE_SHIFT
operator|)
operator||
name|cursor_wm
operator|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermarks For pipe A -"
literal|" plane %d, "
literal|"cursor: %d\n"
argument_list|,
name|plane_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
name|enabled
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
operator|&
name|sandybridge_display_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|sandybridge_cursor_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
block|{
name|val
operator|=
name|I915_READ
argument_list|(
name|WM0_PIPEB_ILK
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|WM0_PIPE_PLANE_MASK
operator||
name|WM0_PIPE_CURSOR_MASK
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM0_PIPEB_ILK
argument_list|,
name|val
operator||
operator|(
operator|(
name|plane_wm
operator|<<
name|WM0_PIPE_PLANE_SHIFT
operator|)
operator||
name|cursor_wm
operator|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermarks For pipe B -"
literal|" plane %d, cursor: %d\n"
argument_list|,
name|plane_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
name|enabled
operator||=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|g4x_compute_wm0
argument_list|(
name|dev
argument_list|,
literal|2
argument_list|,
operator|&
name|sandybridge_display_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|sandybridge_cursor_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
block|{
name|val
operator|=
name|I915_READ
argument_list|(
name|WM0_PIPEC_IVB
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|WM0_PIPE_PLANE_MASK
operator||
name|WM0_PIPE_CURSOR_MASK
operator|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM0_PIPEC_IVB
argument_list|,
name|val
operator||
operator|(
operator|(
name|plane_wm
operator|<<
name|WM0_PIPE_PLANE_SHIFT
operator|)
operator||
name|cursor_wm
operator|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"FIFO watermarks For pipe C -"
literal|" plane %d, cursor: %d\n"
argument_list|,
name|plane_wm
argument_list|,
name|cursor_wm
argument_list|)
expr_stmt|;
name|enabled
operator||=
literal|3
expr_stmt|;
block|}
comment|/* 	 * Calculate and update the self-refresh watermark only when one 	 * display plane is used. 	 * 	 * SNB support 3 levels of watermark. 	 * 	 * WM1/WM2/WM2 watermarks have to be enabled in the ascending order, 	 * and disabled in the descending order 	 * 	 */
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|single_plane_enabled
argument_list|(
name|enabled
argument_list|)
operator|||
name|dev_priv
operator|->
name|sprite_scaling_enabled
condition|)
return|return;
name|enabled
operator|=
name|ffs
argument_list|(
name|enabled
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* WM1 */
if|if
condition|(
operator|!
name|ironlake_compute_srwm
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
name|enabled
argument_list|,
name|SNB_READ_WM1_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
operator|&
name|sandybridge_cursor_srwm_info
argument_list|,
operator|&
name|fbc_wm
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
name|WM1_LP_SR_EN
operator||
operator|(
name|SNB_READ_WM1_LATENCY
argument_list|()
operator|<<
name|WM1_LP_LATENCY_SHIFT
operator|)
operator||
operator|(
name|fbc_wm
operator|<<
name|WM1_LP_FBC_SHIFT
operator|)
operator||
operator|(
name|plane_wm
operator|<<
name|WM1_LP_SR_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
comment|/* WM2 */
if|if
condition|(
operator|!
name|ironlake_compute_srwm
argument_list|(
name|dev
argument_list|,
literal|2
argument_list|,
name|enabled
argument_list|,
name|SNB_READ_WM2_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
operator|&
name|sandybridge_cursor_srwm_info
argument_list|,
operator|&
name|fbc_wm
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
name|WM2_LP_EN
operator||
operator|(
name|SNB_READ_WM2_LATENCY
argument_list|()
operator|<<
name|WM1_LP_LATENCY_SHIFT
operator|)
operator||
operator|(
name|fbc_wm
operator|<<
name|WM1_LP_FBC_SHIFT
operator|)
operator||
operator|(
name|plane_wm
operator|<<
name|WM1_LP_SR_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
comment|/* WM3, note we have to correct the cursor latency */
if|if
condition|(
operator|!
name|ironlake_compute_srwm
argument_list|(
name|dev
argument_list|,
literal|3
argument_list|,
name|enabled
argument_list|,
name|SNB_READ_WM3_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
operator|&
name|sandybridge_cursor_srwm_info
argument_list|,
operator|&
name|fbc_wm
argument_list|,
operator|&
name|plane_wm
argument_list|,
operator|&
name|ignore_cursor_wm
argument_list|)
operator|||
operator|!
name|ironlake_compute_srwm
argument_list|(
name|dev
argument_list|,
literal|3
argument_list|,
name|enabled
argument_list|,
literal|2
operator|*
name|SNB_READ_WM3_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
operator|&
name|sandybridge_cursor_srwm_info
argument_list|,
operator|&
name|ignore_fbc_wm
argument_list|,
operator|&
name|ignore_plane_wm
argument_list|,
operator|&
name|cursor_wm
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
name|WM3_LP_EN
operator||
operator|(
name|SNB_READ_WM3_LATENCY
argument_list|()
operator|<<
name|WM1_LP_LATENCY_SHIFT
operator|)
operator||
operator|(
name|fbc_wm
operator|<<
name|WM1_LP_FBC_SHIFT
operator|)
operator||
operator|(
name|plane_wm
operator|<<
name|WM1_LP_SR_SHIFT
operator|)
operator||
name|cursor_wm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|haswell_update_linetime_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|temp
decl_stmt|;
name|temp
operator|=
name|I915_READ
argument_list|(
name|PIPE_WM_LINETIME
argument_list|(
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|PIPE_WM_LINETIME_MASK
expr_stmt|;
comment|/* The WM are computed with base on how long it takes to fill a single 	 * row at the given clock rate, multiplied by 8. 	 * */
name|temp
operator||=
name|PIPE_WM_LINETIME_TIME
argument_list|(
operator|(
operator|(
name|mode
operator|->
name|crtc_hdisplay
operator|*
literal|1000
operator|)
operator|/
name|mode
operator|->
name|clock
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* IPS watermarks are only used by pipe A, and are ignored by 	 * pipes B and C.  They are calculated similarly to the common 	 * linetime values, except that we are using CD clock frequency 	 * in MHz instead of pixel rate for the division. 	 * 	 * This is a placeholder for the IPS watermark calculation code. 	 */
name|I915_WRITE
argument_list|(
name|PIPE_WM_LINETIME
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|sandybridge_compute_sprite_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|,
name|uint32_t
name|sprite_width
parameter_list|,
name|int
name|pixel_size
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|display
parameter_list|,
name|int
name|display_latency_ns
parameter_list|,
name|int
modifier|*
name|sprite_wm
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|int
name|clock
decl_stmt|;
name|int
name|entries
decl_stmt|,
name|tlb_miss
decl_stmt|;
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
name|plane
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intel_crtc_active
argument_list|(
name|crtc
argument_list|)
condition|)
block|{
operator|*
name|sprite_wm
operator|=
name|display
operator|->
name|guard_size
expr_stmt|;
return|return
name|false
return|;
block|}
name|clock
operator|=
name|crtc
operator|->
name|mode
operator|.
name|clock
expr_stmt|;
comment|/* Use the small buffer method to calculate the sprite watermark */
name|entries
operator|=
operator|(
operator|(
name|clock
operator|*
name|pixel_size
operator|/
literal|1000
operator|)
operator|*
name|display_latency_ns
operator|)
operator|/
literal|1000
expr_stmt|;
name|tlb_miss
operator|=
name|display
operator|->
name|fifo_size
operator|*
name|display
operator|->
name|cacheline_size
operator|-
name|sprite_width
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|tlb_miss
operator|>
literal|0
condition|)
name|entries
operator|+=
name|tlb_miss
expr_stmt|;
name|entries
operator|=
name|DIV_ROUND_UP
argument_list|(
name|entries
argument_list|,
name|display
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|sprite_wm
operator|=
name|entries
operator|+
name|display
operator|->
name|guard_size
expr_stmt|;
if|if
condition|(
operator|*
name|sprite_wm
operator|>
operator|(
name|int
operator|)
name|display
operator|->
name|max_wm
condition|)
operator|*
name|sprite_wm
operator|=
name|display
operator|->
name|max_wm
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|sandybridge_compute_sprite_srwm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|,
name|uint32_t
name|sprite_width
parameter_list|,
name|int
name|pixel_size
parameter_list|,
specifier|const
name|struct
name|intel_watermark_params
modifier|*
name|display
parameter_list|,
name|int
name|latency_ns
parameter_list|,
name|int
modifier|*
name|sprite_wm
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|unsigned
name|long
name|line_time_us
decl_stmt|;
name|int
name|clock
decl_stmt|;
name|int
name|line_count
decl_stmt|,
name|line_size
decl_stmt|;
name|int
name|small
decl_stmt|,
name|large
decl_stmt|;
name|int
name|entries
decl_stmt|;
if|if
condition|(
operator|!
name|latency_ns
condition|)
block|{
operator|*
name|sprite_wm
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
name|crtc
operator|=
name|intel_get_crtc_for_plane
argument_list|(
name|dev
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|clock
operator|=
name|crtc
operator|->
name|mode
operator|.
name|clock
expr_stmt|;
if|if
condition|(
operator|!
name|clock
condition|)
block|{
operator|*
name|sprite_wm
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
name|line_time_us
operator|=
operator|(
name|sprite_width
operator|*
literal|1000
operator|)
operator|/
name|clock
expr_stmt|;
if|if
condition|(
operator|!
name|line_time_us
condition|)
block|{
operator|*
name|sprite_wm
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
name|line_count
operator|=
operator|(
name|latency_ns
operator|/
name|line_time_us
operator|+
literal|1000
operator|)
operator|/
literal|1000
expr_stmt|;
name|line_size
operator|=
name|sprite_width
operator|*
name|pixel_size
expr_stmt|;
comment|/* Use the minimum of the small and large buffer method for primary */
name|small
operator|=
operator|(
operator|(
name|clock
operator|*
name|pixel_size
operator|/
literal|1000
operator|)
operator|*
name|latency_ns
operator|)
operator|/
literal|1000
expr_stmt|;
name|large
operator|=
name|line_count
operator|*
name|line_size
expr_stmt|;
name|entries
operator|=
name|DIV_ROUND_UP
argument_list|(
name|min
argument_list|(
name|small
argument_list|,
name|large
argument_list|)
argument_list|,
name|display
operator|->
name|cacheline_size
argument_list|)
expr_stmt|;
operator|*
name|sprite_wm
operator|=
name|entries
operator|+
name|display
operator|->
name|guard_size
expr_stmt|;
return|return
operator|*
name|sprite_wm
operator|>
literal|0x3ff
condition|?
name|false
else|:
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sandybridge_update_sprite_wm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|,
name|uint32_t
name|sprite_width
parameter_list|,
name|int
name|pixel_size
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|latency
init|=
name|SNB_READ_WM0_LATENCY
argument_list|()
operator|*
literal|100
decl_stmt|;
comment|/* In unit 0.1us */
name|u32
name|val
decl_stmt|;
name|int
name|sprite_wm
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
case|case
literal|0
case|:
name|reg
operator|=
name|WM0_PIPEA_ILK
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|reg
operator|=
name|WM0_PIPEB_ILK
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|reg
operator|=
name|WM0_PIPEC_IVB
expr_stmt|;
break|break;
default|default:
return|return;
comment|/* bad pipe */
block|}
name|ret
operator|=
name|sandybridge_compute_sprite_wm
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|sprite_width
argument_list|,
name|pixel_size
argument_list|,
operator|&
name|sandybridge_display_wm_info
argument_list|,
name|latency
argument_list|,
operator|&
name|sprite_wm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"failed to compute sprite wm for pipe %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return;
block|}
name|val
operator|=
name|I915_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|WM0_PIPE_SPRITE_MASK
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
operator||
operator|(
name|sprite_wm
operator|<<
name|WM0_PIPE_SPRITE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"sprite watermarks For pipe %d - %d\n"
argument_list|,
name|pipe
argument_list|,
name|sprite_wm
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sandybridge_compute_sprite_srwm
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|sprite_width
argument_list|,
name|pixel_size
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
name|SNB_READ_WM1_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sprite_wm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"failed to compute sprite lp1 wm on pipe %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return;
block|}
name|I915_WRITE
argument_list|(
name|WM1S_LP_ILK
argument_list|,
name|sprite_wm
argument_list|)
expr_stmt|;
comment|/* Only IVB has two more LP watermarks for sprite */
if|if
condition|(
operator|!
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|ret
operator|=
name|sandybridge_compute_sprite_srwm
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|sprite_width
argument_list|,
name|pixel_size
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
name|SNB_READ_WM2_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sprite_wm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"failed to compute sprite lp2 wm on pipe %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return;
block|}
name|I915_WRITE
argument_list|(
name|WM2S_LP_IVB
argument_list|,
name|sprite_wm
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sandybridge_compute_sprite_srwm
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|sprite_width
argument_list|,
name|pixel_size
argument_list|,
operator|&
name|sandybridge_display_srwm_info
argument_list|,
name|SNB_READ_WM3_LATENCY
argument_list|()
operator|*
literal|500
argument_list|,
operator|&
name|sprite_wm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"failed to compute sprite lp3 wm on pipe %d\n"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return;
block|}
name|I915_WRITE
argument_list|(
name|WM3S_LP_IVB
argument_list|,
name|sprite_wm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * intel_update_watermarks - update FIFO watermark values based on current modes  *  * Calculate watermark values for the various WM regs based on current mode  * and plane configuration.  *  * There are several cases to deal with here:  *   - normal (i.e. non-self-refresh)  *   - self-refresh (SR) mode  *   - lines are large relative to FIFO size (buffer can hold up to 2)  *   - lines are small relative to FIFO size (buffer can hold more than 2  *     lines), so need to account for TLB latency  *  *   The normal calculation is:  *     watermark = dotclock * bytes per pixel * latency  *   where latency is platform& configuration dependent (we assume pessimal  *   values here).  *  *   The SR calculation is:  *     watermark = (trunc(latency/line time)+1) * surface width *  *       bytes per pixel  *   where  *     line time = htotal / dotclock  *     surface width = hdisplay for normal plane and 64 for cursor  *   and latency is assumed to be high, as above.  *  * The final value programmed to the register should always be rounded up,  * and include an extra 2 entries to account for clock crossings.  *  * We don't use the sprite, so we can ignore that.  And on Crestline we have  * to set the non-SR watermarks to 8.  */
end_comment

begin_function
name|void
name|intel_update_watermarks
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_update_linetime_watermarks
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|display
operator|.
name|update_linetime_wm
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|update_linetime_wm
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_update_sprite_watermarks
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|,
name|uint32_t
name|sprite_width
parameter_list|,
name|int
name|pixel_size
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|display
operator|.
name|update_sprite_wm
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|update_sprite_wm
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
name|sprite_width
argument_list|,
name|pixel_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_i915_gem_object
modifier|*
name|intel_alloc_context_page
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|ctx
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_LOCK_ASSERT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|i915_gem_alloc_object
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"failed to alloc power context, RC6 disabled\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|=
name|i915_gem_object_pin
argument_list|(
name|ctx
argument_list|,
literal|4096
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to pin power context: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unref
goto|;
block|}
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to set-domain on power context: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unpin
goto|;
block|}
return|return
name|ctx
return|;
name|err_unpin
label|:
name|i915_gem_object_unpin
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|err_unref
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|ctx
operator|->
name|base
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Lock protecting IPS related data structures  */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|mchdev_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|mchdev
argument_list|,
operator|&
name|mchdev_lock
argument_list|,
literal|"mchdev"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Global for IPS driver to get at the current i915 device. Protected by  * mchdev_lock. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|drm_i915_private
modifier|*
name|i915_mch_dev
decl_stmt|;
end_decl_stmt

begin_function
name|bool
name|ironlake_set_drps
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|u8
name|val
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u16
name|rgvswctl
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|mchdev_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|rgvswctl
operator|=
name|I915_READ16
argument_list|(
name|MEMSWCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rgvswctl
operator|&
name|MEMCTL_CMD_STS
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"gpu busy, RCS change rejected\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
comment|/* still busy with another command */
block|}
name|rgvswctl
operator|=
operator|(
name|MEMCTL_CMD_CHFREQ
operator|<<
name|MEMCTL_CMD_SHIFT
operator|)
operator||
operator|(
name|val
operator|<<
name|MEMCTL_FREQ_SHIFT
operator|)
operator||
name|MEMCTL_SFCAVM
expr_stmt|;
name|I915_WRITE16
argument_list|(
name|MEMSWCTL
argument_list|,
name|rgvswctl
argument_list|)
expr_stmt|;
name|POSTING_READ16
argument_list|(
name|MEMSWCTL
argument_list|)
expr_stmt|;
name|rgvswctl
operator||=
name|MEMCTL_CMD_STS
expr_stmt|;
name|I915_WRITE16
argument_list|(
name|MEMSWCTL
argument_list|,
name|rgvswctl
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_enable_drps
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|rgvmodectl
init|=
name|I915_READ
argument_list|(
name|MEMMODECTL
argument_list|)
decl_stmt|;
name|u8
name|fmax
decl_stmt|,
name|fmin
decl_stmt|,
name|fstart
decl_stmt|,
name|vstart
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
comment|/* Enable temp reporting */
name|I915_WRITE16
argument_list|(
name|PMMISC
argument_list|,
name|I915_READ
argument_list|(
name|PMMISC
argument_list|)
operator||
name|MCPPCE_EN
argument_list|)
expr_stmt|;
name|I915_WRITE16
argument_list|(
name|TSC1
argument_list|,
name|I915_READ
argument_list|(
name|TSC1
argument_list|)
operator||
name|TSE
argument_list|)
expr_stmt|;
comment|/* 100ms RC evaluation intervals */
name|I915_WRITE
argument_list|(
name|RCUPEI
argument_list|,
literal|100000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RCDNEI
argument_list|,
literal|100000
argument_list|)
expr_stmt|;
comment|/* Set max/min thresholds to 90ms and 80ms respectively */
name|I915_WRITE
argument_list|(
name|RCBMAXAVG
argument_list|,
literal|90000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RCBMINAVG
argument_list|,
literal|80000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|MEMIHYST
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set up min, max, and cur for interrupt handling */
name|fmax
operator|=
operator|(
name|rgvmodectl
operator|&
name|MEMMODE_FMAX_MASK
operator|)
operator|>>
name|MEMMODE_FMAX_SHIFT
expr_stmt|;
name|fmin
operator|=
operator|(
name|rgvmodectl
operator|&
name|MEMMODE_FMIN_MASK
operator|)
expr_stmt|;
name|fstart
operator|=
operator|(
name|rgvmodectl
operator|&
name|MEMMODE_FSTART_MASK
operator|)
operator|>>
name|MEMMODE_FSTART_SHIFT
expr_stmt|;
name|vstart
operator|=
operator|(
name|I915_READ
argument_list|(
name|PXVFREQ_BASE
operator|+
operator|(
name|fstart
operator|*
literal|4
operator|)
argument_list|)
operator|&
name|PXVFREQ_PX_MASK
operator|)
operator|>>
name|PXVFREQ_PX_SHIFT
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|fmax
operator|=
name|fmax
expr_stmt|;
comment|/* IPS callback will increase this */
name|dev_priv
operator|->
name|ips
operator|.
name|fstart
operator|=
name|fstart
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|max_delay
operator|=
name|fstart
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|min_delay
operator|=
name|fmin
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|cur_delay
operator|=
name|fstart
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"fmax: %d, fmin: %d, fstart: %d\n"
argument_list|,
name|fmax
argument_list|,
name|fmin
argument_list|,
name|fstart
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|MEMINTREN
argument_list|,
name|MEMINT_CX_SUPR_EN
operator||
name|MEMINT_EVAL_CHG_EN
argument_list|)
expr_stmt|;
comment|/* 	 * Interrupts will be enabled in ironlake_irq_postinstall 	 */
name|I915_WRITE
argument_list|(
name|VIDSTART
argument_list|,
name|vstart
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|VIDSTART
argument_list|)
expr_stmt|;
name|rgvmodectl
operator||=
name|MEMMODE_SWMODE_EN
expr_stmt|;
name|I915_WRITE
argument_list|(
name|MEMMODECTL
argument_list|,
name|rgvmodectl
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_atomic
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|MEMSWCTL
argument_list|)
operator|&
name|MEMCTL_CMD_STS
operator|)
operator|==
literal|0
argument_list|,
literal|10
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"stuck trying to change perf mode\n"
argument_list|)
expr_stmt|;
name|mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ironlake_set_drps
argument_list|(
name|dev
argument_list|,
name|fstart
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|last_count1
operator|=
name|I915_READ
argument_list|(
literal|0x112e4
argument_list|)
operator|+
name|I915_READ
argument_list|(
literal|0x112e8
argument_list|)
operator|+
name|I915_READ
argument_list|(
literal|0x112e0
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|last_time1
operator|=
name|jiffies_to_msecs
argument_list|(
name|jiffies
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|last_count2
operator|=
name|I915_READ
argument_list|(
literal|0x112f4
argument_list|)
expr_stmt|;
name|getrawmonotonic
argument_list|(
operator|&
name|dev_priv
operator|->
name|ips
operator|.
name|last_time2
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_disable_drps
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u16
name|rgvswctl
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
name|rgvswctl
operator|=
name|I915_READ16
argument_list|(
name|MEMSWCTL
argument_list|)
expr_stmt|;
comment|/* Ack interrupts, disable EFC interrupt */
name|I915_WRITE
argument_list|(
name|MEMINTREN
argument_list|,
name|I915_READ
argument_list|(
name|MEMINTREN
argument_list|)
operator|&
operator|~
name|MEMINT_EVAL_CHG_EN
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|MEMINTRSTS
argument_list|,
name|MEMINT_EVAL_CHG
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIER
argument_list|,
name|I915_READ
argument_list|(
name|DEIER
argument_list|)
operator|&
operator|~
name|DE_PCU_EVENT
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIIR
argument_list|,
name|DE_PCU_EVENT
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DEIMR
argument_list|,
name|I915_READ
argument_list|(
name|DEIMR
argument_list|)
operator||
name|DE_PCU_EVENT
argument_list|)
expr_stmt|;
comment|/* Go back to the starting frequency */
name|ironlake_set_drps
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|ips
operator|.
name|fstart
argument_list|)
expr_stmt|;
name|mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rgvswctl
operator||=
name|MEMCTL_CMD_STS
expr_stmt|;
name|I915_WRITE
argument_list|(
name|MEMSWCTL
argument_list|,
name|rgvswctl
argument_list|)
expr_stmt|;
name|mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* There's a funny hw issue where the hw returns all 0 when reading from  * GEN6_RP_INTERRUPT_LIMITS. Hence we always need to compute the desired value  * ourselves, instead of doing a rmw cycle (which might result in us clearing  * all limits and the gpu stuck at whatever frequency it is at atm).  */
end_comment

begin_function
specifier|static
name|u32
name|gen6_rps_limits
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|u8
modifier|*
name|val
parameter_list|)
block|{
name|u32
name|limits
decl_stmt|;
name|limits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|val
operator|>=
name|dev_priv
operator|->
name|rps
operator|.
name|max_delay
condition|)
operator|*
name|val
operator|=
name|dev_priv
operator|->
name|rps
operator|.
name|max_delay
expr_stmt|;
name|limits
operator||=
name|dev_priv
operator|->
name|rps
operator|.
name|max_delay
operator|<<
literal|24
expr_stmt|;
comment|/* Only set the down limit when we've reached the lowest level to avoid 	 * getting more interrupts, otherwise leave this clear. This prevents a 	 * race in the hw when coming out of rc6: There's a tiny window where 	 * the hw runs at the minimal clock before selecting the desired 	 * frequency, if the down threshold expires in that window we will not 	 * receive a down interrupt. */
if|if
condition|(
operator|*
name|val
operator|<=
name|dev_priv
operator|->
name|rps
operator|.
name|min_delay
condition|)
block|{
operator|*
name|val
operator|=
name|dev_priv
operator|->
name|rps
operator|.
name|min_delay
expr_stmt|;
name|limits
operator||=
name|dev_priv
operator|->
name|rps
operator|.
name|min_delay
operator|<<
literal|16
expr_stmt|;
block|}
return|return
name|limits
return|;
block|}
end_function

begin_function
name|void
name|gen6_set_rps
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|u8
name|val
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|limits
init|=
name|gen6_rps_limits
argument_list|(
name|dev_priv
argument_list|,
operator|&
name|val
argument_list|)
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|hw_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
name|val
operator|>
name|dev_priv
operator|->
name|rps
operator|.
name|max_delay
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
name|val
operator|<
name|dev_priv
operator|->
name|rps
operator|.
name|min_delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|dev_priv
operator|->
name|rps
operator|.
name|cur_delay
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|GEN6_RPNSWREQ
argument_list|,
name|GEN6_FREQUENCY
argument_list|(
name|val
argument_list|)
operator||
name|GEN6_OFFSET
argument_list|(
literal|0
argument_list|)
operator||
name|GEN6_AGGRESSIVE_TURBO
argument_list|)
expr_stmt|;
comment|/* Make sure we continue to get interrupts 	 * until we hit the minimum or maximum frequencies. 	 */
name|I915_WRITE
argument_list|(
name|GEN6_RP_INTERRUPT_LIMITS
argument_list|,
name|limits
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|GEN6_RPNSWREQ
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|rps
operator|.
name|cur_delay
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen6_disable_rps
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RPNSWREQ
argument_list|,
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PMINTRMSK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PMIER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Complete PM interrupt masking here doesn't race with the rps work 	 * item again unmasking PM interrupts because that is using a different 	 * register (PMIMR) to mask PM interrupts. The only risk is in leaving 	 * stale bits in PMIIR and PMIMR which gen6_enable_rps will clean up. */
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|lock
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|rps
operator|.
name|pm_iir
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|lock
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PMIIR
argument_list|,
name|I915_READ
argument_list|(
name|GEN6_PMIIR
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|intel_enable_rc6
parameter_list|(
specifier|const
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
comment|/* Respect the kernel parameter if it is set */
if|if
condition|(
name|i915_enable_rc6
operator|>=
literal|0
condition|)
return|return
name|i915_enable_rc6
return|;
comment|/* Disable RC6 on Ironlake */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|==
literal|5
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"Haswell: only RC6 available\n"
argument_list|)
expr_stmt|;
return|return
name|INTEL_RC6_ENABLE
return|;
block|}
comment|/* snb/ivb have more than one rc6 state. */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|==
literal|6
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"Sandybridge: deep RC6 disabled\n"
argument_list|)
expr_stmt|;
return|return
name|INTEL_RC6_ENABLE
return|;
block|}
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"RC6 and deep RC6 enabled\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|INTEL_RC6_ENABLE
operator||
name|INTEL_RC6p_ENABLE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen6_enable_rps
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|u32
name|rp_state_cap
decl_stmt|;
name|u32
name|gt_perf_status
decl_stmt|;
name|u32
name|rc6vids
decl_stmt|,
name|pcu_mbox
decl_stmt|,
name|rc6_mask
init|=
literal|0
decl_stmt|;
name|u32
name|gtfifodbg
decl_stmt|;
name|int
name|rc6_mode
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|hw_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
comment|/* Here begins a magic sequence of register writes to enable 	 * auto-downclocking. 	 * 	 * Perhaps there might be some value in exposing these to 	 * userspace... 	 */
name|I915_WRITE
argument_list|(
name|GEN6_RC_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear the DBG now so we don't confuse earlier errors */
if|if
condition|(
operator|(
name|gtfifodbg
operator|=
name|I915_READ
argument_list|(
name|GTFIFODBG
argument_list|)
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"GT fifo had a previous error %x\n"
argument_list|,
name|gtfifodbg
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GTFIFODBG
argument_list|,
name|gtfifodbg
argument_list|)
expr_stmt|;
block|}
name|gen6_gt_force_wake_get
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|rp_state_cap
operator|=
name|I915_READ
argument_list|(
name|GEN6_RP_STATE_CAP
argument_list|)
expr_stmt|;
name|gt_perf_status
operator|=
name|I915_READ
argument_list|(
name|GEN6_GT_PERF_STATUS
argument_list|)
expr_stmt|;
comment|/* In units of 100MHz */
name|dev_priv
operator|->
name|rps
operator|.
name|max_delay
operator|=
name|rp_state_cap
operator|&
literal|0xff
expr_stmt|;
name|dev_priv
operator|->
name|rps
operator|.
name|min_delay
operator|=
operator|(
name|rp_state_cap
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|dev_priv
operator|->
name|rps
operator|.
name|cur_delay
operator|=
literal|0
expr_stmt|;
comment|/* disable the counters and set deterministic thresholds */
name|I915_WRITE
argument_list|(
name|GEN6_RC_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC1_WAKE_RATE_LIMIT
argument_list|,
literal|1000
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC6_WAKE_RATE_LIMIT
argument_list|,
literal|40
operator|<<
literal|16
operator||
literal|30
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC6pp_WAKE_RATE_LIMIT
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC_EVALUATION_INTERVAL
argument_list|,
literal|125000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC_IDLE_HYSTERSIS
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
name|I915_WRITE
argument_list|(
name|RING_MAX_IDLE
argument_list|(
name|ring
operator|->
name|mmio_base
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC_SLEEP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC1e_THRESHOLD
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC6_THRESHOLD
argument_list|,
literal|50000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC6p_THRESHOLD
argument_list|,
literal|150000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC6pp_THRESHOLD
argument_list|,
literal|64000
argument_list|)
expr_stmt|;
comment|/* unused */
comment|/* Check if we are enabling RC6 */
name|rc6_mode
operator|=
name|intel_enable_rc6
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc6_mode
operator|&
name|INTEL_RC6_ENABLE
condition|)
name|rc6_mask
operator||=
name|GEN6_RC_CTL_RC6_ENABLE
expr_stmt|;
comment|/* We don't use those on Haswell */
if|if
condition|(
operator|!
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|rc6_mode
operator|&
name|INTEL_RC6p_ENABLE
condition|)
name|rc6_mask
operator||=
name|GEN6_RC_CTL_RC6p_ENABLE
expr_stmt|;
if|if
condition|(
name|rc6_mode
operator|&
name|INTEL_RC6pp_ENABLE
condition|)
name|rc6_mask
operator||=
name|GEN6_RC_CTL_RC6pp_ENABLE
expr_stmt|;
block|}
name|DRM_INFO
argument_list|(
literal|"Enabling RC6 states: RC6 %s, RC6p %s, RC6pp %s\n"
argument_list|,
operator|(
name|rc6_mask
operator|&
name|GEN6_RC_CTL_RC6_ENABLE
operator|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|,
operator|(
name|rc6_mask
operator|&
name|GEN6_RC_CTL_RC6p_ENABLE
operator|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|,
operator|(
name|rc6_mask
operator|&
name|GEN6_RC_CTL_RC6pp_ENABLE
operator|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC_CONTROL
argument_list|,
name|rc6_mask
operator||
name|GEN6_RC_CTL_EI_MODE
argument_list|(
literal|1
argument_list|)
operator||
name|GEN6_RC_CTL_HW_ENABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RPNSWREQ
argument_list|,
name|GEN6_FREQUENCY
argument_list|(
literal|10
argument_list|)
operator||
name|GEN6_OFFSET
argument_list|(
literal|0
argument_list|)
operator||
name|GEN6_AGGRESSIVE_TURBO
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RC_VIDEO_FREQ
argument_list|,
name|GEN6_FREQUENCY
argument_list|(
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_DOWN_TIMEOUT
argument_list|,
literal|1000000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_INTERRUPT_LIMITS
argument_list|,
name|dev_priv
operator|->
name|rps
operator|.
name|max_delay
operator|<<
literal|24
operator||
name|dev_priv
operator|->
name|rps
operator|.
name|min_delay
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_UP_THRESHOLD
argument_list|,
literal|59400
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_DOWN_THRESHOLD
argument_list|,
literal|245000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_UP_EI
argument_list|,
literal|66000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_DOWN_EI
argument_list|,
literal|350000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_IDLE_HYSTERSIS
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_RP_CONTROL
argument_list|,
name|GEN6_RP_MEDIA_TURBO
operator||
name|GEN6_RP_MEDIA_HW_NORMAL_MODE
operator||
name|GEN6_RP_MEDIA_IS_GFX
operator||
name|GEN6_RP_ENABLE
operator||
name|GEN6_RP_UP_BUSY_AVG
operator||
operator|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|?
name|GEN7_RP_DOWN_IDLE_AVG
else|:
name|GEN6_RP_DOWN_IDLE_CONT
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sandybridge_pcode_write
argument_list|(
name|dev_priv
argument_list|,
name|GEN6_PCODE_WRITE_MIN_FREQ_TABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|pcu_mbox
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|sandybridge_pcode_read
argument_list|(
name|dev_priv
argument_list|,
name|GEN6_READ_OC_PARAMS
argument_list|,
operator|&
name|pcu_mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|pcu_mbox
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
condition|)
block|{
comment|/* OC supported */
name|dev_priv
operator|->
name|rps
operator|.
name|max_delay
operator|=
name|pcu_mbox
operator|&
literal|0xff
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"overclocking supported, adjusting frequency max to %dMHz\n"
argument_list|,
name|pcu_mbox
operator|*
literal|50
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"Failed to set the min frequency\n"
argument_list|)
expr_stmt|;
block|}
name|gen6_set_rps
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
operator|(
name|gt_perf_status
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* requires MSI enabled */
name|I915_WRITE
argument_list|(
name|GEN6_PMIER
argument_list|,
name|GEN6_PM_DEFERRED_EVENTS
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|lock
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
name|dev_priv
operator|->
name|rps
operator|.
name|pm_iir
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PMIMR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* enable all PM interrupts */
name|I915_WRITE
argument_list|(
name|GEN6_PMINTRMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc6vids
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|sandybridge_pcode_read
argument_list|(
name|dev_priv
argument_list|,
name|GEN6_PCODE_READ_RC6VIDS
argument_list|,
operator|&
name|rc6vids
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|&&
name|ret
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"Couldn't check for BIOS workaround\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|GEN6_DECODE_RC6_VID
argument_list|(
name|rc6vids
operator|&
literal|0xff
argument_list|)
operator|<
literal|450
operator|)
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"You should update your BIOS. Correcting minimum rc6 voltage (%dmV->%dmV)\n"
argument_list|,
name|GEN6_DECODE_RC6_VID
argument_list|(
name|rc6vids
operator|&
literal|0xff
argument_list|)
argument_list|,
literal|450
argument_list|)
expr_stmt|;
name|rc6vids
operator|&=
literal|0xffff00
expr_stmt|;
name|rc6vids
operator||=
name|GEN6_ENCODE_RC6_VID
argument_list|(
literal|450
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sandybridge_pcode_write
argument_list|(
name|dev_priv
argument_list|,
name|GEN6_PCODE_WRITE_RC6VIDS
argument_list|,
name|rc6vids
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|DRM_ERROR
argument_list|(
literal|"Couldn't fix incorrect rc6 voltage\n"
argument_list|)
expr_stmt|;
block|}
name|gen6_gt_force_wake_put
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen6_update_ring_freq
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|min_freq
init|=
literal|15
decl_stmt|;
name|int
name|gpu_freq
decl_stmt|;
name|unsigned
name|int
name|ia_freq
decl_stmt|,
name|max_ia_freq
decl_stmt|;
name|int
name|scaling_factor
init|=
literal|180
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|hw_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|max_ia_freq
operator|=
name|cpufreq_quick_get_max
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Default to measured freq if none found, PCU will ensure we don't go 	 * over 	 */
if|if
condition|(
operator|!
name|max_ia_freq
condition|)
name|max_ia_freq
operator|=
name|tsc_khz
expr_stmt|;
else|#
directive|else
name|uint64_t
name|tsc_freq
decl_stmt|;
name|tsc_freq
operator|=
name|atomic_load_acq_64
argument_list|(
operator|&
name|tsc_freq
argument_list|)
expr_stmt|;
name|max_ia_freq
operator|=
name|tsc_freq
operator|/
literal|1000
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
comment|/* Convert from kHz to MHz */
name|max_ia_freq
operator|/=
literal|1000
expr_stmt|;
comment|/* 	 * For each potential GPU frequency, load a ring frequency we'd like 	 * to use for memory access.  We do this by specifying the IA frequency 	 * the PCU should use as a reference to determine the ring frequency. 	 */
for|for
control|(
name|gpu_freq
operator|=
name|dev_priv
operator|->
name|rps
operator|.
name|max_delay
init|;
name|gpu_freq
operator|>=
name|dev_priv
operator|->
name|rps
operator|.
name|min_delay
condition|;
name|gpu_freq
operator|--
control|)
block|{
name|int
name|diff
init|=
name|dev_priv
operator|->
name|rps
operator|.
name|max_delay
operator|-
name|gpu_freq
decl_stmt|;
comment|/* 		 * For GPU frequencies less than 750MHz, just use the lowest 		 * ring freq. 		 */
if|if
condition|(
name|gpu_freq
operator|<
name|min_freq
condition|)
name|ia_freq
operator|=
literal|800
expr_stmt|;
else|else
name|ia_freq
operator|=
name|max_ia_freq
operator|-
operator|(
operator|(
name|diff
operator|*
name|scaling_factor
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
name|ia_freq
operator|=
name|DIV_ROUND_CLOSEST
argument_list|(
name|ia_freq
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|ia_freq
operator|<<=
name|GEN6_PCODE_FREQ_IA_RATIO_SHIFT
expr_stmt|;
name|sandybridge_pcode_write
argument_list|(
name|dev_priv
argument_list|,
name|GEN6_PCODE_WRITE_MIN_FREQ_TABLE
argument_list|,
name|ia_freq
operator||
name|gpu_freq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ironlake_teardown_rc6
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|ips
operator|.
name|renderctx
condition|)
block|{
name|i915_gem_object_unpin
argument_list|(
name|dev_priv
operator|->
name|ips
operator|.
name|renderctx
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|dev_priv
operator|->
name|ips
operator|.
name|renderctx
operator|->
name|base
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|renderctx
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|ips
operator|.
name|pwrctx
condition|)
block|{
name|i915_gem_object_unpin
argument_list|(
name|dev_priv
operator|->
name|ips
operator|.
name|pwrctx
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|dev_priv
operator|->
name|ips
operator|.
name|pwrctx
operator|->
name|base
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|pwrctx
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_disable_rc6
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|PWRCTXA
argument_list|)
condition|)
block|{
comment|/* Wake the GPU, prevent RC6, then restore RSTDBYCTL */
name|I915_WRITE
argument_list|(
name|RSTDBYCTL
argument_list|,
name|I915_READ
argument_list|(
name|RSTDBYCTL
argument_list|)
operator||
name|RCX_SW_EXIT
argument_list|)
expr_stmt|;
name|wait_for
argument_list|(
operator|(
operator|(
name|I915_READ
argument_list|(
name|RSTDBYCTL
argument_list|)
operator|&
name|RSX_STATUS_MASK
operator|)
operator|==
name|RSX_STATUS_ON
operator|)
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PWRCTXA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|PWRCTXA
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RSTDBYCTL
argument_list|,
name|I915_READ
argument_list|(
name|RSTDBYCTL
argument_list|)
operator|&
operator|~
name|RCX_SW_EXIT
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|RSTDBYCTL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ironlake_setup_rc6
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|ips
operator|.
name|renderctx
operator|==
name|NULL
condition|)
name|dev_priv
operator|->
name|ips
operator|.
name|renderctx
operator|=
name|intel_alloc_context_page
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|ips
operator|.
name|renderctx
condition|)
return|return
operator|-
name|ENOMEM
return|;
if|if
condition|(
name|dev_priv
operator|->
name|ips
operator|.
name|pwrctx
operator|==
name|NULL
condition|)
name|dev_priv
operator|->
name|ips
operator|.
name|pwrctx
operator|=
name|intel_alloc_context_page
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|ips
operator|.
name|pwrctx
condition|)
block|{
name|ironlake_teardown_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_enable_rc6
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|RCS
index|]
decl_stmt|;
name|bool
name|was_interruptible
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* rc6 disabled by default due to repeated reports of hanging during 	 * boot and resume. 	 */
if|if
condition|(
operator|!
name|intel_enable_rc6
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|DRM_LOCK_ASSERT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ironlake_setup_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return;
name|was_interruptible
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|false
expr_stmt|;
comment|/* 	 * GPU can automatically power down the render unit if given a page 	 * to save state. 	 */
name|ret
operator|=
name|intel_ring_begin
argument_list|(
name|ring
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ironlake_teardown_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|was_interruptible
expr_stmt|;
return|return;
block|}
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_SUSPEND_FLUSH
operator||
name|MI_SUSPEND_FLUSH_EN
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_SET_CONTEXT
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|dev_priv
operator|->
name|ips
operator|.
name|renderctx
operator|->
name|gtt_offset
operator||
name|MI_MM_SPACE_GTT
operator||
name|MI_SAVE_EXT_STATE_EN
operator||
name|MI_RESTORE_EXT_STATE_EN
operator||
name|MI_RESTORE_INHIBIT
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_SUSPEND_FLUSH
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_NOOP
argument_list|)
expr_stmt|;
name|intel_ring_emit
argument_list|(
name|ring
argument_list|,
name|MI_FLUSH
argument_list|)
expr_stmt|;
name|intel_ring_advance
argument_list|(
name|ring
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the command parser to advance past MI_SET_CONTEXT. The HW 	 * does an implicit flush, combined with MI_FLUSH above, it should be 	 * safe to assume that renderctx is valid 	 */
name|ret
operator|=
name|intel_ring_idle
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|was_interruptible
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to enable ironlake power power savings\n"
argument_list|)
expr_stmt|;
name|ironlake_teardown_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
name|I915_WRITE
argument_list|(
name|PWRCTXA
argument_list|,
name|dev_priv
operator|->
name|ips
operator|.
name|pwrctx
operator|->
name|gtt_offset
operator||
name|PWRCTX_EN
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RSTDBYCTL
argument_list|,
name|I915_READ
argument_list|(
name|RSTDBYCTL
argument_list|)
operator|&
operator|~
name|RCX_SW_EXIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|intel_pxfreq
parameter_list|(
name|u32
name|vidfreq
parameter_list|)
block|{
name|unsigned
name|long
name|freq
decl_stmt|;
name|int
name|div
init|=
operator|(
name|vidfreq
operator|&
literal|0x3f0000
operator|)
operator|>>
literal|16
decl_stmt|;
name|int
name|post
init|=
operator|(
name|vidfreq
operator|&
literal|0x3000
operator|)
operator|>>
literal|12
decl_stmt|;
name|int
name|pre
init|=
operator|(
name|vidfreq
operator|&
literal|0x7
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|pre
condition|)
return|return
literal|0
return|;
name|freq
operator|=
operator|(
operator|(
name|div
operator|*
literal|133333
operator|)
operator|/
operator|(
operator|(
literal|1
operator|<<
name|post
operator|)
operator|*
name|pre
operator|)
operator|)
expr_stmt|;
return|return
name|freq
return|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
name|cparams
block|{
name|u16
name|i
decl_stmt|;
name|u16
name|t
decl_stmt|;
name|u16
name|m
decl_stmt|;
name|u16
name|c
decl_stmt|;
block|}
name|cparams
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|1333
block|,
literal|301
block|,
literal|28664
block|}
block|,
block|{
literal|1
block|,
literal|1066
block|,
literal|294
block|,
literal|24460
block|}
block|,
block|{
literal|1
block|,
literal|800
block|,
literal|294
block|,
literal|25192
block|}
block|,
block|{
literal|0
block|,
literal|1333
block|,
literal|276
block|,
literal|27605
block|}
block|,
block|{
literal|0
block|,
literal|1066
block|,
literal|276
block|,
literal|27605
block|}
block|,
block|{
literal|0
block|,
literal|800
block|,
literal|231
block|,
literal|23784
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|unsigned
name|long
name|__i915_chipset_val
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u64
name|total_count
decl_stmt|,
name|diff
decl_stmt|,
name|ret
decl_stmt|;
name|u32
name|count1
decl_stmt|,
name|count2
decl_stmt|,
name|count3
decl_stmt|,
name|m
init|=
literal|0
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|now
init|=
name|jiffies_to_msecs
argument_list|(
name|jiffies
argument_list|)
decl_stmt|,
name|diff1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|mchdev_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|diff1
operator|=
name|now
operator|-
name|dev_priv
operator|->
name|ips
operator|.
name|last_time1
expr_stmt|;
comment|/* Prevent division-by-zero if we are asking too fast. 	 * Also, we don't get interesting results if we are polling 	 * faster than once in 10ms, so just return the saved value 	 * in such cases. 	 */
if|if
condition|(
name|diff1
operator|<=
literal|10
condition|)
return|return
name|dev_priv
operator|->
name|ips
operator|.
name|chipset_power
return|;
name|count1
operator|=
name|I915_READ
argument_list|(
name|DMIEC
argument_list|)
expr_stmt|;
name|count2
operator|=
name|I915_READ
argument_list|(
name|DDREC
argument_list|)
expr_stmt|;
name|count3
operator|=
name|I915_READ
argument_list|(
name|CSIEC
argument_list|)
expr_stmt|;
name|total_count
operator|=
name|count1
operator|+
name|count2
operator|+
name|count3
expr_stmt|;
comment|/* FIXME: handle per-counter overflow */
if|if
condition|(
name|total_count
operator|<
name|dev_priv
operator|->
name|ips
operator|.
name|last_count1
condition|)
block|{
name|diff
operator|=
operator|~
literal|0UL
operator|-
name|dev_priv
operator|->
name|ips
operator|.
name|last_count1
expr_stmt|;
name|diff
operator|+=
name|total_count
expr_stmt|;
block|}
else|else
block|{
name|diff
operator|=
name|total_count
operator|-
name|dev_priv
operator|->
name|ips
operator|.
name|last_count1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|cparams
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cparams
index|[
name|i
index|]
operator|.
name|i
operator|==
name|dev_priv
operator|->
name|ips
operator|.
name|c_m
operator|&&
name|cparams
index|[
name|i
index|]
operator|.
name|t
operator|==
name|dev_priv
operator|->
name|ips
operator|.
name|r_t
condition|)
block|{
name|m
operator|=
name|cparams
index|[
name|i
index|]
operator|.
name|m
expr_stmt|;
name|c
operator|=
name|cparams
index|[
name|i
index|]
operator|.
name|c
expr_stmt|;
break|break;
block|}
block|}
name|diff
operator|=
name|div_u64
argument_list|(
name|diff
argument_list|,
name|diff1
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
operator|(
name|m
operator|*
name|diff
operator|)
operator|+
name|c
operator|)
expr_stmt|;
name|ret
operator|=
name|div_u64
argument_list|(
name|ret
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|last_count1
operator|=
name|total_count
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|last_time1
operator|=
name|now
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|chipset_power
operator|=
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|i915_chipset_val
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|unsigned
name|long
name|val
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|!=
literal|5
condition|)
return|return
literal|0
return|;
name|mtx_lock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
name|val
operator|=
name|__i915_chipset_val
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|i915_mch_val
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|unsigned
name|long
name|m
decl_stmt|,
name|x
decl_stmt|,
name|b
decl_stmt|;
name|u32
name|tsfs
decl_stmt|;
name|tsfs
operator|=
name|I915_READ
argument_list|(
name|TSFS
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
operator|(
name|tsfs
operator|&
name|TSFS_SLOPE_MASK
operator|)
operator|>>
name|TSFS_SLOPE_SHIFT
operator|)
expr_stmt|;
name|x
operator|=
name|I915_READ8
argument_list|(
name|I915_TR1
argument_list|)
expr_stmt|;
name|b
operator|=
name|tsfs
operator|&
name|TSFS_INTR_MASK
expr_stmt|;
return|return
operator|(
operator|(
name|m
operator|*
name|x
operator|)
operator|/
literal|127
operator|)
operator|-
name|b
return|;
block|}
end_function

begin_function
specifier|static
name|u16
name|pvid_to_extvid
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|u8
name|pxvid
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
name|v_table
block|{
name|u16
name|vd
decl_stmt|;
comment|/* in .1 mil */
name|u16
name|vm
decl_stmt|;
comment|/* in .1 mil */
block|}
name|v_table
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|, }
block|,
block|{
literal|375
block|,
literal|0
block|, }
block|,
block|{
literal|500
block|,
literal|0
block|, }
block|,
block|{
literal|625
block|,
literal|0
block|, }
block|,
block|{
literal|750
block|,
literal|0
block|, }
block|,
block|{
literal|875
block|,
literal|0
block|, }
block|,
block|{
literal|1000
block|,
literal|0
block|, }
block|,
block|{
literal|1125
block|,
literal|0
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4125
block|,
literal|3000
block|, }
block|,
block|{
literal|4250
block|,
literal|3125
block|, }
block|,
block|{
literal|4375
block|,
literal|3250
block|, }
block|,
block|{
literal|4500
block|,
literal|3375
block|, }
block|,
block|{
literal|4625
block|,
literal|3500
block|, }
block|,
block|{
literal|4750
block|,
literal|3625
block|, }
block|,
block|{
literal|4875
block|,
literal|3750
block|, }
block|,
block|{
literal|5000
block|,
literal|3875
block|, }
block|,
block|{
literal|5125
block|,
literal|4000
block|, }
block|,
block|{
literal|5250
block|,
literal|4125
block|, }
block|,
block|{
literal|5375
block|,
literal|4250
block|, }
block|,
block|{
literal|5500
block|,
literal|4375
block|, }
block|,
block|{
literal|5625
block|,
literal|4500
block|, }
block|,
block|{
literal|5750
block|,
literal|4625
block|, }
block|,
block|{
literal|5875
block|,
literal|4750
block|, }
block|,
block|{
literal|6000
block|,
literal|4875
block|, }
block|,
block|{
literal|6125
block|,
literal|5000
block|, }
block|,
block|{
literal|6250
block|,
literal|5125
block|, }
block|,
block|{
literal|6375
block|,
literal|5250
block|, }
block|,
block|{
literal|6500
block|,
literal|5375
block|, }
block|,
block|{
literal|6625
block|,
literal|5500
block|, }
block|,
block|{
literal|6750
block|,
literal|5625
block|, }
block|,
block|{
literal|6875
block|,
literal|5750
block|, }
block|,
block|{
literal|7000
block|,
literal|5875
block|, }
block|,
block|{
literal|7125
block|,
literal|6000
block|, }
block|,
block|{
literal|7250
block|,
literal|6125
block|, }
block|,
block|{
literal|7375
block|,
literal|6250
block|, }
block|,
block|{
literal|7500
block|,
literal|6375
block|, }
block|,
block|{
literal|7625
block|,
literal|6500
block|, }
block|,
block|{
literal|7750
block|,
literal|6625
block|, }
block|,
block|{
literal|7875
block|,
literal|6750
block|, }
block|,
block|{
literal|8000
block|,
literal|6875
block|, }
block|,
block|{
literal|8125
block|,
literal|7000
block|, }
block|,
block|{
literal|8250
block|,
literal|7125
block|, }
block|,
block|{
literal|8375
block|,
literal|7250
block|, }
block|,
block|{
literal|8500
block|,
literal|7375
block|, }
block|,
block|{
literal|8625
block|,
literal|7500
block|, }
block|,
block|{
literal|8750
block|,
literal|7625
block|, }
block|,
block|{
literal|8875
block|,
literal|7750
block|, }
block|,
block|{
literal|9000
block|,
literal|7875
block|, }
block|,
block|{
literal|9125
block|,
literal|8000
block|, }
block|,
block|{
literal|9250
block|,
literal|8125
block|, }
block|,
block|{
literal|9375
block|,
literal|8250
block|, }
block|,
block|{
literal|9500
block|,
literal|8375
block|, }
block|,
block|{
literal|9625
block|,
literal|8500
block|, }
block|,
block|{
literal|9750
block|,
literal|8625
block|, }
block|,
block|{
literal|9875
block|,
literal|8750
block|, }
block|,
block|{
literal|10000
block|,
literal|8875
block|, }
block|,
block|{
literal|10125
block|,
literal|9000
block|, }
block|,
block|{
literal|10250
block|,
literal|9125
block|, }
block|,
block|{
literal|10375
block|,
literal|9250
block|, }
block|,
block|{
literal|10500
block|,
literal|9375
block|, }
block|,
block|{
literal|10625
block|,
literal|9500
block|, }
block|,
block|{
literal|10750
block|,
literal|9625
block|, }
block|,
block|{
literal|10875
block|,
literal|9750
block|, }
block|,
block|{
literal|11000
block|,
literal|9875
block|, }
block|,
block|{
literal|11125
block|,
literal|10000
block|, }
block|,
block|{
literal|11250
block|,
literal|10125
block|, }
block|,
block|{
literal|11375
block|,
literal|10250
block|, }
block|,
block|{
literal|11500
block|,
literal|10375
block|, }
block|,
block|{
literal|11625
block|,
literal|10500
block|, }
block|,
block|{
literal|11750
block|,
literal|10625
block|, }
block|,
block|{
literal|11875
block|,
literal|10750
block|, }
block|,
block|{
literal|12000
block|,
literal|10875
block|, }
block|,
block|{
literal|12125
block|,
literal|11000
block|, }
block|,
block|{
literal|12250
block|,
literal|11125
block|, }
block|,
block|{
literal|12375
block|,
literal|11250
block|, }
block|,
block|{
literal|12500
block|,
literal|11375
block|, }
block|,
block|{
literal|12625
block|,
literal|11500
block|, }
block|,
block|{
literal|12750
block|,
literal|11625
block|, }
block|,
block|{
literal|12875
block|,
literal|11750
block|, }
block|,
block|{
literal|13000
block|,
literal|11875
block|, }
block|,
block|{
literal|13125
block|,
literal|12000
block|, }
block|,
block|{
literal|13250
block|,
literal|12125
block|, }
block|,
block|{
literal|13375
block|,
literal|12250
block|, }
block|,
block|{
literal|13500
block|,
literal|12375
block|, }
block|,
block|{
literal|13625
block|,
literal|12500
block|, }
block|,
block|{
literal|13750
block|,
literal|12625
block|, }
block|,
block|{
literal|13875
block|,
literal|12750
block|, }
block|,
block|{
literal|14000
block|,
literal|12875
block|, }
block|,
block|{
literal|14125
block|,
literal|13000
block|, }
block|,
block|{
literal|14250
block|,
literal|13125
block|, }
block|,
block|{
literal|14375
block|,
literal|13250
block|, }
block|,
block|{
literal|14500
block|,
literal|13375
block|, }
block|,
block|{
literal|14625
block|,
literal|13500
block|, }
block|,
block|{
literal|14750
block|,
literal|13625
block|, }
block|,
block|{
literal|14875
block|,
literal|13750
block|, }
block|,
block|{
literal|15000
block|,
literal|13875
block|, }
block|,
block|{
literal|15125
block|,
literal|14000
block|, }
block|,
block|{
literal|15250
block|,
literal|14125
block|, }
block|,
block|{
literal|15375
block|,
literal|14250
block|, }
block|,
block|{
literal|15500
block|,
literal|14375
block|, }
block|,
block|{
literal|15625
block|,
literal|14500
block|, }
block|,
block|{
literal|15750
block|,
literal|14625
block|, }
block|,
block|{
literal|15875
block|,
literal|14750
block|, }
block|,
block|{
literal|16000
block|,
literal|14875
block|, }
block|,
block|{
literal|16125
block|,
literal|15000
block|, }
block|, 	}
struct|;
if|if
condition|(
name|dev_priv
operator|->
name|info
operator|->
name|is_mobile
condition|)
return|return
name|v_table
index|[
name|pxvid
index|]
operator|.
name|vm
return|;
else|else
return|return
name|v_table
index|[
name|pxvid
index|]
operator|.
name|vd
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__i915_update_gfx_val
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|struct
name|timespec
name|now
decl_stmt|,
name|diff1
decl_stmt|;
name|u64
name|diff
decl_stmt|;
name|unsigned
name|long
name|diffms
decl_stmt|;
name|u32
name|count
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|mchdev_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|nanotime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|diff1
operator|=
name|now
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|diff1
argument_list|,
operator|&
name|dev_priv
operator|->
name|ips
operator|.
name|last_time2
argument_list|)
expr_stmt|;
comment|/* Don't divide by 0 */
name|diffms
operator|=
name|diff1
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|diff1
operator|.
name|tv_nsec
operator|/
literal|1000000
expr_stmt|;
if|if
condition|(
operator|!
name|diffms
condition|)
return|return;
name|count
operator|=
name|I915_READ
argument_list|(
name|GFXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|dev_priv
operator|->
name|ips
operator|.
name|last_count2
condition|)
block|{
name|diff
operator|=
operator|~
literal|0UL
operator|-
name|dev_priv
operator|->
name|ips
operator|.
name|last_count2
expr_stmt|;
name|diff
operator|+=
name|count
expr_stmt|;
block|}
else|else
block|{
name|diff
operator|=
name|count
operator|-
name|dev_priv
operator|->
name|ips
operator|.
name|last_count2
expr_stmt|;
block|}
name|dev_priv
operator|->
name|ips
operator|.
name|last_count2
operator|=
name|count
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|last_time2
operator|=
name|now
expr_stmt|;
comment|/* More magic constants... */
name|diff
operator|=
name|diff
operator|*
literal|1181
expr_stmt|;
name|diff
operator|=
name|div_u64
argument_list|(
name|diff
argument_list|,
name|diffms
operator|*
literal|10
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|gfx_power
operator|=
name|diff
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_update_gfx_val
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|!=
literal|5
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
name|__i915_update_gfx_val
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|__i915_gfx_val
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|unsigned
name|long
name|t
decl_stmt|,
name|corr
decl_stmt|,
name|state1
decl_stmt|,
name|corr2
decl_stmt|,
name|state2
decl_stmt|;
name|u32
name|pxvid
decl_stmt|,
name|ext_v
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|mchdev_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pxvid
operator|=
name|I915_READ
argument_list|(
name|PXVFREQ_BASE
operator|+
operator|(
name|dev_priv
operator|->
name|rps
operator|.
name|cur_delay
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
name|pxvid
operator|=
operator|(
name|pxvid
operator|>>
literal|24
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|ext_v
operator|=
name|pvid_to_extvid
argument_list|(
name|dev_priv
argument_list|,
name|pxvid
argument_list|)
expr_stmt|;
name|state1
operator|=
name|ext_v
expr_stmt|;
name|t
operator|=
name|i915_mch_val
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* Revel in the empirically derived constants */
comment|/* Correction factor in 1/100000 units */
if|if
condition|(
name|t
operator|>
literal|80
condition|)
name|corr
operator|=
operator|(
operator|(
name|t
operator|*
literal|2349
operator|)
operator|+
literal|135940
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|>=
literal|50
condition|)
name|corr
operator|=
operator|(
operator|(
name|t
operator|*
literal|964
operator|)
operator|+
literal|29317
operator|)
expr_stmt|;
else|else
comment|/*< 50 */
name|corr
operator|=
operator|(
operator|(
name|t
operator|*
literal|301
operator|)
operator|+
literal|1004
operator|)
expr_stmt|;
name|corr
operator|=
name|corr
operator|*
operator|(
operator|(
literal|150142
operator|*
name|state1
operator|)
operator|/
literal|10000
operator|-
literal|78642
operator|)
expr_stmt|;
name|corr
operator|/=
literal|100000
expr_stmt|;
name|corr2
operator|=
operator|(
name|corr
operator|*
name|dev_priv
operator|->
name|ips
operator|.
name|corr
operator|)
expr_stmt|;
name|state2
operator|=
operator|(
name|corr2
operator|*
name|state1
operator|)
operator|/
literal|10000
expr_stmt|;
name|state2
operator|/=
literal|100
expr_stmt|;
comment|/* convert to mW */
name|__i915_update_gfx_val
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
name|dev_priv
operator|->
name|ips
operator|.
name|gfx_power
operator|+
name|state2
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|i915_gfx_val
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|unsigned
name|long
name|val
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|info
operator|->
name|gen
operator|!=
literal|5
condition|)
return|return
literal|0
return|;
name|mtx_lock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
name|val
operator|=
name|__i915_gfx_val
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/**  * i915_read_mch_val - return value for IPS use  *  * Calculate and return a value for the IPS driver to use when deciding whether  * we have thermal and power headroom to increase CPU or GPU power budget.  */
end_comment

begin_function
name|unsigned
name|long
name|i915_read_mch_val
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|unsigned
name|long
name|chipset_val
decl_stmt|,
name|graphics_val
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i915_mch_dev
condition|)
goto|goto
name|out_unlock
goto|;
name|dev_priv
operator|=
name|i915_mch_dev
expr_stmt|;
name|chipset_val
operator|=
name|__i915_chipset_val
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|graphics_val
operator|=
name|__i915_gfx_val
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chipset_val
operator|+
name|graphics_val
expr_stmt|;
name|out_unlock
label|:
name|mtx_unlock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|i915_read_mch_val
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * i915_gpu_raise - raise GPU frequency limit  *  * Raise the limit; IPS indicates we have thermal headroom.  */
end_comment

begin_function
name|bool
name|i915_gpu_raise
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|bool
name|ret
init|=
name|true
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i915_mch_dev
condition|)
block|{
name|ret
operator|=
name|false
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|dev_priv
operator|=
name|i915_mch_dev
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|ips
operator|.
name|max_delay
operator|>
name|dev_priv
operator|->
name|ips
operator|.
name|fmax
condition|)
name|dev_priv
operator|->
name|ips
operator|.
name|max_delay
operator|--
expr_stmt|;
name|out_unlock
label|:
name|mtx_unlock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|i915_gpu_raise
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * i915_gpu_lower - lower GPU frequency limit  *  * IPS indicates we're close to a thermal limit, so throttle back the GPU  * frequency maximum.  */
end_comment

begin_function
name|bool
name|i915_gpu_lower
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|bool
name|ret
init|=
name|true
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i915_mch_dev
condition|)
block|{
name|ret
operator|=
name|false
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|dev_priv
operator|=
name|i915_mch_dev
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|ips
operator|.
name|max_delay
operator|<
name|dev_priv
operator|->
name|ips
operator|.
name|min_delay
condition|)
name|dev_priv
operator|->
name|ips
operator|.
name|max_delay
operator|++
expr_stmt|;
name|out_unlock
label|:
name|mtx_unlock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|i915_gpu_lower
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * i915_gpu_busy - indicate GPU business to IPS  *  * Tell the IPS driver whether or not the GPU is busy.  */
end_comment

begin_function
name|bool
name|i915_gpu_busy
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|bool
name|ret
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i915_mch_dev
condition|)
goto|goto
name|out_unlock
goto|;
name|dev_priv
operator|=
name|i915_mch_dev
expr_stmt|;
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
name|ret
operator||=
operator|!
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
expr_stmt|;
name|out_unlock
label|:
name|mtx_unlock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|i915_gpu_busy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * i915_gpu_turbo_disable - disable graphics turbo  *  * Disable graphics turbo by resetting the max frequency and setting the  * current frequency to the default.  */
end_comment

begin_function
name|bool
name|i915_gpu_turbo_disable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|bool
name|ret
init|=
name|true
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i915_mch_dev
condition|)
block|{
name|ret
operator|=
name|false
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|dev_priv
operator|=
name|i915_mch_dev
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|max_delay
operator|=
name|dev_priv
operator|->
name|ips
operator|.
name|fstart
expr_stmt|;
if|if
condition|(
operator|!
name|ironlake_set_drps
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|,
name|dev_priv
operator|->
name|ips
operator|.
name|fstart
argument_list|)
condition|)
name|ret
operator|=
name|false
expr_stmt|;
name|out_unlock
label|:
name|mtx_unlock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|i915_gpu_turbo_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FREEBSD_WIP
end_ifdef

begin_comment
comment|/**  * Tells the intel_ips driver that the i915 driver is now loaded, if  * IPS got loaded first.  *  * This awkward dance is so that neither module has to depend on the  * other in order for IPS to do the appropriate communication of  * GPU turbo limits to i915.  */
end_comment

begin_function
specifier|static
name|void
name|ips_ping_for_i915_load
parameter_list|(
name|void
parameter_list|)
block|{
name|void
function_decl|(
modifier|*
name|link
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|link
operator|=
name|symbol_get
argument_list|(
name|ips_link_to_i915_driver
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
condition|)
block|{
name|link
argument_list|()
expr_stmt|;
name|symbol_put
argument_list|(
name|ips_link_to_i915_driver
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREEBSD_WIP */
end_comment

begin_function
name|void
name|intel_gpu_ips_init
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
comment|/* We only register the i915 ips part with intel-ips once everything is 	 * set up, to avoid intel-ips sneaking in and reading bogus values. */
name|mtx_lock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
name|i915_mch_dev
operator|=
name|dev_priv
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|ips_ping_for_i915_load
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
block|}
end_function

begin_function
name|void
name|intel_gpu_ips_teardown
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
name|i915_mch_dev
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mchdev_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_init_emon
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|lcfuse
decl_stmt|;
name|u8
name|pxw
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Disable to program */
name|I915_WRITE
argument_list|(
name|ECR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|ECR
argument_list|)
expr_stmt|;
comment|/* Program energy weights for various events */
name|I915_WRITE
argument_list|(
name|SDEW
argument_list|,
literal|0x15040d00
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|CSIEW0
argument_list|,
literal|0x007f0000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|CSIEW1
argument_list|,
literal|0x1e220004
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|CSIEW2
argument_list|,
literal|0x04000004
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|PEW
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|DEW
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Program P-state weights to account for frequency power adjustment */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|pxvidfreq
init|=
name|I915_READ
argument_list|(
name|PXVFREQ_BASE
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|freq
init|=
name|intel_pxfreq
argument_list|(
name|pxvidfreq
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|vid
init|=
operator|(
name|pxvidfreq
operator|&
name|PXVFREQ_PX_MASK
operator|)
operator|>>
name|PXVFREQ_PX_SHIFT
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|val
operator|=
name|vid
operator|*
name|vid
expr_stmt|;
name|val
operator|*=
operator|(
name|freq
operator|/
literal|1000
operator|)
expr_stmt|;
name|val
operator|*=
literal|255
expr_stmt|;
name|val
operator|/=
operator|(
literal|127
operator|*
literal|127
operator|*
literal|900
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0xff
condition|)
name|DRM_ERROR
argument_list|(
literal|"bad pxval: %ld\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|pxw
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
block|}
comment|/* Render standby states get 0 weight */
name|pxw
index|[
literal|14
index|]
operator|=
literal|0
expr_stmt|;
name|pxw
index|[
literal|15
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|val
init|=
operator|(
name|pxw
index|[
name|i
operator|*
literal|4
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|pxw
index|[
operator|(
name|i
operator|*
literal|4
operator|)
operator|+
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|pxw
index|[
operator|(
name|i
operator|*
literal|4
operator|)
operator|+
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|pxw
index|[
operator|(
name|i
operator|*
literal|4
operator|)
operator|+
literal|3
index|]
operator|)
decl_stmt|;
name|I915_WRITE
argument_list|(
name|PXW
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust magic regs to magic values (more experimental results) */
name|I915_WRITE
argument_list|(
name|OGW0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|OGW1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG0
argument_list|,
literal|0x00007f00
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG1
argument_list|,
literal|0x0000000e
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG2
argument_list|,
literal|0x000e0000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG3
argument_list|,
literal|0x68000300
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG4
argument_list|,
literal|0x42000000
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG5
argument_list|,
literal|0x00140031
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|EG7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|PXWL
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable PMON + select events */
name|I915_WRITE
argument_list|(
name|ECR
argument_list|,
literal|0x80000019
argument_list|)
expr_stmt|;
name|lcfuse
operator|=
name|I915_READ
argument_list|(
name|LCFUSE02
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|ips
operator|.
name|corr
operator|=
operator|(
name|lcfuse
operator|&
name|LCFUSE_HIV_MASK
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_disable_gt_powersave
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|IS_IRONLAKE_M
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ironlake_disable_drps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ironlake_disable_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|6
operator|&&
operator|!
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|taskqueue_cancel_timeout
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|delayed_resume_work
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|hw_lock
argument_list|)
expr_stmt|;
name|gen6_disable_rps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|hw_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intel_gen6_powersave_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|arg
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|dev_priv
operator|->
name|dev
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|hw_lock
argument_list|)
expr_stmt|;
name|gen6_enable_rps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|gen6_update_ring_freq
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|hw_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_enable_gt_powersave
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|IS_IRONLAKE_M
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ironlake_enable_drps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ironlake_enable_rc6
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|intel_init_emon
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_GEN7
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
operator|!
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* 		 * PCU communication is slow and this doesn't need to be 		 * done at any specific time, so do this out of our fast path 		 * to make resume and init faster. 		 */
name|taskqueue_enqueue_timeout
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|delayed_resume_work
argument_list|,
name|round_jiffies_up_relative
argument_list|(
name|HZ
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ibx_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* 	 * On Ibex Peak and Cougar Point, we need to disable clock 	 * gating for the panel power sequencer or it will fail to 	 * start up when no ports are active. 	 */
name|I915_WRITE
argument_list|(
name|SOUTH_DSPCLK_GATE_D
argument_list|,
name|PCH_DPLSUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ironlake_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|dspclk_gate
init|=
name|ILK_VRHUNIT_CLOCK_GATE_DISABLE
decl_stmt|;
comment|/* Required for FBC */
name|dspclk_gate
operator||=
name|ILK_DPFCRUNIT_CLOCK_GATE_DISABLE
operator||
name|ILK_DPFCUNIT_CLOCK_GATE_DISABLE
operator||
name|ILK_DPFDUNIT_CLOCK_GATE_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_3DCGDIS0
argument_list|,
name|MARIUNIT_CLOCK_GATE_DISABLE
operator||
name|SVSMUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|PCH_3DCGDIS1
argument_list|,
name|VFMUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
comment|/* 	 * According to the spec the following bits should be set in 	 * order to enable memory self-refresh 	 * The bit 22/21 of 0x42004 	 * The bit 5 of 0x42020 	 * The bit 15 of 0x45000 	 */
name|I915_WRITE
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|)
operator||
name|ILK_DPARB_GATE
operator||
name|ILK_VSDPFD_FULL
operator|)
argument_list|)
expr_stmt|;
name|dspclk_gate
operator||=
name|ILK_DPARBUNIT_CLOCK_GATE_ENABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DISP_ARB_CTL
argument_list|,
operator|(
name|I915_READ
argument_list|(
name|DISP_ARB_CTL
argument_list|)
operator||
name|DISP_FBC_WM_DIS
operator|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Based on the document from hardware guys the following bits 	 * should be set unconditionally in order to enable FBC. 	 * The bit 22 of 0x42000 	 * The bit 22 of 0x42004 	 * The bit 7,8,9 of 0x42020. 	 */
if|if
condition|(
name|IS_IRONLAKE_M
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|ILK_DISPLAY_CHICKEN1
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN1
argument_list|)
operator||
name|ILK_FBCQ_DIS
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|)
operator||
name|ILK_DPARB_GATE
argument_list|)
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|ILK_DSPCLK_GATE_D
argument_list|,
name|dspclk_gate
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|)
operator||
name|ILK_ELPIN_409_SELECT
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|_3D_CHICKEN2
argument_list|,
name|_3D_CHICKEN2_WM_READ_PIPELINED
operator|<<
literal|16
operator||
name|_3D_CHICKEN2_WM_READ_PIPELINED
argument_list|)
expr_stmt|;
comment|/* WaDisableRenderCachePipelinedFlush */
name|I915_WRITE
argument_list|(
name|CACHE_MODE_0
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|CM0_PIPELINED_RENDER_FLUSH_DISABLE
argument_list|)
argument_list|)
expr_stmt|;
name|ibx_init_clock_gating
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cpt_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipe
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
comment|/* 	 * On Ibex Peak and Cougar Point, we need to disable clock 	 * gating for the panel power sequencer or it will fail to 	 * start up when no ports are active. 	 */
name|I915_WRITE
argument_list|(
name|SOUTH_DSPCLK_GATE_D
argument_list|,
name|PCH_DPLSUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|SOUTH_CHICKEN2
argument_list|,
name|I915_READ
argument_list|(
name|SOUTH_CHICKEN2
argument_list|)
operator||
name|DPLS_EDP_PPS_FIX_DIS
argument_list|)
expr_stmt|;
comment|/* The below fixes the weird display corruption, a few pixels shifted 	 * downward, on (only) LVDS of some HP laptops with IVY. 	 */
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
block|{
name|val
operator|=
name|TRANS_CHICKEN2_TIMING_OVERRIDE
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|fdi_rx_polarity_inverted
condition|)
name|val
operator||=
name|TRANS_CHICKEN2_FDI_POLARITY_REVERSED
expr_stmt|;
name|I915_WRITE
argument_list|(
name|TRANS_CHICKEN2
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* WADP0ClockGatingDisable */
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
block|{
name|I915_WRITE
argument_list|(
name|TRANS_CHICKEN1
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|TRANS_CHICKEN1_DP0UNIT_GC_DISABLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gen6_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipe
decl_stmt|;
name|uint32_t
name|dspclk_gate
init|=
name|ILK_VRHUNIT_CLOCK_GATE_DISABLE
decl_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DSPCLK_GATE_D
argument_list|,
name|dspclk_gate
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|)
operator||
name|ILK_ELPIN_409_SELECT
argument_list|)
expr_stmt|;
comment|/* WaDisableHiZPlanesWhenMSAAEnabled */
name|I915_WRITE
argument_list|(
name|_3D_CHICKEN
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|_3D_CHICKEN_HIZ_PLANE_DISABLE_MSAA_4X_SNB
argument_list|)
argument_list|)
expr_stmt|;
comment|/* WaSetupGtModeTdRowDispatch */
if|if
condition|(
name|IS_SNB_GT1
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|GEN6_GT_MODE
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|GEN6_TD_FOUR_ROW_DISPATCH_DISABLE
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|CACHE_MODE_0
argument_list|,
name|_MASKED_BIT_DISABLE
argument_list|(
name|CM0_STC_EVICT_DISABLE_LRA_SNB
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_UCGCTL1
argument_list|,
name|I915_READ
argument_list|(
name|GEN6_UCGCTL1
argument_list|)
operator||
name|GEN6_BLBUNIT_CLOCK_GATE_DISABLE
operator||
name|GEN6_CSUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
comment|/* According to the BSpec vol1g, bit 12 (RCPBUNIT) clock 	 * gating disable must be set.  Failure to set it results in 	 * flickering pixels due to Z write ordering failures after 	 * some amount of runtime in the Mesa "fire" demo, and Unigine 	 * Sanctuary and Tropics, and apparently anything else with 	 * alpha test or pixel discard. 	 * 	 * According to the spec, bit 11 (RCCUNIT) must also be set, 	 * but we didn't debug actual testcases to find it out. 	 * 	 * Also apply WaDisableVDSUnitClockGating and 	 * WaDisableRCPBUnitClockGating. 	 */
name|I915_WRITE
argument_list|(
name|GEN6_UCGCTL2
argument_list|,
name|GEN7_VDSUNIT_CLOCK_GATE_DISABLE
operator||
name|GEN6_RCPBUNIT_CLOCK_GATE_DISABLE
operator||
name|GEN6_RCCUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
comment|/* Bspec says we need to always set all mask bits. */
name|I915_WRITE
argument_list|(
name|_3D_CHICKEN3
argument_list|,
operator|(
literal|0xFFFF
operator|<<
literal|16
operator|)
operator||
name|_3D_CHICKEN3_SF_DISABLE_FASTCLIP_CULL
argument_list|)
expr_stmt|;
comment|/* 	 * According to the spec the following bits should be 	 * set in order to enable memory self-refresh and fbc: 	 * The bit21 and bit22 of 0x42000 	 * The bit21 and bit22 of 0x42004 	 * The bit5 and bit7 of 0x42020 	 * The bit14 of 0x70180 	 * The bit14 of 0x71180 	 */
name|I915_WRITE
argument_list|(
name|ILK_DISPLAY_CHICKEN1
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN1
argument_list|)
operator||
name|ILK_FBCQ_DIS
operator||
name|ILK_PABSTRETCH_DIS
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DISPLAY_CHICKEN2
argument_list|)
operator||
name|ILK_DPARB_GATE
operator||
name|ILK_VSDPFD_FULL
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DSPCLK_GATE_D
argument_list|,
name|I915_READ
argument_list|(
name|ILK_DSPCLK_GATE_D
argument_list|)
operator||
name|ILK_DPARBUNIT_CLOCK_GATE_ENABLE
operator||
name|ILK_DPFDUNIT_CLOCK_GATE_ENABLE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
comment|/* NOTE Linux<->FreeBSD: Disable GEN6_MBCTL write. 	 * 	 * This arrived in Linux 3.6 in commit 	 * b4ae3f22d238617ca11610b29fde16cf8c0bc6e0 and causes significantly 	 * increased power consumption after kldloading i915kms.ko on FreeBSD 	 * on (some) Sandy Bridge laptops. A Thinkpad X220 reported about 11W 	 * after booting while idle at the vt(4) console and about double that 	 * after loading the driver. 	 * 	 * There were reports in Linux of increased consumption after a suspend 	 * and resume cycle due to that change. 	 * 	 * Linux bug reports: 	 * https://bugs.freedesktop.org/show_bug.cgi?id=54089 	 * https://bugzilla.kernel.org/show_bug.cgi?id=58971 	 * 	 * This suspend and resume issue is reportedly fixed in Linux with 	 * commits 7dcd2677ea912573d9ed4bcd629b0023b2d11505 and 	 * 7dcd2677ea912573d9ed4bcd629b0023b2d11505 (Linux 3.11). However, I 	 * found that those changes did not help on FreeBSD, where increased 	 * power consumption is observed after loading i915kms.ko without 	 * suspending and resuming. 	 * 	 * This workaround should be removed after updating to a future Linux 	 * i915 version and verifying normal power consumption on Sandy Bridge. 	 */
comment|/* WaMbcDriverBootEnable */
name|I915_WRITE
argument_list|(
name|GEN6_MBCTL
argument_list|,
name|I915_READ
argument_list|(
name|GEN6_MBCTL
argument_list|)
operator||
name|GEN6_MBCTL_ENABLE_BOOT_FETCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
block|{
name|I915_WRITE
argument_list|(
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator||
name|DISPPLANE_TRICKLE_FEED_DISABLE
argument_list|)
expr_stmt|;
name|intel_flush_display_plane
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
comment|/* The default value should be 0x200 according to docs, but the two 	 * platforms I checked have a 0 for this. (Maybe BIOS overrides?) */
name|I915_WRITE
argument_list|(
name|GEN6_GT_MODE
argument_list|,
name|_MASKED_BIT_DISABLE
argument_list|(
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_GT_MODE
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|GEN6_GT_MODE_HI
argument_list|)
argument_list|)
expr_stmt|;
name|cpt_init_clock_gating
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen7_setup_fixed_func_scheduler
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|uint32_t
name|reg
init|=
name|I915_READ
argument_list|(
name|GEN7_FF_THREAD_MODE
argument_list|)
decl_stmt|;
name|reg
operator|&=
operator|~
name|GEN7_FF_SCHED_MASK
expr_stmt|;
name|reg
operator||=
name|GEN7_FF_TS_SCHED_HW
expr_stmt|;
name|reg
operator||=
name|GEN7_FF_VS_SCHED_HW
expr_stmt|;
name|reg
operator||=
name|GEN7_FF_DS_SCHED_HW
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN7_FF_THREAD_MODE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lpt_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* 	 * TODO: this bit should only be enabled when really needed, then 	 * disabled when not needed anymore in order to save power. 	 */
if|if
condition|(
name|dev_priv
operator|->
name|pch_id
operator|==
name|INTEL_PCH_LPT_LP_DEVICE_ID_TYPE
condition|)
name|I915_WRITE
argument_list|(
name|SOUTH_DSPCLK_GATE_D
argument_list|,
name|I915_READ
argument_list|(
name|SOUTH_DSPCLK_GATE_D
argument_list|)
operator||
name|PCH_LP_PARTITION_LEVEL_DISABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|haswell_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipe
decl_stmt|;
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* According to the spec, bit 13 (RCZUNIT) must be set on IVB. 	 * This implements the WaDisableRCZUnitClockGating workaround. 	 */
name|I915_WRITE
argument_list|(
name|GEN6_UCGCTL2
argument_list|,
name|GEN6_RCZUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
comment|/* Apply the WaDisableRHWOOptimizationForRenderHang workaround. */
name|I915_WRITE
argument_list|(
name|GEN7_COMMON_SLICE_CHICKEN1
argument_list|,
name|GEN7_CSC1_RHWO_OPT_DISABLE_IN_RCC
argument_list|)
expr_stmt|;
comment|/* WaApplyL3ControlAndL3ChickenMode requires those two on Ivy Bridge */
name|I915_WRITE
argument_list|(
name|GEN7_L3CNTLREG1
argument_list|,
name|GEN7_WA_FOR_GEN7_L3_CONTROL
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN7_L3_CHICKEN_MODE_REGISTER
argument_list|,
name|GEN7_WA_L3_CHICKEN_MODE
argument_list|)
expr_stmt|;
comment|/* This is required by WaCatErrorRejectionIssue */
name|I915_WRITE
argument_list|(
name|GEN7_SQ_CHICKEN_MBCUNIT_CONFIG
argument_list|,
name|I915_READ
argument_list|(
name|GEN7_SQ_CHICKEN_MBCUNIT_CONFIG
argument_list|)
operator||
name|GEN7_SQ_CHICKEN_MBCUNIT_SQINTMOB
argument_list|)
expr_stmt|;
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
block|{
name|I915_WRITE
argument_list|(
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator||
name|DISPPLANE_TRICKLE_FEED_DISABLE
argument_list|)
expr_stmt|;
name|intel_flush_display_plane
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
name|gen7_setup_fixed_func_scheduler
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* WaDisable4x2SubspanOptimization */
name|I915_WRITE
argument_list|(
name|CACHE_MODE_1
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|PIXEL_SUBSPAN_COLLECT_OPT_DISABLE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* WaMbcDriverBootEnable */
name|I915_WRITE
argument_list|(
name|GEN6_MBCTL
argument_list|,
name|I915_READ
argument_list|(
name|GEN6_MBCTL
argument_list|)
operator||
name|GEN6_MBCTL_ENABLE_BOOT_FETCH
argument_list|)
expr_stmt|;
comment|/* XXX: This is a workaround for early silicon revisions and should be 	 * removed later. 	 */
name|I915_WRITE
argument_list|(
name|WM_DBG
argument_list|,
name|I915_READ
argument_list|(
name|WM_DBG
argument_list|)
operator||
name|WM_DBG_DISALLOW_MULTIPLE_LP
operator||
name|WM_DBG_DISALLOW_SPRITE
operator||
name|WM_DBG_DISALLOW_MAXFIFO
argument_list|)
expr_stmt|;
name|lpt_init_clock_gating
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ivybridge_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipe
decl_stmt|;
name|uint32_t
name|snpcr
decl_stmt|;
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DSPCLK_GATE_D
argument_list|,
name|ILK_VRHUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
comment|/* WaDisableEarlyCull */
name|I915_WRITE
argument_list|(
name|_3D_CHICKEN3
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|_3D_CHICKEN_SF_DISABLE_OBJEND_CULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* WaDisableBackToBackFlipFix */
name|I915_WRITE
argument_list|(
name|IVB_CHICKEN3
argument_list|,
name|CHICKEN3_DGMG_REQ_OUT_FIX_DISABLE
operator||
name|CHICKEN3_DGMG_DONE_FIX_DISABLE
argument_list|)
expr_stmt|;
comment|/* WaDisablePSDDualDispatchEnable */
if|if
condition|(
name|IS_IVB_GT1
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|GEN7_HALF_SLICE_CHICKEN1
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|GEN7_PSD_SINGLE_PORT_DISPATCH_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|I915_WRITE
argument_list|(
name|GEN7_HALF_SLICE_CHICKEN1_GT2
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|GEN7_PSD_SINGLE_PORT_DISPATCH_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Apply the WaDisableRHWOOptimizationForRenderHang workaround. */
name|I915_WRITE
argument_list|(
name|GEN7_COMMON_SLICE_CHICKEN1
argument_list|,
name|GEN7_CSC1_RHWO_OPT_DISABLE_IN_RCC
argument_list|)
expr_stmt|;
comment|/* WaApplyL3ControlAndL3ChickenMode requires those two on Ivy Bridge */
name|I915_WRITE
argument_list|(
name|GEN7_L3CNTLREG1
argument_list|,
name|GEN7_WA_FOR_GEN7_L3_CONTROL
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN7_L3_CHICKEN_MODE_REGISTER
argument_list|,
name|GEN7_WA_L3_CHICKEN_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IVB_GT1
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|GEN7_ROW_CHICKEN2
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|DOP_CLOCK_GATING_DISABLE
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|I915_WRITE
argument_list|(
name|GEN7_ROW_CHICKEN2_GT2
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|DOP_CLOCK_GATING_DISABLE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* WaForceL3Serialization */
name|I915_WRITE
argument_list|(
name|GEN7_L3SQCREG4
argument_list|,
name|I915_READ
argument_list|(
name|GEN7_L3SQCREG4
argument_list|)
operator|&
operator|~
name|L3SQ_URB_READ_CAM_MATCH_DISABLE
argument_list|)
expr_stmt|;
comment|/* According to the BSpec vol1g, bit 12 (RCPBUNIT) clock 	 * gating disable must be set.  Failure to set it results in 	 * flickering pixels due to Z write ordering failures after 	 * some amount of runtime in the Mesa "fire" demo, and Unigine 	 * Sanctuary and Tropics, and apparently anything else with 	 * alpha test or pixel discard. 	 * 	 * According to the spec, bit 11 (RCCUNIT) must also be set, 	 * but we didn't debug actual testcases to find it out. 	 * 	 * According to the spec, bit 13 (RCZUNIT) must be set on IVB. 	 * This implements the WaDisableRCZUnitClockGating workaround. 	 */
name|I915_WRITE
argument_list|(
name|GEN6_UCGCTL2
argument_list|,
name|GEN6_RCZUNIT_CLOCK_GATE_DISABLE
operator||
name|GEN6_RCCUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
comment|/* This is required by WaCatErrorRejectionIssue */
name|I915_WRITE
argument_list|(
name|GEN7_SQ_CHICKEN_MBCUNIT_CONFIG
argument_list|,
name|I915_READ
argument_list|(
name|GEN7_SQ_CHICKEN_MBCUNIT_CONFIG
argument_list|)
operator||
name|GEN7_SQ_CHICKEN_MBCUNIT_SQINTMOB
argument_list|)
expr_stmt|;
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
block|{
name|I915_WRITE
argument_list|(
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator||
name|DISPPLANE_TRICKLE_FEED_DISABLE
argument_list|)
expr_stmt|;
name|intel_flush_display_plane
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
comment|/* WaMbcDriverBootEnable */
name|I915_WRITE
argument_list|(
name|GEN6_MBCTL
argument_list|,
name|I915_READ
argument_list|(
name|GEN6_MBCTL
argument_list|)
operator||
name|GEN6_MBCTL_ENABLE_BOOT_FETCH
argument_list|)
expr_stmt|;
name|gen7_setup_fixed_func_scheduler
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* WaDisable4x2SubspanOptimization */
name|I915_WRITE
argument_list|(
name|CACHE_MODE_1
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|PIXEL_SUBSPAN_COLLECT_OPT_DISABLE
argument_list|)
argument_list|)
expr_stmt|;
name|snpcr
operator|=
name|I915_READ
argument_list|(
name|GEN6_MBCUNIT_SNPCR
argument_list|)
expr_stmt|;
name|snpcr
operator|&=
operator|~
name|GEN6_MBC_SNPCR_MASK
expr_stmt|;
name|snpcr
operator||=
name|GEN6_MBC_SNPCR_MED
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_MBCUNIT_SNPCR
argument_list|,
name|snpcr
argument_list|)
expr_stmt|;
name|cpt_init_clock_gating
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|valleyview_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pipe
decl_stmt|;
name|I915_WRITE
argument_list|(
name|WM3_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM2_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|WM1_LP_ILK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|ILK_DSPCLK_GATE_D
argument_list|,
name|ILK_VRHUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
comment|/* WaDisableEarlyCull */
name|I915_WRITE
argument_list|(
name|_3D_CHICKEN3
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|_3D_CHICKEN_SF_DISABLE_OBJEND_CULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* WaDisableBackToBackFlipFix */
name|I915_WRITE
argument_list|(
name|IVB_CHICKEN3
argument_list|,
name|CHICKEN3_DGMG_REQ_OUT_FIX_DISABLE
operator||
name|CHICKEN3_DGMG_DONE_FIX_DISABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN7_HALF_SLICE_CHICKEN1
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|GEN7_PSD_SINGLE_PORT_DISPATCH_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Apply the WaDisableRHWOOptimizationForRenderHang workaround. */
name|I915_WRITE
argument_list|(
name|GEN7_COMMON_SLICE_CHICKEN1
argument_list|,
name|GEN7_CSC1_RHWO_OPT_DISABLE_IN_RCC
argument_list|)
expr_stmt|;
comment|/* WaApplyL3ControlAndL3ChickenMode requires those two on Ivy Bridge */
name|I915_WRITE
argument_list|(
name|GEN7_L3CNTLREG1
argument_list|,
name|I915_READ
argument_list|(
name|GEN7_L3CNTLREG1
argument_list|)
operator||
name|GEN7_L3AGDIS
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN7_L3_CHICKEN_MODE_REGISTER
argument_list|,
name|GEN7_WA_L3_CHICKEN_MODE
argument_list|)
expr_stmt|;
comment|/* WaForceL3Serialization */
name|I915_WRITE
argument_list|(
name|GEN7_L3SQCREG4
argument_list|,
name|I915_READ
argument_list|(
name|GEN7_L3SQCREG4
argument_list|)
operator|&
operator|~
name|L3SQ_URB_READ_CAM_MATCH_DISABLE
argument_list|)
expr_stmt|;
comment|/* WaDisableDopClockGating */
name|I915_WRITE
argument_list|(
name|GEN7_ROW_CHICKEN2
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|DOP_CLOCK_GATING_DISABLE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* WaForceL3Serialization */
name|I915_WRITE
argument_list|(
name|GEN7_L3SQCREG4
argument_list|,
name|I915_READ
argument_list|(
name|GEN7_L3SQCREG4
argument_list|)
operator|&
operator|~
name|L3SQ_URB_READ_CAM_MATCH_DISABLE
argument_list|)
expr_stmt|;
comment|/* This is required by WaCatErrorRejectionIssue */
name|I915_WRITE
argument_list|(
name|GEN7_SQ_CHICKEN_MBCUNIT_CONFIG
argument_list|,
name|I915_READ
argument_list|(
name|GEN7_SQ_CHICKEN_MBCUNIT_CONFIG
argument_list|)
operator||
name|GEN7_SQ_CHICKEN_MBCUNIT_SQINTMOB
argument_list|)
expr_stmt|;
comment|/* WaMbcDriverBootEnable */
name|I915_WRITE
argument_list|(
name|GEN6_MBCTL
argument_list|,
name|I915_READ
argument_list|(
name|GEN6_MBCTL
argument_list|)
operator||
name|GEN6_MBCTL_ENABLE_BOOT_FETCH
argument_list|)
expr_stmt|;
comment|/* According to the BSpec vol1g, bit 12 (RCPBUNIT) clock 	 * gating disable must be set.  Failure to set it results in 	 * flickering pixels due to Z write ordering failures after 	 * some amount of runtime in the Mesa "fire" demo, and Unigine 	 * Sanctuary and Tropics, and apparently anything else with 	 * alpha test or pixel discard. 	 * 	 * According to the spec, bit 11 (RCCUNIT) must also be set, 	 * but we didn't debug actual testcases to find it out. 	 * 	 * According to the spec, bit 13 (RCZUNIT) must be set on IVB. 	 * This implements the WaDisableRCZUnitClockGating workaround. 	 * 	 * Also apply WaDisableVDSUnitClockGating and 	 * WaDisableRCPBUnitClockGating. 	 */
name|I915_WRITE
argument_list|(
name|GEN6_UCGCTL2
argument_list|,
name|GEN7_VDSUNIT_CLOCK_GATE_DISABLE
operator||
name|GEN7_TDLUNIT_CLOCK_GATE_DISABLE
operator||
name|GEN6_RCZUNIT_CLOCK_GATE_DISABLE
operator||
name|GEN6_RCPBUNIT_CLOCK_GATE_DISABLE
operator||
name|GEN6_RCCUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN7_UCGCTL4
argument_list|,
name|GEN7_L3BANK2X_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
name|for_each_pipe
argument_list|(
argument|pipe
argument_list|)
block|{
name|I915_WRITE
argument_list|(
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|,
name|I915_READ
argument_list|(
name|DSPCNTR
argument_list|(
name|pipe
argument_list|)
argument_list|)
operator||
name|DISPPLANE_TRICKLE_FEED_DISABLE
argument_list|)
expr_stmt|;
name|intel_flush_display_plane
argument_list|(
name|dev_priv
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
name|I915_WRITE
argument_list|(
name|CACHE_MODE_1
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|PIXEL_SUBSPAN_COLLECT_OPT_DISABLE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * On ValleyView, the GUnit needs to signal the GT 	 * when flip and other events complete.  So enable 	 * all the GUnit->GT interrupts here 	 */
name|I915_WRITE
argument_list|(
name|VLV_DPFLIPSTAT
argument_list|,
name|PIPEB_LINE_COMPARE_INT_EN
operator||
name|PIPEB_HLINE_INT_EN
operator||
name|PIPEB_VBLANK_INT_EN
operator||
name|SPRITED_FLIPDONE_INT_EN
operator||
name|SPRITEC_FLIPDONE_INT_EN
operator||
name|PLANEB_FLIPDONE_INT_EN
operator||
name|PIPEA_LINE_COMPARE_INT_EN
operator||
name|PIPEA_HLINE_INT_EN
operator||
name|PIPEA_VBLANK_INT_EN
operator||
name|SPRITEB_FLIPDONE_INT_EN
operator||
name|SPRITEA_FLIPDONE_INT_EN
operator||
name|PLANEA_FLIPDONE_INT_EN
argument_list|)
expr_stmt|;
comment|/* 	 * WaDisableVLVClockGating_VBIIssue 	 * Disable clock gating on th GCFG unit to prevent a delay 	 * in the reporting of vblank events. 	 */
name|I915_WRITE
argument_list|(
name|VLV_GUNIT_CLOCK_GATE
argument_list|,
name|GCFG_DIS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g4x_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|dspclk_gate
decl_stmt|;
name|I915_WRITE
argument_list|(
name|RENCLK_GATE_D1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RENCLK_GATE_D2
argument_list|,
name|VF_UNIT_CLOCK_GATE_DISABLE
operator||
name|GS_UNIT_CLOCK_GATE_DISABLE
operator||
name|CL_UNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RAMCLK_GATE_D
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dspclk_gate
operator|=
name|VRHUNIT_CLOCK_GATE_DISABLE
operator||
name|OVRUNIT_CLOCK_GATE_DISABLE
operator||
name|OVCUNIT_CLOCK_GATE_DISABLE
expr_stmt|;
if|if
condition|(
name|IS_GM45
argument_list|(
name|dev
argument_list|)
condition|)
name|dspclk_gate
operator||=
name|DSSUNIT_CLOCK_GATE_DISABLE
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPCLK_GATE_D
argument_list|,
name|dspclk_gate
argument_list|)
expr_stmt|;
comment|/* WaDisableRenderCachePipelinedFlush */
name|I915_WRITE
argument_list|(
name|CACHE_MODE_0
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|CM0_PIPELINED_RENDER_FLUSH_DISABLE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|crestline_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|I915_WRITE
argument_list|(
name|RENCLK_GATE_D1
argument_list|,
name|I965_RCC_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RENCLK_GATE_D2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|DSPCLK_GATE_D
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RAMCLK_GATE_D
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|I915_WRITE16
argument_list|(
name|DEUC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|broadwater_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|I915_WRITE
argument_list|(
name|RENCLK_GATE_D1
argument_list|,
name|I965_RCZ_CLOCK_GATE_DISABLE
operator||
name|I965_RCC_CLOCK_GATE_DISABLE
operator||
name|I965_RCPB_CLOCK_GATE_DISABLE
operator||
name|I965_ISC_CLOCK_GATE_DISABLE
operator||
name|I965_FBC_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RENCLK_GATE_D2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen3_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|dstate
init|=
name|I915_READ
argument_list|(
name|D_STATE
argument_list|)
decl_stmt|;
name|dstate
operator||=
name|DSTATE_PLL_D3_OFF
operator||
name|DSTATE_GFX_CLOCK_GATING
operator||
name|DSTATE_DOT_CLOCK_GATING
expr_stmt|;
name|I915_WRITE
argument_list|(
name|D_STATE
argument_list|,
name|dstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|ECOSKPD
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|ECO_GATING_CX_ONLY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* IIR "flip pending" means done if this bit is set */
name|I915_WRITE
argument_list|(
name|ECOSKPD
argument_list|,
name|_MASKED_BIT_DISABLE
argument_list|(
name|ECO_FLIP_DONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i85x_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|I915_WRITE
argument_list|(
name|RENCLK_GATE_D1
argument_list|,
name|SV_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i830_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|I915_WRITE
argument_list|(
name|DSPCLK_GATE_D
argument_list|,
name|OVRUNIT_CLOCK_GATE_DISABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_init_clock_gating
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Starting with Haswell, we have different power wells for  * different parts of the GPU. This attempts to enable them all.  */
end_comment

begin_function
name|void
name|intel_init_power_wells
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|unsigned
name|long
name|power_wells
index|[]
init|=
block|{
name|HSW_PWR_WELL_CTL1
block|,
name|HSW_PWR_WELL_CTL2
block|,
name|HSW_PWR_WELL_CTL4
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|power_wells
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|well
init|=
name|I915_READ
argument_list|(
name|power_wells
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|well
operator|&
name|HSW_PWR_WELL_STATE
operator|)
operator|==
literal|0
condition|)
block|{
name|I915_WRITE
argument_list|(
name|power_wells
index|[
name|i
index|]
argument_list|,
name|well
operator|&
name|HSW_PWR_WELL_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|power_wells
index|[
name|i
index|]
argument_list|)
operator|&
name|HSW_PWR_WELL_STATE
operator|)
argument_list|,
literal|20
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"Error enabling power well %lx\n"
argument_list|,
name|power_wells
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up chip specific power management-related functions */
end_comment

begin_function
name|void
name|intel_init_pm
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|I915_HAS_FBC
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|fbc_enabled
operator|=
name|ironlake_fbc_enabled
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|enable_fbc
operator|=
name|ironlake_enable_fbc
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|disable_fbc
operator|=
name|ironlake_disable_fbc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GM45
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|fbc_enabled
operator|=
name|g4x_fbc_enabled
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|enable_fbc
operator|=
name|g4x_enable_fbc
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|disable_fbc
operator|=
name|g4x_disable_fbc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_CRESTLINE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|fbc_enabled
operator|=
name|i8xx_fbc_enabled
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|enable_fbc
operator|=
name|i8xx_enable_fbc
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|disable_fbc
operator|=
name|i8xx_disable_fbc
expr_stmt|;
block|}
comment|/* 855GM needs testing */
block|}
comment|/* For cxsr */
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
name|i915_pineview_get_mem_freq
argument_list|(
name|dev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
name|i915_ironlake_get_mem_freq
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* For FIFO watermark updates */
if|if
condition|(
name|HAS_PCH_SPLIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|I915_READ
argument_list|(
name|MLTR_ILK
argument_list|)
operator|&
name|ILK_SRLT_MASK
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|ironlake_update_wm
expr_stmt|;
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Failed to get proper latency. "
literal|"Disable CxSR\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|NULL
expr_stmt|;
block|}
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|ironlake_init_clock_gating
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|SNB_READ_WM0_LATENCY
argument_list|()
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|sandybridge_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_sprite_wm
operator|=
name|sandybridge_update_sprite_wm
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Failed to read display plane latency. "
literal|"Disable CxSR\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|NULL
expr_stmt|;
block|}
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|gen6_init_clock_gating
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* FIXME: detect B0+ stepping and use auto training */
if|if
condition|(
name|SNB_READ_WM0_LATENCY
argument_list|()
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|ivybridge_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_sprite_wm
operator|=
name|sandybridge_update_sprite_wm
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Failed to read display plane latency. "
literal|"Disable CxSR\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|NULL
expr_stmt|;
block|}
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|ivybridge_init_clock_gating
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|SNB_READ_WM0_LATENCY
argument_list|()
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|sandybridge_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_sprite_wm
operator|=
name|sandybridge_update_sprite_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_linetime_wm
operator|=
name|haswell_update_linetime_wm
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Failed to read display plane latency. "
literal|"Disable CxSR\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|NULL
expr_stmt|;
block|}
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|haswell_init_clock_gating
expr_stmt|;
block|}
else|else
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|valleyview_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|valleyview_init_clock_gating
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_PINEVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|intel_get_cxsr_latency
argument_list|(
name|IS_PINEVIEW_G
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev_priv
operator|->
name|is_ddr3
argument_list|,
name|dev_priv
operator|->
name|fsb_freq
argument_list|,
name|dev_priv
operator|->
name|mem_freq
argument_list|)
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"failed to find known CxSR latency "
literal|"(found ddr%s fsb freq %d, mem freq %d), "
literal|"disabling CxSR\n"
argument_list|,
operator|(
name|dev_priv
operator|->
name|is_ddr3
operator|==
literal|1
operator|)
condition|?
literal|"3"
else|:
literal|"2"
argument_list|,
name|dev_priv
operator|->
name|fsb_freq
argument_list|,
name|dev_priv
operator|->
name|mem_freq
argument_list|)
expr_stmt|;
comment|/* Disable CxSR and never update its watermark again */
name|pineview_disable_cxsr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|pineview_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|gen3_init_clock_gating
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_G4X
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|g4x_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|g4x_init_clock_gating
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN4
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|i965_update_wm
expr_stmt|;
if|if
condition|(
name|IS_CRESTLINE
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|crestline_init_clock_gating
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_BROADWATER
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|broadwater_init_clock_gating
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN3
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|i9xx_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
operator|=
name|i9xx_get_fifo_size
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|gen3_init_clock_gating
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_I865G
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|i830_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|i85x_init_clock_gating
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
operator|=
name|i830_get_fifo_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_I85X
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|i9xx_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
operator|=
name|i85x_get_fifo_size
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|i85x_init_clock_gating
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|display
operator|.
name|update_wm
operator|=
name|i830_update_wm
expr_stmt|;
name|dev_priv
operator|->
name|display
operator|.
name|init_clock_gating
operator|=
name|i830_init_clock_gating
expr_stmt|;
if|if
condition|(
name|IS_845G
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
operator|=
name|i845_get_fifo_size
expr_stmt|;
else|else
name|dev_priv
operator|->
name|display
operator|.
name|get_fifo_size
operator|=
name|i830_get_fifo_size
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__gen6_gt_wait_for_thread_c0
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|gt_thread_status_mask
decl_stmt|;
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
name|gt_thread_status_mask
operator|=
name|GEN6_GT_THREAD_STATUS_CORE_MASK_HSW
expr_stmt|;
else|else
name|gt_thread_status_mask
operator|=
name|GEN6_GT_THREAD_STATUS_CORE_MASK
expr_stmt|;
comment|/* w/a for a sporadic read returning 0 by waiting for the GT 	 * thread to wake up. 	 */
if|if
condition|(
name|wait_for_atomic_us
argument_list|(
operator|(
name|I915_READ_NOTRACE
argument_list|(
name|GEN6_GT_THREAD_STATUS_REG
argument_list|)
operator|&
name|gt_thread_status_mask
operator|)
operator|==
literal|0
argument_list|,
literal|500
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"GT thread status wait timed out\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__gen6_gt_force_wake_reset
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|I915_WRITE_NOTRACE
argument_list|(
name|FORCEWAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|ECOBUS
argument_list|)
expr_stmt|;
comment|/* something from same cacheline, but !FORCEWAKE */
block|}
end_function

begin_function
specifier|static
name|void
name|__gen6_gt_force_wake_get
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|forcewake_ack
decl_stmt|;
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
name|forcewake_ack
operator|=
name|FORCEWAKE_ACK_HSW
expr_stmt|;
else|else
name|forcewake_ack
operator|=
name|FORCEWAKE_ACK
expr_stmt|;
if|if
condition|(
name|wait_for_atomic
argument_list|(
operator|(
name|I915_READ_NOTRACE
argument_list|(
name|forcewake_ack
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|,
name|FORCEWAKE_ACK_TIMEOUT_MS
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"Timed out waiting for forcewake old ack to clear.\n"
argument_list|)
expr_stmt|;
name|I915_WRITE_NOTRACE
argument_list|(
name|FORCEWAKE
argument_list|,
name|FORCEWAKE_KERNEL
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|ECOBUS
argument_list|)
expr_stmt|;
comment|/* something from same cacheline, but !FORCEWAKE */
if|if
condition|(
name|wait_for_atomic
argument_list|(
operator|(
name|I915_READ_NOTRACE
argument_list|(
name|forcewake_ack
argument_list|)
operator|&
literal|1
operator|)
argument_list|,
name|FORCEWAKE_ACK_TIMEOUT_MS
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"Timed out waiting for forcewake to ack request.\n"
argument_list|)
expr_stmt|;
name|__gen6_gt_wait_for_thread_c0
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__gen6_gt_force_wake_mt_reset
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|I915_WRITE_NOTRACE
argument_list|(
name|FORCEWAKE_MT
argument_list|,
name|_MASKED_BIT_DISABLE
argument_list|(
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* something from same cacheline, but !FORCEWAKE_MT */
name|POSTING_READ
argument_list|(
name|ECOBUS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__gen6_gt_force_wake_mt_get
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|forcewake_ack
decl_stmt|;
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
condition|)
name|forcewake_ack
operator|=
name|FORCEWAKE_ACK_HSW
expr_stmt|;
else|else
name|forcewake_ack
operator|=
name|FORCEWAKE_MT_ACK
expr_stmt|;
if|if
condition|(
name|wait_for_atomic
argument_list|(
operator|(
name|I915_READ_NOTRACE
argument_list|(
name|forcewake_ack
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|,
name|FORCEWAKE_ACK_TIMEOUT_MS
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"Timed out waiting for forcewake old ack to clear.\n"
argument_list|)
expr_stmt|;
name|I915_WRITE_NOTRACE
argument_list|(
name|FORCEWAKE_MT
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|FORCEWAKE_KERNEL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* something from same cacheline, but !FORCEWAKE_MT */
name|POSTING_READ
argument_list|(
name|ECOBUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_atomic
argument_list|(
operator|(
name|I915_READ_NOTRACE
argument_list|(
name|forcewake_ack
argument_list|)
operator|&
literal|1
operator|)
argument_list|,
name|FORCEWAKE_ACK_TIMEOUT_MS
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"Timed out waiting for forcewake to ack request.\n"
argument_list|)
expr_stmt|;
name|__gen6_gt_wait_for_thread_c0
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generally this is called implicitly by the register read function. However,  * if some sequence requires the GT to not power down then this function should  * be called at the beginning of the sequence followed by a call to  * gen6_gt_force_wake_put() at the end of the sequence.  */
end_comment

begin_function
name|void
name|gen6_gt_force_wake_get
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|gt_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|forcewake_count
operator|++
operator|==
literal|0
condition|)
name|dev_priv
operator|->
name|gt
operator|.
name|force_wake_get
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|gt_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gen6_gt_check_fifodbg
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|gtfifodbg
decl_stmt|;
name|gtfifodbg
operator|=
name|I915_READ_NOTRACE
argument_list|(
name|GTFIFODBG
argument_list|)
expr_stmt|;
if|if
condition|(
name|WARN
argument_list|(
name|gtfifodbg
operator|&
name|GT_FIFO_CPU_ERROR_MASK
argument_list|,
literal|"MMIO read or write has been dropped %x\n"
argument_list|,
name|gtfifodbg
argument_list|)
condition|)
name|I915_WRITE_NOTRACE
argument_list|(
name|GTFIFODBG
argument_list|,
name|GT_FIFO_CPU_ERROR_MASK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__gen6_gt_force_wake_put
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|I915_WRITE_NOTRACE
argument_list|(
name|FORCEWAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* something from same cacheline, but !FORCEWAKE */
name|POSTING_READ
argument_list|(
name|ECOBUS
argument_list|)
expr_stmt|;
name|gen6_gt_check_fifodbg
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__gen6_gt_force_wake_mt_put
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|I915_WRITE_NOTRACE
argument_list|(
name|FORCEWAKE_MT
argument_list|,
name|_MASKED_BIT_DISABLE
argument_list|(
name|FORCEWAKE_KERNEL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* something from same cacheline, but !FORCEWAKE_MT */
name|POSTING_READ
argument_list|(
name|ECOBUS
argument_list|)
expr_stmt|;
name|gen6_gt_check_fifodbg
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * see gen6_gt_force_wake_get()  */
end_comment

begin_function
name|void
name|gen6_gt_force_wake_put
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|gt_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|dev_priv
operator|->
name|forcewake_count
operator|==
literal|0
condition|)
name|dev_priv
operator|->
name|gt
operator|.
name|force_wake_put
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|gt_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|__gen6_gt_wait_for_fifo
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|gt_fifo_count
operator|<
name|GT_FIFO_NUM_RESERVED_ENTRIES
condition|)
block|{
name|int
name|loop
init|=
literal|500
decl_stmt|;
name|u32
name|fifo
init|=
name|I915_READ_NOTRACE
argument_list|(
name|GT_FIFO_FREE_ENTRIES
argument_list|)
decl_stmt|;
while|while
condition|(
name|fifo
operator|<=
name|GT_FIFO_NUM_RESERVED_ENTRIES
operator|&&
name|loop
operator|--
condition|)
block|{
name|udelay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|fifo
operator|=
name|I915_READ_NOTRACE
argument_list|(
name|GT_FIFO_FREE_ENTRIES
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WARN_ON
argument_list|(
name|loop
operator|<
literal|0
operator|&&
name|fifo
operator|<=
name|GT_FIFO_NUM_RESERVED_ENTRIES
argument_list|)
condition|)
operator|++
name|ret
expr_stmt|;
name|dev_priv
operator|->
name|gt_fifo_count
operator|=
name|fifo
expr_stmt|;
block|}
name|dev_priv
operator|->
name|gt_fifo_count
operator|--
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlv_force_wake_reset
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|I915_WRITE_NOTRACE
argument_list|(
name|FORCEWAKE_VLV
argument_list|,
name|_MASKED_BIT_DISABLE
argument_list|(
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* something from same cacheline, but !FORCEWAKE_VLV */
name|POSTING_READ
argument_list|(
name|FORCEWAKE_ACK_VLV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlv_force_wake_get
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
if|if
condition|(
name|wait_for_atomic
argument_list|(
operator|(
name|I915_READ_NOTRACE
argument_list|(
name|FORCEWAKE_ACK_VLV
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|,
name|FORCEWAKE_ACK_TIMEOUT_MS
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"Timed out waiting for forcewake old ack to clear.\n"
argument_list|)
expr_stmt|;
name|I915_WRITE_NOTRACE
argument_list|(
name|FORCEWAKE_VLV
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|FORCEWAKE_KERNEL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_atomic
argument_list|(
operator|(
name|I915_READ_NOTRACE
argument_list|(
name|FORCEWAKE_ACK_VLV
argument_list|)
operator|&
literal|1
operator|)
argument_list|,
name|FORCEWAKE_ACK_TIMEOUT_MS
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"Timed out waiting for forcewake to ack request.\n"
argument_list|)
expr_stmt|;
name|__gen6_gt_wait_for_thread_c0
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlv_force_wake_put
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|I915_WRITE_NOTRACE
argument_list|(
name|FORCEWAKE_VLV
argument_list|,
name|_MASKED_BIT_DISABLE
argument_list|(
name|FORCEWAKE_KERNEL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* something from same cacheline, but !FORCEWAKE_VLV */
name|POSTING_READ
argument_list|(
name|FORCEWAKE_ACK_VLV
argument_list|)
expr_stmt|;
name|gen6_gt_check_fifodbg
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intel_gt_reset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|vlv_force_wake_reset
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|6
condition|)
block|{
name|__gen6_gt_force_wake_reset
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
name|__gen6_gt_force_wake_mt_reset
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|intel_gt_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|dev_priv
operator|->
name|gt_lock
argument_list|,
literal|"i915_gt_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|intel_gt_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_VALLEYVIEW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|gt
operator|.
name|force_wake_get
operator|=
name|vlv_force_wake_get
expr_stmt|;
name|dev_priv
operator|->
name|gt
operator|.
name|force_wake_put
operator|=
name|vlv_force_wake_put
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_IVYBRIDGE
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|gt
operator|.
name|force_wake_get
operator|=
name|__gen6_gt_force_wake_mt_get
expr_stmt|;
name|dev_priv
operator|->
name|gt
operator|.
name|force_wake_put
operator|=
name|__gen6_gt_force_wake_mt_put
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|gt
operator|.
name|force_wake_get
operator|=
name|__gen6_gt_force_wake_get
expr_stmt|;
name|dev_priv
operator|->
name|gt
operator|.
name|force_wake_put
operator|=
name|__gen6_gt_force_wake_put
expr_stmt|;
block|}
name|TIMEOUT_TASK_INIT
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|delayed_resume_work
argument_list|,
literal|0
argument_list|,
name|intel_gen6_powersave_work
argument_list|,
name|dev_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sandybridge_pcode_read
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|u8
name|mbox
parameter_list|,
name|u32
modifier|*
name|val
parameter_list|)
block|{
name|sx_assert
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|hw_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|GEN6_PCODE_MAILBOX
argument_list|)
operator|&
name|GEN6_PCODE_READY
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"warning: pcode (read) mailbox access failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EAGAIN
return|;
block|}
name|I915_WRITE
argument_list|(
name|GEN6_PCODE_DATA
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PCODE_MAILBOX
argument_list|,
name|GEN6_PCODE_READY
operator||
name|mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|GEN6_PCODE_MAILBOX
argument_list|)
operator|&
name|GEN6_PCODE_READY
operator|)
operator|==
literal|0
argument_list|,
literal|500
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for pcode read (%d) to finish\n"
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
return|return
operator|-
name|ETIMEDOUT
return|;
block|}
operator|*
name|val
operator|=
name|I915_READ
argument_list|(
name|GEN6_PCODE_DATA
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PCODE_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sandybridge_pcode_write
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|u8
name|mbox
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|sx_assert
argument_list|(
operator|&
name|dev_priv
operator|->
name|rps
operator|.
name|hw_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|I915_READ
argument_list|(
name|GEN6_PCODE_MAILBOX
argument_list|)
operator|&
name|GEN6_PCODE_READY
condition|)
block|{
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"warning: pcode (write) mailbox access failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EAGAIN
return|;
block|}
name|I915_WRITE
argument_list|(
name|GEN6_PCODE_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN6_PCODE_MAILBOX
argument_list|,
name|GEN6_PCODE_READY
operator||
name|mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for
argument_list|(
operator|(
name|I915_READ
argument_list|(
name|GEN6_PCODE_MAILBOX
argument_list|)
operator|&
name|GEN6_PCODE_READY
operator|)
operator|==
literal|0
argument_list|,
literal|500
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for pcode write (%d) to finish\n"
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
return|return
operator|-
name|ETIMEDOUT
return|;
block|}
name|I915_WRITE
argument_list|(
name|GEN6_PCODE_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

