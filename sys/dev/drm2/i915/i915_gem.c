begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Â© 2008 Intel Corporation  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  *  * Authors:  *    Eric Anholt<eric@anholt.net>  *  * Copyright (c) 2011 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Konstantin Belousov under sponsorship from  * the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sf_buf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_function_decl
specifier|static
name|void
name|i915_gem_object_flush_gtt_write_domain
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_object_flush_cpu_write_domain
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__must_check
name|int
name|i915_gem_object_bind_to_gtt
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|unsigned
name|alignment
parameter_list|,
name|bool
name|map_and_fenceable
parameter_list|,
name|bool
name|nonblocking
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i915_gem_phys_pwrite
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_i915_gem_pwrite
modifier|*
name|args
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_write_fence
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_object_update_fence
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_i915_fence_reg
modifier|*
name|fence
parameter_list|,
name|bool
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_inactive_shrink
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|i915_gem_purge
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|long
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_shrink_all
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_object_truncate
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i915_gem_object_get_pages_range
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|off_t
name|start
parameter_list|,
name|off_t
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|i915_gem_wire_page
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|bool
modifier|*
name|fresh
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_I915_GEM
argument_list|,
literal|"i915gem"
argument_list|,
literal|"Allocations from i915 gem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|long
name|i915_gem_wired_pages_cnt
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|i915_gem_object_fence_lost
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|tiling_mode
condition|)
name|i915_gem_release_mmap
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|/* As we do not have an associated fence register, we will force 	 * a tiling change if we ever need to acquire one. 	 */
name|obj
operator|->
name|fence_dirty
operator|=
name|false
expr_stmt|;
name|obj
operator|->
name|fence_reg
operator|=
name|I915_FENCE_REG_NONE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* some bookkeeping */
end_comment

begin_function
specifier|static
name|void
name|i915_gem_info_add_obj
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|dev_priv
operator|->
name|mm
operator|.
name|object_count
operator|++
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|object_memory
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_info_remove_obj
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|dev_priv
operator|->
name|mm
operator|.
name|object_count
operator|--
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|object_memory
operator|-=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_wait_for_error
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|completion
modifier|*
name|x
init|=
operator|&
name|dev_priv
operator|->
name|error_completion
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|atomic_read
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Only wait 10 seconds for the gpu reset to complete to avoid hanging 	 * userspace. If it takes that long something really bad is going on and 	 * we should simply try to bail out and fail as gracefully as possible. 	 */
name|ret
operator|=
name|wait_for_completion_interruptible_timeout
argument_list|(
name|x
argument_list|,
literal|10
operator|*
name|HZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Timed out waiting for the gpu reset to complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
condition|)
block|{
comment|/* GPU is hung, bump the completion count to account for 		 * the token we just consumed so that we never hit zero and 		 * end up waiting upon a subsequent completion event that 		 * will never happen. 		 */
name|mtx_lock
argument_list|(
operator|&
name|x
operator|->
name|lock
argument_list|)
expr_stmt|;
name|x
operator|->
name|done
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|x
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_mutex_lock_interruptible
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|i915_gem_wait_for_error
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* 	 * interruptible shall it be. might indeed be if dev_lock is 	 * changed to sx 	 */
name|ret
operator|=
name|sx_xlock_sig
argument_list|(
operator|&
name|dev
operator|->
name|dev_struct_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|-
name|EINTR
return|;
name|WARN_ON
argument_list|(
name|i915_verify_lists
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|i915_gem_object_is_inactive
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
return|return
name|obj
operator|->
name|gtt_space
operator|&&
operator|!
name|obj
operator|->
name|active
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_init_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_init
modifier|*
name|args
init|=
name|data
decl_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
if|if
condition|(
name|args
operator|->
name|gtt_start
operator|>=
name|args
operator|->
name|gtt_end
operator|||
operator|(
name|args
operator|->
name|gtt_end
operator||
name|args
operator|->
name|gtt_start
operator|)
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* GEM with user mode setting was never supported on ilk and later. */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|5
condition|)
return|return
operator|-
name|ENODEV
return|;
comment|/* 	 * XXXKIB. The second-time initialization should be guarded 	 * against. 	 */
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_init_global_gtt
argument_list|(
name|dev
argument_list|,
name|args
operator|->
name|gtt_start
argument_list|,
name|args
operator|->
name|gtt_end
argument_list|,
name|args
operator|->
name|gtt_end
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_get_aperture_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_get_aperture
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|size_t
name|pinned
decl_stmt|;
name|pinned
operator|=
literal|0
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|&dev_priv->mm.bound_list
argument_list|,
argument|gtt_list
argument_list|)
if|if
condition|(
name|obj
operator|->
name|pin_count
condition|)
name|pinned
operator|+=
name|obj
operator|->
name|gtt_space
operator|->
name|size
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|args
operator|->
name|aper_size
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_total
expr_stmt|;
name|args
operator|->
name|aper_available_size
operator|=
name|args
operator|->
name|aper_size
operator|-
name|pinned
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_create
parameter_list|(
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint32_t
modifier|*
name|handle_p
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|u32
name|handle
decl_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* Allocate the new object */
name|obj
operator|=
name|i915_gem_alloc_object
argument_list|(
name|dev
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|ret
operator|=
name|drm_gem_handle_create
argument_list|(
name|file
argument_list|,
operator|&
name|obj
operator|->
name|base
argument_list|,
operator|&
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|drm_gem_object_release
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|i915_gem_info_remove_obj
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obj
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* drop reference from allocate - handle holds it now */
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_create %p %x"
argument_list|,
name|obj
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|*
name|handle_p
operator|=
name|handle
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_dumb_create
parameter_list|(
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_mode_create_dumb
modifier|*
name|args
parameter_list|)
block|{
comment|/* have to work out size/pitch and return them */
name|args
operator|->
name|pitch
operator|=
name|roundup2
argument_list|(
name|args
operator|->
name|width
operator|*
operator|(
operator|(
name|args
operator|->
name|bpp
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|args
operator|->
name|size
operator|=
name|args
operator|->
name|pitch
operator|*
name|args
operator|->
name|height
expr_stmt|;
return|return
name|i915_gem_create
argument_list|(
name|file
argument_list|,
name|dev
argument_list|,
name|args
operator|->
name|size
argument_list|,
operator|&
name|args
operator|->
name|handle
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_dumb_destroy
parameter_list|(
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|handle
parameter_list|)
block|{
return|return
name|drm_gem_handle_delete
argument_list|(
name|file
argument_list|,
name|handle
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Creates a new mm object and returns a handle to it.  */
end_comment

begin_function
name|int
name|i915_gem_create_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_create
modifier|*
name|args
init|=
name|data
decl_stmt|;
return|return
name|i915_gem_create
argument_list|(
name|file
argument_list|,
name|dev
argument_list|,
name|args
operator|->
name|size
argument_list|,
operator|&
name|args
operator|->
name|handle
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_object_needs_bit17_swizzle
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
name|dev_priv
operator|->
name|mm
operator|.
name|bit_6_swizzle_x
operator|==
name|I915_BIT_6_SWIZZLE_9_10_17
operator|&&
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|__copy_to_user_swizzled
parameter_list|(
name|char
name|__user
modifier|*
name|cpu_vaddr
parameter_list|,
specifier|const
name|char
modifier|*
name|gpu_vaddr
parameter_list|,
name|int
name|gpu_offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|cpu_offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|int
name|cacheline_end
init|=
name|roundup2
argument_list|(
name|gpu_offset
operator|+
literal|1
argument_list|,
literal|64
argument_list|)
decl_stmt|;
name|int
name|this_length
init|=
name|min
argument_list|(
name|cacheline_end
operator|-
name|gpu_offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|int
name|swizzled_gpu_offset
init|=
name|gpu_offset
operator|^
literal|64
decl_stmt|;
name|ret
operator|=
name|__copy_to_user
argument_list|(
name|cpu_vaddr
operator|+
name|cpu_offset
argument_list|,
name|gpu_vaddr
operator|+
name|swizzled_gpu_offset
argument_list|,
name|this_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
operator|+
name|length
return|;
name|cpu_offset
operator|+=
name|this_length
expr_stmt|;
name|gpu_offset
operator|+=
name|this_length
expr_stmt|;
name|length
operator|-=
name|this_length
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|__copy_from_user_swizzled
parameter_list|(
name|char
modifier|*
name|gpu_vaddr
parameter_list|,
name|int
name|gpu_offset
parameter_list|,
specifier|const
name|char
name|__user
modifier|*
name|cpu_vaddr
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|cpu_offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|int
name|cacheline_end
init|=
name|roundup2
argument_list|(
name|gpu_offset
operator|+
literal|1
argument_list|,
literal|64
argument_list|)
decl_stmt|;
name|int
name|this_length
init|=
name|min
argument_list|(
name|cacheline_end
operator|-
name|gpu_offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|int
name|swizzled_gpu_offset
init|=
name|gpu_offset
operator|^
literal|64
decl_stmt|;
name|ret
operator|=
name|__copy_from_user
argument_list|(
name|gpu_vaddr
operator|+
name|swizzled_gpu_offset
argument_list|,
name|cpu_vaddr
operator|+
name|cpu_offset
argument_list|,
name|this_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
operator|+
name|length
return|;
name|cpu_offset
operator|+=
name|this_length
expr_stmt|;
name|gpu_offset
operator|+=
name|this_length
expr_stmt|;
name|length
operator|-=
name|this_length
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Per-page copy function for the shmem pread fastpath.  * Flushes invalid cachelines before reading the target if  * needs_clflush is set. */
end_comment

begin_function
specifier|static
name|int
name|shmem_pread_fast
parameter_list|(
name|vm_page_t
name|page
parameter_list|,
name|int
name|shmem_page_offset
parameter_list|,
name|int
name|page_length
parameter_list|,
name|char
name|__user
modifier|*
name|user_data
parameter_list|,
name|bool
name|page_do_bit17_swizzling
parameter_list|,
name|bool
name|needs_clflush
parameter_list|)
block|{
name|char
modifier|*
name|vaddr
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|page_do_bit17_swizzling
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sched_pin
argument_list|()
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|page
argument_list|,
name|SFB_NOWAIT
operator||
name|SFB_CPUPRIVATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|==
name|NULL
condition|)
block|{
name|sched_unpin
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
name|EFAULT
operator|)
return|;
block|}
name|vaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_clflush
condition|)
name|drm_clflush_virt_range
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__copy_to_user_inatomic
argument_list|(
name|user_data
argument_list|,
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
return|return
name|ret
condition|?
operator|-
name|EFAULT
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|shmem_clflush_swizzled_range
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|,
name|unsigned
name|long
name|length
parameter_list|,
name|bool
name|swizzled
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|swizzled
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|start
init|=
operator|(
name|unsigned
name|long
operator|)
name|addr
decl_stmt|;
name|unsigned
name|long
name|end
init|=
operator|(
name|unsigned
name|long
operator|)
name|addr
operator|+
name|length
decl_stmt|;
comment|/* For swizzling simply ensure that we always flush both 		 * channels. Lame, but simple and it works. Swizzled 		 * pwrite/pread is far from a hotpath - current userspace 		 * doesn't use it at all. */
name|start
operator|=
name|round_down
argument_list|(
name|start
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|end
operator|=
name|round_up
argument_list|(
name|end
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|drm_clflush_virt_range
argument_list|(
operator|(
name|void
operator|*
operator|)
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drm_clflush_virt_range
argument_list|(
name|addr
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Only difference to the fast-path function is that this can handle bit17  * and uses non-atomic copy and kmap functions. */
end_comment

begin_function
specifier|static
name|int
name|shmem_pread_slow
parameter_list|(
name|vm_page_t
name|page
parameter_list|,
name|int
name|shmem_page_offset
parameter_list|,
name|int
name|page_length
parameter_list|,
name|char
name|__user
modifier|*
name|user_data
parameter_list|,
name|bool
name|page_do_bit17_swizzling
parameter_list|,
name|bool
name|needs_clflush
parameter_list|)
block|{
name|char
modifier|*
name|vaddr
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|page
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_clflush
condition|)
name|shmem_clflush_swizzled_range
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|,
name|page_do_bit17_swizzling
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_do_bit17_swizzling
condition|)
name|ret
operator|=
name|__copy_to_user_swizzled
argument_list|(
name|user_data
argument_list|,
name|vaddr
argument_list|,
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|__copy_to_user
argument_list|(
name|user_data
argument_list|,
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
return|return
name|ret
condition|?
operator|-
name|EFAULT
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_shmem_pread
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_i915_gem_pread
modifier|*
name|args
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|char
name|__user
modifier|*
name|user_data
decl_stmt|;
name|ssize_t
name|remain
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|shmem_page_offset
decl_stmt|,
name|page_length
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|obj_do_bit17_swizzling
decl_stmt|,
name|page_do_bit17_swizzling
decl_stmt|;
name|int
name|hit_slowpath
init|=
literal|0
decl_stmt|;
name|int
name|prefaulted
init|=
literal|0
decl_stmt|;
name|int
name|needs_clflush
init|=
literal|0
decl_stmt|;
name|user_data
operator|=
name|to_user_ptr
argument_list|(
name|args
operator|->
name|data_ptr
argument_list|)
expr_stmt|;
name|remain
operator|=
name|args
operator|->
name|size
expr_stmt|;
name|obj_do_bit17_swizzling
operator|=
name|i915_gem_object_needs_bit17_swizzle
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_DOMAIN_CPU
operator|)
condition|)
block|{
comment|/* If we're not in the cpu read domain, set ourself into the gtt 		 * read domain and manually flush cachelines (if required). This 		 * optimizes for the case when the gpu will dirty the data 		 * anyway again before the next pread happens. */
if|if
condition|(
name|obj
operator|->
name|cache_level
operator|==
name|I915_CACHE_NONE
condition|)
name|needs_clflush
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|gtt_space
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|obj
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
block|}
name|ret
operator|=
name|i915_gem_object_get_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_object_pin_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|offset
operator|=
name|args
operator|->
name|offset
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|vm_page_t
name|page
init|=
name|vm_page_find_least
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
argument_list|)
init|;
condition|;
name|page
operator|=
name|vm_page_next
argument_list|(
name|page
argument_list|)
control|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|remain
operator|<=
literal|0
condition|)
break|break;
comment|/* Operation in this page 		 * 		 * shmem_page_offset = offset within page in shmem file 		 * page_length = bytes to copy for this page 		 */
name|shmem_page_offset
operator|=
name|offset_in_page
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|page_length
operator|=
name|remain
expr_stmt|;
if|if
condition|(
operator|(
name|shmem_page_offset
operator|+
name|page_length
operator|)
operator|>
name|PAGE_SIZE
condition|)
name|page_length
operator|=
name|PAGE_SIZE
operator|-
name|shmem_page_offset
expr_stmt|;
name|page_do_bit17_swizzling
operator|=
name|obj_do_bit17_swizzling
operator|&&
operator|(
name|page_to_phys
argument_list|(
name|page
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|17
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|ret
operator|=
name|shmem_pread_fast
argument_list|(
name|page
argument_list|,
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|,
name|user_data
argument_list|,
name|page_do_bit17_swizzling
argument_list|,
name|needs_clflush
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
goto|goto
name|next_page
goto|;
name|hit_slowpath
operator|=
literal|1
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefaulted
condition|)
block|{
name|ret
operator|=
name|fault_in_multipages_writeable
argument_list|(
name|user_data
argument_list|,
name|remain
argument_list|)
expr_stmt|;
comment|/* Userspace is tricking us, but we've already clobbered 			 * its pages with the prefault and promised to write the 			 * data up to the first fault. Hence ignore any errors 			 * and just continue. */
operator|(
name|void
operator|)
name|ret
expr_stmt|;
name|prefaulted
operator|=
literal|1
expr_stmt|;
block|}
name|ret
operator|=
name|shmem_pread_slow
argument_list|(
name|page
argument_list|,
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|,
name|user_data
argument_list|,
name|page_do_bit17_swizzling
argument_list|,
name|needs_clflush
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|next_page
label|:
name|vm_page_reference
argument_list|(
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|remain
operator|-=
name|page_length
expr_stmt|;
name|user_data
operator|+=
name|page_length
expr_stmt|;
name|offset
operator|+=
name|page_length
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|i915_gem_object_unpin_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|hit_slowpath
condition|)
block|{
comment|/* Fixup: Kill any reinstated backing storage pages */
if|if
condition|(
name|obj
operator|->
name|madv
operator|==
name|__I915_MADV_PURGED
condition|)
name|i915_gem_object_truncate
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Reads data from the object referenced by handle.  *  * On error, the contents of *data are undefined.  */
end_comment

begin_function
name|int
name|i915_gem_pread_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_pread
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|useracc
argument_list|(
name|to_user_ptr
argument_list|(
name|args
operator|->
name|data_ptr
argument_list|)
argument_list|,
name|args
operator|->
name|size
argument_list|,
name|VM_PROT_WRITE
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* Bounds check source.  */
if|if
condition|(
name|args
operator|->
name|offset
operator|>
name|obj
operator|->
name|base
operator|.
name|size
operator|||
name|args
operator|->
name|size
operator|>
name|obj
operator|->
name|base
operator|.
name|size
operator|-
name|args
operator|->
name|offset
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|FREEBSD_WIP
comment|/* prime objects have no backing filp to GEM pread/pwrite 	 * pages from. 	 */
if|if
condition|(
operator|!
name|obj
operator|->
name|base
operator|.
name|filp
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"pread %p %jx %jx"
argument_list|,
name|obj
argument_list|,
name|args
operator|->
name|offset
argument_list|,
name|args
operator|->
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_shmem_pread
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|args
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|out
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* This is the fast write path which cannot handle  * page faults in the source data  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|fast_user_write
parameter_list|(
name|vm_paddr_t
name|mapping_addr
parameter_list|,
name|off_t
name|page_base
parameter_list|,
name|int
name|page_offset
parameter_list|,
name|char
name|__user
modifier|*
name|user_data
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|void
name|__iomem
modifier|*
name|vaddr_atomic
decl_stmt|;
name|void
modifier|*
name|vaddr
decl_stmt|;
name|unsigned
name|long
name|unwritten
decl_stmt|;
name|vaddr_atomic
operator|=
name|pmap_mapdev_attr
argument_list|(
name|mapping_addr
operator|+
name|page_base
argument_list|,
name|length
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
comment|/* We can use the cpu mem copy function because this is X86. */
name|vaddr
operator|=
operator|(
name|char
name|__force
operator|*
operator|)
name|vaddr_atomic
operator|+
name|page_offset
expr_stmt|;
name|unwritten
operator|=
name|__copy_from_user_inatomic_nocache
argument_list|(
name|vaddr
argument_list|,
name|user_data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vaddr_atomic
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|unwritten
return|;
block|}
end_function

begin_comment
comment|/**  * This is the fast pwrite path, where we copy the data directly from the  * user into the GTT, uncached.  */
end_comment

begin_function
specifier|static
name|int
name|i915_gem_gtt_pwrite_fast
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_i915_gem_pwrite
modifier|*
name|args
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|ssize_t
name|remain
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|page_base
decl_stmt|;
name|char
name|__user
modifier|*
name|user_data
decl_stmt|;
name|int
name|page_offset
decl_stmt|,
name|page_length
decl_stmt|,
name|ret
decl_stmt|;
name|ret
operator|=
name|i915_gem_object_pin
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|obj
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out_unpin
goto|;
name|ret
operator|=
name|i915_gem_object_put_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out_unpin
goto|;
name|user_data
operator|=
name|to_user_ptr
argument_list|(
name|args
operator|->
name|data_ptr
argument_list|)
expr_stmt|;
name|remain
operator|=
name|args
operator|->
name|size
expr_stmt|;
name|offset
operator|=
name|obj
operator|->
name|gtt_offset
operator|+
name|args
operator|->
name|offset
expr_stmt|;
while|while
condition|(
name|remain
operator|>
literal|0
condition|)
block|{
comment|/* Operation in this page 		 * 		 * page_base = page offset within aperture 		 * page_offset = offset within page 		 * page_length = bytes to copy for this page 		 */
name|page_base
operator|=
name|offset
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
name|page_offset
operator|=
name|offset_in_page
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|page_length
operator|=
name|remain
expr_stmt|;
if|if
condition|(
operator|(
name|page_offset
operator|+
name|remain
operator|)
operator|>
name|PAGE_SIZE
condition|)
name|page_length
operator|=
name|PAGE_SIZE
operator|-
name|page_offset
expr_stmt|;
comment|/* If we get a fault while copying data, then (presumably) our 		 * source page isn't available.  Return the error and we'll 		 * retry in the slow path. 		 */
if|if
condition|(
name|fast_user_write
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
argument_list|,
name|page_base
argument_list|,
name|page_offset
argument_list|,
name|user_data
argument_list|,
name|page_length
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|out_unpin
goto|;
block|}
name|remain
operator|-=
name|page_length
expr_stmt|;
name|user_data
operator|+=
name|page_length
expr_stmt|;
name|offset
operator|+=
name|page_length
expr_stmt|;
block|}
name|out_unpin
label|:
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Per-page copy function for the shmem pwrite fastpath.  * Flushes invalid cachelines before writing to the target if  * needs_clflush_before is set and flushes out any written cachelines after  * writing if needs_clflush is set. */
end_comment

begin_function
specifier|static
name|int
name|shmem_pwrite_fast
parameter_list|(
name|vm_page_t
name|page
parameter_list|,
name|int
name|shmem_page_offset
parameter_list|,
name|int
name|page_length
parameter_list|,
name|char
name|__user
modifier|*
name|user_data
parameter_list|,
name|bool
name|page_do_bit17_swizzling
parameter_list|,
name|bool
name|needs_clflush_before
parameter_list|,
name|bool
name|needs_clflush_after
parameter_list|)
block|{
name|char
modifier|*
name|vaddr
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|page_do_bit17_swizzling
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sched_pin
argument_list|()
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|page
argument_list|,
name|SFB_NOWAIT
operator||
name|SFB_CPUPRIVATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|==
name|NULL
condition|)
block|{
name|sched_unpin
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
name|EFAULT
operator|)
return|;
block|}
name|vaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_clflush_before
condition|)
name|drm_clflush_virt_range
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__copy_from_user_inatomic_nocache
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|user_data
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_clflush_after
condition|)
name|drm_clflush_virt_range
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
return|return
name|ret
condition|?
operator|-
name|EFAULT
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Only difference to the fast-path function is that this can handle bit17  * and uses non-atomic copy and kmap functions. */
end_comment

begin_function
specifier|static
name|int
name|shmem_pwrite_slow
parameter_list|(
name|vm_page_t
name|page
parameter_list|,
name|int
name|shmem_page_offset
parameter_list|,
name|int
name|page_length
parameter_list|,
name|char
name|__user
modifier|*
name|user_data
parameter_list|,
name|bool
name|page_do_bit17_swizzling
parameter_list|,
name|bool
name|needs_clflush_before
parameter_list|,
name|bool
name|needs_clflush_after
parameter_list|)
block|{
name|char
modifier|*
name|vaddr
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|page
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|needs_clflush_before
operator|||
name|page_do_bit17_swizzling
argument_list|)
condition|)
name|shmem_clflush_swizzled_range
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|,
name|page_do_bit17_swizzling
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_do_bit17_swizzling
condition|)
name|ret
operator|=
name|__copy_from_user_swizzled
argument_list|(
name|vaddr
argument_list|,
name|shmem_page_offset
argument_list|,
name|user_data
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|__copy_from_user
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|user_data
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_clflush_after
condition|)
name|shmem_clflush_swizzled_range
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|,
name|page_do_bit17_swizzling
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
return|return
name|ret
condition|?
operator|-
name|EFAULT
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_shmem_pwrite
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_i915_gem_pwrite
modifier|*
name|args
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|ssize_t
name|remain
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|char
name|__user
modifier|*
name|user_data
decl_stmt|;
name|int
name|shmem_page_offset
decl_stmt|,
name|page_length
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|obj_do_bit17_swizzling
decl_stmt|,
name|page_do_bit17_swizzling
decl_stmt|;
name|int
name|hit_slowpath
init|=
literal|0
decl_stmt|;
name|int
name|needs_clflush_after
init|=
literal|0
decl_stmt|;
name|int
name|needs_clflush_before
init|=
literal|0
decl_stmt|;
name|user_data
operator|=
name|to_user_ptr
argument_list|(
name|args
operator|->
name|data_ptr
argument_list|)
expr_stmt|;
name|remain
operator|=
name|args
operator|->
name|size
expr_stmt|;
name|obj_do_bit17_swizzling
operator|=
name|i915_gem_object_needs_bit17_swizzle
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|!=
name|I915_GEM_DOMAIN_CPU
condition|)
block|{
comment|/* If we're not in the cpu write domain, set ourself into the gtt 		 * write domain and manually flush cachelines (if required). This 		 * optimizes for the case when the gpu will use the data 		 * right away and we therefore have to clflush anyway. */
if|if
condition|(
name|obj
operator|->
name|cache_level
operator|==
name|I915_CACHE_NONE
condition|)
name|needs_clflush_after
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|gtt_space
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|obj
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
block|}
comment|/* Same trick applies for invalidate partially written cachelines before 	 * writing.  */
if|if
condition|(
operator|!
operator|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_DOMAIN_CPU
operator|)
operator|&&
name|obj
operator|->
name|cache_level
operator|==
name|I915_CACHE_NONE
condition|)
name|needs_clflush_before
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_get_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_object_pin_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|offset
operator|=
name|args
operator|->
name|offset
expr_stmt|;
name|obj
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|vm_page_t
name|page
init|=
name|vm_page_find_least
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
argument_list|)
init|;
condition|;
name|page
operator|=
name|vm_page_next
argument_list|(
name|page
argument_list|)
control|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|int
name|partial_cacheline_write
decl_stmt|;
if|if
condition|(
name|remain
operator|<=
literal|0
condition|)
break|break;
comment|/* Operation in this page 		 * 		 * shmem_page_offset = offset within page in shmem file 		 * page_length = bytes to copy for this page 		 */
name|shmem_page_offset
operator|=
name|offset_in_page
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|page_length
operator|=
name|remain
expr_stmt|;
if|if
condition|(
operator|(
name|shmem_page_offset
operator|+
name|page_length
operator|)
operator|>
name|PAGE_SIZE
condition|)
name|page_length
operator|=
name|PAGE_SIZE
operator|-
name|shmem_page_offset
expr_stmt|;
comment|/* If we don't overwrite a cacheline completely we need to be 		 * careful to have up-to-date data by first clflushing. Don't 		 * overcomplicate things and flush the entire patch. */
name|partial_cacheline_write
operator|=
name|needs_clflush_before
operator|&&
operator|(
operator|(
name|shmem_page_offset
operator||
name|page_length
operator|)
operator|&
operator|(
name|cpu_clflush_line_size
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|page_do_bit17_swizzling
operator|=
name|obj_do_bit17_swizzling
operator|&&
operator|(
name|page_to_phys
argument_list|(
name|page
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|17
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|ret
operator|=
name|shmem_pwrite_fast
argument_list|(
name|page
argument_list|,
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|,
name|user_data
argument_list|,
name|page_do_bit17_swizzling
argument_list|,
name|partial_cacheline_write
argument_list|,
name|needs_clflush_after
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
goto|goto
name|next_page
goto|;
name|hit_slowpath
operator|=
literal|1
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|shmem_pwrite_slow
argument_list|(
name|page
argument_list|,
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|,
name|user_data
argument_list|,
name|page_do_bit17_swizzling
argument_list|,
name|partial_cacheline_write
argument_list|,
name|needs_clflush_after
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|next_page
label|:
name|vm_page_dirty
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|vm_page_reference
argument_list|(
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|remain
operator|-=
name|page_length
expr_stmt|;
name|user_data
operator|+=
name|page_length
expr_stmt|;
name|offset
operator|+=
name|page_length
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|i915_gem_object_unpin_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|hit_slowpath
condition|)
block|{
comment|/* Fixup: Kill any reinstated backing storage pages */
if|if
condition|(
name|obj
operator|->
name|madv
operator|==
name|__I915_MADV_PURGED
condition|)
name|i915_gem_object_truncate
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|/* and flush dirty cachelines in case the object isn't in the cpu write 		 * domain anymore. */
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|!=
name|I915_GEM_DOMAIN_CPU
condition|)
block|{
name|i915_gem_clflush_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|i915_gem_chipset_flush
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needs_clflush_after
condition|)
name|i915_gem_chipset_flush
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Writes data to the object referenced by handle.  *  * On error, the contents of the buffer that were to be modified are undefined.  */
end_comment

begin_function
name|int
name|i915_gem_pwrite_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_pwrite
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|useracc
argument_list|(
name|to_user_ptr
argument_list|(
name|args
operator|->
name|data_ptr
argument_list|)
argument_list|,
name|args
operator|->
name|size
argument_list|,
name|VM_PROT_READ
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
name|ret
operator|=
name|fault_in_multipages_readable
argument_list|(
name|to_user_ptr
argument_list|(
name|args
operator|->
name|data_ptr
argument_list|)
argument_list|,
name|args
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|-
name|EFAULT
return|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* Bounds check destination. */
if|if
condition|(
name|args
operator|->
name|offset
operator|>
name|obj
operator|->
name|base
operator|.
name|size
operator|||
name|args
operator|->
name|size
operator|>
name|obj
operator|->
name|base
operator|.
name|size
operator|-
name|args
operator|->
name|offset
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|FREEBSD_WIP
comment|/* prime objects have no backing filp to GEM pread/pwrite 	 * pages from. 	 */
if|if
condition|(
operator|!
name|obj
operator|->
name|base
operator|.
name|filp
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"pwrite %p %jx %jx"
argument_list|,
name|obj
argument_list|,
name|args
operator|->
name|offset
argument_list|,
name|args
operator|->
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
comment|/* We can only do the GTT pwrite on untiled buffers, as otherwise 	 * it would end up going through the fenced access, and we'll get 	 * different detiling behavior between reading and writing. 	 * pread/pwrite currently are reading and writing from the CPU 	 * perspective, requiring manual detiling by the client. 	 */
if|if
condition|(
name|obj
operator|->
name|phys_obj
condition|)
block|{
name|ret
operator|=
name|i915_gem_phys_pwrite
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|args
argument_list|,
name|file
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|cache_level
operator|==
name|I915_CACHE_NONE
operator|&&
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_NONE
operator|&&
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|!=
name|I915_GEM_DOMAIN_CPU
condition|)
block|{
name|ret
operator|=
name|i915_gem_gtt_pwrite_fast
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|args
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Note that the gtt paths might fail with non-page-backed user 		 * pointers (e.g. gtt mappings when moving data between 		 * textures). Fallback to the shmem path in that case. */
block|}
if|if
condition|(
name|ret
operator|==
operator|-
name|EFAULT
operator|||
name|ret
operator|==
operator|-
name|ENOSPC
condition|)
name|ret
operator|=
name|i915_gem_shmem_pwrite
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|args
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|out
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_check_wedge
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|bool
name|interruptible
parameter_list|)
block|{
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
condition|)
block|{
name|struct
name|completion
modifier|*
name|x
init|=
operator|&
name|dev_priv
operator|->
name|error_completion
decl_stmt|;
name|bool
name|recovery_complete
decl_stmt|;
comment|/* Give the error handler a chance to run. */
name|mtx_lock
argument_list|(
operator|&
name|x
operator|->
name|lock
argument_list|)
expr_stmt|;
name|recovery_complete
operator|=
name|x
operator|->
name|done
operator|>
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|x
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Non-interruptible callers can't handle -EAGAIN, hence return 		 * -EIO unconditionally for these. */
if|if
condition|(
operator|!
name|interruptible
condition|)
return|return
operator|-
name|EIO
return|;
comment|/* Recovery complete, but still wedged means reset failure. */
if|if
condition|(
name|recovery_complete
condition|)
return|return
operator|-
name|EIO
return|;
return|return
operator|-
name|EAGAIN
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Compare seqno against outstanding lazy request. Emit a request if they are  * equal.  */
end_comment

begin_function
specifier|static
name|int
name|i915_gem_check_olr
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|u32
name|seqno
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|DRM_LOCK_ASSERT
argument_list|(
name|ring
operator|->
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|seqno
operator|==
name|ring
operator|->
name|outstanding_lazy_request
condition|)
name|ret
operator|=
name|i915_add_request
argument_list|(
name|ring
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * __wait_seqno - wait until execution of seqno has finished  * @ring: the ring expected to report seqno  * @seqno: duh!  * @interruptible: do an interruptible wait (normally yes)  * @timeout: in - how long to wait (NULL forever); out - how much time remaining  *  * Returns 0 if the seqno was found within the alloted time. Else returns the  * errno with remaining time filled in timeout argument.  */
end_comment

begin_function
specifier|static
name|int
name|__wait_seqno
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|u32
name|seqno
parameter_list|,
name|bool
name|interruptible
parameter_list|,
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|ring
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|timespec
name|before
decl_stmt|,
name|now
decl_stmt|,
name|wait_time
init|=
block|{
literal|1
block|,
literal|0
block|}
decl_stmt|;
name|sbintime_t
name|timeout_sbt
decl_stmt|;
name|long
name|end
decl_stmt|;
name|bool
name|wait_forever
init|=
name|true
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|flags
decl_stmt|;
if|if
condition|(
name|i915_seqno_passed
argument_list|(
name|ring
operator|->
name|get_seqno
argument_list|(
name|ring
argument_list|,
name|true
argument_list|)
argument_list|,
name|seqno
argument_list|)
condition|)
return|return
literal|0
return|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"request_wait_begin %s %d"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|!=
name|NULL
condition|)
block|{
name|wait_time
operator|=
operator|*
name|timeout
expr_stmt|;
name|wait_forever
operator|=
name|false
expr_stmt|;
block|}
name|timeout_sbt
operator|=
name|tstosbt
argument_list|(
name|wait_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|WARN_ON
argument_list|(
operator|!
name|ring
operator|->
name|irq_get
argument_list|(
name|ring
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
comment|/* Record current time in case interrupted by signal, or wedged * */
name|getrawmonotonic
argument_list|(
operator|&
name|before
argument_list|)
expr_stmt|;
define|#
directive|define
name|EXIT_COND
define|\
value|(i915_seqno_passed(ring->get_seqno(ring, false), seqno) || \ 	atomic_read(&dev_priv->mm.wedged))
name|flags
operator|=
name|interruptible
condition|?
name|PCATCH
else|:
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|EXIT_COND
condition|)
block|{
name|end
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|-
name|msleep_sbt
argument_list|(
operator|&
name|ring
operator|->
name|irq_queue
argument_list|,
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|,
name|flags
argument_list|,
literal|"915gwr"
argument_list|,
name|timeout_sbt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * NOTE Linux<->FreeBSD: Convert msleep_sbt() return 			 * value to something close to wait_event*_timeout() 			 * functions used on Linux. 			 * 			 *>0 -> condition is true (end = time remaining) 			 * =0 -> sleep timed out 			 *<0 -> error (interrupted) 			 * 			 * We fake the remaining time by returning 1. We 			 * compute a proper value later. 			 */
if|if
condition|(
name|EXIT_COND
condition|)
comment|/* We fake a remaining time of 1 tick. */
name|end
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
name|EINTR
operator|||
name|ret
operator|==
operator|-
name|ERESTART
condition|)
comment|/* Interrupted. */
name|end
operator|=
operator|-
name|ERESTARTSYS
expr_stmt|;
else|else
comment|/* Timeout. */
name|end
operator|=
literal|0
expr_stmt|;
block|}
name|ret
operator|=
name|i915_gem_check_wedge
argument_list|(
name|dev_priv
argument_list|,
name|interruptible
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|end
operator|=
name|ret
expr_stmt|;
block|}
do|while
condition|(
name|end
operator|==
literal|0
operator|&&
name|wait_forever
condition|)
do|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|getrawmonotonic
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|ring
operator|->
name|irq_put
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"request_wait_end %s %d %d"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|seqno
argument_list|,
name|end
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|EXIT_COND
if|if
condition|(
name|timeout
condition|)
block|{
name|timespecsub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|before
argument_list|)
expr_stmt|;
name|timespecsub
argument_list|(
name|timeout
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|end
condition|)
block|{
case|case
operator|-
name|EIO
case|:
case|case
operator|-
name|EAGAIN
case|:
comment|/* Wedged */
case|case
operator|-
name|ERESTARTSYS
case|:
comment|/* Signal */
case|case
operator|-
name|ETIMEDOUT
case|:
comment|/* Timeout */
return|return
operator|(
name|int
operator|)
name|end
return|;
case|case
literal|0
case|:
comment|/* Timeout */
return|return
operator|-
name|ETIMEDOUT
return|;
default|default:
comment|/* Completed */
name|WARN_ON
argument_list|(
name|end
operator|<
literal|0
argument_list|)
expr_stmt|;
comment|/* We're not aware of other errors */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Waits for a sequence number to be signaled, and cleans up the  * request and object lists appropriately for that event.  */
end_comment

begin_function
name|int
name|i915_wait_seqno
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|uint32_t
name|seqno
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|ring
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|bool
name|interruptible
init|=
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_LOCK_ASSERT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|seqno
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_check_wedge
argument_list|(
name|dev_priv
argument_list|,
name|interruptible
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|i915_gem_check_olr
argument_list|(
name|ring
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
return|return
name|__wait_seqno
argument_list|(
name|ring
argument_list|,
name|seqno
argument_list|,
name|interruptible
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Ensures that all rendering to the object has completed and the object is  * safe to unbind from the GTT or access from the CPU.  */
end_comment

begin_function
specifier|static
name|__must_check
name|int
name|i915_gem_object_wait_rendering
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|bool
name|readonly
parameter_list|)
block|{
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
name|obj
operator|->
name|ring
decl_stmt|;
name|u32
name|seqno
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|seqno
operator|=
name|readonly
condition|?
name|obj
operator|->
name|last_write_seqno
else|:
name|obj
operator|->
name|last_read_seqno
expr_stmt|;
if|if
condition|(
name|seqno
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|i915_wait_seqno
argument_list|(
name|ring
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_retire_requests_ring
argument_list|(
name|ring
argument_list|)
expr_stmt|;
comment|/* Manually manage the write flush as we may have not yet 	 * retired the buffer. 	 */
if|if
condition|(
name|obj
operator|->
name|last_write_seqno
operator|&&
name|i915_seqno_passed
argument_list|(
name|seqno
argument_list|,
name|obj
operator|->
name|last_write_seqno
argument_list|)
condition|)
block|{
name|obj
operator|->
name|last_write_seqno
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&=
operator|~
name|I915_GEM_GPU_DOMAINS
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A nonblocking variant of the above wait. This is a highly dangerous routine  * as the object state may change during this call.  */
end_comment

begin_function
specifier|static
name|__must_check
name|int
name|i915_gem_object_wait_rendering__nonblocking
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|bool
name|readonly
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
name|obj
operator|->
name|ring
decl_stmt|;
name|u32
name|seqno
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_LOCK_ASSERT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
argument_list|)
expr_stmt|;
name|seqno
operator|=
name|readonly
condition|?
name|obj
operator|->
name|last_write_seqno
else|:
name|obj
operator|->
name|last_read_seqno
expr_stmt|;
if|if
condition|(
name|seqno
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|i915_gem_check_wedge
argument_list|(
name|dev_priv
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|i915_gem_check_olr
argument_list|(
name|ring
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__wait_seqno
argument_list|(
name|ring
argument_list|,
name|seqno
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_retire_requests_ring
argument_list|(
name|ring
argument_list|)
expr_stmt|;
comment|/* Manually manage the write flush as we may have not yet 	 * retired the buffer. 	 */
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|obj
operator|->
name|last_write_seqno
operator|&&
name|i915_seqno_passed
argument_list|(
name|seqno
argument_list|,
name|obj
operator|->
name|last_write_seqno
argument_list|)
condition|)
block|{
name|obj
operator|->
name|last_write_seqno
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&=
operator|~
name|I915_GEM_GPU_DOMAINS
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Called when user space prepares to use an object with the CPU, either  * through the mmap ioctl's mapping or a GTT mapping.  */
end_comment

begin_function
name|int
name|i915_gem_set_domain_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_set_domain
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|uint32_t
name|read_domains
init|=
name|args
operator|->
name|read_domains
decl_stmt|;
name|uint32_t
name|write_domain
init|=
name|args
operator|->
name|write_domain
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Only handle setting domains to types used by the CPU. */
if|if
condition|(
name|write_domain
operator|&
name|I915_GEM_GPU_DOMAINS
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|read_domains
operator|&
name|I915_GEM_GPU_DOMAINS
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* Having something in the write domain implies it's in the read 	 * domain, and only that read domain.  Enforce that in the request. 	 */
if|if
condition|(
name|write_domain
operator|!=
literal|0
operator|&&
name|read_domains
operator|!=
name|write_domain
condition|)
return|return
operator|-
name|EINVAL
return|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* Try to flush the object off the GPU without holding the lock. 	 * We will repeat the flush holding the lock in the normal manner 	 * to catch cases where we are gazumped. 	 */
name|ret
operator|=
name|i915_gem_object_wait_rendering__nonblocking
argument_list|(
name|obj
argument_list|,
operator|!
name|write_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|unref
goto|;
if|if
condition|(
name|read_domains
operator|&
name|I915_GEM_DOMAIN_GTT
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|obj
argument_list|,
name|write_domain
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Silently promote "you're not bound, there was nothing to do" 		 * to success, since the client was just asking us to 		 * make sure everything was done. 		 */
if|if
condition|(
name|ret
operator|==
operator|-
name|EINVAL
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|i915_gem_object_set_to_cpu_domain
argument_list|(
name|obj
argument_list|,
name|write_domain
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|unref
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Called when user space has done writes to this buffer  */
end_comment

begin_function
name|int
name|i915_gem_sw_finish_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_sw_finish
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* Pinned buffers may be scanout, so flush the cache */
if|if
condition|(
name|obj
operator|->
name|pin_count
condition|)
name|i915_gem_object_flush_cpu_write_domain
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Maps the contents of an object, returning the address it is mapped  * into.  *  * While the mapping holds a reference on the contents of the object, it doesn't  * imply a ref on the object itself.  */
end_comment

begin_function
name|int
name|i915_gem_mmap_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_mmap
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rv
decl_stmt|;
name|obj
operator|=
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOENT
return|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
comment|/* prime objects have no backing filp to GEM mmap 	 * pages from. 	 */
if|if
condition|(
operator|!
name|obj
operator|->
name|filp
condition|)
block|{
name|drm_gem_object_unreference_unlocked
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|size
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|p
operator|=
name|curproc
expr_stmt|;
name|map
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|args
operator|->
name|size
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|size
operator|+
name|size
operator|>
name|lim_cur_proc
argument_list|(
name|p
argument_list|,
name|RLIMIT_VMEM
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
name|vm_object_reference
argument_list|(
name|obj
operator|->
name|vm_obj
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_find
argument_list|(
name|map
argument_list|,
name|obj
operator|->
name|vm_obj
argument_list|,
name|args
operator|->
name|offset
argument_list|,
operator|&
name|addr
argument_list|,
name|args
operator|->
name|size
argument_list|,
literal|0
argument_list|,
name|VMFS_OPTIMAL_SPACE
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|MAP_INHERIT_SHARE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|obj
operator|->
name|vm_obj
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
name|vm_mmap_to_errno
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|args
operator|->
name|addr_ptr
operator|=
operator|(
name|uint64_t
operator|)
name|addr
expr_stmt|;
block|}
name|out
label|:
name|drm_gem_object_unreference_unlocked
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_pager_ctor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_ooffset_t
name|foff
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|u_short
modifier|*
name|color
parameter_list|)
block|{
comment|/* 	 * NOTE Linux<->FreeBSD: drm_gem_mmap_single() takes care of 	 * calling drm_gem_object_reference(). That's why we don't 	 * do this here. i915_gem_pager_dtor(), below, will call 	 * drm_gem_object_unreference(). 	 * 	 * On Linux, drm_gem_vm_open() references the object because 	 * it's called the mapping is copied. drm_gem_vm_open() is not 	 * called when the mapping is created. So the possible sequences 	 * are: 	 *     1. drm_gem_mmap():     ref++ 	 *     2. drm_gem_vm_close(): ref-- 	 * 	 *     1. drm_gem_mmap():     ref++ 	 *     2. drm_gem_vm_open():  ref++ (for the copied vma) 	 *     3. drm_gem_vm_close(): ref-- (for the copied vma) 	 *     4. drm_gem_vm_close(): ref-- (for the initial vma) 	 * 	 * On FreeBSD, i915_gem_pager_ctor() is called once during the 	 * creation of the mapping. No callback is called when the 	 * mapping is shared during a fork(). i915_gem_pager_dtor() is 	 * called when the last reference to the mapping is dropped. So 	 * the only sequence is: 	 *     1. drm_gem_mmap_single(): ref++ 	 *     2. i915_gem_pager_ctor():<noop> 	 *     3. i915_gem_pager_dtor(): ref-- 	 */
operator|*
name|color
operator|=
literal|0
expr_stmt|;
comment|/* XXXKIB */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * i915_gem_fault - fault a page into the GTT  * vma: VMA in question  * vmf: fault info  *  * The fault handler is set up by drm_gem_mmap() when a object is GTT mapped  * from userspace.  The fault handler takes care of binding the object to  * the GTT (if needed), allocating and programming a fence register (again,  * only if needed based on whether the old reg is still valid or the object  * is tiled) and inserting a new PTE into the faulting process.  *  * Note that the faulting process may involve evicting existing objects  * from the GTT and/or fence registers to make room.  So performance may  * suffer if the GTT working set is large or there are few fence registers  * left.  */
end_comment

begin_decl_stmt
name|int
name|i915_intr_pf
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i915_gem_pager_populate
parameter_list|(
name|vm_object_t
name|vm_obj
parameter_list|,
name|vm_pindex_t
name|pidx
parameter_list|,
name|int
name|fault_type
parameter_list|,
name|vm_prot_t
name|max_prot
parameter_list|,
name|vm_pindex_t
modifier|*
name|first
parameter_list|,
name|vm_pindex_t
modifier|*
name|last
parameter_list|)
block|{
name|struct
name|drm_gem_object
modifier|*
name|gem_obj
init|=
name|vm_obj
operator|->
name|handle
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|to_intel_bo
argument_list|(
name|gem_obj
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|vm_page_t
name|page
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|bool
name|write
init|=
operator|(
name|max_prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
decl_stmt|;
name|bool
name|pinned
decl_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|retry
label|:
name|ret
operator|=
literal|0
expr_stmt|;
name|pinned
operator|=
literal|0
expr_stmt|;
name|page
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i915_intr_pf
condition|)
block|{
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Since the object lock was dropped, other thread might have 	 * faulted on the same GTT address and instantiated the 	 * mapping for the page.  Recheck. 	 */
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|page
operator|=
name|vm_page_lookup
argument_list|(
name|vm_obj
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vm_page_busied
argument_list|(
name|page
argument_list|)
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|vm_page_busy_sleep
argument_list|(
name|page
argument_list|,
literal|"915pee"
argument_list|,
name|false
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
goto|goto
name|have_page
goto|;
block|}
else|else
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
comment|/* Now bind it into the GTT if needed */
name|ret
operator|=
name|i915_gem_object_pin
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|unlock
goto|;
name|pinned
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|obj
argument_list|,
name|write
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|unpin
goto|;
name|ret
operator|=
name|i915_gem_object_get_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|unpin
goto|;
name|obj
operator|->
name|fault_mappable
operator|=
name|true
expr_stmt|;
name|page
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
operator|+
name|obj
operator|->
name|gtt_offset
operator|+
name|IDX_TO_OFF
argument_list|(
name|pidx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|unpin
goto|;
block|}
name|KASSERT
argument_list|(
operator|(
name|page
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"physical address %#jx not fictitious, page %p"
operator|,
call|(
name|uintmax_t
call|)
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_base_addr
operator|+
name|obj
operator|->
name|gtt_offset
operator|+
name|IDX_TO_OFF
argument_list|(
name|pidx
argument_list|)
argument_list|)
operator|,
name|page
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|page
operator|->
name|wire_count
operator|==
literal|1
argument_list|,
operator|(
literal|"wire_count not 1 %p"
operator|,
name|page
operator|)
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_page_busied
argument_list|(
name|page
argument_list|)
condition|)
block|{
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|vm_page_busy_sleep
argument_list|(
name|page
argument_list|,
literal|"915pbs"
argument_list|,
name|false
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|vm_page_insert
argument_list|(
name|page
argument_list|,
name|vm_obj
argument_list|,
name|pidx
argument_list|)
condition|)
block|{
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|VM_WAIT
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|page
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|have_page
label|:
name|vm_page_xbusy
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_DRM
argument_list|,
literal|"fault %p %jx %x phys %x"
argument_list|,
name|gem_obj
argument_list|,
name|pidx
argument_list|,
name|fault_type
argument_list|,
name|page
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinned
condition|)
block|{
comment|/* 		 * We may have not pinned the object if the page was 		 * found by the call to vm_page_lookup(). 		 */
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
operator|*
name|first
operator|=
operator|*
name|last
operator|=
name|pidx
expr_stmt|;
return|return
operator|(
name|VM_PAGER_OK
operator|)
return|;
name|unpin
label|:
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|out
label|:
name|KASSERT
argument_list|(
name|ret
operator|!=
literal|0
argument_list|,
operator|(
literal|"i915_gem_pager_fault: wrong return"
operator|)
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_DRM
argument_list|,
literal|"fault_fail %p %jx %x err %d"
argument_list|,
name|gem_obj
argument_list|,
name|pidx
argument_list|,
name|fault_type
argument_list|,
operator|-
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|ERESTARTSYS
condition|)
block|{
comment|/* 		 * NOTE Linux<->FreeBSD: Convert Linux' -ERESTARTSYS to 		 * the more common -EINTR, so the page fault is retried. 		 */
name|ret
operator|=
operator|-
name|EINTR
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
operator|-
name|EAGAIN
operator|||
name|ret
operator|==
operator|-
name|EIO
operator|||
name|ret
operator|==
operator|-
name|EINTR
condition|)
block|{
name|kern_yield
argument_list|(
name|PRI_USER
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|VM_PAGER_ERROR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_pager_dtor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|drm_gem_object
modifier|*
name|obj
init|=
name|handle
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|dev
decl_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|cdev_pager_ops
name|i915_gem_pager_ops
init|=
block|{
operator|.
name|cdev_pg_populate
operator|=
name|i915_gem_pager_populate
block|,
operator|.
name|cdev_pg_ctor
operator|=
name|i915_gem_pager_ctor
block|,
operator|.
name|cdev_pg_dtor
operator|=
name|i915_gem_pager_dtor
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * i915_gem_release_mmap - remove physical page mappings  * @obj: obj in question  *  * Preserve the reservation of the mmapping with the DRM core code, but  * relinquish ownership of the pages back to the system.  *  * It is vital that we remove the page mapping if we have mapped a tiled  * object through the GTT and then lose the fence register due to  * resource pressure. Similarly if the object has been moved out of the  * aperture, than pages mapped into userspace must be revoked. Removing the  * mapping will then trigger a page fault on the next user access, allowing  * fixup by i915_gem_fault().  */
end_comment

begin_function
name|void
name|i915_gem_release_mmap
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|vm_object_t
name|devobj
decl_stmt|;
name|vm_page_t
name|page
decl_stmt|;
name|int
name|i
decl_stmt|,
name|page_count
decl_stmt|;
if|if
condition|(
operator|!
name|obj
operator|->
name|fault_mappable
condition|)
return|return;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"release_mmap %p %x %x"
argument_list|,
name|obj
argument_list|,
name|obj
operator|->
name|gtt_offset
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|devobj
operator|=
name|cdev_pager_lookup
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|devobj
operator|!=
name|NULL
condition|)
block|{
name|page_count
operator|=
name|OFF_TO_IDX
argument_list|(
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|devobj
argument_list|)
expr_stmt|;
name|retry
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_count
condition|;
name|i
operator|++
control|)
block|{
name|page
operator|=
name|vm_page_lookup
argument_list|(
name|devobj
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|vm_page_sleep_if_busy
argument_list|(
name|page
argument_list|,
literal|"915unm"
argument_list|)
condition|)
goto|goto
name|retry
goto|;
name|cdev_pager_free_page
argument_list|(
name|devobj
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|devobj
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|devobj
argument_list|)
expr_stmt|;
block|}
name|obj
operator|->
name|fault_mappable
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|i915_gem_get_gtt_size
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|int
name|tiling_mode
parameter_list|)
block|{
name|uint32_t
name|gtt_size
decl_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
operator|||
name|tiling_mode
operator|==
name|I915_TILING_NONE
condition|)
return|return
name|size
return|;
comment|/* Previous chips need a power-of-two fence region when tiling */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|==
literal|3
condition|)
name|gtt_size
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
else|else
name|gtt_size
operator|=
literal|512
operator|*
literal|1024
expr_stmt|;
while|while
condition|(
name|gtt_size
operator|<
name|size
condition|)
name|gtt_size
operator|<<=
literal|1
expr_stmt|;
return|return
name|gtt_size
return|;
block|}
end_function

begin_comment
comment|/**  * i915_gem_get_gtt_alignment - return required GTT alignment for an object  * @obj: object to check  *  * Return the required GTT alignment for an object, taking into account  * potential fence register mapping.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|i915_gem_get_gtt_alignment
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|int
name|tiling_mode
parameter_list|)
block|{
comment|/* 	 * Minimum alignment is 4k (GTT page size), but might be greater 	 * if a fence register is needed for the object. 	 */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
operator|||
name|tiling_mode
operator|==
name|I915_TILING_NONE
condition|)
return|return
literal|4096
return|;
comment|/* 	 * Previous chips need to be aligned to the size of the smallest 	 * fence register that can contain the object. 	 */
return|return
name|i915_gem_get_gtt_size
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|tiling_mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * i915_gem_get_unfenced_gtt_alignment - return required GTT alignment for an  *					 unfenced object  * @dev: the device  * @size: size of the object  * @tiling_mode: tiling mode of the object  *  * Return the required GTT alignment for an object, only taking into account  * unfenced tiled surface requirements.  */
end_comment

begin_function
name|uint32_t
name|i915_gem_get_unfenced_gtt_alignment
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|int
name|tiling_mode
parameter_list|)
block|{
comment|/* 	 * Minimum alignment is 4k (GTT page size) for sane hw. 	 */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
operator|||
name|IS_G33
argument_list|(
name|dev
argument_list|)
operator|||
name|tiling_mode
operator|==
name|I915_TILING_NONE
condition|)
return|return
literal|4096
return|;
comment|/* Previous hardware however needs to be aligned to a power-of-two 	 * tile height. The simplest method for determining this is to reuse 	 * the power-of-tile object size. 	 */
return|return
name|i915_gem_get_gtt_size
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|tiling_mode
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_object_create_mmap_offset
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|on_map
condition|)
return|return
literal|0
return|;
name|dev_priv
operator|->
name|mm
operator|.
name|shrinker_no_lock_stealing
operator|=
name|true
expr_stmt|;
name|ret
operator|=
name|drm_gem_create_mmap_offset
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
name|ENOSPC
condition|)
goto|goto
name|out
goto|;
comment|/* Badly fragmented mmap space? The only way we can recover 	 * space is by destroying unwanted objects. We can't randomly release 	 * mmap_offsets as userspace expects them to be persistent for the 	 * lifetime of the objects. The closest we can is to release the 	 * offsets on purgeable objects by truncating it and marking it purged, 	 * which prevents userspace from ever using that object again. 	 */
name|i915_gem_purge
argument_list|(
name|dev_priv
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_gem_create_mmap_offset
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
name|ENOSPC
condition|)
goto|goto
name|out
goto|;
name|i915_gem_shrink_all
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_gem_create_mmap_offset
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|out
label|:
name|dev_priv
operator|->
name|mm
operator|.
name|shrinker_no_lock_stealing
operator|=
name|false
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_free_mmap_offset
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
name|obj
operator|->
name|base
operator|.
name|on_map
condition|)
return|return;
name|drm_gem_free_mmap_offset
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_mmap_gtt
parameter_list|(
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|handle
parameter_list|,
name|uint64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|size
operator|>
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mappable_end
condition|)
block|{
name|ret
operator|=
operator|-
name|E2BIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|madv
operator|!=
name|I915_MADV_WILLNEED
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Attempting to mmap a purgeable buffer\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|i915_gem_object_create_mmap_offset
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
operator|*
name|offset
operator|=
name|DRM_GEM_MAPPING_OFF
argument_list|(
name|obj
operator|->
name|base
operator|.
name|map_list
operator|.
name|key
argument_list|)
operator||
name|DRM_GEM_MAPPING_KEY
expr_stmt|;
name|out
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * i915_gem_mmap_gtt_ioctl - prepare an object for GTT mmap'ing  * @dev: DRM device  * @data: GTT mapping ioctl data  * @file: GEM object info  *  * Simply returns the fake offset to userspace so it can mmap it.  * The mmap call will end up in drm_gem_mmap(), which will set things  * up so we can get faults in the handler above.  *  * The fault handler will take care of binding the object into the GTT  * (since it may have been evicted to make room for something), allocating  * a fence register, and mapping the appropriate aperture address into  * userspace.  */
end_comment

begin_function
name|int
name|i915_gem_mmap_gtt_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_mmap_gtt
modifier|*
name|args
init|=
name|data
decl_stmt|;
return|return
name|i915_gem_mmap_gtt
argument_list|(
name|file
argument_list|,
name|dev
argument_list|,
name|args
operator|->
name|handle
argument_list|,
operator|&
name|args
operator|->
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Immediately discard the backing storage */
end_comment

begin_function
specifier|static
name|void
name|i915_gem_object_truncate
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|vm_object_t
name|vm_obj
decl_stmt|;
name|vm_obj
operator|=
name|obj
operator|->
name|base
operator|.
name|vm_obj
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|vm_object_page_remove
argument_list|(
name|vm_obj
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|i915_gem_object_free_mmap_offset
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|madv
operator|=
name|__I915_MADV_PURGED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|i915_gem_object_is_purgeable
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
return|return
name|obj
operator|->
name|madv
operator|==
name|I915_MADV_DONTNEED
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_put_pages_range_locked
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|vm_pindex_t
name|si
parameter_list|,
name|vm_pindex_t
name|ei
parameter_list|)
block|{
name|vm_object_t
name|vm_obj
decl_stmt|;
name|vm_page_t
name|page
decl_stmt|;
name|vm_pindex_t
name|i
decl_stmt|;
name|vm_obj
operator|=
name|obj
operator|->
name|base
operator|.
name|vm_obj
expr_stmt|;
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|si
operator|,
name|page
operator|=
name|vm_page_lookup
argument_list|(
name|vm_obj
argument_list|,
name|i
argument_list|)
init|;
name|i
operator|<
name|ei
condition|;
name|page
operator|=
name|vm_page_next
argument_list|(
name|page
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|page
operator|->
name|pindex
operator|==
name|i
argument_list|,
operator|(
literal|"pindex %jx %jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|page
operator|->
name|pindex
operator|,
operator|(
name|uintmax_t
operator|)
name|i
operator|)
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|page
argument_list|,
name|PQ_INACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|->
name|wire_count
operator|==
literal|0
condition|)
name|atomic_add_long
argument_list|(
operator|&
name|i915_gem_wired_pages_cnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|GEM_PARANOID_CHECK_GTT
value|0
end_define

begin_if
if|#
directive|if
name|GEM_PARANOID_CHECK_GTT
end_if

begin_function
specifier|static
name|void
name|i915_gem_assert_pages_not_mapped
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|int
name|page_count
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|unsigned
name|long
name|start
decl_stmt|,
name|end
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|start
operator|=
name|OFF_TO_IDX
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_start
argument_list|)
expr_stmt|;
name|end
operator|=
name|OFF_TO_IDX
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_end
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
name|intel_gtt_read_pte_paddr
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|page_count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pa
operator|==
name|VM_PAGE_TO_PHYS
argument_list|(
name|ma
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Page %p in GTT pte index %d pte %x"
argument_list|,
name|ma
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|intel_gtt_read_pte
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|i915_gem_object_put_pages_gtt
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|int
name|page_count
init|=
name|obj
operator|->
name|base
operator|.
name|size
operator|/
name|PAGE_SIZE
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|BUG_ON
argument_list|(
name|obj
operator|->
name|madv
operator|==
name|__I915_MADV_PURGED
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_set_to_cpu_domain
argument_list|(
name|obj
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* In the event of a disaster, abandon all caches and 		 * hope for the best. 		 */
name|WARN_ON
argument_list|(
name|ret
operator|!=
operator|-
name|EIO
argument_list|)
expr_stmt|;
name|i915_gem_clflush_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
block|}
if|if
condition|(
name|i915_gem_object_needs_bit17_swizzle
argument_list|(
name|obj
argument_list|)
condition|)
name|i915_gem_object_save_bit_17_swizzle
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|madv
operator|==
name|I915_MADV_DONTNEED
condition|)
name|obj
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
if|#
directive|if
name|GEM_PARANOID_CHECK_GTT
name|i915_gem_assert_pages_not_mapped
argument_list|(
name|obj
operator|->
name|base
operator|.
name|dev
argument_list|,
name|obj
operator|->
name|pages
argument_list|,
name|page_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_count
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|page
init|=
name|obj
operator|->
name|pages
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|dirty
condition|)
name|vm_page_dirty
argument_list|(
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|madv
operator|==
name|I915_MADV_WILLNEED
condition|)
name|vm_page_reference
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|obj
operator|->
name|pages
index|[
name|i
index|]
argument_list|,
name|PQ_ACTIVE
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|i915_gem_wired_pages_cnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|obj
operator|->
name|pages
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pages
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_object_put_pages
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
specifier|const
name|struct
name|drm_i915_gem_object_ops
modifier|*
name|ops
init|=
name|obj
operator|->
name|ops
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|pages
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|BUG_ON
argument_list|(
name|obj
operator|->
name|gtt_space
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|pages_pin_count
condition|)
return|return
operator|-
name|EBUSY
return|;
comment|/* ->put_pages might need to allocate memory for the bit17 swizzle 	 * array, hence protect them from being reaped by removing them from gtt 	 * lists early. */
name|list_del
argument_list|(
operator|&
name|obj
operator|->
name|gtt_list
argument_list|)
expr_stmt|;
name|ops
operator|->
name|put_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pages
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i915_gem_object_is_purgeable
argument_list|(
name|obj
argument_list|)
condition|)
name|i915_gem_object_truncate
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|__i915_gem_shrink
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|long
name|target
parameter_list|,
name|bool
name|purgeable_only
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|long
name|count
init|=
literal|0
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|obj
argument_list|,
argument|next
argument_list|,
argument|&dev_priv->mm.unbound_list
argument_list|,
argument|gtt_list
argument_list|)
block|{
if|if
condition|(
operator|(
name|i915_gem_object_is_purgeable
argument_list|(
name|obj
argument_list|)
operator|||
operator|!
name|purgeable_only
operator|)
operator|&&
name|i915_gem_object_put_pages
argument_list|(
name|obj
argument_list|)
operator|==
literal|0
condition|)
block|{
name|count
operator|+=
name|obj
operator|->
name|base
operator|.
name|size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
if|if
condition|(
name|target
operator|!=
operator|-
literal|1
operator|&&
name|count
operator|>=
name|target
condition|)
return|return
name|count
return|;
block|}
block|}
name|list_for_each_entry_safe
argument_list|(
argument|obj
argument_list|,
argument|next
argument_list|,
argument|&dev_priv->mm.inactive_list
argument_list|,
argument|mm_list
argument_list|)
block|{
if|if
condition|(
operator|(
name|i915_gem_object_is_purgeable
argument_list|(
name|obj
argument_list|)
operator|||
operator|!
name|purgeable_only
operator|)
operator|&&
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
operator|==
literal|0
operator|&&
name|i915_gem_object_put_pages
argument_list|(
name|obj
argument_list|)
operator|==
literal|0
condition|)
block|{
name|count
operator|+=
name|obj
operator|->
name|base
operator|.
name|size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
if|if
condition|(
name|target
operator|!=
operator|-
literal|1
operator|&&
name|count
operator|>=
name|target
condition|)
return|return
name|count
return|;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|i915_gem_purge
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|long
name|target
parameter_list|)
block|{
return|return
name|__i915_gem_shrink
argument_list|(
name|dev_priv
argument_list|,
name|target
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_shrink_all
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|i915_gem_evict_everything
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|obj
argument_list|,
argument|next
argument_list|,
argument|&dev_priv->mm.unbound_list
argument_list|,
argument|gtt_list
argument_list|)
name|i915_gem_object_put_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_object_get_pages_range
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|off_t
name|start
parameter_list|,
name|off_t
name|end
parameter_list|)
block|{
name|vm_object_t
name|vm_obj
decl_stmt|;
name|vm_page_t
name|page
decl_stmt|;
name|vm_pindex_t
name|si
decl_stmt|,
name|ei
decl_stmt|,
name|i
decl_stmt|;
name|bool
name|need_swizzle
decl_stmt|,
name|fresh
decl_stmt|;
name|need_swizzle
operator|=
name|i915_gem_object_needs_bit17_swizzle
argument_list|(
name|obj
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|vm_obj
operator|=
name|obj
operator|->
name|base
operator|.
name|vm_obj
expr_stmt|;
name|si
operator|=
name|OFF_TO_IDX
argument_list|(
name|trunc_page
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|ei
operator|=
name|OFF_TO_IDX
argument_list|(
name|round_page
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|si
init|;
name|i
operator|<
name|ei
condition|;
name|i
operator|++
control|)
block|{
name|page
operator|=
name|i915_gem_wire_page
argument_list|(
name|vm_obj
argument_list|,
name|i
argument_list|,
operator|&
name|fresh
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|need_swizzle
operator|&&
name|fresh
condition|)
name|i915_gem_object_do_bit_17_swizzle_page
argument_list|(
name|obj
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
name|i915_gem_object_put_pages_range_locked
argument_list|(
name|obj
argument_list|,
name|si
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_object_get_pages_gtt
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|vm_object_t
name|vm_obj
decl_stmt|;
name|vm_page_t
name|page
decl_stmt|;
name|vm_pindex_t
name|i
decl_stmt|,
name|page_count
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* Assert that the object is not currently in any GPU domain. As it 	 * wasn't in the GTT, there shouldn't be any way it could have been in 	 * a GPU cache 	 */
name|BUG_ON
argument_list|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_GPU_DOMAINS
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
name|I915_GEM_GPU_DOMAINS
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|obj
operator|->
name|pages
operator|==
name|NULL
argument_list|,
operator|(
literal|"Obj already has pages"
operator|)
argument_list|)
expr_stmt|;
name|page_count
operator|=
name|OFF_TO_IDX
argument_list|(
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pages
operator|=
name|malloc
argument_list|(
name|page_count
operator|*
sizeof|sizeof
argument_list|(
name|vm_page_t
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|res
operator|=
name|i915_gem_object_get_pages_range
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|obj
operator|->
name|pages
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pages
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
name|vm_obj
operator|=
name|obj
operator|->
name|base
operator|.
name|vm_obj
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|page
operator|=
name|vm_page_lookup
argument_list|(
name|vm_obj
argument_list|,
literal|0
argument_list|)
init|;
name|i
operator|<
name|page_count
condition|;
name|i
operator|++
operator|,
name|page
operator|=
name|vm_page_next
argument_list|(
name|page
argument_list|)
control|)
block|{
name|KASSERT
argument_list|(
name|page
operator|->
name|pindex
operator|==
name|i
argument_list|,
operator|(
literal|"pindex %jx %jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|page
operator|->
name|pindex
operator|,
operator|(
name|uintmax_t
operator|)
name|i
operator|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pages
index|[
name|i
index|]
operator|=
name|page
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Ensure that the associated pages are gathered from the backing storage  * and pinned into our object. i915_gem_object_get_pages() may be called  * multiple times before they are released by a single call to  * i915_gem_object_put_pages() - once the pages are no longer referenced  * either as a result of memory pressure (reaping pages under the shrinker)  * or as the object is itself released.  */
end_comment

begin_function
name|int
name|i915_gem_object_get_pages
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
specifier|const
name|struct
name|drm_i915_gem_object_ops
modifier|*
name|ops
init|=
name|obj
operator|->
name|ops
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|pages
condition|)
return|return
literal|0
return|;
name|BUG_ON
argument_list|(
name|obj
operator|->
name|pages_pin_count
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ops
operator|->
name|get_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|list_add_tail
argument_list|(
operator|&
name|obj
operator|->
name|gtt_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|unbound_list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_object_move_to_active
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|seqno
init|=
name|intel_ring_get_seqno
argument_list|(
name|ring
argument_list|)
decl_stmt|;
name|BUG_ON
argument_list|(
name|ring
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|obj
operator|->
name|ring
operator|=
name|ring
expr_stmt|;
comment|/* Add a reference if we're newly entering the active list. */
if|if
condition|(
operator|!
name|obj
operator|->
name|active
condition|)
block|{
name|drm_gem_object_reference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|obj
operator|->
name|active
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Move from whatever list we were on to the tail of execution. */
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|mm_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|active_list
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|ring_list
argument_list|,
operator|&
name|ring
operator|->
name|active_list
argument_list|)
expr_stmt|;
name|obj
operator|->
name|last_read_seqno
operator|=
name|seqno
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|fenced_gpu_access
condition|)
block|{
name|obj
operator|->
name|last_fenced_seqno
operator|=
name|seqno
expr_stmt|;
comment|/* Bump MRU to take account of the delayed flush */
if|if
condition|(
name|obj
operator|->
name|fence_reg
operator|!=
name|I915_FENCE_REG_NONE
condition|)
block|{
name|struct
name|drm_i915_fence_reg
modifier|*
name|reg
decl_stmt|;
name|reg
operator|=
operator|&
name|dev_priv
operator|->
name|fence_regs
index|[
name|obj
operator|->
name|fence_reg
index|]
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|reg
operator|->
name|lru_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|fence_list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_move_to_inactive
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|BUG_ON
argument_list|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
operator|~
name|I915_GEM_GPU_DOMAINS
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|obj
operator|->
name|active
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|mm_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|inactive_list
argument_list|)
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|obj
operator|->
name|ring_list
argument_list|)
expr_stmt|;
name|obj
operator|->
name|ring
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|last_read_seqno
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|last_write_seqno
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|last_fenced_seqno
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|fenced_gpu_access
operator|=
name|false
expr_stmt|;
name|obj
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
name|i915_verify_lists
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_handle_seqno_wrap
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* The hardware uses various monotonic 32-bit counters, if we 	 * detect that they will wraparound we need to idle the GPU 	 * and reset those counters. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|ring
operator|->
name|sync_seqno
argument_list|)
condition|;
name|j
operator|++
control|)
name|ret
operator||=
name|ring
operator|->
name|sync_seqno
index|[
name|j
index|]
operator|!=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|i915_gpu_idle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_retire_requests
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|ring
operator|->
name|sync_seqno
argument_list|)
condition|;
name|j
operator|++
control|)
name|ring
operator|->
name|sync_seqno
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_get_seqno
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|u32
modifier|*
name|seqno
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* reserve 0 for non-seqno */
if|if
condition|(
name|dev_priv
operator|->
name|next_seqno
operator|==
literal|0
condition|)
block|{
name|int
name|ret
init|=
name|i915_gem_handle_seqno_wrap
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|dev_priv
operator|->
name|next_seqno
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|seqno
operator|=
name|dev_priv
operator|->
name|next_seqno
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_add_request
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|u32
modifier|*
name|out_seqno
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|ring
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|u32
name|request_ring_position
decl_stmt|;
name|int
name|was_empty
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * Emit any outstanding flushes - execbuf can fail to emit the flush 	 * after having emitted the batchbuffer command. Hence we need to fix 	 * things up similar to emitting the lazy request. The difference here 	 * is that the flush _must_ happen before the next request, no matter 	 * what. 	 */
name|ret
operator|=
name|intel_ring_flush_all_caches
argument_list|(
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|request
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
comment|/* Record the position of the start of the request so that 	 * should we detect the updated seqno part-way through the 	 * GPU processing the request, we never over-estimate the 	 * position of the head. 	 */
name|request_ring_position
operator|=
name|intel_ring_get_tail
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ring
operator|->
name|add_request
argument_list|(
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|request
operator|->
name|seqno
operator|=
name|intel_ring_get_seqno
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|request
operator|->
name|ring
operator|=
name|ring
expr_stmt|;
name|request
operator|->
name|tail
operator|=
name|request_ring_position
expr_stmt|;
name|request
operator|->
name|emitted_jiffies
operator|=
name|jiffies
expr_stmt|;
name|was_empty
operator|=
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|request
operator|->
name|list
argument_list|,
operator|&
name|ring
operator|->
name|request_list
argument_list|)
expr_stmt|;
name|request
operator|->
name|file_priv
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|struct
name|drm_i915_file_private
modifier|*
name|file_priv
init|=
name|file
operator|->
name|driver_priv
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lock
argument_list|)
expr_stmt|;
name|request
operator|->
name|file_priv
operator|=
name|file_priv
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|request
operator|->
name|client_list
argument_list|,
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|request_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"request_add %s %d"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|request
operator|->
name|seqno
argument_list|)
expr_stmt|;
name|ring
operator|->
name|outstanding_lazy_request
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
condition|)
block|{
if|if
condition|(
name|i915_enable_hangcheck
condition|)
block|{
name|callout_schedule
argument_list|(
operator|&
name|dev_priv
operator|->
name|hangcheck_timer
argument_list|,
name|DRM_I915_HANGCHECK_PERIOD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|was_empty
condition|)
block|{
name|taskqueue_enqueue_timeout
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|retire_work
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|intel_mark_busy
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out_seqno
condition|)
operator|*
name|out_seqno
operator|=
name|request
operator|->
name|seqno
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|i915_gem_request_remove_from_client
parameter_list|(
name|struct
name|drm_i915_gem_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|drm_i915_file_private
modifier|*
name|file_priv
init|=
name|request
operator|->
name|file_priv
decl_stmt|;
if|if
condition|(
operator|!
name|file_priv
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|file_priv
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|request
operator|->
name|client_list
argument_list|)
expr_stmt|;
name|request
operator|->
name|file_priv
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_reset_ring_lists
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
if|if
condition|(
name|ring
operator|->
name|dev
operator|!=
name|NULL
condition|)
name|DRM_LOCK_ASSERT
argument_list|(
name|ring
operator|->
name|dev
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|request
operator|=
name|list_first_entry
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|,
expr|struct
name|drm_i915_gem_request
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|request
operator|->
name|list
argument_list|)
expr_stmt|;
name|i915_gem_request_remove_from_client
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|active_list
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|list_first_entry
argument_list|(
operator|&
name|ring
operator|->
name|active_list
argument_list|,
expr|struct
name|drm_i915_gem_object
argument_list|,
name|ring_list
argument_list|)
expr_stmt|;
name|i915_gem_object_move_to_inactive
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_reset_fences
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|num_fence_regs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_i915_fence_reg
modifier|*
name|reg
init|=
operator|&
name|dev_priv
operator|->
name|fence_regs
index|[
name|i
index|]
decl_stmt|;
name|i915_gem_write_fence
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|->
name|obj
condition|)
name|i915_gem_object_fence_lost
argument_list|(
name|reg
operator|->
name|obj
argument_list|)
expr_stmt|;
name|reg
operator|->
name|pin_count
operator|=
literal|0
expr_stmt|;
name|reg
operator|->
name|obj
operator|=
name|NULL
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|reg
operator|->
name|lru_list
argument_list|)
expr_stmt|;
block|}
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|fence_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_reset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
name|i915_gem_reset_ring_lists
argument_list|(
name|dev_priv
argument_list|,
name|ring
argument_list|)
expr_stmt|;
comment|/* Move everything out of the GPU domains to ensure we do any 	 * necessary invalidation upon reuse. 	 */
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|&dev_priv->mm.inactive_list
argument_list|,
argument|mm_list
argument_list|)
block|{
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&=
operator|~
name|I915_GEM_GPU_DOMAINS
expr_stmt|;
block|}
comment|/* The fence registers are invalidated so clear them out */
name|i915_gem_reset_fences
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This function clears the request list as sequence numbers are passed.  */
end_comment

begin_function
name|void
name|i915_gem_retire_requests_ring
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|uint32_t
name|seqno
decl_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
condition|)
return|return;
name|WARN_ON
argument_list|(
name|i915_verify_lists
argument_list|(
name|ring
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|seqno
operator|=
name|ring
operator|->
name|get_seqno
argument_list|(
name|ring
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"retire_request_ring %s %d"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|request
operator|=
name|list_first_entry
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|,
expr|struct
name|drm_i915_gem_request
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i915_seqno_passed
argument_list|(
name|seqno
argument_list|,
name|request
operator|->
name|seqno
argument_list|)
condition|)
break|break;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"retire_request_seqno_passed %s %d"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
comment|/* We know the GPU must have read the request to have 		 * sent us the seqno + interrupt, so use the position 		 * of tail of the request to update the last known position 		 * of the GPU head. 		 */
name|ring
operator|->
name|last_retired_head
operator|=
name|request
operator|->
name|tail
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|request
operator|->
name|list
argument_list|)
expr_stmt|;
name|i915_gem_request_remove_from_client
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
comment|/* Move any buffers on the active list that are no longer referenced 	 * by the ringbuffer to the flushing/inactive lists as appropriate. 	 */
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|active_list
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|list_first_entry
argument_list|(
operator|&
name|ring
operator|->
name|active_list
argument_list|,
expr|struct
name|drm_i915_gem_object
argument_list|,
name|ring_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i915_seqno_passed
argument_list|(
name|seqno
argument_list|,
name|obj
operator|->
name|last_read_seqno
argument_list|)
condition|)
break|break;
name|i915_gem_object_move_to_inactive
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|ring
operator|->
name|trace_irq_seqno
operator|&&
name|i915_seqno_passed
argument_list|(
name|seqno
argument_list|,
name|ring
operator|->
name|trace_irq_seqno
argument_list|)
argument_list|)
condition|)
block|{
name|ring
operator|->
name|irq_put
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|ring
operator|->
name|trace_irq_seqno
operator|=
literal|0
expr_stmt|;
block|}
name|WARN_ON
argument_list|(
name|i915_verify_lists
argument_list|(
name|ring
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_retire_requests
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
name|i915_gem_retire_requests_ring
argument_list|(
name|ring
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_retire_work_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|bool
name|idle
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dev_priv
operator|=
name|arg
expr_stmt|;
name|dev
operator|=
name|dev_priv
operator|->
name|dev
expr_stmt|;
comment|/* Come back later if the device is busy... */
if|if
condition|(
operator|!
name|sx_try_xlock
argument_list|(
operator|&
name|dev
operator|->
name|dev_struct_lock
argument_list|)
condition|)
block|{
name|taskqueue_enqueue_timeout
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|retire_work
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return;
block|}
name|CTR0
argument_list|(
name|KTR_DRM
argument_list|,
literal|"retire_task"
argument_list|)
expr_stmt|;
name|i915_gem_retire_requests
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Send a periodic flush down the ring so we don't hold onto GEM 	 * objects indefinitely. 	 */
name|idle
operator|=
name|true
expr_stmt|;
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|ring
operator|->
name|gpu_caches_dirty
condition|)
name|i915_add_request
argument_list|(
name|ring
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|idle
operator|&=
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
operator|&&
operator|!
name|idle
condition|)
name|taskqueue_enqueue_timeout
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|retire_work
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|idle
condition|)
name|intel_mark_idle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Ensures that an object will eventually get non-busy by flushing any required  * write domains, emitting any outstanding lazy request and retiring and  * completed requests.  */
end_comment

begin_function
specifier|static
name|int
name|i915_gem_object_flush_active
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|active
condition|)
block|{
name|ret
operator|=
name|i915_gem_check_olr
argument_list|(
name|obj
operator|->
name|ring
argument_list|,
name|obj
operator|->
name|last_read_seqno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_retire_requests_ring
argument_list|(
name|obj
operator|->
name|ring
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * i915_gem_wait_ioctl - implements DRM_IOCTL_I915_GEM_WAIT  * @DRM_IOCTL_ARGS: standard ioctl arguments  *  * Returns 0 if successful, else an error is returned with the remaining time in  * the timeout parameter.  *  -ETIME: object is still busy after timeout  *  -ERESTARTSYS: signal interrupted the wait  *  -ENONENT: object doesn't exist  * Also possible, but rare:  *  -EAGAIN: GPU wedged  *  -ENOMEM: damn  *  -ENODEV: Internal IRQ fail  *  -E?: The add request failed  *  * The wait ioctl with a timeout of 0 reimplements the busy ioctl. With any  * non-zero timeout parameter the wait ioctl will wait for the given number of  * nanoseconds on an object becoming unbusy. Since the wait itself does so  * without holding struct_mutex the object may become re-busied before this  * function completes. A similar but shorter * race condition exists in the busy  * ioctl  */
end_comment

begin_function
name|int
name|i915_gem_wait_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_wait
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
name|NULL
decl_stmt|;
name|struct
name|timespec
name|timeout_stack
decl_stmt|,
modifier|*
name|timeout
init|=
name|NULL
decl_stmt|;
name|u32
name|seqno
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|timeout_ns
operator|>=
literal|0
condition|)
block|{
name|timeout_stack
operator|.
name|tv_sec
operator|=
name|args
operator|->
name|timeout_ns
operator|/
literal|1000000
expr_stmt|;
name|timeout_stack
operator|.
name|tv_nsec
operator|=
name|args
operator|->
name|timeout_ns
operator|%
literal|1000000
expr_stmt|;
name|timeout
operator|=
operator|&
name|timeout_stack
expr_stmt|;
block|}
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|bo_handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOENT
return|;
block|}
comment|/* Need to make sure the object gets inactive eventually. */
name|ret
operator|=
name|i915_gem_object_flush_active
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|obj
operator|->
name|active
condition|)
block|{
name|seqno
operator|=
name|obj
operator|->
name|last_read_seqno
expr_stmt|;
name|ring
operator|=
name|obj
operator|->
name|ring
expr_stmt|;
block|}
if|if
condition|(
name|seqno
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Do this after OLR check to make sure we make forward progress polling 	 * on this IOCTL with a 0 timeout (like busy ioctl) 	 */
if|if
condition|(
operator|!
name|args
operator|->
name|timeout_ns
condition|)
block|{
name|ret
operator|=
operator|-
name|ETIMEDOUT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__wait_seqno
argument_list|(
name|ring
argument_list|,
name|seqno
argument_list|,
name|true
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
condition|)
block|{
name|args
operator|->
name|timeout_ns
operator|=
name|timeout
operator|->
name|tv_sec
operator|*
literal|1000000
operator|+
name|timeout
operator|->
name|tv_nsec
expr_stmt|;
block|}
return|return
name|ret
return|;
name|out
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * i915_gem_object_sync - sync an object to a ring.  *  * @obj: object which may be in use on another ring.  * @to: ring we wish to use the object on. May be NULL.  *  * This code is meant to abstract object synchronization with the GPU.  * Calling with NULL implies synchronizing the object with the CPU  * rather than a particular GPU ring.  *  * Returns 0 if successful, else propagates up the lower layer error.  */
end_comment

begin_function
name|int
name|i915_gem_object_sync
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|to
parameter_list|)
block|{
name|struct
name|intel_ring_buffer
modifier|*
name|from
init|=
name|obj
operator|->
name|ring
decl_stmt|;
name|u32
name|seqno
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|idx
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|NULL
operator|||
name|to
operator|==
name|from
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|to
operator|==
name|NULL
operator|||
operator|!
name|i915_semaphore_is_enabled
argument_list|(
name|obj
operator|->
name|base
operator|.
name|dev
argument_list|)
condition|)
return|return
name|i915_gem_object_wait_rendering
argument_list|(
name|obj
argument_list|,
name|false
argument_list|)
return|;
name|idx
operator|=
name|intel_ring_sync_index
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|seqno
operator|=
name|obj
operator|->
name|last_read_seqno
expr_stmt|;
if|if
condition|(
name|seqno
operator|<=
name|from
operator|->
name|sync_seqno
index|[
name|idx
index|]
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|i915_gem_check_olr
argument_list|(
name|obj
operator|->
name|ring
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|to
operator|->
name|sync_to
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
comment|/* We use last_read_seqno because sync_to() 		 * might have just caused seqno wrap under 		 * the radar. 		 */
name|from
operator|->
name|sync_seqno
index|[
name|idx
index|]
operator|=
name|obj
operator|->
name|last_read_seqno
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_finish_gtt
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|u32
name|old_write_domain
decl_stmt|,
name|old_read_domains
decl_stmt|;
comment|/* Act a barrier for all accesses through the GTT */
name|mb
argument_list|()
expr_stmt|;
comment|/* Force a pagefault for domain tracking on next user access */
name|i915_gem_release_mmap
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_DOMAIN_GTT
operator|)
operator|==
literal|0
condition|)
return|return;
name|old_read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|read_domains
expr_stmt|;
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&=
operator|~
name|I915_GEM_DOMAIN_GTT
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&=
operator|~
name|I915_GEM_DOMAIN_GTT
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain finish gtt %p %x %x"
argument_list|,
name|obj
argument_list|,
name|old_read_domains
argument_list|,
name|old_write_domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Unbinds an object from the GTT aperture.  */
end_comment

begin_function
name|int
name|i915_gem_object_unbind
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|gtt_space
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|obj
operator|->
name|pin_count
condition|)
return|return
operator|-
name|EBUSY
return|;
name|BUG_ON
argument_list|(
name|obj
operator|->
name|pages
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_finish_gpu
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* Continue on if we fail due to EIO, the GPU is hung so we 	 * should be safe and we need to cleanup or else we might 	 * cause memory corruption through use-after-free. 	 */
name|i915_gem_object_finish_gtt
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|/* release the fence reg _after_ flushing */
name|ret
operator|=
name|i915_gem_object_put_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|obj
operator|->
name|has_global_gtt_mapping
condition|)
name|i915_gem_gtt_unbind_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|has_aliasing_ppgtt_mapping
condition|)
block|{
name|i915_ppgtt_unbind_object
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|has_aliasing_ppgtt_mapping
operator|=
literal|0
expr_stmt|;
block|}
name|i915_gem_gtt_finish_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|obj
operator|->
name|mm_list
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|gtt_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|unbound_list
argument_list|)
expr_stmt|;
comment|/* Avoid an unnecessary call to unbind on rebind. */
name|obj
operator|->
name|map_and_fenceable
operator|=
name|true
expr_stmt|;
name|drm_mm_put_block
argument_list|(
name|obj
operator|->
name|gtt_space
argument_list|)
expr_stmt|;
name|obj
operator|->
name|gtt_space
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|gtt_offset
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_gpu_idle
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
comment|/* Flush everything onto the inactive list. */
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
block|{
name|ret
operator|=
name|i915_switch_context
argument_list|(
name|ring
argument_list|,
name|NULL
argument_list|,
name|DEFAULT_CONTEXT_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|intel_ring_idle
argument_list|(
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sandybridge_write_fence_reg
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
if|if
condition|(
name|obj
condition|)
block|{
name|u32
name|size
init|=
name|obj
operator|->
name|gtt_space
operator|->
name|size
decl_stmt|;
name|val
operator|=
call|(
name|uint64_t
call|)
argument_list|(
operator|(
name|obj
operator|->
name|gtt_offset
operator|+
name|size
operator|-
literal|4096
operator|)
operator|&
literal|0xfffff000
argument_list|)
operator|<<
literal|32
expr_stmt|;
name|val
operator||=
name|obj
operator|->
name|gtt_offset
operator|&
literal|0xfffff000
expr_stmt|;
name|val
operator||=
call|(
name|uint64_t
call|)
argument_list|(
operator|(
name|obj
operator|->
name|stride
operator|/
literal|128
operator|)
operator|-
literal|1
argument_list|)
operator|<<
name|SANDYBRIDGE_FENCE_PITCH_SHIFT
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_Y
condition|)
name|val
operator||=
literal|1
operator|<<
name|I965_FENCE_TILING_Y_SHIFT
expr_stmt|;
name|val
operator||=
name|I965_FENCE_REG_VALID
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|I915_WRITE64
argument_list|(
name|FENCE_REG_SANDYBRIDGE_0
operator|+
name|reg
operator|*
literal|8
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|FENCE_REG_SANDYBRIDGE_0
operator|+
name|reg
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i965_write_fence_reg
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
if|if
condition|(
name|obj
condition|)
block|{
name|u32
name|size
init|=
name|obj
operator|->
name|gtt_space
operator|->
name|size
decl_stmt|;
name|val
operator|=
call|(
name|uint64_t
call|)
argument_list|(
operator|(
name|obj
operator|->
name|gtt_offset
operator|+
name|size
operator|-
literal|4096
operator|)
operator|&
literal|0xfffff000
argument_list|)
operator|<<
literal|32
expr_stmt|;
name|val
operator||=
name|obj
operator|->
name|gtt_offset
operator|&
literal|0xfffff000
expr_stmt|;
name|val
operator||=
operator|(
operator|(
name|obj
operator|->
name|stride
operator|/
literal|128
operator|)
operator|-
literal|1
operator|)
operator|<<
name|I965_FENCE_PITCH_SHIFT
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_Y
condition|)
name|val
operator||=
literal|1
operator|<<
name|I965_FENCE_TILING_Y_SHIFT
expr_stmt|;
name|val
operator||=
name|I965_FENCE_REG_VALID
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|I915_WRITE64
argument_list|(
name|FENCE_REG_965_0
operator|+
name|reg
operator|*
literal|8
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|FENCE_REG_965_0
operator|+
name|reg
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_write_fence_reg
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|val
decl_stmt|;
if|if
condition|(
name|obj
condition|)
block|{
name|u32
name|size
init|=
name|obj
operator|->
name|gtt_space
operator|->
name|size
decl_stmt|;
name|int
name|pitch_val
decl_stmt|;
name|int
name|tile_width
decl_stmt|;
name|WARN
argument_list|(
operator|(
name|obj
operator|->
name|gtt_offset
operator|&
operator|~
name|I915_FENCE_START_MASK
operator|)
operator|||
operator|(
name|size
operator|&
operator|-
name|size
operator|)
operator|!=
name|size
operator|||
operator|(
name|obj
operator|->
name|gtt_offset
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
argument_list|,
literal|"object 0x%08x [fenceable? %d] not 1M or pot-size (0x%08x) aligned\n"
argument_list|,
name|obj
operator|->
name|gtt_offset
argument_list|,
name|obj
operator|->
name|map_and_fenceable
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_Y
operator|&&
name|HAS_128_BYTE_Y_TILING
argument_list|(
name|dev
argument_list|)
condition|)
name|tile_width
operator|=
literal|128
expr_stmt|;
else|else
name|tile_width
operator|=
literal|512
expr_stmt|;
comment|/* Note: pitch better be a power of two tile widths */
name|pitch_val
operator|=
name|obj
operator|->
name|stride
operator|/
name|tile_width
expr_stmt|;
name|pitch_val
operator|=
name|ffs
argument_list|(
name|pitch_val
argument_list|)
operator|-
literal|1
expr_stmt|;
name|val
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_Y
condition|)
name|val
operator||=
literal|1
operator|<<
name|I830_FENCE_TILING_Y_SHIFT
expr_stmt|;
name|val
operator||=
name|I915_FENCE_SIZE_BITS
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|val
operator||=
name|pitch_val
operator|<<
name|I830_FENCE_PITCH_SHIFT
expr_stmt|;
name|val
operator||=
name|I830_FENCE_REG_VALID
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg
operator|<
literal|8
condition|)
name|reg
operator|=
name|FENCE_REG_830_0
operator|+
name|reg
operator|*
literal|4
expr_stmt|;
else|else
name|reg
operator|=
name|FENCE_REG_945_8
operator|+
operator|(
name|reg
operator|-
literal|8
operator|)
operator|*
literal|4
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i830_write_fence_reg
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|obj
condition|)
block|{
name|u32
name|size
init|=
name|obj
operator|->
name|gtt_space
operator|->
name|size
decl_stmt|;
name|uint32_t
name|pitch_val
decl_stmt|;
name|WARN
argument_list|(
operator|(
name|obj
operator|->
name|gtt_offset
operator|&
operator|~
name|I830_FENCE_START_MASK
operator|)
operator|||
operator|(
name|size
operator|&
operator|-
name|size
operator|)
operator|!=
name|size
operator|||
operator|(
name|obj
operator|->
name|gtt_offset
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
argument_list|,
literal|"object 0x%08x not 512K or pot-size 0x%08x aligned\n"
argument_list|,
name|obj
operator|->
name|gtt_offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pitch_val
operator|=
name|obj
operator|->
name|stride
operator|/
literal|128
expr_stmt|;
name|pitch_val
operator|=
name|ffs
argument_list|(
name|pitch_val
argument_list|)
operator|-
literal|1
expr_stmt|;
name|val
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_Y
condition|)
name|val
operator||=
literal|1
operator|<<
name|I830_FENCE_TILING_Y_SHIFT
expr_stmt|;
name|val
operator||=
name|I830_FENCE_SIZE_BITS
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|val
operator||=
name|pitch_val
operator|<<
name|I830_FENCE_PITCH_SHIFT
expr_stmt|;
name|val
operator||=
name|I830_FENCE_REG_VALID
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FENCE_REG_830_0
operator|+
name|reg
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|FENCE_REG_830_0
operator|+
name|reg
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_write_fence
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
switch|switch
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
condition|)
block|{
case|case
literal|7
case|:
case|case
literal|6
case|:
name|sandybridge_write_fence_reg
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|obj
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
case|case
literal|4
case|:
name|i965_write_fence_reg
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|obj
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|i915_write_fence_reg
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|obj
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i830_write_fence_reg
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|obj
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|fence_number
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|drm_i915_fence_reg
modifier|*
name|fence
parameter_list|)
block|{
return|return
name|fence
operator|-
name|dev_priv
operator|->
name|fence_regs
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_write_fence__ipi
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|wbinvd
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_update_fence
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_i915_fence_reg
modifier|*
name|fence
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|fence_reg
init|=
name|fence_number
argument_list|(
name|dev_priv
argument_list|,
name|fence
argument_list|)
decl_stmt|;
comment|/* In order to fully serialize access to the fenced region and 	 * the update to the fence register we need to take extreme 	 * measures on SNB+. In theory, the write to the fence register 	 * flushes all memory transactions before, and coupled with the 	 * mb() placed around the register write we serialise all memory 	 * operations with respect to the changes in the tiler. Yet, on 	 * SNB+ we need to take a step further and emit an explicit wbinvd() 	 * on each processor in order to manually flush all memory 	 * transactions before updating the fence register. 	 */
if|if
condition|(
name|HAS_LLC
argument_list|(
name|obj
operator|->
name|base
operator|.
name|dev
argument_list|)
condition|)
name|on_each_cpu
argument_list|(
name|i915_gem_write_fence__ipi
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i915_gem_write_fence
argument_list|(
name|dev
argument_list|,
name|fence_reg
argument_list|,
name|enable
condition|?
name|obj
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|obj
operator|->
name|fence_reg
operator|=
name|fence_reg
expr_stmt|;
name|fence
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|fence
operator|->
name|lru_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|fence_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|obj
operator|->
name|fence_reg
operator|=
name|I915_FENCE_REG_NONE
expr_stmt|;
name|fence
operator|->
name|obj
operator|=
name|NULL
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|fence
operator|->
name|lru_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_object_flush_fence
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|last_fenced_seqno
condition|)
block|{
name|int
name|ret
init|=
name|i915_wait_seqno
argument_list|(
name|obj
operator|->
name|ring
argument_list|,
name|obj
operator|->
name|last_fenced_seqno
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|->
name|last_fenced_seqno
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Ensure that all CPU reads are completed before installing a fence 	 * and all writes before removing the fence. 	 */
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_DOMAIN_GTT
condition|)
name|mb
argument_list|()
expr_stmt|;
name|obj
operator|->
name|fenced_gpu_access
operator|=
name|false
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_put_fence
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|i915_gem_object_flush_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|obj
operator|->
name|fence_reg
operator|==
name|I915_FENCE_REG_NONE
condition|)
return|return
literal|0
return|;
name|i915_gem_object_update_fence
argument_list|(
name|obj
argument_list|,
operator|&
name|dev_priv
operator|->
name|fence_regs
index|[
name|obj
operator|->
name|fence_reg
index|]
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|i915_gem_object_fence_lost
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_i915_fence_reg
modifier|*
name|i915_find_fence_reg
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_fence_reg
modifier|*
name|reg
decl_stmt|,
modifier|*
name|avail
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First try to find a free reg */
name|avail
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dev_priv
operator|->
name|fence_reg_start
init|;
name|i
operator|<
name|dev_priv
operator|->
name|num_fence_regs
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
operator|&
name|dev_priv
operator|->
name|fence_regs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|reg
operator|->
name|obj
condition|)
return|return
name|reg
return|;
if|if
condition|(
operator|!
name|reg
operator|->
name|pin_count
condition|)
name|avail
operator|=
name|reg
expr_stmt|;
block|}
if|if
condition|(
name|avail
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* None available, try to steal one or wait for a user to finish */
name|list_for_each_entry
argument_list|(
argument|reg
argument_list|,
argument|&dev_priv->mm.fence_list
argument_list|,
argument|lru_list
argument_list|)
block|{
if|if
condition|(
name|reg
operator|->
name|pin_count
condition|)
continue|continue;
return|return
name|reg
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * i915_gem_object_get_fence - set up fencing for an object  * @obj: object to map through a fence reg  *  * When mapping objects through the GTT, userspace wants to be able to write  * to them without having to worry about swizzling if the object is tiled.  * This function walks the fence regs looking for a free one for @obj,  * stealing one if it can't find any.  *  * It then sets up the reg based on the object's properties: address, pitch  * and tiling format.  *  * For an untiled surface, this removes any existing fence.  */
end_comment

begin_function
name|int
name|i915_gem_object_get_fence
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|bool
name|enable
init|=
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
decl_stmt|;
name|struct
name|drm_i915_fence_reg
modifier|*
name|reg
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Have we updated the tiling parameters upon the object and so 	 * will need to serialise the write to the associated fence register? 	 */
if|if
condition|(
name|obj
operator|->
name|fence_dirty
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_flush_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
comment|/* Just update our place in the LRU if our fence is getting reused. */
if|if
condition|(
name|obj
operator|->
name|fence_reg
operator|!=
name|I915_FENCE_REG_NONE
condition|)
block|{
name|reg
operator|=
operator|&
name|dev_priv
operator|->
name|fence_regs
index|[
name|obj
operator|->
name|fence_reg
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|obj
operator|->
name|fence_dirty
condition|)
block|{
name|list_move_tail
argument_list|(
operator|&
name|reg
operator|->
name|lru_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|fence_list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|enable
condition|)
block|{
name|reg
operator|=
name|i915_find_fence_reg
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
return|return
operator|-
name|EDEADLK
return|;
if|if
condition|(
name|reg
operator|->
name|obj
condition|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|old
init|=
name|reg
operator|->
name|obj
decl_stmt|;
name|ret
operator|=
name|i915_gem_object_flush_fence
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_object_fence_lost
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
literal|0
return|;
name|i915_gem_object_update_fence
argument_list|(
name|obj
argument_list|,
name|reg
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|obj
operator|->
name|fence_dirty
operator|=
name|false
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|i915_gem_valid_gtt_space
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_mm_node
modifier|*
name|gtt_space
parameter_list|,
name|unsigned
name|long
name|cache_level
parameter_list|)
block|{
name|struct
name|drm_mm_node
modifier|*
name|other
decl_stmt|;
comment|/* On non-LLC machines we have to be careful when putting differing 	 * types of snoopable memory together to avoid the prefetcher 	 * crossing memory domains and dying. 	 */
if|if
condition|(
name|HAS_LLC
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|gtt_space
operator|==
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|gtt_space
operator|->
name|node_list
argument_list|)
condition|)
return|return
name|true
return|;
name|other
operator|=
name|list_entry
argument_list|(
name|gtt_space
operator|->
name|node_list
operator|.
name|prev
argument_list|,
expr|struct
name|drm_mm_node
argument_list|,
name|node_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|other
operator|->
name|allocated
operator|&&
operator|!
name|other
operator|->
name|hole_follows
operator|&&
name|other
operator|->
name|color
operator|!=
name|cache_level
condition|)
return|return
name|false
return|;
name|other
operator|=
name|list_entry
argument_list|(
name|gtt_space
operator|->
name|node_list
operator|.
name|next
argument_list|,
expr|struct
name|drm_mm_node
argument_list|,
name|node_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|other
operator|->
name|allocated
operator|&&
operator|!
name|gtt_space
operator|->
name|hole_follows
operator|&&
name|other
operator|->
name|color
operator|!=
name|cache_level
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_verify_gtt
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|#
directive|if
name|WATCH_GTT
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|&dev_priv->mm.gtt_list
argument_list|,
argument|gtt_list
argument_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|gtt_space
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"object found on GTT list with no space reserved\n"
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|obj
operator|->
name|cache_level
operator|!=
name|obj
operator|->
name|gtt_space
operator|->
name|color
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"object reserved space [%08lx, %08lx] with wrong color, cache_level=%x, color=%lx\n"
argument_list|,
name|obj
operator|->
name|gtt_space
operator|->
name|start
argument_list|,
name|obj
operator|->
name|gtt_space
operator|->
name|start
operator|+
name|obj
operator|->
name|gtt_space
operator|->
name|size
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|,
name|obj
operator|->
name|gtt_space
operator|->
name|color
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|i915_gem_valid_gtt_space
argument_list|(
name|dev
argument_list|,
name|obj
operator|->
name|gtt_space
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"invalid GTT space found at [%08lx, %08lx] - color=%x\n"
argument_list|,
name|obj
operator|->
name|gtt_space
operator|->
name|start
argument_list|,
name|obj
operator|->
name|gtt_space
operator|->
name|start
operator|+
name|obj
operator|->
name|gtt_space
operator|->
name|size
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
name|WARN_ON
argument_list|(
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * Finds free space in the GTT aperture and binds the object there.  */
end_comment

begin_function
specifier|static
name|int
name|i915_gem_object_bind_to_gtt
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|unsigned
name|alignment
parameter_list|,
name|bool
name|map_and_fenceable
parameter_list|,
name|bool
name|nonblocking
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_mm_node
modifier|*
name|node
decl_stmt|;
name|u32
name|size
decl_stmt|,
name|fence_size
decl_stmt|,
name|fence_alignment
decl_stmt|,
name|unfenced_alignment
decl_stmt|;
name|bool
name|mappable
decl_stmt|,
name|fenceable
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|madv
operator|!=
name|I915_MADV_WILLNEED
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Attempting to bind a purgeable object\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|fence_size
operator|=
name|i915_gem_get_gtt_size
argument_list|(
name|dev
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|,
name|obj
operator|->
name|tiling_mode
argument_list|)
expr_stmt|;
name|fence_alignment
operator|=
name|i915_gem_get_gtt_alignment
argument_list|(
name|dev
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|,
name|obj
operator|->
name|tiling_mode
argument_list|)
expr_stmt|;
name|unfenced_alignment
operator|=
name|i915_gem_get_unfenced_gtt_alignment
argument_list|(
name|dev
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|,
name|obj
operator|->
name|tiling_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignment
operator|==
literal|0
condition|)
name|alignment
operator|=
name|map_and_fenceable
condition|?
name|fence_alignment
else|:
name|unfenced_alignment
expr_stmt|;
if|if
condition|(
name|map_and_fenceable
operator|&&
name|alignment
operator|&
operator|(
name|fence_alignment
operator|-
literal|1
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid object alignment requested %u\n"
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|size
operator|=
name|map_and_fenceable
condition|?
name|fence_size
else|:
name|obj
operator|->
name|base
operator|.
name|size
expr_stmt|;
comment|/* If the object is bigger than the entire aperture, reject it early 	 * before evicting everything in a vain attempt to find space. 	 */
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|size
operator|>
operator|(
name|map_and_fenceable
condition|?
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mappable_end
else|:
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_total
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Attempting to bind an object larger than the aperture\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E2BIG
return|;
block|}
name|ret
operator|=
name|i915_gem_object_get_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_object_pin_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|node
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|,
name|DRM_MEM_MM
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|i915_gem_object_unpin_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|search_free
label|:
if|if
condition|(
name|map_and_fenceable
condition|)
name|ret
operator|=
name|drm_mm_insert_node_in_range_generic
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_space
argument_list|,
name|node
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|,
literal|0
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mappable_end
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|drm_mm_insert_node_generic
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_space
argument_list|,
name|node
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ret
operator|=
name|i915_gem_evict_something
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|,
name|map_and_fenceable
argument_list|,
name|nonblocking
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
goto|goto
name|search_free
goto|;
name|i915_gem_object_unpin_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|,
name|DRM_MEM_MM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|WARN_ON
argument_list|(
operator|!
name|i915_gem_valid_gtt_space
argument_list|(
name|dev
argument_list|,
name|node
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
argument_list|)
condition|)
block|{
name|i915_gem_object_unpin_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|drm_mm_put_block
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|ret
operator|=
name|i915_gem_gtt_prepare_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|i915_gem_object_unpin_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|drm_mm_put_block
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|gtt_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|bound_list
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|obj
operator|->
name|mm_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|inactive_list
argument_list|)
expr_stmt|;
name|obj
operator|->
name|gtt_space
operator|=
name|node
expr_stmt|;
name|obj
operator|->
name|gtt_offset
operator|=
name|node
operator|->
name|start
expr_stmt|;
name|fenceable
operator|=
name|node
operator|->
name|size
operator|==
name|fence_size
operator|&&
operator|(
name|node
operator|->
name|start
operator|&
operator|(
name|fence_alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
expr_stmt|;
name|mappable
operator|=
name|obj
operator|->
name|gtt_offset
operator|+
name|obj
operator|->
name|base
operator|.
name|size
operator|<=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mappable_end
expr_stmt|;
name|obj
operator|->
name|map_and_fenceable
operator|=
name|mappable
operator|&&
name|fenceable
expr_stmt|;
name|i915_gem_object_unpin_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_bind %p %x %x %d"
argument_list|,
name|obj
argument_list|,
name|obj
operator|->
name|gtt_offset
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|,
name|map_and_fenceable
argument_list|)
expr_stmt|;
name|i915_gem_verify_gtt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_clflush_object
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
comment|/* If we don't have a page list set up, then we're not pinned 	 * to GPU, and we can ignore the cache flush because it'll happen 	 * again at bind time. 	 */
if|if
condition|(
name|obj
operator|->
name|pages
operator|==
name|NULL
condition|)
return|return;
comment|/* If the GPU is snooping the contents of the CPU cache, 	 * we do not need to manually clear the CPU cache lines.  However, 	 * the caches are only snooped when the render cache is 	 * flushed/invalidated.  As we always have to emit invalidations 	 * and flushes when moving into and out of the RENDER domain, correct 	 * snooping behaviour occurs naturally as the result of our domain 	 * tracking. 	 */
if|if
condition|(
name|obj
operator|->
name|cache_level
operator|!=
name|I915_CACHE_NONE
condition|)
return|return;
name|CTR1
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_clflush %p"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|drm_clflush_pages
argument_list|(
name|obj
operator|->
name|pages
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Flushes the GTT write domain for the object if it's dirty. */
end_comment

begin_function
specifier|static
name|void
name|i915_gem_object_flush_gtt_write_domain
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|uint32_t
name|old_write_domain
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|!=
name|I915_GEM_DOMAIN_GTT
condition|)
return|return;
comment|/* No actual flushing is required for the GTT write domain.  Writes 	 * to it immediately go to main memory as far as we know, so there's 	 * no chipset flush.  It also doesn't land in render cache. 	 * 	 * However, we do have to enforce the order so that all writes through 	 * the GTT land before any writes to the device, such as updates to 	 * the GATT itself. 	 */
name|wmb
argument_list|()
expr_stmt|;
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
literal|0
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain flush gtt_write %p %x %x"
argument_list|,
name|obj
argument_list|,
name|obj
operator|->
name|base
operator|.
name|read_domains
argument_list|,
name|old_write_domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Flushes the CPU write domain for the object if it's dirty. */
end_comment

begin_function
specifier|static
name|void
name|i915_gem_object_flush_cpu_write_domain
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|uint32_t
name|old_write_domain
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|!=
name|I915_GEM_DOMAIN_CPU
condition|)
return|return;
name|i915_gem_clflush_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|i915_gem_chipset_flush
argument_list|(
name|obj
operator|->
name|base
operator|.
name|dev
argument_list|)
expr_stmt|;
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
literal|0
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain flush_cpu_write %p %x %x"
argument_list|,
name|obj
argument_list|,
name|obj
operator|->
name|base
operator|.
name|read_domains
argument_list|,
name|old_write_domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Moves a single object to the GTT read, and possibly write domain.  *  * This function returns when the move is complete, including waiting on  * flushes to occur.  */
end_comment

begin_function
name|int
name|i915_gem_object_set_to_gtt_domain
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|bool
name|write
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|old_write_domain
decl_stmt|,
name|old_read_domains
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Not valid to be called on unbound objects. */
if|if
condition|(
name|obj
operator|->
name|gtt_space
operator|==
name|NULL
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|==
name|I915_GEM_DOMAIN_GTT
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|i915_gem_object_wait_rendering
argument_list|(
name|obj
argument_list|,
operator|!
name|write
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_object_flush_cpu_write_domain
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|old_read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|read_domains
expr_stmt|;
comment|/* It should now be out of any other write domains, and we can update 	 * the domain values for our changes. 	 */
name|BUG_ON
argument_list|(
operator|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
operator|~
name|I915_GEM_DOMAIN_GTT
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator||=
name|I915_GEM_DOMAIN_GTT
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|=
name|I915_GEM_DOMAIN_GTT
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
name|I915_GEM_DOMAIN_GTT
expr_stmt|;
name|obj
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain set_to_gtt %p %x %x"
argument_list|,
name|obj
argument_list|,
name|old_read_domains
argument_list|,
name|old_write_domain
argument_list|)
expr_stmt|;
comment|/* And bump the LRU for this access */
if|if
condition|(
name|i915_gem_object_is_inactive
argument_list|(
name|obj
argument_list|)
condition|)
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|mm_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|inactive_list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_set_cache_level
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|enum
name|i915_cache_level
name|cache_level
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|cache_level
operator|==
name|cache_level
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|obj
operator|->
name|pin_count
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"can not change the cache level of pinned objects\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
if|if
condition|(
operator|!
name|i915_gem_valid_gtt_space
argument_list|(
name|dev
argument_list|,
name|obj
operator|->
name|gtt_space
argument_list|,
name|cache_level
argument_list|)
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|gtt_space
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_finish_gpu
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_object_finish_gtt
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|/* Before SandyBridge, you could not use tiling or fence 		 * registers with snooped memory, so relinquish any fences 		 * currently pointing to our region in the aperture. 		 */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|6
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_put_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|has_global_gtt_mapping
condition|)
name|i915_gem_gtt_bind_object
argument_list|(
name|obj
argument_list|,
name|cache_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|has_aliasing_ppgtt_mapping
condition|)
name|i915_ppgtt_bind_object
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
argument_list|,
name|obj
argument_list|,
name|cache_level
argument_list|)
expr_stmt|;
name|obj
operator|->
name|gtt_space
operator|->
name|color
operator|=
name|cache_level
expr_stmt|;
block|}
if|if
condition|(
name|cache_level
operator|==
name|I915_CACHE_NONE
condition|)
block|{
name|u32
name|old_read_domains
decl_stmt|,
name|old_write_domain
decl_stmt|;
comment|/* If we're coming from LLC cached, then we haven't 		 * actually been tracking whether the data is in the 		 * CPU cache or not, since we only allow one bit set 		 * in obj->write_domain and have been skipping the clflushes. 		 * Just set it to the CPU cache for now. 		 */
name|WARN_ON
argument_list|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
operator|~
name|I915_GEM_DOMAIN_CPU
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
operator|~
name|I915_GEM_DOMAIN_CPU
argument_list|)
expr_stmt|;
name|old_read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|read_domains
expr_stmt|;
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain set_cache_level %p %x %x"
argument_list|,
name|obj
argument_list|,
name|old_read_domains
argument_list|,
name|old_write_domain
argument_list|)
expr_stmt|;
block|}
name|obj
operator|->
name|cache_level
operator|=
name|cache_level
expr_stmt|;
name|i915_gem_verify_gtt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_get_caching_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_caching
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|args
operator|->
name|caching
operator|=
name|obj
operator|->
name|cache_level
operator|!=
name|I915_CACHE_NONE
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_set_caching_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_caching
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|enum
name|i915_cache_level
name|level
decl_stmt|;
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|args
operator|->
name|caching
condition|)
block|{
case|case
name|I915_CACHING_NONE
case|:
name|level
operator|=
name|I915_CACHE_NONE
expr_stmt|;
break|break;
case|case
name|I915_CACHING_CACHED
case|:
name|level
operator|=
name|I915_CACHE_LLC
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|ret
operator|=
name|i915_gem_object_set_cache_level
argument_list|(
name|obj
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|is_pin_display
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
comment|/* There are 3 sources that pin objects: 	 *   1. The display engine (scanouts, sprites, cursors); 	 *   2. Reservations for execbuffer; 	 *   3. The user. 	 * 	 * We can ignore reservations as we hold the struct_mutex and 	 * are only called outside of the reservation path.  The user 	 * can only increment pin_count once, and so if after 	 * subtracting the potential reference by the user, any pin_count 	 * remains, it must be due to another use by the display engine. 	 */
return|return
name|obj
operator|->
name|pin_count
operator|-
operator|!
operator|!
name|obj
operator|->
name|user_pin_count
return|;
block|}
end_function

begin_comment
comment|/*  * Prepare buffer for display plane (scanout, cursors, etc).  * Can be called from an uninterruptible phase (modesetting) and allows  * any flushes to be pipelined (for pageflips).  */
end_comment

begin_function
name|int
name|i915_gem_object_pin_to_display_plane
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|u32
name|alignment
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|pipelined
parameter_list|)
block|{
name|u32
name|old_read_domains
decl_stmt|,
name|old_write_domain
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|pipelined
operator|!=
name|obj
operator|->
name|ring
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_sync
argument_list|(
name|obj
argument_list|,
name|pipelined
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
comment|/* Mark the pin_display early so that we account for the 	 * display coherency whilst setting up the cache domains. 	 */
name|obj
operator|->
name|pin_display
operator|=
name|true
expr_stmt|;
comment|/* The display engine is not coherent with the LLC cache on gen6.  As 	 * a result, we make sure that the pinning that is about to occur is 	 * done with uncached PTEs. This is lowest common denominator for all 	 * chipsets. 	 * 	 * However for gen6+, we could do better by using the GFDT bit instead 	 * of uncaching, which would allow us to flush all the LLC-cached data 	 * with that bit in the PTE to main memory with just one PIPE_CONTROL. 	 */
name|ret
operator|=
name|i915_gem_object_set_cache_level
argument_list|(
name|obj
argument_list|,
name|I915_CACHE_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin_display
goto|;
comment|/* As the user may map the buffer once pinned in the display plane 	 * (e.g. libkms for the bootup splash), we have to ensure that we 	 * always use map_and_fenceable for all scanout buffers. 	 */
name|ret
operator|=
name|i915_gem_object_pin
argument_list|(
name|obj
argument_list|,
name|alignment
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_unpin_display
goto|;
name|i915_gem_object_flush_cpu_write_domain
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|old_read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|read_domains
expr_stmt|;
comment|/* It should now be out of any other write domains, and we can update 	 * the domain values for our changes. 	 */
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator||=
name|I915_GEM_DOMAIN_GTT
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain pin_to_display_plan %p %x %x"
argument_list|,
name|obj
argument_list|,
name|old_read_domains
argument_list|,
name|old_write_domain
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_unpin_display
label|:
name|obj
operator|->
name|pin_display
operator|=
name|is_pin_display
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_object_unpin_from_display_plane
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pin_display
operator|=
name|is_pin_display
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_finish_gpu
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_GPU_DOMAINS
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|i915_gem_object_wait_rendering
argument_list|(
name|obj
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* Ensure that we invalidate the GPU's caches and TLBs. */
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&=
operator|~
name|I915_GEM_GPU_DOMAINS
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Moves a single object to the CPU read, and possibly write domain.  *  * This function returns when the move is complete, including waiting on  * flushes to occur.  */
end_comment

begin_function
name|int
name|i915_gem_object_set_to_cpu_domain
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|bool
name|write
parameter_list|)
block|{
name|uint32_t
name|old_write_domain
decl_stmt|,
name|old_read_domains
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|==
name|I915_GEM_DOMAIN_CPU
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|i915_gem_object_wait_rendering
argument_list|(
name|obj
argument_list|,
operator|!
name|write
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_object_flush_gtt_write_domain
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|old_read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|read_domains
expr_stmt|;
comment|/* Flush the CPU cache if it's still invalid. */
if|if
condition|(
operator|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_DOMAIN_CPU
operator|)
operator|==
literal|0
condition|)
block|{
name|i915_gem_clflush_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator||=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
block|}
comment|/* It should now be out of any other write domains, and we can update 	 * the domain values for our changes. 	 */
name|BUG_ON
argument_list|(
operator|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
operator|~
name|I915_GEM_DOMAIN_CPU
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* If we're writing through the CPU, then the GPU read domains will 	 * need to be invalidated at next use. 	 */
if|if
condition|(
name|write
condition|)
block|{
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain set_to_cpu %p %x %x"
argument_list|,
name|obj
argument_list|,
name|old_read_domains
argument_list|,
name|old_write_domain
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Throttle our rendering by waiting until the ring has completed our requests  * emitted over 20 msec ago.  *  * Note that if we were to use the current jiffies each time around the loop,  * we wouldn't escape the function with any frames outstanding if the time to  * render a frame was over 20ms.  *  * This should get us reasonable parallelism between CPU and GPU but also  * relatively low latency when blocking on a particular request to finish.  */
end_comment

begin_function
specifier|static
name|int
name|i915_gem_ring_throttle
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_file_private
modifier|*
name|file_priv
init|=
name|file
operator|->
name|driver_priv
decl_stmt|;
name|unsigned
name|long
name|recent_enough
init|=
name|jiffies
operator|-
name|msecs_to_jiffies
argument_list|(
literal|20
argument_list|)
decl_stmt|;
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
name|NULL
decl_stmt|;
name|u32
name|seqno
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
name|mtx_lock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lock
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|request
argument_list|,
argument|&file_priv->mm.request_list
argument_list|,
argument|client_list
argument_list|)
block|{
if|if
condition|(
name|time_after_eq
argument_list|(
name|request
operator|->
name|emitted_jiffies
argument_list|,
name|recent_enough
argument_list|)
condition|)
break|break;
name|ring
operator|=
name|request
operator|->
name|ring
expr_stmt|;
name|seqno
operator|=
name|request
operator|->
name|seqno
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|seqno
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|__wait_seqno
argument_list|(
name|ring
argument_list|,
name|seqno
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|taskqueue_enqueue_timeout
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|retire_work
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_pin
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|uint32_t
name|alignment
parameter_list|,
name|bool
name|map_and_fenceable
parameter_list|,
name|bool
name|nonblocking
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|WARN_ON
argument_list|(
name|obj
operator|->
name|pin_count
operator|==
name|DRM_I915_GEM_OBJECT_MAX_PIN_COUNT
argument_list|)
condition|)
return|return
operator|-
name|EBUSY
return|;
if|if
condition|(
name|obj
operator|->
name|gtt_space
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|alignment
operator|&&
name|obj
operator|->
name|gtt_offset
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|map_and_fenceable
operator|&&
operator|!
name|obj
operator|->
name|map_and_fenceable
operator|)
condition|)
block|{
name|WARN
argument_list|(
name|obj
operator|->
name|pin_count
argument_list|,
literal|"bo is already pinned with incorrect alignment:"
literal|" offset=%x, req.alignment=%x, req.map_and_fenceable=%d,"
literal|" obj->map_and_fenceable=%d\n"
argument_list|,
name|obj
operator|->
name|gtt_offset
argument_list|,
name|alignment
argument_list|,
name|map_and_fenceable
argument_list|,
name|obj
operator|->
name|map_and_fenceable
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
block|}
if|if
condition|(
name|obj
operator|->
name|gtt_space
operator|==
name|NULL
condition|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|ret
operator|=
name|i915_gem_object_bind_to_gtt
argument_list|(
name|obj
argument_list|,
name|alignment
argument_list|,
name|map_and_fenceable
argument_list|,
name|nonblocking
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
condition|)
name|i915_gem_gtt_bind_object
argument_list|(
name|obj
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|obj
operator|->
name|has_global_gtt_mapping
operator|&&
name|map_and_fenceable
condition|)
name|i915_gem_gtt_bind_object
argument_list|(
name|obj
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pin_count
operator|++
expr_stmt|;
name|obj
operator|->
name|pin_mappable
operator||=
name|map_and_fenceable
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_object_unpin
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|BUG_ON
argument_list|(
name|obj
operator|->
name|pin_count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|obj
operator|->
name|gtt_space
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|obj
operator|->
name|pin_count
operator|==
literal|0
condition|)
name|obj
operator|->
name|pin_mappable
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_pin_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_pin
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|madv
operator|!=
name|I915_MADV_WILLNEED
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Attempting to pin a purgeable buffer\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|pin_filp
operator|!=
name|NULL
operator|&&
name|obj
operator|->
name|pin_filp
operator|!=
name|file
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Already pinned in i915_gem_pin_ioctl(): %d\n"
argument_list|,
name|args
operator|->
name|handle
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|user_pin_count
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_pin
argument_list|(
name|obj
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
name|obj
operator|->
name|user_pin_count
operator|++
expr_stmt|;
name|obj
operator|->
name|pin_filp
operator|=
name|file
expr_stmt|;
comment|/* XXX - flush the CPU caches for pinned objects 	 * as the X server doesn't manage domains yet 	 */
name|i915_gem_object_flush_cpu_write_domain
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|args
operator|->
name|offset
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
name|out
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_unpin_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_pin
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|pin_filp
operator|!=
name|file
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Not pinned by caller in i915_gem_pin_ioctl(): %d\n"
argument_list|,
name|args
operator|->
name|handle
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|obj
operator|->
name|user_pin_count
operator|--
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|user_pin_count
operator|==
literal|0
condition|)
block|{
name|obj
operator|->
name|pin_filp
operator|=
name|NULL
expr_stmt|;
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_busy_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_busy
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* Count all active objects as busy, even if they are currently not used 	 * by the gpu. Users of this interface expect objects to eventually 	 * become non-busy without any further actions, therefore emit any 	 * necessary flushes here. 	 */
name|ret
operator|=
name|i915_gem_object_flush_active
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|args
operator|->
name|busy
operator|=
name|obj
operator|->
name|active
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|ring
condition|)
block|{
name|BUILD_BUG_ON
argument_list|(
name|I915_NUM_RINGS
operator|>
literal|16
argument_list|)
expr_stmt|;
name|args
operator|->
name|busy
operator||=
name|intel_ring_flag
argument_list|(
name|obj
operator|->
name|ring
argument_list|)
operator|<<
literal|16
expr_stmt|;
block|}
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_throttle_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
return|return
name|i915_gem_ring_throttle
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_madvise_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_i915_gem_madvise
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|args
operator|->
name|madv
condition|)
block|{
case|case
name|I915_MADV_DONTNEED
case|:
case|case
name|I915_MADV_WILLNEED
case|:
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|pin_count
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|madv
operator|!=
name|__I915_MADV_PURGED
condition|)
name|obj
operator|->
name|madv
operator|=
name|args
operator|->
name|madv
expr_stmt|;
comment|/* if the object is no longer attached, discard its backing storage */
if|if
condition|(
name|i915_gem_object_is_purgeable
argument_list|(
name|obj
argument_list|)
operator|&&
name|obj
operator|->
name|pages
operator|==
name|NULL
condition|)
name|i915_gem_object_truncate
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|args
operator|->
name|retained
operator|=
name|obj
operator|->
name|madv
operator|!=
name|__I915_MADV_PURGED
expr_stmt|;
name|out
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_object_init
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
specifier|const
name|struct
name|drm_i915_gem_object_ops
modifier|*
name|ops
parameter_list|)
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|obj
operator|->
name|mm_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|obj
operator|->
name|gtt_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|obj
operator|->
name|ring_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|)
expr_stmt|;
name|obj
operator|->
name|ops
operator|=
name|ops
expr_stmt|;
name|obj
operator|->
name|fence_reg
operator|=
name|I915_FENCE_REG_NONE
expr_stmt|;
name|obj
operator|->
name|madv
operator|=
name|I915_MADV_WILLNEED
expr_stmt|;
comment|/* Avoid an unnecessary call to unbind on the first bind. */
name|obj
operator|->
name|map_and_fenceable
operator|=
name|true
expr_stmt|;
name|i915_gem_info_add_obj
argument_list|(
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_i915_gem_object_ops
name|i915_gem_object_ops
init|=
block|{
operator|.
name|get_pages
operator|=
name|i915_gem_object_get_pages_gtt
block|,
operator|.
name|put_pages
operator|=
name|i915_gem_object_put_pages_gtt
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|drm_i915_gem_object
modifier|*
name|i915_gem_alloc_object
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|obj
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|drm_gem_object_init
argument_list|(
name|dev
argument_list|,
operator|&
name|obj
operator|->
name|base
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|obj
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|mask
operator|=
name|GFP_HIGHUSER
operator||
name|__GFP_RECLAIMABLE
expr_stmt|;
if|if
condition|(
name|IS_CRESTLINE
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_BROADWATER
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* 965gm cannot relocate objects above 4GiB. */
name|mask
operator|&=
operator|~
name|__GFP_HIGHMEM
expr_stmt|;
name|mask
operator||=
name|__GFP_DMA32
expr_stmt|;
block|}
name|mapping
operator|=
name|obj
operator|->
name|base
operator|.
name|filp
operator|->
name|f_path
operator|.
name|dentry
operator|->
name|d_inode
operator|->
name|i_mapping
expr_stmt|;
name|mapping_set_gfp_mask
argument_list|(
name|mapping
argument_list|,
name|mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|i915_gem_object_init
argument_list|(
name|obj
argument_list|,
operator|&
name|i915_gem_object_ops
argument_list|)
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
if|if
condition|(
name|HAS_LLC
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* On some devices, we can have the GPU use the LLC (the CPU 		 * cache) for about a 10% performance improvement 		 * compared to uncached.  Graphics requests other than 		 * display scanout are coherent with the CPU in 		 * accessing this cache.  This means in this mode we 		 * don't need to clflush on the CPU side, and on the 		 * GPU side we only need to flush internal caches to 		 * get data visible to the CPU. 		 * 		 * However, we maintain the display planes as UC, and so 		 * need to rebind when first used as such. 		 */
name|obj
operator|->
name|cache_level
operator|=
name|I915_CACHE_LLC
expr_stmt|;
block|}
else|else
name|obj
operator|->
name|cache_level
operator|=
name|I915_CACHE_NONE
expr_stmt|;
return|return
name|obj
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_init_object
parameter_list|(
name|struct
name|drm_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|printf
argument_list|(
literal|"i915_gem_init_object called\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_free_object
parameter_list|(
name|struct
name|drm_gem_object
modifier|*
name|gem_obj
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|to_intel_bo
argument_list|(
name|gem_obj
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|CTR1
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_destroy_tail %p"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|phys_obj
condition|)
name|i915_gem_detach_phys_object
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pin_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|WARN_ON
argument_list|(
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
operator|==
operator|-
name|ERESTARTSYS
argument_list|)
condition|)
block|{
name|bool
name|was_interruptible
decl_stmt|;
name|was_interruptible
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|false
expr_stmt|;
name|WARN_ON
argument_list|(
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|was_interruptible
expr_stmt|;
block|}
name|obj
operator|->
name|pages_pin_count
operator|=
literal|0
expr_stmt|;
name|i915_gem_object_put_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|i915_gem_object_free_mmap_offset
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|obj
operator|->
name|pages
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|import_attach
condition|)
name|drm_prime_gem_destroy
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|drm_gem_object_release
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|i915_gem_info_remove_obj
argument_list|(
name|dev_priv
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obj
operator|->
name|bit_17
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obj
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_idle
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ret
operator|=
name|i915_gpu_idle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|i915_gem_retire_requests
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Under UMS, be paranoid and evict. */
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
name|i915_gem_evict_everything
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_reset_fences
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Hack!  Don't let anybody do execbuf while we don't control the chip. 	 * We need to replace this with a semaphore, or something. 	 * And not confound mm.suspended! 	 */
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
operator|=
literal|1
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|dev_priv
operator|->
name|hangcheck_timer
argument_list|)
expr_stmt|;
name|i915_kernel_lost_context
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_cleanup_ringbuffer
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Cancel the retire work handler, which should be idle now. */
name|taskqueue_cancel_timeout
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|retire_work
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_l3_remap
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|misccpctl
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|HAS_L3_GPU_CACHE
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|l3_parity
operator|.
name|remap_info
condition|)
return|return;
name|misccpctl
operator|=
name|I915_READ
argument_list|(
name|GEN7_MISCCPCTL
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN7_MISCCPCTL
argument_list|,
name|misccpctl
operator|&
operator|~
name|GEN7_DOP_CLOCK_GATE_ENABLE
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|GEN7_MISCCPCTL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEN7_L3LOG_SIZE
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|u32
name|remap
init|=
name|I915_READ
argument_list|(
name|GEN7_L3LOG_BASE
operator|+
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|remap
operator|&&
name|remap
operator|!=
name|dev_priv
operator|->
name|l3_parity
operator|.
name|remap_info
index|[
name|i
operator|/
literal|4
index|]
condition|)
name|DRM_DEBUG
argument_list|(
literal|"0x%x was already programmed to %x\n"
argument_list|,
name|GEN7_L3LOG_BASE
operator|+
name|i
argument_list|,
name|remap
argument_list|)
expr_stmt|;
if|if
condition|(
name|remap
operator|&&
operator|!
name|dev_priv
operator|->
name|l3_parity
operator|.
name|remap_info
index|[
name|i
operator|/
literal|4
index|]
condition|)
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"Clearing remapped register\n"
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN7_L3LOG_BASE
operator|+
name|i
argument_list|,
name|dev_priv
operator|->
name|l3_parity
operator|.
name|remap_info
index|[
name|i
operator|/
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure all the writes land before disabling dop clock gating */
name|POSTING_READ
argument_list|(
name|GEN7_L3LOG_BASE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GEN7_MISCCPCTL
argument_list|,
name|misccpctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_init_swizzling
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|5
operator|||
name|dev_priv
operator|->
name|mm
operator|.
name|bit_6_swizzle_x
operator|==
name|I915_BIT_6_SWIZZLE_NONE
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|DISP_ARB_CTL
argument_list|,
name|I915_READ
argument_list|(
name|DISP_ARB_CTL
argument_list|)
operator||
name|DISP_TILE_SURFACE_SWIZZLING
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|TILECTL
argument_list|,
name|I915_READ
argument_list|(
name|TILECTL
argument_list|)
operator||
name|TILECTL_SWZCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|ARB_MODE
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|ARB_MODE_SWIZZLE_SNB
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|I915_WRITE
argument_list|(
name|ARB_MODE
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|ARB_MODE_SWIZZLE_IVB
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_enable_blt
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|HAS_BLT
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The blitter was dysfunctional on early prototypes */
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
operator|&&
name|pci_get_revid
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|<
literal|8
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"BLT not supported on this pre-production hardware;"
literal|" graphics performance will be degraded.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_init_hw
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|6
operator|&&
operator|!
name|intel_enable_gtt
argument_list|()
condition|)
return|return
operator|-
name|EIO
return|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
if|if
condition|(
name|IS_HASWELL
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|I915_READ
argument_list|(
literal|0x120010
argument_list|)
operator|==
literal|1
operator|)
condition|)
name|I915_WRITE
argument_list|(
literal|0x9008
argument_list|,
name|I915_READ
argument_list|(
literal|0x9008
argument_list|)
operator||
literal|0xf0000
argument_list|)
expr_stmt|;
name|i915_gem_l3_remap
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_init_swizzling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_init_render_ring_buffer
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|HAS_BSD
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ret
operator|=
name|intel_init_bsd_ring_buffer
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup_render_ring
goto|;
block|}
if|if
condition|(
name|intel_enable_blt
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ret
operator|=
name|intel_init_blt_ring_buffer
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup_bsd_ring
goto|;
block|}
name|dev_priv
operator|->
name|next_seqno
operator|=
literal|1
expr_stmt|;
comment|/* 	 * XXX: There was some w/a described somewhere suggesting loading 	 * contexts before PPGTT. 	 */
name|i915_gem_context_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_init_ppgtt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|cleanup_bsd_ring
label|:
name|intel_cleanup_ring_buffer
argument_list|(
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|VCS
index|]
argument_list|)
expr_stmt|;
name|cleanup_render_ring
label|:
name|intel_cleanup_ring_buffer
argument_list|(
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|RCS
index|]
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_enable_ppgtt
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|i915_enable_ppgtt
operator|>=
literal|0
condition|)
return|return
name|i915_enable_ppgtt
return|;
ifdef|#
directive|ifdef
name|CONFIG_INTEL_IOMMU
comment|/* Disable ppgtt on SNB if VT-d is on. */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|==
literal|6
operator|&&
name|intel_iommu_gfx_mapped
condition|)
return|return
name|false
return|;
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|unsigned
name|long
name|gtt_size
decl_stmt|,
name|mappable_size
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|gtt_size
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_total_entries
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|mappable_size
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|->
name|gtt_mappable_entries
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_enable_ppgtt
argument_list|(
name|dev
argument_list|)
operator|&&
name|HAS_ALIASING_PPGTT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* PPGTT pdes are stolen from global gtt ptes, so shrink the 		 * aperture accordingly when using aliasing ppgtt. */
name|gtt_size
operator|-=
name|I915_PPGTT_PD_ENTRIES
operator|*
name|PAGE_SIZE
expr_stmt|;
name|i915_gem_init_global_gtt
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mappable_size
argument_list|,
name|gtt_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_init_aliasing_ppgtt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
else|else
block|{
comment|/* Let GEM Manage all of the aperture. 		 * 		 * However, leave one page at the end still bound to the scratch 		 * page.  There are a number of places where the hardware 		 * apparently prefetches past the end of the object, and we've 		 * seen multiple hangs with the GPU head pointer stuck in a 		 * batchbuffer bound at the last page of the aperture.  One page 		 * should be enough to keep any prefetching inside of the 		 * aperture. 		 */
name|i915_gem_init_global_gtt
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mappable_size
argument_list|,
name|gtt_size
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|i915_gem_init_hw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|i915_gem_cleanup_aliasing_ppgtt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* Allow hardware batchbuffers unless told otherwise, but not for KMS. */
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
name|dev_priv
operator|->
name|dri1
operator|.
name|allow_batchbuffer
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_cleanup_ringbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
name|intel_cleanup_ring_buffer
argument_list|(
name|ring
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_entervt_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Reenabling wedged hardware, good luck\n"
argument_list|)
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|i915_gem_init_hw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|BUG_ON
argument_list|(
operator|!
name|list_empty
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|active_list
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_irq_install
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup_ringbuffer
goto|;
return|return
literal|0
return|;
name|cleanup_ringbuffer
label|:
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_cleanup_ringbuffer
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
operator|=
literal|1
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_leavevt_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
literal|0
return|;
name|drm_irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|i915_gem_idle
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_lastclose
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return;
name|ret
operator|=
name|i915_gem_idle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to idle hardware: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_ring_lists
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ring
operator|->
name|active_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_load
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|active_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|inactive_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|unbound_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|bound_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|fence_list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I915_NUM_RINGS
condition|;
name|i
operator|++
control|)
name|init_ring_lists
argument_list|(
operator|&
name|dev_priv
operator|->
name|ring
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I915_MAX_NUM_FENCES
condition|;
name|i
operator|++
control|)
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|fence_regs
index|[
name|i
index|]
operator|.
name|lru_list
argument_list|)
expr_stmt|;
name|TIMEOUT_TASK_INIT
argument_list|(
name|dev_priv
operator|->
name|wq
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|retire_work
argument_list|,
literal|0
argument_list|,
name|i915_gem_retire_work_handler
argument_list|,
name|dev_priv
argument_list|)
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion
argument_list|)
expr_stmt|;
comment|/* On GEN3 we really need to make sure the ARB C3 LP bit is set */
if|if
condition|(
name|IS_GEN3
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|MI_ARB_STATE
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|MI_ARB_C3_LP_WRITE_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dev_priv
operator|->
name|relative_constants_mode
operator|=
name|I915_EXEC_CONSTANTS_REL_GENERAL
expr_stmt|;
comment|/* Old X drivers will take 0-2 for front, back, depth buffers */
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
name|dev_priv
operator|->
name|fence_reg_start
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
operator|||
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_G33
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|num_fence_regs
operator|=
literal|16
expr_stmt|;
else|else
name|dev_priv
operator|->
name|num_fence_regs
operator|=
literal|8
expr_stmt|;
comment|/* Initialize fence registers to zero */
name|i915_gem_reset_fences
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_detect_bit_6_swizzle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_INIT_WAITQUEUE
argument_list|(
operator|&
name|dev_priv
operator|->
name|pending_flip_queue
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|true
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|inactive_shrinker
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vm_lowmem
argument_list|,
name|i915_gem_inactive_shrink
argument_list|,
name|dev
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a physically contiguous memory object for this object  * e.g. for cursor + overlay regs  */
end_comment

begin_function
specifier|static
name|int
name|i915_gem_init_phys_object
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_phys_object
modifier|*
name|phys_obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|phys_objs
index|[
name|id
operator|-
literal|1
index|]
operator|||
operator|!
name|size
condition|)
return|return
literal|0
return|;
name|phys_obj
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|drm_i915_gem_phys_object
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phys_obj
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|phys_obj
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|phys_obj
operator|->
name|handle
operator|=
name|drm_pci_alloc
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phys_obj
operator|->
name|handle
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|kfree_obj
goto|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_X86
name|pmap_change_attr
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|phys_obj
operator|->
name|handle
operator|->
name|vaddr
argument_list|,
name|size
operator|/
name|PAGE_SIZE
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dev_priv
operator|->
name|mm
operator|.
name|phys_objs
index|[
name|id
operator|-
literal|1
index|]
operator|=
name|phys_obj
expr_stmt|;
return|return
literal|0
return|;
name|kfree_obj
label|:
name|free
argument_list|(
name|phys_obj
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_free_phys_object
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_phys_object
modifier|*
name|phys_obj
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mm
operator|.
name|phys_objs
index|[
name|id
operator|-
literal|1
index|]
condition|)
return|return;
name|phys_obj
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|phys_objs
index|[
name|id
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|phys_obj
operator|->
name|cur_obj
condition|)
block|{
name|i915_gem_detach_phys_object
argument_list|(
name|dev
argument_list|,
name|phys_obj
operator|->
name|cur_obj
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FREEBSD_WIP
ifdef|#
directive|ifdef
name|CONFIG_X86
name|set_memory_wb
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|phys_obj
operator|->
name|handle
operator|->
name|vaddr
argument_list|,
name|phys_obj
operator|->
name|handle
operator|->
name|size
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|drm_pci_free
argument_list|(
name|dev
argument_list|,
name|phys_obj
operator|->
name|handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|phys_obj
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|phys_objs
index|[
name|id
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_free_all_phys_object
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|I915_GEM_PHYS_CURSOR_0
init|;
name|i
operator|<=
name|I915_MAX_PHYS_OBJECT
condition|;
name|i
operator|++
control|)
name|i915_gem_free_phys_object
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_detach_phys_object
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|char
modifier|*
name|vaddr
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|page_count
decl_stmt|;
if|if
condition|(
operator|!
name|obj
operator|->
name|phys_obj
condition|)
return|return;
name|vaddr
operator|=
name|obj
operator|->
name|phys_obj
operator|->
name|handle
operator|->
name|vaddr
expr_stmt|;
name|page_count
operator|=
name|obj
operator|->
name|base
operator|.
name|size
operator|/
name|PAGE_SIZE
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_count
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|page
init|=
name|i915_gem_wire_page
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|==
name|NULL
condition|)
continue|continue;
comment|/* XXX */
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|page
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|!=
name|NULL
condition|)
block|{
name|dst
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|vaddr
operator|+
name|IDX_TO_OFF
argument_list|(
name|i
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
name|drm_clflush_pages
argument_list|(
operator|&
name|page
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|vm_page_reference
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|page
argument_list|,
name|PQ_INACTIVE
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|i915_gem_wired_pages_cnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|i915_gem_chipset_flush
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|obj
operator|->
name|phys_obj
operator|->
name|cur_obj
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|phys_obj
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_attach_phys_object
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|page_count
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|id
operator|>
name|I915_MAX_PHYS_OBJECT
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|obj
operator|->
name|phys_obj
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|phys_obj
operator|->
name|id
operator|==
name|id
condition|)
return|return
literal|0
return|;
name|i915_gem_detach_phys_object
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
comment|/* create a new object */
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mm
operator|.
name|phys_objs
index|[
name|id
operator|-
literal|1
index|]
condition|)
block|{
name|ret
operator|=
name|i915_gem_init_phys_object
argument_list|(
name|dev
argument_list|,
name|id
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to init phys object %d size: %zu\n"
argument_list|,
name|id
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
comment|/* bind to the object */
name|obj
operator|->
name|phys_obj
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|phys_objs
index|[
name|id
operator|-
literal|1
index|]
expr_stmt|;
name|obj
operator|->
name|phys_obj
operator|->
name|cur_obj
operator|=
name|obj
expr_stmt|;
name|page_count
operator|=
name|obj
operator|->
name|base
operator|.
name|size
operator|/
name|PAGE_SIZE
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_count
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|page
init|=
name|i915_gem_wire_page
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|EIO
expr_stmt|;
break|break;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|page
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|src
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|(
name|char
operator|*
operator|)
name|obj
operator|->
name|phys_obj
operator|->
name|handle
operator|->
name|vaddr
operator|+
name|IDX_TO_OFF
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|vm_page_reference
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|page
argument_list|,
name|PQ_INACTIVE
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|i915_gem_wired_pages_cnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_phys_pwrite
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_i915_gem_pwrite
modifier|*
name|args
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|void
modifier|*
name|vaddr
init|=
operator|(
name|char
operator|*
operator|)
name|obj
operator|->
name|phys_obj
operator|->
name|handle
operator|->
name|vaddr
operator|+
name|args
operator|->
name|offset
decl_stmt|;
name|char
name|__user
modifier|*
name|user_data
init|=
name|to_user_ptr
argument_list|(
name|args
operator|->
name|data_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|__copy_from_user_inatomic_nocache
argument_list|(
name|vaddr
argument_list|,
name|user_data
argument_list|,
name|args
operator|->
name|size
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|unwritten
decl_stmt|;
comment|/* The physical object once assigned is fixed for the lifetime 		 * of the obj, so we can safely drop the lock and continue 		 * to access vaddr. 		 */
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unwritten
operator|=
name|copy_from_user
argument_list|(
name|vaddr
argument_list|,
name|user_data
argument_list|,
name|args
operator|->
name|size
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwritten
condition|)
return|return
operator|-
name|EFAULT
return|;
block|}
name|i915_gem_chipset_flush
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_release
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_file_private
modifier|*
name|file_priv
init|=
name|file
operator|->
name|driver_priv
decl_stmt|;
comment|/* Clean up our request list when the client is going away, so that 	 * later retire_requests won't dereference our soon-to-be-gone 	 * file_priv. 	 */
name|mtx_lock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|request_list
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|request
operator|=
name|list_first_entry
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|request_list
argument_list|,
expr|struct
name|drm_i915_gem_request
argument_list|,
name|client_list
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|request
operator|->
name|client_list
argument_list|)
expr_stmt|;
name|request
operator|->
name|file_priv
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_inactive_shrink
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|arg
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pass1
decl_stmt|,
name|pass2
decl_stmt|;
if|if
condition|(
operator|!
name|sx_try_xlock
argument_list|(
operator|&
name|dev
operator|->
name|dev_struct_lock
argument_list|)
condition|)
block|{
return|return;
block|}
name|CTR0
argument_list|(
name|KTR_DRM
argument_list|,
literal|"gem_lowmem"
argument_list|)
expr_stmt|;
name|pass1
operator|=
name|i915_gem_purge
argument_list|(
name|dev_priv
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pass2
operator|=
name|__i915_gem_shrink
argument_list|(
name|dev_priv
argument_list|,
operator|-
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass2
operator|<=
name|pass1
operator|/
literal|100
condition|)
name|i915_gem_shrink_all
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|i915_gem_wire_page
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|bool
modifier|*
name|fresh
parameter_list|)
block|{
name|vm_page_t
name|page
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|page
operator|=
name|vm_page_grab
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_NOBUSY
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|->
name|valid
operator|!=
name|VM_PAGE_BITS_ALL
condition|)
block|{
name|vm_page_xbusy
argument_list|(
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_pager_has_page
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|rv
operator|=
name|vm_pager_get_pages
argument_list|(
name|object
argument_list|,
operator|&
name|page
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|VM_PAGER_OK
condition|)
block|{
name|vm_page_lock
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|page
argument_list|,
name|PQ_NONE
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|page
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|fresh
operator|!=
name|NULL
condition|)
operator|*
name|fresh
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|pmap_zero_page
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|page
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|page
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fresh
operator|!=
name|NULL
condition|)
operator|*
name|fresh
operator|=
name|false
expr_stmt|;
block|}
name|vm_page_xunbusy
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fresh
operator|!=
name|NULL
condition|)
operator|*
name|fresh
operator|=
name|false
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|i915_gem_wired_pages_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|page
operator|)
return|;
block|}
end_function

end_unit

