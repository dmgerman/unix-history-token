begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright Â© 2008 Intel Corporation  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  *  * Authors:  *    Eric Anholt<eric@anholt.net>  *  * Copyright (c) 2011 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Konstantin Belousov under sponsorship from  * the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/i915_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_drv.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/i915/intel_ringbuffer.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sf_buf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_function_decl
specifier|static
name|void
name|i915_gem_object_flush_cpu_write_domain
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|i915_gem_get_gtt_size
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|int
name|tiling_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|i915_gem_get_gtt_alignment
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|int
name|tiling_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i915_gem_object_bind_to_gtt
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|unsigned
name|alignment
parameter_list|,
name|bool
name|map_and_fenceable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i915_gem_object_get_pages_gtt
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_object_put_pages_gtt
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_object_put_pages_range
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|off_t
name|start
parameter_list|,
name|off_t
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i915_gem_object_get_pages_range
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|off_t
name|start
parameter_list|,
name|off_t
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_object_finish_gtt
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_object_truncate
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i915_gem_object_is_purgeable
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|i915_gem_object_is_inactive
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i915_gem_object_needs_bit17_swizzle
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|i915_gem_wire_page
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|bool
modifier|*
name|fresh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_process_flushing_list
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|uint32_t
name|flush_domains
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_reset_fences
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_retire_task_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_lowmem
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i915_gem_write_fence
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|__wait_seqno
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|u32
name|seqno
parameter_list|,
name|bool
name|interruptible
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i915_gem_check_olr
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|u32
name|seqno
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_I915_GEM
argument_list|,
literal|"i915gem"
argument_list|,
literal|"Allocations from i915 gem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|long
name|i915_gem_wired_pages_cnt
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|cpu_cache_is_coherent
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|enum
name|i915_cache_level
name|level
parameter_list|)
block|{
return|return
name|HAS_LLC
argument_list|(
name|dev
argument_list|)
operator|||
name|level
operator|!=
name|I915_CACHE_NONE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|cpu_write_needs_clflush
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cpu_cache_is_coherent
argument_list|(
name|obj
operator|->
name|base
operator|.
name|dev
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|obj
operator|->
name|pin_display
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|i915_gem_object_fence_lost
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|tiling_mode
condition|)
name|i915_gem_release_mmap
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|/* As we do not have an associated fence register, we will force 	 * a tiling change if we ever need to acquire one. 	 */
name|obj
operator|->
name|fence_dirty
operator|=
name|false
expr_stmt|;
name|obj
operator|->
name|fence_reg
operator|=
name|I915_FENCE_REG_NONE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_info_add_obj
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|dev_priv
operator|->
name|mm
operator|.
name|object_count
operator|++
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|object_memory
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_info_remove_obj
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|dev_priv
operator|->
name|mm
operator|.
name|object_count
operator|--
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|object_memory
operator|-=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_wait_for_error
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
operator|!
name|atomic_load_acq_int
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|dev_priv
operator|->
name|error_completion
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
name|msleep
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion
argument_list|,
operator|&
name|dev_priv
operator|->
name|error_completion_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"915wco"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|ERESTART
condition|)
name|ret
operator|=
operator|-
name|ERESTARTSYS
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion_lock
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|error_completion
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_mutex_lock_interruptible
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|ret
operator|=
name|i915_gem_wait_for_error
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* 	 * interruptible shall it be. might indeed be if dev_lock is 	 * changed to sx 	 */
name|ret
operator|=
name|sx_xlock_sig
argument_list|(
operator|&
name|dev
operator|->
name|dev_struct_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
name|ret
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_free_object
parameter_list|(
name|struct
name|drm_gem_object
modifier|*
name|gem_obj
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
init|=
name|to_intel_bo
argument_list|(
name|gem_obj
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|dev
operator|=
name|obj
operator|->
name|base
operator|.
name|dev
expr_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_destroy_tail %p"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|phys_obj
condition|)
name|i915_gem_detach_phys_object
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pin_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
operator|==
operator|-
name|ERESTARTSYS
condition|)
block|{
name|bool
name|was_interruptible
decl_stmt|;
name|was_interruptible
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
condition|)
name|printf
argument_list|(
literal|"i915_gem_free_object: unbind\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|was_interruptible
expr_stmt|;
block|}
name|drm_gem_free_mmap_offset
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|drm_gem_object_release
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|i915_gem_info_remove_obj
argument_list|(
name|dev_priv
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obj
operator|->
name|bit_17
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obj
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_ring_lists
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ring
operator|->
name|active_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ring
operator|->
name|gpu_write_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_load
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|active_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|flushing_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|inactive_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|fence_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I915_NUM_RINGS
condition|;
name|i
operator|++
control|)
name|init_ring_lists
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I915_MAX_NUM_FENCES
condition|;
name|i
operator|++
control|)
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|fence_regs
index|[
name|i
index|]
operator|.
name|lru_list
argument_list|)
expr_stmt|;
name|TIMEOUT_TASK_INIT
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|retire_task
argument_list|,
literal|0
argument_list|,
name|i915_gem_retire_task_handler
argument_list|,
name|dev_priv
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|error_completion
operator|=
literal|0
expr_stmt|;
comment|/* On GEN3 we really need to make sure the ARB C3 LP bit is set */
if|if
condition|(
name|IS_GEN3
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|I915_WRITE
argument_list|(
name|MI_ARB_STATE
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|MI_ARB_C3_LP_WRITE_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dev_priv
operator|->
name|relative_constants_mode
operator|=
name|I915_EXEC_CONSTANTS_REL_GENERAL
expr_stmt|;
comment|/* Old X drivers will take 0-2 for front, back, depth buffers */
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
name|dev_priv
operator|->
name|fence_reg_start
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
operator|||
name|IS_I945G
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_I945GM
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_G33
argument_list|(
name|dev
argument_list|)
condition|)
name|dev_priv
operator|->
name|num_fence_regs
operator|=
literal|16
expr_stmt|;
else|else
name|dev_priv
operator|->
name|num_fence_regs
operator|=
literal|8
expr_stmt|;
comment|/* Initialize fence registers to zero */
name|i915_gem_reset_fences
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_detect_bit_6_swizzle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
operator|=
name|true
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|i915_lowmem
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vm_lowmem
argument_list|,
name|i915_gem_lowmem
argument_list|,
name|dev
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_init_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_init
modifier|*
name|args
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|ENODEV
return|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|args
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|gtt_start
operator|>=
name|args
operator|->
name|gtt_end
operator|||
operator|(
name|args
operator|->
name|gtt_end
operator||
name|args
operator|->
name|gtt_start
operator|)
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_space
operator|.
name|unused_lock
argument_list|)
condition|)
return|return
operator|(
operator|-
name|EBUSY
operator|)
return|;
comment|/* GEM with user mode setting was never supported on ilk and later. */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|5
condition|)
return|return
operator|-
name|ENODEV
return|;
comment|/* 	 * XXXKIB. The second-time initialization should be guarded 	 * against. 	 */
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|i915_gem_init_global_gtt
argument_list|(
name|dev
argument_list|,
name|args
operator|->
name|gtt_start
argument_list|,
name|args
operator|->
name|gtt_end
argument_list|,
name|args
operator|->
name|gtt_end
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_idle
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ret
operator|=
name|i915_gpu_idle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|i915_gem_retire_requests
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Under UMS, be paranoid and evict. */
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
block|{
name|ret
operator|=
name|i915_gem_evict_everything
argument_list|(
name|dev
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|i915_gem_reset_fences
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Hack!  Don't let anybody do execbuf while we don't control the chip. 	 * We need to replace this with a semaphore, or something. 	 * And not confound mm.suspended! 	 */
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
operator|=
literal|1
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|dev_priv
operator|->
name|hangcheck_timer
argument_list|)
expr_stmt|;
name|i915_kernel_lost_context
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_cleanup_ringbuffer
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Cancel the retire work handler, which should be idle now. */
name|taskqueue_cancel_timeout
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|retire_task
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_init_swizzling
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|5
operator|||
name|dev_priv
operator|->
name|mm
operator|.
name|bit_6_swizzle_x
operator|==
name|I915_BIT_6_SWIZZLE_NONE
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|DISP_ARB_CTL
argument_list|,
name|I915_READ
argument_list|(
name|DISP_ARB_CTL
argument_list|)
operator||
name|DISP_TILE_SURFACE_SWIZZLING
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN5
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|I915_WRITE
argument_list|(
name|TILECTL
argument_list|,
name|I915_READ
argument_list|(
name|TILECTL
argument_list|)
operator||
name|TILECTL_SWZCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_GEN6
argument_list|(
name|dev
argument_list|)
condition|)
name|I915_WRITE
argument_list|(
name|ARB_MODE
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|ARB_MODE_SWIZZLE_SNB
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|I915_WRITE
argument_list|(
name|ARB_MODE
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|ARB_MODE_SWIZZLE_IVB
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_init_ppgtt
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|i915_hw_ppgtt
modifier|*
name|ppgtt
decl_stmt|;
name|uint32_t
name|pd_offset
decl_stmt|,
name|pd_entry
decl_stmt|;
name|vm_paddr_t
name|pt_addr
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|u_int
name|first_pd_entry_in_global_pt
decl_stmt|,
name|i
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|ppgtt
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
expr_stmt|;
if|if
condition|(
name|ppgtt
operator|==
name|NULL
condition|)
return|return;
name|first_pd_entry_in_global_pt
operator|=
literal|512
operator|*
literal|1024
operator|-
name|I915_PPGTT_PD_ENTRIES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppgtt
operator|->
name|num_pd_entries
condition|;
name|i
operator|++
control|)
block|{
name|pt_addr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|ppgtt
operator|->
name|pt_pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pd_entry
operator|=
name|GEN6_PDE_ADDR_ENCODE
argument_list|(
name|pt_addr
argument_list|)
expr_stmt|;
name|pd_entry
operator||=
name|GEN6_PDE_VALID
expr_stmt|;
name|intel_gtt_write
argument_list|(
name|first_pd_entry_in_global_pt
operator|+
name|i
argument_list|,
name|pd_entry
argument_list|)
expr_stmt|;
block|}
name|intel_gtt_read_pte
argument_list|(
name|first_pd_entry_in_global_pt
argument_list|)
expr_stmt|;
name|pd_offset
operator|=
name|ppgtt
operator|->
name|pd_offset
expr_stmt|;
name|pd_offset
operator|/=
literal|64
expr_stmt|;
comment|/* in cachelines, */
name|pd_offset
operator|<<=
literal|16
expr_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|==
literal|6
condition|)
block|{
name|uint32_t
name|ecochk
decl_stmt|,
name|gab_ctl
decl_stmt|,
name|ecobits
decl_stmt|;
name|ecobits
operator|=
name|I915_READ
argument_list|(
name|GAC_ECO_BITS
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GAC_ECO_BITS
argument_list|,
name|ecobits
operator||
name|ECOBITS_PPGTT_CACHE64B
argument_list|)
expr_stmt|;
name|gab_ctl
operator|=
name|I915_READ
argument_list|(
name|GAB_CTL
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GAB_CTL
argument_list|,
name|gab_ctl
operator||
name|GAB_CTL_CONT_AFTER_PAGEFAULT
argument_list|)
expr_stmt|;
name|ecochk
operator|=
name|I915_READ
argument_list|(
name|GAM_ECOCHK
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GAM_ECOCHK
argument_list|,
name|ecochk
operator||
name|ECOCHK_SNB_BIT
operator||
name|ECOCHK_PPGTT_CACHE64B
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|GFX_MODE
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|GFX_PPGTT_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|7
condition|)
block|{
name|I915_WRITE
argument_list|(
name|GAM_ECOCHK
argument_list|,
name|ECOCHK_PPGTT_CACHE64B
argument_list|)
expr_stmt|;
comment|/* GFX_MODE is per-ring on gen7+ */
block|}
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|7
condition|)
name|I915_WRITE
argument_list|(
name|RING_MODE_GEN7
argument_list|(
name|ring
argument_list|)
argument_list|,
name|_MASKED_BIT_ENABLE
argument_list|(
name|GFX_PPGTT_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RING_PP_DIR_DCLV
argument_list|(
name|ring
argument_list|)
argument_list|,
name|PP_DIR_DCLV_2G
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|RING_PP_DIR_BASE
argument_list|(
name|ring
argument_list|)
argument_list|,
name|pd_offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|i915_gem_init_hw
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|i915_gem_init_swizzling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|intel_init_render_ring_buffer
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|HAS_BSD
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ret
operator|=
name|intel_init_bsd_ring_buffer
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup_render_ring
goto|;
block|}
if|if
condition|(
name|HAS_BLT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ret
operator|=
name|intel_init_blt_ring_buffer
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup_bsd_ring
goto|;
block|}
name|dev_priv
operator|->
name|next_seqno
operator|=
literal|1
expr_stmt|;
name|i915_gem_context_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_init_ppgtt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup_bsd_ring
label|:
name|intel_cleanup_ring_buffer
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|VCS
index|]
argument_list|)
expr_stmt|;
name|cleanup_render_ring
label|:
name|intel_cleanup_ring_buffer
argument_list|(
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|RCS
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|intel_enable_ppgtt
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|i915_enable_ppgtt
operator|>=
literal|0
condition|)
return|return
name|i915_enable_ppgtt
return|;
comment|/* Disable ppgtt on SNB if VT-d is on. */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|==
literal|6
operator|&&
name|intel_iommu_enabled
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|unsigned
name|long
name|gtt_size
decl_stmt|,
name|mappable_size
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|gtt_size
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|.
name|gtt_total_entries
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|mappable_size
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt
operator|.
name|gtt_mappable_entries
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_enable_ppgtt
argument_list|(
name|dev
argument_list|)
operator|&&
name|HAS_ALIASING_PPGTT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* PPGTT pdes are stolen from global gtt ptes, so shrink the 		 * aperture accordingly when using aliasing ppgtt. */
name|gtt_size
operator|-=
name|I915_PPGTT_PD_ENTRIES
operator|*
name|PAGE_SIZE
expr_stmt|;
name|i915_gem_init_global_gtt
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mappable_size
argument_list|,
name|gtt_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_init_aliasing_ppgtt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
else|else
block|{
comment|/* Let GEM Manage all of the aperture. 		 * 		 * However, leave one page at the end still bound to the scratch 		 * page.  There are a number of places where the hardware 		 * apparently prefetches past the end of the object, and we've 		 * seen multiple hangs with the GPU head pointer stuck in a 		 * batchbuffer bound at the last page of the aperture.  One page 		 * should be enough to keep any prefetching inside of the 		 * aperture. 		 */
name|i915_gem_init_global_gtt
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mappable_size
argument_list|,
name|gtt_size
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|i915_gem_init_hw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|i915_gem_cleanup_aliasing_ppgtt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Allow hardware batchbuffers unless told otherwise, but not for KMS. */
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
name|dev_priv
operator|->
name|dri1
operator|.
name|allow_batchbuffer
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_get_aperture_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_i915_gem_get_aperture
modifier|*
name|args
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|size_t
name|pinned
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|args
operator|=
name|data
expr_stmt|;
name|pinned
operator|=
literal|0
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|&dev_priv->mm.gtt_list
argument_list|,
argument|gtt_list
argument_list|)
if|if
condition|(
name|obj
operator|->
name|pin_count
condition|)
name|pinned
operator|+=
name|obj
operator|->
name|gtt_space
operator|->
name|size
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|args
operator|->
name|aper_size
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_total
expr_stmt|;
name|args
operator|->
name|aper_available_size
operator|=
name|args
operator|->
name|aper_size
operator|-
name|pinned
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_pin
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|uint32_t
name|alignment
parameter_list|,
name|bool
name|map_and_fenceable
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|pin_count
operator|==
name|DRM_I915_GEM_OBJECT_MAX_PIN_COUNT
condition|)
return|return
operator|(
operator|-
name|EBUSY
operator|)
return|;
if|if
condition|(
name|obj
operator|->
name|gtt_space
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|alignment
operator|&&
name|obj
operator|->
name|gtt_offset
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|map_and_fenceable
operator|&&
operator|!
name|obj
operator|->
name|map_and_fenceable
operator|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"bo is already pinned with incorrect alignment:"
literal|" offset=%x, req.alignment=%x, req.map_and_fenceable=%d,"
literal|" obj->map_and_fenceable=%d\n"
argument_list|,
name|obj
operator|->
name|gtt_offset
argument_list|,
name|alignment
argument_list|,
name|map_and_fenceable
argument_list|,
name|obj
operator|->
name|map_and_fenceable
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
if|if
condition|(
name|obj
operator|->
name|gtt_space
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_bind_to_gtt
argument_list|(
name|obj
argument_list|,
name|alignment
argument_list|,
name|map_and_fenceable
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|obj
operator|->
name|has_global_gtt_mapping
operator|&&
name|map_and_fenceable
condition|)
name|i915_gem_gtt_bind_object
argument_list|(
name|obj
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pin_count
operator|++
expr_stmt|;
name|obj
operator|->
name|pin_mappable
operator||=
name|map_and_fenceable
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_object_unpin
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|obj
operator|->
name|pin_count
operator|!=
literal|0
argument_list|,
operator|(
literal|"zero pin count"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|obj
operator|->
name|gtt_space
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No gtt mapping"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|obj
operator|->
name|pin_count
operator|==
literal|0
condition|)
name|obj
operator|->
name|pin_mappable
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_pin_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_pin
modifier|*
name|args
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_gem_object
modifier|*
name|gobj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|args
operator|=
name|data
expr_stmt|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
name|gobj
operator|=
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|gobj
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|gobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|madv
operator|!=
name|I915_MADV_WILLNEED
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Attempting to pin a purgeable buffer\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|pin_filp
operator|!=
name|NULL
operator|&&
name|obj
operator|->
name|pin_filp
operator|!=
name|file
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Already pinned in i915_gem_pin_ioctl(): %d\n"
argument_list|,
name|args
operator|->
name|handle
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|obj
operator|->
name|user_pin_count
operator|++
expr_stmt|;
name|obj
operator|->
name|pin_filp
operator|=
name|file
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|user_pin_count
operator|==
literal|1
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_pin
argument_list|(
name|obj
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* XXX - flush the CPU caches for pinned objects 	 * as the X server doesn't manage domains yet 	 */
name|i915_gem_object_flush_cpu_write_domain
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|args
operator|->
name|offset
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
name|out
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_unpin_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_pin
modifier|*
name|args
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|args
operator|=
name|data
expr_stmt|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|pin_filp
operator|!=
name|file
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Not pinned by caller in i915_gem_pin_ioctl(): %d\n"
argument_list|,
name|args
operator|->
name|handle
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|obj
operator|->
name|user_pin_count
operator|--
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|user_pin_count
operator|==
literal|0
condition|)
block|{
name|obj
operator|->
name|pin_filp
operator|=
name|NULL
expr_stmt|;
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_busy_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_busy
modifier|*
name|args
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|args
operator|=
name|data
expr_stmt|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|args
operator|->
name|busy
operator|=
name|obj
operator|->
name|active
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|busy
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
name|I915_GEM_GPU_DOMAINS
condition|)
block|{
name|ret
operator|=
name|i915_gem_flush_ring
argument_list|(
name|obj
operator|->
name|ring
argument_list|,
literal|0
argument_list|,
name|obj
operator|->
name|base
operator|.
name|write_domain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|i915_gem_check_olr
argument_list|(
name|obj
operator|->
name|ring
argument_list|,
name|obj
operator|->
name|last_rendering_seqno
argument_list|)
expr_stmt|;
block|}
name|i915_gem_retire_requests_ring
argument_list|(
name|obj
operator|->
name|ring
argument_list|)
expr_stmt|;
name|args
operator|->
name|busy
operator|=
name|obj
operator|->
name|active
expr_stmt|;
block|}
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_ring_throttle
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_i915_file_private
modifier|*
name|file_priv
decl_stmt|;
name|unsigned
name|long
name|recent_enough
decl_stmt|;
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|u32
name|seqno
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
condition|)
return|return
operator|(
operator|-
name|EIO
operator|)
return|;
name|file_priv
operator|=
name|file
operator|->
name|driver_priv
expr_stmt|;
name|recent_enough
operator|=
name|ticks
operator|-
operator|(
literal|20
operator|*
name|hz
operator|/
literal|1000
operator|)
expr_stmt|;
name|ring
operator|=
name|NULL
expr_stmt|;
name|seqno
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lck
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|request
argument_list|,
argument|&file_priv->mm.request_list
argument_list|,
argument|client_list
argument_list|)
block|{
if|if
condition|(
name|time_after_eq
argument_list|(
name|request
operator|->
name|emitted_jiffies
argument_list|,
name|recent_enough
argument_list|)
condition|)
break|break;
name|ring
operator|=
name|request
operator|->
name|ring
expr_stmt|;
name|seqno
operator|=
name|request
operator|->
name|seqno
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lck
argument_list|)
expr_stmt|;
if|if
condition|(
name|seqno
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ret
operator|=
name|__wait_seqno
argument_list|(
name|ring
argument_list|,
name|seqno
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|taskqueue_enqueue_timeout
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|retire_task
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_throttle_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
return|return
operator|(
name|i915_gem_ring_throttle
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_madvise_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_i915_gem_madvise
modifier|*
name|args
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|args
operator|=
name|data
expr_stmt|;
switch|switch
condition|(
name|args
operator|->
name|madv
condition|)
block|{
case|case
name|I915_MADV_DONTNEED
case|:
case|case
name|I915_MADV_WILLNEED
case|:
break|break;
default|default:
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|pin_count
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|madv
operator|!=
name|I915_MADV_PURGED_INTERNAL
condition|)
name|obj
operator|->
name|madv
operator|=
name|args
operator|->
name|madv
expr_stmt|;
if|if
condition|(
name|i915_gem_object_is_purgeable
argument_list|(
name|obj
argument_list|)
operator|&&
name|obj
operator|->
name|gtt_space
operator|==
name|NULL
condition|)
name|i915_gem_object_truncate
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|args
operator|->
name|retained
operator|=
name|obj
operator|->
name|madv
operator|!=
name|I915_MADV_PURGED_INTERNAL
expr_stmt|;
name|out
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_cleanup_ringbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
name|intel_cleanup_ring_buffer
argument_list|(
name|ring
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_entervt_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Reenabling wedged hardware, good luck\n"
argument_list|)
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|i915_gem_init_hw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|list_empty
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|active_list
argument_list|)
argument_list|,
operator|(
literal|"active list"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|list_empty
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|flushing_list
argument_list|)
argument_list|,
operator|(
literal|"flushing list"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|list_empty
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|inactive_list
argument_list|)
argument_list|,
operator|(
literal|"inactive list"
operator|)
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_irq_install
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup_ringbuffer
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup_ringbuffer
label|:
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i915_gem_cleanup_ringbuffer
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
operator|=
literal|1
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_leavevt_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
literal|0
return|;
name|drm_irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|i915_gem_idle
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_create
parameter_list|(
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint32_t
modifier|*
name|handle_p
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|uint32_t
name|handle
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
name|obj
operator|=
name|i915_gem_alloc_object
argument_list|(
name|dev
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|ret
operator|=
name|drm_gem_handle_create
argument_list|(
name|file
argument_list|,
operator|&
name|obj
operator|->
name|base
argument_list|,
operator|&
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|drm_gem_object_release
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|i915_gem_info_remove_obj
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obj
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* drop reference from allocate - handle holds it now */
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_create %p %x"
argument_list|,
name|obj
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|*
name|handle_p
operator|=
name|handle
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_dumb_create
parameter_list|(
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_mode_create_dumb
modifier|*
name|args
parameter_list|)
block|{
comment|/* have to work out size/pitch and return them */
name|args
operator|->
name|pitch
operator|=
name|roundup2
argument_list|(
name|args
operator|->
name|width
operator|*
operator|(
operator|(
name|args
operator|->
name|bpp
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|args
operator|->
name|size
operator|=
name|args
operator|->
name|pitch
operator|*
name|args
operator|->
name|height
expr_stmt|;
return|return
operator|(
name|i915_gem_create
argument_list|(
name|file
argument_list|,
name|dev
argument_list|,
name|args
operator|->
name|size
argument_list|,
operator|&
name|args
operator|->
name|handle
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_dumb_destroy
parameter_list|(
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|handle
parameter_list|)
block|{
return|return
operator|(
name|drm_gem_handle_delete
argument_list|(
name|file
argument_list|,
name|handle
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_create_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_create
modifier|*
name|args
init|=
name|data
decl_stmt|;
return|return
operator|(
name|i915_gem_create
argument_list|(
name|file
argument_list|,
name|dev
argument_list|,
name|args
operator|->
name|size
argument_list|,
operator|&
name|args
operator|->
name|handle
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|__user
end_define

begin_define
define|#
directive|define
name|__force
end_define

begin_define
define|#
directive|define
name|__iomem
end_define

begin_define
define|#
directive|define
name|to_user_ptr
parameter_list|(
name|x
parameter_list|)
value|((void *)(uintptr_t)(x))
end_define

begin_define
define|#
directive|define
name|offset_in_page
parameter_list|(
name|x
parameter_list|)
value|((x)& PAGE_MASK)
end_define

begin_define
define|#
directive|define
name|page_to_phys
parameter_list|(
name|x
parameter_list|)
value|VM_PAGE_TO_PHYS(x)
end_define

begin_function
specifier|static
specifier|inline
name|int
name|__copy_to_user_inatomic
parameter_list|(
name|void
name|__user
modifier|*
name|to
parameter_list|,
specifier|const
name|void
modifier|*
name|from
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
return|return
operator|(
name|copyout_nofault
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|n
argument_list|)
operator|!=
literal|0
condition|?
name|n
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|__copy_from_user_inatomic_nocache
parameter_list|(
name|void
modifier|*
name|to
parameter_list|,
specifier|const
name|void
name|__user
modifier|*
name|from
parameter_list|,
name|unsigned
name|long
name|n
parameter_list|)
block|{
comment|/* 	 * XXXKIB.  Equivalent Linux function is implemented using 	 * MOVNTI for aligned moves.  For unaligned head and tail, 	 * normal move is performed.  As such, it is not incorrect, if 	 * only somewhat slower, to use normal copyin.  All uses 	 * except shmem_pwrite_fast() have the destination mapped WC. 	 */
return|return
operator|(
operator|(
name|copyin_nofault
argument_list|(
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|from
argument_list|)
argument_list|,
name|to
argument_list|,
name|n
argument_list|)
operator|!=
literal|0
condition|?
name|n
else|:
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|fault_in_multipages_readable
parameter_list|(
specifier|const
name|char
name|__user
modifier|*
name|uaddr
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|char
name|__user
modifier|*
name|end
init|=
name|uaddr
operator|+
name|size
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|==
literal|0
argument_list|)
condition|)
return|return
name|ret
return|;
while|while
condition|(
name|uaddr
operator|<=
name|end
condition|)
block|{
name|ret
operator|=
operator|-
name|copyin
argument_list|(
name|uaddr
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|-
name|EFAULT
return|;
name|uaddr
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
comment|/* Check whether the range spilled into the next page. */
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|uaddr
operator|&
operator|~
name|PAGE_MASK
operator|)
operator|==
operator|(
operator|(
name|unsigned
name|long
operator|)
name|end
operator|&
operator|~
name|PAGE_MASK
operator|)
condition|)
block|{
name|ret
operator|=
operator|-
name|copyin
argument_list|(
name|end
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|fault_in_multipages_writeable
parameter_list|(
name|char
name|__user
modifier|*
name|uaddr
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
name|__user
modifier|*
name|end
init|=
name|uaddr
operator|+
name|size
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|==
literal|0
argument_list|)
condition|)
return|return
name|ret
return|;
comment|/* 	 * Writing zeroes into userspace here is OK, because we know that if 	 * the zero gets there, we'll be overwriting it. 	 */
while|while
condition|(
name|uaddr
operator|<=
name|end
condition|)
block|{
name|ret
operator|=
name|subyte
argument_list|(
name|uaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|-
name|EFAULT
return|;
name|uaddr
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
comment|/* Check whether the range spilled into the next page. */
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|uaddr
operator|&
operator|~
name|PAGE_MASK
operator|)
operator|==
operator|(
operator|(
name|unsigned
name|long
operator|)
name|end
operator|&
operator|~
name|PAGE_MASK
operator|)
condition|)
name|ret
operator|=
name|subyte
argument_list|(
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|__copy_to_user_swizzled
parameter_list|(
name|char
name|__user
modifier|*
name|cpu_vaddr
parameter_list|,
specifier|const
name|char
modifier|*
name|gpu_vaddr
parameter_list|,
name|int
name|gpu_offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|cpu_offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|int
name|cacheline_end
init|=
name|roundup2
argument_list|(
name|gpu_offset
operator|+
literal|1
argument_list|,
literal|64
argument_list|)
decl_stmt|;
name|int
name|this_length
init|=
name|min
argument_list|(
name|cacheline_end
operator|-
name|gpu_offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|int
name|swizzled_gpu_offset
init|=
name|gpu_offset
operator|^
literal|64
decl_stmt|;
name|ret
operator|=
name|__copy_to_user
argument_list|(
name|cpu_vaddr
operator|+
name|cpu_offset
argument_list|,
name|gpu_vaddr
operator|+
name|swizzled_gpu_offset
argument_list|,
name|this_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
operator|+
name|length
return|;
name|cpu_offset
operator|+=
name|this_length
expr_stmt|;
name|gpu_offset
operator|+=
name|this_length
expr_stmt|;
name|length
operator|-=
name|this_length
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|__copy_from_user_swizzled
parameter_list|(
name|char
modifier|*
name|gpu_vaddr
parameter_list|,
name|int
name|gpu_offset
parameter_list|,
specifier|const
name|char
name|__user
modifier|*
name|cpu_vaddr
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|cpu_offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|int
name|cacheline_end
init|=
name|roundup2
argument_list|(
name|gpu_offset
operator|+
literal|1
argument_list|,
literal|64
argument_list|)
decl_stmt|;
name|int
name|this_length
init|=
name|min
argument_list|(
name|cacheline_end
operator|-
name|gpu_offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|int
name|swizzled_gpu_offset
init|=
name|gpu_offset
operator|^
literal|64
decl_stmt|;
name|ret
operator|=
name|__copy_from_user
argument_list|(
name|gpu_vaddr
operator|+
name|swizzled_gpu_offset
argument_list|,
name|cpu_vaddr
operator|+
name|cpu_offset
argument_list|,
name|this_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
operator|+
name|length
return|;
name|cpu_offset
operator|+=
name|this_length
expr_stmt|;
name|gpu_offset
operator|+=
name|this_length
expr_stmt|;
name|length
operator|-=
name|this_length
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_phys_pwrite
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_i915_gem_pwrite
modifier|*
name|args
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|void
modifier|*
name|vaddr
init|=
operator|(
name|char
operator|*
operator|)
name|obj
operator|->
name|phys_obj
operator|->
name|handle
operator|->
name|vaddr
operator|+
name|args
operator|->
name|offset
decl_stmt|;
name|char
name|__user
modifier|*
name|user_data
init|=
name|to_user_ptr
argument_list|(
name|args
operator|->
name|data_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|__copy_from_user_inatomic_nocache
argument_list|(
name|vaddr
argument_list|,
name|user_data
argument_list|,
name|args
operator|->
name|size
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|unwritten
decl_stmt|;
comment|/* The physical object once assigned is fixed for the lifetime 		 * of the obj, so we can safely drop the lock and continue 		 * to access vaddr. 		 */
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unwritten
operator|=
name|copy_from_user
argument_list|(
name|vaddr
argument_list|,
name|user_data
argument_list|,
name|args
operator|->
name|size
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwritten
condition|)
return|return
operator|-
name|EFAULT
return|;
block|}
name|i915_gem_chipset_flush
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Per-page copy function for the shmem pread fastpath.  * Flushes invalid cachelines before reading the target if  * needs_clflush is set. */
end_comment

begin_function
specifier|static
name|int
name|shmem_pread_fast
parameter_list|(
name|vm_page_t
name|page
parameter_list|,
name|int
name|shmem_page_offset
parameter_list|,
name|int
name|page_length
parameter_list|,
name|char
name|__user
modifier|*
name|user_data
parameter_list|,
name|bool
name|page_do_bit17_swizzling
parameter_list|,
name|bool
name|needs_clflush
parameter_list|)
block|{
name|char
modifier|*
name|vaddr
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|page_do_bit17_swizzling
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sched_pin
argument_list|()
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|page
argument_list|,
name|SFB_NOWAIT
operator||
name|SFB_CPUPRIVATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|==
name|NULL
condition|)
block|{
name|sched_unpin
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
name|EFAULT
operator|)
return|;
block|}
name|vaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_clflush
condition|)
name|drm_clflush_virt_range
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__copy_to_user_inatomic
argument_list|(
name|user_data
argument_list|,
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
return|return
name|ret
condition|?
operator|-
name|EFAULT
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|shmem_clflush_swizzled_range
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|,
name|unsigned
name|long
name|length
parameter_list|,
name|bool
name|swizzled
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|swizzled
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|start
init|=
operator|(
name|unsigned
name|long
operator|)
name|addr
decl_stmt|;
name|unsigned
name|long
name|end
init|=
operator|(
name|unsigned
name|long
operator|)
name|addr
operator|+
name|length
decl_stmt|;
comment|/* For swizzling simply ensure that we always flush both 		 * channels. Lame, but simple and it works. Swizzled 		 * pwrite/pread is far from a hotpath - current userspace 		 * doesn't use it at all. */
name|start
operator|=
name|rounddown2
argument_list|(
name|start
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|end
operator|=
name|roundup2
argument_list|(
name|end
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|drm_clflush_virt_range
argument_list|(
operator|(
name|void
operator|*
operator|)
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drm_clflush_virt_range
argument_list|(
name|addr
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Only difference to the fast-path function is that this can handle bit17  * and uses non-atomic copy and kmap functions. */
end_comment

begin_function
specifier|static
name|int
name|shmem_pread_slow
parameter_list|(
name|vm_page_t
name|page
parameter_list|,
name|int
name|shmem_page_offset
parameter_list|,
name|int
name|page_length
parameter_list|,
name|char
name|__user
modifier|*
name|user_data
parameter_list|,
name|bool
name|page_do_bit17_swizzling
parameter_list|,
name|bool
name|needs_clflush
parameter_list|)
block|{
name|char
modifier|*
name|vaddr
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|page
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_clflush
condition|)
name|shmem_clflush_swizzled_range
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|,
name|page_do_bit17_swizzling
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_do_bit17_swizzling
condition|)
name|ret
operator|=
name|__copy_to_user_swizzled
argument_list|(
name|user_data
argument_list|,
name|vaddr
argument_list|,
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|__copy_to_user
argument_list|(
name|user_data
argument_list|,
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
return|return
name|ret
condition|?
operator|-
name|EFAULT
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_shmem_pread
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_i915_gem_pread
modifier|*
name|args
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|char
name|__user
modifier|*
name|user_data
decl_stmt|;
name|ssize_t
name|remain
decl_stmt|,
name|sremain
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|soffset
decl_stmt|;
name|int
name|shmem_page_offset
decl_stmt|,
name|page_length
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|obj_do_bit17_swizzling
decl_stmt|,
name|page_do_bit17_swizzling
decl_stmt|;
name|int
name|prefaulted
init|=
literal|0
decl_stmt|;
name|int
name|needs_clflush
init|=
literal|0
decl_stmt|;
name|user_data
operator|=
name|to_user_ptr
argument_list|(
name|args
operator|->
name|data_ptr
argument_list|)
expr_stmt|;
name|sremain
operator|=
name|remain
operator|=
name|args
operator|->
name|size
expr_stmt|;
name|obj_do_bit17_swizzling
operator|=
name|i915_gem_object_needs_bit17_swizzle
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_DOMAIN_CPU
operator|)
condition|)
block|{
comment|/* If we're not in the cpu read domain, set ourself into the gtt 		 * read domain and manually flush cachelines (if required). This 		 * optimizes for the case when the gpu will dirty the data 		 * anyway again before the next pread happens. */
name|needs_clflush
operator|=
operator|!
name|cpu_cache_is_coherent
argument_list|(
name|dev
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|obj
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|soffset
operator|=
name|offset
operator|=
name|args
operator|->
name|offset
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_get_pages_range
argument_list|(
name|obj
argument_list|,
name|soffset
argument_list|,
name|soffset
operator|+
name|sremain
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_object_pin_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|vm_page_t
name|page
init|=
name|vm_page_find_least
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
argument_list|)
init|;
condition|;
name|page
operator|=
name|vm_page_next
argument_list|(
name|page
argument_list|)
control|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|remain
operator|<=
literal|0
condition|)
break|break;
comment|/* Operation in this page 		 * 		 * shmem_page_offset = offset within page in shmem file 		 * page_length = bytes to copy for this page 		 */
name|shmem_page_offset
operator|=
name|offset_in_page
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|page_length
operator|=
name|remain
expr_stmt|;
if|if
condition|(
operator|(
name|shmem_page_offset
operator|+
name|page_length
operator|)
operator|>
name|PAGE_SIZE
condition|)
name|page_length
operator|=
name|PAGE_SIZE
operator|-
name|shmem_page_offset
expr_stmt|;
name|page_do_bit17_swizzling
operator|=
name|obj_do_bit17_swizzling
operator|&&
operator|(
name|page_to_phys
argument_list|(
name|page
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|17
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|ret
operator|=
name|shmem_pread_fast
argument_list|(
name|page
argument_list|,
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|,
name|user_data
argument_list|,
name|page_do_bit17_swizzling
argument_list|,
name|needs_clflush
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
goto|goto
name|next_page
goto|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
operator|!
name|i915_prefault_disable
argument_list|)
operator|&&
operator|!
name|prefaulted
condition|)
block|{
name|ret
operator|=
name|fault_in_multipages_writeable
argument_list|(
name|user_data
argument_list|,
name|remain
argument_list|)
expr_stmt|;
comment|/* Userspace is tricking us, but we've already clobbered 			 * its pages with the prefault and promised to write the 			 * data up to the first fault. Hence ignore any errors 			 * and just continue. */
operator|(
name|void
operator|)
name|ret
expr_stmt|;
name|prefaulted
operator|=
literal|1
expr_stmt|;
block|}
name|ret
operator|=
name|shmem_pread_slow
argument_list|(
name|page
argument_list|,
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|,
name|user_data
argument_list|,
name|page_do_bit17_swizzling
argument_list|,
name|needs_clflush
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|next_page
label|:
name|vm_page_reference
argument_list|(
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|remain
operator|-=
name|page_length
expr_stmt|;
name|user_data
operator|+=
name|page_length
expr_stmt|;
name|offset
operator|+=
name|page_length
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|i915_gem_object_unpin_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|i915_gem_object_put_pages_range
argument_list|(
name|obj
argument_list|,
name|soffset
argument_list|,
name|soffset
operator|+
name|sremain
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Reads data from the object referenced by handle.  *  * On error, the contents of *data are undefined.  */
end_comment

begin_function
name|int
name|i915_gem_pread_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_pread
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|useracc
argument_list|(
name|to_user_ptr
argument_list|(
name|args
operator|->
name|data_ptr
argument_list|)
argument_list|,
name|args
operator|->
name|size
argument_list|,
name|VM_PROT_WRITE
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* Bounds check source.  */
if|if
condition|(
name|args
operator|->
name|offset
operator|>
name|obj
operator|->
name|base
operator|.
name|size
operator|||
name|args
operator|->
name|size
operator|>
name|obj
operator|->
name|base
operator|.
name|size
operator|-
name|args
operator|->
name|offset
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|#
directive|if
literal|1
name|KIB_NOTYET
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* prime objects have no backing filp to GEM pread/pwrite 	 * pages from. 	 */
if|if
condition|(
operator|!
name|obj
operator|->
name|base
operator|.
name|filp
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"pread %p %jx %jx"
argument_list|,
name|obj
argument_list|,
name|args
operator|->
name|offset
argument_list|,
name|args
operator|->
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_shmem_pread
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|args
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|out
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* This is the fast write path which cannot handle  * page faults in the source data  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|fast_user_write
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|off_t
name|page_base
parameter_list|,
name|int
name|page_offset
parameter_list|,
name|char
name|__user
modifier|*
name|user_data
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|void
name|__iomem
modifier|*
name|vaddr_atomic
decl_stmt|;
name|void
modifier|*
name|vaddr
decl_stmt|;
name|unsigned
name|long
name|unwritten
decl_stmt|;
name|vaddr_atomic
operator|=
name|pmap_mapdev_attr
argument_list|(
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|page_base
argument_list|,
name|length
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
comment|/* We can use the cpu mem copy function because this is X86. */
name|vaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|vaddr_atomic
operator|+
name|page_offset
expr_stmt|;
name|unwritten
operator|=
name|__copy_from_user_inatomic_nocache
argument_list|(
name|vaddr
argument_list|,
name|user_data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vaddr_atomic
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|unwritten
return|;
block|}
end_function

begin_comment
comment|/**  * This is the fast pwrite path, where we copy the data directly from the  * user into the GTT, uncached.  */
end_comment

begin_function
specifier|static
name|int
name|i915_gem_gtt_pwrite_fast
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_i915_gem_pwrite
modifier|*
name|args
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|ssize_t
name|remain
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|page_base
decl_stmt|;
name|char
name|__user
modifier|*
name|user_data
decl_stmt|;
name|int
name|page_offset
decl_stmt|,
name|page_length
decl_stmt|,
name|ret
decl_stmt|;
name|ret
operator|=
name|i915_gem_object_pin
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* XXXKIB ret = i915_gem_obj_ggtt_pin(obj, 0, true, true); */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|obj
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out_unpin
goto|;
name|ret
operator|=
name|i915_gem_object_put_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out_unpin
goto|;
name|user_data
operator|=
name|to_user_ptr
argument_list|(
name|args
operator|->
name|data_ptr
argument_list|)
expr_stmt|;
name|remain
operator|=
name|args
operator|->
name|size
expr_stmt|;
name|offset
operator|=
name|obj
operator|->
name|gtt_offset
operator|+
name|args
operator|->
name|offset
expr_stmt|;
while|while
condition|(
name|remain
operator|>
literal|0
condition|)
block|{
comment|/* Operation in this page 		 * 		 * page_base = page offset within aperture 		 * page_offset = offset within page 		 * page_length = bytes to copy for this page 		 */
name|page_base
operator|=
name|offset
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
name|page_offset
operator|=
name|offset_in_page
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|page_length
operator|=
name|remain
expr_stmt|;
if|if
condition|(
operator|(
name|page_offset
operator|+
name|remain
operator|)
operator|>
name|PAGE_SIZE
condition|)
name|page_length
operator|=
name|PAGE_SIZE
operator|-
name|page_offset
expr_stmt|;
comment|/* If we get a fault while copying data, then (presumably) our 		 * source page isn't available.  Return the error and we'll 		 * retry in the slow path. 		 */
if|if
condition|(
name|fast_user_write
argument_list|(
name|dev
argument_list|,
name|page_base
argument_list|,
name|page_offset
argument_list|,
name|user_data
argument_list|,
name|page_length
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|out_unpin
goto|;
block|}
name|remain
operator|-=
name|page_length
expr_stmt|;
name|user_data
operator|+=
name|page_length
expr_stmt|;
name|offset
operator|+=
name|page_length
expr_stmt|;
block|}
name|out_unpin
label|:
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Per-page copy function for the shmem pwrite fastpath.  * Flushes invalid cachelines before writing to the target if  * needs_clflush_before is set and flushes out any written cachelines after  * writing if needs_clflush is set. */
end_comment

begin_function
specifier|static
name|int
name|shmem_pwrite_fast
parameter_list|(
name|vm_page_t
name|page
parameter_list|,
name|int
name|shmem_page_offset
parameter_list|,
name|int
name|page_length
parameter_list|,
name|char
name|__user
modifier|*
name|user_data
parameter_list|,
name|bool
name|page_do_bit17_swizzling
parameter_list|,
name|bool
name|needs_clflush_before
parameter_list|,
name|bool
name|needs_clflush_after
parameter_list|)
block|{
name|char
modifier|*
name|vaddr
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|page_do_bit17_swizzling
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sched_pin
argument_list|()
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|page
argument_list|,
name|SFB_NOWAIT
operator||
name|SFB_CPUPRIVATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|==
name|NULL
condition|)
block|{
name|sched_unpin
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
name|EFAULT
operator|)
return|;
block|}
name|vaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_clflush_before
condition|)
name|drm_clflush_virt_range
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__copy_from_user_inatomic_nocache
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|user_data
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_clflush_after
condition|)
name|drm_clflush_virt_range
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
return|return
name|ret
condition|?
operator|-
name|EFAULT
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Only difference to the fast-path function is that this can handle bit17  * and uses non-atomic copy and kmap functions. */
end_comment

begin_function
specifier|static
name|int
name|shmem_pwrite_slow
parameter_list|(
name|vm_page_t
name|page
parameter_list|,
name|int
name|shmem_page_offset
parameter_list|,
name|int
name|page_length
parameter_list|,
name|char
name|__user
modifier|*
name|user_data
parameter_list|,
name|bool
name|page_do_bit17_swizzling
parameter_list|,
name|bool
name|needs_clflush_before
parameter_list|,
name|bool
name|needs_clflush_after
parameter_list|)
block|{
name|char
modifier|*
name|vaddr
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|page
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|needs_clflush_before
operator|||
name|page_do_bit17_swizzling
argument_list|)
condition|)
name|shmem_clflush_swizzled_range
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|,
name|page_do_bit17_swizzling
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_do_bit17_swizzling
condition|)
name|ret
operator|=
name|__copy_from_user_swizzled
argument_list|(
name|vaddr
argument_list|,
name|shmem_page_offset
argument_list|,
name|user_data
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|__copy_from_user
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|user_data
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_clflush_after
condition|)
name|shmem_clflush_swizzled_range
argument_list|(
name|vaddr
operator|+
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|,
name|page_do_bit17_swizzling
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
return|return
name|ret
condition|?
operator|-
name|EFAULT
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_shmem_pwrite
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_i915_gem_pwrite
modifier|*
name|args
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|ssize_t
name|remain
decl_stmt|,
name|sremain
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|soffset
decl_stmt|;
name|char
name|__user
modifier|*
name|user_data
decl_stmt|;
name|int
name|shmem_page_offset
decl_stmt|,
name|page_length
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|obj_do_bit17_swizzling
decl_stmt|,
name|page_do_bit17_swizzling
decl_stmt|;
name|int
name|hit_slowpath
init|=
literal|0
decl_stmt|;
name|int
name|needs_clflush_after
init|=
literal|0
decl_stmt|;
name|int
name|needs_clflush_before
init|=
literal|0
decl_stmt|;
name|user_data
operator|=
name|to_user_ptr
argument_list|(
name|args
operator|->
name|data_ptr
argument_list|)
expr_stmt|;
name|sremain
operator|=
name|remain
operator|=
name|args
operator|->
name|size
expr_stmt|;
name|obj_do_bit17_swizzling
operator|=
name|i915_gem_object_needs_bit17_swizzle
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|!=
name|I915_GEM_DOMAIN_CPU
condition|)
block|{
comment|/* If we're not in the cpu write domain, set ourself into the gtt 		 * write domain and manually flush cachelines (if required). This 		 * optimizes for the case when the gpu will use the data 		 * right away and we therefore have to clflush anyway. */
name|needs_clflush_after
operator|=
name|cpu_write_needs_clflush
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|obj
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
comment|/* Same trick applies to invalidate partially written cachelines read 	 * before writing. */
if|if
condition|(
operator|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_DOMAIN_CPU
operator|)
operator|==
literal|0
condition|)
name|needs_clflush_before
operator|=
operator|!
name|cpu_cache_is_coherent
argument_list|(
name|dev
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
name|soffset
operator|=
name|offset
operator|=
name|args
operator|->
name|offset
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_get_pages_range
argument_list|(
name|obj
argument_list|,
name|soffset
argument_list|,
name|soffset
operator|+
name|sremain
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_object_pin_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|vm_page_t
name|page
init|=
name|vm_page_find_least
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
argument_list|)
init|;
condition|;
name|page
operator|=
name|vm_page_next
argument_list|(
name|page
argument_list|)
control|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|int
name|partial_cacheline_write
decl_stmt|;
if|if
condition|(
name|remain
operator|<=
literal|0
condition|)
break|break;
comment|/* Operation in this page 		 * 		 * shmem_page_offset = offset within page in shmem file 		 * page_length = bytes to copy for this page 		 */
name|shmem_page_offset
operator|=
name|offset_in_page
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|page_length
operator|=
name|remain
expr_stmt|;
if|if
condition|(
operator|(
name|shmem_page_offset
operator|+
name|page_length
operator|)
operator|>
name|PAGE_SIZE
condition|)
name|page_length
operator|=
name|PAGE_SIZE
operator|-
name|shmem_page_offset
expr_stmt|;
comment|/* If we don't overwrite a cacheline completely we need to be 		 * careful to have up-to-date data by first clflushing. Don't 		 * overcomplicate things and flush the entire patch. */
name|partial_cacheline_write
operator|=
name|needs_clflush_before
operator|&&
operator|(
operator|(
name|shmem_page_offset
operator||
name|page_length
operator|)
operator|&
operator|(
name|cpu_clflush_line_size
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|page_do_bit17_swizzling
operator|=
name|obj_do_bit17_swizzling
operator|&&
operator|(
name|page_to_phys
argument_list|(
name|page
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|17
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|ret
operator|=
name|shmem_pwrite_fast
argument_list|(
name|page
argument_list|,
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|,
name|user_data
argument_list|,
name|page_do_bit17_swizzling
argument_list|,
name|partial_cacheline_write
argument_list|,
name|needs_clflush_after
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
goto|goto
name|next_page
goto|;
name|hit_slowpath
operator|=
literal|1
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|shmem_pwrite_slow
argument_list|(
name|page
argument_list|,
name|shmem_page_offset
argument_list|,
name|page_length
argument_list|,
name|user_data
argument_list|,
name|page_do_bit17_swizzling
argument_list|,
name|partial_cacheline_write
argument_list|,
name|needs_clflush_after
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|next_page
label|:
name|vm_page_dirty
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|vm_page_reference
argument_list|(
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|remain
operator|-=
name|page_length
expr_stmt|;
name|user_data
operator|+=
name|page_length
expr_stmt|;
name|offset
operator|+=
name|page_length
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|i915_gem_object_unpin_pages
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|i915_gem_object_put_pages_range
argument_list|(
name|obj
argument_list|,
name|soffset
argument_list|,
name|soffset
operator|+
name|sremain
argument_list|)
expr_stmt|;
if|if
condition|(
name|hit_slowpath
condition|)
block|{
comment|/* 		 * Fixup: Flush cpu caches in case we didn't flush the dirty 		 * cachelines in-line while writing and the object moved 		 * out of the cpu write domain while we've dropped the lock. 		 */
if|if
condition|(
operator|!
name|needs_clflush_after
operator|&&
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|!=
name|I915_GEM_DOMAIN_CPU
condition|)
block|{
name|i915_gem_clflush_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|i915_gem_chipset_flush
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needs_clflush_after
condition|)
name|i915_gem_chipset_flush
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Writes data to the object referenced by handle.  *  * On error, the contents of the buffer that were to be modified are undefined.  */
end_comment

begin_function
name|int
name|i915_gem_pwrite_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_pwrite
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|useracc
argument_list|(
name|to_user_ptr
argument_list|(
name|args
operator|->
name|data_ptr
argument_list|)
argument_list|,
name|args
operator|->
name|size
argument_list|,
name|VM_PROT_READ
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
if|if
condition|(
name|likely
argument_list|(
operator|!
name|i915_prefault_disable
argument_list|)
condition|)
block|{
name|ret
operator|=
name|fault_in_multipages_readable
argument_list|(
name|to_user_ptr
argument_list|(
name|args
operator|->
name|data_ptr
argument_list|)
argument_list|,
name|args
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|-
name|EFAULT
return|;
block|}
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* Bounds check destination. */
if|if
condition|(
name|args
operator|->
name|offset
operator|>
name|obj
operator|->
name|base
operator|.
name|size
operator|||
name|args
operator|->
name|size
operator|>
name|obj
operator|->
name|base
operator|.
name|size
operator|-
name|args
operator|->
name|offset
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|#
directive|if
literal|1
name|KIB_NOTYET
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* prime objects have no backing filp to GEM pread/pwrite 	 * pages from. 	 */
if|if
condition|(
operator|!
name|obj
operator|->
name|base
operator|.
name|filp
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"pwrite %p %jx %jx"
argument_list|,
name|obj
argument_list|,
name|args
operator|->
name|offset
argument_list|,
name|args
operator|->
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
comment|/* We can only do the GTT pwrite on untiled buffers, as otherwise 	 * it would end up going through the fenced access, and we'll get 	 * different detiling behavior between reading and writing. 	 * pread/pwrite currently are reading and writing from the CPU 	 * perspective, requiring manual detiling by the client. 	 */
if|if
condition|(
name|obj
operator|->
name|phys_obj
condition|)
block|{
name|ret
operator|=
name|i915_gem_phys_pwrite
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|args
argument_list|,
name|file
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_NONE
operator|&&
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|!=
name|I915_GEM_DOMAIN_CPU
operator|&&
name|cpu_write_needs_clflush
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|ret
operator|=
name|i915_gem_gtt_pwrite_fast
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|args
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Note that the gtt paths might fail with non-page-backed user 		 * pointers (e.g. gtt mappings when moving data between 		 * textures). Fallback to the shmem path in that case. */
block|}
if|if
condition|(
name|ret
operator|==
operator|-
name|EFAULT
operator|||
name|ret
operator|==
operator|-
name|ENOSPC
condition|)
name|ret
operator|=
name|i915_gem_shmem_pwrite
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|,
name|args
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|out
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|__user
end_undef

begin_undef
undef|#
directive|undef
name|__force
end_undef

begin_undef
undef|#
directive|undef
name|__iomem
end_undef

begin_undef
undef|#
directive|undef
name|to_user_ptr
end_undef

begin_undef
undef|#
directive|undef
name|offset_in_page
end_undef

begin_undef
undef|#
directive|undef
name|page_to_phys
end_undef

begin_function
name|int
name|i915_gem_set_domain_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_set_domain
modifier|*
name|args
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|uint32_t
name|read_domains
decl_stmt|;
name|uint32_t
name|write_domain
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|args
operator|=
name|data
expr_stmt|;
name|read_domains
operator|=
name|args
operator|->
name|read_domains
expr_stmt|;
name|write_domain
operator|=
name|args
operator|->
name|write_domain
expr_stmt|;
if|if
condition|(
operator|(
name|write_domain
operator|&
name|I915_GEM_GPU_DOMAINS
operator|)
operator|!=
literal|0
operator|||
operator|(
name|read_domains
operator|&
name|I915_GEM_GPU_DOMAINS
operator|)
operator|!=
literal|0
operator|||
operator|(
name|write_domain
operator|!=
literal|0
operator|&&
name|read_domains
operator|!=
name|write_domain
operator|)
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
operator|(
name|read_domains
operator|&
name|I915_GEM_DOMAIN_GTT
operator|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|obj
argument_list|,
name|write_domain
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|EINVAL
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|i915_gem_object_set_to_cpu_domain
argument_list|(
name|obj
argument_list|,
name|write_domain
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_sw_finish_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_sw_finish
modifier|*
name|args
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|args
operator|=
name|data
expr_stmt|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|pin_count
operator|!=
literal|0
condition|)
name|i915_gem_object_flush_cpu_write_domain
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_mmap_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_gem_mmap
modifier|*
name|args
decl_stmt|;
name|struct
name|drm_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rv
decl_stmt|;
name|args
operator|=
name|data
expr_stmt|;
name|obj
operator|=
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|args
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOENT
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|size
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|p
operator|=
name|curproc
expr_stmt|;
name|map
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|args
operator|->
name|size
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|size
operator|+
name|size
operator|>
name|lim_cur_proc
argument_list|(
name|p
argument_list|,
name|RLIMIT_VMEM
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
name|vm_object_reference
argument_list|(
name|obj
operator|->
name|vm_obj
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_find
argument_list|(
name|map
argument_list|,
name|obj
operator|->
name|vm_obj
argument_list|,
name|args
operator|->
name|offset
argument_list|,
operator|&
name|addr
argument_list|,
name|args
operator|->
name|size
argument_list|,
literal|0
argument_list|,
name|VMFS_OPTIMAL_SPACE
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|MAP_INHERIT_SHARE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|obj
operator|->
name|vm_obj
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
name|vm_mmap_to_errno
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|args
operator|->
name|addr_ptr
operator|=
operator|(
name|uint64_t
operator|)
name|addr
expr_stmt|;
block|}
name|out
label|:
name|drm_gem_object_unreference
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_pager_ctor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_ooffset_t
name|foff
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|u_short
modifier|*
name|color
parameter_list|)
block|{
operator|*
name|color
operator|=
literal|0
expr_stmt|;
comment|/* XXXKIB */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|i915_intr_pf
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i915_gem_pager_fault
parameter_list|(
name|vm_object_t
name|vm_obj
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|int
name|prot
parameter_list|,
name|vm_page_t
modifier|*
name|mres
parameter_list|)
block|{
name|struct
name|drm_gem_object
modifier|*
name|gem_obj
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|oldm
decl_stmt|;
name|int
name|cause
decl_stmt|,
name|ret
decl_stmt|;
name|bool
name|write
decl_stmt|;
name|gem_obj
operator|=
name|vm_obj
operator|->
name|handle
expr_stmt|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|gem_obj
argument_list|)
expr_stmt|;
name|dev
operator|=
name|obj
operator|->
name|base
operator|.
name|dev
expr_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
if|#
directive|if
literal|0
block|write = (prot& VM_PROT_WRITE) != 0;
else|#
directive|else
name|write
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
name|vm_object_pip_add
argument_list|(
name|vm_obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the placeholder page inserted by vm_fault() from the 	 * object before dropping the object lock. If 	 * i915_gem_release_mmap() is active in parallel on this gem 	 * object, then it owns the drm device sx and might find the 	 * placeholder already. Then, since the page is busy, 	 * i915_gem_release_mmap() sleeps waiting for the busy state 	 * of the page cleared. We will be not able to acquire drm 	 * device lock until i915_gem_release_mmap() is able to make a 	 * progress. 	 */
if|if
condition|(
operator|*
name|mres
operator|!=
name|NULL
condition|)
block|{
name|oldm
operator|=
operator|*
name|mres
expr_stmt|;
name|vm_page_lock
argument_list|(
name|oldm
argument_list|)
expr_stmt|;
name|vm_page_remove
argument_list|(
name|oldm
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|oldm
argument_list|)
expr_stmt|;
operator|*
name|mres
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|oldm
operator|=
name|NULL
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|retry
label|:
name|cause
operator|=
name|ret
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i915_intr_pf
condition|)
block|{
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|cause
operator|=
literal|10
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Since the object lock was dropped, other thread might have 	 * faulted on the same GTT address and instantiated the 	 * mapping for the page.  Recheck. 	 */
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|vm_obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vm_page_busied
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|vm_page_busy_sleep
argument_list|(
name|m
argument_list|,
literal|"915pee"
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
goto|goto
name|have_page
goto|;
block|}
else|else
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
comment|/* Now bind it into the GTT if needed */
if|if
condition|(
operator|!
name|obj
operator|->
name|map_and_fenceable
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|cause
operator|=
literal|20
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|obj
operator|->
name|gtt_space
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_bind_to_gtt
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|cause
operator|=
literal|30
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|ret
operator|=
name|i915_gem_object_set_to_gtt_domain
argument_list|(
name|obj
argument_list|,
name|write
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|cause
operator|=
literal|40
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|obj
operator|->
name|has_global_gtt_mapping
condition|)
name|i915_gem_gtt_bind_object
argument_list|(
name|obj
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_get_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|cause
operator|=
literal|50
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
name|i915_gem_object_is_inactive
argument_list|(
name|obj
argument_list|)
condition|)
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|mm_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|inactive_list
argument_list|)
expr_stmt|;
name|obj
operator|->
name|fault_mappable
operator|=
name|true
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|obj
operator|->
name|gtt_offset
operator|+
name|offset
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"physical address %#jx not fictitious"
operator|,
call|(
name|uintmax_t
call|)
argument_list|(
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|obj
operator|->
name|gtt_offset
operator|+
name|offset
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|cause
operator|=
literal|60
expr_stmt|;
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"not fictitious %p"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|wire_count
operator|==
literal|1
argument_list|,
operator|(
literal|"wire_count not 1 %p"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_page_busied
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|vm_page_busy_sleep
argument_list|(
name|m
argument_list|,
literal|"915pbs"
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|vm_page_insert
argument_list|(
name|m
argument_list|,
name|vm_obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
argument_list|)
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|VM_WAIT
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|have_page
label|:
operator|*
name|mres
operator|=
name|m
expr_stmt|;
name|vm_page_xbusy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_DRM
argument_list|,
literal|"fault %p %jx %x phys %x"
argument_list|,
name|gem_obj
argument_list|,
name|offset
argument_list|,
name|prot
argument_list|,
name|m
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldm
operator|!=
name|NULL
condition|)
block|{
name|vm_page_lock
argument_list|(
name|oldm
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|oldm
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|oldm
argument_list|)
expr_stmt|;
block|}
name|vm_object_pip_wakeup
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|VM_PAGER_OK
operator|)
return|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|out
label|:
name|KASSERT
argument_list|(
name|ret
operator|!=
literal|0
argument_list|,
operator|(
literal|"i915_gem_pager_fault: wrong return"
operator|)
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_DRM
argument_list|,
literal|"fault_fail %p %jx %x err %d %d"
argument_list|,
name|gem_obj
argument_list|,
name|offset
argument_list|,
name|prot
argument_list|,
operator|-
name|ret
argument_list|,
name|cause
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|EAGAIN
operator|||
name|ret
operator|==
operator|-
name|EIO
operator|||
name|ret
operator|==
operator|-
name|EINTR
condition|)
block|{
name|kern_yield
argument_list|(
name|PRI_USER
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|vm_object_pip_wakeup
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|VM_PAGER_ERROR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_pager_dtor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|drm_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|obj
operator|=
name|handle
expr_stmt|;
name|dev
operator|=
name|obj
operator|->
name|dev
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|drm_gem_free_mmap_offset
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|i915_gem_release_mmap
argument_list|(
name|to_intel_bo
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|cdev_pager_ops
name|i915_gem_pager_ops
init|=
block|{
operator|.
name|cdev_pg_fault
operator|=
name|i915_gem_pager_fault
block|,
operator|.
name|cdev_pg_ctor
operator|=
name|i915_gem_pager_ctor
block|,
operator|.
name|cdev_pg_dtor
operator|=
name|i915_gem_pager_dtor
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|i915_gem_mmap_gtt
parameter_list|(
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|handle
parameter_list|,
name|uint64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|ret
operator|=
name|i915_mutex_lock_interruptible
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|obj
operator|=
name|to_intel_bo
argument_list|(
name|drm_gem_object_lookup
argument_list|(
name|dev
argument_list|,
name|file
argument_list|,
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|obj
operator|->
name|base
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOENT
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|size
operator|>
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mappable_end
condition|)
block|{
name|ret
operator|=
operator|-
name|E2BIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|madv
operator|!=
name|I915_MADV_WILLNEED
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Attempting to mmap a purgeable buffer\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|drm_gem_create_mmap_offset
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
operator|*
name|offset
operator|=
name|DRM_GEM_MAPPING_OFF
argument_list|(
name|obj
operator|->
name|base
operator|.
name|map_list
operator|.
name|key
argument_list|)
operator||
name|DRM_GEM_MAPPING_KEY
expr_stmt|;
name|out
label|:
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|unlock
label|:
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_mmap_gtt_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_i915_gem_mmap_gtt
modifier|*
name|args
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|args
operator|=
name|data
expr_stmt|;
return|return
operator|(
name|i915_gem_mmap_gtt
argument_list|(
name|file
argument_list|,
name|dev
argument_list|,
name|args
operator|->
name|handle
argument_list|,
operator|&
name|args
operator|->
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|drm_i915_gem_object
modifier|*
name|i915_gem_alloc_object
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|obj
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|obj
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|drm_gem_object_init
argument_list|(
name|dev
argument_list|,
operator|&
name|obj
operator|->
name|base
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|obj
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
if|if
condition|(
name|HAS_LLC
argument_list|(
name|dev
argument_list|)
condition|)
name|obj
operator|->
name|cache_level
operator|=
name|I915_CACHE_LLC
expr_stmt|;
else|else
name|obj
operator|->
name|cache_level
operator|=
name|I915_CACHE_NONE
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|driver_private
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|fence_reg
operator|=
name|I915_FENCE_REG_NONE
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|obj
operator|->
name|mm_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|obj
operator|->
name|gtt_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|obj
operator|->
name|ring_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|obj
operator|->
name|exec_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|obj
operator|->
name|gpu_write_list
argument_list|)
expr_stmt|;
name|obj
operator|->
name|madv
operator|=
name|I915_MADV_WILLNEED
expr_stmt|;
comment|/* Avoid an unnecessary call to unbind on the first bind. */
name|obj
operator|->
name|map_and_fenceable
operator|=
name|true
expr_stmt|;
name|i915_gem_info_add_obj
argument_list|(
name|dev_priv
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|obj
operator|)
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_clflush_object
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
comment|/* If we don't have a page list set up, then we're not pinned 	 * to GPU, and we can ignore the cache flush because it'll happen 	 * again at bind time. 	 */
if|if
condition|(
name|obj
operator|->
name|pages
operator|==
name|NULL
condition|)
return|return;
comment|/* If the GPU is snooping the contents of the CPU cache, 	 * we do not need to manually clear the CPU cache lines.  However, 	 * the caches are only snooped when the render cache is 	 * flushed/invalidated.  As we always have to emit invalidations 	 * and flushes when moving into and out of the RENDER domain, correct 	 * snooping behaviour occurs naturally as the result of our domain 	 * tracking. 	 */
if|if
condition|(
name|obj
operator|->
name|cache_level
operator|!=
name|I915_CACHE_NONE
condition|)
return|return;
name|CTR1
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_clflush %p"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|drm_clflush_pages
argument_list|(
name|obj
operator|->
name|pages
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_flush_cpu_write_domain
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|uint32_t
name|old_write_domain
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|!=
name|I915_GEM_DOMAIN_CPU
condition|)
return|return;
name|i915_gem_clflush_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|intel_gtt_chipset_flush
argument_list|()
expr_stmt|;
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
literal|0
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain flush_cpu_write %p %x %x"
argument_list|,
name|obj
argument_list|,
name|obj
operator|->
name|base
operator|.
name|read_domains
argument_list|,
name|old_write_domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_object_flush_gpu_write_domain
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
name|I915_GEM_GPU_DOMAINS
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|i915_gem_flush_ring
argument_list|(
name|obj
operator|->
name|ring
argument_list|,
literal|0
argument_list|,
name|obj
operator|->
name|base
operator|.
name|write_domain
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_flush_gtt_write_domain
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|uint32_t
name|old_write_domain
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|!=
name|I915_GEM_DOMAIN_GTT
condition|)
return|return;
name|wmb
argument_list|()
expr_stmt|;
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
literal|0
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain flush gtt_write %p %x %x"
argument_list|,
name|obj
argument_list|,
name|obj
operator|->
name|base
operator|.
name|read_domains
argument_list|,
name|old_write_domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_set_to_gtt_domain
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|bool
name|write
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|old_write_domain
decl_stmt|,
name|old_read_domains
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|gtt_space
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|==
name|I915_GEM_DOMAIN_GTT
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|i915_gem_object_flush_gpu_write_domain
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|obj
operator|->
name|pending_gpu_write
operator|||
name|write
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_wait_rendering
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|i915_gem_object_flush_cpu_write_domain
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|old_read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|read_domains
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
operator|~
name|I915_GEM_DOMAIN_GTT
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"In GTT write domain"
operator|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator||=
name|I915_GEM_DOMAIN_GTT
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|=
name|I915_GEM_DOMAIN_GTT
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
name|I915_GEM_DOMAIN_GTT
expr_stmt|;
name|obj
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
block|}
comment|/* And bump the LRU for this access */
if|if
condition|(
name|i915_gem_object_is_inactive
argument_list|(
name|obj
argument_list|)
condition|)
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|mm_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|inactive_list
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain set_to_gtt %p %x %x"
argument_list|,
name|obj
argument_list|,
name|old_read_domains
argument_list|,
name|old_write_domain
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_set_cache_level
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|enum
name|i915_cache_level
name|cache_level
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|cache_level
operator|==
name|cache_level
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|obj
operator|->
name|pin_count
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"can not change the cache level of pinned objects\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EBUSY
operator|)
return|;
block|}
name|dev
operator|=
name|obj
operator|->
name|base
operator|.
name|dev
expr_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|gtt_space
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_finish_gpu
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|i915_gem_object_finish_gtt
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|/* Before SandyBridge, you could not use tiling or fence 		 * registers with snooped memory, so relinquish any fences 		 * currently pointing to our region in the aperture. 		 */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|obj
operator|->
name|base
operator|.
name|dev
argument_list|)
operator|->
name|gen
operator|<
literal|6
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_put_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|has_global_gtt_mapping
condition|)
name|i915_gem_gtt_bind_object
argument_list|(
name|obj
argument_list|,
name|cache_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|has_aliasing_ppgtt_mapping
condition|)
name|i915_ppgtt_bind_object
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
argument_list|,
name|obj
argument_list|,
name|cache_level
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cache_level
operator|==
name|I915_CACHE_NONE
condition|)
block|{
name|u32
name|old_read_domains
decl_stmt|,
name|old_write_domain
decl_stmt|;
comment|/* If we're coming from LLC cached, then we haven't 		 * actually been tracking whether the data is in the 		 * CPU cache or not, since we only allow one bit set 		 * in obj->write_domain and have been skipping the clflushes. 		 * Just set it to the CPU cache for now. 		 */
name|KASSERT
argument_list|(
operator|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
operator|~
name|I915_GEM_DOMAIN_CPU
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"obj %p in CPU write domain"
operator|,
name|obj
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
operator|~
name|I915_GEM_DOMAIN_CPU
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"obj %p in CPU read domain"
operator|,
name|obj
operator|)
argument_list|)
expr_stmt|;
name|old_read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|read_domains
expr_stmt|;
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain set_cache_level %p %x %x"
argument_list|,
name|obj
argument_list|,
name|old_read_domains
argument_list|,
name|old_write_domain
argument_list|)
expr_stmt|;
block|}
name|obj
operator|->
name|cache_level
operator|=
name|cache_level
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|is_pin_display
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
comment|/* There are 3 sources that pin objects: 	 *   1. The display engine (scanouts, sprites, cursors); 	 *   2. Reservations for execbuffer; 	 *   3. The user. 	 * 	 * We can ignore reservations as we hold the struct_mutex and 	 * are only called outside of the reservation path.  The user 	 * can only increment pin_count once, and so if after 	 * subtracting the potential reference by the user, any pin_count 	 * remains, it must be due to another use by the display engine. 	 */
return|return
name|obj
operator|->
name|pin_count
operator|-
operator|!
operator|!
name|obj
operator|->
name|user_pin_count
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_pin_to_display_plane
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|u32
name|alignment
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|pipelined
parameter_list|)
block|{
name|u32
name|old_read_domains
decl_stmt|,
name|old_write_domain
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|i915_gem_object_flush_gpu_write_domain
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|pipelined
operator|!=
name|obj
operator|->
name|ring
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_sync
argument_list|(
name|obj
argument_list|,
name|pipelined
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|obj
operator|->
name|pin_display
operator|=
name|true
expr_stmt|;
name|ret
operator|=
name|i915_gem_object_set_cache_level
argument_list|(
name|obj
argument_list|,
name|I915_CACHE_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|err_unpin_display
goto|;
name|ret
operator|=
name|i915_gem_object_pin
argument_list|(
name|obj
argument_list|,
name|alignment
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|err_unpin_display
goto|;
name|i915_gem_object_flush_cpu_write_domain
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|old_read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|read_domains
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
operator|~
name|I915_GEM_DOMAIN_GTT
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"obj %p in GTT write domain"
operator|,
name|obj
operator|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator||=
name|I915_GEM_DOMAIN_GTT
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain pin_to_display_plan %p %x %x"
argument_list|,
name|obj
argument_list|,
name|old_read_domains
argument_list|,
name|obj
operator|->
name|base
operator|.
name|write_domain
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_unpin_display
label|:
name|obj
operator|->
name|pin_display
operator|=
name|is_pin_display
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_object_unpin_from_display_plane
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|i915_gem_object_unpin
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pin_display
operator|=
name|is_pin_display
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_finish_gpu
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_GPU_DOMAINS
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
name|I915_GEM_GPU_DOMAINS
condition|)
block|{
name|ret
operator|=
name|i915_gem_flush_ring
argument_list|(
name|obj
operator|->
name|ring
argument_list|,
literal|0
argument_list|,
name|obj
operator|->
name|base
operator|.
name|write_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|ret
operator|=
name|i915_gem_object_wait_rendering
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&=
operator|~
name|I915_GEM_GPU_DOMAINS
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_set_to_cpu_domain
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|bool
name|write
parameter_list|)
block|{
name|uint32_t
name|old_write_domain
decl_stmt|,
name|old_read_domains
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|==
name|I915_GEM_DOMAIN_CPU
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|i915_gem_object_flush_gpu_write_domain
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|write
operator|||
name|obj
operator|->
name|pending_gpu_write
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_wait_rendering
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|i915_gem_object_flush_gtt_write_domain
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|old_read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|read_domains
expr_stmt|;
if|if
condition|(
operator|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_DOMAIN_CPU
operator|)
operator|==
literal|0
condition|)
block|{
name|i915_gem_clflush_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator||=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
operator|~
name|I915_GEM_DOMAIN_CPU
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"In cpu write domain"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain set_to_cpu %p %x %x"
argument_list|,
name|obj
argument_list|,
name|old_read_domains
argument_list|,
name|old_write_domain
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|i915_gem_get_gtt_size
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|int
name|tiling_mode
parameter_list|)
block|{
name|uint32_t
name|gtt_size
decl_stmt|;
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
operator|||
name|tiling_mode
operator|==
name|I915_TILING_NONE
condition|)
return|return
operator|(
name|size
operator|)
return|;
comment|/* Previous chips need a power-of-two fence region when tiling */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|==
literal|3
condition|)
name|gtt_size
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
else|else
name|gtt_size
operator|=
literal|512
operator|*
literal|1024
expr_stmt|;
while|while
condition|(
name|gtt_size
operator|<
name|size
condition|)
name|gtt_size
operator|<<=
literal|1
expr_stmt|;
return|return
operator|(
name|gtt_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * i915_gem_get_gtt_alignment - return required GTT alignment for an object  * @obj: object to check  *  * Return the required GTT alignment for an object, taking into account  * potential fence register mapping.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|i915_gem_get_gtt_alignment
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|int
name|tiling_mode
parameter_list|)
block|{
comment|/* 	 * Minimum alignment is 4k (GTT page size), but might be greater 	 * if a fence register is needed for the object. 	 */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
operator|||
name|tiling_mode
operator|==
name|I915_TILING_NONE
condition|)
return|return
operator|(
literal|4096
operator|)
return|;
comment|/* 	 * Previous chips need to be aligned to the size of the smallest 	 * fence register that can contain the object. 	 */
return|return
operator|(
name|i915_gem_get_gtt_size
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|tiling_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|i915_gem_get_unfenced_gtt_alignment
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|int
name|tiling_mode
parameter_list|)
block|{
if|if
condition|(
name|tiling_mode
operator|==
name|I915_TILING_NONE
condition|)
return|return
operator|(
literal|4096
operator|)
return|;
comment|/* 	 * Minimum alignment is 4k (GTT page size) for sane hw. 	 */
if|if
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
operator|>=
literal|4
operator|||
name|IS_G33
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|4096
operator|)
return|;
comment|/* 	 * Previous hardware however needs to be aligned to a power-of-two 	 * tile height. The simplest method for determining this is to reuse 	 * the power-of-tile object size.          */
return|return
operator|(
name|i915_gem_get_gtt_size
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|tiling_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_object_bind_to_gtt
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|unsigned
name|alignment
parameter_list|,
name|bool
name|map_and_fenceable
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_mm_node
modifier|*
name|free_space
decl_stmt|;
name|uint32_t
name|size
decl_stmt|,
name|fence_size
decl_stmt|,
name|fence_alignment
decl_stmt|,
name|unfenced_alignment
decl_stmt|;
name|bool
name|mappable
decl_stmt|,
name|fenceable
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dev
operator|=
name|obj
operator|->
name|base
operator|.
name|dev
expr_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|madv
operator|!=
name|I915_MADV_WILLNEED
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Attempting to bind a purgeable object\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
name|fence_size
operator|=
name|i915_gem_get_gtt_size
argument_list|(
name|dev
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|,
name|obj
operator|->
name|tiling_mode
argument_list|)
expr_stmt|;
name|fence_alignment
operator|=
name|i915_gem_get_gtt_alignment
argument_list|(
name|dev
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|,
name|obj
operator|->
name|tiling_mode
argument_list|)
expr_stmt|;
name|unfenced_alignment
operator|=
name|i915_gem_get_unfenced_gtt_alignment
argument_list|(
name|dev
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|,
name|obj
operator|->
name|tiling_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignment
operator|==
literal|0
condition|)
name|alignment
operator|=
name|map_and_fenceable
condition|?
name|fence_alignment
else|:
name|unfenced_alignment
expr_stmt|;
if|if
condition|(
name|map_and_fenceable
operator|&&
operator|(
name|alignment
operator|&
operator|(
name|fence_alignment
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid object alignment requested %u\n"
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
name|size
operator|=
name|map_and_fenceable
condition|?
name|fence_size
else|:
name|obj
operator|->
name|base
operator|.
name|size
expr_stmt|;
comment|/* If the object is bigger than the entire aperture, reject it early 	 * before evicting everything in a vain attempt to find space. 	 */
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|size
operator|>
operator|(
name|map_and_fenceable
condition|?
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mappable_end
else|:
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_total
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Attempting to bind an object larger than the aperture\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|E2BIG
operator|)
return|;
block|}
name|search_free
label|:
if|if
condition|(
name|map_and_fenceable
condition|)
name|free_space
operator|=
name|drm_mm_search_free_in_range
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_space
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mappable_end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|free_space
operator|=
name|drm_mm_search_free
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_space
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_space
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|map_and_fenceable
condition|)
name|obj
operator|->
name|gtt_space
operator|=
name|drm_mm_get_block_range_generic
argument_list|(
name|free_space
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mappable_end
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|obj
operator|->
name|gtt_space
operator|=
name|drm_mm_get_block_generic
argument_list|(
name|free_space
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|->
name|gtt_space
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|i915_gem_evict_something
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
name|map_and_fenceable
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
goto|goto
name|search_free
goto|;
block|}
name|ret
operator|=
name|i915_gem_object_get_pages_gtt
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|drm_mm_put_block
argument_list|(
name|obj
operator|->
name|gtt_space
argument_list|)
expr_stmt|;
name|obj
operator|->
name|gtt_space
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * i915_gem_object_get_pages_gtt() cannot return 		 * ENOMEM, since we use vm_page_grab(). 		 */
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|ret
operator|=
name|i915_gem_gtt_prepare_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|i915_gem_object_put_pages_gtt
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|drm_mm_put_block
argument_list|(
name|obj
operator|->
name|gtt_space
argument_list|)
expr_stmt|;
name|obj
operator|->
name|gtt_space
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i915_gem_evict_everything
argument_list|(
name|dev
argument_list|,
name|false
argument_list|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
goto|goto
name|search_free
goto|;
block|}
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
condition|)
name|i915_gem_gtt_bind_object
argument_list|(
name|obj
argument_list|,
name|obj
operator|->
name|cache_level
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|obj
operator|->
name|gtt_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_list
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|obj
operator|->
name|mm_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|inactive_list
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_GPU_DOMAINS
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Object in gpu read domain"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
name|I915_GEM_GPU_DOMAINS
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Object in gpu write domain"
operator|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|gtt_offset
operator|=
name|obj
operator|->
name|gtt_space
operator|->
name|start
expr_stmt|;
name|fenceable
operator|=
name|obj
operator|->
name|gtt_space
operator|->
name|size
operator|==
name|fence_size
operator|&&
operator|(
name|obj
operator|->
name|gtt_space
operator|->
name|start
operator|&
operator|(
name|fence_alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
expr_stmt|;
name|mappable
operator|=
name|obj
operator|->
name|gtt_offset
operator|+
name|obj
operator|->
name|base
operator|.
name|size
operator|<=
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_mappable_end
expr_stmt|;
name|obj
operator|->
name|map_and_fenceable
operator|=
name|mappable
operator|&&
name|fenceable
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_bind %p %x %x %d"
argument_list|,
name|obj
argument_list|,
name|obj
operator|->
name|gtt_offset
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|,
name|map_and_fenceable
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_sync
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|to
parameter_list|)
block|{
name|struct
name|intel_ring_buffer
modifier|*
name|from
init|=
name|obj
operator|->
name|ring
decl_stmt|;
name|u32
name|seqno
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|idx
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|NULL
operator|||
name|to
operator|==
name|from
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|to
operator|==
name|NULL
operator|||
operator|!
name|i915_semaphore_is_enabled
argument_list|(
name|obj
operator|->
name|base
operator|.
name|dev
argument_list|)
condition|)
return|return
name|i915_gem_object_wait_rendering
argument_list|(
name|obj
argument_list|)
return|;
name|idx
operator|=
name|intel_ring_sync_index
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|seqno
operator|=
name|obj
operator|->
name|last_rendering_seqno
expr_stmt|;
if|if
condition|(
name|seqno
operator|<=
name|from
operator|->
name|sync_seqno
index|[
name|idx
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|seqno
operator|==
name|from
operator|->
name|outstanding_lazy_request
condition|)
block|{
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|request
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_add_request
argument_list|(
name|from
argument_list|,
name|NULL
argument_list|,
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|seqno
operator|=
name|request
operator|->
name|seqno
expr_stmt|;
block|}
name|ret
operator|=
name|to
operator|->
name|sync_to
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|from
operator|->
name|sync_seqno
index|[
name|idx
index|]
operator|=
name|seqno
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_finish_gtt
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|u32
name|old_write_domain
decl_stmt|,
name|old_read_domains
decl_stmt|;
comment|/* Act a barrier for all accesses through the GTT */
name|mb
argument_list|()
expr_stmt|;
comment|/* Force a pagefault for domain tracking on next user access */
name|i915_gem_release_mmap
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_DOMAIN_GTT
operator|)
operator|==
literal|0
condition|)
return|return;
name|old_read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|read_domains
expr_stmt|;
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&=
operator|~
name|I915_GEM_DOMAIN_GTT
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&=
operator|~
name|I915_GEM_DOMAIN_GTT
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain finish gtt %p %x %x"
argument_list|,
name|obj
argument_list|,
name|old_read_domains
argument_list|,
name|old_write_domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_unbind
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dev_priv
operator|=
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|gtt_space
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|obj
operator|->
name|pin_count
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Attempting to unbind pinned buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
name|ret
operator|=
name|i915_gem_object_finish_gpu
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|ERESTARTSYS
operator|||
name|ret
operator|==
operator|-
name|EINTR
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|i915_gem_object_finish_gtt
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|ret
operator|=
name|i915_gem_object_set_to_cpu_domain
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|ERESTARTSYS
operator|||
name|ret
operator|==
operator|-
name|EINTR
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|i915_gem_clflush_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
name|I915_GEM_DOMAIN_CPU
expr_stmt|;
block|}
name|ret
operator|=
name|i915_gem_object_put_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|obj
operator|->
name|has_global_gtt_mapping
condition|)
name|i915_gem_gtt_unbind_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|has_aliasing_ppgtt_mapping
condition|)
block|{
name|i915_ppgtt_unbind_object
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|aliasing_ppgtt
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|has_aliasing_ppgtt_mapping
operator|=
literal|0
expr_stmt|;
block|}
name|i915_gem_gtt_finish_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|i915_gem_object_put_pages_gtt
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|obj
operator|->
name|gtt_list
argument_list|)
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|obj
operator|->
name|mm_list
argument_list|)
expr_stmt|;
name|obj
operator|->
name|map_and_fenceable
operator|=
name|true
expr_stmt|;
name|drm_mm_put_block
argument_list|(
name|obj
operator|->
name|gtt_space
argument_list|)
expr_stmt|;
name|obj
operator|->
name|gtt_space
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|gtt_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i915_gem_object_is_purgeable
argument_list|(
name|obj
argument_list|)
condition|)
name|i915_gem_object_truncate
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_unbind %p"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_put_pages_range_locked
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|vm_pindex_t
name|si
parameter_list|,
name|vm_pindex_t
name|ei
parameter_list|)
block|{
name|vm_object_t
name|vm_obj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_pindex_t
name|i
decl_stmt|;
name|vm_obj
operator|=
name|obj
operator|->
name|base
operator|.
name|vm_obj
expr_stmt|;
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|si
operator|,
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|vm_obj
argument_list|,
name|i
argument_list|)
init|;
name|i
operator|<
name|ei
condition|;
name|m
operator|=
name|vm_page_next
argument_list|(
name|m
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|m
operator|->
name|pindex
operator|==
name|i
argument_list|,
operator|(
literal|"pindex %jx %jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|m
operator|->
name|pindex
operator|,
operator|(
name|uintmax_t
operator|)
name|i
operator|)
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
name|PQ_INACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
name|atomic_add_long
argument_list|(
operator|&
name|i915_gem_wired_pages_cnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_put_pages_range
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|off_t
name|start
parameter_list|,
name|off_t
name|end
parameter_list|)
block|{
name|vm_object_t
name|vm_obj
decl_stmt|;
name|vm_obj
operator|=
name|obj
operator|->
name|base
operator|.
name|vm_obj
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|i915_gem_object_put_pages_range_locked
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|trunc_page
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|round_page
argument_list|(
name|end
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_object_get_pages_range
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|off_t
name|start
parameter_list|,
name|off_t
name|end
parameter_list|)
block|{
name|vm_object_t
name|vm_obj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_pindex_t
name|si
decl_stmt|,
name|ei
decl_stmt|,
name|i
decl_stmt|;
name|bool
name|need_swizzle
decl_stmt|,
name|fresh
decl_stmt|;
name|need_swizzle
operator|=
name|i915_gem_object_needs_bit17_swizzle
argument_list|(
name|obj
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|vm_obj
operator|=
name|obj
operator|->
name|base
operator|.
name|vm_obj
expr_stmt|;
name|si
operator|=
name|OFF_TO_IDX
argument_list|(
name|trunc_page
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|ei
operator|=
name|OFF_TO_IDX
argument_list|(
name|round_page
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|si
init|;
name|i
operator|<
name|ei
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|i915_gem_wire_page
argument_list|(
name|vm_obj
argument_list|,
name|i
argument_list|,
operator|&
name|fresh
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|need_swizzle
operator|&&
name|fresh
condition|)
name|i915_gem_object_do_bit_17_swizzle_page
argument_list|(
name|obj
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
name|i915_gem_object_put_pages_range_locked
argument_list|(
name|obj
argument_list|,
name|si
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_object_get_pages_gtt
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|vm_object_t
name|vm_obj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_pindex_t
name|i
decl_stmt|,
name|page_count
decl_stmt|;
name|int
name|res
decl_stmt|;
name|dev
operator|=
name|obj
operator|->
name|base
operator|.
name|dev
expr_stmt|;
name|KASSERT
argument_list|(
name|obj
operator|->
name|pages
operator|==
name|NULL
argument_list|,
operator|(
literal|"Obj already has pages"
operator|)
argument_list|)
expr_stmt|;
name|page_count
operator|=
name|OFF_TO_IDX
argument_list|(
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pages
operator|=
name|malloc
argument_list|(
name|page_count
operator|*
sizeof|sizeof
argument_list|(
name|vm_page_t
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|res
operator|=
name|i915_gem_object_get_pages_range
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|obj
operator|->
name|pages
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pages
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
name|vm_obj
operator|=
name|obj
operator|->
name|base
operator|.
name|vm_obj
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|vm_obj
argument_list|,
literal|0
argument_list|)
init|;
name|i
operator|<
name|page_count
condition|;
name|i
operator|++
operator|,
name|m
operator|=
name|vm_page_next
argument_list|(
name|m
argument_list|)
control|)
block|{
name|KASSERT
argument_list|(
name|m
operator|->
name|pindex
operator|==
name|i
argument_list|,
operator|(
literal|"pindex %jx %jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|m
operator|->
name|pindex
operator|,
operator|(
name|uintmax_t
operator|)
name|i
operator|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pages
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|GEM_PARANOID_CHECK_GTT
value|0
end_define

begin_if
if|#
directive|if
name|GEM_PARANOID_CHECK_GTT
end_if

begin_function
specifier|static
name|void
name|i915_gem_assert_pages_not_mapped
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|int
name|page_count
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|unsigned
name|long
name|start
decl_stmt|,
name|end
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|start
operator|=
name|OFF_TO_IDX
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_start
argument_list|)
expr_stmt|;
name|end
operator|=
name|OFF_TO_IDX
argument_list|(
name|dev_priv
operator|->
name|mm
operator|.
name|gtt_end
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
name|intel_gtt_read_pte_paddr
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|page_count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pa
operator|==
name|VM_PAGE_TO_PHYS
argument_list|(
name|ma
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Page %p in GTT pte index %d pte %x"
argument_list|,
name|ma
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|intel_gtt_read_pte
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|i915_gem_object_put_pages_gtt
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|int
name|page_count
decl_stmt|,
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|obj
operator|->
name|madv
operator|!=
name|I915_MADV_PURGED_INTERNAL
argument_list|,
operator|(
literal|"Purged object"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
condition|)
name|i915_gem_object_save_bit_17_swizzle
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|madv
operator|==
name|I915_MADV_DONTNEED
condition|)
name|obj
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|page_count
operator|=
name|obj
operator|->
name|base
operator|.
name|size
operator|/
name|PAGE_SIZE
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
if|#
directive|if
name|GEM_PARANOID_CHECK_GTT
name|i915_gem_assert_pages_not_mapped
argument_list|(
name|obj
operator|->
name|base
operator|.
name|dev
argument_list|,
name|obj
operator|->
name|pages
argument_list|,
name|page_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_count
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|obj
operator|->
name|pages
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|dirty
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|madv
operator|==
name|I915_MADV_WILLNEED
condition|)
name|vm_page_reference
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|obj
operator|->
name|pages
index|[
name|i
index|]
argument_list|,
name|PQ_ACTIVE
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|i915_gem_wired_pages_cnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|obj
operator|->
name|pages
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|obj
operator|->
name|pages
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_release_mmap
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|vm_object_t
name|devobj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|i
decl_stmt|,
name|page_count
decl_stmt|;
if|if
condition|(
operator|!
name|obj
operator|->
name|fault_mappable
condition|)
return|return;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"release_mmap %p %x %x"
argument_list|,
name|obj
argument_list|,
name|obj
operator|->
name|gtt_offset
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|devobj
operator|=
name|cdev_pager_lookup
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|devobj
operator|!=
name|NULL
condition|)
block|{
name|page_count
operator|=
name|OFF_TO_IDX
argument_list|(
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|devobj
argument_list|)
expr_stmt|;
name|retry
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_count
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|devobj
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|vm_page_sleep_if_busy
argument_list|(
name|m
argument_list|,
literal|"915unm"
argument_list|)
condition|)
goto|goto
name|retry
goto|;
name|cdev_pager_free_page
argument_list|(
name|devobj
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|devobj
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|devobj
argument_list|)
expr_stmt|;
block|}
name|obj
operator|->
name|fault_mappable
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_wait_rendering
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
name|I915_GEM_GPU_DOMAINS
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"In GPU write domain"
operator|)
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_wait_rendering %p %s %x %d %d"
argument_list|,
name|obj
argument_list|,
name|obj
operator|->
name|ring
operator|!=
name|NULL
condition|?
name|obj
operator|->
name|ring
operator|->
name|name
else|:
literal|"none"
argument_list|,
name|obj
operator|->
name|gtt_offset
argument_list|,
name|obj
operator|->
name|active
argument_list|,
name|obj
operator|->
name|last_rendering_seqno
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|active
condition|)
block|{
name|ret
operator|=
name|i915_wait_request
argument_list|(
name|obj
operator|->
name|ring
argument_list|,
name|obj
operator|->
name|last_rendering_seqno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|i915_gem_retire_requests_ring
argument_list|(
name|obj
operator|->
name|ring
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|i915_gem_object_move_to_active
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|uint32_t
name|seqno
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_fence_reg
modifier|*
name|reg
decl_stmt|;
name|obj
operator|->
name|ring
operator|=
name|ring
expr_stmt|;
name|KASSERT
argument_list|(
name|ring
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL ring"
operator|)
argument_list|)
expr_stmt|;
comment|/* Add a reference if we're newly entering the active list. */
if|if
condition|(
operator|!
name|obj
operator|->
name|active
condition|)
block|{
name|drm_gem_object_reference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|obj
operator|->
name|active
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Move from whatever list we were on to the tail of execution. */
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|mm_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|active_list
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|ring_list
argument_list|,
operator|&
name|ring
operator|->
name|active_list
argument_list|)
expr_stmt|;
name|obj
operator|->
name|last_rendering_seqno
operator|=
name|seqno
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|fenced_gpu_access
condition|)
block|{
name|obj
operator|->
name|last_fenced_seqno
operator|=
name|seqno
expr_stmt|;
comment|/* Bump MRU to take account of the delayed flush */
if|if
condition|(
name|obj
operator|->
name|fence_reg
operator|!=
name|I915_FENCE_REG_NONE
condition|)
block|{
name|reg
operator|=
operator|&
name|dev_priv
operator|->
name|fence_regs
index|[
name|obj
operator|->
name|fence_reg
index|]
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|reg
operator|->
name|lru_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|fence_list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_move_off_active
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|list_del_init
argument_list|(
operator|&
name|obj
operator|->
name|ring_list
argument_list|)
expr_stmt|;
name|obj
operator|->
name|last_rendering_seqno
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|last_fenced_seqno
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_move_to_flushing
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|KASSERT
argument_list|(
name|obj
operator|->
name|active
argument_list|,
operator|(
literal|"Object not active"
operator|)
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|mm_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|flushing_list
argument_list|)
expr_stmt|;
name|i915_gem_object_move_off_active
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_move_to_inactive
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|obj
operator|->
name|mm_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|inactive_list
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|list_empty
argument_list|(
operator|&
name|obj
operator|->
name|gpu_write_list
argument_list|)
argument_list|,
operator|(
literal|"On gpu_write_list"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|obj
operator|->
name|active
argument_list|,
operator|(
literal|"Object not active"
operator|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|ring
operator|=
name|NULL
expr_stmt|;
name|i915_gem_object_move_off_active
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|fenced_gpu_access
operator|=
name|false
expr_stmt|;
name|obj
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|pending_gpu_write
operator|=
name|false
expr_stmt|;
name|drm_gem_object_unreference
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|KIB_NOTYET
argument_list|()
expr_stmt|;
else|#
directive|else
name|WARN_ON
argument_list|(
name|i915_verify_lists
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_truncate
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|vm_object_t
name|vm_obj
decl_stmt|;
name|vm_obj
operator|=
name|obj
operator|->
name|base
operator|.
name|vm_obj
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|vm_object_page_remove
argument_list|(
name|vm_obj
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|drm_gem_free_mmap_offset
argument_list|(
operator|&
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|obj
operator|->
name|madv
operator|=
name|I915_MADV_PURGED_INTERNAL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|i915_gem_object_is_purgeable
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
return|return
operator|(
name|obj
operator|->
name|madv
operator|==
name|I915_MADV_DONTNEED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_process_flushing_list
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|uint32_t
name|flush_domains
parameter_list|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|uint32_t
name|old_write_domain
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|obj
argument_list|,
argument|next
argument_list|,
argument|&ring->gpu_write_list
argument_list|,
argument|gpu_write_list
argument_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
name|flush_domains
condition|)
block|{
name|old_write_domain
operator|=
name|obj
operator|->
name|base
operator|.
name|write_domain
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
literal|0
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|obj
operator|->
name|gpu_write_list
argument_list|)
expr_stmt|;
name|i915_gem_object_move_to_active
argument_list|(
name|obj
argument_list|,
name|ring
argument_list|,
name|i915_gem_next_request_seqno
argument_list|(
name|ring
argument_list|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"object_change_domain process_flush %p %x %x"
argument_list|,
name|obj
argument_list|,
name|obj
operator|->
name|base
operator|.
name|read_domains
argument_list|,
name|old_write_domain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_object_needs_bit17_swizzle
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|dev_priv
operator|=
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
expr_stmt|;
return|return
operator|(
name|dev_priv
operator|->
name|mm
operator|.
name|bit_6_swizzle_x
operator|==
name|I915_BIT_6_SWIZZLE_9_10_17
operator|&&
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|i915_gem_wire_page
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|bool
modifier|*
name|fresh
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|m
operator|=
name|vm_page_grab
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|valid
operator|!=
name|VM_PAGE_BITS_ALL
condition|)
block|{
if|if
condition|(
name|vm_pager_has_page
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|rv
operator|=
name|vm_pager_get_pages
argument_list|(
name|object
argument_list|,
operator|&
name|m
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|VM_PAGER_OK
condition|)
block|{
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|fresh
operator|!=
name|NULL
condition|)
operator|*
name|fresh
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|pmap_zero_page
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|m
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fresh
operator|!=
name|NULL
condition|)
operator|*
name|fresh
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fresh
operator|!=
name|NULL
condition|)
block|{
operator|*
name|fresh
operator|=
name|false
expr_stmt|;
block|}
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_wire
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_xunbusy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|i915_gem_wired_pages_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_flush_ring
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|uint32_t
name|invalidate_domains
parameter_list|,
name|uint32_t
name|flush_domains
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|invalidate_domains
operator||
name|flush_domains
operator|)
operator|&
name|I915_GEM_GPU_DOMAINS
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"ring_flush %s %x %x"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|invalidate_domains
argument_list|,
name|flush_domains
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ring
operator|->
name|flush
argument_list|(
name|ring
argument_list|,
name|invalidate_domains
argument_list|,
name|flush_domains
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|flush_domains
operator|&
name|I915_GEM_GPU_DOMAINS
condition|)
name|i915_gem_process_flushing_list
argument_list|(
name|ring
argument_list|,
name|flush_domains
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_ring_idle
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|gpu_write_list
argument_list|)
operator|&&
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|active_list
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|gpu_write_list
argument_list|)
condition|)
block|{
name|ret
operator|=
name|i915_gem_flush_ring
argument_list|(
name|ring
argument_list|,
name|I915_GEM_GPU_DOMAINS
argument_list|,
name|I915_GEM_GPU_DOMAINS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
block|}
return|return
operator|(
name|i915_wait_request
argument_list|(
name|ring
argument_list|,
name|i915_gem_next_request_seqno
argument_list|(
name|ring
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i915_gpu_idle
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
comment|/* Flush everything onto the inactive list. */
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
block|{
name|ret
operator|=
name|i915_switch_context
argument_list|(
name|ring
argument_list|,
name|NULL
argument_list|,
name|DEFAULT_CONTEXT_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|i915_ring_idle
argument_list|(
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* Is the device fubar? */
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|gpu_write_list
argument_list|)
condition|)
return|return
operator|-
name|EBUSY
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_check_wedge
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|)
block|{
name|DRM_LOCK_ASSERT
argument_list|(
name|dev_priv
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bool
name|recovery_complete
decl_stmt|;
comment|/* Give the error handler a chance to run. */
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion_lock
argument_list|)
expr_stmt|;
name|recovery_complete
operator|=
operator|(
operator|&
name|dev_priv
operator|->
name|error_completion
operator|)
operator|>
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|error_completion_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|recovery_complete
condition|?
operator|-
name|EIO
else|:
operator|-
name|EAGAIN
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Compare seqno against outstanding lazy request. Emit a request if they are  * equal.  */
end_comment

begin_function
specifier|static
name|int
name|i915_gem_check_olr
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|u32
name|seqno
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|DRM_LOCK_ASSERT
argument_list|(
name|ring
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|seqno
operator|==
name|ring
operator|->
name|outstanding_lazy_request
condition|)
block|{
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|request
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_add_request
argument_list|(
name|ring
argument_list|,
name|NULL
argument_list|,
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|MPASS
argument_list|(
name|seqno
operator|==
name|request
operator|->
name|seqno
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__wait_seqno
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|u32
name|seqno
parameter_list|,
name|bool
name|interruptible
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|ring
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|;
if|if
condition|(
name|i915_seqno_passed
argument_list|(
name|ring
operator|->
name|get_seqno
argument_list|(
name|ring
argument_list|)
argument_list|,
name|seqno
argument_list|)
condition|)
return|return
literal|0
return|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"request_wait_begin %s %d"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ring
operator|->
name|irq_get
argument_list|(
name|ring
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENODEV
operator|)
return|;
block|}
name|flags
operator|=
name|interruptible
condition|?
name|PCATCH
else|:
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|i915_seqno_passed
argument_list|(
name|ring
operator|->
name|get_seqno
argument_list|(
name|ring
argument_list|)
argument_list|,
name|seqno
argument_list|)
operator|&&
operator|!
name|atomic_load_acq_int
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
name|msleep
argument_list|(
name|ring
argument_list|,
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|,
name|flags
argument_list|,
literal|"915gwr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|ERESTART
condition|)
name|ret
operator|=
operator|-
name|ERESTARTSYS
expr_stmt|;
block|}
name|ring
operator|->
name|irq_put
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"request_wait_end %s %d %d"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|seqno
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_wait_request
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|uint32_t
name|seqno
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|KASSERT
argument_list|(
name|seqno
operator|!=
literal|0
argument_list|,
operator|(
literal|"Zero seqno"
operator|)
argument_list|)
expr_stmt|;
name|dev_priv
operator|=
name|ring
operator|->
name|dev
operator|->
name|dev_private
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|i915_gem_check_wedge
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|i915_gem_check_olr
argument_list|(
name|ring
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|__wait_seqno
argument_list|(
name|ring
argument_list|,
name|seqno
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|interruptible
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|wedged
argument_list|)
condition|)
name|ret
operator|=
operator|-
name|EAGAIN
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|i915_gem_get_seqno
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|seqno
init|=
name|dev_priv
operator|->
name|next_seqno
decl_stmt|;
comment|/* reserve 0 for non-seqno */
if|if
condition|(
operator|++
name|dev_priv
operator|->
name|next_seqno
operator|==
literal|0
condition|)
name|dev_priv
operator|->
name|next_seqno
operator|=
literal|1
expr_stmt|;
return|return
name|seqno
return|;
block|}
end_function

begin_function
name|u32
name|i915_gem_next_request_seqno
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
if|if
condition|(
name|ring
operator|->
name|outstanding_lazy_request
operator|==
literal|0
condition|)
name|ring
operator|->
name|outstanding_lazy_request
operator|=
name|i915_gem_get_seqno
argument_list|(
name|ring
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return
name|ring
operator|->
name|outstanding_lazy_request
return|;
block|}
end_function

begin_function
name|int
name|i915_add_request
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|,
name|struct
name|drm_i915_gem_request
modifier|*
name|request
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_i915_file_private
modifier|*
name|file_priv
decl_stmt|;
name|uint32_t
name|seqno
decl_stmt|;
name|u32
name|request_ring_position
decl_stmt|;
name|int
name|was_empty
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|KASSERT
argument_list|(
name|request
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL request in add"
operator|)
argument_list|)
expr_stmt|;
name|DRM_LOCK_ASSERT
argument_list|(
name|ring
operator|->
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|=
name|ring
operator|->
name|dev
operator|->
name|dev_private
expr_stmt|;
name|seqno
operator|=
name|i915_gem_next_request_seqno
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|request_ring_position
operator|=
name|intel_ring_get_tail
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ring
operator|->
name|add_request
argument_list|(
name|ring
argument_list|,
operator|&
name|seqno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"request_add %s %d"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
name|request
operator|->
name|seqno
operator|=
name|seqno
expr_stmt|;
name|request
operator|->
name|ring
operator|=
name|ring
expr_stmt|;
name|request
operator|->
name|tail
operator|=
name|request_ring_position
expr_stmt|;
name|request
operator|->
name|emitted_jiffies
operator|=
name|ticks
expr_stmt|;
name|was_empty
operator|=
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|request
operator|->
name|list
argument_list|,
operator|&
name|ring
operator|->
name|request_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
block|{
name|file_priv
operator|=
name|file
operator|->
name|driver_priv
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lck
argument_list|)
expr_stmt|;
name|request
operator|->
name|file_priv
operator|=
name|file_priv
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|request
operator|->
name|client_list
argument_list|,
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|request_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lck
argument_list|)
expr_stmt|;
block|}
name|ring
operator|->
name|outstanding_lazy_request
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
condition|)
block|{
if|if
condition|(
name|i915_enable_hangcheck
condition|)
block|{
name|callout_schedule
argument_list|(
operator|&
name|dev_priv
operator|->
name|hangcheck_timer
argument_list|,
name|DRM_I915_HANGCHECK_PERIOD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|was_empty
condition|)
name|taskqueue_enqueue_timeout
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|retire_task
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|i915_gem_request_remove_from_client
parameter_list|(
name|struct
name|drm_i915_gem_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|drm_i915_file_private
modifier|*
name|file_priv
init|=
name|request
operator|->
name|file_priv
decl_stmt|;
if|if
condition|(
operator|!
name|file_priv
condition|)
return|return;
name|DRM_LOCK_ASSERT
argument_list|(
name|request
operator|->
name|ring
operator|->
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lck
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|file_priv
operator|!=
name|NULL
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|request
operator|->
name|client_list
argument_list|)
expr_stmt|;
name|request
operator|->
name|file_priv
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lck
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_release
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|drm_i915_file_private
modifier|*
name|file_priv
decl_stmt|;
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|file_priv
operator|=
name|file
operator|->
name|driver_priv
expr_stmt|;
comment|/* Clean up our request list when the client is going away, so that 	 * later retire_requests won't dereference our soon-to-be-gone 	 * file_priv. 	 */
name|mtx_lock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lck
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|request_list
argument_list|)
condition|)
block|{
name|request
operator|=
name|list_first_entry
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|request_list
argument_list|,
expr|struct
name|drm_i915_gem_request
argument_list|,
name|client_list
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|request
operator|->
name|client_list
argument_list|)
expr_stmt|;
name|request
operator|->
name|file_priv
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|file_priv
operator|->
name|mm
operator|.
name|lck
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_reset_ring_lists
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
if|if
condition|(
name|ring
operator|->
name|dev
operator|!=
name|NULL
condition|)
name|DRM_LOCK_ASSERT
argument_list|(
name|ring
operator|->
name|dev
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|request
operator|=
name|list_first_entry
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|,
expr|struct
name|drm_i915_gem_request
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|request
operator|->
name|list
argument_list|)
expr_stmt|;
name|i915_gem_request_remove_from_client
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|active_list
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|list_first_entry
argument_list|(
operator|&
name|ring
operator|->
name|active_list
argument_list|,
expr|struct
name|drm_i915_gem_object
argument_list|,
name|ring_list
argument_list|)
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
literal|0
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|obj
operator|->
name|gpu_write_list
argument_list|)
expr_stmt|;
name|i915_gem_object_move_to_inactive
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_reset_fences
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|num_fence_regs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_i915_fence_reg
modifier|*
name|reg
init|=
operator|&
name|dev_priv
operator|->
name|fence_regs
index|[
name|i
index|]
decl_stmt|;
name|i915_gem_write_fence
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|->
name|obj
condition|)
name|i915_gem_object_fence_lost
argument_list|(
name|reg
operator|->
name|obj
argument_list|)
expr_stmt|;
name|reg
operator|->
name|pin_count
operator|=
literal|0
expr_stmt|;
name|reg
operator|->
name|obj
operator|=
name|NULL
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|reg
operator|->
name|lru_list
argument_list|)
expr_stmt|;
block|}
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|fence_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_reset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
name|i915_gem_reset_ring_lists
argument_list|(
name|dev_priv
argument_list|,
name|ring
argument_list|)
expr_stmt|;
comment|/* Remove anything from the flushing lists. The GPU cache is likely 	 * to be lost on reset along with the data, so simply move the 	 * lost bo to the inactive list. 	 */
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|flushing_list
argument_list|)
condition|)
block|{
name|obj
operator|=
name|list_first_entry
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|flushing_list
argument_list|,
expr|struct
name|drm_i915_gem_object
argument_list|,
name|mm_list
argument_list|)
expr_stmt|;
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|=
literal|0
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|obj
operator|->
name|gpu_write_list
argument_list|)
expr_stmt|;
name|i915_gem_object_move_to_inactive
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
comment|/* Move everything out of the GPU domains to ensure we do any 	 * necessary invalidation upon reuse. 	 */
name|list_for_each_entry
argument_list|(
argument|obj
argument_list|,
argument|&dev_priv->mm.inactive_list
argument_list|,
argument|mm_list
argument_list|)
block|{
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&=
operator|~
name|I915_GEM_GPU_DOMAINS
expr_stmt|;
block|}
comment|/* The fence registers are invalidated so clear them out */
name|i915_gem_reset_fences
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This function clears the request list as sequence numbers are passed.  */
end_comment

begin_function
name|void
name|i915_gem_retire_requests_ring
parameter_list|(
name|struct
name|intel_ring_buffer
modifier|*
name|ring
parameter_list|)
block|{
name|uint32_t
name|seqno
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
condition|)
return|return;
name|seqno
operator|=
name|ring
operator|->
name|get_seqno
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"retire_request_ring %s %d"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|ring
operator|->
name|sync_seqno
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|seqno
operator|>=
name|ring
operator|->
name|sync_seqno
index|[
name|i
index|]
condition|)
name|ring
operator|->
name|sync_seqno
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|request
operator|=
name|list_first_entry
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|,
expr|struct
name|drm_i915_gem_request
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i915_seqno_passed
argument_list|(
name|seqno
argument_list|,
name|request
operator|->
name|seqno
argument_list|)
condition|)
break|break;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"retire_request_seqno_passed %s %d"
argument_list|,
name|ring
operator|->
name|name
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
name|ring
operator|->
name|last_retired_head
operator|=
name|request
operator|->
name|tail
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|request
operator|->
name|list
argument_list|)
expr_stmt|;
name|i915_gem_request_remove_from_client
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
comment|/* Move any buffers on the active list that are no longer referenced 	 * by the ringbuffer to the flushing/inactive lists as appropriate. 	 */
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|active_list
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|list_first_entry
argument_list|(
operator|&
name|ring
operator|->
name|active_list
argument_list|,
expr|struct
name|drm_i915_gem_object
argument_list|,
name|ring_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i915_seqno_passed
argument_list|(
name|seqno
argument_list|,
name|obj
operator|->
name|last_rendering_seqno
argument_list|)
condition|)
break|break;
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|!=
literal|0
condition|)
name|i915_gem_object_move_to_flushing
argument_list|(
name|obj
argument_list|)
expr_stmt|;
else|else
name|i915_gem_object_move_to_inactive
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ring
operator|->
name|trace_irq_seqno
operator|&&
name|i915_seqno_passed
argument_list|(
name|seqno
argument_list|,
name|ring
operator|->
name|trace_irq_seqno
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|ring
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|ring
operator|->
name|irq_put
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_priv
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|ring
operator|->
name|trace_irq_seqno
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|i915_gem_retire_requests
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
name|i915_gem_retire_requests_ring
argument_list|(
name|ring
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sandybridge_write_fence_reg
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
if|if
condition|(
name|obj
condition|)
block|{
name|u32
name|size
init|=
name|obj
operator|->
name|gtt_space
operator|->
name|size
decl_stmt|;
name|val
operator|=
call|(
name|uint64_t
call|)
argument_list|(
operator|(
name|obj
operator|->
name|gtt_offset
operator|+
name|size
operator|-
literal|4096
operator|)
operator|&
literal|0xfffff000
argument_list|)
operator|<<
literal|32
expr_stmt|;
name|val
operator||=
name|obj
operator|->
name|gtt_offset
operator|&
literal|0xfffff000
expr_stmt|;
name|val
operator||=
call|(
name|uint64_t
call|)
argument_list|(
operator|(
name|obj
operator|->
name|stride
operator|/
literal|128
operator|)
operator|-
literal|1
argument_list|)
operator|<<
name|SANDYBRIDGE_FENCE_PITCH_SHIFT
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_Y
condition|)
name|val
operator||=
literal|1
operator|<<
name|I965_FENCE_TILING_Y_SHIFT
expr_stmt|;
name|val
operator||=
name|I965_FENCE_REG_VALID
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|I915_WRITE64
argument_list|(
name|FENCE_REG_SANDYBRIDGE_0
operator|+
name|reg
operator|*
literal|8
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|FENCE_REG_SANDYBRIDGE_0
operator|+
name|reg
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i965_write_fence_reg
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
if|if
condition|(
name|obj
condition|)
block|{
name|u32
name|size
init|=
name|obj
operator|->
name|gtt_space
operator|->
name|size
decl_stmt|;
name|val
operator|=
call|(
name|uint64_t
call|)
argument_list|(
operator|(
name|obj
operator|->
name|gtt_offset
operator|+
name|size
operator|-
literal|4096
operator|)
operator|&
literal|0xfffff000
argument_list|)
operator|<<
literal|32
expr_stmt|;
name|val
operator||=
name|obj
operator|->
name|gtt_offset
operator|&
literal|0xfffff000
expr_stmt|;
name|val
operator||=
operator|(
operator|(
name|obj
operator|->
name|stride
operator|/
literal|128
operator|)
operator|-
literal|1
operator|)
operator|<<
name|I965_FENCE_PITCH_SHIFT
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_Y
condition|)
name|val
operator||=
literal|1
operator|<<
name|I965_FENCE_TILING_Y_SHIFT
expr_stmt|;
name|val
operator||=
name|I965_FENCE_REG_VALID
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|I915_WRITE64
argument_list|(
name|FENCE_REG_965_0
operator|+
name|reg
operator|*
literal|8
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|FENCE_REG_965_0
operator|+
name|reg
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_write_fence_reg
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|val
decl_stmt|;
if|if
condition|(
name|obj
condition|)
block|{
name|u32
name|size
init|=
name|obj
operator|->
name|gtt_space
operator|->
name|size
decl_stmt|;
name|int
name|pitch_val
decl_stmt|;
name|int
name|tile_width
decl_stmt|;
if|if
condition|(
operator|(
name|obj
operator|->
name|gtt_offset
operator|&
operator|~
name|I915_FENCE_START_MASK
operator|)
operator|||
operator|(
name|size
operator|&
operator|-
name|size
operator|)
operator|!=
name|size
operator|||
operator|(
name|obj
operator|->
name|gtt_offset
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"object 0x%08x [fenceable? %d] not 1M or pot-size (0x%08x) aligned\n"
argument_list|,
name|obj
operator|->
name|gtt_offset
argument_list|,
name|obj
operator|->
name|map_and_fenceable
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_Y
operator|&&
name|HAS_128_BYTE_Y_TILING
argument_list|(
name|dev
argument_list|)
condition|)
name|tile_width
operator|=
literal|128
expr_stmt|;
else|else
name|tile_width
operator|=
literal|512
expr_stmt|;
comment|/* Note: pitch better be a power of two tile widths */
name|pitch_val
operator|=
name|obj
operator|->
name|stride
operator|/
name|tile_width
expr_stmt|;
name|pitch_val
operator|=
name|ffs
argument_list|(
name|pitch_val
argument_list|)
operator|-
literal|1
expr_stmt|;
name|val
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_Y
condition|)
name|val
operator||=
literal|1
operator|<<
name|I830_FENCE_TILING_Y_SHIFT
expr_stmt|;
name|val
operator||=
name|I915_FENCE_SIZE_BITS
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|val
operator||=
name|pitch_val
operator|<<
name|I830_FENCE_PITCH_SHIFT
expr_stmt|;
name|val
operator||=
name|I830_FENCE_REG_VALID
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg
operator|<
literal|8
condition|)
name|reg
operator|=
name|FENCE_REG_830_0
operator|+
name|reg
operator|*
literal|4
expr_stmt|;
else|else
name|reg
operator|=
name|FENCE_REG_945_8
operator|+
operator|(
name|reg
operator|-
literal|8
operator|)
operator|*
literal|4
expr_stmt|;
name|I915_WRITE
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i830_write_fence_reg
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|obj
condition|)
block|{
name|u32
name|size
init|=
name|obj
operator|->
name|gtt_space
operator|->
name|size
decl_stmt|;
name|uint32_t
name|pitch_val
decl_stmt|;
if|if
condition|(
operator|(
name|obj
operator|->
name|gtt_offset
operator|&
operator|~
name|I830_FENCE_START_MASK
operator|)
operator|||
operator|(
name|size
operator|&
operator|-
name|size
operator|)
operator|!=
name|size
operator|||
operator|(
name|obj
operator|->
name|gtt_offset
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"object 0x%08x not 512K or pot-size 0x%08x aligned\n"
argument_list|,
name|obj
operator|->
name|gtt_offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pitch_val
operator|=
name|obj
operator|->
name|stride
operator|/
literal|128
expr_stmt|;
name|pitch_val
operator|=
name|ffs
argument_list|(
name|pitch_val
argument_list|)
operator|-
literal|1
expr_stmt|;
name|val
operator|=
name|obj
operator|->
name|gtt_offset
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|tiling_mode
operator|==
name|I915_TILING_Y
condition|)
name|val
operator||=
literal|1
operator|<<
name|I830_FENCE_TILING_Y_SHIFT
expr_stmt|;
name|val
operator||=
name|I830_FENCE_SIZE_BITS
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|val
operator||=
name|pitch_val
operator|<<
name|I830_FENCE_PITCH_SHIFT
expr_stmt|;
name|val
operator||=
name|I830_FENCE_REG_VALID
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|I915_WRITE
argument_list|(
name|FENCE_REG_830_0
operator|+
name|reg
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POSTING_READ
argument_list|(
name|FENCE_REG_830_0
operator|+
name|reg
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_write_fence
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
switch|switch
condition|(
name|INTEL_INFO
argument_list|(
name|dev
argument_list|)
operator|->
name|gen
condition|)
block|{
case|case
literal|7
case|:
case|case
literal|6
case|:
name|sandybridge_write_fence_reg
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|obj
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
case|case
literal|4
case|:
name|i965_write_fence_reg
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|obj
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|i915_write_fence_reg
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|obj
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i830_write_fence_reg
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|obj
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|fence_number
parameter_list|(
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|drm_i915_fence_reg
modifier|*
name|fence
parameter_list|)
block|{
return|return
name|fence
operator|-
name|dev_priv
operator|->
name|fence_regs
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_object_update_fence
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|struct
name|drm_i915_fence_reg
modifier|*
name|fence
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|reg
init|=
name|fence_number
argument_list|(
name|dev_priv
argument_list|,
name|fence
argument_list|)
decl_stmt|;
name|i915_gem_write_fence
argument_list|(
name|obj
operator|->
name|base
operator|.
name|dev
argument_list|,
name|reg
argument_list|,
name|enable
condition|?
name|obj
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|obj
operator|->
name|fence_reg
operator|=
name|reg
expr_stmt|;
name|fence
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|fence
operator|->
name|lru_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|fence_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|obj
operator|->
name|fence_reg
operator|=
name|I915_FENCE_REG_NONE
expr_stmt|;
name|fence
operator|->
name|obj
operator|=
name|NULL
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|fence
operator|->
name|lru_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_object_flush_fence
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|fenced_gpu_access
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|write_domain
operator|&
name|I915_GEM_GPU_DOMAINS
condition|)
block|{
name|ret
operator|=
name|i915_gem_flush_ring
argument_list|(
name|obj
operator|->
name|ring
argument_list|,
literal|0
argument_list|,
name|obj
operator|->
name|base
operator|.
name|write_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|obj
operator|->
name|fenced_gpu_access
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|->
name|last_fenced_seqno
condition|)
block|{
name|ret
operator|=
name|i915_wait_request
argument_list|(
name|obj
operator|->
name|ring
argument_list|,
name|obj
operator|->
name|last_fenced_seqno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|obj
operator|->
name|last_fenced_seqno
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Ensure that all CPU reads are completed before installing a fence 	 * and all writes before removing the fence. 	 */
if|if
condition|(
name|obj
operator|->
name|base
operator|.
name|read_domains
operator|&
name|I915_GEM_DOMAIN_GTT
condition|)
name|mb
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_put_fence
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|obj
operator|->
name|base
operator|.
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|i915_gem_object_flush_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|obj
operator|->
name|fence_reg
operator|==
name|I915_FENCE_REG_NONE
condition|)
return|return
literal|0
return|;
name|i915_gem_object_update_fence
argument_list|(
name|obj
argument_list|,
operator|&
name|dev_priv
operator|->
name|fence_regs
index|[
name|obj
operator|->
name|fence_reg
index|]
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|i915_gem_object_fence_lost
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_i915_fence_reg
modifier|*
name|i915_find_fence_reg
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_i915_fence_reg
modifier|*
name|reg
decl_stmt|,
modifier|*
name|avail
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First try to find a free reg */
name|avail
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dev_priv
operator|->
name|fence_reg_start
init|;
name|i
operator|<
name|dev_priv
operator|->
name|num_fence_regs
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
operator|&
name|dev_priv
operator|->
name|fence_regs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|reg
operator|->
name|obj
condition|)
return|return
name|reg
return|;
if|if
condition|(
operator|!
name|reg
operator|->
name|pin_count
condition|)
name|avail
operator|=
name|reg
expr_stmt|;
block|}
if|if
condition|(
name|avail
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* None available, try to steal one or wait for a user to finish */
name|list_for_each_entry
argument_list|(
argument|reg
argument_list|,
argument|&dev_priv->mm.fence_list
argument_list|,
argument|lru_list
argument_list|)
block|{
if|if
condition|(
name|reg
operator|->
name|pin_count
condition|)
continue|continue;
return|return
name|reg
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_object_get_fence
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|obj
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|bool
name|enable
init|=
name|obj
operator|->
name|tiling_mode
operator|!=
name|I915_TILING_NONE
decl_stmt|;
name|struct
name|drm_i915_fence_reg
modifier|*
name|reg
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Have we updated the tiling parameters upon the object and so 	 * will need to serialise the write to the associated fence register? 	 */
if|if
condition|(
name|obj
operator|->
name|fence_dirty
condition|)
block|{
name|ret
operator|=
name|i915_gem_object_flush_fence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|fence_reg
operator|!=
name|I915_FENCE_REG_NONE
condition|)
block|{
name|reg
operator|=
operator|&
name|dev_priv
operator|->
name|fence_regs
index|[
name|obj
operator|->
name|fence_reg
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|obj
operator|->
name|fence_dirty
condition|)
block|{
name|list_move_tail
argument_list|(
operator|&
name|reg
operator|->
name|lru_list
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|fence_list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|enable
condition|)
block|{
name|reg
operator|=
name|i915_find_fence_reg
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
return|return
operator|-
name|EDEADLK
return|;
if|if
condition|(
name|reg
operator|->
name|obj
condition|)
block|{
name|struct
name|drm_i915_gem_object
modifier|*
name|old
init|=
name|reg
operator|->
name|obj
decl_stmt|;
name|ret
operator|=
name|i915_gem_object_flush_fence
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|i915_gem_object_fence_lost
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
literal|0
return|;
name|i915_gem_object_update_fence
argument_list|(
name|obj
argument_list|,
name|reg
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|obj
operator|->
name|fence_dirty
operator|=
name|false
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_gem_init_object
parameter_list|(
name|struct
name|drm_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|printf
argument_list|(
literal|"i915_gem_init_object called\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|i915_gem_object_is_inactive
parameter_list|(
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
return|return
operator|!
name|obj
operator|->
name|active
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_retire_task_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|intel_ring_buffer
modifier|*
name|ring
decl_stmt|;
name|bool
name|idle
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dev_priv
operator|=
name|arg
expr_stmt|;
name|dev
operator|=
name|dev_priv
operator|->
name|dev
expr_stmt|;
comment|/* Come back later if the device is busy... */
if|if
condition|(
operator|!
name|sx_try_xlock
argument_list|(
operator|&
name|dev
operator|->
name|dev_struct_lock
argument_list|)
condition|)
block|{
name|taskqueue_enqueue_timeout
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|retire_task
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return;
block|}
name|CTR0
argument_list|(
name|KTR_DRM
argument_list|,
literal|"retire_task"
argument_list|)
expr_stmt|;
name|i915_gem_retire_requests
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Send a periodic flush down the ring so we don't hold onto GEM 	 * objects indefinitely. 	 */
name|idle
operator|=
name|true
expr_stmt|;
name|for_each_ring
argument_list|(
argument|ring
argument_list|,
argument|dev_priv
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|intel_ring_buffer
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|rings
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|gpu_write_list
argument_list|)
condition|)
block|{
name|struct
name|drm_i915_gem_request
modifier|*
name|request
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|i915_gem_flush_ring
argument_list|(
name|ring
argument_list|,
literal|0
argument_list|,
name|I915_GEM_GPU_DOMAINS
argument_list|)
expr_stmt|;
name|request
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|||
name|request
operator|==
name|NULL
operator|||
name|i915_add_request
argument_list|(
name|ring
argument_list|,
name|NULL
argument_list|,
name|request
argument_list|)
condition|)
name|free
argument_list|(
name|request
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
block|}
name|idle
operator|&=
name|list_empty
argument_list|(
operator|&
name|ring
operator|->
name|request_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mm
operator|.
name|suspended
operator|&&
operator|!
name|idle
condition|)
name|taskqueue_enqueue_timeout
argument_list|(
name|dev_priv
operator|->
name|tq
argument_list|,
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|retire_task
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_lastclose
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return;
name|ret
operator|=
name|i915_gem_idle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to idle hardware: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gem_init_phys_object
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_i915_gem_phys_object
modifier|*
name|phys_obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|phys_objs
index|[
name|id
operator|-
literal|1
index|]
operator|!=
name|NULL
operator|||
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|phys_obj
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|drm_i915_gem_phys_object
argument_list|)
argument_list|,
name|DRM_I915_GEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|phys_obj
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|phys_obj
operator|->
name|handle
operator|=
name|drm_pci_alloc
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|phys_obj
operator|->
name|handle
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|free_obj
goto|;
block|}
name|pmap_change_attr
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|phys_obj
operator|->
name|handle
operator|->
name|vaddr
argument_list|,
name|size
operator|/
name|PAGE_SIZE
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|phys_objs
index|[
name|id
operator|-
literal|1
index|]
operator|=
name|phys_obj
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|free_obj
label|:
name|free
argument_list|(
name|phys_obj
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_free_phys_object
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_i915_gem_phys_object
modifier|*
name|phys_obj
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|phys_objs
index|[
name|id
operator|-
literal|1
index|]
operator|==
name|NULL
condition|)
return|return;
name|phys_obj
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|phys_objs
index|[
name|id
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|phys_obj
operator|->
name|cur_obj
operator|!=
name|NULL
condition|)
name|i915_gem_detach_phys_object
argument_list|(
name|dev
argument_list|,
name|phys_obj
operator|->
name|cur_obj
argument_list|)
expr_stmt|;
name|drm_pci_free
argument_list|(
name|dev
argument_list|,
name|phys_obj
operator|->
name|handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|phys_obj
argument_list|,
name|DRM_I915_GEM
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mm
operator|.
name|phys_objs
index|[
name|id
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_free_all_phys_object
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|I915_GEM_PHYS_CURSOR_0
init|;
name|i
operator|<=
name|I915_MAX_PHYS_OBJECT
condition|;
name|i
operator|++
control|)
name|i915_gem_free_phys_object
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_detach_phys_object
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|char
modifier|*
name|vaddr
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|int
name|i
decl_stmt|,
name|page_count
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|phys_obj
operator|==
name|NULL
condition|)
return|return;
name|vaddr
operator|=
name|obj
operator|->
name|phys_obj
operator|->
name|handle
operator|->
name|vaddr
expr_stmt|;
name|page_count
operator|=
name|obj
operator|->
name|base
operator|.
name|size
operator|/
name|PAGE_SIZE
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_count
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|i915_gem_wire_page
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
comment|/* XXX */
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|!=
name|NULL
condition|)
block|{
name|dst
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|vaddr
operator|+
name|IDX_TO_OFF
argument_list|(
name|i
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
name|drm_clflush_pages
argument_list|(
operator|&
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|vm_page_reference
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
name|PQ_INACTIVE
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|i915_gem_wired_pages_cnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|intel_gtt_chipset_flush
argument_list|()
expr_stmt|;
name|obj
operator|->
name|phys_obj
operator|->
name|cur_obj
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|phys_obj
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_gem_attach_phys_object
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|int
name|i
decl_stmt|,
name|page_count
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|id
operator|>
name|I915_MAX_PHYS_OBJECT
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
if|if
condition|(
name|obj
operator|->
name|phys_obj
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|phys_obj
operator|->
name|id
operator|==
name|id
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|i915_gem_detach_phys_object
argument_list|(
name|dev
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|mm
operator|.
name|phys_objs
index|[
name|id
operator|-
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|i915_gem_init_phys_object
argument_list|(
name|dev
argument_list|,
name|id
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to init phys object %d size: %zu\n"
argument_list|,
name|id
argument_list|,
name|obj
operator|->
name|base
operator|.
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
comment|/* bind to the object */
name|obj
operator|->
name|phys_obj
operator|=
name|dev_priv
operator|->
name|mm
operator|.
name|phys_objs
index|[
name|id
operator|-
literal|1
index|]
expr_stmt|;
name|obj
operator|->
name|phys_obj
operator|->
name|cur_obj
operator|=
name|obj
expr_stmt|;
name|page_count
operator|=
name|obj
operator|->
name|base
operator|.
name|size
operator|/
name|PAGE_SIZE
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_count
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|i915_gem_wire_page
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|EIO
expr_stmt|;
break|break;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|src
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|(
name|char
operator|*
operator|)
name|obj
operator|->
name|phys_obj
operator|->
name|handle
operator|->
name|vaddr
operator|+
name|IDX_TO_OFF
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
name|vm_page_reference
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
name|PQ_INACTIVE
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|i915_gem_wired_pages_cnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
operator|->
name|base
operator|.
name|vm_obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_gpu_is_active
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
return|return
operator|(
operator|!
name|list_empty
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|flushing_list
argument_list|)
operator|||
operator|!
name|list_empty
argument_list|(
operator|&
name|dev_priv
operator|->
name|mm
operator|.
name|active_list
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_gem_lowmem
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|struct
name|drm_i915_gem_object
modifier|*
name|obj
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|cnt_fail
decl_stmt|,
name|cnt_total
decl_stmt|;
name|dev
operator|=
name|arg
expr_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
operator|!
name|sx_try_xlock
argument_list|(
operator|&
name|dev
operator|->
name|dev_struct_lock
argument_list|)
condition|)
return|return;
name|CTR0
argument_list|(
name|KTR_DRM
argument_list|,
literal|"gem_lowmem"
argument_list|)
expr_stmt|;
name|rescan
label|:
comment|/* first scan for clean buffers */
name|i915_gem_retire_requests
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cnt_total
operator|=
name|cnt_fail
operator|=
name|cnt
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|obj
argument_list|,
argument|next
argument_list|,
argument|&dev_priv->mm.inactive_list
argument_list|,
argument|mm_list
argument_list|)
block|{
if|if
condition|(
name|i915_gem_object_is_purgeable
argument_list|(
name|obj
argument_list|)
condition|)
block|{
if|if
condition|(
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
operator|!=
literal|0
condition|)
name|cnt_total
operator|++
expr_stmt|;
block|}
else|else
name|cnt_total
operator|++
expr_stmt|;
block|}
comment|/* second pass, evict/count anything still on the inactive list */
name|list_for_each_entry_safe
argument_list|(
argument|obj
argument_list|,
argument|next
argument_list|,
argument|&dev_priv->mm.inactive_list
argument_list|,
argument|mm_list
argument_list|)
block|{
if|if
condition|(
name|i915_gem_object_unbind
argument_list|(
name|obj
argument_list|)
operator|==
literal|0
condition|)
name|cnt
operator|++
expr_stmt|;
else|else
name|cnt_fail
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cnt_fail
operator|>
name|cnt_total
operator|/
literal|100
operator|&&
name|i915_gpu_is_active
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* 		 * We are desperate for pages, so as a last resort, wait 		 * for the GPU to finish and discard whatever we can. 		 * This has a dramatic impact to reduce the number of 		 * OOM-killer events whilst running the GPU aggressively. 		 */
if|if
condition|(
name|i915_gpu_idle
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|rescan
goto|;
block|}
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_gem_unload
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vm_lowmem
argument_list|,
name|dev_priv
operator|->
name|mm
operator|.
name|i915_lowmem
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

