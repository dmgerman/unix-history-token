begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2003 Eric Anholt  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * ERIC ANHOLT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *  * Authors:  *    Eric Anholt<anholt@FreeBSD.org>  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/** @file drm_irq.c  * Support code for handling setup/teardown of interrupt handlers and  * handing interrupt handlers off to the drivers.  */
end_comment

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_VBLANK
argument_list|,
literal|"drm_vblank"
argument_list|,
literal|"DRM VBLANK Handling Data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Access macro for slots in vblank timestamp ringbuffer. */
end_comment

begin_define
define|#
directive|define
name|vblanktimestamp
parameter_list|(
name|dev
parameter_list|,
name|crtc
parameter_list|,
name|count
parameter_list|)
value|( \ 	(dev)->_vblank_time[(crtc) * DRM_VBLANKTIME_RBSIZE + \ 	((count) % DRM_VBLANKTIME_RBSIZE)])
end_define

begin_comment
comment|/* Retry timestamp calculation up to 3 times to satisfy  * drm_timestamp_precision before giving up.  */
end_comment

begin_define
define|#
directive|define
name|DRM_TIMESTAMP_MAXRETRIES
value|3
end_define

begin_comment
comment|/* Threshold in nanoseconds for detection of redundant  * vblank irq in drm_handle_vblank(). 1 msec should be ok.  */
end_comment

begin_define
define|#
directive|define
name|DRM_REDUNDANT_VBLIRQ_THRESH_NS
value|1000000
end_define

begin_function
name|int
name|drm_irq_by_busid
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_irq_busid
modifier|*
name|irq
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|irq
operator|->
name|busnum
operator|>>
literal|8
operator|)
operator|!=
name|dev
operator|->
name|pci_domain
operator|||
operator|(
name|irq
operator|->
name|busnum
operator|&
literal|0xff
operator|)
operator|!=
name|dev
operator|->
name|pci_bus
operator|||
name|irq
operator|->
name|devnum
operator|!=
name|dev
operator|->
name|pci_slot
operator|||
name|irq
operator|->
name|funcnum
operator|!=
name|dev
operator|->
name|pci_func
condition|)
return|return
name|EINVAL
return|;
name|irq
operator|->
name|irq
operator|=
name|dev
operator|->
name|irq
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%d:%d:%d => IRQ %d\n"
argument_list|,
name|irq
operator|->
name|busnum
argument_list|,
name|irq
operator|->
name|devnum
argument_list|,
name|irq
operator|->
name|funcnum
argument_list|,
name|irq
operator|->
name|irq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drm_irq_handler_wrap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|arg
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|irq_handler
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|irq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|drm_irq_install
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|retcode
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|irq
operator|==
literal|0
operator|||
name|dev
operator|->
name|dev_private
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|DRM_DEBUG
argument_list|(
literal|"irq=%d\n"
argument_list|,
name|dev
operator|->
name|irq
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|irq_enabled
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|dev
operator|->
name|irq_enabled
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|context_flag
operator|=
literal|0
expr_stmt|;
comment|/* Before installing handler */
if|if
condition|(
name|dev
operator|->
name|driver
operator|->
name|irq_preinstall
condition|)
name|dev
operator|->
name|driver
operator|->
name|irq_preinstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Install handler */
name|retcode
operator|=
name|bus_setup_intr
argument_list|(
name|dev
operator|->
name|device
argument_list|,
name|dev
operator|->
name|irqr
argument_list|,
name|INTR_TYPE_TTY
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
operator|(
name|dev
operator|->
name|driver
operator|->
name|driver_features
operator|&
name|DRIVER_LOCKLESS_IRQ
operator|)
operator|!=
literal|0
condition|?
name|drm_irq_handler_wrap
else|:
name|dev
operator|->
name|driver
operator|->
name|irq_handler
argument_list|,
name|dev
argument_list|,
operator|&
name|dev
operator|->
name|irqh
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* After installing handler */
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|driver
operator|->
name|irq_postinstall
condition|)
name|dev
operator|->
name|driver
operator|->
name|irq_postinstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|device_printf
argument_list|(
name|dev
operator|->
name|device
argument_list|,
literal|"Error setting interrupt: %d\n"
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
name|dev
operator|->
name|irq_enabled
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_function
name|int
name|drm_irq_uninstall
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|irq_enabled
condition|)
return|return
name|EINVAL
return|;
name|dev
operator|->
name|irq_enabled
operator|=
literal|0
expr_stmt|;
comment|/* 	* Wake up any waiters so they don't hang. 	*/
if|if
condition|(
name|dev
operator|->
name|num_crtcs
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|vbl_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|num_crtcs
condition|;
name|i
operator|++
control|)
block|{
name|wakeup
argument_list|(
operator|&
name|dev
operator|->
name|_vblank_count
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dev
operator|->
name|vblank_enabled
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|last_vblank
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|driver
operator|->
name|get_vblank_counter
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|vbl_lock
argument_list|)
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"irq=%d\n"
argument_list|,
name|dev
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|driver
operator|->
name|irq_uninstall
condition|)
name|dev
operator|->
name|driver
operator|->
name|irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
operator|->
name|device
argument_list|,
name|dev
operator|->
name|irqr
argument_list|,
name|dev
operator|->
name|irqh
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|drm_control
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_control
modifier|*
name|ctl
init|=
name|data
decl_stmt|;
name|int
name|err
decl_stmt|;
switch|switch
condition|(
name|ctl
operator|->
name|func
condition|)
block|{
case|case
name|DRM_INST_HANDLER
case|:
comment|/* Handle drivers whose DRM used to require IRQ setup but the 		 * no longer does. 		 */
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_HAVE_IRQ
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dev
operator|->
name|if_version
operator|<
name|DRM_IF_VERSION
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|&&
name|ctl
operator|->
name|irq
operator|!=
name|dev
operator|->
name|irq
condition|)
return|return
name|EINVAL
return|;
return|return
name|drm_irq_install
argument_list|(
name|dev
argument_list|)
return|;
case|case
name|DRM_UNINST_HANDLER
case|:
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_HAVE_IRQ
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
literal|0
return|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|drm_irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|NSEC_PER_USEC
value|1000L
end_define

begin_define
define|#
directive|define
name|NSEC_PER_SEC
value|1000000000L
end_define

begin_function
name|int64_t
name|timeval_to_ns
parameter_list|(
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
return|return
operator|(
operator|(
name|int64_t
operator|)
name|tv
operator|->
name|tv_sec
operator|*
name|NSEC_PER_SEC
operator|)
operator|+
name|tv
operator|->
name|tv_usec
operator|*
name|NSEC_PER_USEC
return|;
block|}
end_function

begin_function
name|struct
name|timeval
name|ns_to_timeval
parameter_list|(
specifier|const
name|int64_t
name|nsec
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|long
name|rem
decl_stmt|;
if|if
condition|(
name|nsec
operator|==
literal|0
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|tv
operator|)
return|;
block|}
name|tv
operator|.
name|tv_sec
operator|=
name|nsec
operator|/
name|NSEC_PER_SEC
expr_stmt|;
name|rem
operator|=
name|nsec
operator|%
name|NSEC_PER_SEC
expr_stmt|;
if|if
condition|(
name|rem
operator|<
literal|0
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|rem
operator|+=
name|NSEC_PER_SEC
expr_stmt|;
block|}
name|tv
operator|.
name|tv_usec
operator|=
name|rem
operator|/
literal|1000
expr_stmt|;
return|return
operator|(
name|tv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear vblank timestamp buffer for a crtc.  */
end_comment

begin_function
specifier|static
name|void
name|clear_vblank_timestamps
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|crtc
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|dev
operator|->
name|_vblank_time
index|[
name|crtc
operator|*
name|DRM_VBLANKTIME_RBSIZE
index|]
argument_list|,
literal|0
argument_list|,
name|DRM_VBLANKTIME_RBSIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|abs64
parameter_list|(
name|int64_t
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|<
literal|0
condition|?
operator|-
name|x
else|:
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disable vblank irq's on crtc, make sure that last vblank count  * of hardware and corresponding consistent software vblank counter  * are preserved, even if there are any spurious vblank irq's after  * disable.  */
end_comment

begin_function
specifier|static
name|void
name|vblank_disable_and_save
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|crtc
parameter_list|)
block|{
name|u32
name|vblcount
decl_stmt|;
name|int64_t
name|diff_ns
decl_stmt|;
name|int
name|vblrc
decl_stmt|;
name|struct
name|timeval
name|tvblank
decl_stmt|;
comment|/* Prevent vblank irq processing while disabling vblank irqs, 	 * so no updates of timestamps or count can happen after we've 	 * disabled. Needed to prevent races in case of delayed irq's. 	 */
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|vblank_time_lock
argument_list|)
expr_stmt|;
name|dev
operator|->
name|driver
operator|->
name|disable_vblank
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
name|dev
operator|->
name|vblank_enabled
index|[
name|crtc
index|]
operator|=
literal|0
expr_stmt|;
comment|/* No further vblank irq's will be processed after 	 * this point. Get current hardware vblank count and 	 * vblank timestamp, repeat until they are consistent. 	 * 	 * FIXME: There is still a race condition here and in 	 * drm_update_vblank_count() which can cause off-by-one 	 * reinitialization of software vblank counter. If gpu 	 * vblank counter doesn't increment exactly at the leading 	 * edge of a vblank interval, then we can lose 1 count if 	 * we happen to execute between start of vblank and the 	 * delayed gpu counter increment. 	 */
do|do
block|{
name|dev
operator|->
name|last_vblank
index|[
name|crtc
index|]
operator|=
name|dev
operator|->
name|driver
operator|->
name|get_vblank_counter
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
name|vblrc
operator|=
name|drm_get_last_vbltimestamp
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
operator|&
name|tvblank
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dev
operator|->
name|last_vblank
index|[
name|crtc
index|]
operator|!=
name|dev
operator|->
name|driver
operator|->
name|get_vblank_counter
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
condition|)
do|;
comment|/* Compute time difference to stored timestamp of last vblank 	 * as updated by last invocation of drm_handle_vblank() in vblank irq. 	 */
name|vblcount
operator|=
name|atomic_read
argument_list|(
operator|&
name|dev
operator|->
name|_vblank_count
index|[
name|crtc
index|]
argument_list|)
expr_stmt|;
name|diff_ns
operator|=
name|timeval_to_ns
argument_list|(
operator|&
name|tvblank
argument_list|)
operator|-
name|timeval_to_ns
argument_list|(
operator|&
name|vblanktimestamp
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
name|vblcount
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is at least 1 msec difference between the last stored 	 * timestamp and tvblank, then we are currently executing our 	 * disable inside a new vblank interval, the tvblank timestamp 	 * corresponds to this new vblank interval and the irq handler 	 * for this vblank didn't run yet and won't run due to our disable. 	 * Therefore we need to do the job of drm_handle_vblank() and 	 * increment the vblank counter by one to account for this vblank. 	 * 	 * Skip this step if there isn't any high precision timestamp 	 * available. In that case we can't account for this and just 	 * hope for the best. 	 */
if|if
condition|(
operator|(
name|vblrc
operator|>
literal|0
operator|)
operator|&&
operator|(
name|abs64
argument_list|(
name|diff_ns
argument_list|)
operator|>
literal|1000000
operator|)
condition|)
block|{
name|atomic_inc
argument_list|(
operator|&
name|dev
operator|->
name|_vblank_count
index|[
name|crtc
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Invalidate all timestamps while vblank irq's are off. */
name|clear_vblank_timestamps
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|vblank_time_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vblank_disable_fn
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
operator|(
expr|struct
name|drm_device
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|vblank_disable_allowed
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|num_crtcs
condition|;
name|i
operator|++
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|vbl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|dev
operator|->
name|vblank_refcount
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|dev
operator|->
name|vblank_enabled
index|[
name|i
index|]
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"disabling vblank on crtc %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vblank_disable_and_save
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|vbl_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|drm_vblank_cleanup
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
comment|/* Bail if the driver didn't call drm_vblank_init() */
if|if
condition|(
name|dev
operator|->
name|num_crtcs
operator|==
literal|0
condition|)
return|return;
name|callout_stop
argument_list|(
operator|&
name|dev
operator|->
name|vblank_disable_callout
argument_list|)
expr_stmt|;
name|vblank_disable_fn
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
operator|->
name|_vblank_count
argument_list|,
name|DRM_MEM_VBLANK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
operator|->
name|vblank_refcount
argument_list|,
name|DRM_MEM_VBLANK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
operator|->
name|vblank_enabled
argument_list|,
name|DRM_MEM_VBLANK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
operator|->
name|last_vblank
argument_list|,
name|DRM_MEM_VBLANK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
operator|->
name|last_vblank_wait
argument_list|,
name|DRM_MEM_VBLANK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
operator|->
name|vblank_inmodeset
argument_list|,
name|DRM_MEM_VBLANK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
operator|->
name|_vblank_time
argument_list|,
name|DRM_MEM_VBLANK
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_crtcs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|drm_vblank_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|num_crtcs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|callout_init
argument_list|(
operator|&
name|dev
operator|->
name|vblank_disable_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|mtx_init(&dev->vbl_lock, "drmvbl", NULL, MTX_DEF);
endif|#
directive|endif
name|mtx_init
argument_list|(
operator|&
name|dev
operator|->
name|vblank_time_lock
argument_list|,
literal|"drmvtl"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_crtcs
operator|=
name|num_crtcs
expr_stmt|;
name|dev
operator|->
name|_vblank_count
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|atomic_t
argument_list|)
operator|*
name|num_crtcs
argument_list|,
name|DRM_MEM_VBLANK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|dev
operator|->
name|vblank_refcount
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|atomic_t
argument_list|)
operator|*
name|num_crtcs
argument_list|,
name|DRM_MEM_VBLANK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|dev
operator|->
name|vblank_enabled
operator|=
name|malloc
argument_list|(
name|num_crtcs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|DRM_MEM_VBLANK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|dev
operator|->
name|last_vblank
operator|=
name|malloc
argument_list|(
name|num_crtcs
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|DRM_MEM_VBLANK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|dev
operator|->
name|last_vblank_wait
operator|=
name|malloc
argument_list|(
name|num_crtcs
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|DRM_MEM_VBLANK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|dev
operator|->
name|vblank_inmodeset
operator|=
name|malloc
argument_list|(
name|num_crtcs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|DRM_MEM_VBLANK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|dev
operator|->
name|_vblank_time
operator|=
name|malloc
argument_list|(
name|num_crtcs
operator|*
name|DRM_VBLANKTIME_RBSIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|,
name|DRM_MEM_VBLANK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"Supports vblank timestamp caching Rev 1 (10.10.2010).\n"
argument_list|)
expr_stmt|;
comment|/* Driver specific high-precision vblank timestamping supported? */
if|if
condition|(
name|dev
operator|->
name|driver
operator|->
name|get_vblank_timestamp
condition|)
name|DRM_INFO
argument_list|(
literal|"Driver supports precise vblank timestamp query.\n"
argument_list|)
expr_stmt|;
else|else
name|DRM_INFO
argument_list|(
literal|"No driver support for vblank timestamp query.\n"
argument_list|)
expr_stmt|;
comment|/* Zero per-crtc vblank stuff */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_crtcs
condition|;
name|i
operator|++
control|)
block|{
name|atomic_set
argument_list|(
operator|&
name|dev
operator|->
name|_vblank_count
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|dev
operator|->
name|vblank_refcount
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|vblank_disable_allowed
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|drm_calc_timestamping_constants
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|int64_t
name|linedur_ns
init|=
literal|0
decl_stmt|,
name|pixeldur_ns
init|=
literal|0
decl_stmt|,
name|framedur_ns
init|=
literal|0
decl_stmt|;
name|uint64_t
name|dotclock
decl_stmt|;
comment|/* Dot clock in Hz: */
name|dotclock
operator|=
operator|(
name|uint64_t
operator|)
name|crtc
operator|->
name|hwmode
operator|.
name|clock
operator|*
literal|1000
expr_stmt|;
comment|/* Fields of interlaced scanout modes are only halve a frame duration. 	 * Double the dotclock to get halve the frame-/line-/pixelduration. 	 */
if|if
condition|(
name|crtc
operator|->
name|hwmode
operator|.
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
condition|)
name|dotclock
operator|*=
literal|2
expr_stmt|;
comment|/* Valid dotclock? */
if|if
condition|(
name|dotclock
operator|>
literal|0
condition|)
block|{
comment|/* Convert scanline length in pixels and video dot clock to 		 * line duration, frame duration and pixel duration in 		 * nanoseconds: 		 */
name|pixeldur_ns
operator|=
operator|(
name|int64_t
operator|)
literal|1000000000
operator|/
name|dotclock
expr_stmt|;
name|linedur_ns
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|crtc
operator|->
name|hwmode
operator|.
name|crtc_htotal
operator|*
literal|1000000000
operator|)
operator|/
name|dotclock
expr_stmt|;
name|framedur_ns
operator|=
operator|(
name|int64_t
operator|)
name|crtc
operator|->
name|hwmode
operator|.
name|crtc_vtotal
operator|*
name|linedur_ns
expr_stmt|;
block|}
else|else
name|DRM_ERROR
argument_list|(
literal|"crtc %d: Can't calculate constants, dotclock = 0!\n"
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|pixeldur_ns
operator|=
name|pixeldur_ns
expr_stmt|;
name|crtc
operator|->
name|linedur_ns
operator|=
name|linedur_ns
expr_stmt|;
name|crtc
operator|->
name|framedur_ns
operator|=
name|framedur_ns
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"crtc %d: hwmode: htotal %d, vtotal %d, vdisplay %d\n"
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|,
name|crtc
operator|->
name|hwmode
operator|.
name|crtc_htotal
argument_list|,
name|crtc
operator|->
name|hwmode
operator|.
name|crtc_vtotal
argument_list|,
name|crtc
operator|->
name|hwmode
operator|.
name|crtc_vdisplay
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"crtc %d: clock %d kHz framedur %d linedur %d, pixeldur %d\n"
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|,
operator|(
name|int
operator|)
name|dotclock
operator|/
literal|1000
argument_list|,
operator|(
name|int
operator|)
name|framedur_ns
argument_list|,
operator|(
name|int
operator|)
name|linedur_ns
argument_list|,
operator|(
name|int
operator|)
name|pixeldur_ns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_calc_vbltimestamp_from_scanoutpos - helper routine for kms  * drivers. Implements calculation of exact vblank timestamps from  * given drm_display_mode timings and current video scanout position  * of a crtc. This can be called from within get_vblank_timestamp()  * implementation of a kms driver to implement the actual timestamping.  *  * Should return timestamps conforming to the OML_sync_control OpenML  * extension specification. The timestamp corresponds to the end of  * the vblank interval, aka start of scanout of topmost-leftmost display  * pixel in the following video frame.  *  * Requires support for optional dev->driver->get_scanout_position()  * in kms driver, plus a bit of setup code to provide a drm_display_mode  * that corresponds to the true scanout timing.  *  * The current implementation only handles standard video modes. It  * returns as no operation if a doublescan or interlaced video mode is  * active. Higher level code is expected to handle this.  *  * @dev: DRM device.  * @crtc: Which crtc's vblank timestamp to retrieve.  * @max_error: Desired maximum allowable error in timestamps (nanosecs).  *             On return contains true maximum error of timestamp.  * @vblank_time: Pointer to struct timeval which should receive the timestamp.  * @flags: Flags to pass to driver:  *         0 = Default.  *         DRM_CALLED_FROM_VBLIRQ = If function is called from vbl irq handler.  * @refcrtc: drm_crtc* of crtc which defines scanout timing.  *  * Returns negative value on error, failure or if not supported in current  * video mode:  *  * -EINVAL   - Invalid crtc.  * -EAGAIN   - Temporary unavailable, e.g., called before initial modeset.  * -ENOTSUPP - Function not supported in current display mode.  * -EIO      - Failed, e.g., due to failed scanout position query.  *  * Returns or'ed positive status flags on success:  *  * DRM_VBLANKTIME_SCANOUTPOS_METHOD - Signal this method used for timestamping.  * DRM_VBLANKTIME_INVBL - Timestamp taken while scanout was in vblank interval.  *  */
end_comment

begin_function
name|int
name|drm_calc_vbltimestamp_from_scanoutpos
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|crtc
parameter_list|,
name|int
modifier|*
name|max_error
parameter_list|,
name|struct
name|timeval
modifier|*
name|vblank_time
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|refcrtc
parameter_list|)
block|{
name|struct
name|timeval
name|stime
decl_stmt|,
name|raw_time
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|int
name|vbl_status
decl_stmt|,
name|vtotal
decl_stmt|,
name|vdisplay
decl_stmt|;
name|int
name|vpos
decl_stmt|,
name|hpos
decl_stmt|,
name|i
decl_stmt|;
name|int64_t
name|framedur_ns
decl_stmt|,
name|linedur_ns
decl_stmt|,
name|pixeldur_ns
decl_stmt|,
name|delta_ns
decl_stmt|,
name|duration_ns
decl_stmt|;
name|bool
name|invbl
decl_stmt|;
if|if
condition|(
name|crtc
operator|<
literal|0
operator|||
name|crtc
operator|>=
name|dev
operator|->
name|num_crtcs
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid crtc %d\n"
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Scanout position query not supported? Should not happen. */
if|if
condition|(
operator|!
name|dev
operator|->
name|driver
operator|->
name|get_scanout_position
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Called from driver w/o get_scanout_position()!?\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
name|mode
operator|=
operator|&
name|refcrtc
operator|->
name|hwmode
expr_stmt|;
name|vtotal
operator|=
name|mode
operator|->
name|crtc_vtotal
expr_stmt|;
name|vdisplay
operator|=
name|mode
operator|->
name|crtc_vdisplay
expr_stmt|;
comment|/* Durations of frames, lines, pixels in nanoseconds. */
name|framedur_ns
operator|=
name|refcrtc
operator|->
name|framedur_ns
expr_stmt|;
name|linedur_ns
operator|=
name|refcrtc
operator|->
name|linedur_ns
expr_stmt|;
name|pixeldur_ns
operator|=
name|refcrtc
operator|->
name|pixeldur_ns
expr_stmt|;
comment|/* If mode timing undefined, just return as no-op: 	 * Happens during initial modesetting of a crtc. 	 */
if|if
condition|(
name|vtotal
operator|<=
literal|0
operator|||
name|vdisplay
operator|<=
literal|0
operator|||
name|framedur_ns
operator|==
literal|0
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"crtc %d: Noop due to uninitialized mode.\n"
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
return|return
operator|-
name|EAGAIN
return|;
block|}
comment|/* Get current scanout position with system timestamp. 	 * Repeat query up to DRM_TIMESTAMP_MAXRETRIES times 	 * if single query takes longer than max_error nanoseconds. 	 * 	 * This guarantees a tight bound on maximum error if 	 * code gets preempted or delayed for some reason. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_TIMESTAMP_MAXRETRIES
condition|;
name|i
operator|++
control|)
block|{
comment|/* Disable preemption to make it very likely to 		 * succeed in the first iteration. 		 */
name|critical_enter
argument_list|()
expr_stmt|;
comment|/* Get system timestamp before query. */
name|getmicrouptime
argument_list|(
operator|&
name|stime
argument_list|)
expr_stmt|;
comment|/* Get vertical and horizontal scanout pos. vpos, hpos. */
name|vbl_status
operator|=
name|dev
operator|->
name|driver
operator|->
name|get_scanout_position
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
operator|&
name|vpos
argument_list|,
operator|&
name|hpos
argument_list|)
expr_stmt|;
comment|/* Get system timestamp after query. */
name|getmicrouptime
argument_list|(
operator|&
name|raw_time
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
comment|/* Return as no-op if scanout query unsupported or failed. */
if|if
condition|(
operator|!
operator|(
name|vbl_status
operator|&
name|DRM_SCANOUTPOS_VALID
operator|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"crtc %d : scanoutpos query failed [%d].\n"
argument_list|,
name|crtc
argument_list|,
name|vbl_status
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
name|duration_ns
operator|=
name|timeval_to_ns
argument_list|(
operator|&
name|raw_time
argument_list|)
operator|-
name|timeval_to_ns
argument_list|(
operator|&
name|stime
argument_list|)
expr_stmt|;
comment|/* Accept result with<  max_error nsecs timing uncertainty. */
if|if
condition|(
name|duration_ns
operator|<=
operator|(
name|int64_t
operator|)
operator|*
name|max_error
condition|)
break|break;
block|}
comment|/* Noisy system timing? */
if|if
condition|(
name|i
operator|==
name|DRM_TIMESTAMP_MAXRETRIES
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"crtc %d: Noisy timestamp %d us> %d us [%d reps].\n"
argument_list|,
name|crtc
argument_list|,
operator|(
name|int
operator|)
name|duration_ns
operator|/
literal|1000
argument_list|,
operator|*
name|max_error
operator|/
literal|1000
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Return upper bound of timestamp precision error. */
operator|*
name|max_error
operator|=
operator|(
name|int
operator|)
name|duration_ns
expr_stmt|;
comment|/* Check if in vblank area: 	 * vpos is>=0 in video scanout area, but negative 	 * within vblank area, counting down the number of lines until 	 * start of scanout. 	 */
name|invbl
operator|=
name|vbl_status
operator|&
name|DRM_SCANOUTPOS_INVBL
expr_stmt|;
comment|/* Convert scanout position into elapsed time at raw_time query 	 * since start of scanout at first display scanline. delta_ns 	 * can be negative if start of scanout hasn't happened yet. 	 */
name|delta_ns
operator|=
operator|(
name|int64_t
operator|)
name|vpos
operator|*
name|linedur_ns
operator|+
operator|(
name|int64_t
operator|)
name|hpos
operator|*
name|pixeldur_ns
expr_stmt|;
comment|/* Is vpos outside nominal vblank area, but less than 	 * 1/100 of a frame height away from start of vblank? 	 * If so, assume this isn't a massively delayed vblank 	 * interrupt, but a vblank interrupt that fired a few 	 * microseconds before true start of vblank. Compensate 	 * by adding a full frame duration to the final timestamp. 	 * Happens, e.g., on ATI R500, R600. 	 * 	 * We only do this if DRM_CALLED_FROM_VBLIRQ. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|DRM_CALLED_FROM_VBLIRQ
operator|)
operator|&&
operator|!
name|invbl
operator|&&
operator|(
operator|(
name|vdisplay
operator|-
name|vpos
operator|)
operator|<
name|vtotal
operator|/
literal|100
operator|)
condition|)
block|{
name|delta_ns
operator|=
name|delta_ns
operator|-
name|framedur_ns
expr_stmt|;
comment|/* Signal this correction as "applied". */
name|vbl_status
operator||=
literal|0x8
expr_stmt|;
block|}
comment|/* Subtract time delta from raw timestamp to get final 	 * vblank_time timestamp for end of vblank. 	 */
operator|*
name|vblank_time
operator|=
name|ns_to_timeval
argument_list|(
name|timeval_to_ns
argument_list|(
operator|&
name|raw_time
argument_list|)
operator|-
name|delta_ns
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"crtc %d : v %d p(%d,%d)@ %jd.%jd -> %jd.%jd [e %d us, %d rep]\n"
argument_list|,
name|crtc
argument_list|,
operator|(
name|int
operator|)
name|vbl_status
argument_list|,
name|hpos
argument_list|,
name|vpos
argument_list|,
operator|(
name|uintmax_t
operator|)
name|raw_time
operator|.
name|tv_sec
argument_list|,
operator|(
name|uintmax_t
operator|)
name|raw_time
operator|.
name|tv_usec
argument_list|,
operator|(
name|uintmax_t
operator|)
name|vblank_time
operator|->
name|tv_sec
argument_list|,
operator|(
name|uintmax_t
operator|)
name|vblank_time
operator|->
name|tv_usec
argument_list|,
operator|(
name|int
operator|)
name|duration_ns
operator|/
literal|1000
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vbl_status
operator|=
name|DRM_VBLANKTIME_SCANOUTPOS_METHOD
expr_stmt|;
if|if
condition|(
name|invbl
condition|)
name|vbl_status
operator||=
name|DRM_VBLANKTIME_INVBL
expr_stmt|;
return|return
name|vbl_status
return|;
block|}
end_function

begin_comment
comment|/**  * drm_get_last_vbltimestamp - retrieve raw timestamp for the most recent  * vblank interval.  *  * @dev: DRM device  * @crtc: which crtc's vblank timestamp to retrieve  * @tvblank: Pointer to target struct timeval which should receive the timestamp  * @flags: Flags to pass to driver:  *         0 = Default.  *         DRM_CALLED_FROM_VBLIRQ = If function is called from vbl irq handler.  *  * Fetches the system timestamp corresponding to the time of the most recent  * vblank interval on specified crtc. May call into kms-driver to  * compute the timestamp with a high-precision GPU specific method.  *  * Returns zero if timestamp originates from uncorrected do_gettimeofday()  * call, i.e., it isn't very precisely locked to the true vblank.  *  * Returns non-zero if timestamp is considered to be very precise.  */
end_comment

begin_function
name|u32
name|drm_get_last_vbltimestamp
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|crtc
parameter_list|,
name|struct
name|timeval
modifier|*
name|tvblank
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* Define requested maximum error on timestamps (nanoseconds). */
name|int
name|max_error
init|=
operator|(
name|int
operator|)
name|drm_timestamp_precision
operator|*
literal|1000
decl_stmt|;
comment|/* Query driver if possible and precision timestamping enabled. */
if|if
condition|(
name|dev
operator|->
name|driver
operator|->
name|get_vblank_timestamp
operator|&&
operator|(
name|max_error
operator|>
literal|0
operator|)
condition|)
block|{
name|ret
operator|=
name|dev
operator|->
name|driver
operator|->
name|get_vblank_timestamp
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
operator|&
name|max_error
argument_list|,
name|tvblank
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
operator|(
name|u32
operator|)
name|ret
return|;
block|}
comment|/* GPU high precision timestamp query unsupported or failed. 	 * Return gettimeofday timestamp as best estimate. 	 */
name|microtime
argument_list|(
name|tvblank
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * drm_vblank_count - retrieve "cooked" vblank counter value  * @dev: DRM device  * @crtc: which counter to retrieve  *  * Fetches the "cooked" vblank count value that represents the number of  * vblank events since the system was booted, including lost events due to  * modesetting activity.  */
end_comment

begin_function
name|u32
name|drm_vblank_count
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|crtc
parameter_list|)
block|{
return|return
name|atomic_read
argument_list|(
operator|&
name|dev
operator|->
name|_vblank_count
index|[
name|crtc
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * drm_vblank_count_and_time - retrieve "cooked" vblank counter value  * and the system timestamp corresponding to that vblank counter value.  *  * @dev: DRM device  * @crtc: which counter to retrieve  * @vblanktime: Pointer to struct timeval to receive the vblank timestamp.  *  * Fetches the "cooked" vblank count value that represents the number of  * vblank events since the system was booted, including lost events due to  * modesetting activity. Returns corresponding system timestamp of the time  * of the vblank interval that corresponds to the current value vblank counter  * value.  */
end_comment

begin_function
name|u32
name|drm_vblank_count_and_time
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|crtc
parameter_list|,
name|struct
name|timeval
modifier|*
name|vblanktime
parameter_list|)
block|{
name|u32
name|cur_vblank
decl_stmt|;
comment|/* Read timestamp from slot of _vblank_time ringbuffer 	 * that corresponds to current vblank count. Retry if 	 * count has incremented during readout. This works like 	 * a seqlock. 	 */
do|do
block|{
name|cur_vblank
operator|=
name|atomic_read
argument_list|(
operator|&
name|dev
operator|->
name|_vblank_count
index|[
name|crtc
index|]
argument_list|)
expr_stmt|;
operator|*
name|vblanktime
operator|=
name|vblanktimestamp
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
name|cur_vblank
argument_list|)
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|cur_vblank
operator|!=
name|atomic_read
argument_list|(
operator|&
name|dev
operator|->
name|_vblank_count
index|[
name|crtc
index|]
argument_list|)
condition|)
do|;
return|return
name|cur_vblank
return|;
block|}
end_function

begin_comment
comment|/**  * drm_update_vblank_count - update the master vblank counter  * @dev: DRM device  * @crtc: counter to update  *  * Call back into the driver to update the appropriate vblank counter  * (specified by @crtc).  Deal with wraparound, if it occurred, and  * update the last read value so we can deal with wraparound on the next  * call if necessary.  *  * Only necessary when going from off->on, to account for frames we  * didn't get an interrupt for.  *  * Note: caller must hold dev->vbl_lock since this reads& writes  * device vblank fields.  */
end_comment

begin_function
specifier|static
name|void
name|drm_update_vblank_count
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|crtc
parameter_list|)
block|{
name|u32
name|cur_vblank
decl_stmt|,
name|diff
decl_stmt|,
name|tslot
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|timeval
name|t_vblank
decl_stmt|;
comment|/* 	 * Interrupts were disabled prior to this call, so deal with counter 	 * wrap if needed. 	 * NOTE!  It's possible we lost a full dev->max_vblank_count events 	 * here if the register is small or we had vblank interrupts off for 	 * a long time. 	 * 	 * We repeat the hardware vblank counter& timestamp query until 	 * we get consistent results. This to prevent races between gpu 	 * updating its hardware counter while we are retrieving the 	 * corresponding vblank timestamp. 	 */
do|do
block|{
name|cur_vblank
operator|=
name|dev
operator|->
name|driver
operator|->
name|get_vblank_counter
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|drm_get_last_vbltimestamp
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
operator|&
name|t_vblank
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cur_vblank
operator|!=
name|dev
operator|->
name|driver
operator|->
name|get_vblank_counter
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
condition|)
do|;
comment|/* Deal with counter wrap */
name|diff
operator|=
name|cur_vblank
operator|-
name|dev
operator|->
name|last_vblank
index|[
name|crtc
index|]
expr_stmt|;
if|if
condition|(
name|cur_vblank
operator|<
name|dev
operator|->
name|last_vblank
index|[
name|crtc
index|]
condition|)
block|{
name|diff
operator|+=
name|dev
operator|->
name|max_vblank_count
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"last_vblank[%d]=0x%x, cur_vblank=0x%x => diff=0x%x\n"
argument_list|,
name|crtc
argument_list|,
name|dev
operator|->
name|last_vblank
index|[
name|crtc
index|]
argument_list|,
name|cur_vblank
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"enabling vblank interrupts on crtc %d, missed %d\n"
argument_list|,
name|crtc
argument_list|,
name|diff
argument_list|)
expr_stmt|;
comment|/* Reinitialize corresponding vblank timestamp if high-precision query 	 * available. Skip this step if query unsupported or failed. Will 	 * reinitialize delayed at next vblank interrupt in that case. 	 */
if|if
condition|(
name|rc
condition|)
block|{
name|tslot
operator|=
name|atomic_read
argument_list|(
operator|&
name|dev
operator|->
name|_vblank_count
index|[
name|crtc
index|]
argument_list|)
operator|+
name|diff
expr_stmt|;
name|vblanktimestamp
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
name|tslot
argument_list|)
operator|=
name|t_vblank
expr_stmt|;
block|}
name|atomic_add
argument_list|(
name|diff
argument_list|,
operator|&
name|dev
operator|->
name|_vblank_count
index|[
name|crtc
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_vblank_get - get a reference count on vblank events  * @dev: DRM device  * @crtc: which CRTC to own  *  * Acquire a reference count on vblank events to avoid having them disabled  * while in use.  *  * RETURNS  * Zero on success, nonzero on failure.  */
end_comment

begin_function
name|int
name|drm_vblank_get
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|crtc
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|vbl_lock
argument_list|)
expr_stmt|;
comment|/* Going from 0->1 means we have to enable interrupts again */
if|if
condition|(
name|atomic_add_return
argument_list|(
literal|1
argument_list|,
operator|&
name|dev
operator|->
name|vblank_refcount
index|[
name|crtc
index|]
argument_list|)
operator|==
literal|1
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|vblank_time_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|vblank_enabled
index|[
name|crtc
index|]
condition|)
block|{
comment|/* Enable vblank irqs under vblank_time_lock protection. 			 * All vblank count& timestamp updates are held off 			 * until we are done reinitializing master counter and 			 * timestamps. Filtercode in drm_handle_vblank() will 			 * prevent double-accounting of same vblank interval. 			 */
name|ret
operator|=
operator|-
name|dev
operator|->
name|driver
operator|->
name|enable_vblank
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"enabling vblank on crtc %d, ret: %d\n"
argument_list|,
name|crtc
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|vblank_refcount
index|[
name|crtc
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|dev
operator|->
name|vblank_enabled
index|[
name|crtc
index|]
operator|=
literal|1
expr_stmt|;
name|drm_update_vblank_count
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|vblank_time_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|dev
operator|->
name|vblank_enabled
index|[
name|crtc
index|]
condition|)
block|{
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|vblank_refcount
index|[
name|crtc
index|]
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|vbl_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * drm_vblank_put - give up ownership of vblank events  * @dev: DRM device  * @crtc: which counter to give up  *  * Release ownership of a given vblank counter, turning off interrupts  * if possible. Disable interrupts after drm_vblank_offdelay milliseconds.  */
end_comment

begin_function
name|void
name|drm_vblank_put
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|crtc
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|dev
operator|->
name|vblank_refcount
index|[
name|crtc
index|]
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"Too many drm_vblank_put for crtc %d"
operator|,
name|crtc
operator|)
argument_list|)
expr_stmt|;
comment|/* Last user schedules interrupt disable */
if|if
condition|(
name|atomic_dec_and_test
argument_list|(
operator|&
name|dev
operator|->
name|vblank_refcount
index|[
name|crtc
index|]
argument_list|)
operator|&&
operator|(
name|drm_vblank_offdelay
operator|>
literal|0
operator|)
condition|)
name|callout_reset
argument_list|(
operator|&
name|dev
operator|->
name|vblank_disable_callout
argument_list|,
operator|(
name|drm_vblank_offdelay
operator|*
name|DRM_HZ
operator|)
operator|/
literal|1000
argument_list|,
name|vblank_disable_fn
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|drm_vblank_off
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|crtc
parameter_list|)
block|{
name|struct
name|drm_pending_vblank_event
modifier|*
name|e
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|unsigned
name|int
name|seq
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|vbl_lock
argument_list|)
expr_stmt|;
name|vblank_disable_and_save
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|dev
operator|->
name|_vblank_count
index|[
name|crtc
index|]
argument_list|)
expr_stmt|;
comment|/* Send any queued vblank events, lest the natives grow disquiet */
name|seq
operator|=
name|drm_vblank_count_and_time
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|e
argument_list|,
argument|t
argument_list|,
argument|&dev->vblank_event_list
argument_list|,
argument|base.link
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|pipe
operator|!=
name|crtc
condition|)
continue|continue;
name|DRM_DEBUG
argument_list|(
literal|"Sending premature vblank event on disable: \ 			  wanted %d, current %d\n"
argument_list|,
name|e
operator|->
name|event
operator|.
name|sequence
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|sequence
operator|=
name|seq
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|tv_usec
operator|=
name|now
operator|.
name|tv_usec
expr_stmt|;
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|e
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|e
operator|->
name|base
operator|.
name|link
argument_list|,
operator|&
name|e
operator|->
name|base
operator|.
name|file_priv
operator|->
name|event_list
argument_list|)
expr_stmt|;
name|drm_event_wakeup
argument_list|(
operator|&
name|e
operator|->
name|base
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"vblank_event_delivered %d %d %d"
argument_list|,
name|e
operator|->
name|base
operator|.
name|pid
argument_list|,
name|e
operator|->
name|pipe
argument_list|,
name|e
operator|->
name|event
operator|.
name|sequence
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|vbl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_vblank_pre_modeset - account for vblanks across mode sets  * @dev: DRM device  * @crtc: CRTC in question  * @post: post or pre mode set?  *  * Account for vblank events across mode setting events, which will likely  * reset the hardware frame counter.  */
end_comment

begin_function
name|void
name|drm_vblank_pre_modeset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|crtc
parameter_list|)
block|{
comment|/* vblank is not initialized (IRQ not installed ?) */
if|if
condition|(
operator|!
name|dev
operator|->
name|num_crtcs
condition|)
return|return;
comment|/* 	 * To avoid all the problems that might happen if interrupts 	 * were enabled/disabled around or between these calls, we just 	 * have the kernel take a reference on the CRTC (just once though 	 * to avoid corrupting the count if multiple, mismatch calls occur), 	 * so that interrupts remain enabled in the interim. 	 */
if|if
condition|(
operator|!
name|dev
operator|->
name|vblank_inmodeset
index|[
name|crtc
index|]
condition|)
block|{
name|dev
operator|->
name|vblank_inmodeset
index|[
name|crtc
index|]
operator|=
literal|0x1
expr_stmt|;
if|if
condition|(
name|drm_vblank_get
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
operator|==
literal|0
condition|)
name|dev
operator|->
name|vblank_inmodeset
index|[
name|crtc
index|]
operator||=
literal|0x2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|drm_vblank_post_modeset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|crtc
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|vblank_inmodeset
index|[
name|crtc
index|]
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|vbl_lock
argument_list|)
expr_stmt|;
name|dev
operator|->
name|vblank_disable_allowed
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|vbl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|vblank_inmodeset
index|[
name|crtc
index|]
operator|&
literal|0x2
condition|)
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
name|dev
operator|->
name|vblank_inmodeset
index|[
name|crtc
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * drm_modeset_ctl - handle vblank event counter changes across mode switch  * @DRM_IOCTL_ARGS: standard ioctl arguments  *  * Applications should call the %_DRM_PRE_MODESET and %_DRM_POST_MODESET  * ioctls around modesetting so that any lost vblank events are accounted for.  *  * Generally the counter will reset across mode sets.  If interrupts are  * enabled around this call, we don't have to do anything since the counter  * will have already been incremented.  */
end_comment

begin_function
name|int
name|drm_modeset_ctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_modeset_ctl
modifier|*
name|modeset
init|=
name|data
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|crtc
decl_stmt|;
comment|/* If drm_vblank_init() hasn't been called yet, just no-op */
if|if
condition|(
operator|!
name|dev
operator|->
name|num_crtcs
condition|)
goto|goto
name|out
goto|;
name|crtc
operator|=
name|modeset
operator|->
name|crtc
expr_stmt|;
if|if
condition|(
name|crtc
operator|>=
name|dev
operator|->
name|num_crtcs
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|modeset
operator|->
name|cmd
condition|)
block|{
case|case
name|_DRM_PRE_MODESET
case|:
name|drm_vblank_pre_modeset
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
break|break;
case|case
name|_DRM_POST_MODESET
case|:
name|drm_vblank_post_modeset
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drm_vblank_event_destroy
parameter_list|(
name|struct
name|drm_pending_event
modifier|*
name|e
parameter_list|)
block|{
name|free
argument_list|(
name|e
argument_list|,
name|DRM_MEM_VBLANK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_queue_vblank_event
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|pipe
parameter_list|,
name|union
name|drm_wait_vblank
modifier|*
name|vblwait
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_pending_vblank_event
modifier|*
name|e
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|unsigned
name|int
name|seq
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|e
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|e
argument_list|,
name|DRM_MEM_VBLANK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|e
operator|->
name|pipe
operator|=
name|pipe
expr_stmt|;
name|e
operator|->
name|base
operator|.
name|pid
operator|=
name|curproc
operator|->
name|p_pid
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|base
operator|.
name|type
operator|=
name|DRM_EVENT_VBLANK
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|base
operator|.
name|length
operator|=
sizeof|sizeof
name|e
operator|->
name|event
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|user_data
operator|=
name|vblwait
operator|->
name|request
operator|.
name|signal
expr_stmt|;
name|e
operator|->
name|base
operator|.
name|event
operator|=
operator|&
name|e
operator|->
name|event
operator|.
name|base
expr_stmt|;
name|e
operator|->
name|base
operator|.
name|file_priv
operator|=
name|file_priv
expr_stmt|;
name|e
operator|->
name|base
operator|.
name|destroy
operator|=
name|drm_vblank_event_destroy
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_priv
operator|->
name|event_space
operator|<
sizeof|sizeof
name|e
operator|->
name|event
condition|)
block|{
name|ret
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
name|file_priv
operator|->
name|event_space
operator|-=
sizeof|sizeof
name|e
operator|->
name|event
expr_stmt|;
name|seq
operator|=
name|drm_vblank_count_and_time
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vblwait
operator|->
name|request
operator|.
name|type
operator|&
name|_DRM_VBLANK_NEXTONMISS
operator|)
operator|&&
operator|(
name|seq
operator|-
name|vblwait
operator|->
name|request
operator|.
name|sequence
operator|)
operator|<=
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
block|{
name|vblwait
operator|->
name|request
operator|.
name|sequence
operator|=
name|seq
operator|+
literal|1
expr_stmt|;
name|vblwait
operator|->
name|reply
operator|.
name|sequence
operator|=
name|vblwait
operator|->
name|request
operator|.
name|sequence
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"event on vblank count %d, current %d, crtc %d\n"
argument_list|,
name|vblwait
operator|->
name|request
operator|.
name|sequence
argument_list|,
name|seq
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_DRM
argument_list|,
literal|"vblank_event_queued %d %d rt %x %d"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|,
name|pipe
argument_list|,
name|vblwait
operator|->
name|request
operator|.
name|type
argument_list|,
name|vblwait
operator|->
name|request
operator|.
name|sequence
argument_list|)
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|sequence
operator|=
name|vblwait
operator|->
name|request
operator|.
name|sequence
expr_stmt|;
if|if
condition|(
operator|(
name|seq
operator|-
name|vblwait
operator|->
name|request
operator|.
name|sequence
operator|)
operator|<=
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
block|{
name|e
operator|->
name|event
operator|.
name|sequence
operator|=
name|seq
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|tv_usec
operator|=
name|now
operator|.
name|tv_usec
expr_stmt|;
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|e
operator|->
name|base
operator|.
name|link
argument_list|,
operator|&
name|e
operator|->
name|base
operator|.
name|file_priv
operator|->
name|event_list
argument_list|)
expr_stmt|;
name|drm_event_wakeup
argument_list|(
operator|&
name|e
operator|->
name|base
argument_list|)
expr_stmt|;
name|vblwait
operator|->
name|reply
operator|.
name|sequence
operator|=
name|seq
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"vblank_event_wakeup p1 %d %d %d"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|,
name|pipe
argument_list|,
name|vblwait
operator|->
name|request
operator|.
name|sequence
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* drm_handle_vblank_events will call drm_vblank_put */
name|list_add_tail
argument_list|(
operator|&
name|e
operator|->
name|base
operator|.
name|link
argument_list|,
operator|&
name|dev
operator|->
name|vblank_event_list
argument_list|)
expr_stmt|;
name|vblwait
operator|->
name|reply
operator|.
name|sequence
operator|=
name|vblwait
operator|->
name|request
operator|.
name|sequence
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_unlock
label|:
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|,
name|DRM_MEM_VBLANK
argument_list|)
expr_stmt|;
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Wait for VBLANK.  *  * \param inode device inode.  * \param file_priv DRM file private.  * \param cmd command.  * \param data user argument, pointing to a drm_wait_vblank structure.  * \return zero on success or a negative number on failure.  *  * This function enables the vblank interrupt on the pipe requested, then  * sleeps waiting for the requested sequence number to occur, and drops  * the vblank interrupt refcount afterwards. (vblank irq disable follows that  * after a timeout with no further vblank waits scheduled).  */
end_comment

begin_function
name|int
name|drm_wait_vblank
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|union
name|drm_wait_vblank
modifier|*
name|vblwait
init|=
name|data
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|,
name|seq
decl_stmt|,
name|crtc
decl_stmt|,
name|high_crtc
decl_stmt|;
if|if
condition|(
comment|/*(!drm_dev_to_irq(dev)) || */
operator|(
operator|!
name|dev
operator|->
name|irq_enabled
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|vblwait
operator|->
name|request
operator|.
name|type
operator|&
name|_DRM_VBLANK_SIGNAL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|vblwait
operator|->
name|request
operator|.
name|type
operator|&
operator|~
operator|(
name|_DRM_VBLANK_TYPES_MASK
operator||
name|_DRM_VBLANK_FLAGS_MASK
operator||
name|_DRM_VBLANK_HIGH_CRTC_MASK
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unsupported type value 0x%x, supported mask 0x%x\n"
argument_list|,
name|vblwait
operator|->
name|request
operator|.
name|type
argument_list|,
operator|(
name|_DRM_VBLANK_TYPES_MASK
operator||
name|_DRM_VBLANK_FLAGS_MASK
operator||
name|_DRM_VBLANK_HIGH_CRTC_MASK
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|flags
operator|=
name|vblwait
operator|->
name|request
operator|.
name|type
operator|&
name|_DRM_VBLANK_FLAGS_MASK
expr_stmt|;
name|high_crtc
operator|=
operator|(
name|vblwait
operator|->
name|request
operator|.
name|type
operator|&
name|_DRM_VBLANK_HIGH_CRTC_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|high_crtc
condition|)
name|crtc
operator|=
name|high_crtc
operator|>>
name|_DRM_VBLANK_HIGH_CRTC_SHIFT
expr_stmt|;
else|else
name|crtc
operator|=
name|flags
operator|&
name|_DRM_VBLANK_SECONDARY
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|crtc
operator|>=
name|dev
operator|->
name|num_crtcs
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ret
operator|=
name|drm_vblank_get
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"failed to acquire vblank counter, %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|seq
operator|=
name|drm_vblank_count
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vblwait
operator|->
name|request
operator|.
name|type
operator|&
name|_DRM_VBLANK_TYPES_MASK
condition|)
block|{
case|case
name|_DRM_VBLANK_RELATIVE
case|:
name|vblwait
operator|->
name|request
operator|.
name|sequence
operator|+=
name|seq
expr_stmt|;
name|vblwait
operator|->
name|request
operator|.
name|type
operator|&=
operator|~
name|_DRM_VBLANK_RELATIVE
expr_stmt|;
case|case
name|_DRM_VBLANK_ABSOLUTE
case|:
break|break;
default|default:
name|ret
operator|=
operator|(
name|EINVAL
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|flags
operator|&
name|_DRM_VBLANK_EVENT
condition|)
block|{
comment|/* must hold on to the vblank ref until the event fires 		 * drm_vblank_put will be called asynchronously 		 */
return|return
name|drm_queue_vblank_event
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
name|vblwait
argument_list|,
name|file_priv
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|_DRM_VBLANK_NEXTONMISS
operator|)
operator|&&
operator|(
name|seq
operator|-
name|vblwait
operator|->
name|request
operator|.
name|sequence
operator|)
operator|<=
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
block|{
name|vblwait
operator|->
name|request
operator|.
name|sequence
operator|=
name|seq
operator|+
literal|1
expr_stmt|;
block|}
name|dev
operator|->
name|last_vblank_wait
index|[
name|crtc
index|]
operator|=
name|vblwait
operator|->
name|request
operator|.
name|sequence
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|vblank_time_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|drm_vblank_count
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
operator|-
name|vblwait
operator|->
name|request
operator|.
name|sequence
operator|)
operator|>
operator|(
literal|1
operator|<<
literal|23
operator|)
operator|)
operator|&&
name|dev
operator|->
name|irq_enabled
condition|)
block|{
comment|/* 		 * The wakeups from the drm_irq_uninstall() and 		 * drm_vblank_off() may be lost there since vbl_lock 		 * is not held.  Then, the timeout will wake us; the 3 		 * seconds delay should not be a problem for 		 * application when crtc is disabled or irq 		 * uninstalled anyway. 		 */
name|ret
operator|=
name|msleep
argument_list|(
operator|&
name|dev
operator|->
name|_vblank_count
index|[
name|crtc
index|]
argument_list|,
operator|&
name|dev
operator|->
name|vblank_time_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"drmvbl"
argument_list|,
literal|3
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|vblank_time_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|EINTR
condition|)
block|{
name|struct
name|timeval
name|now
decl_stmt|;
name|long
name|reply_seq
decl_stmt|;
name|reply_seq
operator|=
name|drm_vblank_count_and_time
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_DRM
argument_list|,
literal|"wait_vblank %d %d rt %x success %d %d"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|,
name|crtc
argument_list|,
name|vblwait
operator|->
name|request
operator|.
name|type
argument_list|,
name|vblwait
operator|->
name|request
operator|.
name|sequence
argument_list|,
name|reply_seq
argument_list|)
expr_stmt|;
name|vblwait
operator|->
name|reply
operator|.
name|sequence
operator|=
name|reply_seq
expr_stmt|;
name|vblwait
operator|->
name|reply
operator|.
name|tval_sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|vblwait
operator|->
name|reply
operator|.
name|tval_usec
operator|=
name|now
operator|.
name|tv_usec
expr_stmt|;
block|}
else|else
block|{
name|CTR5
argument_list|(
name|KTR_DRM
argument_list|,
literal|"wait_vblank %d %d rt %x error %d %d"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|,
name|crtc
argument_list|,
name|vblwait
operator|->
name|request
operator|.
name|type
argument_list|,
name|ret
argument_list|,
name|vblwait
operator|->
name|request
operator|.
name|sequence
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|drm_handle_vblank_events
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|crtc
parameter_list|)
block|{
name|struct
name|drm_pending_vblank_event
modifier|*
name|e
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|unsigned
name|int
name|seq
decl_stmt|;
name|seq
operator|=
name|drm_vblank_count_and_time
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"drm_handle_vblank_events %d %d"
argument_list|,
name|seq
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|e
argument_list|,
argument|t
argument_list|,
argument|&dev->vblank_event_list
argument_list|,
argument|base.link
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|pipe
operator|!=
name|crtc
condition|)
continue|continue;
if|if
condition|(
operator|(
name|seq
operator|-
name|e
operator|->
name|event
operator|.
name|sequence
operator|)
operator|>
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
continue|continue;
name|e
operator|->
name|event
operator|.
name|sequence
operator|=
name|seq
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|tv_usec
operator|=
name|now
operator|.
name|tv_usec
expr_stmt|;
name|drm_vblank_put
argument_list|(
name|dev
argument_list|,
name|e
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|e
operator|->
name|base
operator|.
name|link
argument_list|,
operator|&
name|e
operator|->
name|base
operator|.
name|file_priv
operator|->
name|event_list
argument_list|)
expr_stmt|;
name|drm_event_wakeup
argument_list|(
operator|&
name|e
operator|->
name|base
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"vblank_event_wakeup p2 %d %d %d"
argument_list|,
name|e
operator|->
name|base
operator|.
name|pid
argument_list|,
name|e
operator|->
name|pipe
argument_list|,
name|e
operator|->
name|event
operator|.
name|sequence
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_handle_vblank - handle a vblank event  * @dev: DRM device  * @crtc: where this event occurred  *  * Drivers should call this routine in their vblank interrupt handlers to  * update the vblank counter and send any signals that may be pending.  */
end_comment

begin_function
name|bool
name|drm_handle_vblank
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|crtc
parameter_list|)
block|{
name|u32
name|vblcount
decl_stmt|;
name|int64_t
name|diff_ns
decl_stmt|;
name|struct
name|timeval
name|tvblank
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|num_crtcs
condition|)
return|return
name|false
return|;
comment|/* Need timestamp lock to prevent concurrent execution with 	 * vblank enable/disable, as this would cause inconsistent 	 * or corrupted timestamps and vblank counts. 	 */
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|vblank_time_lock
argument_list|)
expr_stmt|;
comment|/* Vblank irq handling disabled. Nothing to do. */
if|if
condition|(
operator|!
name|dev
operator|->
name|vblank_enabled
index|[
name|crtc
index|]
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|vblank_time_lock
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Fetch corresponding timestamp for this vblank interval from 	 * driver and store it in proper slot of timestamp ringbuffer. 	 */
comment|/* Get current timestamp and count. */
name|vblcount
operator|=
name|atomic_read
argument_list|(
operator|&
name|dev
operator|->
name|_vblank_count
index|[
name|crtc
index|]
argument_list|)
expr_stmt|;
name|drm_get_last_vbltimestamp
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
operator|&
name|tvblank
argument_list|,
name|DRM_CALLED_FROM_VBLIRQ
argument_list|)
expr_stmt|;
comment|/* Compute time difference to timestamp of last vblank */
name|diff_ns
operator|=
name|timeval_to_ns
argument_list|(
operator|&
name|tvblank
argument_list|)
operator|-
name|timeval_to_ns
argument_list|(
operator|&
name|vblanktimestamp
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
name|vblcount
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update vblank timestamp and count if at least 	 * DRM_REDUNDANT_VBLIRQ_THRESH_NS nanoseconds 	 * difference between last stored timestamp and current 	 * timestamp. A smaller difference means basically 	 * identical timestamps. Happens if this vblank has 	 * been already processed and this is a redundant call, 	 * e.g., due to spurious vblank interrupts. We need to 	 * ignore those for accounting. 	 */
if|if
condition|(
name|abs64
argument_list|(
name|diff_ns
argument_list|)
operator|>
name|DRM_REDUNDANT_VBLIRQ_THRESH_NS
condition|)
block|{
comment|/* Store new timestamp in ringbuffer. */
name|vblanktimestamp
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|,
name|vblcount
operator|+
literal|1
argument_list|)
operator|=
name|tvblank
expr_stmt|;
comment|/* Increment cooked vblank count. This also atomically commits 		 * the timestamp computed above. 		 */
name|atomic_inc
argument_list|(
operator|&
name|dev
operator|->
name|_vblank_count
index|[
name|crtc
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG
argument_list|(
literal|"crtc %d: Redundant vblirq ignored. diff_ns = %d\n"
argument_list|,
name|crtc
argument_list|,
operator|(
name|int
operator|)
name|diff_ns
argument_list|)
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|dev
operator|->
name|_vblank_count
index|[
name|crtc
index|]
argument_list|)
expr_stmt|;
name|drm_handle_vblank_events
argument_list|(
name|dev
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|vblank_time_lock
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

end_unit

