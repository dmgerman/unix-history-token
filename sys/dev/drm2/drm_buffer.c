begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  *  * Copyright 2010 Pauli Nieminen.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the  * "Software"), to deal in the Software without restriction, including  * without limitation the rights to use, copy, modify, merge, publish,  * distribute, sub license, and/or sell copies of the Software, and to  * permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE  * USE OR OTHER DEALINGS IN THE SOFTWARE.  *  *  **************************************************************************/
end_comment

begin_comment
comment|/*  * Multipart buffer for coping data which is larger than the page size.  *  * Authors:  * Pauli Nieminen<suokkos-at-gmail-dot-com>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drm_buffer.h>
end_include

begin_comment
comment|/**  * Allocate the drm buffer object.  *  *   buf: Pointer to a pointer where the object is stored.  *   size: The number of bytes to allocate.  */
end_comment

begin_function
name|int
name|drm_buffer_alloc
parameter_list|(
name|struct
name|drm_buffer
modifier|*
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|nr_pages
init|=
name|size
operator|/
name|PAGE_SIZE
operator|+
literal|1
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* Allocating pointer table to end of structure makes drm_buffer 	 * variable sized */
operator|*
name|buf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|drm_buffer
argument_list|)
operator|+
name|nr_pages
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed to allocate drm buffer object to hold"
literal|" %d bytes in %d pages.\n"
argument_list|,
name|size
argument_list|,
name|nr_pages
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
operator|(
operator|*
name|buf
operator|)
operator|->
name|size
operator|=
name|size
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nr_pages
condition|;
operator|++
name|idx
control|)
block|{
operator|(
operator|*
name|buf
operator|)
operator|->
name|data
index|[
name|idx
index|]
operator|=
name|malloc
argument_list|(
name|min
argument_list|(
name|PAGE_SIZE
argument_list|,
name|size
operator|-
name|idx
operator|*
name|PAGE_SIZE
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|buf
operator|)
operator|->
name|data
index|[
name|idx
index|]
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed to allocate %dth page for drm"
literal|" buffer with %d bytes and %d pages.\n"
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|size
argument_list|,
name|nr_pages
argument_list|)
expr_stmt|;
goto|goto
name|error_out
goto|;
block|}
block|}
return|return
literal|0
return|;
name|error_out
label|:
comment|/* Only last element can be null pointer so check for it first. */
if|if
condition|(
operator|(
operator|*
name|buf
operator|)
operator|->
name|data
index|[
name|idx
index|]
condition|)
name|free
argument_list|(
operator|(
operator|*
name|buf
operator|)
operator|->
name|data
index|[
name|idx
index|]
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
for|for
control|(
operator|--
name|idx
init|;
name|idx
operator|>=
literal|0
condition|;
operator|--
name|idx
control|)
name|free
argument_list|(
operator|(
operator|*
name|buf
operator|)
operator|->
name|data
index|[
name|idx
index|]
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|buf
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_comment
comment|/**  * Copy the user data to the begin of the buffer and reset the processing  * iterator.  *  *   user_data: A pointer the data that is copied to the buffer.  *   size: The Number of bytes to copy.  */
end_comment

begin_function
name|int
name|drm_buffer_copy_from_user
parameter_list|(
name|struct
name|drm_buffer
modifier|*
name|buf
parameter_list|,
name|void
name|__user
modifier|*
name|user_data
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|nr_pages
init|=
name|size
operator|/
name|PAGE_SIZE
operator|+
literal|1
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|buf
operator|->
name|size
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Requesting to copy %d bytes to a drm buffer with"
literal|" %d bytes space\n"
argument_list|,
name|size
argument_list|,
name|buf
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nr_pages
condition|;
operator|++
name|idx
control|)
block|{
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
name|buf
operator|->
name|data
index|[
name|idx
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|user_data
operator|+
name|idx
operator|*
name|PAGE_SIZE
argument_list|,
name|min
argument_list|(
name|PAGE_SIZE
argument_list|,
name|size
operator|-
name|idx
operator|*
name|PAGE_SIZE
argument_list|)
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed to copy user data (%p) to drm buffer"
literal|" (%p) %dth page.\n"
argument_list|,
name|user_data
argument_list|,
name|buf
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
block|}
name|buf
operator|->
name|iterator
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Free the drm buffer object  */
end_comment

begin_function
name|void
name|drm_buffer_free
parameter_list|(
name|struct
name|drm_buffer
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|int
name|nr_pages
init|=
name|buf
operator|->
name|size
operator|/
name|PAGE_SIZE
operator|+
literal|1
decl_stmt|;
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nr_pages
condition|;
operator|++
name|idx
control|)
name|free
argument_list|(
name|buf
operator|->
name|data
index|[
name|idx
index|]
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Read an object from buffer that may be split to multiple parts. If object  * is not split function just returns the pointer to object in buffer. But in  * case of split object data is copied to given stack object that is suplied  * by caller.  *  * The processing location of the buffer is also advanced to the next byte  * after the object.  *  *   objsize: The size of the objet in bytes.  *   stack_obj: A pointer to a memory location where object can be copied.  */
end_comment

begin_function
name|void
modifier|*
name|drm_buffer_read_object
parameter_list|(
name|struct
name|drm_buffer
modifier|*
name|buf
parameter_list|,
name|int
name|objsize
parameter_list|,
name|void
modifier|*
name|stack_obj
parameter_list|)
block|{
name|int
name|idx
init|=
name|drm_buffer_index
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|int
name|page
init|=
name|drm_buffer_page
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|void
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|idx
operator|+
name|objsize
operator|<=
name|PAGE_SIZE
condition|)
block|{
name|obj
operator|=
operator|&
name|buf
operator|->
name|data
index|[
name|page
index|]
index|[
name|idx
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* The object is split which forces copy to temporary object.*/
name|int
name|beginsz
init|=
name|PAGE_SIZE
operator|-
name|idx
decl_stmt|;
name|memcpy
argument_list|(
name|stack_obj
argument_list|,
operator|&
name|buf
operator|->
name|data
index|[
name|page
index|]
index|[
name|idx
index|]
argument_list|,
name|beginsz
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|stack_obj
operator|+
name|beginsz
argument_list|,
operator|&
name|buf
operator|->
name|data
index|[
name|page
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|objsize
operator|-
name|beginsz
argument_list|)
expr_stmt|;
name|obj
operator|=
name|stack_obj
expr_stmt|;
block|}
name|drm_buffer_advance
argument_list|(
name|buf
argument_list|,
name|objsize
argument_list|)
expr_stmt|;
return|return
name|obj
return|;
block|}
end_function

end_unit

