begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file drm_drv.c  * Generic driver template  *  * \author Rickard E. (Rik) Faith<faith@valinux.com>  * \author Gareth Hughes<gareth@valinux.com>  *  * To use this template, you must at least define the following (samples  * given for the MGA driver):  *  * \code  * #define DRIVER_AUTHOR	"VA Linux Systems, Inc."  *  * #define DRIVER_NAME		"mga"  * #define DRIVER_DESC		"Matrox G200/G400"  * #define DRIVER_DATE		"20001127"  *  * #define drm_x		mga_##x  * \endcode  */
end_comment

begin_comment
comment|/*  * Created: Thu Nov 23 03:10:50 2000 by gareth@valinux.com  *  * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.  * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_global.h>
end_include

begin_decl_stmt
name|struct
name|sx
name|drm_global_mutex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** Ioctl table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|drm_ioctl_desc
name|drm_ioctls
index|[]
init|=
block|{
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_VERSION
argument_list|,
name|drm_version
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_GET_UNIQUE
argument_list|,
name|drm_getunique
argument_list|,
literal|0
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_GET_MAGIC
argument_list|,
name|drm_getmagic
argument_list|,
literal|0
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_IRQ_BUSID
argument_list|,
name|drm_irq_by_busid
argument_list|,
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_GET_MAP
argument_list|,
name|drm_getmap
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_GET_CLIENT
argument_list|,
name|drm_getclient
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_GET_STATS
argument_list|,
name|drm_getstats
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_GET_CAP
argument_list|,
name|drm_getcap
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_SET_VERSION
argument_list|,
name|drm_setversion
argument_list|,
name|DRM_MASTER
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_SET_UNIQUE
argument_list|,
name|drm_setunique
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_BLOCK
argument_list|,
name|drm_noop
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_UNBLOCK
argument_list|,
name|drm_noop
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_AUTH_MAGIC
argument_list|,
name|drm_authmagic
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_ADD_MAP
argument_list|,
name|drm_addmap_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_RM_MAP
argument_list|,
name|drm_rmmap_ioctl
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_SET_SAREA_CTX
argument_list|,
name|drm_setsareactx
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_GET_SAREA_CTX
argument_list|,
name|drm_getsareactx
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_SET_MASTER
argument_list|,
name|drm_setmaster_ioctl
argument_list|,
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_DROP_MASTER
argument_list|,
name|drm_dropmaster_ioctl
argument_list|,
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_ADD_CTX
argument_list|,
name|drm_addctx
argument_list|,
name|DRM_AUTH
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_RM_CTX
argument_list|,
name|drm_rmctx
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MOD_CTX
argument_list|,
name|drm_modctx
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_GET_CTX
argument_list|,
name|drm_getctx
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_SWITCH_CTX
argument_list|,
name|drm_switchctx
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_NEW_CTX
argument_list|,
name|drm_newctx
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_RES_CTX
argument_list|,
name|drm_resctx
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_ADD_DRAW
argument_list|,
name|drm_noop
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_RM_DRAW
argument_list|,
name|drm_noop
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_LOCK
argument_list|,
name|drm_lock
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_UNLOCK
argument_list|,
name|drm_unlock
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_FINISH
argument_list|,
name|drm_noop
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_ADD_BUFS
argument_list|,
name|drm_addbufs
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MARK_BUFS
argument_list|,
name|drm_markbufs
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_INFO_BUFS
argument_list|,
name|drm_infobufs
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MAP_BUFS
argument_list|,
name|drm_mapbufs
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_FREE_BUFS
argument_list|,
name|drm_freebufs
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
comment|/* The DRM_IOCTL_DMA ioctl should be defined by the driver. */
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_DMA
argument_list|,
name|NULL
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_CONTROL
argument_list|,
name|drm_control
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
if|#
directive|if
name|__OS_HAS_AGP
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_AGP_ACQUIRE
argument_list|,
name|drm_agp_acquire_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_AGP_RELEASE
argument_list|,
name|drm_agp_release_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_AGP_ENABLE
argument_list|,
name|drm_agp_enable_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_AGP_INFO
argument_list|,
name|drm_agp_info_ioctl
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_AGP_ALLOC
argument_list|,
name|drm_agp_alloc_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_AGP_FREE
argument_list|,
name|drm_agp_free_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_AGP_BIND
argument_list|,
name|drm_agp_bind_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_AGP_UNBIND
argument_list|,
name|drm_agp_unbind_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
endif|#
directive|endif
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_SG_ALLOC
argument_list|,
name|drm_sg_alloc_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_SG_FREE
argument_list|,
name|drm_sg_free
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_WAIT_VBLANK
argument_list|,
name|drm_wait_vblank
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODESET_CTL
argument_list|,
name|drm_modeset_ctl
argument_list|,
literal|0
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_UPDATE_DRAW
argument_list|,
name|drm_noop
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_GEM_CLOSE
argument_list|,
name|drm_gem_close_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_GEM_FLINK
argument_list|,
name|drm_gem_flink_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_GEM_OPEN
argument_list|,
name|drm_gem_open_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_GETRESOURCES
argument_list|,
name|drm_mode_getresources
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
ifdef|#
directive|ifdef
name|FREEBSD_NOTYET
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_PRIME_HANDLE_TO_FD
argument_list|,
name|drm_prime_handle_to_fd_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_PRIME_FD_TO_HANDLE
argument_list|,
name|drm_prime_fd_to_handle_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
endif|#
directive|endif
comment|/* FREEBSD_NOTYET */
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_GETPLANERESOURCES
argument_list|,
name|drm_mode_getplane_res
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_GETCRTC
argument_list|,
name|drm_mode_getcrtc
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_SETCRTC
argument_list|,
name|drm_mode_setcrtc
argument_list|,
name|DRM_MASTER
operator||
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_GETPLANE
argument_list|,
name|drm_mode_getplane
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_SETPLANE
argument_list|,
name|drm_mode_setplane
argument_list|,
name|DRM_MASTER
operator||
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_CURSOR
argument_list|,
name|drm_mode_cursor_ioctl
argument_list|,
name|DRM_MASTER
operator||
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_GETGAMMA
argument_list|,
name|drm_mode_gamma_get_ioctl
argument_list|,
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_SETGAMMA
argument_list|,
name|drm_mode_gamma_set_ioctl
argument_list|,
name|DRM_MASTER
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_GETENCODER
argument_list|,
name|drm_mode_getencoder
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_GETCONNECTOR
argument_list|,
name|drm_mode_getconnector
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_ATTACHMODE
argument_list|,
name|drm_mode_attachmode_ioctl
argument_list|,
name|DRM_MASTER
operator||
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_DETACHMODE
argument_list|,
name|drm_mode_detachmode_ioctl
argument_list|,
name|DRM_MASTER
operator||
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_GETPROPERTY
argument_list|,
name|drm_mode_getproperty_ioctl
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_SETPROPERTY
argument_list|,
name|drm_mode_connector_property_set_ioctl
argument_list|,
name|DRM_MASTER
operator||
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_GETPROPBLOB
argument_list|,
name|drm_mode_getblob_ioctl
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_GETFB
argument_list|,
name|drm_mode_getfb
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_ADDFB
argument_list|,
name|drm_mode_addfb
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_ADDFB2
argument_list|,
name|drm_mode_addfb2
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_RMFB
argument_list|,
name|drm_mode_rmfb
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_PAGE_FLIP
argument_list|,
name|drm_mode_page_flip_ioctl
argument_list|,
name|DRM_MASTER
operator||
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_DIRTYFB
argument_list|,
name|drm_mode_dirtyfb_ioctl
argument_list|,
name|DRM_MASTER
operator||
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_CREATE_DUMB
argument_list|,
name|drm_mode_create_dumb_ioctl
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_MAP_DUMB
argument_list|,
name|drm_mode_mmap_dumb_ioctl
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_DESTROY_DUMB
argument_list|,
name|drm_mode_destroy_dumb_ioctl
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_OBJ_GETPROPERTIES
argument_list|,
name|drm_mode_obj_get_properties_ioctl
argument_list|,
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_IOCTL_MODE_OBJ_SETPROPERTY
argument_list|,
name|drm_mode_obj_set_property_ioctl
argument_list|,
name|DRM_MASTER
operator||
name|DRM_CONTROL_ALLOW
operator||
name|DRM_UNLOCKED
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|drm_ioctl_desc
name|drm_compat_ioctls
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DRM_CORE_IOCTL_COUNT
value|ARRAY_SIZE( drm_ioctls )
end_define

begin_comment
comment|/**  * Take down the DRM device.  *  * \param dev DRM device structure.  *  * Frees every resource in \p dev.  *  * \sa drm_device  */
end_comment

begin_function
name|int
name|drm_lastclose
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__linux__
name|struct
name|drm_vma_entry
modifier|*
name|vma
decl_stmt|,
modifier|*
name|vma_temp
decl_stmt|;
endif|#
directive|endif
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|driver
operator|->
name|lastclose
condition|)
name|dev
operator|->
name|driver
operator|->
name|lastclose
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"driver lastclose completed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|irq_enabled
operator|&&
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
name|drm_irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Clear AGP information */
if|if
condition|(
name|drm_core_has_AGP
argument_list|(
name|dev
argument_list|)
operator|&&
name|dev
operator|->
name|agp
operator|&&
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
block|{
name|struct
name|drm_agp_mem
modifier|*
name|entry
decl_stmt|,
modifier|*
name|tempe
decl_stmt|;
comment|/* Remove AGP resources, but leave dev->agp 		   intact until drv_cleanup is called. */
name|list_for_each_entry_safe
argument_list|(
argument|entry
argument_list|,
argument|tempe
argument_list|,
argument|&dev->agp->memory
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|bound
condition|)
name|drm_unbind_agp
argument_list|(
name|entry
operator|->
name|memory
argument_list|)
expr_stmt|;
name|drm_free_agp
argument_list|(
name|entry
operator|->
name|memory
argument_list|,
name|entry
operator|->
name|pages
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|,
name|DRM_MEM_AGPLISTS
argument_list|)
expr_stmt|;
block|}
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|agp
operator|->
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|agp
operator|->
name|acquired
condition|)
name|drm_agp_release
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|agp
operator|->
name|acquired
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|agp
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_SG
argument_list|)
operator|&&
name|dev
operator|->
name|sg
operator|&&
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
block|{
name|drm_sg_cleanup
argument_list|(
name|dev
operator|->
name|sg
argument_list|)
expr_stmt|;
name|dev
operator|->
name|sg
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__linux__
comment|/* Clear vma list (only built for debugging) */
name|list_for_each_entry_safe
argument_list|(
argument|vma
argument_list|,
argument|vma_temp
argument_list|,
argument|&dev->vmalist
argument_list|,
argument|head
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|vma
operator|->
name|head
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|vma
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_HAVE_DMA
argument_list|)
operator|&&
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
name|drm_dma_takedown
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"lastclose completed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_comment
comment|/** File operations structure */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|file_operations
name|drm_stub_fops
init|=
block|{
operator|.
name|owner
operator|=
name|THIS_MODULE
block|,
operator|.
name|open
operator|=
name|drm_stub_open
block|,
operator|.
name|llseek
operator|=
name|noop_llseek
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|__init
name|drm_core_init
parameter_list|(
name|void
parameter_list|)
block|{
name|sx_init
argument_list|(
operator|&
name|drm_global_mutex
argument_list|,
literal|"drm_global_mutex"
argument_list|)
expr_stmt|;
name|drm_global_init
argument_list|()
expr_stmt|;
if|#
directive|if
name|DRM_LINUX
name|linux_ioctl_register_handler
argument_list|(
operator|&
name|drm_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DRM_LINUX */
name|DRM_INFO
argument_list|(
literal|"Initialized %s %d.%d.%d %s\n"
argument_list|,
name|CORE_NAME
argument_list|,
name|CORE_MAJOR
argument_list|,
name|CORE_MINOR
argument_list|,
name|CORE_PATCHLEVEL
argument_list|,
name|CORE_DATE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__exit
name|drm_core_exit
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|DRM_LINUX
name|linux_ioctl_unregister_handler
argument_list|(
operator|&
name|drm_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DRM_LINUX */
name|drm_global_release
argument_list|()
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|drm_global_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|drm_register
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|drm_core_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|drm_unregister
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|drm_core_exit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * Copy and IOCTL return string to user space  */
end_comment

begin_function
specifier|static
name|int
name|drm_copy_field
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|buf_len
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* don't overflow userbuf */
name|len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
operator|*
name|buf_len
condition|)
name|len
operator|=
operator|*
name|buf_len
expr_stmt|;
comment|/* let userspace know exact length of driver value (which could be 	 * larger than the userspace-supplied buffer) */
operator|*
name|buf_len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* finally, try filling in the userbuf */
if|if
condition|(
name|len
operator|&&
name|buf
condition|)
if|if
condition|(
name|copy_to_user
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Get version information  *  * \param inode device inode.  * \param filp file pointer.  * \param cmd command.  * \param arg user argument, pointing to a drm_version structure.  * \return zero on success or negative number on failure.  *  * Fills in the version information in \p arg.  */
end_comment

begin_function
name|int
name|drm_version
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_version
modifier|*
name|version
init|=
name|data
decl_stmt|;
name|int
name|err
decl_stmt|;
name|version
operator|->
name|version_major
operator|=
name|dev
operator|->
name|driver
operator|->
name|major
expr_stmt|;
name|version
operator|->
name|version_minor
operator|=
name|dev
operator|->
name|driver
operator|->
name|minor
expr_stmt|;
name|version
operator|->
name|version_patchlevel
operator|=
name|dev
operator|->
name|driver
operator|->
name|patchlevel
expr_stmt|;
name|err
operator|=
name|drm_copy_field
argument_list|(
name|version
operator|->
name|name
argument_list|,
operator|&
name|version
operator|->
name|name_len
argument_list|,
name|dev
operator|->
name|driver
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|drm_copy_field
argument_list|(
name|version
operator|->
name|date
argument_list|,
operator|&
name|version
operator|->
name|date_len
argument_list|,
name|dev
operator|->
name|driver
operator|->
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|drm_copy_field
argument_list|(
name|version
operator|->
name|desc
argument_list|,
operator|&
name|version
operator|->
name|desc_len
argument_list|,
name|dev
operator|->
name|driver
operator|->
name|desc
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/**  * Called whenever a process performs an ioctl on /dev/drm.  *  * \param inode device inode.  * \param file_priv DRM file private.  * \param cmd command.  * \param arg user argument.  * \return zero on success or negative number on failure.  *  * Looks up the ioctl function in the ::ioctls table, checking for root  * previleges if so required, and dispatches to the respective function.  */
end_comment

begin_function
name|int
name|drm_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|kdev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flags
parameter_list|,
name|DRM_STRUCTPROC
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|drm_file
modifier|*
name|file_priv
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|drm_ioctl_desc
modifier|*
name|ioctl
decl_stmt|;
name|drm_ioctl_t
modifier|*
name|func
decl_stmt|;
name|unsigned
name|int
name|nr
init|=
name|DRM_IOCTL_NR
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|dev
operator|=
name|drm_get_device_from_kdev
argument_list|(
name|kdev
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|file_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"can't find authenticator\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|retcode
operator|=
operator|-
name|EINVAL
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|dev
operator|->
name|ioctl_count
argument_list|)
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|dev
operator|->
name|counts
index|[
name|_DRM_STAT_IOCTLS
index|]
argument_list|)
expr_stmt|;
operator|++
name|file_priv
operator|->
name|ioctl_count
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"pid=%d, cmd=0x%02lx, nr=0x%02x, dev 0x%lx, auth=%d\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|cmd
argument_list|,
name|nr
argument_list|,
operator|(
name|long
operator|)
name|file_priv
operator|->
name|minor
operator|->
name|device
argument_list|,
name|file_priv
operator|->
name|authenticated
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIONBIO
case|:
case|case
name|FIOASYNC
case|:
return|return
literal|0
return|;
case|case
name|FIOSETOWN
case|:
return|return
name|fsetown
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
operator|&
name|file_priv
operator|->
name|minor
operator|->
name|buf_sigio
argument_list|)
return|;
case|case
name|FIOGETOWN
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|fgetown
argument_list|(
operator|&
name|file_priv
operator|->
name|minor
operator|->
name|buf_sigio
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|IOCGROUP
argument_list|(
name|cmd
argument_list|)
operator|!=
name|DRM_IOCTL_BASE
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Bad ioctl group 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|IOCGROUP
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
name|nr
operator|>=
name|DRM_CORE_IOCTL_COUNT
operator|)
operator|&&
operator|(
operator|(
name|nr
operator|<
name|DRM_COMMAND_BASE
operator|)
operator|||
operator|(
name|nr
operator|>=
name|DRM_COMMAND_END
operator|)
operator|)
condition|)
goto|goto
name|err_i1
goto|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
name|SV_CURPROC_FLAG
argument_list|(
name|SV_ILP32
argument_list|)
operator|&&
operator|(
name|nr
operator|>=
name|DRM_COMMAND_BASE
operator|)
operator|&&
operator|(
name|nr
operator|<
name|DRM_COMMAND_END
operator|)
operator|&&
operator|(
name|nr
operator|<
name|DRM_COMMAND_BASE
operator|+
operator|*
name|dev
operator|->
name|driver
operator|->
name|num_compat_ioctls
operator|)
operator|&&
operator|(
name|dev
operator|->
name|driver
operator|->
name|compat_ioctls
index|[
name|nr
operator|-
name|DRM_COMMAND_BASE
index|]
operator|.
name|func
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ioctl
operator|=
operator|&
name|dev
operator|->
name|driver
operator|->
name|compat_ioctls
index|[
name|nr
operator|-
name|DRM_COMMAND_BASE
index|]
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|(
name|nr
operator|>=
name|DRM_COMMAND_BASE
operator|)
operator|&&
operator|(
name|nr
operator|<
name|DRM_COMMAND_END
operator|)
operator|&&
operator|(
name|nr
operator|<
name|DRM_COMMAND_BASE
operator|+
name|dev
operator|->
name|driver
operator|->
name|num_ioctls
operator|)
condition|)
block|{
name|ioctl
operator|=
operator|&
name|dev
operator|->
name|driver
operator|->
name|ioctls
index|[
name|nr
operator|-
name|DRM_COMMAND_BASE
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|nr
operator|>=
name|DRM_COMMAND_END
operator|)
operator|||
operator|(
name|nr
operator|<
name|DRM_COMMAND_BASE
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
comment|/* 		 * Called whenever a 32-bit process running under a 64-bit 		 * kernel performs an ioctl on /dev/drm. 		 */
if|if
condition|(
name|SV_CURPROC_FLAG
argument_list|(
name|SV_ILP32
argument_list|)
operator|&&
name|drm_compat_ioctls
index|[
name|nr
index|]
operator|.
name|func
operator|!=
name|NULL
condition|)
comment|/* 			 * Assume that ioctls without an explicit compat 			 * routine will just work.  This may not always be a 			 * good assumption, but it's better than always 			 * failing. 			 */
name|ioctl
operator|=
operator|&
name|drm_compat_ioctls
index|[
name|nr
index|]
expr_stmt|;
else|else
endif|#
directive|endif
name|ioctl
operator|=
operator|&
name|drm_ioctls
index|[
name|nr
index|]
expr_stmt|;
block|}
else|else
goto|goto
name|err_i1
goto|;
comment|/* Do not trust userspace, use our own definition */
name|func
operator|=
name|ioctl
operator|->
name|func
expr_stmt|;
comment|/* is there a local override? */
ifdef|#
directive|ifdef
name|FREEBSD_NOTYET
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
name|SV_CURPROC_FLAG
argument_list|(
name|SV_ILP32
argument_list|)
operator|&&
operator|(
name|nr
operator|==
name|DRM_IOCTL_NR
argument_list|(
name|DRM_IOCTL_DMA
argument_list|)
operator|)
operator|&&
name|dev
operator|->
name|driver
operator|->
name|dma_compat_ioctl
condition|)
name|func
operator|=
name|dev
operator|->
name|driver
operator|->
name|dma_compat_ioctl
expr_stmt|;
elseif|else
endif|#
directive|endif
endif|#
directive|endif
comment|/* FREEBSD_NOTYET */
if|if
condition|(
operator|(
name|nr
operator|==
name|DRM_IOCTL_NR
argument_list|(
name|DRM_IOCTL_DMA
argument_list|)
operator|)
operator|&&
name|dev
operator|->
name|driver
operator|->
name|dma_ioctl
condition|)
name|func
operator|=
name|dev
operator|->
name|driver
operator|->
name|dma_ioctl
expr_stmt|;
if|if
condition|(
operator|!
name|func
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"no function\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|ioctl
operator|->
name|flags
operator|&
name|DRM_ROOT_ONLY
operator|)
operator|&&
operator|!
name|DRM_SUSER
argument_list|(
name|p
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|ioctl
operator|->
name|flags
operator|&
name|DRM_AUTH
operator|)
operator|&&
operator|!
name|file_priv
operator|->
name|authenticated
operator|)
operator|||
operator|(
operator|(
name|ioctl
operator|->
name|flags
operator|&
name|DRM_MASTER
operator|)
operator|&&
operator|!
name|file_priv
operator|->
name|is_master
operator|)
operator|||
operator|(
operator|!
operator|(
name|ioctl
operator|->
name|flags
operator|&
name|DRM_CONTROL_ALLOW
operator|)
operator|&&
operator|(
name|file_priv
operator|->
name|minor
operator|->
name|type
operator|==
name|DRM_MINOR_CONTROL
operator|)
operator|)
condition|)
block|{
name|retcode
operator|=
operator|-
name|EACCES
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioctl
operator|->
name|flags
operator|&
name|DRM_UNLOCKED
condition|)
name|retcode
operator|=
name|func
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
else|else
block|{
name|sx_xlock
argument_list|(
operator|&
name|drm_global_mutex
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|func
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|drm_global_mutex
argument_list|)
expr_stmt|;
block|}
block|}
name|err_i1
label|:
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|ioctl_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
operator|-
name|ERESTARTSYS
condition|)
block|{
comment|/* 		 * FIXME: Find where in i915 ERESTARTSYS should be 		 * converted to EINTR. 		 */
name|DRM_DEBUG
argument_list|(
literal|"ret = %d -> %d\n"
argument_list|,
name|retcode
argument_list|,
operator|-
name|EINTR
argument_list|)
expr_stmt|;
name|retcode
operator|=
operator|-
name|EINTR
expr_stmt|;
block|}
if|if
condition|(
name|retcode
condition|)
name|DRM_DEBUG
argument_list|(
literal|"ret = %d\n"
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
operator|&&
operator|(
name|drm_debug
operator|&
name|DRM_DEBUGBITS_FAILED_IOCTL
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pid %d, cmd 0x%02lx, nr 0x%02x, dev 0x%lx, auth %d, res %d\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|cmd
argument_list|,
name|nr
argument_list|,
operator|(
name|long
operator|)
name|file_priv
operator|->
name|minor
operator|->
name|device
argument_list|,
name|file_priv
operator|->
name|authenticated
argument_list|,
operator|-
name|retcode
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
name|retcode
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_ioctl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|struct
name|drm_local_map
modifier|*
name|drm_getsarea
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_map_list
modifier|*
name|entry
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|entry
argument_list|,
argument|&dev->maplist
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|map
operator|&&
name|entry
operator|->
name|map
operator|->
name|type
operator|==
name|_DRM_SHM
operator|&&
operator|(
name|entry
operator|->
name|map
operator|->
name|flags
operator|&
name|_DRM_CONTAINS_LOCK
operator|)
condition|)
block|{
return|return
name|entry
operator|->
name|map
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_getsarea
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

