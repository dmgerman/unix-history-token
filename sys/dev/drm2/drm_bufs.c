begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file drm_bufs.c  * Generic buffer template  *  * \author Rickard E. (Rik) Faith<faith@valinux.com>  * \author Gareth Hughes<gareth@valinux.com>  */
end_comment

begin_comment
comment|/*  * Created: Thu Nov 23 03:10:50 2000 by gareth@valinux.com  *  * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.  * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_comment
comment|/* Allocation of PCI memory resources (framebuffer, registers, etc.) for  * drm_get_resource_*.  Note that they are not RF_ACTIVE, so there's no virtual  * address for accessing them.  Cleaned up at unload.  */
end_comment

begin_function
specifier|static
name|int
name|drm_alloc_resource
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|resource
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|rid
decl_stmt|;
if|if
condition|(
name|resource
operator|>=
name|DRM_MAX_PCI_RESOURCE
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Resource %d too large\n"
argument_list|,
name|resource
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|dev
operator|->
name|pcir
index|[
name|resource
index|]
operator|!=
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|rid
operator|=
name|PCIR_BAR
argument_list|(
name|resource
argument_list|)
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Couldn't find resource 0x%x\n"
argument_list|,
name|resource
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|dev
operator|->
name|pcir
index|[
name|resource
index|]
operator|==
name|NULL
condition|)
block|{
name|dev
operator|->
name|pcirid
index|[
name|resource
index|]
operator|=
name|rid
expr_stmt|;
name|dev
operator|->
name|pcir
index|[
name|resource
index|]
operator|=
name|res
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|drm_get_resource_start
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|int
name|resource
parameter_list|)
block|{
name|unsigned
name|long
name|start
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|pcir_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|drm_alloc_resource
argument_list|(
name|dev
argument_list|,
name|resource
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|start
operator|=
name|rman_get_start
argument_list|(
name|dev
operator|->
name|pcir
index|[
name|resource
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|pcir_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|start
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|drm_get_resource_len
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|int
name|resource
parameter_list|)
block|{
name|unsigned
name|long
name|len
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|pcir_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|drm_alloc_resource
argument_list|(
name|dev
argument_list|,
name|resource
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|rman_get_size
argument_list|(
name|dev
operator|->
name|pcir
index|[
name|resource
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|pcir_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_map_list
modifier|*
name|drm_find_matching_map
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_local_map
modifier|*
name|map
parameter_list|)
block|{
name|struct
name|drm_map_list
modifier|*
name|entry
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|entry
argument_list|,
argument|&dev->maplist
argument_list|,
argument|head
argument_list|)
block|{
comment|/* 		 * Because the kernel-userspace ABI is fixed at a 32-bit offset 		 * while PCI resources may live above that, we only compare the 		 * lower 32 bits of the map offset for maps of type 		 * _DRM_FRAMEBUFFER or _DRM_REGISTERS. 		 * It is assumed that if a driver have more than one resource 		 * of each type, the lower 32 bits are different. 		 */
if|if
condition|(
operator|!
name|entry
operator|->
name|map
operator|||
name|map
operator|->
name|type
operator|!=
name|entry
operator|->
name|map
operator|->
name|type
operator|||
name|entry
operator|->
name|master
operator|!=
name|dev
operator|->
name|primary
operator|->
name|master
condition|)
continue|continue;
switch|switch
condition|(
name|map
operator|->
name|type
condition|)
block|{
case|case
name|_DRM_SHM
case|:
if|if
condition|(
name|map
operator|->
name|flags
operator|!=
name|_DRM_CONTAINS_LOCK
condition|)
break|break;
return|return
name|entry
return|;
case|case
name|_DRM_REGISTERS
case|:
case|case
name|_DRM_FRAME_BUFFER
case|:
if|if
condition|(
operator|(
name|entry
operator|->
name|map
operator|->
name|offset
operator|&
literal|0xffffffff
operator|)
operator|==
operator|(
name|map
operator|->
name|offset
operator|&
literal|0xffffffff
operator|)
condition|)
return|return
name|entry
return|;
default|default:
comment|/* Make gcc happy */
empty_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|map
operator|->
name|offset
operator|==
name|map
operator|->
name|offset
condition|)
return|return
name|entry
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_map_handle
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_hash_item
modifier|*
name|hash
parameter_list|,
name|unsigned
name|long
name|user_token
parameter_list|,
name|int
name|hashed_handle
parameter_list|,
name|int
name|shm
parameter_list|)
block|{
name|int
name|use_hashed_handle
decl_stmt|,
name|shift
decl_stmt|;
name|unsigned
name|long
name|add
decl_stmt|;
if|#
directive|if
operator|(
name|BITS_PER_LONG
operator|==
literal|64
operator|)
name|use_hashed_handle
operator|=
operator|(
operator|(
name|user_token
operator|&
literal|0xFFFFFFFF00000000UL
operator|)
operator|||
name|hashed_handle
operator|)
expr_stmt|;
elif|#
directive|elif
operator|(
name|BITS_PER_LONG
operator|==
literal|32
operator|)
name|use_hashed_handle
operator|=
name|hashed_handle
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|Unsupported long size. Neither 64 nor 32 bits.
endif|#
directive|endif
if|if
condition|(
operator|!
name|use_hashed_handle
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|hash
operator|->
name|key
operator|=
name|user_token
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|ret
operator|=
name|drm_ht_insert_item
argument_list|(
operator|&
name|dev
operator|->
name|map_hash
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
name|EINVAL
condition|)
return|return
name|ret
return|;
block|}
name|shift
operator|=
literal|0
expr_stmt|;
name|add
operator|=
name|DRM_MAP_HASH_OFFSET
operator|>>
name|PAGE_SHIFT
expr_stmt|;
if|if
condition|(
name|shm
operator|&&
operator|(
name|SHMLBA
operator|>
name|PAGE_SIZE
operator|)
condition|)
block|{
name|int
name|bits
init|=
name|ilog2
argument_list|(
name|SHMLBA
operator|>>
name|PAGE_SHIFT
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* For shared memory, we have to preserve the SHMLBA 		 * bits of the eventual vma->vm_pgoff value during 		 * mmap().  Otherwise we run into cache aliasing problems 		 * on some platforms.  On these platforms, the pgoff of 		 * a mmap() request is used to pick a suitable virtual 		 * address for the mmap() region such that it will not 		 * cause cache aliasing problems. 		 * 		 * Therefore, make sure the SHMLBA relevant bits of the 		 * hash value we use are equal to those in the original 		 * kernel virtual address. 		 */
name|shift
operator|=
name|bits
expr_stmt|;
name|add
operator||=
operator|(
operator|(
name|user_token
operator|>>
name|PAGE_SHIFT
operator|)
operator|&
operator|(
operator|(
literal|1UL
operator|<<
name|bits
operator|)
operator|-
literal|1UL
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|drm_ht_just_insert_please
argument_list|(
operator|&
name|dev
operator|->
name|map_hash
argument_list|,
name|hash
argument_list|,
name|user_token
argument_list|,
literal|32
operator|-
name|PAGE_SHIFT
operator|-
literal|3
argument_list|,
name|shift
argument_list|,
name|add
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Core function to create a range of memory available for mapping by a  * non-root process.  *  * Adjusts the memory offset to its absolute value according to the mapping  * type.  Adds the map to the map list drm_device::maplist. Adds MTRR's where  * applicable and if supported by the kernel.  */
end_comment

begin_function
specifier|static
name|int
name|drm_addmap_core
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|resource_size_t
name|offset
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|enum
name|drm_map_type
name|type
parameter_list|,
name|enum
name|drm_map_flags
name|flags
parameter_list|,
name|struct
name|drm_map_list
modifier|*
modifier|*
name|maplist
parameter_list|)
block|{
name|struct
name|drm_local_map
modifier|*
name|map
decl_stmt|;
name|struct
name|drm_map_list
modifier|*
name|list
decl_stmt|;
name|drm_dma_handle_t
modifier|*
name|dmah
decl_stmt|;
name|unsigned
name|long
name|user_token
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|align
decl_stmt|;
name|map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|DRM_MEM_MAPS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|map
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|map
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|map
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|map
operator|->
name|type
operator|=
name|type
expr_stmt|;
comment|/* Only allow shared memory to be removable since we only keep enough 	 * book keeping information about shared memory to allow for removal 	 * when processes fork. 	 */
if|if
condition|(
operator|(
name|map
operator|->
name|flags
operator|&
name|_DRM_REMOVABLE
operator|)
operator|&&
name|map
operator|->
name|type
operator|!=
name|_DRM_SHM
condition|)
block|{
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"offset = 0x%08llx, size = 0x%08lx, type = %d\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|map
operator|->
name|offset
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|map
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* page-align _DRM_SHM maps. They are allocated here so there is no security 	 * hole created by that and it works around various broken drivers that use 	 * a non-aligned quantity to map the SAREA. --BenH 	 */
if|if
condition|(
name|map
operator|->
name|type
operator|==
name|_DRM_SHM
condition|)
name|map
operator|->
name|size
operator|=
name|PAGE_ALIGN
argument_list|(
name|map
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * FreeBSD port note: FreeBSD's PAGE_MASK is the inverse of 	 * Linux's one. That's why the test below doesn't inverse the 	 * constant. 	 */
if|if
condition|(
operator|(
name|map
operator|->
name|offset
operator|&
operator|(
operator|(
name|resource_size_t
operator|)
name|PAGE_MASK
operator|)
operator|)
operator|||
operator|(
name|map
operator|->
name|size
operator|&
operator|(
name|PAGE_MASK
operator|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|map
operator|->
name|mtrr
operator|=
operator|-
literal|1
expr_stmt|;
name|map
operator|->
name|handle
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|map
operator|->
name|type
condition|)
block|{
case|case
name|_DRM_REGISTERS
case|:
case|case
name|_DRM_FRAME_BUFFER
case|:
ifdef|#
directive|ifdef
name|__linux__
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__sparc__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__ia64__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__powerpc64__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__arm__
argument_list|)
if|if
condition|(
name|map
operator|->
name|offset
operator|+
operator|(
name|map
operator|->
name|size
operator|-
literal|1
operator|)
operator|<
name|map
operator|->
name|offset
operator|||
name|map
operator|->
name|offset
operator|<
name|virt_to_phys
argument_list|(
name|high_memory
argument_list|)
condition|)
block|{
name|kfree
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* Some drivers preinitialize some maps, without the X Server 		 * needing to be aware of it.  Therefore, we just return success 		 * when the server tries to create a duplicate map. 		 */
name|list
operator|=
name|drm_find_matching_map
argument_list|(
name|dev
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|map
operator|->
name|size
operator|!=
name|map
operator|->
name|size
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Matching maps of type %d with "
literal|"mismatched sizes, (%ld vs %ld)\n"
argument_list|,
name|map
operator|->
name|type
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|list
operator|->
name|map
operator|->
name|size
argument_list|)
expr_stmt|;
name|list
operator|->
name|map
operator|->
name|size
operator|=
name|map
operator|->
name|size
expr_stmt|;
block|}
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
operator|*
name|maplist
operator|=
name|list
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|drm_core_has_MTRR
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|map
operator|->
name|type
operator|==
name|_DRM_FRAME_BUFFER
operator|||
operator|(
name|map
operator|->
name|flags
operator|&
name|_DRM_WRITE_COMBINING
operator|)
condition|)
block|{
if|if
condition|(
name|drm_mtrr_add
argument_list|(
name|map
operator|->
name|offset
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|DRM_MTRR_WC
argument_list|)
operator|==
literal|0
condition|)
name|map
operator|->
name|mtrr
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|map
operator|->
name|type
operator|==
name|_DRM_REGISTERS
condition|)
block|{
name|drm_core_ioremap
argument_list|(
name|map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
operator|->
name|handle
condition|)
block|{
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
block|}
break|break;
case|case
name|_DRM_SHM
case|:
name|list
operator|=
name|drm_find_matching_map
argument_list|(
name|dev
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|map
operator|->
name|size
operator|!=
name|map
operator|->
name|size
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Matching maps of type %d with "
literal|"mismatched sizes, (%ld vs %ld)\n"
argument_list|,
name|map
operator|->
name|type
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|list
operator|->
name|map
operator|->
name|size
argument_list|)
expr_stmt|;
name|list
operator|->
name|map
operator|->
name|size
operator|=
name|map
operator|->
name|size
expr_stmt|;
block|}
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
operator|*
name|maplist
operator|=
name|list
expr_stmt|;
return|return
literal|0
return|;
block|}
name|map
operator|->
name|handle
operator|=
name|malloc
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|DRM_MEM_MAPS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%lu %d %p\n"
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|drm_order
argument_list|(
name|map
operator|->
name|size
argument_list|)
argument_list|,
name|map
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
operator|->
name|handle
condition|)
block|{
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|map
operator|->
name|offset
operator|=
operator|(
name|unsigned
name|long
operator|)
name|map
operator|->
name|handle
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|flags
operator|&
name|_DRM_CONTAINS_LOCK
condition|)
block|{
comment|/* Prevent a 2nd X Server from creating a 2nd lock */
if|if
condition|(
name|dev
operator|->
name|primary
operator|->
name|master
operator|->
name|lock
operator|.
name|hw_lock
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|map
operator|->
name|handle
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
name|dev
operator|->
name|sigdata
operator|.
name|lock
operator|=
name|dev
operator|->
name|primary
operator|->
name|master
operator|->
name|lock
operator|.
name|hw_lock
operator|=
name|map
operator|->
name|handle
expr_stmt|;
comment|/* Pointer to lock */
block|}
break|break;
case|case
name|_DRM_AGP
case|:
block|{
name|struct
name|drm_agp_mem
modifier|*
name|entry
decl_stmt|;
name|int
name|valid
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_has_AGP
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
ifdef|#
directive|ifdef
name|__linux__
ifdef|#
directive|ifdef
name|__alpha__
name|map
operator|->
name|offset
operator|+=
name|dev
operator|->
name|hose
operator|->
name|mem_space
operator|->
name|start
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* In some cases (i810 driver), user space may have already 		 * added the AGP base itself, because dev->agp->base previously 		 * only got set during AGP enable.  So, only add the base 		 * address if the map's offset isn't already within the 		 * aperture. 		 */
if|if
condition|(
name|map
operator|->
name|offset
operator|<
name|dev
operator|->
name|agp
operator|->
name|base
operator|||
name|map
operator|->
name|offset
operator|>
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|dev
operator|->
name|agp
operator|->
name|agp_info
operator|.
name|ai_aperture_size
operator|*
literal|1024
operator|*
literal|1024
operator|-
literal|1
condition|)
block|{
name|map
operator|->
name|offset
operator|+=
name|dev
operator|->
name|agp
operator|->
name|base
expr_stmt|;
block|}
name|map
operator|->
name|mtrr
operator|=
name|dev
operator|->
name|agp
operator|->
name|agp_mtrr
expr_stmt|;
comment|/* for getmap */
comment|/* This assumes the DRM is in total control of AGP space. 		 * It's not always the case as AGP can be in the control 		 * of user space (i.e. i810 driver). So this loop will get 		 * skipped and we double check that dev->agp->memory is 		 * actually set as well as being invalid before EPERM'ing 		 */
name|list_for_each_entry
argument_list|(
argument|entry
argument_list|,
argument|&dev->agp->memory
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|(
name|map
operator|->
name|offset
operator|>=
name|entry
operator|->
name|bound
operator|)
operator|&&
operator|(
name|map
operator|->
name|offset
operator|+
name|map
operator|->
name|size
operator|<=
name|entry
operator|->
name|bound
operator|+
name|entry
operator|->
name|pages
operator|*
name|PAGE_SIZE
operator|)
condition|)
block|{
name|valid
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|dev
operator|->
name|agp
operator|->
name|memory
argument_list|)
operator|&&
operator|!
name|valid
condition|)
block|{
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
operator|-
name|EPERM
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"AGP offset = 0x%08llx, size = 0x%08lx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|map
operator|->
name|offset
argument_list|,
name|map
operator|->
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|_DRM_GEM
case|:
name|DRM_ERROR
argument_list|(
literal|"tried to addmap GEM object\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|_DRM_SCATTER_GATHER
case|:
if|if
condition|(
operator|!
name|dev
operator|->
name|sg
condition|)
block|{
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|map
operator|->
name|handle
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|dev
operator|->
name|sg
operator|->
name|vaddr
operator|+
name|offset
operator|)
expr_stmt|;
name|map
operator|->
name|offset
operator|+=
name|dev
operator|->
name|sg
operator|->
name|vaddr
expr_stmt|;
break|break;
case|case
name|_DRM_CONSISTENT
case|:
comment|/* dma_addr_t is 64bit on i386 with CONFIG_HIGHMEM64G, 		 * As we're limiting the address to 2^32-1 (or less), 		 * casting it down to 32 bits is no problem, but we 		 * need to point to a 64bit variable first. */
name|align
operator|=
name|map
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|align
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|align
operator|=
name|PAGE_SIZE
expr_stmt|;
name|dmah
operator|=
name|drm_pci_alloc
argument_list|(
name|dev
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|align
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dmah
condition|)
block|{
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|map
operator|->
name|handle
operator|=
name|dmah
operator|->
name|vaddr
expr_stmt|;
name|map
operator|->
name|offset
operator|=
name|dmah
operator|->
name|busaddr
expr_stmt|;
name|map
operator|->
name|dmah
operator|=
name|dmah
expr_stmt|;
break|break;
default|default:
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|list
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|list
argument_list|)
argument_list|,
name|DRM_MEM_MAPS
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
block|{
if|if
condition|(
name|map
operator|->
name|type
operator|==
name|_DRM_REGISTERS
condition|)
name|drm_core_ioremapfree
argument_list|(
name|map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|list
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|list
operator|->
name|head
argument_list|,
operator|&
name|dev
operator|->
name|maplist
argument_list|)
expr_stmt|;
comment|/* Assign a 32-bit handle */
comment|/* We do it here so that dev->struct_mutex protects the increment */
name|user_token
operator|=
operator|(
name|map
operator|->
name|type
operator|==
name|_DRM_SHM
operator|)
condition|?
operator|(
name|unsigned
name|long
operator|)
name|map
operator|->
name|handle
else|:
name|map
operator|->
name|offset
expr_stmt|;
name|ret
operator|=
name|drm_map_handle
argument_list|(
name|dev
argument_list|,
operator|&
name|list
operator|->
name|hash
argument_list|,
name|user_token
argument_list|,
literal|0
argument_list|,
operator|(
name|map
operator|->
name|type
operator|==
name|_DRM_SHM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|map
operator|->
name|type
operator|==
name|_DRM_REGISTERS
condition|)
name|drm_core_ioremapfree
argument_list|(
name|map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|list
operator|->
name|user_token
operator|=
name|list
operator|->
name|hash
operator|.
name|key
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|map
operator|->
name|flags
operator|&
name|_DRM_DRIVER
operator|)
condition|)
name|list
operator|->
name|master
operator|=
name|dev
operator|->
name|primary
operator|->
name|master
expr_stmt|;
operator|*
name|maplist
operator|=
name|list
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|drm_addmap
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|resource_size_t
name|offset
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|enum
name|drm_map_type
name|type
parameter_list|,
name|enum
name|drm_map_flags
name|flags
parameter_list|,
name|struct
name|drm_local_map
modifier|*
modifier|*
name|map_ptr
parameter_list|)
block|{
name|struct
name|drm_map_list
modifier|*
name|list
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|drm_addmap_core
argument_list|(
name|dev
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|flags
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
operator|*
name|map_ptr
operator|=
name|list
operator|->
name|map
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_addmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * Ioctl to specify a range of memory that is available for mapping by a  * non-root process.  *  * \param inode device inode.  * \param file_priv DRM file private.  * \param cmd command.  * \param arg pointer to a drm_map structure.  * \return zero on success or a negative value on error.  *  */
end_comment

begin_function
name|int
name|drm_addmap_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_map
modifier|*
name|map
init|=
name|data
decl_stmt|;
name|struct
name|drm_map_list
modifier|*
name|maplist
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|DRM_SUSER
argument_list|(
name|DRM_CURPROC
argument_list|)
operator|||
name|map
operator|->
name|type
operator|==
name|_DRM_AGP
operator|||
name|map
operator|->
name|type
operator|==
name|_DRM_SHM
operator|)
condition|)
return|return
operator|-
name|EPERM
return|;
name|err
operator|=
name|drm_addmap_core
argument_list|(
name|dev
argument_list|,
name|map
operator|->
name|offset
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|map
operator|->
name|type
argument_list|,
name|map
operator|->
name|flags
argument_list|,
operator|&
name|maplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* avoid a warning on 64-bit, this casting isn't very nice, but the API is set so too late */
name|map
operator|->
name|handle
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|maplist
operator|->
name|user_token
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Remove a map private from list and deallocate resources if the mapping  * isn't in use.  *  * Searches the map on drm_device::maplist, removes it from the list, see if  * its being used, and free any associate resource (such as MTRR's) if it's not  * being on use.  *  * \sa drm_addmap  */
end_comment

begin_function
name|int
name|drm_rmmap_locked
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_local_map
modifier|*
name|map
parameter_list|)
block|{
name|struct
name|drm_map_list
modifier|*
name|r_list
init|=
name|NULL
decl_stmt|,
modifier|*
name|list_t
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|drm_master
modifier|*
name|master
decl_stmt|;
comment|/* Find the list entry for the map and remove it */
name|list_for_each_entry_safe
argument_list|(
argument|r_list
argument_list|,
argument|list_t
argument_list|,
argument|&dev->maplist
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|r_list
operator|->
name|map
operator|==
name|map
condition|)
block|{
name|master
operator|=
name|r_list
operator|->
name|master
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|r_list
operator|->
name|head
argument_list|)
expr_stmt|;
name|drm_ht_remove_key
argument_list|(
operator|&
name|dev
operator|->
name|map_hash
argument_list|,
name|r_list
operator|->
name|user_token
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r_list
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
operator|-
name|EINVAL
return|;
switch|switch
condition|(
name|map
operator|->
name|type
condition|)
block|{
case|case
name|_DRM_REGISTERS
case|:
name|drm_core_ioremapfree
argument_list|(
name|map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|_DRM_FRAME_BUFFER
case|:
if|if
condition|(
name|drm_core_has_MTRR
argument_list|(
name|dev
argument_list|)
operator|&&
name|map
operator|->
name|mtrr
operator|>=
literal|0
condition|)
block|{
name|int
name|retcode
decl_stmt|;
name|retcode
operator|=
name|drm_mtrr_del
argument_list|(
name|map
operator|->
name|mtrr
argument_list|,
name|map
operator|->
name|offset
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|DRM_MTRR_WC
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"mtrr_del=%d\n"
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|_DRM_SHM
case|:
name|free
argument_list|(
name|map
operator|->
name|handle
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|master
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|sigdata
operator|.
name|lock
operator|==
name|master
operator|->
name|lock
operator|.
name|hw_lock
condition|)
name|dev
operator|->
name|sigdata
operator|.
name|lock
operator|=
name|NULL
expr_stmt|;
name|master
operator|->
name|lock
operator|.
name|hw_lock
operator|=
name|NULL
expr_stmt|;
comment|/* SHM removed */
name|master
operator|->
name|lock
operator|.
name|file_priv
operator|=
name|NULL
expr_stmt|;
name|DRM_WAKEUP_INT
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|master
operator|->
name|lock
operator|.
name|lock_queue
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|_DRM_AGP
case|:
case|case
name|_DRM_SCATTER_GATHER
case|:
break|break;
case|case
name|_DRM_CONSISTENT
case|:
name|drm_pci_free
argument_list|(
name|dev
argument_list|,
name|map
operator|->
name|dmah
argument_list|)
expr_stmt|;
break|break;
case|case
name|_DRM_GEM
case|:
name|DRM_ERROR
argument_list|(
literal|"tried to rmmap GEM object\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_rmmap_locked
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|drm_rmmap
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_local_map
modifier|*
name|map
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_rmmap_locked
argument_list|(
name|dev
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_rmmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The rmmap ioctl appears to be unnecessary.  All mappings are torn down on  * the last close of the device, and this is necessary for cleanup when things  * exit uncleanly.  Therefore, having userland manually remove mappings seems  * like a pointless exercise since they're going away anyway.  *  * One use case might be after addmap is allowed for normal users for SHM and  * gets used by drivers that the server doesn't need to care about.  This seems  * unlikely.  *  * \param inode device inode.  * \param file_priv DRM file private.  * \param cmd command.  * \param arg pointer to a struct drm_map structure.  * \return zero on success or a negative value on error.  */
end_comment

begin_function
name|int
name|drm_rmmap_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_map
modifier|*
name|request
init|=
name|data
decl_stmt|;
name|struct
name|drm_local_map
modifier|*
name|map
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_map_list
modifier|*
name|r_list
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|r_list
argument_list|,
argument|&dev->maplist
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|r_list
operator|->
name|map
operator|&&
name|r_list
operator|->
name|user_token
operator|==
operator|(
name|unsigned
name|long
operator|)
name|request
operator|->
name|handle
operator|&&
name|r_list
operator|->
name|map
operator|->
name|flags
operator|&
name|_DRM_REMOVABLE
condition|)
block|{
name|map
operator|=
name|r_list
operator|->
name|map
expr_stmt|;
break|break;
block|}
block|}
comment|/* List has wrapped around to the head pointer, or its empty we didn't 	 * find anything. 	 */
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|dev
operator|->
name|maplist
argument_list|)
operator|||
operator|!
name|map
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Register and framebuffer maps are permanent */
if|if
condition|(
operator|(
name|map
operator|->
name|type
operator|==
name|_DRM_REGISTERS
operator|)
operator|||
operator|(
name|map
operator|->
name|type
operator|==
name|_DRM_FRAME_BUFFER
operator|)
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ret
operator|=
name|drm_rmmap_locked
argument_list|(
name|dev
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Cleanup after an error on one of the addbufs() functions.  *  * \param dev DRM device.  * \param entry buffer entry where the error occurred.  *  * Frees any pages and buffers associated with the given entry.  */
end_comment

begin_function
specifier|static
name|void
name|drm_cleanup_buf_error
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_buf_entry
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|seg_count
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|seg_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|seglist
index|[
name|i
index|]
condition|)
block|{
name|drm_pci_free
argument_list|(
name|dev
argument_list|,
name|entry
operator|->
name|seglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|entry
operator|->
name|seglist
argument_list|,
name|DRM_MEM_SEGS
argument_list|)
expr_stmt|;
name|entry
operator|->
name|seg_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|buf_count
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|entry
operator|->
name|buflist
index|[
name|i
index|]
operator|.
name|dev_private
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|entry
operator|->
name|buflist
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|__OS_HAS_AGP
end_if

begin_comment
comment|/**  * Add AGP buffers for DMA transfers.  *  * \param dev struct drm_device to which the buffers are to be added.  * \param request pointer to a struct drm_buf_desc describing the request.  * \return zero on success or a negative number on failure.  *  * After some sanity checks creates a drm_buf structure for each buffer and  * reallocates the buffer list of the same size order to accommodate the new  * buffers.  */
end_comment

begin_function
name|int
name|drm_addbufs_agp
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_buf_desc
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|struct
name|drm_buf_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|drm_agp_mem
modifier|*
name|agp_entry
decl_stmt|;
name|struct
name|drm_buf
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|agp_offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|order
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|int
name|page_order
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
name|int
name|i
decl_stmt|,
name|valid
decl_stmt|;
name|struct
name|drm_buf
modifier|*
modifier|*
name|temp_buflist
decl_stmt|;
if|if
condition|(
operator|!
name|dma
condition|)
return|return
operator|-
name|EINVAL
return|;
name|count
operator|=
name|request
operator|->
name|count
expr_stmt|;
name|order
operator|=
name|drm_order
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
operator|<<
name|order
expr_stmt|;
name|alignment
operator|=
operator|(
name|request
operator|->
name|flags
operator|&
name|_DRM_PAGE_ALIGN
operator|)
condition|?
name|PAGE_ALIGN
argument_list|(
name|size
argument_list|)
else|:
name|size
expr_stmt|;
name|page_order
operator|=
name|order
operator|-
name|PAGE_SHIFT
operator|>
literal|0
condition|?
name|order
operator|-
name|PAGE_SHIFT
else|:
literal|0
expr_stmt|;
name|total
operator|=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
name|byte_count
operator|=
literal|0
expr_stmt|;
name|agp_offset
operator|=
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|request
operator|->
name|agp_start
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"count:      %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"order:      %d\n"
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"size:       %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"agp_offset: %lx\n"
argument_list|,
name|agp_offset
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"alignment:  %d\n"
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"page_order: %d\n"
argument_list|,
name|page_order
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"total:      %d\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
name|DRM_MIN_ORDER
operator|||
name|order
operator|>
name|DRM_MAX_ORDER
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* Make sure buffers are located in AGP memory that we own */
name|valid
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|agp_entry
argument_list|,
argument|&dev->agp->memory
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|(
name|agp_offset
operator|>=
name|agp_entry
operator|->
name|bound
operator|)
operator|&&
operator|(
name|agp_offset
operator|+
name|total
operator|*
name|count
operator|<=
name|agp_entry
operator|->
name|bound
operator|+
name|agp_entry
operator|->
name|pages
operator|*
name|PAGE_SIZE
operator|)
condition|)
block|{
name|valid
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|dev
operator|->
name|agp
operator|->
name|memory
argument_list|)
operator|&&
operator|!
name|valid
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"zone invalid\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|buf_use
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
name|atomic_inc
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|dma
operator|->
name|bufs
index|[
name|order
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|buf_count
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
comment|/* May only call once for each order */
block|}
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|count
operator|>
literal|4096
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|entry
operator|->
name|buflist
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|buflist
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|entry
operator|->
name|buf_size
operator|=
name|size
expr_stmt|;
name|entry
operator|->
name|page_order
operator|=
name|page_order
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|entry
operator|->
name|buf_count
operator|<
name|count
condition|)
block|{
name|buf
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|entry
operator|->
name|buf_count
index|]
expr_stmt|;
name|buf
operator|->
name|idx
operator|=
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
expr_stmt|;
name|buf
operator|->
name|total
operator|=
name|alignment
expr_stmt|;
name|buf
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|offset
operator|=
operator|(
name|dma
operator|->
name|byte_count
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|bus_address
operator|=
name|agp_offset
operator|+
name|offset
expr_stmt|;
name|buf
operator|->
name|address
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|agp_offset
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|waiting
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|file_priv
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dev_priv_size
operator|=
name|dev
operator|->
name|driver
operator|->
name|dev_priv_size
expr_stmt|;
name|buf
operator|->
name|dev_private
operator|=
name|malloc
argument_list|(
name|buf
operator|->
name|dev_priv_size
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|->
name|dev_private
condition|)
block|{
comment|/* Set count correctly so we free the proper amount. */
name|entry
operator|->
name|buf_count
operator|=
name|count
expr_stmt|;
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"buffer %d @ %p\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|,
name|buf
operator|->
name|address
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|alignment
expr_stmt|;
name|entry
operator|->
name|buf_count
operator|++
expr_stmt|;
name|byte_count
operator|+=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"byte_count: %d\n"
argument_list|,
name|byte_count
argument_list|)
expr_stmt|;
name|temp_buflist
operator|=
name|realloc
argument_list|(
name|dma
operator|->
name|buflist
argument_list|,
operator|(
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp_buflist
condition|)
block|{
comment|/* Free the entry because it isn't valid */
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dma
operator|->
name|buflist
operator|=
name|temp_buflist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|dma
operator|->
name|buflist
index|[
name|i
operator|+
name|dma
operator|->
name|buf_count
index|]
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
block|}
name|dma
operator|->
name|buf_count
operator|+=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|dma
operator|->
name|seg_count
operator|+=
name|entry
operator|->
name|seg_count
expr_stmt|;
name|dma
operator|->
name|page_count
operator|+=
name|byte_count
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|dma
operator|->
name|byte_count
operator|+=
name|byte_count
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dma->buf_count : %d\n"
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"entry->buf_count : %d\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|request
operator|->
name|count
operator|=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|request
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|dma
operator|->
name|flags
operator|=
name|_DRM_DMA_USE_AGP
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_addbufs_agp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __OS_HAS_AGP */
end_comment

begin_function
name|int
name|drm_addbufs_pci
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_buf_desc
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|order
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|page_order
decl_stmt|;
name|struct
name|drm_buf_entry
modifier|*
name|entry
decl_stmt|;
name|drm_dma_handle_t
modifier|*
name|dmah
decl_stmt|;
name|struct
name|drm_buf
modifier|*
name|buf
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
name|int
name|page_count
decl_stmt|;
name|unsigned
name|long
modifier|*
name|temp_pagelist
decl_stmt|;
name|struct
name|drm_buf
modifier|*
modifier|*
name|temp_buflist
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_PCI_DMA
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|dma
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|DRM_SUSER
argument_list|(
name|DRM_CURPROC
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
name|count
operator|=
name|request
operator|->
name|count
expr_stmt|;
name|order
operator|=
name|drm_order
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
operator|<<
name|order
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"count=%d, size=%d (%d), order=%d\n"
argument_list|,
name|request
operator|->
name|count
argument_list|,
name|request
operator|->
name|size
argument_list|,
name|size
argument_list|,
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
name|DRM_MIN_ORDER
operator|||
name|order
operator|>
name|DRM_MAX_ORDER
condition|)
return|return
operator|-
name|EINVAL
return|;
name|alignment
operator|=
operator|(
name|request
operator|->
name|flags
operator|&
name|_DRM_PAGE_ALIGN
operator|)
condition|?
name|PAGE_ALIGN
argument_list|(
name|size
argument_list|)
else|:
name|size
expr_stmt|;
name|page_order
operator|=
name|order
operator|-
name|PAGE_SHIFT
operator|>
literal|0
condition|?
name|order
operator|-
name|PAGE_SHIFT
else|:
literal|0
expr_stmt|;
name|total
operator|=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|buf_use
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
name|atomic_inc
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|dma
operator|->
name|bufs
index|[
name|order
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|buf_count
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
comment|/* May only call once for each order */
block|}
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|count
operator|>
literal|4096
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|entry
operator|->
name|buflist
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|buflist
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|entry
operator|->
name|seglist
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|seglist
argument_list|)
argument_list|,
name|DRM_MEM_SEGS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|seglist
condition|)
block|{
name|free
argument_list|(
name|entry
operator|->
name|buflist
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
comment|/* Keep the original pagelist until we know all the allocations 	 * have succeeded 	 */
name|temp_pagelist
operator|=
name|malloc
argument_list|(
operator|(
name|dma
operator|->
name|page_count
operator|+
operator|(
name|count
operator|<<
name|page_order
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|pagelist
argument_list|)
argument_list|,
name|DRM_MEM_PAGES
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp_pagelist
condition|)
block|{
name|free
argument_list|(
name|entry
operator|->
name|buflist
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
operator|->
name|seglist
argument_list|,
name|DRM_MEM_SEGS
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|memcpy
argument_list|(
name|temp_pagelist
argument_list|,
name|dma
operator|->
name|pagelist
argument_list|,
name|dma
operator|->
name|page_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|pagelist
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"pagelist: %d entries\n"
argument_list|,
name|dma
operator|->
name|page_count
operator|+
operator|(
name|count
operator|<<
name|page_order
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf_size
operator|=
name|size
expr_stmt|;
name|entry
operator|->
name|page_order
operator|=
name|page_order
expr_stmt|;
name|byte_count
operator|=
literal|0
expr_stmt|;
name|page_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|entry
operator|->
name|buf_count
operator|<
name|count
condition|)
block|{
name|dmah
operator|=
name|drm_pci_alloc
argument_list|(
name|dev
argument_list|,
name|PAGE_SIZE
operator|<<
name|page_order
argument_list|,
literal|0x1000
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dmah
condition|)
block|{
comment|/* Set count correctly so we free the proper amount. */
name|entry
operator|->
name|buf_count
operator|=
name|count
expr_stmt|;
name|entry
operator|->
name|seg_count
operator|=
name|count
expr_stmt|;
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_pagelist
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|entry
operator|->
name|seglist
index|[
name|entry
operator|->
name|seg_count
operator|++
index|]
operator|=
name|dmah
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|page_order
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"page %d @ 0x%08lx\n"
argument_list|,
name|dma
operator|->
name|page_count
operator|+
name|page_count
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dmah
operator|->
name|vaddr
operator|+
name|PAGE_SIZE
operator|*
name|i
argument_list|)
expr_stmt|;
name|temp_pagelist
index|[
name|dma
operator|->
name|page_count
operator|+
name|page_count
operator|++
index|]
operator|=
operator|(
name|unsigned
name|long
operator|)
name|dmah
operator|->
name|vaddr
operator|+
name|PAGE_SIZE
operator|*
name|i
expr_stmt|;
block|}
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|+
name|size
operator|<=
name|total
operator|&&
name|entry
operator|->
name|buf_count
operator|<
name|count
condition|;
name|offset
operator|+=
name|alignment
operator|,
operator|++
name|entry
operator|->
name|buf_count
control|)
block|{
name|buf
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|entry
operator|->
name|buf_count
index|]
expr_stmt|;
name|buf
operator|->
name|idx
operator|=
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
expr_stmt|;
name|buf
operator|->
name|total
operator|=
name|alignment
expr_stmt|;
name|buf
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|offset
operator|=
operator|(
name|dma
operator|->
name|byte_count
operator|+
name|byte_count
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|address
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dmah
operator|->
name|vaddr
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|bus_address
operator|=
name|dmah
operator|->
name|busaddr
operator|+
name|offset
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|waiting
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|file_priv
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dev_priv_size
operator|=
name|dev
operator|->
name|driver
operator|->
name|dev_priv_size
expr_stmt|;
name|buf
operator|->
name|dev_private
operator|=
name|malloc
argument_list|(
name|buf
operator|->
name|dev_priv_size
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|->
name|dev_private
condition|)
block|{
comment|/* Set count correctly so we free the proper amount. */
name|entry
operator|->
name|buf_count
operator|=
name|count
expr_stmt|;
name|entry
operator|->
name|seg_count
operator|=
name|count
expr_stmt|;
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_pagelist
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"buffer %d @ %p\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|,
name|buf
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
name|byte_count
operator|+=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
block|}
name|temp_buflist
operator|=
name|realloc
argument_list|(
name|dma
operator|->
name|buflist
argument_list|,
operator|(
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp_buflist
condition|)
block|{
comment|/* Free the entry because it isn't valid */
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_pagelist
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dma
operator|->
name|buflist
operator|=
name|temp_buflist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|dma
operator|->
name|buflist
index|[
name|i
operator|+
name|dma
operator|->
name|buf_count
index|]
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* No allocations failed, so now we can replace the original pagelist 	 * with the new one. 	 */
if|if
condition|(
name|dma
operator|->
name|page_count
condition|)
block|{
name|free
argument_list|(
name|dma
operator|->
name|pagelist
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
block|}
name|dma
operator|->
name|pagelist
operator|=
name|temp_pagelist
expr_stmt|;
name|dma
operator|->
name|buf_count
operator|+=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|dma
operator|->
name|seg_count
operator|+=
name|entry
operator|->
name|seg_count
expr_stmt|;
name|dma
operator|->
name|page_count
operator|+=
name|entry
operator|->
name|seg_count
operator|<<
name|page_order
expr_stmt|;
name|dma
operator|->
name|byte_count
operator|+=
name|PAGE_SIZE
operator|*
operator|(
name|entry
operator|->
name|seg_count
operator|<<
name|page_order
operator|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|request
operator|->
name|count
operator|=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|request
operator|->
name|size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|flags
operator|&
name|_DRM_PCI_BUFFER_RO
condition|)
name|dma
operator|->
name|flags
operator|=
name|_DRM_DMA_USE_PCI_RO
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_addbufs_pci
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|drm_addbufs_sg
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_buf_desc
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|struct
name|drm_buf_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|drm_buf
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|agp_offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|order
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|int
name|page_order
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|drm_buf
modifier|*
modifier|*
name|temp_buflist
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_SG
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|dma
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|DRM_SUSER
argument_list|(
name|DRM_CURPROC
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
name|count
operator|=
name|request
operator|->
name|count
expr_stmt|;
name|order
operator|=
name|drm_order
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
operator|<<
name|order
expr_stmt|;
name|alignment
operator|=
operator|(
name|request
operator|->
name|flags
operator|&
name|_DRM_PAGE_ALIGN
operator|)
condition|?
name|PAGE_ALIGN
argument_list|(
name|size
argument_list|)
else|:
name|size
expr_stmt|;
name|page_order
operator|=
name|order
operator|-
name|PAGE_SHIFT
operator|>
literal|0
condition|?
name|order
operator|-
name|PAGE_SHIFT
else|:
literal|0
expr_stmt|;
name|total
operator|=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
name|byte_count
operator|=
literal|0
expr_stmt|;
name|agp_offset
operator|=
name|request
operator|->
name|agp_start
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"count:      %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"order:      %d\n"
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"size:       %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"agp_offset: %lu\n"
argument_list|,
name|agp_offset
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"alignment:  %d\n"
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"page_order: %d\n"
argument_list|,
name|page_order
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"total:      %d\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
name|DRM_MIN_ORDER
operator|||
name|order
operator|>
name|DRM_MAX_ORDER
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|buf_use
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
name|atomic_inc
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|dma
operator|->
name|bufs
index|[
name|order
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|buf_count
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
comment|/* May only call once for each order */
block|}
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|count
operator|>
literal|4096
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|entry
operator|->
name|buflist
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|buflist
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|entry
operator|->
name|buf_size
operator|=
name|size
expr_stmt|;
name|entry
operator|->
name|page_order
operator|=
name|page_order
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|entry
operator|->
name|buf_count
operator|<
name|count
condition|)
block|{
name|buf
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|entry
operator|->
name|buf_count
index|]
expr_stmt|;
name|buf
operator|->
name|idx
operator|=
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
expr_stmt|;
name|buf
operator|->
name|total
operator|=
name|alignment
expr_stmt|;
name|buf
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|offset
operator|=
operator|(
name|dma
operator|->
name|byte_count
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|bus_address
operator|=
name|agp_offset
operator|+
name|offset
expr_stmt|;
name|buf
operator|->
name|address
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|agp_offset
operator|+
name|offset
operator|+
operator|(
name|unsigned
name|long
operator|)
name|dev
operator|->
name|sg
operator|->
name|vaddr
operator|)
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|waiting
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|file_priv
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dev_priv_size
operator|=
name|dev
operator|->
name|driver
operator|->
name|dev_priv_size
expr_stmt|;
name|buf
operator|->
name|dev_private
operator|=
name|malloc
argument_list|(
name|buf
operator|->
name|dev_priv_size
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|->
name|dev_private
condition|)
block|{
comment|/* Set count correctly so we free the proper amount. */
name|entry
operator|->
name|buf_count
operator|=
name|count
expr_stmt|;
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"buffer %d @ %p\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|,
name|buf
operator|->
name|address
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|alignment
expr_stmt|;
name|entry
operator|->
name|buf_count
operator|++
expr_stmt|;
name|byte_count
operator|+=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"byte_count: %d\n"
argument_list|,
name|byte_count
argument_list|)
expr_stmt|;
name|temp_buflist
operator|=
name|realloc
argument_list|(
name|dma
operator|->
name|buflist
argument_list|,
operator|(
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp_buflist
condition|)
block|{
comment|/* Free the entry because it isn't valid */
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dma
operator|->
name|buflist
operator|=
name|temp_buflist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|dma
operator|->
name|buflist
index|[
name|i
operator|+
name|dma
operator|->
name|buf_count
index|]
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
block|}
name|dma
operator|->
name|buf_count
operator|+=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|dma
operator|->
name|seg_count
operator|+=
name|entry
operator|->
name|seg_count
expr_stmt|;
name|dma
operator|->
name|page_count
operator|+=
name|byte_count
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|dma
operator|->
name|byte_count
operator|+=
name|byte_count
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dma->buf_count : %d\n"
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"entry->buf_count : %d\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|request
operator|->
name|count
operator|=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|request
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|dma
operator|->
name|flags
operator|=
name|_DRM_DMA_USE_SG
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_addbufs_fb
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_buf_desc
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|struct
name|drm_buf_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|drm_buf
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|agp_offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|order
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|int
name|page_order
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|drm_buf
modifier|*
modifier|*
name|temp_buflist
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_FB_DMA
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|dma
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|DRM_SUSER
argument_list|(
name|DRM_CURPROC
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
name|count
operator|=
name|request
operator|->
name|count
expr_stmt|;
name|order
operator|=
name|drm_order
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
operator|<<
name|order
expr_stmt|;
name|alignment
operator|=
operator|(
name|request
operator|->
name|flags
operator|&
name|_DRM_PAGE_ALIGN
operator|)
condition|?
name|PAGE_ALIGN
argument_list|(
name|size
argument_list|)
else|:
name|size
expr_stmt|;
name|page_order
operator|=
name|order
operator|-
name|PAGE_SHIFT
operator|>
literal|0
condition|?
name|order
operator|-
name|PAGE_SHIFT
else|:
literal|0
expr_stmt|;
name|total
operator|=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
name|byte_count
operator|=
literal|0
expr_stmt|;
name|agp_offset
operator|=
name|request
operator|->
name|agp_start
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"count:      %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"order:      %d\n"
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"size:       %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"agp_offset: %lu\n"
argument_list|,
name|agp_offset
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"alignment:  %d\n"
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"page_order: %d\n"
argument_list|,
name|page_order
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"total:      %d\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
name|DRM_MIN_ORDER
operator|||
name|order
operator|>
name|DRM_MAX_ORDER
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|buf_use
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
name|atomic_inc
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|dma
operator|->
name|bufs
index|[
name|order
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|buf_count
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
comment|/* May only call once for each order */
block|}
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|count
operator|>
literal|4096
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|entry
operator|->
name|buflist
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|buflist
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|entry
operator|->
name|buf_size
operator|=
name|size
expr_stmt|;
name|entry
operator|->
name|page_order
operator|=
name|page_order
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|entry
operator|->
name|buf_count
operator|<
name|count
condition|)
block|{
name|buf
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|entry
operator|->
name|buf_count
index|]
expr_stmt|;
name|buf
operator|->
name|idx
operator|=
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
expr_stmt|;
name|buf
operator|->
name|total
operator|=
name|alignment
expr_stmt|;
name|buf
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|offset
operator|=
operator|(
name|dma
operator|->
name|byte_count
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|bus_address
operator|=
name|agp_offset
operator|+
name|offset
expr_stmt|;
name|buf
operator|->
name|address
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|agp_offset
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|waiting
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|file_priv
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dev_priv_size
operator|=
name|dev
operator|->
name|driver
operator|->
name|dev_priv_size
expr_stmt|;
name|buf
operator|->
name|dev_private
operator|=
name|malloc
argument_list|(
name|buf
operator|->
name|dev_priv_size
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|->
name|dev_private
condition|)
block|{
comment|/* Set count correctly so we free the proper amount. */
name|entry
operator|->
name|buf_count
operator|=
name|count
expr_stmt|;
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"buffer %d @ %p\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|,
name|buf
operator|->
name|address
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|alignment
expr_stmt|;
name|entry
operator|->
name|buf_count
operator|++
expr_stmt|;
name|byte_count
operator|+=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"byte_count: %d\n"
argument_list|,
name|byte_count
argument_list|)
expr_stmt|;
name|temp_buflist
operator|=
name|realloc
argument_list|(
name|dma
operator|->
name|buflist
argument_list|,
operator|(
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp_buflist
condition|)
block|{
comment|/* Free the entry because it isn't valid */
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dma
operator|->
name|buflist
operator|=
name|temp_buflist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|dma
operator|->
name|buflist
index|[
name|i
operator|+
name|dma
operator|->
name|buf_count
index|]
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
block|}
name|dma
operator|->
name|buf_count
operator|+=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|dma
operator|->
name|seg_count
operator|+=
name|entry
operator|->
name|seg_count
expr_stmt|;
name|dma
operator|->
name|page_count
operator|+=
name|byte_count
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|dma
operator|->
name|byte_count
operator|+=
name|byte_count
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dma->buf_count : %d\n"
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"entry->buf_count : %d\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|request
operator|->
name|count
operator|=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|request
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|dma
operator|->
name|flags
operator|=
name|_DRM_DMA_USE_FB
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Add buffers for DMA transfers (ioctl).  *  * \param inode device inode.  * \param file_priv DRM file private.  * \param cmd command.  * \param arg pointer to a struct drm_buf_desc request.  * \return zero on success or a negative number on failure.  *  * According with the memory type specified in drm_buf_desc::flags and the  * build options, it dispatches the call either to addbufs_agp(),  * addbufs_sg() or addbufs_pci() for AGP, scatter-gather or consistent  * PCI memory respectively.  */
end_comment

begin_function
name|int
name|drm_addbufs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_buf_desc
modifier|*
name|request
init|=
name|data
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_HAVE_DMA
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|#
directive|if
name|__OS_HAS_AGP
if|if
condition|(
name|request
operator|->
name|flags
operator|&
name|_DRM_AGP_BUFFER
condition|)
name|ret
operator|=
name|drm_addbufs_agp
argument_list|(
name|dev
argument_list|,
name|request
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|request
operator|->
name|flags
operator|&
name|_DRM_SG_BUFFER
condition|)
name|ret
operator|=
name|drm_addbufs_sg
argument_list|(
name|dev
argument_list|,
name|request
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|request
operator|->
name|flags
operator|&
name|_DRM_FB_BUFFER
condition|)
name|ret
operator|=
name|drm_addbufs_fb
argument_list|(
name|dev
argument_list|,
name|request
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|drm_addbufs_pci
argument_list|(
name|dev
argument_list|,
name|request
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Get information about the buffer mappings.  *  * This was originally mean for debugging purposes, or by a sophisticated  * client library to determine how best to use the available buffers (e.g.,  * large buffers can be used for image transfer).  *  * \param inode device inode.  * \param file_priv DRM file private.  * \param cmd command.  * \param arg pointer to a drm_buf_info structure.  * \return zero on success or a negative number on failure.  *  * Increments drm_device::buf_use while holding the drm_device::count_lock  * lock, preventing of allocating more buffers after this call. Information  * about each requested buffer is then copied into user space.  */
end_comment

begin_function
name|int
name|drm_infobufs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|struct
name|drm_buf_info
modifier|*
name|request
init|=
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_HAVE_DMA
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|dma
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
operator|++
name|dev
operator|->
name|buf_use
expr_stmt|;
comment|/* Can't allocate more after this call */
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_MAX_ORDER
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_count
condition|)
operator|++
name|count
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"count = %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|count
operator|>=
name|count
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_MAX_ORDER
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_count
condition|)
block|{
name|struct
name|drm_buf_desc
name|__user
modifier|*
name|to
init|=
operator|&
name|request
operator|->
name|list
index|[
name|count
index|]
decl_stmt|;
name|struct
name|drm_buf_entry
modifier|*
name|from
init|=
operator|&
name|dma
operator|->
name|bufs
index|[
name|i
index|]
decl_stmt|;
name|struct
name|drm_freelist
modifier|*
name|list
init|=
operator|&
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|freelist
decl_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|&
name|to
operator|->
name|count
argument_list|,
operator|&
name|from
operator|->
name|buf_count
argument_list|,
sizeof|sizeof
argument_list|(
name|from
operator|->
name|buf_count
argument_list|)
argument_list|)
operator|||
name|copy_to_user
argument_list|(
operator|&
name|to
operator|->
name|size
argument_list|,
operator|&
name|from
operator|->
name|buf_size
argument_list|,
sizeof|sizeof
argument_list|(
name|from
operator|->
name|buf_size
argument_list|)
argument_list|)
operator|||
name|copy_to_user
argument_list|(
operator|&
name|to
operator|->
name|low_mark
argument_list|,
operator|&
name|list
operator|->
name|low_mark
argument_list|,
sizeof|sizeof
argument_list|(
name|list
operator|->
name|low_mark
argument_list|)
argument_list|)
operator|||
name|copy_to_user
argument_list|(
operator|&
name|to
operator|->
name|high_mark
argument_list|,
operator|&
name|list
operator|->
name|high_mark
argument_list|,
sizeof|sizeof
argument_list|(
name|list
operator|->
name|high_mark
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
name|DRM_DEBUG
argument_list|(
literal|"%d %d %d %d %d\n"
argument_list|,
name|i
argument_list|,
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_count
argument_list|,
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_size
argument_list|,
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|freelist
operator|.
name|low_mark
argument_list|,
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|freelist
operator|.
name|high_mark
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
block|}
name|request
operator|->
name|count
operator|=
name|count
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Specifies a low and high water mark for buffer allocation  *  * \param inode device inode.  * \param file_priv DRM file private.  * \param cmd command.  * \param arg a pointer to a drm_buf_desc structure.  * \return zero on success or a negative number on failure.  *  * Verifies that the size order is bounded between the admissible orders and  * updates the respective drm_device_dma::bufs entry low and high water mark.  *  * \note This ioctl is deprecated and mostly never used.  */
end_comment

begin_function
name|int
name|drm_markbufs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|struct
name|drm_buf_desc
modifier|*
name|request
init|=
name|data
decl_stmt|;
name|int
name|order
decl_stmt|;
name|struct
name|drm_buf_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_HAVE_DMA
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|dma
condition|)
return|return
operator|-
name|EINVAL
return|;
name|DRM_DEBUG
argument_list|(
literal|"%d, %d, %d\n"
argument_list|,
name|request
operator|->
name|size
argument_list|,
name|request
operator|->
name|low_mark
argument_list|,
name|request
operator|->
name|high_mark
argument_list|)
expr_stmt|;
name|order
operator|=
name|drm_order
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
name|DRM_MIN_ORDER
operator|||
name|order
operator|>
name|DRM_MAX_ORDER
condition|)
return|return
operator|-
name|EINVAL
return|;
name|entry
operator|=
operator|&
name|dma
operator|->
name|bufs
index|[
name|order
index|]
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|low_mark
operator|<
literal|0
operator|||
name|request
operator|->
name|low_mark
operator|>
name|entry
operator|->
name|buf_count
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|request
operator|->
name|high_mark
operator|<
literal|0
operator|||
name|request
operator|->
name|high_mark
operator|>
name|entry
operator|->
name|buf_count
condition|)
return|return
operator|-
name|EINVAL
return|;
name|entry
operator|->
name|freelist
operator|.
name|low_mark
operator|=
name|request
operator|->
name|low_mark
expr_stmt|;
name|entry
operator|->
name|freelist
operator|.
name|high_mark
operator|=
name|request
operator|->
name|high_mark
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Unreserve the buffers in list, previously reserved using drmDMA.  *  * \param inode device inode.  * \param file_priv DRM file private.  * \param cmd command.  * \param arg pointer to a drm_buf_free structure.  * \return zero on success or a negative number on failure.  *  * Calls free_buffer() for each used buffer.  * This function is primarily used for debugging.  */
end_comment

begin_function
name|int
name|drm_freebufs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|struct
name|drm_buf_free
modifier|*
name|request
init|=
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|struct
name|drm_buf
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_HAVE_DMA
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|dma
condition|)
return|return
operator|-
name|EINVAL
return|;
name|DRM_DEBUG
argument_list|(
literal|"%d\n"
argument_list|,
name|request
operator|->
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|request
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|idx
argument_list|,
operator|&
name|request
operator|->
name|list
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Index %d (of %d max)\n"
argument_list|,
name|idx
argument_list|,
name|dma
operator|->
name|buf_count
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|file_priv
operator|!=
name|file_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Process %d freeing buffer not owned\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|drm_free_buffer
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Maps all of the DMA buffers into client-virtual space (ioctl).  *  * \param inode device inode.  * \param file_priv DRM file private.  * \param cmd command.  * \param arg pointer to a drm_buf_map structure.  * \return zero on success or a negative number on failure.  *  * Maps the AGP, SG or PCI buffer region with vm_mmap(), and copies information  * about each buffer into user space. For PCI buffers, it calls vm_mmap() with  * offset equal to 0, which drm_mmap() interpretes as PCI buffers and calls  * drm_mmap_dma().  */
end_comment

begin_function
name|int
name|drm_mapbufs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|zero
init|=
literal|0
decl_stmt|;
name|vm_offset_t
name|virtual
decl_stmt|;
name|vm_offset_t
name|address
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vms
decl_stmt|;
name|struct
name|drm_buf_map
modifier|*
name|request
init|=
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_HAVE_DMA
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|dma
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|dev
operator|->
name|buf_alloc
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
name|dev
operator|->
name|buf_use
operator|++
expr_stmt|;
comment|/* Can't allocate more after this call */
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
name|vms
operator|=
name|DRM_CURPROC
operator|->
name|td_proc
operator|->
name|p_vmspace
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|count
operator|>=
name|dma
operator|->
name|buf_count
condition|)
block|{
if|if
condition|(
operator|(
name|drm_core_has_AGP
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|dma
operator|->
name|flags
operator|&
name|_DRM_DMA_USE_AGP
operator|)
operator|)
operator|||
operator|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_SG
argument_list|)
operator|&&
operator|(
name|dma
operator|->
name|flags
operator|&
name|_DRM_DMA_USE_SG
operator|)
operator|)
operator|||
operator|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_FB_DMA
argument_list|)
operator|&&
operator|(
name|dma
operator|->
name|flags
operator|&
name|_DRM_DMA_USE_FB
operator|)
operator|)
condition|)
block|{
name|struct
name|drm_local_map
modifier|*
name|map
init|=
name|dev
operator|->
name|agp_buffer_map
decl_stmt|;
name|vm_ooffset_t
name|token
init|=
name|dev
operator|->
name|agp_buffer_token
decl_stmt|;
if|if
condition|(
operator|!
name|map
condition|)
block|{
name|retcode
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|retcode
operator|=
name|vm_mmap
argument_list|(
operator|&
name|vms
operator|->
name|vm_map
argument_list|,
operator|&
name|virtual
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_SHARED
operator||
name|MAP_NOSYNC
argument_list|,
name|OBJT_DEVICE
argument_list|,
name|file_priv
operator|->
name|minor
operator|->
name|device
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retcode
operator|=
name|vm_mmap
argument_list|(
operator|&
name|vms
operator|->
name|vm_map
argument_list|,
operator|&
name|virtual
argument_list|,
name|dma
operator|->
name|byte_count
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_SHARED
operator||
name|MAP_NOSYNC
argument_list|,
name|OBJT_DEVICE
argument_list|,
name|file_priv
operator|->
name|minor
operator|->
name|device
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retcode
condition|)
block|{
comment|/* Real error */
name|retcode
operator|=
operator|-
name|retcode
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|request
operator|->
name|virtual
operator|=
operator|(
name|void
name|__user
operator|*
operator|)
name|virtual
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dma
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|copy_to_user
argument_list|(
operator|&
name|request
operator|->
name|list
index|[
name|i
index|]
operator|.
name|idx
argument_list|,
operator|&
name|dma
operator|->
name|buflist
index|[
name|i
index|]
operator|->
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|request
operator|->
name|list
index|[
literal|0
index|]
operator|.
name|idx
argument_list|)
argument_list|)
condition|)
block|{
name|retcode
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|copy_to_user
argument_list|(
operator|&
name|request
operator|->
name|list
index|[
name|i
index|]
operator|.
name|total
argument_list|,
operator|&
name|dma
operator|->
name|buflist
index|[
name|i
index|]
operator|->
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|request
operator|->
name|list
index|[
literal|0
index|]
operator|.
name|total
argument_list|)
argument_list|)
condition|)
block|{
name|retcode
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|copy_to_user
argument_list|(
operator|&
name|request
operator|->
name|list
index|[
name|i
index|]
operator|.
name|used
argument_list|,
operator|&
name|zero
argument_list|,
sizeof|sizeof
argument_list|(
name|zero
argument_list|)
argument_list|)
condition|)
block|{
name|retcode
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|address
operator|=
name|virtual
operator|+
name|dma
operator|->
name|buflist
index|[
name|i
index|]
operator|->
name|offset
expr_stmt|;
comment|/* *** */
if|if
condition|(
name|copy_to_user
argument_list|(
operator|&
name|request
operator|->
name|list
index|[
name|i
index|]
operator|.
name|address
argument_list|,
operator|&
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|address
argument_list|)
argument_list|)
condition|)
block|{
name|retcode
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|done
label|:
name|request
operator|->
name|count
operator|=
name|dma
operator|->
name|buf_count
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%d buffers, retcode = %d\n"
argument_list|,
name|request
operator|->
name|count
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
return|return
name|retcode
return|;
block|}
end_function

begin_comment
comment|/**  * Compute size order.  Returns the exponent of the smaller power of two which  * is greater or equal to given number.  *  * \param size size.  * \return order.  *  * \todo Can be made faster.  */
end_comment

begin_function
name|int
name|drm_order
parameter_list|(
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|int
name|order
decl_stmt|;
name|unsigned
name|long
name|tmp
decl_stmt|;
for|for
control|(
name|order
operator|=
literal|0
operator|,
name|tmp
operator|=
name|size
operator|>>
literal|1
init|;
name|tmp
condition|;
name|tmp
operator|>>=
literal|1
operator|,
name|order
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|size
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
operator|++
name|order
expr_stmt|;
return|return
name|order
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_order
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

