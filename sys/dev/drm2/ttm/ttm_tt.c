begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  *  * Copyright (c) 2006-2009 VMware, Inc., Palo Alto, CA., USA  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the  * "Software"), to deal in the Software without restriction, including  * without limitation the rights to use, copy, modify, merge, publish,  * distribute, sub license, and/or sell copies of the Software, and to  * permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE  * USE OR OTHER DEALINGS IN THE SOFTWARE.  *  **************************************************************************/
end_comment

begin_comment
comment|/*  * Authors: Thomas Hellstrom<thellstrom-at-vmware-dot-com>  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Konstantin Belousov  *<kib@FreeBSD.org> under sponsorship from the FreeBSD Foundation.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_module.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_bo_driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_placement.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_page_alloc.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_TTM_PD
argument_list|,
literal|"ttm_pd"
argument_list|,
literal|"TTM Page Directories"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * Allocates storage for pointers to the pages that back the ttm.  */
end_comment

begin_function
specifier|static
name|void
name|ttm_tt_alloc_page_directory
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|)
block|{
name|ttm
operator|->
name|pages
operator|=
name|malloc
argument_list|(
name|ttm
operator|->
name|num_pages
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|M_TTM_PD
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttm_dma_tt_alloc_page_directory
parameter_list|(
name|struct
name|ttm_dma_tt
modifier|*
name|ttm
parameter_list|)
block|{
name|ttm
operator|->
name|ttm
operator|.
name|pages
operator|=
name|malloc
argument_list|(
name|ttm
operator|->
name|ttm
operator|.
name|num_pages
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|M_TTM_PD
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ttm
operator|->
name|dma_address
operator|=
name|malloc
argument_list|(
name|ttm
operator|->
name|ttm
operator|.
name|num_pages
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ttm
operator|->
name|dma_address
argument_list|)
argument_list|,
name|M_TTM_PD
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_function
specifier|static
specifier|inline
name|int
name|ttm_tt_set_page_caching
parameter_list|(
name|vm_page_t
name|p
parameter_list|,
name|enum
name|ttm_caching_state
name|c_old
parameter_list|,
name|enum
name|ttm_caching_state
name|c_new
parameter_list|)
block|{
comment|/* XXXKIB our VM does not need this. */
if|#
directive|if
literal|0
block|if (c_old != tt_cached) {
comment|/* p isn't in the default caching state, set it to 		 * writeback first to free its current memtype. */
block|pmap_page_set_memattr(p, VM_MEMATTR_WRITE_BACK); 	}
endif|#
directive|endif
if|if
condition|(
name|c_new
operator|==
name|tt_wc
condition|)
name|pmap_page_set_memattr
argument_list|(
name|p
argument_list|,
name|VM_MEMATTR_WRITE_COMBINING
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c_new
operator|==
name|tt_uncached
condition|)
name|pmap_page_set_memattr
argument_list|(
name|p
argument_list|,
name|VM_MEMATTR_UNCACHEABLE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
specifier|inline
name|int
name|ttm_tt_set_page_caching
parameter_list|(
name|vm_page_t
name|p
parameter_list|,
name|enum
name|ttm_caching_state
name|c_old
parameter_list|,
name|enum
name|ttm_caching_state
name|c_new
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Change caching policy for the linear kernel map  * for range of pages in a ttm.  */
end_comment

begin_function
specifier|static
name|int
name|ttm_tt_set_caching
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|,
name|enum
name|ttm_caching_state
name|c_state
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|vm_page_t
name|cur_page
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|ttm
operator|->
name|caching_state
operator|==
name|c_state
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ttm
operator|->
name|state
operator|==
name|tt_unpopulated
condition|)
block|{
comment|/* Change caching but don't populate */
name|ttm
operator|->
name|caching_state
operator|=
name|c_state
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ttm
operator|->
name|caching_state
operator|==
name|tt_cached
condition|)
name|drm_clflush_pages
argument_list|(
name|ttm
operator|->
name|pages
argument_list|,
name|ttm
operator|->
name|num_pages
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ttm
operator|->
name|num_pages
condition|;
operator|++
name|i
control|)
block|{
name|cur_page
operator|=
name|ttm
operator|->
name|pages
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|cur_page
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|ret
operator|=
name|ttm_tt_set_page_caching
argument_list|(
name|cur_page
argument_list|,
name|ttm
operator|->
name|caching_state
argument_list|,
name|c_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
condition|)
goto|goto
name|out_err
goto|;
block|}
block|}
name|ttm
operator|->
name|caching_state
operator|=
name|c_state
expr_stmt|;
return|return
literal|0
return|;
name|out_err
label|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
block|{
name|cur_page
operator|=
name|ttm
operator|->
name|pages
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|cur_page
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ttm_tt_set_page_caching
argument_list|(
name|cur_page
argument_list|,
name|c_state
argument_list|,
name|ttm
operator|->
name|caching_state
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ttm_tt_set_placement_caching
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|,
name|uint32_t
name|placement
parameter_list|)
block|{
name|enum
name|ttm_caching_state
name|state
decl_stmt|;
if|if
condition|(
name|placement
operator|&
name|TTM_PL_FLAG_WC
condition|)
name|state
operator|=
name|tt_wc
expr_stmt|;
elseif|else
if|if
condition|(
name|placement
operator|&
name|TTM_PL_FLAG_UNCACHED
condition|)
name|state
operator|=
name|tt_uncached
expr_stmt|;
else|else
name|state
operator|=
name|tt_cached
expr_stmt|;
return|return
name|ttm_tt_set_caching
argument_list|(
name|ttm
argument_list|,
name|state
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ttm_tt_destroy
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|ttm
operator|==
name|NULL
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ttm
operator|->
name|state
operator|==
name|tt_bound
condition|)
block|{
name|ttm_tt_unbind
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|likely
argument_list|(
name|ttm
operator|->
name|pages
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|ttm
operator|->
name|bdev
operator|->
name|driver
operator|->
name|ttm_tt_unpopulate
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ttm
operator|->
name|page_flags
operator|&
name|TTM_PAGE_FLAG_PERSISTENT_SWAP
operator|)
operator|&&
name|ttm
operator|->
name|swap_storage
condition|)
name|vm_object_deallocate
argument_list|(
name|ttm
operator|->
name|swap_storage
argument_list|)
expr_stmt|;
name|ttm
operator|->
name|swap_storage
operator|=
name|NULL
expr_stmt|;
name|ttm
operator|->
name|func
operator|->
name|destroy
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ttm_tt_init
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|,
name|struct
name|ttm_bo_device
modifier|*
name|bdev
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|uint32_t
name|page_flags
parameter_list|,
name|vm_page_t
name|dummy_read_page
parameter_list|)
block|{
name|ttm
operator|->
name|bdev
operator|=
name|bdev
expr_stmt|;
name|ttm
operator|->
name|glob
operator|=
name|bdev
operator|->
name|glob
expr_stmt|;
name|ttm
operator|->
name|num_pages
operator|=
operator|(
name|size
operator|+
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|ttm
operator|->
name|caching_state
operator|=
name|tt_cached
expr_stmt|;
name|ttm
operator|->
name|page_flags
operator|=
name|page_flags
expr_stmt|;
name|ttm
operator|->
name|dummy_read_page
operator|=
name|dummy_read_page
expr_stmt|;
name|ttm
operator|->
name|state
operator|=
name|tt_unpopulated
expr_stmt|;
name|ttm
operator|->
name|swap_storage
operator|=
name|NULL
expr_stmt|;
name|ttm_tt_alloc_page_directory
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ttm
operator|->
name|pages
condition|)
block|{
name|ttm_tt_destroy
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Failed allocating page table\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ttm_tt_fini
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|)
block|{
name|free
argument_list|(
name|ttm
operator|->
name|pages
argument_list|,
name|M_TTM_PD
argument_list|)
expr_stmt|;
name|ttm
operator|->
name|pages
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ttm_dma_tt_init
parameter_list|(
name|struct
name|ttm_dma_tt
modifier|*
name|ttm_dma
parameter_list|,
name|struct
name|ttm_bo_device
modifier|*
name|bdev
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|uint32_t
name|page_flags
parameter_list|,
name|vm_page_t
name|dummy_read_page
parameter_list|)
block|{
name|struct
name|ttm_tt
modifier|*
name|ttm
init|=
operator|&
name|ttm_dma
operator|->
name|ttm
decl_stmt|;
name|ttm
operator|->
name|bdev
operator|=
name|bdev
expr_stmt|;
name|ttm
operator|->
name|glob
operator|=
name|bdev
operator|->
name|glob
expr_stmt|;
name|ttm
operator|->
name|num_pages
operator|=
operator|(
name|size
operator|+
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|ttm
operator|->
name|caching_state
operator|=
name|tt_cached
expr_stmt|;
name|ttm
operator|->
name|page_flags
operator|=
name|page_flags
expr_stmt|;
name|ttm
operator|->
name|dummy_read_page
operator|=
name|dummy_read_page
expr_stmt|;
name|ttm
operator|->
name|state
operator|=
name|tt_unpopulated
expr_stmt|;
name|ttm
operator|->
name|swap_storage
operator|=
name|NULL
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ttm_dma
operator|->
name|pages_list
argument_list|)
expr_stmt|;
name|ttm_dma_tt_alloc_page_directory
argument_list|(
name|ttm_dma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ttm
operator|->
name|pages
operator|||
operator|!
name|ttm_dma
operator|->
name|dma_address
condition|)
block|{
name|ttm_tt_destroy
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Failed allocating page table\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ttm_dma_tt_fini
parameter_list|(
name|struct
name|ttm_dma_tt
modifier|*
name|ttm_dma
parameter_list|)
block|{
name|struct
name|ttm_tt
modifier|*
name|ttm
init|=
operator|&
name|ttm_dma
operator|->
name|ttm
decl_stmt|;
name|free
argument_list|(
name|ttm
operator|->
name|pages
argument_list|,
name|M_TTM_PD
argument_list|)
expr_stmt|;
name|ttm
operator|->
name|pages
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|ttm_dma
operator|->
name|dma_address
argument_list|,
name|M_TTM_PD
argument_list|)
expr_stmt|;
name|ttm_dma
operator|->
name|dma_address
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ttm_tt_unbind
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|ttm
operator|->
name|state
operator|==
name|tt_bound
condition|)
block|{
name|ret
operator|=
name|ttm
operator|->
name|func
operator|->
name|unbind
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ret
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ttm
operator|->
name|state
operator|=
name|tt_unbound
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ttm_tt_bind
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|,
name|struct
name|ttm_mem_reg
modifier|*
name|bo_mem
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ttm
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|ttm
operator|->
name|state
operator|==
name|tt_bound
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|ttm
operator|->
name|bdev
operator|->
name|driver
operator|->
name|ttm_tt_populate
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|ttm
operator|->
name|func
operator|->
name|bind
argument_list|(
name|ttm
argument_list|,
name|bo_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
condition|)
return|return
name|ret
return|;
name|ttm
operator|->
name|state
operator|=
name|tt_bound
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ttm_tt_swapin
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|vm_page_t
name|from_page
decl_stmt|,
name|to_page
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|,
name|rv
decl_stmt|;
name|obj
operator|=
name|ttm
operator|->
name|swap_storage
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|vm_object_pip_add
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ttm
operator|->
name|num_pages
condition|;
operator|++
name|i
control|)
block|{
name|from_page
operator|=
name|vm_page_grab
argument_list|(
name|obj
argument_list|,
name|i
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_page
operator|->
name|valid
operator|!=
name|VM_PAGE_BITS_ALL
condition|)
block|{
if|if
condition|(
name|vm_pager_has_page
argument_list|(
name|obj
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|rv
operator|=
name|vm_pager_get_pages
argument_list|(
name|obj
argument_list|,
operator|&
name|from_page
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|VM_PAGER_OK
condition|)
block|{
name|vm_page_lock
argument_list|(
name|from_page
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|from_page
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|from_page
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EIO
expr_stmt|;
goto|goto
name|err_ret
goto|;
block|}
block|}
else|else
name|vm_page_zero_invalid
argument_list|(
name|from_page
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|vm_page_xunbusy
argument_list|(
name|from_page
argument_list|)
expr_stmt|;
name|to_page
operator|=
name|ttm
operator|->
name|pages
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|to_page
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_ret
goto|;
block|}
name|pmap_copy_page
argument_list|(
name|from_page
argument_list|,
name|to_page
argument_list|)
expr_stmt|;
block|}
name|vm_object_pip_wakeup
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ttm
operator|->
name|page_flags
operator|&
name|TTM_PAGE_FLAG_PERSISTENT_SWAP
operator|)
condition|)
name|vm_object_deallocate
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|ttm
operator|->
name|swap_storage
operator|=
name|NULL
expr_stmt|;
name|ttm
operator|->
name|page_flags
operator|&=
operator|~
name|TTM_PAGE_FLAG_SWAPPED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_ret
label|:
name|vm_object_pip_wakeup
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ttm_tt_swapout
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|,
name|vm_object_t
name|persistent_swap_storage
parameter_list|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|vm_page_t
name|from_page
decl_stmt|,
name|to_page
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MPASS
argument_list|(
name|ttm
operator|->
name|state
operator|==
name|tt_unbound
operator|||
name|ttm
operator|->
name|state
operator|==
name|tt_unpopulated
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ttm
operator|->
name|caching_state
operator|==
name|tt_cached
argument_list|)
expr_stmt|;
if|if
condition|(
name|persistent_swap_storage
operator|==
name|NULL
condition|)
block|{
name|obj
operator|=
name|vm_pager_allocate
argument_list|(
name|OBJT_SWAP
argument_list|,
name|NULL
argument_list|,
name|IDX_TO_OFF
argument_list|(
name|ttm
operator|->
name|num_pages
argument_list|)
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
literal|0
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"[TTM] Failed allocating swap storage\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
block|}
else|else
name|obj
operator|=
name|persistent_swap_storage
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|vm_object_pip_add
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ttm
operator|->
name|num_pages
condition|;
operator|++
name|i
control|)
block|{
name|from_page
operator|=
name|ttm
operator|->
name|pages
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|from_page
operator|==
name|NULL
argument_list|)
condition|)
continue|continue;
name|to_page
operator|=
name|vm_page_grab
argument_list|(
name|obj
argument_list|,
name|i
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
name|pmap_copy_page
argument_list|(
name|from_page
argument_list|,
name|to_page
argument_list|)
expr_stmt|;
name|to_page
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|to_page
argument_list|)
expr_stmt|;
name|vm_page_xunbusy
argument_list|(
name|to_page
argument_list|)
expr_stmt|;
block|}
name|vm_object_pip_wakeup
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|ttm
operator|->
name|bdev
operator|->
name|driver
operator|->
name|ttm_tt_unpopulate
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
name|ttm
operator|->
name|swap_storage
operator|=
name|obj
expr_stmt|;
name|ttm
operator|->
name|page_flags
operator||=
name|TTM_PAGE_FLAG_SWAPPED
expr_stmt|;
if|if
condition|(
name|persistent_swap_storage
operator|!=
name|NULL
condition|)
name|ttm
operator|->
name|page_flags
operator||=
name|TTM_PAGE_FLAG_PERSISTENT_SWAP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

