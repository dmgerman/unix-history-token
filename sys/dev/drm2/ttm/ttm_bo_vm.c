begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  *  * Copyright (c) 2006-2009 VMware, Inc., Palo Alto, CA., USA  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the  * "Software"), to deal in the Software without restriction, including  * without limitation the rights to use, copy, modify, merge, publish,  * distribute, sub license, and/or sell copies of the Software, and to  * permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE  * USE OR OTHER DEALINGS IN THE SOFTWARE.  *  **************************************************************************/
end_comment

begin_comment
comment|/*  * Authors: Thomas Hellstrom<thellstrom-at-vmware-dot-com>  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Konstantin Belousov  *<kib@FreeBSD.org> under sponsorship from the FreeBSD Foundation.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_vm.h"
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_module.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_bo_driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_placement.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_define
define|#
directive|define
name|TTM_BO_VM_NUM_PREFAULT
value|16
end_define

begin_expr_stmt
name|RB_GENERATE
argument_list|(
name|ttm_bo_device_buffer_objects
argument_list|,
name|ttm_buffer_object
argument_list|,
name|vm_rb
argument_list|,
name|ttm_bo_cmp_rb_tree_items
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|ttm_bo_cmp_rb_tree_items
parameter_list|(
name|struct
name|ttm_buffer_object
modifier|*
name|a
parameter_list|,
name|struct
name|ttm_buffer_object
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|vm_node
operator|->
name|start
operator|<
name|b
operator|->
name|vm_node
operator|->
name|start
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|vm_node
operator|->
name|start
operator|>
name|b
operator|->
name|vm_node
operator|->
name|start
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|ttm_buffer_object
modifier|*
name|ttm_bo_vm_lookup_rb
parameter_list|(
name|struct
name|ttm_bo_device
modifier|*
name|bdev
parameter_list|,
name|unsigned
name|long
name|page_start
parameter_list|,
name|unsigned
name|long
name|num_pages
parameter_list|)
block|{
name|unsigned
name|long
name|cur_offset
decl_stmt|;
name|struct
name|ttm_buffer_object
modifier|*
name|bo
decl_stmt|;
name|struct
name|ttm_buffer_object
modifier|*
name|best_bo
init|=
name|NULL
decl_stmt|;
name|bo
operator|=
name|RB_ROOT
argument_list|(
operator|&
name|bdev
operator|->
name|addr_space_rb
argument_list|)
expr_stmt|;
while|while
condition|(
name|bo
operator|!=
name|NULL
condition|)
block|{
name|cur_offset
operator|=
name|bo
operator|->
name|vm_node
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|page_start
operator|>=
name|cur_offset
condition|)
block|{
name|best_bo
operator|=
name|bo
expr_stmt|;
if|if
condition|(
name|page_start
operator|==
name|cur_offset
condition|)
break|break;
name|bo
operator|=
name|RB_RIGHT
argument_list|(
name|bo
argument_list|,
name|vm_rb
argument_list|)
expr_stmt|;
block|}
else|else
name|bo
operator|=
name|RB_LEFT
argument_list|(
name|bo
argument_list|,
name|vm_rb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|best_bo
operator|==
name|NULL
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|best_bo
operator|->
name|vm_node
operator|->
name|start
operator|+
name|best_bo
operator|->
name|num_pages
operator|)
operator|<
operator|(
name|page_start
operator|+
name|num_pages
operator|)
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|best_bo
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttm_bo_vm_fault
parameter_list|(
name|vm_object_t
name|vm_obj
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|int
name|prot
parameter_list|,
name|vm_page_t
modifier|*
name|mres
parameter_list|)
block|{
name|struct
name|ttm_buffer_object
modifier|*
name|bo
init|=
name|vm_obj
operator|->
name|handle
decl_stmt|;
name|struct
name|ttm_bo_device
modifier|*
name|bdev
init|=
name|bo
operator|->
name|bdev
decl_stmt|;
name|struct
name|ttm_tt
modifier|*
name|ttm
init|=
name|NULL
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|m1
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|retval
init|=
name|VM_PAGER_OK
decl_stmt|;
name|struct
name|ttm_mem_type_manager
modifier|*
name|man
init|=
operator|&
name|bdev
operator|->
name|man
index|[
name|bo
operator|->
name|mem
operator|.
name|mem_type
index|]
decl_stmt|;
name|vm_object_pip_add
argument_list|(
name|vm_obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mres
operator|!=
name|NULL
condition|)
block|{
name|vm_page_lock
argument_list|(
operator|*
name|mres
argument_list|)
expr_stmt|;
name|vm_page_remove
argument_list|(
operator|*
name|mres
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
operator|*
name|mres
argument_list|)
expr_stmt|;
block|}
name|retry
label|:
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|reserve
label|:
name|ret
operator|=
name|ttm_bo_reserve
argument_list|(
name|bo
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
operator|-
name|EBUSY
condition|)
block|{
name|kern_yield
argument_list|(
name|PRI_USER
argument_list|)
expr_stmt|;
goto|goto
name|reserve
goto|;
block|}
block|}
if|if
condition|(
name|bdev
operator|->
name|driver
operator|->
name|fault_reserve_notify
condition|)
block|{
name|ret
operator|=
name|bdev
operator|->
name|driver
operator|->
name|fault_reserve_notify
argument_list|(
name|bo
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
operator|-
name|EBUSY
case|:
case|case
operator|-
name|ERESTARTSYS
case|:
case|case
operator|-
name|EINTR
case|:
name|kern_yield
argument_list|(
name|PRI_USER
argument_list|)
expr_stmt|;
goto|goto
name|reserve
goto|;
default|default:
name|retval
operator|=
name|VM_PAGER_ERROR
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
block|}
comment|/* 	 * Wait for buffer data in transit, due to a pipelined 	 * move. 	 */
name|mtx_lock
argument_list|(
operator|&
name|bdev
operator|->
name|fence_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_bit
argument_list|(
name|TTM_BO_PRIV_FLAG_MOVING
argument_list|,
operator|&
name|bo
operator|->
name|priv_flags
argument_list|)
condition|)
block|{
comment|/* 		 * Here, the behavior differs between Linux and FreeBSD. 		 * 		 * On Linux, the wait is interruptible (3rd argument to 		 * ttm_bo_wait). There must be some mechanism to resume 		 * page fault handling, once the signal is processed. 		 * 		 * On FreeBSD, the wait is uninteruptible. This is not a 		 * problem as we can't end up with an unkillable process 		 * here, because the wait will eventually time out. 		 * 		 * An example of this situation is the Xorg process 		 * which uses SIGALRM internally. The signal could 		 * interrupt the wait, causing the page fault to fail 		 * and the process to receive SIGSEGV. 		 */
name|ret
operator|=
name|ttm_bo_wait
argument_list|(
name|bo
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bdev
operator|->
name|fence_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|retval
operator|=
name|VM_PAGER_ERROR
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|bdev
operator|->
name|fence_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ttm_mem_io_lock
argument_list|(
name|man
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|retval
operator|=
name|VM_PAGER_ERROR
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|ret
operator|=
name|ttm_mem_io_reserve_vm
argument_list|(
name|bo
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|retval
operator|=
name|VM_PAGER_ERROR
expr_stmt|;
goto|goto
name|out_io_unlock
goto|;
block|}
comment|/* 	 * Strictly, we're not allowed to modify vma->vm_page_prot here, 	 * since the mmap_sem is only held in read mode. However, we 	 * modify only the caching bits of vma->vm_page_prot and 	 * consider those bits protected by 	 * the bo->mutex, as we should be the only writers. 	 * There shouldn't really be any readers of these bits except 	 * within vm_insert_mixed()? fork? 	 * 	 * TODO: Add a list of vmas to the bo, and change the 	 * vma->vm_page_prot when the object changes caching policy, with 	 * the correct locks held. 	 */
if|if
condition|(
operator|!
name|bo
operator|->
name|mem
operator|.
name|bus
operator|.
name|is_iomem
condition|)
block|{
comment|/* Allocate all page at once, most common usage */
name|ttm
operator|=
name|bo
operator|->
name|ttm
expr_stmt|;
if|if
condition|(
name|ttm
operator|->
name|bdev
operator|->
name|driver
operator|->
name|ttm_tt_populate
argument_list|(
name|ttm
argument_list|)
condition|)
block|{
name|retval
operator|=
name|VM_PAGER_ERROR
expr_stmt|;
goto|goto
name|out_io_unlock
goto|;
block|}
block|}
if|if
condition|(
name|bo
operator|->
name|mem
operator|.
name|bus
operator|.
name|is_iomem
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|bo
operator|->
name|mem
operator|.
name|bus
operator|.
name|base
operator|+
name|bo
operator|->
name|mem
operator|.
name|bus
operator|.
name|offset
operator|+
name|offset
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"physical address %#jx not fictitious"
operator|,
call|(
name|uintmax_t
call|)
argument_list|(
name|bo
operator|->
name|mem
operator|.
name|bus
operator|.
name|base
operator|+
name|bo
operator|->
name|mem
operator|.
name|bus
operator|.
name|offset
operator|+
name|offset
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|pmap_page_set_memattr
argument_list|(
name|m
argument_list|,
name|ttm_io_prot
argument_list|(
name|bo
operator|->
name|mem
operator|.
name|placement
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ttm
operator|=
name|bo
operator|->
name|ttm
expr_stmt|;
name|m
operator|=
name|ttm
operator|->
name|pages
index|[
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|m
argument_list|)
condition|)
block|{
name|retval
operator|=
name|VM_PAGER_ERROR
expr_stmt|;
goto|goto
name|out_io_unlock
goto|;
block|}
name|pmap_page_set_memattr
argument_list|(
name|m
argument_list|,
operator|(
name|bo
operator|->
name|mem
operator|.
name|placement
operator|&
name|TTM_PL_FLAG_CACHED
operator|)
condition|?
name|VM_MEMATTR_WRITE_BACK
else|:
name|ttm_io_prot
argument_list|(
name|bo
operator|->
name|mem
operator|.
name|placement
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_page_busied
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|vm_page_busy_sleep
argument_list|(
name|m
argument_list|,
literal|"ttmpbs"
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|ttm_mem_io_unlock
argument_list|(
name|man
argument_list|)
expr_stmt|;
name|ttm_bo_unreserve
argument_list|(
name|bo
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|m1
operator|=
name|vm_page_lookup
argument_list|(
name|vm_obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|vm_page_insert
argument_list|(
name|m
argument_list|,
name|vm_obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
argument_list|)
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|VM_WAIT
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|ttm_mem_io_unlock
argument_list|(
name|man
argument_list|)
expr_stmt|;
name|ttm_bo_unreserve
argument_list|(
name|bo
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|m
operator|==
name|m1
argument_list|,
operator|(
literal|"inconsistent insert bo %p m %p m1 %p offset %jx"
operator|,
name|bo
operator|,
name|m
operator|,
name|m1
operator|,
operator|(
name|uintmax_t
operator|)
name|offset
operator|)
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|vm_page_xbusy
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mres
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|*
name|mres
operator|!=
name|m
argument_list|,
operator|(
literal|"losing %p %p"
operator|,
operator|*
name|mres
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
operator|*
name|mres
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
operator|*
name|mres
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
operator|*
name|mres
argument_list|)
expr_stmt|;
block|}
operator|*
name|mres
operator|=
name|m
expr_stmt|;
name|out_io_unlock1
label|:
name|ttm_mem_io_unlock
argument_list|(
name|man
argument_list|)
expr_stmt|;
name|out_unlock1
label|:
name|ttm_bo_unreserve
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|vm_object_pip_wakeup
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
name|out_io_unlock
label|:
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
goto|goto
name|out_io_unlock1
goto|;
name|out_unlock
label|:
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock1
goto|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttm_bo_vm_ctor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_ooffset_t
name|foff
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|u_short
modifier|*
name|color
parameter_list|)
block|{
comment|/* 	 * On Linux, a reference to the buffer object is acquired here. 	 * The reason is that this function is not called when the 	 * mmap() is initialized, but only when a process forks for 	 * instance. Therefore on Linux, the reference on the bo is 	 * acquired either in ttm_bo_mmap() or ttm_bo_vm_open(). It's 	 * then released in ttm_bo_vm_close(). 	 * 	 * Here, this function is called during mmap() initialization. 	 * Thus, the reference acquired in ttm_bo_mmap_single() is 	 * sufficient. 	 */
operator|*
name|color
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttm_bo_vm_dtor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|ttm_buffer_object
modifier|*
name|bo
init|=
name|handle
decl_stmt|;
name|ttm_bo_unref
argument_list|(
operator|&
name|bo
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdev_pager_ops
name|ttm_pager_ops
init|=
block|{
operator|.
name|cdev_pg_fault
operator|=
name|ttm_bo_vm_fault
block|,
operator|.
name|cdev_pg_ctor
operator|=
name|ttm_bo_vm_ctor
block|,
operator|.
name|cdev_pg_dtor
operator|=
name|ttm_bo_vm_dtor
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ttm_bo_mmap_single
parameter_list|(
name|struct
name|ttm_bo_device
modifier|*
name|bdev
parameter_list|,
name|vm_ooffset_t
modifier|*
name|offset
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|struct
name|vm_object
modifier|*
modifier|*
name|obj_res
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|struct
name|ttm_bo_driver
modifier|*
name|driver
decl_stmt|;
name|struct
name|ttm_buffer_object
modifier|*
name|bo
decl_stmt|;
name|struct
name|vm_object
modifier|*
name|vm_obj
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|bdev
operator|->
name|vm_lock
argument_list|)
expr_stmt|;
name|bo
operator|=
name|ttm_bo_vm_lookup_rb
argument_list|(
name|bdev
argument_list|,
name|OFF_TO_IDX
argument_list|(
operator|*
name|offset
argument_list|)
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|bo
operator|!=
name|NULL
argument_list|)
condition|)
name|refcount_acquire
argument_list|(
operator|&
name|bo
operator|->
name|kref
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|bdev
operator|->
name|vm_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|bo
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"[TTM] Could not find buffer object to map\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
name|driver
operator|=
name|bo
operator|->
name|bdev
operator|->
name|driver
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|driver
operator|->
name|verify_access
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EPERM
expr_stmt|;
goto|goto
name|out_unref
goto|;
block|}
name|ret
operator|=
name|driver
operator|->
name|verify_access
argument_list|(
name|bo
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
condition|)
goto|goto
name|out_unref
goto|;
name|vm_obj
operator|=
name|cdev_pager_allocate
argument_list|(
name|bo
argument_list|,
name|OBJT_MGTDEVICE
argument_list|,
operator|&
name|ttm_pager_ops
argument_list|,
name|size
argument_list|,
name|nprot
argument_list|,
literal|0
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_obj
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out_unref
goto|;
block|}
comment|/* 	 * Note: We're transferring the bo reference to vm_obj->handle here. 	 */
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
operator|*
name|obj_res
operator|=
name|vm_obj
expr_stmt|;
return|return
literal|0
return|;
name|out_unref
label|:
name|ttm_bo_unref
argument_list|(
operator|&
name|bo
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|ttm_bo_release_mmap
parameter_list|(
name|struct
name|ttm_buffer_object
modifier|*
name|bo
parameter_list|)
block|{
name|vm_object_t
name|vm_obj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vm_obj
operator|=
name|cdev_pager_lookup
argument_list|(
name|bo
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_obj
operator|==
name|NULL
condition|)
return|return;
name|VM_OBJECT_WLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|retry
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bo
operator|->
name|num_pages
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|vm_obj
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|vm_page_sleep_if_busy
argument_list|(
name|m
argument_list|,
literal|"ttm_unm"
argument_list|)
condition|)
goto|goto
name|retry
goto|;
name|cdev_pager_free_page
argument_list|(
name|vm_obj
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|vm_obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|int ttm_fbdev_mmap(struct vm_area_struct *vma, struct ttm_buffer_object *bo) { 	if (vma->vm_pgoff != 0) 		return -EACCES;  	vma->vm_ops =&ttm_bo_vm_ops; 	vma->vm_private_data = ttm_bo_reference(bo); 	vma->vm_flags |= VM_IO | VM_MIXEDMAP | VM_DONTEXPAND; 	return 0; }  ssize_t ttm_bo_io(struct ttm_bo_device *bdev, struct file *filp, 		  const char __user *wbuf, char __user *rbuf, size_t count, 		  loff_t *f_pos, bool write) { 	struct ttm_buffer_object *bo; 	struct ttm_bo_driver *driver; 	struct ttm_bo_kmap_obj map; 	unsigned long dev_offset = (*f_pos>> PAGE_SHIFT); 	unsigned long kmap_offset; 	unsigned long kmap_end; 	unsigned long kmap_num; 	size_t io_size; 	unsigned int page_offset; 	char *virtual; 	int ret; 	bool no_wait = false; 	bool dummy;  	read_lock(&bdev->vm_lock); 	bo = ttm_bo_vm_lookup_rb(bdev, dev_offset, 1); 	if (likely(bo != NULL)) 		ttm_bo_reference(bo); 	read_unlock(&bdev->vm_lock);  	if (unlikely(bo == NULL)) 		return -EFAULT;  	driver = bo->bdev->driver; 	if (unlikely(!driver->verify_access)) { 		ret = -EPERM; 		goto out_unref; 	}  	ret = driver->verify_access(bo, filp); 	if (unlikely(ret != 0)) 		goto out_unref;  	kmap_offset = dev_offset - bo->vm_node->start; 	if (unlikely(kmap_offset>= bo->num_pages)) { 		ret = -EFBIG; 		goto out_unref; 	}  	page_offset = *f_pos& ~PAGE_MASK; 	io_size = bo->num_pages - kmap_offset; 	io_size = (io_size<< PAGE_SHIFT) - page_offset; 	if (count< io_size) 		io_size = count;  	kmap_end = (*f_pos + count - 1)>> PAGE_SHIFT; 	kmap_num = kmap_end - kmap_offset + 1;  	ret = ttm_bo_reserve(bo, true, no_wait, false, 0);  	switch (ret) { 	case 0: 		break; 	case -EBUSY: 		ret = -EAGAIN; 		goto out_unref; 	default: 		goto out_unref; 	}  	ret = ttm_bo_kmap(bo, kmap_offset, kmap_num,&map); 	if (unlikely(ret != 0)) { 		ttm_bo_unreserve(bo); 		goto out_unref; 	}  	virtual = ttm_kmap_obj_virtual(&map,&dummy); 	virtual += page_offset;  	if (write) 		ret = copy_from_user(virtual, wbuf, io_size); 	else 		ret = copy_to_user(rbuf, virtual, io_size);  	ttm_bo_kunmap(&map); 	ttm_bo_unreserve(bo); 	ttm_bo_unref(&bo);  	if (unlikely(ret != 0)) 		return -EFBIG;  	*f_pos += io_size;  	return io_size; out_unref: 	ttm_bo_unref(&bo); 	return ret; }  ssize_t ttm_bo_fbdev_io(struct ttm_buffer_object *bo, const char __user *wbuf, 			char __user *rbuf, size_t count, loff_t *f_pos, 			bool write) { 	struct ttm_bo_kmap_obj map; 	unsigned long kmap_offset; 	unsigned long kmap_end; 	unsigned long kmap_num; 	size_t io_size; 	unsigned int page_offset; 	char *virtual; 	int ret; 	bool no_wait = false; 	bool dummy;  	kmap_offset = (*f_pos>> PAGE_SHIFT); 	if (unlikely(kmap_offset>= bo->num_pages)) 		return -EFBIG;  	page_offset = *f_pos& ~PAGE_MASK; 	io_size = bo->num_pages - kmap_offset; 	io_size = (io_size<< PAGE_SHIFT) - page_offset; 	if (count< io_size) 		io_size = count;  	kmap_end = (*f_pos + count - 1)>> PAGE_SHIFT; 	kmap_num = kmap_end - kmap_offset + 1;  	ret = ttm_bo_reserve(bo, true, no_wait, false, 0);  	switch (ret) { 	case 0: 		break; 	case -EBUSY: 		return -EAGAIN; 	default: 		return ret; 	}  	ret = ttm_bo_kmap(bo, kmap_offset, kmap_num,&map); 	if (unlikely(ret != 0)) { 		ttm_bo_unreserve(bo); 		return ret; 	}  	virtual = ttm_kmap_obj_virtual(&map,&dummy); 	virtual += page_offset;  	if (write) 		ret = copy_from_user(virtual, wbuf, io_size); 	else 		ret = copy_to_user(rbuf, virtual, io_size);  	ttm_bo_kunmap(&map); 	ttm_bo_unreserve(bo); 	ttm_bo_unref(&bo);  	if (unlikely(ret != 0)) 		return ret;  	*f_pos += io_size;  	return io_size; }
endif|#
directive|endif
end_endif

end_unit

