begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  *  * Copyright (c) 2006-2009 VMware, Inc., Palo Alto, CA., USA  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the  * "Software"), to deal in the Software without restriction, including  * without limitation the rights to use, copy, modify, merge, publish,  * distribute, sub license, and/or sell copies of the Software, and to  * permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE  * USE OR OTHER DEALINGS IN THE SOFTWARE.  *  **************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_memory.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_module.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_page_alloc.h>
end_include

begin_define
define|#
directive|define
name|TTM_MEMORY_ALLOC_RETRIES
value|4
end_define

begin_struct
struct|struct
name|ttm_mem_zone
block|{
name|u_int
name|kobj_ref
decl_stmt|;
name|struct
name|ttm_mem_global
modifier|*
name|glob
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint64_t
name|zone_mem
decl_stmt|;
name|uint64_t
name|emer_mem
decl_stmt|;
name|uint64_t
name|max_mem
decl_stmt|;
name|uint64_t
name|swap_limit
decl_stmt|;
name|uint64_t
name|used_mem
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_TTM_ZONE
argument_list|,
literal|"ttm_zone"
argument_list|,
literal|"TTM Zone"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|ttm_mem_zone_kobj_release
parameter_list|(
name|struct
name|ttm_mem_zone
modifier|*
name|zone
parameter_list|)
block|{
name|printf
argument_list|(
literal|"pTTM] Zone %7s: Used memory at exit: %llu kiB\n"
argument_list|,
name|zone
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|zone
operator|->
name|used_mem
operator|>>
literal|10
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zone
argument_list|,
name|M_TTM_ZONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXXKIB sysctl */
end_comment

begin_endif
unit|static ssize_t ttm_mem_zone_show(struct ttm_mem_zone *zone; 				 struct attribute *attr, 				 char *buffer) { 	uint64_t val = 0;  	mtx_lock(&zone->glob->lock); 	if (attr ==&ttm_mem_sys) 		val = zone->zone_mem; 	else if (attr ==&ttm_mem_emer) 		val = zone->emer_mem; 	else if (attr ==&ttm_mem_max) 		val = zone->max_mem; 	else if (attr ==&ttm_mem_swap) 		val = zone->swap_limit; 	else if (attr ==&ttm_mem_used) 		val = zone->used_mem; 	mtx_unlock(&zone->glob->lock);  	return snprintf(buffer, PAGE_SIZE, "%llu\n", 			(unsigned long long) val>> 10); }
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ttm_check_swapping
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXXKIB sysctl */
end_comment

begin_endif
unit|static ssize_t ttm_mem_zone_store(struct ttm_mem_zone *zone, 				  struct attribute *attr, 				  const char *buffer, 				  size_t size) { 	int chars; 	unsigned long val; 	uint64_t val64;  	chars = sscanf(buffer, "%lu",&val); 	if (chars == 0) 		return size;  	val64 = val; 	val64<<= 10;  	mtx_lock(&zone->glob->lock); 	if (val64> zone->zone_mem) 		val64 = zone->zone_mem; 	if (attr ==&ttm_mem_emer) { 		zone->emer_mem = val64; 		if (zone->max_mem> val64) 			zone->max_mem = val64; 	} else if (attr ==&ttm_mem_max) { 		zone->max_mem = val64; 		if (zone->emer_mem< val64) 			zone->emer_mem = val64; 	} else if (attr ==&ttm_mem_swap) 		zone->swap_limit = val64; 	mtx_unlock(&zone->glob->lock);  	ttm_check_swapping(zone->glob);  	return size; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ttm_mem_global_kobj_release
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|)
block|{
name|free
argument_list|(
name|glob
argument_list|,
name|M_TTM_ZONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ttm_zones_above_swap_target
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|,
name|bool
name|from_wq
parameter_list|,
name|uint64_t
name|extra
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|ttm_mem_zone
modifier|*
name|zone
decl_stmt|;
name|uint64_t
name|target
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|glob
operator|->
name|num_zones
condition|;
operator|++
name|i
control|)
block|{
name|zone
operator|=
name|glob
operator|->
name|zones
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|from_wq
condition|)
name|target
operator|=
name|zone
operator|->
name|swap_limit
expr_stmt|;
elseif|else
if|if
condition|(
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_VM_MLOCK
argument_list|)
operator|==
literal|0
condition|)
name|target
operator|=
name|zone
operator|->
name|emer_mem
expr_stmt|;
else|else
name|target
operator|=
name|zone
operator|->
name|max_mem
expr_stmt|;
name|target
operator|=
operator|(
name|extra
operator|>
name|target
operator|)
condition|?
literal|0ULL
else|:
name|target
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|used_mem
operator|>
name|target
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/**  * At this point we only support a single shrink callback.  * Extend this if needed, perhaps using a linked list of callbacks.  * Note that this function is reentrant:  * many threads may try to swap out at any given time.  */
end_comment

begin_function
specifier|static
name|void
name|ttm_shrink
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|,
name|bool
name|from_wq
parameter_list|,
name|uint64_t
name|extra
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|ttm_mem_shrink
modifier|*
name|shrink
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|glob
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|glob
operator|->
name|shrink
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
while|while
condition|(
name|ttm_zones_above_swap_target
argument_list|(
name|glob
argument_list|,
name|from_wq
argument_list|,
name|extra
argument_list|)
condition|)
block|{
name|shrink
operator|=
name|glob
operator|->
name|shrink
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|glob
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|shrink
operator|->
name|do_shrink
argument_list|(
name|shrink
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|glob
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|glob
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttm_shrink_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|ttm_mem_global
modifier|*
name|glob
init|=
name|arg
decl_stmt|;
name|ttm_shrink
argument_list|(
name|glob
argument_list|,
name|true
argument_list|,
literal|0ULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttm_mem_init_kernel_zone
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|,
name|uint64_t
name|mem
parameter_list|)
block|{
name|struct
name|ttm_mem_zone
modifier|*
name|zone
decl_stmt|;
name|zone
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zone
argument_list|)
argument_list|,
name|M_TTM_ZONE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|zone
operator|->
name|name
operator|=
literal|"kernel"
expr_stmt|;
name|zone
operator|->
name|zone_mem
operator|=
name|mem
expr_stmt|;
name|zone
operator|->
name|max_mem
operator|=
name|mem
operator|>>
literal|1
expr_stmt|;
name|zone
operator|->
name|emer_mem
operator|=
operator|(
name|mem
operator|>>
literal|1
operator|)
operator|+
operator|(
name|mem
operator|>>
literal|2
operator|)
expr_stmt|;
name|zone
operator|->
name|swap_limit
operator|=
name|zone
operator|->
name|max_mem
operator|-
operator|(
name|mem
operator|>>
literal|3
operator|)
expr_stmt|;
name|zone
operator|->
name|used_mem
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|glob
operator|=
name|glob
expr_stmt|;
name|glob
operator|->
name|zone_kernel
operator|=
name|zone
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|zone
operator|->
name|kobj_ref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|glob
operator|->
name|zones
index|[
name|glob
operator|->
name|num_zones
operator|++
index|]
operator|=
name|zone
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttm_mem_init_dma32_zone
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|,
name|uint64_t
name|mem
parameter_list|)
block|{
name|struct
name|ttm_mem_zone
modifier|*
name|zone
decl_stmt|;
name|zone
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zone
argument_list|)
argument_list|,
name|M_TTM_ZONE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/** 	 * No special dma32 zone needed. 	 */
if|if
condition|(
name|mem
operator|<=
operator|(
operator|(
name|uint64_t
operator|)
literal|1ULL
operator|<<
literal|32
operator|)
condition|)
block|{
name|free
argument_list|(
name|zone
argument_list|,
name|M_TTM_ZONE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Limit max dma32 memory to 4GB for now 	 * until we can figure out how big this 	 * zone really is. 	 */
name|mem
operator|=
operator|(
operator|(
name|uint64_t
operator|)
literal|1ULL
operator|<<
literal|32
operator|)
expr_stmt|;
name|zone
operator|->
name|name
operator|=
literal|"dma32"
expr_stmt|;
name|zone
operator|->
name|zone_mem
operator|=
name|mem
expr_stmt|;
name|zone
operator|->
name|max_mem
operator|=
name|mem
operator|>>
literal|1
expr_stmt|;
name|zone
operator|->
name|emer_mem
operator|=
operator|(
name|mem
operator|>>
literal|1
operator|)
operator|+
operator|(
name|mem
operator|>>
literal|2
operator|)
expr_stmt|;
name|zone
operator|->
name|swap_limit
operator|=
name|zone
operator|->
name|max_mem
operator|-
operator|(
name|mem
operator|>>
literal|3
operator|)
expr_stmt|;
name|zone
operator|->
name|used_mem
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|glob
operator|=
name|glob
expr_stmt|;
name|glob
operator|->
name|zone_dma32
operator|=
name|zone
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|zone
operator|->
name|kobj_ref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|glob
operator|->
name|zones
index|[
name|glob
operator|->
name|num_zones
operator|++
index|]
operator|=
name|zone
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ttm_mem_global_init
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|)
block|{
name|u_int64_t
name|mem
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|ttm_mem_zone
modifier|*
name|zone
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|glob
operator|->
name|lock
argument_list|,
literal|"ttmgz"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|glob
operator|->
name|swap_queue
operator|=
name|taskqueue_create
argument_list|(
literal|"ttm_swap"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|glob
operator|->
name|swap_queue
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|glob
operator|->
name|swap_queue
argument_list|,
literal|1
argument_list|,
name|PVM
argument_list|,
literal|"ttm swap"
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|glob
operator|->
name|work
argument_list|,
literal|0
argument_list|,
name|ttm_shrink_work
argument_list|,
name|glob
argument_list|)
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|glob
operator|->
name|kobj_ref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mem
operator|=
name|physmem
operator|*
name|PAGE_SIZE
expr_stmt|;
name|ret
operator|=
name|ttm_mem_init_kernel_zone
argument_list|(
name|glob
argument_list|,
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
condition|)
goto|goto
name|out_no_zone
goto|;
name|ret
operator|=
name|ttm_mem_init_dma32_zone
argument_list|(
name|glob
argument_list|,
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
condition|)
goto|goto
name|out_no_zone
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|glob
operator|->
name|num_zones
condition|;
operator|++
name|i
control|)
block|{
name|zone
operator|=
name|glob
operator|->
name|zones
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"[TTM] Zone %7s: Available graphics memory: %llu kiB\n"
argument_list|,
name|zone
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|zone
operator|->
name|max_mem
operator|>>
literal|10
argument_list|)
expr_stmt|;
block|}
name|ttm_page_alloc_init
argument_list|(
name|glob
argument_list|,
name|glob
operator|->
name|zone_kernel
operator|->
name|max_mem
operator|/
operator|(
literal|2
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
name|ttm_dma_page_alloc_init
argument_list|(
name|glob
argument_list|,
name|glob
operator|->
name|zone_kernel
operator|->
name|max_mem
operator|/
operator|(
literal|2
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out_no_zone
label|:
name|ttm_mem_global_release
argument_list|(
name|glob
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|ttm_mem_global_release
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|ttm_mem_zone
modifier|*
name|zone
decl_stmt|;
comment|/* let the page allocator first stop the shrink work. */
name|ttm_page_alloc_fini
argument_list|()
expr_stmt|;
name|ttm_dma_page_alloc_fini
argument_list|()
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|glob
operator|->
name|swap_queue
argument_list|,
operator|&
name|glob
operator|->
name|work
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|glob
operator|->
name|swap_queue
argument_list|)
expr_stmt|;
name|glob
operator|->
name|swap_queue
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|glob
operator|->
name|num_zones
condition|;
operator|++
name|i
control|)
block|{
name|zone
operator|=
name|glob
operator|->
name|zones
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|zone
operator|->
name|kobj_ref
argument_list|)
condition|)
name|ttm_mem_zone_kobj_release
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|glob
operator|->
name|kobj_ref
argument_list|)
condition|)
name|ttm_mem_global_kobj_release
argument_list|(
name|glob
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttm_check_swapping
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|)
block|{
name|bool
name|needs_swapping
init|=
name|false
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|ttm_mem_zone
modifier|*
name|zone
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|glob
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|glob
operator|->
name|num_zones
condition|;
operator|++
name|i
control|)
block|{
name|zone
operator|=
name|glob
operator|->
name|zones
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|used_mem
operator|>
name|zone
operator|->
name|swap_limit
condition|)
block|{
name|needs_swapping
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|glob
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|needs_swapping
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|glob
operator|->
name|swap_queue
argument_list|,
operator|&
name|glob
operator|->
name|work
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttm_mem_global_free_zone
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|,
name|struct
name|ttm_mem_zone
modifier|*
name|single_zone
parameter_list|,
name|uint64_t
name|amount
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|ttm_mem_zone
modifier|*
name|zone
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|glob
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|glob
operator|->
name|num_zones
condition|;
operator|++
name|i
control|)
block|{
name|zone
operator|=
name|glob
operator|->
name|zones
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|single_zone
operator|&&
name|zone
operator|!=
name|single_zone
condition|)
continue|continue;
name|zone
operator|->
name|used_mem
operator|-=
name|amount
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|glob
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ttm_mem_global_free
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|,
name|uint64_t
name|amount
parameter_list|)
block|{
return|return
name|ttm_mem_global_free_zone
argument_list|(
name|glob
argument_list|,
name|NULL
argument_list|,
name|amount
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttm_mem_global_reserve
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|,
name|struct
name|ttm_mem_zone
modifier|*
name|single_zone
parameter_list|,
name|uint64_t
name|amount
parameter_list|,
name|bool
name|reserve
parameter_list|)
block|{
name|uint64_t
name|limit
decl_stmt|;
name|int
name|ret
init|=
operator|-
name|ENOMEM
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|ttm_mem_zone
modifier|*
name|zone
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|glob
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|glob
operator|->
name|num_zones
condition|;
operator|++
name|i
control|)
block|{
name|zone
operator|=
name|glob
operator|->
name|zones
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|single_zone
operator|&&
name|zone
operator|!=
name|single_zone
condition|)
continue|continue;
name|limit
operator|=
operator|(
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_VM_MLOCK
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|zone
operator|->
name|emer_mem
else|:
name|zone
operator|->
name|max_mem
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|used_mem
operator|>
name|limit
condition|)
goto|goto
name|out_unlock
goto|;
block|}
if|if
condition|(
name|reserve
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|glob
operator|->
name|num_zones
condition|;
operator|++
name|i
control|)
block|{
name|zone
operator|=
name|glob
operator|->
name|zones
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|single_zone
operator|&&
name|zone
operator|!=
name|single_zone
condition|)
continue|continue;
name|zone
operator|->
name|used_mem
operator|+=
name|amount
expr_stmt|;
block|}
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|out_unlock
label|:
name|mtx_unlock
argument_list|(
operator|&
name|glob
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ttm_check_swapping
argument_list|(
name|glob
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttm_mem_global_alloc_zone
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|,
name|struct
name|ttm_mem_zone
modifier|*
name|single_zone
parameter_list|,
name|uint64_t
name|memory
parameter_list|,
name|bool
name|no_wait
parameter_list|,
name|bool
name|interruptible
parameter_list|)
block|{
name|int
name|count
init|=
name|TTM_MEMORY_ALLOC_RETRIES
decl_stmt|;
while|while
condition|(
name|unlikely
argument_list|(
name|ttm_mem_global_reserve
argument_list|(
name|glob
argument_list|,
name|single_zone
argument_list|,
name|memory
argument_list|,
name|true
argument_list|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|no_wait
condition|)
return|return
operator|-
name|ENOMEM
return|;
if|if
condition|(
name|unlikely
argument_list|(
name|count
operator|--
operator|==
literal|0
argument_list|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|ttm_shrink
argument_list|(
name|glob
argument_list|,
name|false
argument_list|,
name|memory
operator|+
operator|(
name|memory
operator|>>
literal|2
operator|)
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ttm_mem_global_alloc
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|,
name|uint64_t
name|memory
parameter_list|,
name|bool
name|no_wait
parameter_list|,
name|bool
name|interruptible
parameter_list|)
block|{
comment|/** 	 * Normal allocations of kernel memory are registered in 	 * all zones. 	 */
return|return
name|ttm_mem_global_alloc_zone
argument_list|(
name|glob
argument_list|,
name|NULL
argument_list|,
name|memory
argument_list|,
name|no_wait
argument_list|,
name|interruptible
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|page_to_pfn
parameter_list|(
name|pp
parameter_list|)
value|OFF_TO_IDX(VM_PAGE_TO_PHYS(pp))
end_define

begin_function
name|int
name|ttm_mem_global_alloc_page
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|,
name|struct
name|vm_page
modifier|*
name|page
parameter_list|,
name|bool
name|no_wait
parameter_list|,
name|bool
name|interruptible
parameter_list|)
block|{
name|struct
name|ttm_mem_zone
modifier|*
name|zone
init|=
name|NULL
decl_stmt|;
comment|/** 	 * Page allocations may be registed in a single zone 	 * only if highmem or !dma32. 	 */
if|if
condition|(
name|glob
operator|->
name|zone_dma32
operator|&&
name|page_to_pfn
argument_list|(
name|page
argument_list|)
operator|>
literal|0x00100000UL
condition|)
name|zone
operator|=
name|glob
operator|->
name|zone_kernel
expr_stmt|;
return|return
name|ttm_mem_global_alloc_zone
argument_list|(
name|glob
argument_list|,
name|zone
argument_list|,
name|PAGE_SIZE
argument_list|,
name|no_wait
argument_list|,
name|interruptible
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ttm_mem_global_free_page
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|,
name|struct
name|vm_page
modifier|*
name|page
parameter_list|)
block|{
name|struct
name|ttm_mem_zone
modifier|*
name|zone
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|glob
operator|->
name|zone_dma32
operator|&&
name|page_to_pfn
argument_list|(
name|page
argument_list|)
operator|>
literal|0x00100000UL
condition|)
name|zone
operator|=
name|glob
operator|->
name|zone_kernel
expr_stmt|;
name|ttm_mem_global_free_zone
argument_list|(
name|glob
argument_list|,
name|zone
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|ttm_round_pot
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
operator|(
name|size
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|size
return|;
elseif|else
if|if
condition|(
name|size
operator|>
name|PAGE_SIZE
condition|)
return|return
name|PAGE_ALIGN
argument_list|(
name|size
argument_list|)
return|;
else|else
block|{
name|size_t
name|tmp_size
init|=
literal|4
decl_stmt|;
while|while
condition|(
name|tmp_size
operator|<
name|size
condition|)
name|tmp_size
operator|<<=
literal|1
expr_stmt|;
return|return
name|tmp_size
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

