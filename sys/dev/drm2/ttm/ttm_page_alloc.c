begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) Red Hat Inc.   * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sub license,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Authors: Dave Airlie<airlied@redhat.com>  *          Jerome Glisse<jglisse@redhat.com>  *          Pauli Nieminen<suokkos@gmail.com>  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Konstantin Belousov  *<kib@FreeBSD.org> under sponsorship from the FreeBSD Foundation.  */
end_comment

begin_comment
comment|/* simple list based uncached page pool  * - Pool collects resently freed pages for reuse  * - Use page->lru to keep a free list  * - doesn't track currently in use pages  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_bo_driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_page_alloc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_define
define|#
directive|define
name|NUM_PAGES_TO_ALLOC
value|(PAGE_SIZE/sizeof(vm_page_t))
end_define

begin_define
define|#
directive|define
name|SMALL_ALLOCATION
value|16
end_define

begin_define
define|#
directive|define
name|FREE_ALL_PAGES
value|(~0U)
end_define

begin_comment
comment|/* times are in msecs */
end_comment

begin_define
define|#
directive|define
name|PAGE_FREE_INTERVAL
value|1000
end_define

begin_comment
comment|/**  * struct ttm_page_pool - Pool to reuse recently allocated uc/wc pages.  *  * @lock: Protects the shared pool from concurrnet access. Must be used with  * irqsave/irqrestore variants because pool allocator maybe called from  * delayed work.  * @fill_lock: Prevent concurrent calls to fill.  * @list: Pool of free uc/wc pages for fast reuse.  * @gfp_flags: Flags to pass for alloc_page.  * @npages: Number of pages in pool.  */
end_comment

begin_struct
struct|struct
name|ttm_page_pool
block|{
name|struct
name|mtx
name|lock
decl_stmt|;
name|bool
name|fill_lock
decl_stmt|;
name|bool
name|dma32
decl_stmt|;
name|struct
name|pglist
name|list
decl_stmt|;
name|int
name|ttm_page_alloc_flags
decl_stmt|;
name|unsigned
name|npages
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|nfrees
decl_stmt|;
name|unsigned
name|long
name|nrefills
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Limits for the pool. They are handled without locks because only place where  * they may change is in sysfs store. They won't have immediate effect anyway  * so forcing serialization to access them is pointless.  */
end_comment

begin_struct
struct|struct
name|ttm_pool_opts
block|{
name|unsigned
name|alloc_size
decl_stmt|;
name|unsigned
name|max_size
decl_stmt|;
name|unsigned
name|small
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NUM_POOLS
value|4
end_define

begin_comment
comment|/**  * struct ttm_pool_manager - Holds memory pools for fst allocation  *  * Manager is read only object for pool code so it doesn't need locking.  *  * @free_interval: minimum number of jiffies between freeing pages from pool.  * @page_alloc_inited: reference counting for pool allocation.  * @work: Work that is used to shrink the pool. Work is only run when there is  * some pages to free.  * @small_allocation: Limit in number of pages what is small allocation.  *  * @pools: All pool objects in use.  **/
end_comment

begin_struct
struct|struct
name|ttm_pool_manager
block|{
name|unsigned
name|int
name|kobj_ref
decl_stmt|;
name|eventhandler_tag
name|lowmem_handler
decl_stmt|;
name|struct
name|ttm_pool_opts
name|options
decl_stmt|;
union|union
block|{
name|struct
name|ttm_page_pool
name|u_pools
index|[
name|NUM_POOLS
index|]
decl_stmt|;
struct|struct
name|_utag
block|{
name|struct
name|ttm_page_pool
name|u_wc_pool
decl_stmt|;
name|struct
name|ttm_page_pool
name|u_uc_pool
decl_stmt|;
name|struct
name|ttm_page_pool
name|u_wc_pool_dma32
decl_stmt|;
name|struct
name|ttm_page_pool
name|u_uc_pool_dma32
decl_stmt|;
block|}
name|_ut
struct|;
block|}
name|_u
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|pools
value|_u.u_pools
end_define

begin_define
define|#
directive|define
name|wc_pool
value|_u._ut.u_wc_pool
end_define

begin_define
define|#
directive|define
name|uc_pool
value|_u._ut.u_uc_pool
end_define

begin_define
define|#
directive|define
name|wc_pool_dma32
value|_u._ut.u_wc_pool_dma32
end_define

begin_define
define|#
directive|define
name|uc_pool_dma32
value|_u._ut.u_uc_pool_dma32
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_TTM_POOLMGR
argument_list|,
literal|"ttm_poolmgr"
argument_list|,
literal|"TTM Pool Manager"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|ttm_vm_page_free
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|m
operator|->
name|object
operator|==
name|NULL
argument_list|,
operator|(
literal|"ttm page %p is owned"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|wire_count
operator|==
literal|1
argument_list|,
operator|(
literal|"ttm lost wire %p"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"ttm lost fictitious %p"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"ttm got unmanaged %p"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_FICTITIOUS
expr_stmt|;
name|m
operator|->
name|oflags
operator||=
name|VPO_UNMANAGED
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
name|PQ_NONE
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vm_memattr_t
name|ttm_caching_state_to_vm
parameter_list|(
name|enum
name|ttm_caching_state
name|cstate
parameter_list|)
block|{
switch|switch
condition|(
name|cstate
condition|)
block|{
case|case
name|tt_uncached
case|:
return|return
operator|(
name|VM_MEMATTR_UNCACHEABLE
operator|)
return|;
case|case
name|tt_wc
case|:
return|return
operator|(
name|VM_MEMATTR_WRITE_COMBINING
operator|)
return|;
case|case
name|tt_cached
case|:
return|return
operator|(
name|VM_MEMATTR_WRITE_BACK
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"caching state %d\n"
argument_list|,
name|cstate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|ttm_vm_page_alloc_dma32
parameter_list|(
name|int
name|req
parameter_list|,
name|vm_memattr_t
name|memattr
parameter_list|)
block|{
name|vm_page_t
name|p
decl_stmt|;
name|int
name|tries
decl_stmt|;
for|for
control|(
name|tries
operator|=
literal|0
init|;
condition|;
name|tries
operator|++
control|)
block|{
name|p
operator|=
name|vm_page_alloc_contig
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|req
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|memattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|||
name|tries
operator|>
literal|2
condition|)
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
operator|!
name|vm_page_reclaim_contig
argument_list|(
name|req
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
condition|)
name|VM_WAIT
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|ttm_vm_page_alloc_any
parameter_list|(
name|int
name|req
parameter_list|,
name|vm_memattr_t
name|memattr
parameter_list|)
block|{
name|vm_page_t
name|p
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
break|break;
name|VM_WAIT
expr_stmt|;
block|}
name|pmap_page_set_memattr
argument_list|(
name|p
argument_list|,
name|memattr
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|ttm_vm_page_alloc
parameter_list|(
name|int
name|flags
parameter_list|,
name|enum
name|ttm_caching_state
name|cstate
parameter_list|)
block|{
name|vm_page_t
name|p
decl_stmt|;
name|vm_memattr_t
name|memattr
decl_stmt|;
name|int
name|req
decl_stmt|;
name|memattr
operator|=
name|ttm_caching_state_to_vm
argument_list|(
name|cstate
argument_list|)
expr_stmt|;
name|req
operator|=
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_NOOBJ
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TTM_PAGE_FLAG_ZERO_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|req
operator||=
name|VM_ALLOC_ZERO
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TTM_PAGE_FLAG_DMA32
operator|)
operator|!=
literal|0
condition|)
name|p
operator|=
name|ttm_vm_page_alloc_dma32
argument_list|(
name|req
argument_list|,
name|memattr
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|ttm_vm_page_alloc_any
argument_list|(
name|req
argument_list|,
name|memattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|oflags
operator|&=
operator|~
name|VPO_UNMANAGED
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|PG_FICTITIOUS
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttm_pool_kobj_release
parameter_list|(
name|struct
name|ttm_pool_manager
modifier|*
name|m
parameter_list|)
block|{
name|free
argument_list|(
name|m
argument_list|,
name|M_TTM_POOLMGR
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXXKIB sysctl */
end_comment

begin_comment
unit|static ssize_t ttm_pool_store(struct ttm_pool_manager *m, 		struct attribute *attr, const char *buffer, size_t size) { 	int chars; 	unsigned val; 	chars = sscanf(buffer, "%u",&val); 	if (chars == 0) 		return size;
comment|/* Convert kb to number of pages */
end_comment

begin_endif
unit|val = val / (PAGE_SIZE>> 10);  	if (attr ==&ttm_page_pool_max) 		m->options.max_size = val; 	else if (attr ==&ttm_page_pool_small) 		m->options.small = val; 	else if (attr ==&ttm_page_pool_alloc_size) { 		if (val> NUM_PAGES_TO_ALLOC*8) { 			pr_err("Setting allocation size to %lu is not allowed. Recommended size is %lu\n", 			       NUM_PAGES_TO_ALLOC*(PAGE_SIZE>> 7), 			       NUM_PAGES_TO_ALLOC*(PAGE_SIZE>> 10)); 			return size; 		} else if (val> NUM_PAGES_TO_ALLOC) { 			pr_warn("Setting allocation size to larger than %lu is not recommended\n", 				NUM_PAGES_TO_ALLOC*(PAGE_SIZE>> 10)); 		} 		m->options.alloc_size = val; 	}  	return size; }  static ssize_t ttm_pool_show(struct ttm_pool_manager *m, 		struct attribute *attr, char *buffer) { 	unsigned val = 0;  	if (attr ==&ttm_page_pool_max) 		val = m->options.max_size; 	else if (attr ==&ttm_page_pool_small) 		val = m->options.small; 	else if (attr ==&ttm_page_pool_alloc_size) 		val = m->options.alloc_size;  	val = val * (PAGE_SIZE>> 10);  	return snprintf(buffer, PAGE_SIZE, "%u\n", val); }
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|ttm_pool_manager
modifier|*
name|_manager
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|set_pages_array_wb
parameter_list|(
name|vm_page_t
modifier|*
name|pages
parameter_list|,
name|int
name|addrinarray
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TTM_HAS_AGP
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addrinarray
condition|;
name|i
operator|++
control|)
name|pmap_page_set_memattr
argument_list|(
name|pages
index|[
name|i
index|]
argument_list|,
name|VM_MEMATTR_WRITE_BACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_pages_array_wc
parameter_list|(
name|vm_page_t
modifier|*
name|pages
parameter_list|,
name|int
name|addrinarray
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TTM_HAS_AGP
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addrinarray
condition|;
name|i
operator|++
control|)
name|pmap_page_set_memattr
argument_list|(
name|pages
index|[
name|i
index|]
argument_list|,
name|VM_MEMATTR_WRITE_COMBINING
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_pages_array_uc
parameter_list|(
name|vm_page_t
modifier|*
name|pages
parameter_list|,
name|int
name|addrinarray
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TTM_HAS_AGP
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addrinarray
condition|;
name|i
operator|++
control|)
name|pmap_page_set_memattr
argument_list|(
name|pages
index|[
name|i
index|]
argument_list|,
name|VM_MEMATTR_UNCACHEABLE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Select the right pool or requested caching state and ttm flags. */
end_comment

begin_function
specifier|static
name|struct
name|ttm_page_pool
modifier|*
name|ttm_get_pool
parameter_list|(
name|int
name|flags
parameter_list|,
name|enum
name|ttm_caching_state
name|cstate
parameter_list|)
block|{
name|int
name|pool_index
decl_stmt|;
if|if
condition|(
name|cstate
operator|==
name|tt_cached
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|cstate
operator|==
name|tt_wc
condition|)
name|pool_index
operator|=
literal|0x0
expr_stmt|;
else|else
name|pool_index
operator|=
literal|0x1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TTM_PAGE_FLAG_DMA32
condition|)
name|pool_index
operator||=
literal|0x2
expr_stmt|;
return|return
operator|&
name|_manager
operator|->
name|pools
index|[
name|pool_index
index|]
return|;
block|}
end_function

begin_comment
comment|/* set memory back to wb and free the pages. */
end_comment

begin_function
specifier|static
name|void
name|ttm_pages_put
parameter_list|(
name|vm_page_t
modifier|*
name|pages
parameter_list|,
name|unsigned
name|npages
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* Our VM handles vm memattr automatically on the page free. */
if|if
condition|(
name|set_pages_array_wb
argument_list|(
name|pages
argument_list|,
name|npages
argument_list|)
condition|)
name|printf
argument_list|(
literal|"[TTM] Failed to set %d pages to wb!\n"
argument_list|,
name|npages
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
operator|++
name|i
control|)
name|ttm_vm_page_free
argument_list|(
name|pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttm_pool_update_free_locked
parameter_list|(
name|struct
name|ttm_page_pool
modifier|*
name|pool
parameter_list|,
name|unsigned
name|freed_pages
parameter_list|)
block|{
name|pool
operator|->
name|npages
operator|-=
name|freed_pages
expr_stmt|;
name|pool
operator|->
name|nfrees
operator|+=
name|freed_pages
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Free pages from pool.  *  * To prevent hogging the ttm_swap process we only free NUM_PAGES_TO_ALLOC  * number of pages in one go.  *  * @pool: to free the pages from  * @free_all: If set to true will free all pages in pool  **/
end_comment

begin_function
specifier|static
name|int
name|ttm_page_pool_free
parameter_list|(
name|struct
name|ttm_page_pool
modifier|*
name|pool
parameter_list|,
name|unsigned
name|nr_free
parameter_list|)
block|{
name|vm_page_t
name|p
decl_stmt|,
name|p1
decl_stmt|;
name|vm_page_t
modifier|*
name|pages_to_free
decl_stmt|;
name|unsigned
name|freed_pages
init|=
literal|0
decl_stmt|,
name|npages_to_free
init|=
name|nr_free
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|NUM_PAGES_TO_ALLOC
operator|<
name|nr_free
condition|)
name|npages_to_free
operator|=
name|NUM_PAGES_TO_ALLOC
expr_stmt|;
name|pages_to_free
operator|=
name|malloc
argument_list|(
name|npages_to_free
operator|*
sizeof|sizeof
argument_list|(
name|vm_page_t
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|restart
label|:
name|mtx_lock
argument_list|(
operator|&
name|pool
operator|->
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_REVERSE_SAFE
argument_list|(
argument|p
argument_list|,
argument|&pool->list
argument_list|,
argument|pglist
argument_list|,
argument|plinks.q
argument_list|,
argument|p1
argument_list|)
block|{
if|if
condition|(
name|freed_pages
operator|>=
name|npages_to_free
condition|)
break|break;
name|pages_to_free
index|[
name|freed_pages
operator|++
index|]
operator|=
name|p
expr_stmt|;
comment|/* We can only remove NUM_PAGES_TO_ALLOC at a time. */
if|if
condition|(
name|freed_pages
operator|>=
name|NUM_PAGES_TO_ALLOC
condition|)
block|{
comment|/* remove range of pages from the pool */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|freed_pages
condition|;
name|i
operator|++
control|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|pages_to_free
index|[
name|i
index|]
argument_list|,
name|plinks
operator|.
name|q
argument_list|)
expr_stmt|;
name|ttm_pool_update_free_locked
argument_list|(
name|pool
argument_list|,
name|freed_pages
argument_list|)
expr_stmt|;
comment|/** 			 * Because changing page caching is costly 			 * we unlock the pool to prevent stalling. 			 */
name|mtx_unlock
argument_list|(
operator|&
name|pool
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ttm_pages_put
argument_list|(
name|pages_to_free
argument_list|,
name|freed_pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|nr_free
operator|!=
name|FREE_ALL_PAGES
argument_list|)
condition|)
name|nr_free
operator|-=
name|freed_pages
expr_stmt|;
if|if
condition|(
name|NUM_PAGES_TO_ALLOC
operator|>=
name|nr_free
condition|)
name|npages_to_free
operator|=
name|nr_free
expr_stmt|;
else|else
name|npages_to_free
operator|=
name|NUM_PAGES_TO_ALLOC
expr_stmt|;
name|freed_pages
operator|=
literal|0
expr_stmt|;
comment|/* free all so restart the processing */
if|if
condition|(
name|nr_free
condition|)
goto|goto
name|restart
goto|;
comment|/* Not allowed to fall through or break because 			 * following context is inside spinlock while we are 			 * outside here. 			 */
goto|goto
name|out
goto|;
block|}
block|}
comment|/* remove range of pages from the pool */
if|if
condition|(
name|freed_pages
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|freed_pages
condition|;
name|i
operator|++
control|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|pages_to_free
index|[
name|i
index|]
argument_list|,
name|plinks
operator|.
name|q
argument_list|)
expr_stmt|;
name|ttm_pool_update_free_locked
argument_list|(
name|pool
argument_list|,
name|freed_pages
argument_list|)
expr_stmt|;
name|nr_free
operator|-=
name|freed_pages
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pool
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|freed_pages
condition|)
name|ttm_pages_put
argument_list|(
name|pages_to_free
argument_list|,
name|freed_pages
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|pages_to_free
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|nr_free
return|;
block|}
end_function

begin_comment
comment|/* Get good estimation how many pages are free in pools */
end_comment

begin_function
specifier|static
name|int
name|ttm_pool_get_num_unused_pages
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_POOLS
condition|;
operator|++
name|i
control|)
name|total
operator|+=
name|_manager
operator|->
name|pools
index|[
name|i
index|]
operator|.
name|npages
expr_stmt|;
return|return
name|total
return|;
block|}
end_function

begin_comment
comment|/**  * Callback for mm to request pool to reduce number of page held.  */
end_comment

begin_function
specifier|static
name|int
name|ttm_pool_mm_shrink
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
name|unsigned
name|int
name|start_pool
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|pool_offset
init|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|start_pool
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|struct
name|ttm_page_pool
modifier|*
name|pool
decl_stmt|;
name|int
name|shrink_pages
init|=
literal|100
decl_stmt|;
comment|/* XXXKIB */
name|pool_offset
operator|=
name|pool_offset
operator|%
name|NUM_POOLS
expr_stmt|;
comment|/* select start pool in round robin fashion */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_POOLS
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|nr_free
init|=
name|shrink_pages
decl_stmt|;
if|if
condition|(
name|shrink_pages
operator|==
literal|0
condition|)
break|break;
name|pool
operator|=
operator|&
name|_manager
operator|->
name|pools
index|[
operator|(
name|i
operator|+
name|pool_offset
operator|)
operator|%
name|NUM_POOLS
index|]
expr_stmt|;
name|shrink_pages
operator|=
name|ttm_page_pool_free
argument_list|(
name|pool
argument_list|,
name|nr_free
argument_list|)
expr_stmt|;
block|}
comment|/* return estimated number of unused pages in pool */
return|return
name|ttm_pool_get_num_unused_pages
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttm_pool_mm_shrink_init
parameter_list|(
name|struct
name|ttm_pool_manager
modifier|*
name|manager
parameter_list|)
block|{
name|manager
operator|->
name|lowmem_handler
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vm_lowmem
argument_list|,
name|ttm_pool_mm_shrink
argument_list|,
name|manager
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttm_pool_mm_shrink_fini
parameter_list|(
name|struct
name|ttm_pool_manager
modifier|*
name|manager
parameter_list|)
block|{
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vm_lowmem
argument_list|,
name|manager
operator|->
name|lowmem_handler
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttm_set_pages_caching
parameter_list|(
name|vm_page_t
modifier|*
name|pages
parameter_list|,
name|enum
name|ttm_caching_state
name|cstate
parameter_list|,
name|unsigned
name|cpages
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
comment|/* Set page caching */
switch|switch
condition|(
name|cstate
condition|)
block|{
case|case
name|tt_uncached
case|:
name|r
operator|=
name|set_pages_array_uc
argument_list|(
name|pages
argument_list|,
name|cpages
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|printf
argument_list|(
literal|"[TTM] Failed to set %d pages to uc!\n"
argument_list|,
name|cpages
argument_list|)
expr_stmt|;
break|break;
case|case
name|tt_wc
case|:
name|r
operator|=
name|set_pages_array_wc
argument_list|(
name|pages
argument_list|,
name|cpages
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|printf
argument_list|(
literal|"[TTM] Failed to set %d pages to wc!\n"
argument_list|,
name|cpages
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/**  * Free pages the pages that failed to change the caching state. If there is  * any pages that have changed their caching state already put them to the  * pool.  */
end_comment

begin_function
specifier|static
name|void
name|ttm_handle_caching_state_failure
parameter_list|(
name|struct
name|pglist
modifier|*
name|pages
parameter_list|,
name|int
name|ttm_flags
parameter_list|,
name|enum
name|ttm_caching_state
name|cstate
parameter_list|,
name|vm_page_t
modifier|*
name|failed_pages
parameter_list|,
name|unsigned
name|cpages
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* Failed pages have to be freed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpages
condition|;
operator|++
name|i
control|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|pages
argument_list|,
name|failed_pages
index|[
name|i
index|]
argument_list|,
name|plinks
operator|.
name|q
argument_list|)
expr_stmt|;
name|ttm_vm_page_free
argument_list|(
name|failed_pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Allocate new pages with correct caching.  *  * This function is reentrant if caller updates count depending on number of  * pages returned in pages array.  */
end_comment

begin_function
specifier|static
name|int
name|ttm_alloc_new_pages
parameter_list|(
name|struct
name|pglist
modifier|*
name|pages
parameter_list|,
name|int
name|ttm_alloc_flags
parameter_list|,
name|int
name|ttm_flags
parameter_list|,
name|enum
name|ttm_caching_state
name|cstate
parameter_list|,
name|unsigned
name|count
parameter_list|)
block|{
name|vm_page_t
modifier|*
name|caching_array
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|cpages
decl_stmt|;
name|unsigned
name|max_cpages
init|=
name|min
argument_list|(
name|count
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|vm_page_t
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* allocate array for page caching change */
name|caching_array
operator|=
name|malloc
argument_list|(
name|max_cpages
operator|*
sizeof|sizeof
argument_list|(
name|vm_page_t
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cpages
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
name|ttm_vm_page_alloc
argument_list|(
name|ttm_alloc_flags
argument_list|,
name|cstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"[TTM] Unable to get page %u\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* store already allocated pages in the pool after 			 * setting the caching state */
if|if
condition|(
name|cpages
condition|)
block|{
name|r
operator|=
name|ttm_set_pages_caching
argument_list|(
name|caching_array
argument_list|,
name|cstate
argument_list|,
name|cpages
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|ttm_handle_caching_state_failure
argument_list|(
name|pages
argument_list|,
name|ttm_flags
argument_list|,
name|cstate
argument_list|,
name|caching_array
argument_list|,
name|cpages
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_HIGHMEM
comment|/* KIB: nop */
comment|/* gfp flags of highmem page should never be dma32 so we 		 * we should be fine in such case 		 */
if|if
condition|(
operator|!
name|PageHighMem
argument_list|(
name|p
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|caching_array
index|[
name|cpages
operator|++
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|cpages
operator|==
name|max_cpages
condition|)
block|{
name|r
operator|=
name|ttm_set_pages_caching
argument_list|(
name|caching_array
argument_list|,
name|cstate
argument_list|,
name|cpages
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|ttm_handle_caching_state_failure
argument_list|(
name|pages
argument_list|,
name|ttm_flags
argument_list|,
name|cstate
argument_list|,
name|caching_array
argument_list|,
name|cpages
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cpages
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|TAILQ_INSERT_HEAD
argument_list|(
name|pages
argument_list|,
name|p
argument_list|,
name|plinks
operator|.
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cpages
condition|)
block|{
name|r
operator|=
name|ttm_set_pages_caching
argument_list|(
name|caching_array
argument_list|,
name|cstate
argument_list|,
name|cpages
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|ttm_handle_caching_state_failure
argument_list|(
name|pages
argument_list|,
name|ttm_flags
argument_list|,
name|cstate
argument_list|,
name|caching_array
argument_list|,
name|cpages
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|free
argument_list|(
name|caching_array
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/**  * Fill the given pool if there aren't enough pages and the requested number of  * pages is small.  */
end_comment

begin_function
specifier|static
name|void
name|ttm_page_pool_fill_locked
parameter_list|(
name|struct
name|ttm_page_pool
modifier|*
name|pool
parameter_list|,
name|int
name|ttm_flags
parameter_list|,
name|enum
name|ttm_caching_state
name|cstate
parameter_list|,
name|unsigned
name|count
parameter_list|)
block|{
name|vm_page_t
name|p
decl_stmt|;
name|int
name|r
decl_stmt|;
name|unsigned
name|cpages
init|=
literal|0
decl_stmt|;
comment|/** 	 * Only allow one pool fill operation at a time. 	 * If pool doesn't have enough pages for the allocation new pages are 	 * allocated from outside of pool. 	 */
if|if
condition|(
name|pool
operator|->
name|fill_lock
condition|)
return|return;
name|pool
operator|->
name|fill_lock
operator|=
name|true
expr_stmt|;
comment|/* If allocation request is small and there are not enough 	 * pages in a pool we fill the pool up first. */
if|if
condition|(
name|count
operator|<
name|_manager
operator|->
name|options
operator|.
name|small
operator|&&
name|count
operator|>
name|pool
operator|->
name|npages
condition|)
block|{
name|struct
name|pglist
name|new_pages
decl_stmt|;
name|unsigned
name|alloc_size
init|=
name|_manager
operator|->
name|options
operator|.
name|alloc_size
decl_stmt|;
comment|/** 		 * Can't change page caching if in irqsave context. We have to 		 * drop the pool->lock. 		 */
name|mtx_unlock
argument_list|(
operator|&
name|pool
operator|->
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|new_pages
argument_list|)
expr_stmt|;
name|r
operator|=
name|ttm_alloc_new_pages
argument_list|(
operator|&
name|new_pages
argument_list|,
name|pool
operator|->
name|ttm_page_alloc_flags
argument_list|,
name|ttm_flags
argument_list|,
name|cstate
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pool
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|TAILQ_CONCAT
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
operator|&
name|new_pages
argument_list|,
name|plinks
operator|.
name|q
argument_list|)
expr_stmt|;
operator|++
name|pool
operator|->
name|nrefills
expr_stmt|;
name|pool
operator|->
name|npages
operator|+=
name|alloc_size
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"[TTM] Failed to fill pool (%p)\n"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If we have any pages left put them to the pool. */
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&pool->list
argument_list|,
argument|plinks.q
argument_list|)
block|{
operator|++
name|cpages
expr_stmt|;
block|}
name|TAILQ_CONCAT
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
operator|&
name|new_pages
argument_list|,
name|plinks
operator|.
name|q
argument_list|)
expr_stmt|;
name|pool
operator|->
name|npages
operator|+=
name|cpages
expr_stmt|;
block|}
block|}
name|pool
operator|->
name|fill_lock
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Cut 'count' number of pages from the pool and put them on the return list.  *  * @return count of pages still required to fulfill the request.  */
end_comment

begin_function
specifier|static
name|unsigned
name|ttm_page_pool_get_pages
parameter_list|(
name|struct
name|ttm_page_pool
modifier|*
name|pool
parameter_list|,
name|struct
name|pglist
modifier|*
name|pages
parameter_list|,
name|int
name|ttm_flags
parameter_list|,
name|enum
name|ttm_caching_state
name|cstate
parameter_list|,
name|unsigned
name|count
parameter_list|)
block|{
name|vm_page_t
name|p
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pool
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ttm_page_pool_fill_locked
argument_list|(
name|pool
argument_list|,
name|ttm_flags
argument_list|,
name|cstate
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|pool
operator|->
name|npages
condition|)
block|{
comment|/* take all pages from the pool */
name|TAILQ_CONCAT
argument_list|(
name|pages
argument_list|,
operator|&
name|pool
operator|->
name|list
argument_list|,
name|plinks
operator|.
name|q
argument_list|)
expr_stmt|;
name|count
operator|-=
name|pool
operator|->
name|npages
expr_stmt|;
name|pool
operator|->
name|npages
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|p
argument_list|,
name|plinks
operator|.
name|q
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|pages
argument_list|,
name|p
argument_list|,
name|plinks
operator|.
name|q
argument_list|)
expr_stmt|;
block|}
name|pool
operator|->
name|npages
operator|-=
name|count
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|pool
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Put all pages in pages list to correct pool to wait for reuse */
end_comment

begin_function
specifier|static
name|void
name|ttm_put_pages
parameter_list|(
name|vm_page_t
modifier|*
name|pages
parameter_list|,
name|unsigned
name|npages
parameter_list|,
name|int
name|flags
parameter_list|,
name|enum
name|ttm_caching_state
name|cstate
parameter_list|)
block|{
name|struct
name|ttm_page_pool
modifier|*
name|pool
init|=
name|ttm_get_pool
argument_list|(
name|flags
argument_list|,
name|cstate
argument_list|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
comment|/* No pool for this memory type so free the pages */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pages
index|[
name|i
index|]
condition|)
block|{
name|ttm_vm_page_free
argument_list|(
name|pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pages
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|pool
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pages
index|[
name|i
index|]
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|pages
index|[
name|i
index|]
argument_list|,
name|plinks
operator|.
name|q
argument_list|)
expr_stmt|;
name|pages
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|npages
operator|++
expr_stmt|;
block|}
block|}
comment|/* Check that we don't go over the pool limit */
name|npages
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|npages
operator|>
name|_manager
operator|->
name|options
operator|.
name|max_size
condition|)
block|{
name|npages
operator|=
name|pool
operator|->
name|npages
operator|-
name|_manager
operator|->
name|options
operator|.
name|max_size
expr_stmt|;
comment|/* free at least NUM_PAGES_TO_ALLOC number of pages 		 * to reduce calls to set_memory_wb */
if|if
condition|(
name|npages
operator|<
name|NUM_PAGES_TO_ALLOC
condition|)
name|npages
operator|=
name|NUM_PAGES_TO_ALLOC
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pool
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|npages
condition|)
name|ttm_page_pool_free
argument_list|(
name|pool
argument_list|,
name|npages
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * On success pages list will hold count number of correctly  * cached pages.  */
end_comment

begin_function
specifier|static
name|int
name|ttm_get_pages
parameter_list|(
name|vm_page_t
modifier|*
name|pages
parameter_list|,
name|unsigned
name|npages
parameter_list|,
name|int
name|flags
parameter_list|,
name|enum
name|ttm_caching_state
name|cstate
parameter_list|)
block|{
name|struct
name|ttm_page_pool
modifier|*
name|pool
init|=
name|ttm_get_pool
argument_list|(
name|flags
argument_list|,
name|cstate
argument_list|)
decl_stmt|;
name|struct
name|pglist
name|plist
decl_stmt|;
name|vm_page_t
name|p
init|=
name|NULL
decl_stmt|;
name|int
name|gfp_flags
decl_stmt|;
name|unsigned
name|count
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* No pool for cached pages */
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|npages
condition|;
operator|++
name|r
control|)
block|{
name|p
operator|=
name|ttm_vm_page_alloc
argument_list|(
name|flags
argument_list|,
name|cstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"[TTM] Unable to allocate page\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|pages
index|[
name|r
index|]
operator|=
name|p
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* combine zero flag to pool flags */
name|gfp_flags
operator|=
name|flags
operator||
name|pool
operator|->
name|ttm_page_alloc_flags
expr_stmt|;
comment|/* First we take pages from the pool */
name|TAILQ_INIT
argument_list|(
operator|&
name|plist
argument_list|)
expr_stmt|;
name|npages
operator|=
name|ttm_page_pool_get_pages
argument_list|(
name|pool
argument_list|,
operator|&
name|plist
argument_list|,
name|flags
argument_list|,
name|cstate
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&plist
argument_list|,
argument|plinks.q
argument_list|)
block|{
name|pages
index|[
name|count
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
comment|/* clear the pages coming from the pool if requested */
if|if
condition|(
name|flags
operator|&
name|TTM_PAGE_FLAG_ZERO_ALLOC
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&plist
argument_list|,
argument|plinks.q
argument_list|)
block|{
name|pmap_zero_page
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If pool didn't have enough pages allocate new one. */
if|if
condition|(
name|npages
operator|>
literal|0
condition|)
block|{
comment|/* ttm_alloc_new_pages doesn't reference pool so we can run 		 * multiple requests in parallel. 		 **/
name|TAILQ_INIT
argument_list|(
operator|&
name|plist
argument_list|)
expr_stmt|;
name|r
operator|=
name|ttm_alloc_new_pages
argument_list|(
operator|&
name|plist
argument_list|,
name|gfp_flags
argument_list|,
name|flags
argument_list|,
name|cstate
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&plist
argument_list|,
argument|plinks.q
argument_list|)
block|{
name|pages
index|[
name|count
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|r
condition|)
block|{
comment|/* If there is any pages in the list put them back to 			 * the pool. */
name|printf
argument_list|(
literal|"[TTM] Failed to allocate extra pages for large request\n"
argument_list|)
expr_stmt|;
name|ttm_put_pages
argument_list|(
name|pages
argument_list|,
name|count
argument_list|,
name|flags
argument_list|,
name|cstate
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttm_page_pool_init_locked
parameter_list|(
name|struct
name|ttm_page_pool
modifier|*
name|pool
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|pool
operator|->
name|lock
argument_list|,
literal|"ttmpool"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|pool
operator|->
name|fill_lock
operator|=
name|false
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
name|pool
operator|->
name|npages
operator|=
name|pool
operator|->
name|nfrees
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|ttm_page_alloc_flags
operator|=
name|flags
expr_stmt|;
name|pool
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ttm_page_alloc_init
parameter_list|(
name|struct
name|ttm_mem_global
modifier|*
name|glob
parameter_list|,
name|unsigned
name|max_pages
parameter_list|)
block|{
if|if
condition|(
name|_manager
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"[TTM] manager != NULL\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[TTM] Initializing pool allocator\n"
argument_list|)
expr_stmt|;
name|_manager
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|_manager
argument_list|)
argument_list|,
name|M_TTM_POOLMGR
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ttm_page_pool_init_locked
argument_list|(
operator|&
name|_manager
operator|->
name|wc_pool
argument_list|,
literal|0
argument_list|,
literal|"wc"
argument_list|)
expr_stmt|;
name|ttm_page_pool_init_locked
argument_list|(
operator|&
name|_manager
operator|->
name|uc_pool
argument_list|,
literal|0
argument_list|,
literal|"uc"
argument_list|)
expr_stmt|;
name|ttm_page_pool_init_locked
argument_list|(
operator|&
name|_manager
operator|->
name|wc_pool_dma32
argument_list|,
name|TTM_PAGE_FLAG_DMA32
argument_list|,
literal|"wc dma"
argument_list|)
expr_stmt|;
name|ttm_page_pool_init_locked
argument_list|(
operator|&
name|_manager
operator|->
name|uc_pool_dma32
argument_list|,
name|TTM_PAGE_FLAG_DMA32
argument_list|,
literal|"uc dma"
argument_list|)
expr_stmt|;
name|_manager
operator|->
name|options
operator|.
name|max_size
operator|=
name|max_pages
expr_stmt|;
name|_manager
operator|->
name|options
operator|.
name|small
operator|=
name|SMALL_ALLOCATION
expr_stmt|;
name|_manager
operator|->
name|options
operator|.
name|alloc_size
operator|=
name|NUM_PAGES_TO_ALLOC
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|_manager
operator|->
name|kobj_ref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ttm_pool_mm_shrink_init
argument_list|(
name|_manager
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ttm_page_alloc_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"[TTM] Finalizing pool allocator\n"
argument_list|)
expr_stmt|;
name|ttm_pool_mm_shrink_fini
argument_list|(
name|_manager
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_POOLS
condition|;
operator|++
name|i
control|)
name|ttm_page_pool_free
argument_list|(
operator|&
name|_manager
operator|->
name|pools
index|[
name|i
index|]
argument_list|,
name|FREE_ALL_PAGES
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|_manager
operator|->
name|kobj_ref
argument_list|)
condition|)
name|ttm_pool_kobj_release
argument_list|(
name|_manager
argument_list|)
expr_stmt|;
name|_manager
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ttm_pool_populate
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|)
block|{
name|struct
name|ttm_mem_global
modifier|*
name|mem_glob
init|=
name|ttm
operator|->
name|glob
operator|->
name|mem_glob
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|ttm
operator|->
name|state
operator|!=
name|tt_unpopulated
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ttm
operator|->
name|num_pages
condition|;
operator|++
name|i
control|)
block|{
name|ret
operator|=
name|ttm_get_pages
argument_list|(
operator|&
name|ttm
operator|->
name|pages
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|ttm
operator|->
name|page_flags
argument_list|,
name|ttm
operator|->
name|caching_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|ttm_pool_unpopulate
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|ret
operator|=
name|ttm_mem_global_alloc_page
argument_list|(
name|mem_glob
argument_list|,
name|ttm
operator|->
name|pages
index|[
name|i
index|]
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|ttm_pool_unpopulate
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|ttm
operator|->
name|page_flags
operator|&
name|TTM_PAGE_FLAG_SWAPPED
argument_list|)
condition|)
block|{
name|ret
operator|=
name|ttm_tt_swapin
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|ttm_pool_unpopulate
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|ttm
operator|->
name|state
operator|=
name|tt_unbound
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ttm_pool_unpopulate
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ttm
operator|->
name|num_pages
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ttm
operator|->
name|pages
index|[
name|i
index|]
condition|)
block|{
name|ttm_mem_global_free_page
argument_list|(
name|ttm
operator|->
name|glob
operator|->
name|mem_glob
argument_list|,
name|ttm
operator|->
name|pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ttm_put_pages
argument_list|(
operator|&
name|ttm
operator|->
name|pages
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|ttm
operator|->
name|page_flags
argument_list|,
name|ttm
operator|->
name|caching_state
argument_list|)
expr_stmt|;
block|}
block|}
name|ttm
operator|->
name|state
operator|=
name|tt_unpopulated
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXXKIB sysctl */
end_comment

begin_endif
unit|int ttm_page_alloc_debugfs(struct seq_file *m, void *data) { 	struct ttm_page_pool *p; 	unsigned i; 	char *h[] = {"pool", "refills", "pages freed", "size"}; 	if (!_manager) { 		seq_printf(m, "No pool allocator running.\n"); 		return 0; 	} 	seq_printf(m, "%6s %12s %13s %8s\n", 			h[0], h[1], h[2], h[3]); 	for (i = 0; i< NUM_POOLS; ++i) { 		p =&_manager->pools[i];  		seq_printf(m, "%6s %12ld %13ld %8d\n", 				p->name, p->nrefills, 				p->nfrees, p->npages); 	} 	return 0; }
endif|#
directive|endif
end_endif

end_unit

