begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *  * Authors: RafaÅ MiÅecki<zajec5@gmail.com>  *          Alex Deucher<alexdeucher@gmail.com>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|"radeon.h"
end_include

begin_include
include|#
directive|include
file|"avivod.h"
end_include

begin_include
include|#
directive|include
file|"atom.h"
end_include

begin_define
define|#
directive|define
name|RADEON_IDLE_LOOP_MS
value|100
end_define

begin_define
define|#
directive|define
name|RADEON_RECLOCK_DELAY_MS
value|200
end_define

begin_define
define|#
directive|define
name|RADEON_WAIT_VBLANK_TIMEOUT
value|200
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|radeon_pm_state_type_name
index|[
literal|5
index|]
init|=
block|{
literal|""
block|,
literal|"Powersave"
block|,
literal|"Battery"
block|,
literal|"Balanced"
block|,
literal|"Performance"
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
end_ifdef

begin_function_decl
specifier|static
name|void
name|radeon_dynpm_idle_work_handler
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DUMBBELL_WIP */
end_comment

begin_function_decl
specifier|static
name|int
name|radeon_debugfs_pm_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|radeon_pm_in_vbl
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|radeon_pm_debug_check_in_vbl
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|bool
name|finish
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|radeon_pm_update_profile
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|radeon_pm_set_clocks
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|radeon_pm_get_type_index
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|enum
name|radeon_pm_state_type
name|ps_type
parameter_list|,
name|int
name|instance
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|found_instance
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdev
operator|->
name|pm
operator|.
name|num_power_states
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|power_state
index|[
name|i
index|]
operator|.
name|type
operator|==
name|ps_type
condition|)
block|{
name|found_instance
operator|++
expr_stmt|;
if|if
condition|(
name|found_instance
operator|==
name|instance
condition|)
return|return
name|i
return|;
block|}
block|}
comment|/* return default if no match */
return|return
name|rdev
operator|->
name|pm
operator|.
name|default_power_state_index
return|;
block|}
end_function

begin_function
name|void
name|radeon_pm_acpi_event_handler
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|pm_method
operator|==
name|PM_METHOD_PROFILE
condition|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|profile
operator|==
name|PM_PROFILE_AUTO
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|radeon_pm_update_profile
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_pm_set_clocks
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_pm_update_profile
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
switch|switch
condition|(
name|rdev
operator|->
name|pm
operator|.
name|profile
condition|)
block|{
case|case
name|PM_PROFILE_DEFAULT
case|:
name|rdev
operator|->
name|pm
operator|.
name|profile_index
operator|=
name|PM_PROFILE_DEFAULT_IDX
expr_stmt|;
break|break;
case|case
name|PM_PROFILE_AUTO
case|:
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
if|if
condition|(
name|power_supply_is_system_supplied
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|active_crtc_count
operator|>
literal|1
condition|)
name|rdev
operator|->
name|pm
operator|.
name|profile_index
operator|=
name|PM_PROFILE_HIGH_MH_IDX
expr_stmt|;
else|else
name|rdev
operator|->
name|pm
operator|.
name|profile_index
operator|=
name|PM_PROFILE_HIGH_SH_IDX
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|active_crtc_count
operator|>
literal|1
condition|)
name|rdev
operator|->
name|pm
operator|.
name|profile_index
operator|=
name|PM_PROFILE_MID_MH_IDX
expr_stmt|;
else|else
name|rdev
operator|->
name|pm
operator|.
name|profile_index
operator|=
name|PM_PROFILE_MID_SH_IDX
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
break|break;
case|case
name|PM_PROFILE_LOW
case|:
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|active_crtc_count
operator|>
literal|1
condition|)
name|rdev
operator|->
name|pm
operator|.
name|profile_index
operator|=
name|PM_PROFILE_LOW_MH_IDX
expr_stmt|;
else|else
name|rdev
operator|->
name|pm
operator|.
name|profile_index
operator|=
name|PM_PROFILE_LOW_SH_IDX
expr_stmt|;
break|break;
case|case
name|PM_PROFILE_MID
case|:
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|active_crtc_count
operator|>
literal|1
condition|)
name|rdev
operator|->
name|pm
operator|.
name|profile_index
operator|=
name|PM_PROFILE_MID_MH_IDX
expr_stmt|;
else|else
name|rdev
operator|->
name|pm
operator|.
name|profile_index
operator|=
name|PM_PROFILE_MID_SH_IDX
expr_stmt|;
break|break;
case|case
name|PM_PROFILE_HIGH
case|:
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|active_crtc_count
operator|>
literal|1
condition|)
name|rdev
operator|->
name|pm
operator|.
name|profile_index
operator|=
name|PM_PROFILE_HIGH_MH_IDX
expr_stmt|;
else|else
name|rdev
operator|->
name|pm
operator|.
name|profile_index
operator|=
name|PM_PROFILE_HIGH_SH_IDX
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|active_crtc_count
operator|==
literal|0
condition|)
block|{
name|rdev
operator|->
name|pm
operator|.
name|requested_power_state_index
operator|=
name|rdev
operator|->
name|pm
operator|.
name|profiles
index|[
name|rdev
operator|->
name|pm
operator|.
name|profile_index
index|]
operator|.
name|dpms_off_ps_idx
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|requested_clock_mode_index
operator|=
name|rdev
operator|->
name|pm
operator|.
name|profiles
index|[
name|rdev
operator|->
name|pm
operator|.
name|profile_index
index|]
operator|.
name|dpms_off_cm_idx
expr_stmt|;
block|}
else|else
block|{
name|rdev
operator|->
name|pm
operator|.
name|requested_power_state_index
operator|=
name|rdev
operator|->
name|pm
operator|.
name|profiles
index|[
name|rdev
operator|->
name|pm
operator|.
name|profile_index
index|]
operator|.
name|dpms_on_ps_idx
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|requested_clock_mode_index
operator|=
name|rdev
operator|->
name|pm
operator|.
name|profiles
index|[
name|rdev
operator|->
name|pm
operator|.
name|profile_index
index|]
operator|.
name|dpms_on_cm_idx
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_unmap_vram_bos
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|struct
name|radeon_bo
modifier|*
name|bo
decl_stmt|,
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|rdev
operator|->
name|gem
operator|.
name|objects
argument_list|)
condition|)
return|return;
name|list_for_each_entry_safe
argument_list|(
argument|bo
argument_list|,
argument|n
argument_list|,
argument|&rdev->gem.objects
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|bo
operator|->
name|tbo
operator|.
name|mem
operator|.
name|mem_type
operator|==
name|TTM_PL_VRAM
condition|)
name|ttm_bo_unmap_virtual
argument_list|(
operator|&
name|bo
operator|->
name|tbo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_sync_with_vblank
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|active_crtcs
condition|)
block|{
name|rdev
operator|->
name|pm
operator|.
name|vblank_sync
operator|=
name|false
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|wait_event_timeout
argument_list|(
name|rdev
operator|->
name|irq
operator|.
name|vblank_queue
argument_list|,
name|rdev
operator|->
name|pm
operator|.
name|vblank_sync
argument_list|,
name|msecs_to_jiffies
argument_list|(
name|RADEON_WAIT_VBLANK_TIMEOUT
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_set_power_state
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|u32
name|sclk
decl_stmt|,
name|mclk
decl_stmt|;
name|bool
name|misc_after
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|(
name|rdev
operator|->
name|pm
operator|.
name|requested_clock_mode_index
operator|==
name|rdev
operator|->
name|pm
operator|.
name|current_clock_mode_index
operator|)
operator|&&
operator|(
name|rdev
operator|->
name|pm
operator|.
name|requested_power_state_index
operator|==
name|rdev
operator|->
name|pm
operator|.
name|current_power_state_index
operator|)
condition|)
return|return;
if|if
condition|(
name|radeon_gui_idle
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|sclk
operator|=
name|rdev
operator|->
name|pm
operator|.
name|power_state
index|[
name|rdev
operator|->
name|pm
operator|.
name|requested_power_state_index
index|]
operator|.
name|clock_info
index|[
name|rdev
operator|->
name|pm
operator|.
name|requested_clock_mode_index
index|]
operator|.
name|sclk
expr_stmt|;
if|if
condition|(
name|sclk
operator|>
name|rdev
operator|->
name|pm
operator|.
name|default_sclk
condition|)
name|sclk
operator|=
name|rdev
operator|->
name|pm
operator|.
name|default_sclk
expr_stmt|;
comment|/* starting with BTC, there is one state that is used for both 		 * MH and SH.  Difference is that we always use the high clock index for 		 * mclk. 		 */
if|if
condition|(
operator|(
name|rdev
operator|->
name|pm
operator|.
name|pm_method
operator|==
name|PM_METHOD_PROFILE
operator|)
operator|&&
operator|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_BARTS
operator|)
operator|&&
name|rdev
operator|->
name|pm
operator|.
name|active_crtc_count
operator|&&
operator|(
operator|(
name|rdev
operator|->
name|pm
operator|.
name|profile_index
operator|==
name|PM_PROFILE_MID_MH_IDX
operator|)
operator|||
operator|(
name|rdev
operator|->
name|pm
operator|.
name|profile_index
operator|==
name|PM_PROFILE_LOW_MH_IDX
operator|)
operator|)
condition|)
name|mclk
operator|=
name|rdev
operator|->
name|pm
operator|.
name|power_state
index|[
name|rdev
operator|->
name|pm
operator|.
name|requested_power_state_index
index|]
operator|.
name|clock_info
index|[
name|rdev
operator|->
name|pm
operator|.
name|profiles
index|[
name|PM_PROFILE_HIGH_MH_IDX
index|]
operator|.
name|dpms_on_cm_idx
index|]
operator|.
name|mclk
expr_stmt|;
else|else
name|mclk
operator|=
name|rdev
operator|->
name|pm
operator|.
name|power_state
index|[
name|rdev
operator|->
name|pm
operator|.
name|requested_power_state_index
index|]
operator|.
name|clock_info
index|[
name|rdev
operator|->
name|pm
operator|.
name|requested_clock_mode_index
index|]
operator|.
name|mclk
expr_stmt|;
if|if
condition|(
name|mclk
operator|>
name|rdev
operator|->
name|pm
operator|.
name|default_mclk
condition|)
name|mclk
operator|=
name|rdev
operator|->
name|pm
operator|.
name|default_mclk
expr_stmt|;
comment|/* upvolt before raising clocks, downvolt after lowering clocks */
if|if
condition|(
name|sclk
operator|<
name|rdev
operator|->
name|pm
operator|.
name|current_sclk
condition|)
name|misc_after
operator|=
name|true
expr_stmt|;
name|radeon_sync_with_vblank
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|pm_method
operator|==
name|PM_METHOD_DYNPM
condition|)
block|{
if|if
condition|(
operator|!
name|radeon_pm_in_vbl
argument_list|(
name|rdev
argument_list|)
condition|)
return|return;
block|}
name|radeon_pm_prepare
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|misc_after
condition|)
comment|/* voltage, pcie lanes, etc.*/
name|radeon_pm_misc
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
comment|/* set engine clock */
if|if
condition|(
name|sclk
operator|!=
name|rdev
operator|->
name|pm
operator|.
name|current_sclk
condition|)
block|{
name|radeon_pm_debug_check_in_vbl
argument_list|(
name|rdev
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|radeon_set_engine_clock
argument_list|(
name|rdev
argument_list|,
name|sclk
argument_list|)
expr_stmt|;
name|radeon_pm_debug_check_in_vbl
argument_list|(
name|rdev
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|current_sclk
operator|=
name|sclk
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"Setting: e: %d\n"
argument_list|,
name|sclk
argument_list|)
expr_stmt|;
block|}
comment|/* set memory clock */
if|if
condition|(
name|rdev
operator|->
name|asic
operator|->
name|pm
operator|.
name|set_memory_clock
operator|&&
operator|(
name|mclk
operator|!=
name|rdev
operator|->
name|pm
operator|.
name|current_mclk
operator|)
condition|)
block|{
name|radeon_pm_debug_check_in_vbl
argument_list|(
name|rdev
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|radeon_set_memory_clock
argument_list|(
name|rdev
argument_list|,
name|mclk
argument_list|)
expr_stmt|;
name|radeon_pm_debug_check_in_vbl
argument_list|(
name|rdev
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|current_mclk
operator|=
name|mclk
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"Setting: m: %d\n"
argument_list|,
name|mclk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|misc_after
condition|)
comment|/* voltage, pcie lanes, etc.*/
name|radeon_pm_misc
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_pm_finish
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|current_power_state_index
operator|=
name|rdev
operator|->
name|pm
operator|.
name|requested_power_state_index
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|current_clock_mode_index
operator|=
name|rdev
operator|->
name|pm
operator|.
name|requested_clock_mode_index
expr_stmt|;
block|}
else|else
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"pm: GUI not idle!!!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_pm_set_clocks
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
comment|/* no need to take locks, etc. if nothing's going to change */
if|if
condition|(
operator|(
name|rdev
operator|->
name|pm
operator|.
name|requested_clock_mode_index
operator|==
name|rdev
operator|->
name|pm
operator|.
name|current_clock_mode_index
operator|)
operator|&&
operator|(
name|rdev
operator|->
name|pm
operator|.
name|requested_power_state_index
operator|==
name|rdev
operator|->
name|pm
operator|.
name|current_power_state_index
operator|)
condition|)
return|return;
name|DRM_LOCK
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mclk_lock
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
comment|/* wait for the rings to drain */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|radeon_ring
modifier|*
name|ring
init|=
operator|&
name|rdev
operator|->
name|ring
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ring
operator|->
name|ready
condition|)
block|{
continue|continue;
block|}
name|r
operator|=
name|radeon_fence_wait_empty_locked
argument_list|(
name|rdev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
comment|/* needs a GPU reset dont reset here */
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mclk_lock
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|radeon_unmap_vram_bos
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|irq
operator|.
name|installed
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdev
operator|->
name|num_crtc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|active_crtcs
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|rdev
operator|->
name|pm
operator|.
name|req_vblank
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|drm_vblank_get
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|radeon_set_power_state
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|irq
operator|.
name|installed
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdev
operator|->
name|num_crtc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|req_vblank
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|rdev
operator|->
name|pm
operator|.
name|req_vblank
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|drm_vblank_put
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* update display watermarks based on new power state */
name|radeon_update_bandwidth_info
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|active_crtc_count
condition|)
name|radeon_bandwidth_update
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|=
name|DYNPM_ACTION_NONE
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mclk_lock
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_pm_print_states
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|radeon_power_state
modifier|*
name|power_state
decl_stmt|;
name|struct
name|radeon_pm_clock_info
modifier|*
name|clock_info
decl_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"%d Power State(s)\n"
argument_list|,
name|rdev
operator|->
name|pm
operator|.
name|num_power_states
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdev
operator|->
name|pm
operator|.
name|num_power_states
condition|;
name|i
operator|++
control|)
block|{
name|power_state
operator|=
operator|&
name|rdev
operator|->
name|pm
operator|.
name|power_state
index|[
name|i
index|]
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"State %d: %s\n"
argument_list|,
name|i
argument_list|,
name|radeon_pm_state_type_name
index|[
name|power_state
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|rdev
operator|->
name|pm
operator|.
name|default_power_state_index
condition|)
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"\tDefault"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_PCIE
operator|)
operator|&&
operator|!
operator|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_IGP
operator|)
condition|)
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"\t%d PCIE Lanes\n"
argument_list|,
name|power_state
operator|->
name|pcie_lanes
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_state
operator|->
name|flags
operator|&
name|RADEON_PM_STATE_SINGLE_DISPLAY_ONLY
condition|)
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"\tSingle display only\n"
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"\t%d Clock Mode(s)\n"
argument_list|,
name|power_state
operator|->
name|num_clock_modes
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|power_state
operator|->
name|num_clock_modes
condition|;
name|j
operator|++
control|)
block|{
name|clock_info
operator|=
operator|&
operator|(
name|power_state
operator|->
name|clock_info
index|[
name|j
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_IGP
condition|)
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"\t\t%d e: %d\n"
argument_list|,
name|j
argument_list|,
name|clock_info
operator|->
name|sclk
operator|*
literal|10
argument_list|)
expr_stmt|;
else|else
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"\t\t%d e: %d\tm: %d\tv: %d\n"
argument_list|,
name|j
argument_list|,
name|clock_info
operator|->
name|sclk
operator|*
literal|10
argument_list|,
name|clock_info
operator|->
name|mclk
operator|*
literal|10
argument_list|,
name|clock_info
operator|->
name|voltage
operator|.
name|voltage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
end_ifdef

begin_function
specifier|static
name|ssize_t
name|radeon_get_pm_profile
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|ddev
init|=
name|pci_get_drvdata
argument_list|(
name|to_pci_dev
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|ddev
operator|->
name|dev_private
decl_stmt|;
name|int
name|cp
init|=
name|rdev
operator|->
name|pm
operator|.
name|profile
decl_stmt|;
return|return
name|snprintf
argument_list|(
name|buf
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|"%s\n"
argument_list|,
operator|(
name|cp
operator|==
name|PM_PROFILE_AUTO
operator|)
condition|?
literal|"auto"
else|:
operator|(
name|cp
operator|==
name|PM_PROFILE_LOW
operator|)
condition|?
literal|"low"
else|:
operator|(
name|cp
operator|==
name|PM_PROFILE_MID
operator|)
condition|?
literal|"mid"
else|:
operator|(
name|cp
operator|==
name|PM_PROFILE_HIGH
operator|)
condition|?
literal|"high"
else|:
literal|"default"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|radeon_set_pm_profile
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|ddev
init|=
name|pci_get_drvdata
argument_list|(
name|to_pci_dev
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|ddev
operator|->
name|dev_private
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|pm_method
operator|==
name|PM_METHOD_PROFILE
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
literal|"default"
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
literal|"default"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|rdev
operator|->
name|pm
operator|.
name|profile
operator|=
name|PM_PROFILE_DEFAULT
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
literal|"auto"
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
literal|"auto"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|rdev
operator|->
name|pm
operator|.
name|profile
operator|=
name|PM_PROFILE_AUTO
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
literal|"low"
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
literal|"low"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|rdev
operator|->
name|pm
operator|.
name|profile
operator|=
name|PM_PROFILE_LOW
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
literal|"mid"
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
literal|"mid"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|rdev
operator|->
name|pm
operator|.
name|profile
operator|=
name|PM_PROFILE_MID
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
literal|"high"
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
literal|"high"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|rdev
operator|->
name|pm
operator|.
name|profile
operator|=
name|PM_PROFILE_HIGH
expr_stmt|;
else|else
block|{
name|count
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|radeon_pm_update_profile
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_pm_set_clocks
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
else|else
name|count
operator|=
operator|-
name|EINVAL
expr_stmt|;
name|fail
label|:
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|radeon_get_pm_method
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|ddev
init|=
name|pci_get_drvdata
argument_list|(
name|to_pci_dev
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|ddev
operator|->
name|dev_private
decl_stmt|;
name|int
name|pm
init|=
name|rdev
operator|->
name|pm
operator|.
name|pm_method
decl_stmt|;
return|return
name|snprintf
argument_list|(
name|buf
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|"%s\n"
argument_list|,
operator|(
name|pm
operator|==
name|PM_METHOD_DYNPM
operator|)
condition|?
literal|"dynpm"
else|:
literal|"profile"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|radeon_set_pm_method
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|ddev
init|=
name|pci_get_drvdata
argument_list|(
name|to_pci_dev
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|ddev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|"dynpm"
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
literal|"dynpm"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|pm_method
operator|=
name|PM_METHOD_DYNPM
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|=
name|DYNPM_STATE_PAUSED
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|=
name|DYNPM_ACTION_DEFAULT
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
literal|"profile"
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
literal|"profile"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
comment|/* disable dynpm */
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|=
name|DYNPM_STATE_DISABLED
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|=
name|DYNPM_ACTION_NONE
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|pm_method
operator|=
name|PM_METHOD_PROFILE
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|cancel_delayed_work_sync
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|dynpm_idle_work
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
block|}
else|else
block|{
name|count
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|radeon_pm_compute_clocks
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
name|count
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|DEVICE_ATTR
argument_list|(
name|power_profile
argument_list|,
name|S_IRUGO
operator||
name|S_IWUSR
argument_list|,
name|radeon_get_pm_profile
argument_list|,
name|radeon_set_pm_profile
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|DEVICE_ATTR
argument_list|(
name|power_method
argument_list|,
name|S_IRUGO
operator||
name|S_IWUSR
argument_list|,
name|radeon_get_pm_method
argument_list|,
name|radeon_set_pm_method
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|ssize_t
name|radeon_hwmon_show_temp
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|ddev
init|=
name|pci_get_drvdata
argument_list|(
name|to_pci_dev
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|ddev
operator|->
name|dev_private
decl_stmt|;
name|int
name|temp
decl_stmt|;
switch|switch
condition|(
name|rdev
operator|->
name|pm
operator|.
name|int_thermal_type
condition|)
block|{
case|case
name|THERMAL_TYPE_RV6XX
case|:
name|temp
operator|=
name|rv6xx_get_temp
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
break|break;
case|case
name|THERMAL_TYPE_RV770
case|:
name|temp
operator|=
name|rv770_get_temp
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
break|break;
case|case
name|THERMAL_TYPE_EVERGREEN
case|:
case|case
name|THERMAL_TYPE_NI
case|:
name|temp
operator|=
name|evergreen_get_temp
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
break|break;
case|case
name|THERMAL_TYPE_SUMO
case|:
name|temp
operator|=
name|sumo_get_temp
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
break|break;
case|case
name|THERMAL_TYPE_SI
case|:
name|temp
operator|=
name|si_get_temp
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
break|break;
default|default:
name|temp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|snprintf
argument_list|(
name|buf
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|"%d\n"
argument_list|,
name|temp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|radeon_hwmon_show_name
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"radeon\n"
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|SENSOR_DEVICE_ATTR
argument_list|(
name|temp1_input
argument_list|,
name|S_IRUGO
argument_list|,
name|radeon_hwmon_show_temp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SENSOR_DEVICE_ATTR
argument_list|(
name|name
argument_list|,
name|S_IRUGO
argument_list|,
name|radeon_hwmon_show_name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|attribute
modifier|*
name|hwmon_attributes
index|[]
init|=
block|{
operator|&
name|sensor_dev_attr_temp1_input
operator|.
name|dev_attr
operator|.
name|attr
block|,
operator|&
name|sensor_dev_attr_name
operator|.
name|dev_attr
operator|.
name|attr
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|attribute_group
name|hwmon_attrgroup
init|=
block|{
operator|.
name|attrs
operator|=
name|hwmon_attributes
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DUMBBELL_WIP */
end_comment

begin_function
specifier|static
name|int
name|radeon_hwmon_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|rdev
operator|->
name|pm
operator|.
name|int_hwmon_dev
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
switch|switch
condition|(
name|rdev
operator|->
name|pm
operator|.
name|int_thermal_type
condition|)
block|{
case|case
name|THERMAL_TYPE_RV6XX
case|:
case|case
name|THERMAL_TYPE_RV770
case|:
case|case
name|THERMAL_TYPE_EVERGREEN
case|:
case|case
name|THERMAL_TYPE_NI
case|:
case|case
name|THERMAL_TYPE_SUMO
case|:
case|case
name|THERMAL_TYPE_SI
case|:
comment|/* No support for TN yet */
if|if
condition|(
name|rdev
operator|->
name|family
operator|==
name|CHIP_ARUBA
condition|)
return|return
name|err
return|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|rdev
operator|->
name|pm
operator|.
name|int_hwmon_dev
operator|=
name|hwmon_device_register
argument_list|(
name|rdev
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|rdev
operator|->
name|pm
operator|.
name|int_hwmon_dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|rdev
operator|->
name|pm
operator|.
name|int_hwmon_dev
argument_list|)
expr_stmt|;
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"Unable to register hwmon device: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
name|dev_set_drvdata
argument_list|(
name|rdev
operator|->
name|pm
operator|.
name|int_hwmon_dev
argument_list|,
name|rdev
operator|->
name|ddev
argument_list|)
expr_stmt|;
name|err
operator|=
name|sysfs_create_group
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|int_hwmon_dev
operator|->
name|kobj
argument_list|,
operator|&
name|hwmon_attrgroup
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"Unable to create hwmon sysfs file: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|hwmon_device_unregister
argument_list|(
name|rdev
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
break|break;
default|default:
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_hwmon_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|int_hwmon_dev
condition|)
block|{
name|sysfs_remove_group
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|int_hwmon_dev
operator|->
name|kobj
argument_list|,
operator|&
name|hwmon_attrgroup
argument_list|)
expr_stmt|;
name|hwmon_device_unregister
argument_list|(
name|rdev
operator|->
name|pm
operator|.
name|int_hwmon_dev
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
block|}
end_function

begin_function
name|void
name|radeon_pm_suspend
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|pm_method
operator|==
name|PM_METHOD_DYNPM
condition|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|==
name|DYNPM_STATE_ACTIVE
condition|)
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|=
name|DYNPM_STATE_SUSPENDED
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|cancel_delayed_work_sync
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|dynpm_idle_work
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
block|}
end_function

begin_function
name|void
name|radeon_pm_resume
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
comment|/* set up the default clocks if the MC ucode is loaded */
if|if
condition|(
operator|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_BARTS
operator|)
operator|&&
operator|(
name|rdev
operator|->
name|family
operator|<=
name|CHIP_CAYMAN
operator|)
operator|&&
name|rdev
operator|->
name|mc_fw
condition|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|default_vddc
condition|)
name|radeon_atom_set_voltage
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|pm
operator|.
name|default_vddc
argument_list|,
name|SET_VOLTAGE_TYPE_ASIC_VDDC
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|default_vddci
condition|)
name|radeon_atom_set_voltage
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|pm
operator|.
name|default_vddci
argument_list|,
name|SET_VOLTAGE_TYPE_ASIC_VDDCI
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|default_sclk
condition|)
name|radeon_set_engine_clock
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|pm
operator|.
name|default_sclk
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|default_mclk
condition|)
name|radeon_set_memory_clock
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|pm
operator|.
name|default_mclk
argument_list|)
expr_stmt|;
block|}
comment|/* asic init will reset the default power state */
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|current_power_state_index
operator|=
name|rdev
operator|->
name|pm
operator|.
name|default_power_state_index
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|current_clock_mode_index
operator|=
literal|0
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|current_sclk
operator|=
name|rdev
operator|->
name|pm
operator|.
name|default_sclk
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|current_mclk
operator|=
name|rdev
operator|->
name|pm
operator|.
name|default_mclk
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|current_vddc
operator|=
name|rdev
operator|->
name|pm
operator|.
name|power_state
index|[
name|rdev
operator|->
name|pm
operator|.
name|default_power_state_index
index|]
operator|.
name|clock_info
index|[
literal|0
index|]
operator|.
name|voltage
operator|.
name|voltage
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|current_vddci
operator|=
name|rdev
operator|->
name|pm
operator|.
name|power_state
index|[
name|rdev
operator|->
name|pm
operator|.
name|default_power_state_index
index|]
operator|.
name|clock_info
index|[
literal|0
index|]
operator|.
name|voltage
operator|.
name|vddci
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|pm_method
operator|==
name|PM_METHOD_DYNPM
operator|&&
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|==
name|DYNPM_STATE_SUSPENDED
condition|)
block|{
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|=
name|DYNPM_STATE_ACTIVE
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|schedule_delayed_work
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|dynpm_idle_work
argument_list|,
name|msecs_to_jiffies
argument_list|(
name|RADEON_IDLE_LOOP_MS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
block|}
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|radeon_pm_compute_clocks
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|radeon_pm_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* default to profile method */
name|rdev
operator|->
name|pm
operator|.
name|pm_method
operator|=
name|PM_METHOD_PROFILE
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|profile
operator|=
name|PM_PROFILE_DEFAULT
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|=
name|DYNPM_STATE_DISABLED
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|=
name|DYNPM_ACTION_NONE
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|dynpm_can_upclock
operator|=
name|true
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|dynpm_can_downclock
operator|=
name|true
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|default_sclk
operator|=
name|rdev
operator|->
name|clock
operator|.
name|default_sclk
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|default_mclk
operator|=
name|rdev
operator|->
name|clock
operator|.
name|default_mclk
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|current_sclk
operator|=
name|rdev
operator|->
name|clock
operator|.
name|default_sclk
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|current_mclk
operator|=
name|rdev
operator|->
name|clock
operator|.
name|default_mclk
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|int_thermal_type
operator|=
name|THERMAL_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|bios
condition|)
block|{
if|if
condition|(
name|rdev
operator|->
name|is_atom_bios
condition|)
name|radeon_atombios_get_power_modes
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
else|else
name|radeon_combios_get_power_modes
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_pm_print_states
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_pm_init_profile
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
comment|/* set up the default clocks if the MC ucode is loaded */
if|if
condition|(
operator|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_BARTS
operator|)
operator|&&
operator|(
name|rdev
operator|->
name|family
operator|<=
name|CHIP_CAYMAN
operator|)
operator|&&
name|rdev
operator|->
name|mc_fw
condition|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|default_vddc
condition|)
name|radeon_atom_set_voltage
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|pm
operator|.
name|default_vddc
argument_list|,
name|SET_VOLTAGE_TYPE_ASIC_VDDC
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|default_vddci
condition|)
name|radeon_atom_set_voltage
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|pm
operator|.
name|default_vddci
argument_list|,
name|SET_VOLTAGE_TYPE_ASIC_VDDCI
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|default_sclk
condition|)
name|radeon_set_engine_clock
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|pm
operator|.
name|default_sclk
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|default_mclk
condition|)
name|radeon_set_memory_clock
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|pm
operator|.
name|default_mclk
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* set up the internal thermal sensor if applicable */
name|ret
operator|=
name|radeon_hwmon_init
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|INIT_DELAYED_WORK
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|dynpm_idle_work
argument_list|,
name|radeon_dynpm_idle_work_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|num_power_states
operator|>
literal|1
condition|)
block|{
comment|/* where's the best place to put these? */
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|ret
operator|=
name|device_create_file
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
operator|&
name|dev_attr_power_profile
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
if|if
condition|(
name|ret
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to create device file for power profile\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|ret
operator|=
name|device_create_file
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
operator|&
name|dev_attr_power_method
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
if|if
condition|(
name|ret
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to create device file for power method\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_debugfs_pm_init
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed to register debugfs file for PM!\n"
argument_list|)
expr_stmt|;
block|}
name|DRM_INFO
argument_list|(
literal|"radeon: power management initialized\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|radeon_pm_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|num_power_states
operator|>
literal|1
condition|)
block|{
name|DRM_UNLOCK
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|)
expr_stmt|;
comment|/* Work around LOR. */
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|pm_method
operator|==
name|PM_METHOD_PROFILE
condition|)
block|{
name|rdev
operator|->
name|pm
operator|.
name|profile
operator|=
name|PM_PROFILE_DEFAULT
expr_stmt|;
name|radeon_pm_update_profile
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_pm_set_clocks
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|pm_method
operator|==
name|PM_METHOD_DYNPM
condition|)
block|{
comment|/* reset default clocks */
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|=
name|DYNPM_STATE_DISABLED
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|=
name|DYNPM_ACTION_DEFAULT
expr_stmt|;
name|radeon_pm_set_clocks
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|cancel_delayed_work_sync
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|dynpm_idle_work
argument_list|)
expr_stmt|;
name|device_remove_file
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
operator|&
name|dev_attr_power_profile
argument_list|)
expr_stmt|;
name|device_remove_file
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
operator|&
name|dev_attr_power_method
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
block|}
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|power_state
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdev
operator|->
name|pm
operator|.
name|num_power_states
condition|;
operator|++
name|i
control|)
block|{
name|free
argument_list|(
name|rdev
operator|->
name|pm
operator|.
name|power_state
index|[
name|i
index|]
operator|.
name|clock_info
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rdev
operator|->
name|pm
operator|.
name|power_state
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|power_state
operator|=
name|NULL
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|num_power_states
operator|=
literal|0
expr_stmt|;
block|}
name|radeon_hwmon_fini
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|radeon_pm_compute_clocks
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|ddev
init|=
name|rdev
operator|->
name|ddev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
decl_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|num_power_states
operator|<
literal|2
condition|)
return|return;
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|active_crtcs
operator|=
literal|0
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|active_crtc_count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&ddev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
name|radeon_crtc
operator|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_crtc
operator|->
name|enabled
condition|)
block|{
name|rdev
operator|->
name|pm
operator|.
name|active_crtcs
operator||=
operator|(
literal|1
operator|<<
name|radeon_crtc
operator|->
name|crtc_id
operator|)
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|active_crtc_count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|pm_method
operator|==
name|PM_METHOD_PROFILE
condition|)
block|{
name|radeon_pm_update_profile
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_pm_set_clocks
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|pm_method
operator|==
name|PM_METHOD_DYNPM
condition|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|!=
name|DYNPM_STATE_DISABLED
condition|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|active_crtc_count
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|==
name|DYNPM_STATE_ACTIVE
condition|)
block|{
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|cancel_delayed_work
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|dynpm_idle_work
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|=
name|DYNPM_STATE_PAUSED
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|=
name|DYNPM_ACTION_DEFAULT
expr_stmt|;
name|radeon_pm_get_dynpm_state
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_pm_set_clocks
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"radeon: dynamic power management deactivated\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|active_crtc_count
operator|==
literal|1
condition|)
block|{
comment|/* TODO: Increase clocks if needed for current mode */
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|==
name|DYNPM_STATE_MINIMUM
condition|)
block|{
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|=
name|DYNPM_STATE_ACTIVE
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|=
name|DYNPM_ACTION_UPCLOCK
expr_stmt|;
name|radeon_pm_get_dynpm_state
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_pm_set_clocks
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|schedule_delayed_work
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|dynpm_idle_work
argument_list|,
name|msecs_to_jiffies
argument_list|(
name|RADEON_IDLE_LOOP_MS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
block|}
elseif|else
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|==
name|DYNPM_STATE_PAUSED
condition|)
block|{
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|=
name|DYNPM_STATE_ACTIVE
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|schedule_delayed_work
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|dynpm_idle_work
argument_list|,
name|msecs_to_jiffies
argument_list|(
name|RADEON_IDLE_LOOP_MS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"radeon: dynamic power management activated\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* count == 0 */
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|!=
name|DYNPM_STATE_MINIMUM
condition|)
block|{
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|cancel_delayed_work
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|dynpm_idle_work
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|=
name|DYNPM_STATE_MINIMUM
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|=
name|DYNPM_ACTION_MINIMUM
expr_stmt|;
name|radeon_pm_get_dynpm_state
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_pm_set_clocks
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|radeon_pm_in_vbl
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|crtc
decl_stmt|,
name|vpos
decl_stmt|,
name|hpos
decl_stmt|,
name|vbl_status
decl_stmt|;
name|bool
name|in_vbl
init|=
name|true
decl_stmt|;
comment|/* Iterate over all active crtc's. All crtc's must be in vblank, 	 * otherwise return in_vbl == false. 	 */
for|for
control|(
name|crtc
operator|=
literal|0
init|;
operator|(
name|crtc
operator|<
name|rdev
operator|->
name|num_crtc
operator|)
operator|&&
name|in_vbl
condition|;
name|crtc
operator|++
control|)
block|{
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|active_crtcs
operator|&
operator|(
literal|1
operator|<<
name|crtc
operator|)
condition|)
block|{
name|vbl_status
operator|=
name|radeon_get_crtc_scanoutpos
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|,
name|crtc
argument_list|,
operator|&
name|vpos
argument_list|,
operator|&
name|hpos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vbl_status
operator|&
name|DRM_SCANOUTPOS_VALID
operator|)
operator|&&
operator|!
operator|(
name|vbl_status
operator|&
name|DRM_SCANOUTPOS_INVBL
operator|)
condition|)
name|in_vbl
operator|=
name|false
expr_stmt|;
block|}
block|}
return|return
name|in_vbl
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|radeon_pm_debug_check_in_vbl
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|bool
name|finish
parameter_list|)
block|{
name|u32
name|stat_crtc
init|=
literal|0
decl_stmt|;
name|bool
name|in_vbl
init|=
name|radeon_pm_in_vbl
argument_list|(
name|rdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|in_vbl
operator|==
name|false
condition|)
name|DRM_DEBUG_DRIVER
argument_list|(
literal|"not in vbl for pm change %08x at %s\n"
argument_list|,
name|stat_crtc
argument_list|,
name|finish
condition|?
literal|"exit"
else|:
literal|"entry"
argument_list|)
expr_stmt|;
return|return
name|in_vbl
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
end_ifdef

begin_function
specifier|static
name|void
name|radeon_dynpm_idle_work_handler
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|int
name|resched
decl_stmt|;
name|rdev
operator|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|radeon_device
argument_list|,
name|pm
operator|.
name|dynpm_idle_work
operator|.
name|work
argument_list|)
expr_stmt|;
name|resched
operator|=
name|ttm_bo_lock_delayed_workqueue
argument_list|(
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bdev
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|dynpm_state
operator|==
name|DYNPM_STATE_ACTIVE
condition|)
block|{
name|int
name|not_processed
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|radeon_ring
modifier|*
name|ring
init|=
operator|&
name|rdev
operator|->
name|ring
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ring
operator|->
name|ready
condition|)
block|{
name|not_processed
operator|+=
name|radeon_fence_count_emitted
argument_list|(
name|rdev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_processed
operator|>=
literal|3
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|not_processed
operator|>=
literal|3
condition|)
block|{
comment|/* should upclock */
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|==
name|DYNPM_ACTION_DOWNCLOCK
condition|)
block|{
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|=
name|DYNPM_ACTION_NONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|==
name|DYNPM_ACTION_NONE
operator|&&
name|rdev
operator|->
name|pm
operator|.
name|dynpm_can_upclock
condition|)
block|{
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|=
name|DYNPM_ACTION_UPCLOCK
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|dynpm_action_timeout
operator|=
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
name|RADEON_RECLOCK_DELAY_MS
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|not_processed
operator|==
literal|0
condition|)
block|{
comment|/* should downclock */
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|==
name|DYNPM_ACTION_UPCLOCK
condition|)
block|{
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|=
name|DYNPM_ACTION_NONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|==
name|DYNPM_ACTION_NONE
operator|&&
name|rdev
operator|->
name|pm
operator|.
name|dynpm_can_downclock
condition|)
block|{
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|=
name|DYNPM_ACTION_DOWNCLOCK
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|dynpm_action_timeout
operator|=
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
name|RADEON_RECLOCK_DELAY_MS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Note, radeon_pm_set_clocks is called with static_switch set 		 * to false since we want to wait for vbl to avoid flicker. 		 */
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|dynpm_planned_action
operator|!=
name|DYNPM_ACTION_NONE
operator|&&
name|jiffies
operator|>
name|rdev
operator|->
name|pm
operator|.
name|dynpm_action_timeout
condition|)
block|{
name|radeon_pm_get_dynpm_state
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_pm_set_clocks
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
name|schedule_delayed_work
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|dynpm_idle_work
argument_list|,
name|msecs_to_jiffies
argument_list|(
name|RADEON_IDLE_LOOP_MS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|ttm_bo_unlock_delayed_workqueue
argument_list|(
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bdev
argument_list|,
name|resched
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DUMBBELL_WIP */
end_comment

begin_comment
comment|/*  * Debugfs info  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DEBUG_FS
argument_list|)
end_if

begin_function
specifier|static
name|int
name|radeon_debugfs_pm_info
parameter_list|(
name|struct
name|seq_file
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|drm_info_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|drm_info_node
operator|*
operator|)
name|m
operator|->
name|private
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|node
operator|->
name|minor
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"default engine clock: %u0 kHz\n"
argument_list|,
name|rdev
operator|->
name|pm
operator|.
name|default_sclk
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"current engine clock: %u0 kHz\n"
argument_list|,
name|radeon_get_engine_clock
argument_list|(
name|rdev
argument_list|)
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"default memory clock: %u0 kHz\n"
argument_list|,
name|rdev
operator|->
name|pm
operator|.
name|default_mclk
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|asic
operator|->
name|pm
operator|.
name|get_memory_clock
condition|)
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"current memory clock: %u0 kHz\n"
argument_list|,
name|radeon_get_memory_clock
argument_list|(
name|rdev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|pm
operator|.
name|current_vddc
condition|)
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"voltage: %u mV\n"
argument_list|,
name|rdev
operator|->
name|pm
operator|.
name|current_vddc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|asic
operator|->
name|pm
operator|.
name|get_pcie_lanes
condition|)
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"PCIE lanes: %d\n"
argument_list|,
name|radeon_get_pcie_lanes
argument_list|(
name|rdev
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|drm_info_list
name|radeon_pm_info_list
index|[]
init|=
block|{
block|{
literal|"radeon_pm_info"
block|,
name|radeon_debugfs_pm_info
block|,
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|radeon_debugfs_pm_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DEBUG_FS
argument_list|)
return|return
name|radeon_debugfs_add_files
argument_list|(
name|rdev
argument_list|,
name|radeon_pm_info_list
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|radeon_pm_info_list
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

end_unit

