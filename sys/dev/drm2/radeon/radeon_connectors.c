begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2007-8 Advanced Micro Devices, Inc.  * Copyright 2008 Red Hat Inc.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *  * Authors: Dave Airlie  *          Alex Deucher  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_edid.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc_helper.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_fb_helper.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/radeon/radeon_drm.h>
end_include

begin_include
include|#
directive|include
file|"radeon.h"
end_include

begin_include
include|#
directive|include
file|"atom.h"
end_include

begin_function
name|void
name|radeon_connector_hotplug
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
comment|/* bail if the connector does not have hpd pin, e.g., 	 * VGA, TV, etc. 	 */
if|if
condition|(
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
operator|==
name|RADEON_HPD_NONE
condition|)
return|return;
name|radeon_hpd_set_polarity
argument_list|(
name|rdev
argument_list|,
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
argument_list|)
expr_stmt|;
comment|/* if the connector is already off, don't turn it back on */
if|if
condition|(
name|connector
operator|->
name|dpms
operator|!=
name|DRM_MODE_DPMS_ON
condition|)
return|return;
comment|/* just deal with DP (not eDP) here. */
if|if
condition|(
name|connector
operator|->
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_DisplayPort
condition|)
block|{
name|struct
name|radeon_connector_atom_dig
modifier|*
name|dig_connector
init|=
name|radeon_connector
operator|->
name|con_priv
decl_stmt|;
comment|/* if existing sink type was not DP no need to retrain */
if|if
condition|(
name|dig_connector
operator|->
name|dp_sink_type
operator|!=
name|CONNECTOR_OBJECT_ID_DISPLAYPORT
condition|)
return|return;
comment|/* first get sink type as it may be reset after (un)plug */
name|dig_connector
operator|->
name|dp_sink_type
operator|=
name|radeon_dp_getsinktype
argument_list|(
name|radeon_connector
argument_list|)
expr_stmt|;
comment|/* don't do anything if sink is not display port, i.e., 		 * passive dp->(dvi|hdmi) adaptor 		 */
if|if
condition|(
name|dig_connector
operator|->
name|dp_sink_type
operator|==
name|CONNECTOR_OBJECT_ID_DISPLAYPORT
condition|)
block|{
name|int
name|saved_dpms
init|=
name|connector
operator|->
name|dpms
decl_stmt|;
comment|/* Only turn off the display if it's physically disconnected */
if|if
condition|(
operator|!
name|radeon_hpd_sense
argument_list|(
name|rdev
argument_list|,
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
argument_list|)
condition|)
block|{
name|drm_helper_connector_dpms
argument_list|(
name|connector
argument_list|,
name|DRM_MODE_DPMS_OFF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|radeon_dp_needs_link_train
argument_list|(
name|radeon_connector
argument_list|)
condition|)
block|{
comment|/* set it to OFF so that drm_helper_connector_dpms() 				 * won't return immediately since the current state 				 * is ON at this point. 				 */
name|connector
operator|->
name|dpms
operator|=
name|DRM_MODE_DPMS_OFF
expr_stmt|;
name|drm_helper_connector_dpms
argument_list|(
name|connector
argument_list|,
name|DRM_MODE_DPMS_ON
argument_list|)
expr_stmt|;
block|}
name|connector
operator|->
name|dpms
operator|=
name|saved_dpms
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_property_change_mode
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|encoder
operator|->
name|crtc
decl_stmt|;
if|if
condition|(
name|crtc
operator|&&
name|crtc
operator|->
name|enabled
condition|)
block|{
name|drm_crtc_helper_set_mode
argument_list|(
name|crtc
argument_list|,
operator|&
name|crtc
operator|->
name|mode
argument_list|,
name|crtc
operator|->
name|x
argument_list|,
name|crtc
operator|->
name|y
argument_list|,
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|radeon_get_monitor_bpc
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|radeon_connector_atom_dig
modifier|*
name|dig_connector
decl_stmt|;
name|int
name|bpc
init|=
literal|8
decl_stmt|;
switch|switch
condition|(
name|connector
operator|->
name|connector_type
condition|)
block|{
case|case
name|DRM_MODE_CONNECTOR_DVII
case|:
case|case
name|DRM_MODE_CONNECTOR_HDMIB
case|:
if|if
condition|(
name|radeon_connector
operator|->
name|use_digital
condition|)
block|{
if|if
condition|(
name|drm_detect_hdmi_monitor
argument_list|(
name|radeon_connector
operator|->
name|edid
argument_list|)
condition|)
block|{
if|if
condition|(
name|connector
operator|->
name|display_info
operator|.
name|bpc
condition|)
name|bpc
operator|=
name|connector
operator|->
name|display_info
operator|.
name|bpc
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DRM_MODE_CONNECTOR_DVID
case|:
case|case
name|DRM_MODE_CONNECTOR_HDMIA
case|:
if|if
condition|(
name|drm_detect_hdmi_monitor
argument_list|(
name|radeon_connector
operator|->
name|edid
argument_list|)
condition|)
block|{
if|if
condition|(
name|connector
operator|->
name|display_info
operator|.
name|bpc
condition|)
name|bpc
operator|=
name|connector
operator|->
name|display_info
operator|.
name|bpc
expr_stmt|;
block|}
break|break;
case|case
name|DRM_MODE_CONNECTOR_DisplayPort
case|:
name|dig_connector
operator|=
name|radeon_connector
operator|->
name|con_priv
expr_stmt|;
if|if
condition|(
operator|(
name|dig_connector
operator|->
name|dp_sink_type
operator|==
name|CONNECTOR_OBJECT_ID_DISPLAYPORT
operator|)
operator|||
operator|(
name|dig_connector
operator|->
name|dp_sink_type
operator|==
name|CONNECTOR_OBJECT_ID_eDP
operator|)
operator|||
name|drm_detect_hdmi_monitor
argument_list|(
name|radeon_connector
operator|->
name|edid
argument_list|)
condition|)
block|{
if|if
condition|(
name|connector
operator|->
name|display_info
operator|.
name|bpc
condition|)
name|bpc
operator|=
name|connector
operator|->
name|display_info
operator|.
name|bpc
expr_stmt|;
block|}
break|break;
case|case
name|DRM_MODE_CONNECTOR_eDP
case|:
case|case
name|DRM_MODE_CONNECTOR_LVDS
case|:
if|if
condition|(
name|connector
operator|->
name|display_info
operator|.
name|bpc
condition|)
name|bpc
operator|=
name|connector
operator|->
name|display_info
operator|.
name|bpc
expr_stmt|;
elseif|else
if|if
condition|(
name|ASIC_IS_DCE41
argument_list|(
name|rdev
argument_list|)
operator|||
name|ASIC_IS_DCE5
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|struct
name|drm_connector_helper_funcs
modifier|*
name|connector_funcs
init|=
name|connector
operator|->
name|helper_private
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
name|connector_funcs
operator|->
name|best_encoder
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
if|if
condition|(
name|dig
operator|->
name|lcd_misc
operator|&
name|ATOM_PANEL_MISC_V13_6BIT_PER_COLOR
condition|)
name|bpc
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|dig
operator|->
name|lcd_misc
operator|&
name|ATOM_PANEL_MISC_V13_8BIT_PER_COLOR
condition|)
name|bpc
operator|=
literal|8
expr_stmt|;
block|}
break|break;
block|}
return|return
name|bpc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_connector_update_scratch_regs
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|enum
name|drm_connector_status
name|status
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|best_encoder
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_connector_helper_funcs
modifier|*
name|connector_funcs
init|=
name|connector
operator|->
name|helper_private
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|bool
name|connected
decl_stmt|;
name|int
name|i
decl_stmt|;
name|best_encoder
operator|=
name|connector_funcs
operator|->
name|best_encoder
argument_list|(
name|connector
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_ENCODER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|connector
operator|->
name|dev
argument_list|,
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
argument_list|,
name|DRM_MODE_OBJECT_ENCODER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
continue|continue;
name|encoder
operator|=
name|obj_to_encoder
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|encoder
operator|==
name|best_encoder
operator|)
operator|&&
operator|(
name|status
operator|==
name|connector_status_connected
operator|)
condition|)
name|connected
operator|=
name|true
expr_stmt|;
else|else
name|connected
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|is_atom_bios
condition|)
name|radeon_atombios_connected_scratch_regs
argument_list|(
name|connector
argument_list|,
name|encoder
argument_list|,
name|connected
argument_list|)
expr_stmt|;
else|else
name|radeon_combios_connected_scratch_regs
argument_list|(
name|connector
argument_list|,
name|encoder
argument_list|,
name|connected
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_encoder
modifier|*
name|radeon_find_encoder
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|int
name|encoder_type
parameter_list|)
block|{
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_ENCODER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|connector
operator|->
name|dev
argument_list|,
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
argument_list|,
name|DRM_MODE_OBJECT_ENCODER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
continue|continue;
name|encoder
operator|=
name|obj_to_encoder
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoder
operator|->
name|encoder_type
operator|==
name|encoder_type
condition|)
return|return
name|encoder
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_encoder
modifier|*
name|radeon_best_single_encoder
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|int
name|enc_id
init|=
name|connector
operator|->
name|encoder_ids
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
comment|/* pick the encoder ids */
if|if
condition|(
name|enc_id
condition|)
block|{
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|connector
operator|->
name|dev
argument_list|,
name|enc_id
argument_list|,
name|DRM_MODE_OBJECT_ENCODER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
return|return
name|NULL
return|;
name|encoder
operator|=
name|obj_to_encoder
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
name|encoder
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * radeon_connector_analog_encoder_conflict_solve  * - search for other connectors sharing this encoder  *   if priority is true, then set them disconnected if this is connected  *   if priority is false, set us disconnected if they are connected  */
end_comment

begin_function
specifier|static
name|enum
name|drm_connector_status
name|radeon_connector_analog_encoder_conflict_solve
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|enum
name|drm_connector_status
name|current_status
parameter_list|,
name|bool
name|priority
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|conflict
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_conflict
decl_stmt|;
name|int
name|i
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|conflict
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|conflict
operator|==
name|connector
condition|)
continue|continue;
name|radeon_conflict
operator|=
name|to_radeon_connector
argument_list|(
name|conflict
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_ENCODER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|conflict
operator|->
name|encoder_ids
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
comment|/* if the IDs match */
if|if
condition|(
name|conflict
operator|->
name|encoder_ids
index|[
name|i
index|]
operator|==
name|encoder
operator|->
name|base
operator|.
name|id
condition|)
block|{
if|if
condition|(
name|conflict
operator|->
name|status
operator|!=
name|connector_status_connected
condition|)
continue|continue;
if|if
condition|(
name|radeon_conflict
operator|->
name|use_digital
condition|)
continue|continue;
if|if
condition|(
name|priority
operator|==
name|true
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"1: conflicting encoders switching off %s\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|conflict
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"in favor of %s\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
name|conflict
operator|->
name|status
operator|=
name|connector_status_disconnected
expr_stmt|;
name|radeon_connector_update_scratch_regs
argument_list|(
name|conflict
argument_list|,
name|connector_status_disconnected
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"2: conflicting encoders switching off %s\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"in favor of %s\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|conflict
argument_list|)
argument_list|)
expr_stmt|;
name|current_status
operator|=
name|connector_status_disconnected
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|current_status
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_display_mode
modifier|*
name|radeon_fp_native_mode
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|native_mode
init|=
operator|&
name|radeon_encoder
operator|->
name|native_mode
decl_stmt|;
if|if
condition|(
name|native_mode
operator|->
name|hdisplay
operator|!=
literal|0
operator|&&
name|native_mode
operator|->
name|vdisplay
operator|!=
literal|0
operator|&&
name|native_mode
operator|->
name|clock
operator|!=
literal|0
condition|)
block|{
name|mode
operator|=
name|drm_mode_duplicate
argument_list|(
name|dev
argument_list|,
name|native_mode
argument_list|)
expr_stmt|;
name|mode
operator|->
name|type
operator|=
name|DRM_MODE_TYPE_PREFERRED
operator||
name|DRM_MODE_TYPE_DRIVER
expr_stmt|;
name|drm_mode_set_name
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Adding native panel mode %s\n"
argument_list|,
name|mode
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|native_mode
operator|->
name|hdisplay
operator|!=
literal|0
operator|&&
name|native_mode
operator|->
name|vdisplay
operator|!=
literal|0
condition|)
block|{
comment|/* mac laptops without an edid */
comment|/* Note that this is not necessarily the exact panel mode, 		 * but an approximation based on the cvt formula.  For these 		 * systems we should ideally read the mode info out of the 		 * registers or add a mode table, but this works and is much 		 * simpler. 		 */
name|mode
operator|=
name|drm_cvt_mode
argument_list|(
name|dev
argument_list|,
name|native_mode
operator|->
name|hdisplay
argument_list|,
name|native_mode
operator|->
name|vdisplay
argument_list|,
literal|60
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|mode
operator|->
name|type
operator|=
name|DRM_MODE_TYPE_PREFERRED
operator||
name|DRM_MODE_TYPE_DRIVER
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Adding cvt approximation of native panel mode %s\n"
argument_list|,
name|mode
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_add_common_modes
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|native_mode
init|=
operator|&
name|radeon_encoder
operator|->
name|native_mode
decl_stmt|;
name|int
name|i
decl_stmt|;
struct|struct
name|mode_size
block|{
name|int
name|w
decl_stmt|;
name|int
name|h
decl_stmt|;
block|}
name|common_modes
index|[
literal|17
index|]
init|=
block|{
block|{
literal|640
block|,
literal|480
block|}
block|,
block|{
literal|720
block|,
literal|480
block|}
block|,
block|{
literal|800
block|,
literal|600
block|}
block|,
block|{
literal|848
block|,
literal|480
block|}
block|,
block|{
literal|1024
block|,
literal|768
block|}
block|,
block|{
literal|1152
block|,
literal|768
block|}
block|,
block|{
literal|1280
block|,
literal|720
block|}
block|,
block|{
literal|1280
block|,
literal|800
block|}
block|,
block|{
literal|1280
block|,
literal|854
block|}
block|,
block|{
literal|1280
block|,
literal|960
block|}
block|,
block|{
literal|1280
block|,
literal|1024
block|}
block|,
block|{
literal|1440
block|,
literal|900
block|}
block|,
block|{
literal|1400
block|,
literal|1050
block|}
block|,
block|{
literal|1680
block|,
literal|1050
block|}
block|,
block|{
literal|1600
block|,
literal|1200
block|}
block|,
block|{
literal|1920
block|,
literal|1080
block|}
block|,
block|{
literal|1920
block|,
literal|1200
block|}
block|}
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|17
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|radeon_encoder
operator|->
name|devices
operator|&
operator|(
name|ATOM_DEVICE_TV_SUPPORT
operator|)
condition|)
block|{
if|if
condition|(
name|common_modes
index|[
name|i
index|]
operator|.
name|w
operator|>
literal|1024
operator|||
name|common_modes
index|[
name|i
index|]
operator|.
name|h
operator|>
literal|768
condition|)
continue|continue;
block|}
if|if
condition|(
name|radeon_encoder
operator|->
name|devices
operator|&
operator|(
name|ATOM_DEVICE_LCD_SUPPORT
operator|)
condition|)
block|{
if|if
condition|(
name|common_modes
index|[
name|i
index|]
operator|.
name|w
operator|>
name|native_mode
operator|->
name|hdisplay
operator|||
name|common_modes
index|[
name|i
index|]
operator|.
name|h
operator|>
name|native_mode
operator|->
name|vdisplay
operator|||
operator|(
name|common_modes
index|[
name|i
index|]
operator|.
name|w
operator|==
name|native_mode
operator|->
name|hdisplay
operator|&&
name|common_modes
index|[
name|i
index|]
operator|.
name|h
operator|==
name|native_mode
operator|->
name|vdisplay
operator|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|common_modes
index|[
name|i
index|]
operator|.
name|w
operator|<
literal|320
operator|||
name|common_modes
index|[
name|i
index|]
operator|.
name|h
operator|<
literal|200
condition|)
continue|continue;
name|mode
operator|=
name|drm_cvt_mode
argument_list|(
name|dev
argument_list|,
name|common_modes
index|[
name|i
index|]
operator|.
name|w
argument_list|,
name|common_modes
index|[
name|i
index|]
operator|.
name|h
argument_list|,
literal|60
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|drm_mode_probed_add
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_connector_set_property
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_property
modifier|*
name|property
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
decl_stmt|;
if|if
condition|(
name|property
operator|==
name|rdev
operator|->
name|mode_info
operator|.
name|coherent_mode_property
condition|)
block|{
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
decl_stmt|;
name|bool
name|new_coherent_mode
decl_stmt|;
comment|/* need to find digital encoder on connector */
name|encoder
operator|=
name|radeon_find_encoder
argument_list|(
name|connector
argument_list|,
name|DRM_MODE_ENCODER_TMDS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoder
condition|)
return|return
literal|0
return|;
name|radeon_encoder
operator|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_encoder
operator|->
name|enc_priv
condition|)
return|return
literal|0
return|;
name|dig
operator|=
name|radeon_encoder
operator|->
name|enc_priv
expr_stmt|;
name|new_coherent_mode
operator|=
name|val
condition|?
name|true
else|:
name|false
expr_stmt|;
if|if
condition|(
name|dig
operator|->
name|coherent_mode
operator|!=
name|new_coherent_mode
condition|)
block|{
name|dig
operator|->
name|coherent_mode
operator|=
name|new_coherent_mode
expr_stmt|;
name|radeon_property_change_mode
argument_list|(
operator|&
name|radeon_encoder
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|property
operator|==
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_property
condition|)
block|{
comment|/* need to find digital encoder on connector */
name|encoder
operator|=
name|radeon_find_encoder
argument_list|(
name|connector
argument_list|,
name|DRM_MODE_ENCODER_TMDS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoder
condition|)
return|return
literal|0
return|;
name|radeon_encoder
operator|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_encoder
operator|->
name|underscan_type
operator|!=
name|val
condition|)
block|{
name|radeon_encoder
operator|->
name|underscan_type
operator|=
name|val
expr_stmt|;
name|radeon_property_change_mode
argument_list|(
operator|&
name|radeon_encoder
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|property
operator|==
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_hborder_property
condition|)
block|{
comment|/* need to find digital encoder on connector */
name|encoder
operator|=
name|radeon_find_encoder
argument_list|(
name|connector
argument_list|,
name|DRM_MODE_ENCODER_TMDS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoder
condition|)
return|return
literal|0
return|;
name|radeon_encoder
operator|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_encoder
operator|->
name|underscan_hborder
operator|!=
name|val
condition|)
block|{
name|radeon_encoder
operator|->
name|underscan_hborder
operator|=
name|val
expr_stmt|;
name|radeon_property_change_mode
argument_list|(
operator|&
name|radeon_encoder
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|property
operator|==
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_vborder_property
condition|)
block|{
comment|/* need to find digital encoder on connector */
name|encoder
operator|=
name|radeon_find_encoder
argument_list|(
name|connector
argument_list|,
name|DRM_MODE_ENCODER_TMDS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoder
condition|)
return|return
literal|0
return|;
name|radeon_encoder
operator|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_encoder
operator|->
name|underscan_vborder
operator|!=
name|val
condition|)
block|{
name|radeon_encoder
operator|->
name|underscan_vborder
operator|=
name|val
expr_stmt|;
name|radeon_property_change_mode
argument_list|(
operator|&
name|radeon_encoder
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|property
operator|==
name|rdev
operator|->
name|mode_info
operator|.
name|tv_std_property
condition|)
block|{
name|encoder
operator|=
name|radeon_find_encoder
argument_list|(
name|connector
argument_list|,
name|DRM_MODE_ENCODER_TVDAC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoder
condition|)
block|{
name|encoder
operator|=
name|radeon_find_encoder
argument_list|(
name|connector
argument_list|,
name|DRM_MODE_ENCODER_DAC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|encoder
condition|)
return|return
literal|0
return|;
name|radeon_encoder
operator|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_encoder
operator|->
name|enc_priv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
operator|||
name|radeon_r4xx_atom
condition|)
block|{
name|struct
name|radeon_encoder_atom_dac
modifier|*
name|dac_int
decl_stmt|;
name|dac_int
operator|=
name|radeon_encoder
operator|->
name|enc_priv
expr_stmt|;
name|dac_int
operator|->
name|tv_std
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|struct
name|radeon_encoder_tv_dac
modifier|*
name|dac_int
decl_stmt|;
name|dac_int
operator|=
name|radeon_encoder
operator|->
name|enc_priv
expr_stmt|;
name|dac_int
operator|->
name|tv_std
operator|=
name|val
expr_stmt|;
block|}
name|radeon_property_change_mode
argument_list|(
operator|&
name|radeon_encoder
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|property
operator|==
name|rdev
operator|->
name|mode_info
operator|.
name|load_detect_property
condition|)
block|{
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|radeon_connector
operator|->
name|dac_load_detect
operator|=
name|false
expr_stmt|;
else|else
name|radeon_connector
operator|->
name|dac_load_detect
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|property
operator|==
name|rdev
operator|->
name|mode_info
operator|.
name|tmds_pll_property
condition|)
block|{
name|struct
name|radeon_encoder_int_tmds
modifier|*
name|tmds
init|=
name|NULL
decl_stmt|;
name|bool
name|ret
init|=
name|false
decl_stmt|;
comment|/* need to find digital encoder on connector */
name|encoder
operator|=
name|radeon_find_encoder
argument_list|(
name|connector
argument_list|,
name|DRM_MODE_ENCODER_TMDS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoder
condition|)
return|return
literal|0
return|;
name|radeon_encoder
operator|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|tmds
operator|=
name|radeon_encoder
operator|->
name|enc_priv
expr_stmt|;
if|if
condition|(
operator|!
name|tmds
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rdev
operator|->
name|is_atom_bios
condition|)
name|ret
operator|=
name|radeon_atombios_get_tmds_info
argument_list|(
name|radeon_encoder
argument_list|,
name|tmds
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|radeon_legacy_get_tmds_info_from_combios
argument_list|(
name|radeon_encoder
argument_list|,
name|tmds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
literal|1
operator|||
name|ret
operator|==
name|false
condition|)
block|{
name|radeon_legacy_get_tmds_info_from_table
argument_list|(
name|radeon_encoder
argument_list|,
name|tmds
argument_list|)
expr_stmt|;
block|}
name|radeon_property_change_mode
argument_list|(
operator|&
name|radeon_encoder
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_fixup_lvds_native_mode
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|native_mode
init|=
operator|&
name|radeon_encoder
operator|->
name|native_mode
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|t
decl_stmt|,
modifier|*
name|mode
decl_stmt|;
comment|/* If the EDID preferred mode doesn't match the native mode, use it */
name|list_for_each_entry_safe
argument_list|(
argument|mode
argument_list|,
argument|t
argument_list|,
argument|&connector->probed_modes
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|mode
operator|->
name|type
operator|&
name|DRM_MODE_TYPE_PREFERRED
condition|)
block|{
if|if
condition|(
name|mode
operator|->
name|hdisplay
operator|!=
name|native_mode
operator|->
name|hdisplay
operator|||
name|mode
operator|->
name|vdisplay
operator|!=
name|native_mode
operator|->
name|vdisplay
condition|)
name|memcpy
argument_list|(
name|native_mode
argument_list|,
name|mode
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Try to get native mode details from EDID if necessary */
if|if
condition|(
operator|!
name|native_mode
operator|->
name|clock
condition|)
block|{
name|list_for_each_entry_safe
argument_list|(
argument|mode
argument_list|,
argument|t
argument_list|,
argument|&connector->probed_modes
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|mode
operator|->
name|hdisplay
operator|==
name|native_mode
operator|->
name|hdisplay
operator|&&
name|mode
operator|->
name|vdisplay
operator|==
name|native_mode
operator|->
name|vdisplay
condition|)
block|{
operator|*
name|native_mode
operator|=
operator|*
name|mode
expr_stmt|;
name|drm_mode_set_crtcinfo
argument_list|(
name|native_mode
argument_list|,
name|CRTC_INTERLACE_HALVE_V
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Determined LVDS native mode details from EDID\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|native_mode
operator|->
name|clock
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"No LVDS native mode details, disabling RMX\n"
argument_list|)
expr_stmt|;
name|radeon_encoder
operator|->
name|rmx_type
operator|=
name|RMX_OFF
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_lvds_get_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
if|if
condition|(
name|radeon_connector
operator|->
name|ddc_bus
condition|)
block|{
name|ret
operator|=
name|radeon_ddc_get_modes
argument_list|(
name|radeon_connector
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|encoder
operator|=
name|radeon_best_single_encoder
argument_list|(
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoder
condition|)
block|{
name|radeon_fixup_lvds_native_mode
argument_list|(
name|encoder
argument_list|,
name|connector
argument_list|)
expr_stmt|;
comment|/* add scaled modes */
name|radeon_add_common_modes
argument_list|(
name|encoder
argument_list|,
name|connector
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
block|}
name|encoder
operator|=
name|radeon_best_single_encoder
argument_list|(
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoder
condition|)
return|return
literal|0
return|;
comment|/* we have no EDID modes */
name|mode
operator|=
name|radeon_fp_native_mode
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
name|drm_mode_probed_add
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* add the width/height from vbios tables if available */
name|connector
operator|->
name|display_info
operator|.
name|width_mm
operator|=
name|mode
operator|->
name|width_mm
expr_stmt|;
name|connector
operator|->
name|display_info
operator|.
name|height_mm
operator|=
name|mode
operator|->
name|height_mm
expr_stmt|;
comment|/* add scaled modes */
name|radeon_add_common_modes
argument_list|(
name|encoder
argument_list|,
name|connector
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_lvds_mode_valid
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
name|radeon_best_single_encoder
argument_list|(
name|connector
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|mode
operator|->
name|hdisplay
operator|<
literal|320
operator|)
operator|||
operator|(
name|mode
operator|->
name|vdisplay
operator|<
literal|240
operator|)
condition|)
return|return
name|MODE_PANEL
return|;
if|if
condition|(
name|encoder
condition|)
block|{
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|native_mode
init|=
operator|&
name|radeon_encoder
operator|->
name|native_mode
decl_stmt|;
comment|/* AVIVO hardware supports downscaling modes larger than the panel 		 * to the panel size, but I'm not sure this is desirable. 		 */
if|if
condition|(
operator|(
name|mode
operator|->
name|hdisplay
operator|>
name|native_mode
operator|->
name|hdisplay
operator|)
operator|||
operator|(
name|mode
operator|->
name|vdisplay
operator|>
name|native_mode
operator|->
name|vdisplay
operator|)
condition|)
return|return
name|MODE_PANEL
return|;
comment|/* if scaling is disabled, block non-native modes */
if|if
condition|(
name|radeon_encoder
operator|->
name|rmx_type
operator|==
name|RMX_OFF
condition|)
block|{
if|if
condition|(
operator|(
name|mode
operator|->
name|hdisplay
operator|!=
name|native_mode
operator|->
name|hdisplay
operator|)
operator|||
operator|(
name|mode
operator|->
name|vdisplay
operator|!=
name|native_mode
operator|->
name|vdisplay
operator|)
condition|)
return|return
name|MODE_PANEL
return|;
block|}
block|}
return|return
name|MODE_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|drm_connector_status
name|radeon_lvds_detect
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
name|radeon_best_single_encoder
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|enum
name|drm_connector_status
name|ret
init|=
name|connector_status_disconnected
decl_stmt|;
if|if
condition|(
name|encoder
condition|)
block|{
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|native_mode
init|=
operator|&
name|radeon_encoder
operator|->
name|native_mode
decl_stmt|;
comment|/* check if panel is valid */
if|if
condition|(
name|native_mode
operator|->
name|hdisplay
operator|>=
literal|320
operator|&&
name|native_mode
operator|->
name|vdisplay
operator|>=
literal|240
condition|)
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
block|}
comment|/* check for edid as well */
if|if
condition|(
name|radeon_connector
operator|->
name|edid
condition|)
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
else|else
block|{
if|if
condition|(
name|radeon_connector
operator|->
name|ddc_bus
condition|)
block|{
name|radeon_connector
operator|->
name|edid
operator|=
name|drm_get_edid
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|radeon_connector
operator|->
name|ddc_bus
operator|->
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_connector
operator|->
name|edid
condition|)
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
block|}
block|}
comment|/* check acpi lid status ??? */
name|radeon_connector_update_scratch_regs
argument_list|(
name|connector
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_connector_destroy
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
if|if
condition|(
name|radeon_connector
operator|->
name|edid
condition|)
name|free
argument_list|(
name|radeon_connector
operator|->
name|edid
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|radeon_connector
operator|->
name|con_priv
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|drm_sysfs_connector_remove
argument_list|(
name|connector
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
name|drm_connector_cleanup
argument_list|(
name|connector
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|connector
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_lvds_set_property
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_property
modifier|*
name|property
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
decl_stmt|;
name|enum
name|radeon_rmx_type
name|rmx_type
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|property
operator|!=
name|dev
operator|->
name|mode_config
operator|.
name|scaling_mode_property
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|connector
operator|->
name|encoder
condition|)
name|radeon_encoder
operator|=
name|to_radeon_encoder
argument_list|(
name|connector
operator|->
name|encoder
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|drm_connector_helper_funcs
modifier|*
name|connector_funcs
init|=
name|connector
operator|->
name|helper_private
decl_stmt|;
name|radeon_encoder
operator|=
name|to_radeon_encoder
argument_list|(
name|connector_funcs
operator|->
name|best_encoder
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|DRM_MODE_SCALE_NONE
case|:
name|rmx_type
operator|=
name|RMX_OFF
expr_stmt|;
break|break;
case|case
name|DRM_MODE_SCALE_CENTER
case|:
name|rmx_type
operator|=
name|RMX_CENTER
expr_stmt|;
break|break;
case|case
name|DRM_MODE_SCALE_ASPECT
case|:
name|rmx_type
operator|=
name|RMX_ASPECT
expr_stmt|;
break|break;
default|default:
case|case
name|DRM_MODE_SCALE_FULLSCREEN
case|:
name|rmx_type
operator|=
name|RMX_FULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|radeon_encoder
operator|->
name|rmx_type
operator|==
name|rmx_type
condition|)
return|return
literal|0
return|;
name|radeon_encoder
operator|->
name|rmx_type
operator|=
name|rmx_type
expr_stmt|;
name|radeon_property_change_mode
argument_list|(
operator|&
name|radeon_encoder
operator|->
name|base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_connector_helper_funcs
name|radeon_lvds_connector_helper_funcs
init|=
block|{
operator|.
name|get_modes
operator|=
name|radeon_lvds_get_modes
block|,
operator|.
name|mode_valid
operator|=
name|radeon_lvds_mode_valid
block|,
operator|.
name|best_encoder
operator|=
name|radeon_best_single_encoder
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_connector_funcs
name|radeon_lvds_connector_funcs
init|=
block|{
operator|.
name|dpms
operator|=
name|drm_helper_connector_dpms
block|,
operator|.
name|detect
operator|=
name|radeon_lvds_detect
block|,
operator|.
name|fill_modes
operator|=
name|drm_helper_probe_single_connector_modes
block|,
operator|.
name|destroy
operator|=
name|radeon_connector_destroy
block|,
operator|.
name|set_property
operator|=
name|radeon_lvds_set_property
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|radeon_vga_get_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|radeon_ddc_get_modes
argument_list|(
name|radeon_connector
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_vga_mode_valid
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* XXX check mode bandwidth */
if|if
condition|(
operator|(
name|mode
operator|->
name|clock
operator|/
literal|10
operator|)
operator|>
name|rdev
operator|->
name|clock
operator|.
name|max_pixel_clock
condition|)
return|return
name|MODE_CLOCK_HIGH
return|;
return|return
name|MODE_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|drm_connector_status
name|radeon_vga_detect
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
decl_stmt|;
name|bool
name|dret
init|=
name|false
decl_stmt|;
name|enum
name|drm_connector_status
name|ret
init|=
name|connector_status_disconnected
decl_stmt|;
name|encoder
operator|=
name|radeon_best_single_encoder
argument_list|(
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoder
condition|)
name|ret
operator|=
name|connector_status_disconnected
expr_stmt|;
if|if
condition|(
name|radeon_connector
operator|->
name|ddc_bus
condition|)
name|dret
operator|=
name|radeon_ddc_probe
argument_list|(
name|radeon_connector
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|dret
condition|)
block|{
name|radeon_connector
operator|->
name|detected_by_load
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|radeon_connector
operator|->
name|edid
condition|)
block|{
name|free
argument_list|(
name|radeon_connector
operator|->
name|edid
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|radeon_connector
operator|->
name|edid
operator|=
name|NULL
expr_stmt|;
block|}
name|radeon_connector
operator|->
name|edid
operator|=
name|drm_get_edid
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|radeon_connector
operator|->
name|ddc_bus
operator|->
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|edid
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"%s: probed a monitor but no|invalid EDID\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
block|}
else|else
block|{
name|radeon_connector
operator|->
name|use_digital
operator|=
operator|!
operator|!
operator|(
name|radeon_connector
operator|->
name|edid
operator|->
name|input
operator|&
name|DRM_EDID_INPUT_DIGITAL
operator|)
expr_stmt|;
comment|/* some oems have boards with separate digital and analog connectors 			 * with a shared ddc line (often vga + hdmi) 			 */
if|if
condition|(
name|radeon_connector
operator|->
name|use_digital
operator|&&
name|radeon_connector
operator|->
name|shared_ddc
condition|)
block|{
name|free
argument_list|(
name|radeon_connector
operator|->
name|edid
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|radeon_connector
operator|->
name|edid
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|connector_status_disconnected
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* if we aren't forcing don't do destructive polling */
if|if
condition|(
operator|!
name|force
condition|)
block|{
comment|/* only return the previous status if we last 			 * detected a monitor via load. 			 */
if|if
condition|(
name|radeon_connector
operator|->
name|detected_by_load
condition|)
return|return
name|connector
operator|->
name|status
return|;
else|else
return|return
name|ret
return|;
block|}
if|if
condition|(
name|radeon_connector
operator|->
name|dac_load_detect
operator|&&
name|encoder
condition|)
block|{
name|encoder_funcs
operator|=
name|encoder
operator|->
name|helper_private
expr_stmt|;
name|ret
operator|=
name|encoder_funcs
operator|->
name|detect
argument_list|(
name|encoder
argument_list|,
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|connector_status_disconnected
condition|)
name|radeon_connector
operator|->
name|detected_by_load
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|connector_status_connected
condition|)
name|ret
operator|=
name|radeon_connector_analog_encoder_conflict_solve
argument_list|(
name|connector
argument_list|,
name|encoder
argument_list|,
name|ret
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* RN50 and some RV100 asics in servers often have a hardcoded EDID in the 	 * vbios to deal with KVMs. If we have one and are not able to detect a monitor 	 * by other means, assume the CRT is connected and use that EDID. 	 */
if|if
condition|(
operator|(
operator|!
name|rdev
operator|->
name|is_atom_bios
operator|)
operator|&&
operator|(
name|ret
operator|==
name|connector_status_disconnected
operator|)
operator|&&
name|rdev
operator|->
name|mode_info
operator|.
name|bios_hardcoded_edid_size
condition|)
block|{
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
block|}
name|radeon_connector_update_scratch_regs
argument_list|(
name|connector
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_connector_helper_funcs
name|radeon_vga_connector_helper_funcs
init|=
block|{
operator|.
name|get_modes
operator|=
name|radeon_vga_get_modes
block|,
operator|.
name|mode_valid
operator|=
name|radeon_vga_mode_valid
block|,
operator|.
name|best_encoder
operator|=
name|radeon_best_single_encoder
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_connector_funcs
name|radeon_vga_connector_funcs
init|=
block|{
operator|.
name|dpms
operator|=
name|drm_helper_connector_dpms
block|,
operator|.
name|detect
operator|=
name|radeon_vga_detect
block|,
operator|.
name|fill_modes
operator|=
name|drm_helper_probe_single_connector_modes
block|,
operator|.
name|destroy
operator|=
name|radeon_connector_destroy
block|,
operator|.
name|set_property
operator|=
name|radeon_connector_set_property
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|radeon_tv_get_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|tv_mode
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|encoder
operator|=
name|radeon_best_single_encoder
argument_list|(
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoder
condition|)
return|return
literal|0
return|;
comment|/* avivo chips can scale any mode */
if|if
condition|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_RS600
condition|)
comment|/* add scaled modes */
name|radeon_add_common_modes
argument_list|(
name|encoder
argument_list|,
name|connector
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* only 800x600 is supported right now on pre-avivo chips */
name|tv_mode
operator|=
name|drm_cvt_mode
argument_list|(
name|dev
argument_list|,
literal|800
argument_list|,
literal|600
argument_list|,
literal|60
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|tv_mode
operator|->
name|type
operator|=
name|DRM_MODE_TYPE_DRIVER
operator||
name|DRM_MODE_TYPE_PREFERRED
expr_stmt|;
name|drm_mode_probed_add
argument_list|(
name|connector
argument_list|,
name|tv_mode
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_tv_mode_valid
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mode
operator|->
name|hdisplay
operator|>
literal|1024
operator|)
operator|||
operator|(
name|mode
operator|->
name|vdisplay
operator|>
literal|768
operator|)
condition|)
return|return
name|MODE_CLOCK_RANGE
return|;
return|return
name|MODE_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|drm_connector_status
name|radeon_tv_detect
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|enum
name|drm_connector_status
name|ret
init|=
name|connector_status_disconnected
decl_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|dac_load_detect
condition|)
return|return
name|ret
return|;
name|encoder
operator|=
name|radeon_best_single_encoder
argument_list|(
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoder
condition|)
name|ret
operator|=
name|connector_status_disconnected
expr_stmt|;
else|else
block|{
name|encoder_funcs
operator|=
name|encoder
operator|->
name|helper_private
expr_stmt|;
name|ret
operator|=
name|encoder_funcs
operator|->
name|detect
argument_list|(
name|encoder
argument_list|,
name|connector
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|connector_status_connected
condition|)
name|ret
operator|=
name|radeon_connector_analog_encoder_conflict_solve
argument_list|(
name|connector
argument_list|,
name|encoder
argument_list|,
name|ret
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|radeon_connector_update_scratch_regs
argument_list|(
name|connector
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_connector_helper_funcs
name|radeon_tv_connector_helper_funcs
init|=
block|{
operator|.
name|get_modes
operator|=
name|radeon_tv_get_modes
block|,
operator|.
name|mode_valid
operator|=
name|radeon_tv_mode_valid
block|,
operator|.
name|best_encoder
operator|=
name|radeon_best_single_encoder
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_connector_funcs
name|radeon_tv_connector_funcs
init|=
block|{
operator|.
name|dpms
operator|=
name|drm_helper_connector_dpms
block|,
operator|.
name|detect
operator|=
name|radeon_tv_detect
block|,
operator|.
name|fill_modes
operator|=
name|drm_helper_probe_single_connector_modes
block|,
operator|.
name|destroy
operator|=
name|radeon_connector_destroy
block|,
operator|.
name|set_property
operator|=
name|radeon_connector_set_property
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|radeon_dvi_get_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|radeon_ddc_get_modes
argument_list|(
name|radeon_connector
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|radeon_check_hpd_status_unchanged
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|enum
name|drm_connector_status
name|status
decl_stmt|;
comment|/* We only trust HPD on R600 and newer ASICS. */
if|if
condition|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_R600
operator|&&
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
operator|!=
name|RADEON_HPD_NONE
condition|)
block|{
if|if
condition|(
name|radeon_hpd_sense
argument_list|(
name|rdev
argument_list|,
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
argument_list|)
condition|)
name|status
operator|=
name|connector_status_connected
expr_stmt|;
else|else
name|status
operator|=
name|connector_status_disconnected
expr_stmt|;
if|if
condition|(
name|connector
operator|->
name|status
operator|==
name|status
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * DVI is complicated  * Do a DDC probe, if DDC probe passes, get the full EDID so  * we can do analog/digital monitor detection at this point.  * If the monitor is an analog monitor or we got no DDC,  * we need to find the DAC encoder object for this connector.  * If we got no DDC, we do load detection on the DAC encoder object.  * If we got analog DDC or load detection passes on the DAC encoder  * we have to check if this analog encoder is shared with anyone else (TV)  * if its shared we have to set the other connector to disconnected.  */
end_comment

begin_function
specifier|static
name|enum
name|drm_connector_status
name|radeon_dvi_detect
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|drm_connector_status
name|ret
init|=
name|connector_status_disconnected
decl_stmt|;
name|bool
name|dret
init|=
name|false
decl_stmt|,
name|broken_edid
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|radeon_check_hpd_status_unchanged
argument_list|(
name|connector
argument_list|)
condition|)
return|return
name|connector
operator|->
name|status
return|;
if|if
condition|(
name|radeon_connector
operator|->
name|ddc_bus
condition|)
name|dret
operator|=
name|radeon_ddc_probe
argument_list|(
name|radeon_connector
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|dret
condition|)
block|{
name|radeon_connector
operator|->
name|detected_by_load
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|radeon_connector
operator|->
name|edid
condition|)
block|{
name|free
argument_list|(
name|radeon_connector
operator|->
name|edid
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|radeon_connector
operator|->
name|edid
operator|=
name|NULL
expr_stmt|;
block|}
name|radeon_connector
operator|->
name|edid
operator|=
name|drm_get_edid
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|radeon_connector
operator|->
name|ddc_bus
operator|->
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|edid
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"%s: probed a monitor but no|invalid EDID\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
comment|/* rs690 seems to have a problem with connectors not existing and always 			 * return a block of 0's. If we see this just stop polling on this output */
if|if
condition|(
operator|(
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS690
operator|||
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS740
operator|)
operator|&&
name|radeon_connector
operator|->
name|base
operator|.
name|null_edid_counter
condition|)
block|{
name|ret
operator|=
name|connector_status_disconnected
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"%s: detected RS690 floating bus bug, stopping ddc detect\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
name|radeon_connector
operator|->
name|ddc_bus
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
name|broken_edid
operator|=
name|true
expr_stmt|;
comment|/* defer use_digital to later */
block|}
block|}
else|else
block|{
name|radeon_connector
operator|->
name|use_digital
operator|=
operator|!
operator|!
operator|(
name|radeon_connector
operator|->
name|edid
operator|->
name|input
operator|&
name|DRM_EDID_INPUT_DIGITAL
operator|)
expr_stmt|;
comment|/* some oems have boards with separate digital and analog connectors 			 * with a shared ddc line (often vga + hdmi) 			 */
if|if
condition|(
operator|(
operator|!
name|radeon_connector
operator|->
name|use_digital
operator|)
operator|&&
name|radeon_connector
operator|->
name|shared_ddc
condition|)
block|{
name|free
argument_list|(
name|radeon_connector
operator|->
name|edid
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|radeon_connector
operator|->
name|edid
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|connector_status_disconnected
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
comment|/* This gets complicated.  We have boards with VGA + HDMI with a 			 * shared DDC line and we have boards with DVI-D + HDMI with a shared 			 * DDC line.  The latter is more complex because with DVI<->HDMI adapters 			 * you don't really know what's connected to which port as both are digital. 			 */
if|if
condition|(
name|radeon_connector
operator|->
name|shared_ddc
operator|&&
operator|(
name|ret
operator|==
name|connector_status_connected
operator|)
condition|)
block|{
name|struct
name|drm_connector
modifier|*
name|list_connector
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|list_radeon_connector
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|list_connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|connector
operator|==
name|list_connector
condition|)
continue|continue;
name|list_radeon_connector
operator|=
name|to_radeon_connector
argument_list|(
name|list_connector
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_radeon_connector
operator|->
name|shared_ddc
operator|&&
operator|(
name|list_radeon_connector
operator|->
name|ddc_bus
operator|->
name|rec
operator|.
name|i2c_id
operator|==
name|radeon_connector
operator|->
name|ddc_bus
operator|->
name|rec
operator|.
name|i2c_id
operator|)
condition|)
block|{
comment|/* cases where both connectors are digital */
if|if
condition|(
name|list_connector
operator|->
name|connector_type
operator|!=
name|DRM_MODE_CONNECTOR_VGA
condition|)
block|{
comment|/* hpd is our only option in this case */
if|if
condition|(
operator|!
name|radeon_hpd_sense
argument_list|(
name|rdev
argument_list|,
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|radeon_connector
operator|->
name|edid
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|radeon_connector
operator|->
name|edid
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|connector_status_disconnected
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|ret
operator|==
name|connector_status_connected
operator|)
operator|&&
operator|(
name|radeon_connector
operator|->
name|use_digital
operator|==
name|true
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* DVI-D and HDMI-A are digital only */
if|if
condition|(
operator|(
name|connector
operator|->
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_DVID
operator|)
operator|||
operator|(
name|connector
operator|->
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_HDMIA
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* if we aren't forcing don't do destructive polling */
if|if
condition|(
operator|!
name|force
condition|)
block|{
comment|/* only return the previous status if we last 		 * detected a monitor via load. 		 */
if|if
condition|(
name|radeon_connector
operator|->
name|detected_by_load
condition|)
name|ret
operator|=
name|connector
operator|->
name|status
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* find analog encoder */
if|if
condition|(
name|radeon_connector
operator|->
name|dac_load_detect
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_ENCODER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|connector
operator|->
name|dev
argument_list|,
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
argument_list|,
name|DRM_MODE_OBJECT_ENCODER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
continue|continue;
name|encoder
operator|=
name|obj_to_encoder
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoder
operator|->
name|encoder_type
operator|!=
name|DRM_MODE_ENCODER_DAC
operator|&&
name|encoder
operator|->
name|encoder_type
operator|!=
name|DRM_MODE_ENCODER_TVDAC
condition|)
continue|continue;
name|encoder_funcs
operator|=
name|encoder
operator|->
name|helper_private
expr_stmt|;
if|if
condition|(
name|encoder_funcs
operator|->
name|detect
condition|)
block|{
if|if
condition|(
operator|!
name|broken_edid
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
name|connector_status_connected
condition|)
block|{
comment|/* deal with analog monitors without DDC */
name|ret
operator|=
name|encoder_funcs
operator|->
name|detect
argument_list|(
name|encoder
argument_list|,
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|connector_status_connected
condition|)
block|{
name|radeon_connector
operator|->
name|use_digital
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
name|connector_status_disconnected
condition|)
name|radeon_connector
operator|->
name|detected_by_load
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|enum
name|drm_connector_status
name|lret
decl_stmt|;
comment|/* assume digital unless load detected otherwise */
name|radeon_connector
operator|->
name|use_digital
operator|=
name|true
expr_stmt|;
name|lret
operator|=
name|encoder_funcs
operator|->
name|detect
argument_list|(
name|encoder
argument_list|,
name|connector
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"load_detect %x returned: %x\n"
argument_list|,
name|encoder
operator|->
name|encoder_type
argument_list|,
name|lret
argument_list|)
expr_stmt|;
if|if
condition|(
name|lret
operator|==
name|connector_status_connected
condition|)
name|radeon_connector
operator|->
name|use_digital
operator|=
name|false
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|ret
operator|==
name|connector_status_connected
operator|)
operator|&&
operator|(
name|radeon_connector
operator|->
name|use_digital
operator|==
name|false
operator|)
operator|&&
name|encoder
condition|)
block|{
name|ret
operator|=
name|radeon_connector_analog_encoder_conflict_solve
argument_list|(
name|connector
argument_list|,
name|encoder
argument_list|,
name|ret
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* RN50 and some RV100 asics in servers often have a hardcoded EDID in the 	 * vbios to deal with KVMs. If we have one and are not able to detect a monitor 	 * by other means, assume the DFP is connected and use that EDID.  In most 	 * cases the DVI port is actually a virtual KVM port connected to the service 	 * processor. 	 */
name|out
label|:
if|if
condition|(
operator|(
operator|!
name|rdev
operator|->
name|is_atom_bios
operator|)
operator|&&
operator|(
name|ret
operator|==
name|connector_status_disconnected
operator|)
operator|&&
name|rdev
operator|->
name|mode_info
operator|.
name|bios_hardcoded_edid_size
condition|)
block|{
name|radeon_connector
operator|->
name|use_digital
operator|=
name|true
expr_stmt|;
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
block|}
comment|/* updated in get modes as well since we need to know if it's analog or digital */
name|radeon_connector_update_scratch_regs
argument_list|(
name|connector
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* okay need to be smart in here about which encoder to pick */
end_comment

begin_function
specifier|static
name|struct
name|drm_encoder
modifier|*
name|radeon_dvi_encoder
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|int
name|enc_id
init|=
name|connector
operator|->
name|encoder_ids
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_ENCODER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|connector
operator|->
name|dev
argument_list|,
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
argument_list|,
name|DRM_MODE_OBJECT_ENCODER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
continue|continue;
name|encoder
operator|=
name|obj_to_encoder
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_connector
operator|->
name|use_digital
operator|==
name|true
condition|)
block|{
if|if
condition|(
name|encoder
operator|->
name|encoder_type
operator|==
name|DRM_MODE_ENCODER_TMDS
condition|)
return|return
name|encoder
return|;
block|}
else|else
block|{
if|if
condition|(
name|encoder
operator|->
name|encoder_type
operator|==
name|DRM_MODE_ENCODER_DAC
operator|||
name|encoder
operator|->
name|encoder_type
operator|==
name|DRM_MODE_ENCODER_TVDAC
condition|)
return|return
name|encoder
return|;
block|}
block|}
comment|/* see if we have a default encoder  TODO */
comment|/* then check use digitial */
comment|/* pick the first one */
if|if
condition|(
name|enc_id
condition|)
block|{
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|connector
operator|->
name|dev
argument_list|,
name|enc_id
argument_list|,
name|DRM_MODE_OBJECT_ENCODER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
return|return
name|NULL
return|;
name|encoder
operator|=
name|obj_to_encoder
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
name|encoder
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_dvi_force
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
if|if
condition|(
name|connector
operator|->
name|force
operator|==
name|DRM_FORCE_ON
condition|)
name|radeon_connector
operator|->
name|use_digital
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|connector
operator|->
name|force
operator|==
name|DRM_FORCE_ON_DIGITAL
condition|)
name|radeon_connector
operator|->
name|use_digital
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_dvi_mode_valid
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
comment|/* XXX check mode bandwidth */
comment|/* clocks over 135 MHz have heat issues with DVI on RV100 */
if|if
condition|(
name|radeon_connector
operator|->
name|use_digital
operator|&&
operator|(
name|rdev
operator|->
name|family
operator|==
name|CHIP_RV100
operator|)
operator|&&
operator|(
name|mode
operator|->
name|clock
operator|>
literal|135000
operator|)
condition|)
return|return
name|MODE_CLOCK_HIGH
return|;
if|if
condition|(
name|radeon_connector
operator|->
name|use_digital
operator|&&
operator|(
name|mode
operator|->
name|clock
operator|>
literal|165000
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|radeon_connector
operator|->
name|connector_object_id
operator|==
name|CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_I
operator|)
operator|||
operator|(
name|radeon_connector
operator|->
name|connector_object_id
operator|==
name|CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_D
operator|)
operator|||
operator|(
name|radeon_connector
operator|->
name|connector_object_id
operator|==
name|CONNECTOR_OBJECT_ID_HDMI_TYPE_B
operator|)
condition|)
return|return
name|MODE_OK
return|;
elseif|else
if|if
condition|(
name|radeon_connector
operator|->
name|connector_object_id
operator|==
name|CONNECTOR_OBJECT_ID_HDMI_TYPE_A
condition|)
block|{
if|if
condition|(
name|ASIC_IS_DCE6
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
comment|/* HDMI 1.3+ supports max clock of 340 Mhz */
if|if
condition|(
name|mode
operator|->
name|clock
operator|>
literal|340000
condition|)
return|return
name|MODE_CLOCK_HIGH
return|;
else|else
return|return
name|MODE_OK
return|;
block|}
else|else
return|return
name|MODE_CLOCK_HIGH
return|;
block|}
else|else
return|return
name|MODE_CLOCK_HIGH
return|;
block|}
comment|/* check against the max pixel clock */
if|if
condition|(
operator|(
name|mode
operator|->
name|clock
operator|/
literal|10
operator|)
operator|>
name|rdev
operator|->
name|clock
operator|.
name|max_pixel_clock
condition|)
return|return
name|MODE_CLOCK_HIGH
return|;
return|return
name|MODE_OK
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_connector_helper_funcs
name|radeon_dvi_connector_helper_funcs
init|=
block|{
operator|.
name|get_modes
operator|=
name|radeon_dvi_get_modes
block|,
operator|.
name|mode_valid
operator|=
name|radeon_dvi_mode_valid
block|,
operator|.
name|best_encoder
operator|=
name|radeon_dvi_encoder
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_connector_funcs
name|radeon_dvi_connector_funcs
init|=
block|{
operator|.
name|dpms
operator|=
name|drm_helper_connector_dpms
block|,
operator|.
name|detect
operator|=
name|radeon_dvi_detect
block|,
operator|.
name|fill_modes
operator|=
name|drm_helper_probe_single_connector_modes
block|,
operator|.
name|set_property
operator|=
name|radeon_connector_set_property
block|,
operator|.
name|destroy
operator|=
name|radeon_connector_destroy
block|,
operator|.
name|force
operator|=
name|radeon_dvi_force
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|radeon_dp_connector_destroy
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|radeon_connector_atom_dig
modifier|*
name|radeon_dig_connector
init|=
name|radeon_connector
operator|->
name|con_priv
decl_stmt|;
if|if
condition|(
name|radeon_connector
operator|->
name|edid
condition|)
name|free
argument_list|(
name|radeon_connector
operator|->
name|edid
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_dig_connector
operator|->
name|dp_i2c_bus
condition|)
name|radeon_i2c_destroy
argument_list|(
name|radeon_dig_connector
operator|->
name|dp_i2c_bus
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|radeon_connector
operator|->
name|con_priv
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|drm_sysfs_connector_remove
argument_list|(
name|connector
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
name|drm_connector_cleanup
argument_list|(
name|connector
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|connector
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_dp_get_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|radeon_connector_atom_dig
modifier|*
name|radeon_dig_connector
init|=
name|radeon_connector
operator|->
name|con_priv
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
name|radeon_best_single_encoder
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|connector
operator|->
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_eDP
operator|)
operator|||
operator|(
name|connector
operator|->
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_LVDS
operator|)
condition|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
if|if
condition|(
name|connector
operator|->
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_eDP
condition|)
block|{
if|if
condition|(
operator|!
name|radeon_dig_connector
operator|->
name|edp_on
condition|)
name|atombios_set_edp_panel_power
argument_list|(
name|connector
argument_list|,
name|ATOM_TRANSMITTER_ACTION_POWER_ON
argument_list|)
expr_stmt|;
name|ret
operator|=
name|radeon_ddc_get_modes
argument_list|(
name|radeon_connector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_dig_connector
operator|->
name|edp_on
condition|)
name|atombios_set_edp_panel_power
argument_list|(
name|connector
argument_list|,
name|ATOM_TRANSMITTER_ACTION_POWER_OFF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* need to setup ddc on the bridge */
if|if
condition|(
name|radeon_connector_encoder_get_dp_bridge_encoder_id
argument_list|(
name|connector
argument_list|)
operator|!=
name|ENCODER_OBJECT_ID_NONE
condition|)
block|{
if|if
condition|(
name|encoder
condition|)
name|radeon_atom_ext_encoder_setup_ddc
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|radeon_ddc_get_modes
argument_list|(
name|radeon_connector
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|encoder
condition|)
block|{
name|radeon_fixup_lvds_native_mode
argument_list|(
name|encoder
argument_list|,
name|connector
argument_list|)
expr_stmt|;
comment|/* add scaled modes */
name|radeon_add_common_modes
argument_list|(
name|encoder
argument_list|,
name|connector
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|!
name|encoder
condition|)
return|return
literal|0
return|;
comment|/* we have no EDID modes */
name|mode
operator|=
name|radeon_fp_native_mode
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
name|drm_mode_probed_add
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* add the width/height from vbios tables if available */
name|connector
operator|->
name|display_info
operator|.
name|width_mm
operator|=
name|mode
operator|->
name|width_mm
expr_stmt|;
name|connector
operator|->
name|display_info
operator|.
name|height_mm
operator|=
name|mode
operator|->
name|height_mm
expr_stmt|;
comment|/* add scaled modes */
name|radeon_add_common_modes
argument_list|(
name|encoder
argument_list|,
name|connector
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* need to setup ddc on the bridge */
if|if
condition|(
name|radeon_connector_encoder_get_dp_bridge_encoder_id
argument_list|(
name|connector
argument_list|)
operator|!=
name|ENCODER_OBJECT_ID_NONE
condition|)
block|{
if|if
condition|(
name|encoder
condition|)
name|radeon_atom_ext_encoder_setup_ddc
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|radeon_ddc_get_modes
argument_list|(
name|radeon_connector
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|u16
name|radeon_connector_encoder_get_dp_bridge_encoder_id
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_ENCODER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|connector
operator|->
name|dev
argument_list|,
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
argument_list|,
name|DRM_MODE_OBJECT_ENCODER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
continue|continue;
name|encoder
operator|=
name|obj_to_encoder
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|radeon_encoder
operator|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|radeon_encoder
operator|->
name|encoder_id
condition|)
block|{
case|case
name|ENCODER_OBJECT_ID_TRAVIS
case|:
case|case
name|ENCODER_OBJECT_ID_NUTMEG
case|:
return|return
name|radeon_encoder
operator|->
name|encoder_id
return|;
default|default:
break|break;
block|}
block|}
return|return
name|ENCODER_OBJECT_ID_NONE
return|;
block|}
end_function

begin_function
name|bool
name|radeon_connector_encoder_is_hbr2
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_ENCODER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|connector
operator|->
name|dev
argument_list|,
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
argument_list|,
name|DRM_MODE_OBJECT_ENCODER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
continue|continue;
name|encoder
operator|=
name|obj_to_encoder
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|radeon_encoder
operator|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_encoder
operator|->
name|caps
operator|&
name|ATOM_ENCODER_CAP_RECORD_HBR2
condition|)
name|found
operator|=
name|true
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
end_function

begin_function
name|bool
name|radeon_connector_is_dp12_capable
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|ASIC_IS_DCE5
argument_list|(
name|rdev
argument_list|)
operator|&&
operator|(
name|rdev
operator|->
name|clock
operator|.
name|dp_extclk
operator|>=
literal|53900
operator|)
operator|&&
name|radeon_connector_encoder_is_hbr2
argument_list|(
name|connector
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|drm_connector_status
name|radeon_dp_detect
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|enum
name|drm_connector_status
name|ret
init|=
name|connector_status_disconnected
decl_stmt|;
name|struct
name|radeon_connector_atom_dig
modifier|*
name|radeon_dig_connector
init|=
name|radeon_connector
operator|->
name|con_priv
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
name|radeon_best_single_encoder
argument_list|(
name|connector
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|radeon_check_hpd_status_unchanged
argument_list|(
name|connector
argument_list|)
condition|)
return|return
name|connector
operator|->
name|status
return|;
if|if
condition|(
name|radeon_connector
operator|->
name|edid
condition|)
block|{
name|free
argument_list|(
name|radeon_connector
operator|->
name|edid
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|radeon_connector
operator|->
name|edid
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|connector
operator|->
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_eDP
operator|)
operator|||
operator|(
name|connector
operator|->
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_LVDS
operator|)
condition|)
block|{
if|if
condition|(
name|encoder
condition|)
block|{
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|native_mode
init|=
operator|&
name|radeon_encoder
operator|->
name|native_mode
decl_stmt|;
comment|/* check if panel is valid */
if|if
condition|(
name|native_mode
operator|->
name|hdisplay
operator|>=
literal|320
operator|&&
name|native_mode
operator|->
name|vdisplay
operator|>=
literal|240
condition|)
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
block|}
comment|/* eDP is always DP */
name|radeon_dig_connector
operator|->
name|dp_sink_type
operator|=
name|CONNECTOR_OBJECT_ID_DISPLAYPORT
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_dig_connector
operator|->
name|edp_on
condition|)
name|atombios_set_edp_panel_power
argument_list|(
name|connector
argument_list|,
name|ATOM_TRANSMITTER_ACTION_POWER_ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_dp_getdpcd
argument_list|(
name|radeon_connector
argument_list|)
condition|)
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_dig_connector
operator|->
name|edp_on
condition|)
name|atombios_set_edp_panel_power
argument_list|(
name|connector
argument_list|,
name|ATOM_TRANSMITTER_ACTION_POWER_OFF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|radeon_connector_encoder_get_dp_bridge_encoder_id
argument_list|(
name|connector
argument_list|)
operator|!=
name|ENCODER_OBJECT_ID_NONE
condition|)
block|{
comment|/* DP bridges are always DP */
name|radeon_dig_connector
operator|->
name|dp_sink_type
operator|=
name|CONNECTOR_OBJECT_ID_DISPLAYPORT
expr_stmt|;
comment|/* get the DPCD from the bridge */
name|radeon_dp_getdpcd
argument_list|(
name|radeon_connector
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoder
condition|)
block|{
comment|/* setup ddc on the bridge */
name|radeon_atom_ext_encoder_setup_ddc
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
comment|/* bridge chips are always aux */
if|if
condition|(
name|radeon_ddc_probe
argument_list|(
name|radeon_connector
argument_list|,
name|true
argument_list|)
condition|)
comment|/* try DDC */
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
elseif|else
if|if
condition|(
name|radeon_connector
operator|->
name|dac_load_detect
condition|)
block|{
comment|/* try load detection */
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
init|=
name|encoder
operator|->
name|helper_private
decl_stmt|;
name|ret
operator|=
name|encoder_funcs
operator|->
name|detect
argument_list|(
name|encoder
argument_list|,
name|connector
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|radeon_dig_connector
operator|->
name|dp_sink_type
operator|=
name|radeon_dp_getsinktype
argument_list|(
name|radeon_connector
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_hpd_sense
argument_list|(
name|rdev
argument_list|,
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
argument_list|)
condition|)
block|{
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
if|if
condition|(
name|radeon_dig_connector
operator|->
name|dp_sink_type
operator|==
name|CONNECTOR_OBJECT_ID_DISPLAYPORT
condition|)
name|radeon_dp_getdpcd
argument_list|(
name|radeon_connector
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|radeon_dig_connector
operator|->
name|dp_sink_type
operator|==
name|CONNECTOR_OBJECT_ID_DISPLAYPORT
condition|)
block|{
if|if
condition|(
name|radeon_dp_getdpcd
argument_list|(
name|radeon_connector
argument_list|)
condition|)
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
block|}
else|else
block|{
comment|/* try non-aux ddc (DP to DVI/HMDI/etc. adapter) */
if|if
condition|(
name|radeon_ddc_probe
argument_list|(
name|radeon_connector
argument_list|,
name|false
argument_list|)
condition|)
name|ret
operator|=
name|connector_status_connected
expr_stmt|;
block|}
block|}
block|}
name|radeon_connector_update_scratch_regs
argument_list|(
name|connector
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_dp_mode_valid
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|radeon_connector_atom_dig
modifier|*
name|radeon_dig_connector
init|=
name|radeon_connector
operator|->
name|con_priv
decl_stmt|;
comment|/* XXX check mode bandwidth */
if|if
condition|(
operator|(
name|connector
operator|->
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_eDP
operator|)
operator|||
operator|(
name|connector
operator|->
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_LVDS
operator|)
condition|)
block|{
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
name|radeon_best_single_encoder
argument_list|(
name|connector
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|mode
operator|->
name|hdisplay
operator|<
literal|320
operator|)
operator|||
operator|(
name|mode
operator|->
name|vdisplay
operator|<
literal|240
operator|)
condition|)
return|return
name|MODE_PANEL
return|;
if|if
condition|(
name|encoder
condition|)
block|{
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|native_mode
init|=
operator|&
name|radeon_encoder
operator|->
name|native_mode
decl_stmt|;
comment|/* AVIVO hardware supports downscaling modes larger than the panel 			 * to the panel size, but I'm not sure this is desirable. 			 */
if|if
condition|(
operator|(
name|mode
operator|->
name|hdisplay
operator|>
name|native_mode
operator|->
name|hdisplay
operator|)
operator|||
operator|(
name|mode
operator|->
name|vdisplay
operator|>
name|native_mode
operator|->
name|vdisplay
operator|)
condition|)
return|return
name|MODE_PANEL
return|;
comment|/* if scaling is disabled, block non-native modes */
if|if
condition|(
name|radeon_encoder
operator|->
name|rmx_type
operator|==
name|RMX_OFF
condition|)
block|{
if|if
condition|(
operator|(
name|mode
operator|->
name|hdisplay
operator|!=
name|native_mode
operator|->
name|hdisplay
operator|)
operator|||
operator|(
name|mode
operator|->
name|vdisplay
operator|!=
name|native_mode
operator|->
name|vdisplay
operator|)
condition|)
return|return
name|MODE_PANEL
return|;
block|}
block|}
return|return
name|MODE_OK
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|radeon_dig_connector
operator|->
name|dp_sink_type
operator|==
name|CONNECTOR_OBJECT_ID_DISPLAYPORT
operator|)
operator|||
operator|(
name|radeon_dig_connector
operator|->
name|dp_sink_type
operator|==
name|CONNECTOR_OBJECT_ID_eDP
operator|)
condition|)
return|return
name|radeon_dp_mode_valid_helper
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
return|;
else|else
return|return
name|MODE_OK
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_connector_helper_funcs
name|radeon_dp_connector_helper_funcs
init|=
block|{
operator|.
name|get_modes
operator|=
name|radeon_dp_get_modes
block|,
operator|.
name|mode_valid
operator|=
name|radeon_dp_mode_valid
block|,
operator|.
name|best_encoder
operator|=
name|radeon_dvi_encoder
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_connector_funcs
name|radeon_dp_connector_funcs
init|=
block|{
operator|.
name|dpms
operator|=
name|drm_helper_connector_dpms
block|,
operator|.
name|detect
operator|=
name|radeon_dp_detect
block|,
operator|.
name|fill_modes
operator|=
name|drm_helper_probe_single_connector_modes
block|,
operator|.
name|set_property
operator|=
name|radeon_connector_set_property
block|,
operator|.
name|destroy
operator|=
name|radeon_dp_connector_destroy
block|,
operator|.
name|force
operator|=
name|radeon_dvi_force
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|radeon_add_atom_connector
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|connector_id
parameter_list|,
name|uint32_t
name|supported_device
parameter_list|,
name|int
name|connector_type
parameter_list|,
name|struct
name|radeon_i2c_bus_rec
modifier|*
name|i2c_bus
parameter_list|,
name|uint32_t
name|igp_lane_info
parameter_list|,
name|uint16_t
name|connector_object_id
parameter_list|,
name|struct
name|radeon_hpd
modifier|*
name|hpd
parameter_list|,
name|struct
name|radeon_router
modifier|*
name|router
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
decl_stmt|;
name|struct
name|radeon_connector_atom_dig
modifier|*
name|radeon_dig_connector
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
decl_stmt|;
name|uint32_t
name|subpixel_order
init|=
name|SubPixelNone
decl_stmt|;
name|bool
name|shared_ddc
init|=
name|false
decl_stmt|;
name|bool
name|is_dp_bridge
init|=
name|false
decl_stmt|;
if|if
condition|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_Unknown
condition|)
return|return;
comment|/* if the user selected tv=0 don't try and add the connector */
if|if
condition|(
operator|(
operator|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_SVIDEO
operator|)
operator|||
operator|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_Composite
operator|)
operator|||
operator|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_9PinDIN
operator|)
operator|)
operator|&&
operator|(
name|radeon_tv
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* see if we already added it */
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
name|radeon_connector
operator|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_connector
operator|->
name|connector_id
operator|==
name|connector_id
condition|)
block|{
name|radeon_connector
operator|->
name|devices
operator||=
name|supported_device
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|radeon_connector
operator|->
name|ddc_bus
operator|&&
name|i2c_bus
operator|->
name|valid
condition|)
block|{
if|if
condition|(
name|radeon_connector
operator|->
name|ddc_bus
operator|->
name|rec
operator|.
name|i2c_id
operator|==
name|i2c_bus
operator|->
name|i2c_id
condition|)
block|{
name|radeon_connector
operator|->
name|shared_ddc
operator|=
name|true
expr_stmt|;
name|shared_ddc
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|radeon_connector
operator|->
name|router_bus
operator|&&
name|router
operator|->
name|ddc_valid
operator|&&
operator|(
name|radeon_connector
operator|->
name|router
operator|.
name|router_id
operator|==
name|router
operator|->
name|router_id
operator|)
condition|)
block|{
name|radeon_connector
operator|->
name|shared_ddc
operator|=
name|false
expr_stmt|;
name|shared_ddc
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
comment|/* check if it's a dp bridge */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
name|radeon_encoder
operator|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_encoder
operator|->
name|devices
operator|&
name|supported_device
condition|)
block|{
switch|switch
condition|(
name|radeon_encoder
operator|->
name|encoder_id
condition|)
block|{
case|case
name|ENCODER_OBJECT_ID_TRAVIS
case|:
case|case
name|ENCODER_OBJECT_ID_NUTMEG
case|:
name|is_dp_bridge
operator|=
name|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|radeon_connector
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|radeon_connector
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
condition|)
return|return;
name|connector
operator|=
operator|&
name|radeon_connector
operator|->
name|base
expr_stmt|;
name|radeon_connector
operator|->
name|connector_id
operator|=
name|connector_id
expr_stmt|;
name|radeon_connector
operator|->
name|devices
operator|=
name|supported_device
expr_stmt|;
name|radeon_connector
operator|->
name|shared_ddc
operator|=
name|shared_ddc
expr_stmt|;
name|radeon_connector
operator|->
name|connector_object_id
operator|=
name|connector_object_id
expr_stmt|;
name|radeon_connector
operator|->
name|hpd
operator|=
operator|*
name|hpd
expr_stmt|;
name|radeon_connector
operator|->
name|router
operator|=
operator|*
name|router
expr_stmt|;
if|if
condition|(
name|router
operator|->
name|ddc_valid
operator|||
name|router
operator|->
name|cd_valid
condition|)
block|{
name|radeon_connector
operator|->
name|router_bus
operator|=
name|radeon_i2c_lookup
argument_list|(
name|rdev
argument_list|,
operator|&
name|router
operator|->
name|i2c_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|router_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"Failed to assign router i2c bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_dp_bridge
condition|)
block|{
name|radeon_dig_connector
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|radeon_connector_atom_dig
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_dig_connector
condition|)
goto|goto
name|failed
goto|;
name|radeon_dig_connector
operator|->
name|igp_lane_info
operator|=
name|igp_lane_info
expr_stmt|;
name|radeon_connector
operator|->
name|con_priv
operator|=
name|radeon_dig_connector
expr_stmt|;
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_dp_connector_funcs
argument_list|,
name|connector_type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_dp_connector_helper_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2c_bus
operator|->
name|valid
condition|)
block|{
comment|/* add DP i2c bus */
if|if
condition|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_eDP
condition|)
name|radeon_dig_connector
operator|->
name|dp_i2c_bus
operator|=
name|radeon_i2c_create_dp
argument_list|(
name|dev
argument_list|,
name|i2c_bus
argument_list|,
literal|"eDP-auxch"
argument_list|)
expr_stmt|;
else|else
name|radeon_dig_connector
operator|->
name|dp_i2c_bus
operator|=
name|radeon_i2c_create_dp
argument_list|(
name|dev
argument_list|,
name|i2c_bus
argument_list|,
literal|"DP-auxch"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_dig_connector
operator|->
name|dp_i2c_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"DP: Failed to assign dp ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
name|radeon_connector
operator|->
name|ddc_bus
operator|=
name|radeon_i2c_lookup
argument_list|(
name|rdev
argument_list|,
name|i2c_bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|ddc_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"DP: Failed to assign ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|connector_type
condition|)
block|{
case|case
name|DRM_MODE_CONNECTOR_VGA
case|:
case|case
name|DRM_MODE_CONNECTOR_DVIA
case|:
default|default:
name|connector
operator|->
name|interlace_allowed
operator|=
name|true
expr_stmt|;
name|connector
operator|->
name|doublescan_allowed
operator|=
name|true
expr_stmt|;
name|radeon_connector
operator|->
name|dac_load_detect
operator|=
name|true
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|load_detect_property
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_DVII
case|:
case|case
name|DRM_MODE_CONNECTOR_DVID
case|:
case|case
name|DRM_MODE_CONNECTOR_HDMIA
case|:
case|case
name|DRM_MODE_CONNECTOR_HDMIB
case|:
case|case
name|DRM_MODE_CONNECTOR_DisplayPort
case|:
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_property
argument_list|,
name|UNDERSCAN_OFF
argument_list|)
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_hborder_property
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_vborder_property
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subpixel_order
operator|=
name|SubPixelHorizontalRGB
expr_stmt|;
name|connector
operator|->
name|interlace_allowed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_HDMIB
condition|)
name|connector
operator|->
name|doublescan_allowed
operator|=
name|true
expr_stmt|;
else|else
name|connector
operator|->
name|doublescan_allowed
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_DVII
condition|)
block|{
name|radeon_connector
operator|->
name|dac_load_detect
operator|=
name|true
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|load_detect_property
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DRM_MODE_CONNECTOR_LVDS
case|:
case|case
name|DRM_MODE_CONNECTOR_eDP
case|:
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|scaling_mode_property
argument_list|,
name|DRM_MODE_SCALE_FULLSCREEN
argument_list|)
expr_stmt|;
name|subpixel_order
operator|=
name|SubPixelHorizontalRGB
expr_stmt|;
name|connector
operator|->
name|interlace_allowed
operator|=
name|false
expr_stmt|;
name|connector
operator|->
name|doublescan_allowed
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|connector_type
condition|)
block|{
case|case
name|DRM_MODE_CONNECTOR_VGA
case|:
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_vga_connector_funcs
argument_list|,
name|connector_type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_vga_connector_helper_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2c_bus
operator|->
name|valid
condition|)
block|{
name|radeon_connector
operator|->
name|ddc_bus
operator|=
name|radeon_i2c_lookup
argument_list|(
name|rdev
argument_list|,
name|i2c_bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|ddc_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"VGA: Failed to assign ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
block|}
name|radeon_connector
operator|->
name|dac_load_detect
operator|=
name|true
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|load_detect_property
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* no HPD on analog connectors */
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
operator|=
name|RADEON_HPD_NONE
expr_stmt|;
name|connector
operator|->
name|polled
operator|=
name|DRM_CONNECTOR_POLL_CONNECT
expr_stmt|;
name|connector
operator|->
name|interlace_allowed
operator|=
name|true
expr_stmt|;
name|connector
operator|->
name|doublescan_allowed
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_DVIA
case|:
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_vga_connector_funcs
argument_list|,
name|connector_type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_vga_connector_helper_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2c_bus
operator|->
name|valid
condition|)
block|{
name|radeon_connector
operator|->
name|ddc_bus
operator|=
name|radeon_i2c_lookup
argument_list|(
name|rdev
argument_list|,
name|i2c_bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|ddc_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"DVIA: Failed to assign ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
block|}
name|radeon_connector
operator|->
name|dac_load_detect
operator|=
name|true
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|load_detect_property
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* no HPD on analog connectors */
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
operator|=
name|RADEON_HPD_NONE
expr_stmt|;
name|connector
operator|->
name|interlace_allowed
operator|=
name|true
expr_stmt|;
name|connector
operator|->
name|doublescan_allowed
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_DVII
case|:
case|case
name|DRM_MODE_CONNECTOR_DVID
case|:
name|radeon_dig_connector
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|radeon_connector_atom_dig
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_dig_connector
condition|)
goto|goto
name|failed
goto|;
name|radeon_dig_connector
operator|->
name|igp_lane_info
operator|=
name|igp_lane_info
expr_stmt|;
name|radeon_connector
operator|->
name|con_priv
operator|=
name|radeon_dig_connector
expr_stmt|;
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_dvi_connector_funcs
argument_list|,
name|connector_type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_dvi_connector_helper_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2c_bus
operator|->
name|valid
condition|)
block|{
name|radeon_connector
operator|->
name|ddc_bus
operator|=
name|radeon_i2c_lookup
argument_list|(
name|rdev
argument_list|,
name|i2c_bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|ddc_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"DVI: Failed to assign ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
block|}
name|subpixel_order
operator|=
name|SubPixelHorizontalRGB
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|coherent_mode_property
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_property
argument_list|,
name|UNDERSCAN_OFF
argument_list|)
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_hborder_property
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_vborder_property
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_DVII
condition|)
block|{
name|radeon_connector
operator|->
name|dac_load_detect
operator|=
name|true
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|load_detect_property
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|connector
operator|->
name|interlace_allowed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_DVII
condition|)
name|connector
operator|->
name|doublescan_allowed
operator|=
name|true
expr_stmt|;
else|else
name|connector
operator|->
name|doublescan_allowed
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_HDMIA
case|:
case|case
name|DRM_MODE_CONNECTOR_HDMIB
case|:
name|radeon_dig_connector
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|radeon_connector_atom_dig
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_dig_connector
condition|)
goto|goto
name|failed
goto|;
name|radeon_dig_connector
operator|->
name|igp_lane_info
operator|=
name|igp_lane_info
expr_stmt|;
name|radeon_connector
operator|->
name|con_priv
operator|=
name|radeon_dig_connector
expr_stmt|;
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_dvi_connector_funcs
argument_list|,
name|connector_type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_dvi_connector_helper_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2c_bus
operator|->
name|valid
condition|)
block|{
name|radeon_connector
operator|->
name|ddc_bus
operator|=
name|radeon_i2c_lookup
argument_list|(
name|rdev
argument_list|,
name|i2c_bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|ddc_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"HDMI: Failed to assign ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
block|}
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|coherent_mode_property
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_property
argument_list|,
name|UNDERSCAN_OFF
argument_list|)
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_hborder_property
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_vborder_property
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|subpixel_order
operator|=
name|SubPixelHorizontalRGB
expr_stmt|;
name|connector
operator|->
name|interlace_allowed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_HDMIB
condition|)
name|connector
operator|->
name|doublescan_allowed
operator|=
name|true
expr_stmt|;
else|else
name|connector
operator|->
name|doublescan_allowed
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_DisplayPort
case|:
name|radeon_dig_connector
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|radeon_connector_atom_dig
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_dig_connector
condition|)
goto|goto
name|failed
goto|;
name|radeon_dig_connector
operator|->
name|igp_lane_info
operator|=
name|igp_lane_info
expr_stmt|;
name|radeon_connector
operator|->
name|con_priv
operator|=
name|radeon_dig_connector
expr_stmt|;
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_dp_connector_funcs
argument_list|,
name|connector_type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_dp_connector_helper_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2c_bus
operator|->
name|valid
condition|)
block|{
comment|/* add DP i2c bus */
name|radeon_dig_connector
operator|->
name|dp_i2c_bus
operator|=
name|radeon_i2c_create_dp
argument_list|(
name|dev
argument_list|,
name|i2c_bus
argument_list|,
literal|"DP-auxch"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_dig_connector
operator|->
name|dp_i2c_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"DP: Failed to assign dp ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
name|radeon_connector
operator|->
name|ddc_bus
operator|=
name|radeon_i2c_lookup
argument_list|(
name|rdev
argument_list|,
name|i2c_bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|ddc_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"DP: Failed to assign ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
block|}
name|subpixel_order
operator|=
name|SubPixelHorizontalRGB
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|coherent_mode_property
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_property
argument_list|,
name|UNDERSCAN_OFF
argument_list|)
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_hborder_property
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|underscan_vborder_property
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|connector
operator|->
name|interlace_allowed
operator|=
name|true
expr_stmt|;
comment|/* in theory with a DP to VGA converter... */
name|connector
operator|->
name|doublescan_allowed
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_eDP
case|:
name|radeon_dig_connector
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|radeon_connector_atom_dig
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_dig_connector
condition|)
goto|goto
name|failed
goto|;
name|radeon_dig_connector
operator|->
name|igp_lane_info
operator|=
name|igp_lane_info
expr_stmt|;
name|radeon_connector
operator|->
name|con_priv
operator|=
name|radeon_dig_connector
expr_stmt|;
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_dp_connector_funcs
argument_list|,
name|connector_type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_dp_connector_helper_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2c_bus
operator|->
name|valid
condition|)
block|{
comment|/* add DP i2c bus */
name|radeon_dig_connector
operator|->
name|dp_i2c_bus
operator|=
name|radeon_i2c_create_dp
argument_list|(
name|dev
argument_list|,
name|i2c_bus
argument_list|,
literal|"eDP-auxch"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_dig_connector
operator|->
name|dp_i2c_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"DP: Failed to assign dp ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
name|radeon_connector
operator|->
name|ddc_bus
operator|=
name|radeon_i2c_lookup
argument_list|(
name|rdev
argument_list|,
name|i2c_bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|ddc_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"DP: Failed to assign ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
block|}
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|scaling_mode_property
argument_list|,
name|DRM_MODE_SCALE_FULLSCREEN
argument_list|)
expr_stmt|;
name|subpixel_order
operator|=
name|SubPixelHorizontalRGB
expr_stmt|;
name|connector
operator|->
name|interlace_allowed
operator|=
name|false
expr_stmt|;
name|connector
operator|->
name|doublescan_allowed
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_SVIDEO
case|:
case|case
name|DRM_MODE_CONNECTOR_Composite
case|:
case|case
name|DRM_MODE_CONNECTOR_9PinDIN
case|:
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_tv_connector_funcs
argument_list|,
name|connector_type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_tv_connector_helper_funcs
argument_list|)
expr_stmt|;
name|radeon_connector
operator|->
name|dac_load_detect
operator|=
name|true
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|load_detect_property
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|tv_std_property
argument_list|,
name|radeon_atombios_get_tv_info
argument_list|(
name|rdev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* no HPD on analog connectors */
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
operator|=
name|RADEON_HPD_NONE
expr_stmt|;
name|connector
operator|->
name|interlace_allowed
operator|=
name|false
expr_stmt|;
name|connector
operator|->
name|doublescan_allowed
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_LVDS
case|:
name|radeon_dig_connector
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|radeon_connector_atom_dig
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_dig_connector
condition|)
goto|goto
name|failed
goto|;
name|radeon_dig_connector
operator|->
name|igp_lane_info
operator|=
name|igp_lane_info
expr_stmt|;
name|radeon_connector
operator|->
name|con_priv
operator|=
name|radeon_dig_connector
expr_stmt|;
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_lvds_connector_funcs
argument_list|,
name|connector_type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_lvds_connector_helper_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2c_bus
operator|->
name|valid
condition|)
block|{
name|radeon_connector
operator|->
name|ddc_bus
operator|=
name|radeon_i2c_lookup
argument_list|(
name|rdev
argument_list|,
name|i2c_bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|ddc_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"LVDS: Failed to assign ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
block|}
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|scaling_mode_property
argument_list|,
name|DRM_MODE_SCALE_FULLSCREEN
argument_list|)
expr_stmt|;
name|subpixel_order
operator|=
name|SubPixelHorizontalRGB
expr_stmt|;
name|connector
operator|->
name|interlace_allowed
operator|=
name|false
expr_stmt|;
name|connector
operator|->
name|doublescan_allowed
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
operator|==
name|RADEON_HPD_NONE
condition|)
block|{
if|if
condition|(
name|i2c_bus
operator|->
name|valid
condition|)
name|connector
operator|->
name|polled
operator|=
name|DRM_CONNECTOR_POLL_CONNECT
expr_stmt|;
block|}
else|else
name|connector
operator|->
name|polled
operator|=
name|DRM_CONNECTOR_POLL_HPD
expr_stmt|;
name|connector
operator|->
name|display_info
operator|.
name|subpixel_order
operator|=
name|subpixel_order
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|drm_sysfs_connector_add
argument_list|(
name|connector
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
return|return;
name|failed
label|:
name|drm_connector_cleanup
argument_list|(
name|connector
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|connector
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|radeon_add_legacy_connector
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|connector_id
parameter_list|,
name|uint32_t
name|supported_device
parameter_list|,
name|int
name|connector_type
parameter_list|,
name|struct
name|radeon_i2c_bus_rec
modifier|*
name|i2c_bus
parameter_list|,
name|uint16_t
name|connector_object_id
parameter_list|,
name|struct
name|radeon_hpd
modifier|*
name|hpd
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
decl_stmt|;
name|uint32_t
name|subpixel_order
init|=
name|SubPixelNone
decl_stmt|;
if|if
condition|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_Unknown
condition|)
return|return;
comment|/* if the user selected tv=0 don't try and add the connector */
if|if
condition|(
operator|(
operator|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_SVIDEO
operator|)
operator|||
operator|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_Composite
operator|)
operator|||
operator|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_9PinDIN
operator|)
operator|)
operator|&&
operator|(
name|radeon_tv
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* see if we already added it */
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
name|radeon_connector
operator|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_connector
operator|->
name|connector_id
operator|==
name|connector_id
condition|)
block|{
name|radeon_connector
operator|->
name|devices
operator||=
name|supported_device
expr_stmt|;
return|return;
block|}
block|}
name|radeon_connector
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|radeon_connector
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
condition|)
return|return;
name|connector
operator|=
operator|&
name|radeon_connector
operator|->
name|base
expr_stmt|;
name|radeon_connector
operator|->
name|connector_id
operator|=
name|connector_id
expr_stmt|;
name|radeon_connector
operator|->
name|devices
operator|=
name|supported_device
expr_stmt|;
name|radeon_connector
operator|->
name|connector_object_id
operator|=
name|connector_object_id
expr_stmt|;
name|radeon_connector
operator|->
name|hpd
operator|=
operator|*
name|hpd
expr_stmt|;
switch|switch
condition|(
name|connector_type
condition|)
block|{
case|case
name|DRM_MODE_CONNECTOR_VGA
case|:
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_vga_connector_funcs
argument_list|,
name|connector_type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_vga_connector_helper_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2c_bus
operator|->
name|valid
condition|)
block|{
name|radeon_connector
operator|->
name|ddc_bus
operator|=
name|radeon_i2c_lookup
argument_list|(
name|rdev
argument_list|,
name|i2c_bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|ddc_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"VGA: Failed to assign ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
block|}
name|radeon_connector
operator|->
name|dac_load_detect
operator|=
name|true
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|load_detect_property
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* no HPD on analog connectors */
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
operator|=
name|RADEON_HPD_NONE
expr_stmt|;
name|connector
operator|->
name|polled
operator|=
name|DRM_CONNECTOR_POLL_CONNECT
expr_stmt|;
name|connector
operator|->
name|interlace_allowed
operator|=
name|true
expr_stmt|;
name|connector
operator|->
name|doublescan_allowed
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_DVIA
case|:
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_vga_connector_funcs
argument_list|,
name|connector_type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_vga_connector_helper_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2c_bus
operator|->
name|valid
condition|)
block|{
name|radeon_connector
operator|->
name|ddc_bus
operator|=
name|radeon_i2c_lookup
argument_list|(
name|rdev
argument_list|,
name|i2c_bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|ddc_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"DVIA: Failed to assign ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
block|}
name|radeon_connector
operator|->
name|dac_load_detect
operator|=
name|true
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|load_detect_property
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* no HPD on analog connectors */
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
operator|=
name|RADEON_HPD_NONE
expr_stmt|;
name|connector
operator|->
name|interlace_allowed
operator|=
name|true
expr_stmt|;
name|connector
operator|->
name|doublescan_allowed
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_DVII
case|:
case|case
name|DRM_MODE_CONNECTOR_DVID
case|:
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_dvi_connector_funcs
argument_list|,
name|connector_type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_dvi_connector_helper_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2c_bus
operator|->
name|valid
condition|)
block|{
name|radeon_connector
operator|->
name|ddc_bus
operator|=
name|radeon_i2c_lookup
argument_list|(
name|rdev
argument_list|,
name|i2c_bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|ddc_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"DVI: Failed to assign ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_DVII
condition|)
block|{
name|radeon_connector
operator|->
name|dac_load_detect
operator|=
name|true
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|load_detect_property
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|subpixel_order
operator|=
name|SubPixelHorizontalRGB
expr_stmt|;
name|connector
operator|->
name|interlace_allowed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_DVII
condition|)
name|connector
operator|->
name|doublescan_allowed
operator|=
name|true
expr_stmt|;
else|else
name|connector
operator|->
name|doublescan_allowed
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_SVIDEO
case|:
case|case
name|DRM_MODE_CONNECTOR_Composite
case|:
case|case
name|DRM_MODE_CONNECTOR_9PinDIN
case|:
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_tv_connector_funcs
argument_list|,
name|connector_type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_tv_connector_helper_funcs
argument_list|)
expr_stmt|;
name|radeon_connector
operator|->
name|dac_load_detect
operator|=
name|true
expr_stmt|;
comment|/* RS400,RC410,RS480 chipset seems to report a lot 		 * of false positive on load detect, we haven't yet 		 * found a way to make load detect reliable on those 		 * chipset, thus just disable it for TV. 		 */
if|if
condition|(
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS400
operator|||
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS480
condition|)
name|radeon_connector
operator|->
name|dac_load_detect
operator|=
name|false
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|load_detect_property
argument_list|,
name|radeon_connector
operator|->
name|dac_load_detect
argument_list|)
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|tv_std_property
argument_list|,
name|radeon_combios_get_tv_info
argument_list|(
name|rdev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* no HPD on analog connectors */
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
operator|=
name|RADEON_HPD_NONE
expr_stmt|;
name|connector
operator|->
name|interlace_allowed
operator|=
name|false
expr_stmt|;
name|connector
operator|->
name|doublescan_allowed
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DRM_MODE_CONNECTOR_LVDS
case|:
name|drm_connector_init
argument_list|(
name|dev
argument_list|,
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_lvds_connector_funcs
argument_list|,
name|connector_type
argument_list|)
expr_stmt|;
name|drm_connector_helper_add
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
operator|&
name|radeon_lvds_connector_helper_funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2c_bus
operator|->
name|valid
condition|)
block|{
name|radeon_connector
operator|->
name|ddc_bus
operator|=
name|radeon_i2c_lookup
argument_list|(
name|rdev
argument_list|,
name|i2c_bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|ddc_bus
condition|)
name|DRM_ERROR
argument_list|(
literal|"LVDS: Failed to assign ddc bus! Check dmesg for i2c errors.\n"
argument_list|)
expr_stmt|;
block|}
name|drm_connector_attach_property
argument_list|(
operator|&
name|radeon_connector
operator|->
name|base
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|scaling_mode_property
argument_list|,
name|DRM_MODE_SCALE_FULLSCREEN
argument_list|)
expr_stmt|;
name|subpixel_order
operator|=
name|SubPixelHorizontalRGB
expr_stmt|;
name|connector
operator|->
name|interlace_allowed
operator|=
name|false
expr_stmt|;
name|connector
operator|->
name|doublescan_allowed
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|radeon_connector
operator|->
name|hpd
operator|.
name|hpd
operator|==
name|RADEON_HPD_NONE
condition|)
block|{
if|if
condition|(
name|i2c_bus
operator|->
name|valid
condition|)
name|connector
operator|->
name|polled
operator|=
name|DRM_CONNECTOR_POLL_CONNECT
expr_stmt|;
block|}
else|else
name|connector
operator|->
name|polled
operator|=
name|DRM_CONNECTOR_POLL_HPD
expr_stmt|;
name|connector
operator|->
name|display_info
operator|.
name|subpixel_order
operator|=
name|subpixel_order
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
name|drm_sysfs_connector_add
argument_list|(
name|connector
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
block|}
end_function

end_unit

