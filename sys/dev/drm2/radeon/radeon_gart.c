begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008 Advanced Micro Devices, Inc.  * Copyright 2008 Red Hat Inc.  * Copyright 2009 Jerome Glisse.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *  * Authors: Dave Airlie  *          Alex Deucher  *          Jerome Glisse  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/radeon/radeon_drm.h>
end_include

begin_include
include|#
directive|include
file|"radeon.h"
end_include

begin_include
include|#
directive|include
file|"radeon_reg.h"
end_include

begin_comment
comment|/*  * GART  * The GART (Graphics Aperture Remapping Table) is an aperture  * in the GPU's address space.  System pages can be mapped into  * the aperture and look like contiguous pages from the GPU's  * perspective.  A page table maps the pages in the aperture  * to the actual backing pages in system memory.  *  * Radeon GPUs support both an internal GART, as described above,  * and AGP.  AGP works similarly, but the GART table is configured  * and maintained by the northbridge rather than the driver.  * Radeon hw has a separate AGP aperture that is programmed to  * point to the AGP aperture provided by the northbridge and the  * requests are passed through to the northbridge aperture.  * Both AGP and internal GART can be used at the same time, however  * that is not currently supported by the driver.  *  * This file handles the common internal GART management.  */
end_comment

begin_comment
comment|/*  * Common GART table functions.  */
end_comment

begin_comment
comment|/**  * radeon_gart_table_ram_alloc - allocate system ram for gart page table  *  * @rdev: radeon_device pointer  *  * Allocate system memory for GART page table  * (r1xx-r3xx, non-pcie r4xx, rs400).  These asics require the  * gart table to be in system memory.  * Returns 0 for success, -ENOMEM for failure.  */
end_comment

begin_function
name|int
name|radeon_gart_table_ram_alloc
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|drm_dma_handle_t
modifier|*
name|dmah
decl_stmt|;
name|dmah
operator|=
name|drm_pci_alloc
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|,
name|rdev
operator|->
name|gart
operator|.
name|table_size
argument_list|,
name|PAGE_SIZE
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmah
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
name|ENOMEM
return|;
block|}
name|rdev
operator|->
name|gart
operator|.
name|dmah
operator|=
name|dmah
expr_stmt|;
name|rdev
operator|->
name|gart
operator|.
name|ptr
operator|=
name|dmah
operator|->
name|vaddr
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_X86
if|if
condition|(
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS400
operator|||
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS480
operator|||
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS690
operator|||
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS740
condition|)
block|{
name|pmap_change_attr
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|rdev
operator|->
name|gart
operator|.
name|ptr
argument_list|,
name|rdev
operator|->
name|gart
operator|.
name|table_size
operator|>>
name|PAGE_SHIFT
argument_list|,
name|PAT_UNCACHED
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|rdev
operator|->
name|gart
operator|.
name|table_addr
operator|=
name|dmah
operator|->
name|busaddr
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rdev
operator|->
name|gart
operator|.
name|ptr
argument_list|,
literal|0
argument_list|,
name|rdev
operator|->
name|gart
operator|.
name|table_size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_gart_table_ram_free - free system ram for gart page table  *  * @rdev: radeon_device pointer  *  * Free system memory for GART page table  * (r1xx-r3xx, non-pcie r4xx, rs400).  These asics require the  * gart table to be in system memory.  */
end_comment

begin_function
name|void
name|radeon_gart_table_ram_free
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|if
condition|(
name|rdev
operator|->
name|gart
operator|.
name|ptr
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
ifdef|#
directive|ifdef
name|CONFIG_X86
if|if
condition|(
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS400
operator|||
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS480
operator|||
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS690
operator|||
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS740
condition|)
block|{
name|pmap_change_attr
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|rdev
operator|->
name|gart
operator|.
name|ptr
argument_list|,
name|rdev
operator|->
name|gart
operator|.
name|table_size
operator|>>
name|PAGE_SHIFT
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|drm_pci_free
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|,
name|rdev
operator|->
name|gart
operator|.
name|dmah
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|gart
operator|.
name|dmah
operator|=
name|NULL
expr_stmt|;
name|rdev
operator|->
name|gart
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|rdev
operator|->
name|gart
operator|.
name|table_addr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_gart_table_vram_alloc - allocate vram for gart page table  *  * @rdev: radeon_device pointer  *  * Allocate video memory for GART page table  * (pcie r4xx, r5xx+).  These asics require the  * gart table to be in video memory.  * Returns 0 for success, error for failure.  */
end_comment

begin_function
name|int
name|radeon_gart_table_vram_alloc
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|rdev
operator|->
name|gart
operator|.
name|robj
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|radeon_bo_create
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|gart
operator|.
name|table_size
argument_list|,
name|PAGE_SIZE
argument_list|,
name|true
argument_list|,
name|RADEON_GEM_DOMAIN_VRAM
argument_list|,
name|NULL
argument_list|,
operator|&
name|rdev
operator|->
name|gart
operator|.
name|robj
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
return|return
name|r
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_gart_table_vram_pin - pin gart page table in vram  *  * @rdev: radeon_device pointer  *  * Pin the GART page table in vram so it will not be moved  * by the memory manager (pcie r4xx, r5xx+).  These asics require the  * gart table to be in video memory.  * Returns 0 for success, error for failure.  */
end_comment

begin_function
name|int
name|radeon_gart_table_vram_pin
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|uint64_t
name|gpu_addr
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|radeon_bo_reserve
argument_list|(
name|rdev
operator|->
name|gart
operator|.
name|robj
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
operator|!=
literal|0
argument_list|)
condition|)
return|return
name|r
return|;
name|r
operator|=
name|radeon_bo_pin
argument_list|(
name|rdev
operator|->
name|gart
operator|.
name|robj
argument_list|,
name|RADEON_GEM_DOMAIN_VRAM
argument_list|,
operator|&
name|gpu_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|radeon_bo_unreserve
argument_list|(
name|rdev
operator|->
name|gart
operator|.
name|robj
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|r
operator|=
name|radeon_bo_kmap
argument_list|(
name|rdev
operator|->
name|gart
operator|.
name|robj
argument_list|,
operator|&
name|rdev
operator|->
name|gart
operator|.
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|radeon_bo_unpin
argument_list|(
name|rdev
operator|->
name|gart
operator|.
name|robj
argument_list|)
expr_stmt|;
name|radeon_bo_unreserve
argument_list|(
name|rdev
operator|->
name|gart
operator|.
name|robj
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|gart
operator|.
name|table_addr
operator|=
name|gpu_addr
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_gart_table_vram_unpin - unpin gart page table in vram  *  * @rdev: radeon_device pointer  *  * Unpin the GART page table in vram (pcie r4xx, r5xx+).  * These asics require the gart table to be in video memory.  */
end_comment

begin_function
name|void
name|radeon_gart_table_vram_unpin
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|rdev
operator|->
name|gart
operator|.
name|robj
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|r
operator|=
name|radeon_bo_reserve
argument_list|(
name|rdev
operator|->
name|gart
operator|.
name|robj
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|r
operator|==
literal|0
argument_list|)
condition|)
block|{
name|radeon_bo_kunmap
argument_list|(
name|rdev
operator|->
name|gart
operator|.
name|robj
argument_list|)
expr_stmt|;
name|radeon_bo_unpin
argument_list|(
name|rdev
operator|->
name|gart
operator|.
name|robj
argument_list|)
expr_stmt|;
name|radeon_bo_unreserve
argument_list|(
name|rdev
operator|->
name|gart
operator|.
name|robj
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|gart
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_gart_table_vram_free - free gart page table vram  *  * @rdev: radeon_device pointer  *  * Free the video memory used for the GART page table  * (pcie r4xx, r5xx+).  These asics require the gart table to  * be in video memory.  */
end_comment

begin_function
name|void
name|radeon_gart_table_vram_free
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|if
condition|(
name|rdev
operator|->
name|gart
operator|.
name|robj
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|radeon_gart_table_vram_unpin
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_bo_unref
argument_list|(
operator|&
name|rdev
operator|->
name|gart
operator|.
name|robj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Common gart functions.  */
end_comment

begin_comment
comment|/**  * radeon_gart_unbind - unbind pages from the gart page table  *  * @rdev: radeon_device pointer  * @offset: offset into the GPU's gart aperture  * @pages: number of pages to unbind  *  * Unbinds the requested pages from the gart page table and  * replaces them with the dummy page (all asics).  */
end_comment

begin_function
name|void
name|radeon_gart_unbind
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|unsigned
name|offset
parameter_list|,
name|int
name|pages
parameter_list|)
block|{
name|unsigned
name|t
decl_stmt|;
name|unsigned
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u64
name|page_base
decl_stmt|;
if|if
condition|(
operator|!
name|rdev
operator|->
name|gart
operator|.
name|ready
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"trying to unbind memory from uninitialized GART !\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|offset
operator|/
name|RADEON_GPU_PAGE_SIZE
expr_stmt|;
name|p
operator|=
name|t
operator|/
operator|(
name|PAGE_SIZE
operator|/
name|RADEON_GPU_PAGE_SIZE
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pages
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
name|rdev
operator|->
name|gart
operator|.
name|pages
index|[
name|p
index|]
condition|)
block|{
name|rdev
operator|->
name|gart
operator|.
name|pages
index|[
name|p
index|]
operator|=
name|NULL
expr_stmt|;
name|rdev
operator|->
name|gart
operator|.
name|pages_addr
index|[
name|p
index|]
operator|=
name|rdev
operator|->
name|dummy_page
operator|.
name|addr
expr_stmt|;
name|page_base
operator|=
name|rdev
operator|->
name|gart
operator|.
name|pages_addr
index|[
name|p
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|PAGE_SIZE
operator|/
name|RADEON_GPU_PAGE_SIZE
operator|)
condition|;
name|j
operator|++
operator|,
name|t
operator|++
control|)
block|{
if|if
condition|(
name|rdev
operator|->
name|gart
operator|.
name|ptr
condition|)
block|{
name|radeon_gart_set_page
argument_list|(
name|rdev
argument_list|,
name|t
argument_list|,
name|page_base
argument_list|)
expr_stmt|;
block|}
name|page_base
operator|+=
name|RADEON_GPU_PAGE_SIZE
expr_stmt|;
block|}
block|}
block|}
name|mb
argument_list|()
expr_stmt|;
name|radeon_gart_tlb_flush
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_gart_bind - bind pages into the gart page table  *  * @rdev: radeon_device pointer  * @offset: offset into the GPU's gart aperture  * @pages: number of pages to bind  * @pagelist: pages to bind  * @dma_addr: DMA addresses of pages  *  * Binds the requested pages to the gart page table  * (all asics).  * Returns 0 for success, -EINVAL for failure.  */
end_comment

begin_function
name|int
name|radeon_gart_bind
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|unsigned
name|offset
parameter_list|,
name|int
name|pages
parameter_list|,
name|vm_page_t
modifier|*
name|pagelist
parameter_list|,
name|dma_addr_t
modifier|*
name|dma_addr
parameter_list|)
block|{
name|unsigned
name|t
decl_stmt|;
name|unsigned
name|p
decl_stmt|;
name|uint64_t
name|page_base
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|rdev
operator|->
name|gart
operator|.
name|ready
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"trying to bind memory to uninitialized GART !\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|t
operator|=
name|offset
operator|/
name|RADEON_GPU_PAGE_SIZE
expr_stmt|;
name|p
operator|=
name|t
operator|/
operator|(
name|PAGE_SIZE
operator|/
name|RADEON_GPU_PAGE_SIZE
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pages
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|rdev
operator|->
name|gart
operator|.
name|pages_addr
index|[
name|p
index|]
operator|=
name|dma_addr
index|[
name|i
index|]
expr_stmt|;
name|rdev
operator|->
name|gart
operator|.
name|pages
index|[
name|p
index|]
operator|=
name|pagelist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|gart
operator|.
name|ptr
condition|)
block|{
name|page_base
operator|=
name|rdev
operator|->
name|gart
operator|.
name|pages_addr
index|[
name|p
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|PAGE_SIZE
operator|/
name|RADEON_GPU_PAGE_SIZE
operator|)
condition|;
name|j
operator|++
operator|,
name|t
operator|++
control|)
block|{
name|radeon_gart_set_page
argument_list|(
name|rdev
argument_list|,
name|t
argument_list|,
name|page_base
argument_list|)
expr_stmt|;
name|page_base
operator|+=
name|RADEON_GPU_PAGE_SIZE
expr_stmt|;
block|}
block|}
block|}
name|mb
argument_list|()
expr_stmt|;
name|radeon_gart_tlb_flush
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_gart_restore - bind all pages in the gart page table  *  * @rdev: radeon_device pointer  *  * Binds all pages in the gart page table (all asics).  * Used to rebuild the gart table on device startup or resume.  */
end_comment

begin_function
name|void
name|radeon_gart_restore
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|t
decl_stmt|;
name|u64
name|page_base
decl_stmt|;
if|if
condition|(
operator|!
name|rdev
operator|->
name|gart
operator|.
name|ptr
condition|)
block|{
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|t
operator|=
literal|0
init|;
name|i
operator|<
name|rdev
operator|->
name|gart
operator|.
name|num_cpu_pages
condition|;
name|i
operator|++
control|)
block|{
name|page_base
operator|=
name|rdev
operator|->
name|gart
operator|.
name|pages_addr
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|PAGE_SIZE
operator|/
name|RADEON_GPU_PAGE_SIZE
operator|)
condition|;
name|j
operator|++
operator|,
name|t
operator|++
control|)
block|{
name|radeon_gart_set_page
argument_list|(
name|rdev
argument_list|,
name|t
argument_list|,
name|page_base
argument_list|)
expr_stmt|;
name|page_base
operator|+=
name|RADEON_GPU_PAGE_SIZE
expr_stmt|;
block|}
block|}
name|mb
argument_list|()
expr_stmt|;
name|radeon_gart_tlb_flush
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_gart_init - init the driver info for managing the gart  *  * @rdev: radeon_device pointer  *  * Allocate the dummy page and init the gart driver info (all asics).  * Returns 0 for success, error for failure.  */
end_comment

begin_function
name|int
name|radeon_gart_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|rdev
operator|->
name|gart
operator|.
name|pages
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* We need PAGE_SIZE>= RADEON_GPU_PAGE_SIZE */
if|if
condition|(
name|PAGE_SIZE
operator|<
name|RADEON_GPU_PAGE_SIZE
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Page size is smaller than GPU page size!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|r
operator|=
name|radeon_dummy_page_init
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
comment|/* Compute table size */
name|rdev
operator|->
name|gart
operator|.
name|num_cpu_pages
operator|=
name|rdev
operator|->
name|mc
operator|.
name|gtt_size
operator|/
name|PAGE_SIZE
expr_stmt|;
name|rdev
operator|->
name|gart
operator|.
name|num_gpu_pages
operator|=
name|rdev
operator|->
name|mc
operator|.
name|gtt_size
operator|/
name|RADEON_GPU_PAGE_SIZE
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"GART: num cpu pages %u, num gpu pages %u\n"
argument_list|,
name|rdev
operator|->
name|gart
operator|.
name|num_cpu_pages
argument_list|,
name|rdev
operator|->
name|gart
operator|.
name|num_gpu_pages
argument_list|)
expr_stmt|;
comment|/* Allocate pages table */
name|rdev
operator|->
name|gart
operator|.
name|pages
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|rdev
operator|->
name|gart
operator|.
name|num_cpu_pages
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|gart
operator|.
name|pages
operator|==
name|NULL
condition|)
block|{
name|radeon_gart_fini
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|rdev
operator|->
name|gart
operator|.
name|pages_addr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dma_addr_t
argument_list|)
operator|*
name|rdev
operator|->
name|gart
operator|.
name|num_cpu_pages
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|gart
operator|.
name|pages_addr
operator|==
name|NULL
condition|)
block|{
name|radeon_gart_fini
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
comment|/* set GART entry to point to the dummy page by default */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdev
operator|->
name|gart
operator|.
name|num_cpu_pages
condition|;
name|i
operator|++
control|)
block|{
name|rdev
operator|->
name|gart
operator|.
name|pages_addr
index|[
name|i
index|]
operator|=
name|rdev
operator|->
name|dummy_page
operator|.
name|addr
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_gart_fini - tear down the driver info for managing the gart  *  * @rdev: radeon_device pointer  *  * Tear down the gart driver info and free the dummy page (all asics).  */
end_comment

begin_function
name|void
name|radeon_gart_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|if
condition|(
name|rdev
operator|->
name|gart
operator|.
name|pages
operator|&&
name|rdev
operator|->
name|gart
operator|.
name|pages_addr
operator|&&
name|rdev
operator|->
name|gart
operator|.
name|ready
condition|)
block|{
comment|/* unbind pages */
name|radeon_gart_unbind
argument_list|(
name|rdev
argument_list|,
literal|0
argument_list|,
name|rdev
operator|->
name|gart
operator|.
name|num_cpu_pages
argument_list|)
expr_stmt|;
block|}
name|rdev
operator|->
name|gart
operator|.
name|ready
operator|=
name|false
expr_stmt|;
name|free
argument_list|(
name|rdev
operator|->
name|gart
operator|.
name|pages
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rdev
operator|->
name|gart
operator|.
name|pages_addr
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|gart
operator|.
name|pages
operator|=
name|NULL
expr_stmt|;
name|rdev
operator|->
name|gart
operator|.
name|pages_addr
operator|=
name|NULL
expr_stmt|;
name|radeon_dummy_page_fini
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * GPUVM  * GPUVM is similar to the legacy gart on older asics, however  * rather than there being a single global gart table  * for the entire GPU, there are multiple VM page tables active  * at any given time.  The VM page tables can contain a mix  * vram pages and system memory pages and system memory pages  * can be mapped as snooped (cached system pages) or unsnooped  * (uncached system pages).  * Each VM has an ID associated with it and there is a page table  * associated with each VMID.  When execting a command buffer,  * the kernel tells the the ring what VMID to use for that command  * buffer.  VMIDs are allocated dynamically as commands are submitted.  * The userspace drivers maintain their own address space and the kernel  * sets up their pages tables accordingly when they submit their  * command buffers and a VMID is assigned.  * Cayman/Trinity support up to 8 active VMs at any given time;  * SI supports 16.  */
end_comment

begin_comment
comment|/*  * vm helpers  *  * TODO bind a default page at vm initialization for default address  */
end_comment

begin_comment
comment|/**  * radeon_vm_num_pde - return the number of page directory entries  *  * @rdev: radeon_device pointer  *  * Calculate the number of page directory entries (cayman+).  */
end_comment

begin_function
specifier|static
name|unsigned
name|radeon_vm_num_pdes
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
return|return
name|rdev
operator|->
name|vm_manager
operator|.
name|max_pfn
operator|>>
name|RADEON_VM_BLOCK_SIZE
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_directory_size - returns the size of the page directory in bytes  *  * @rdev: radeon_device pointer  *  * Calculate the size of the page directory in bytes (cayman+).  */
end_comment

begin_function
specifier|static
name|unsigned
name|radeon_vm_directory_size
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
return|return
name|RADEON_GPU_PAGE_ALIGN
argument_list|(
name|radeon_vm_num_pdes
argument_list|(
name|rdev
argument_list|)
operator|*
literal|8
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_manager_init - init the vm manager  *  * @rdev: radeon_device pointer  *  * Init the vm manager (cayman+).  * Returns 0 for success, error for failure.  */
end_comment

begin_function
name|int
name|radeon_vm_manager_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|struct
name|radeon_vm
modifier|*
name|vm
decl_stmt|;
name|struct
name|radeon_bo_va
modifier|*
name|bo_va
decl_stmt|;
name|int
name|r
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|rdev
operator|->
name|vm_manager
operator|.
name|enabled
condition|)
block|{
comment|/* allocate enough for 2 full VM pts */
name|size
operator|=
name|radeon_vm_directory_size
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|size
operator|+=
name|rdev
operator|->
name|vm_manager
operator|.
name|max_pfn
operator|*
literal|8
expr_stmt|;
name|size
operator|*=
literal|2
expr_stmt|;
name|r
operator|=
name|radeon_sa_bo_manager_init
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|sa_manager
argument_list|,
name|RADEON_GPU_PAGE_ALIGN
argument_list|(
name|size
argument_list|)
argument_list|,
name|RADEON_GEM_DOMAIN_VRAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"failed to allocate vm bo (%dKB)\n"
argument_list|,
operator|(
name|rdev
operator|->
name|vm_manager
operator|.
name|max_pfn
operator|*
literal|8
operator|)
operator|>>
literal|10
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|r
operator|=
name|radeon_asic_vm_init
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|rdev
operator|->
name|vm_manager
operator|.
name|enabled
operator|=
name|true
expr_stmt|;
name|r
operator|=
name|radeon_sa_bo_manager_start
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|sa_manager
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
block|}
comment|/* restore page table */
name|list_for_each_entry
argument_list|(
argument|vm
argument_list|,
argument|&rdev->vm_manager.lru_vm
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|vm
operator|->
name|page_directory
operator|==
name|NULL
condition|)
continue|continue;
name|list_for_each_entry
argument_list|(
argument|bo_va
argument_list|,
argument|&vm->va
argument_list|,
argument|vm_list
argument_list|)
block|{
name|bo_va
operator|->
name|valid
operator|=
name|false
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_free_pt - free the page table for a specific vm  *  * @rdev: radeon_device pointer  * @vm: vm to unbind  *  * Free the page table of a specific vm (cayman+).  *  * Global and local mutex must be lock!  */
end_comment

begin_function
specifier|static
name|void
name|radeon_vm_free_pt
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_vm
modifier|*
name|vm
parameter_list|)
block|{
name|struct
name|radeon_bo_va
modifier|*
name|bo_va
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|vm
operator|->
name|page_directory
condition|)
return|return;
name|list_del_init
argument_list|(
operator|&
name|vm
operator|->
name|list
argument_list|)
expr_stmt|;
name|radeon_sa_bo_free
argument_list|(
name|rdev
argument_list|,
operator|&
name|vm
operator|->
name|page_directory
argument_list|,
name|vm
operator|->
name|fence
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|bo_va
argument_list|,
argument|&vm->va
argument_list|,
argument|vm_list
argument_list|)
block|{
name|bo_va
operator|->
name|valid
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|vm
operator|->
name|page_tables
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|radeon_vm_num_pdes
argument_list|(
name|rdev
argument_list|)
condition|;
name|i
operator|++
control|)
name|radeon_sa_bo_free
argument_list|(
name|rdev
argument_list|,
operator|&
name|vm
operator|->
name|page_tables
index|[
name|i
index|]
argument_list|,
name|vm
operator|->
name|fence
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vm
operator|->
name|page_tables
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_manager_fini - tear down the vm manager  *  * @rdev: radeon_device pointer  *  * Tear down the VM manager (cayman+).  */
end_comment

begin_function
name|void
name|radeon_vm_manager_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|struct
name|radeon_vm
modifier|*
name|vm
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|rdev
operator|->
name|vm_manager
operator|.
name|enabled
condition|)
return|return;
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* free all allocated page tables */
name|list_for_each_entry_safe
argument_list|(
argument|vm
argument_list|,
argument|tmp
argument_list|,
argument|&rdev->vm_manager.lru_vm
argument_list|,
argument|list
argument_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|vm
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|radeon_vm_free_pt
argument_list|(
name|rdev
argument_list|,
name|vm
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|vm
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_VM
condition|;
operator|++
name|i
control|)
block|{
name|radeon_fence_unref
argument_list|(
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|active
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|radeon_asic_vm_fini
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|lock
argument_list|)
expr_stmt|;
name|radeon_sa_bo_manager_suspend
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|sa_manager
argument_list|)
expr_stmt|;
name|radeon_sa_bo_manager_fini
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|sa_manager
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|vm_manager
operator|.
name|enabled
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_evict - evict page table to make room for new one  *  * @rdev: radeon_device pointer  * @vm: VM we want to allocate something for  *  * Evict a VM from the lru, making sure that it isn't @vm. (cayman+).  * Returns 0 for success, -ENOMEM for failure.  *  * Global and local mutex must be locked!  */
end_comment

begin_function
specifier|static
name|int
name|radeon_vm_evict
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_vm
modifier|*
name|vm
parameter_list|)
block|{
name|struct
name|radeon_vm
modifier|*
name|vm_evict
decl_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|lru_vm
argument_list|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|vm_evict
operator|=
name|list_first_entry
argument_list|(
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|lru_vm
argument_list|,
expr|struct
name|radeon_vm
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_evict
operator|==
name|vm
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|sx_xlock
argument_list|(
operator|&
name|vm_evict
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|radeon_vm_free_pt
argument_list|(
name|rdev
argument_list|,
name|vm_evict
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|vm_evict
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_alloc_pt - allocates a page table for a VM  *  * @rdev: radeon_device pointer  * @vm: vm to bind  *  * Allocate a page table for the requested vm (cayman+).  * Returns 0 for success, error for failure.  *  * Global and local mutex must be locked!  */
end_comment

begin_function
name|int
name|radeon_vm_alloc_pt
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_vm
modifier|*
name|vm
parameter_list|)
block|{
name|unsigned
name|pd_size
decl_stmt|,
name|pts_size
decl_stmt|;
name|u64
modifier|*
name|pd_addr
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|vm
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|vm
operator|->
name|page_directory
operator|!=
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|retry
label|:
name|pd_size
operator|=
name|RADEON_GPU_PAGE_ALIGN
argument_list|(
name|radeon_vm_directory_size
argument_list|(
name|rdev
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|radeon_sa_bo_new
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|sa_manager
argument_list|,
operator|&
name|vm
operator|->
name|page_directory
argument_list|,
name|pd_size
argument_list|,
name|RADEON_GPU_PAGE_SIZE
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
name|ENOMEM
condition|)
block|{
name|r
operator|=
name|radeon_vm_evict
argument_list|(
name|rdev
argument_list|,
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|r
condition|)
block|{
return|return
name|r
return|;
block|}
name|vm
operator|->
name|pd_gpu_addr
operator|=
name|radeon_sa_bo_gpu_addr
argument_list|(
name|vm
operator|->
name|page_directory
argument_list|)
expr_stmt|;
comment|/* Initially clear the page directory */
name|pd_addr
operator|=
name|radeon_sa_bo_cpu_addr
argument_list|(
name|vm
operator|->
name|page_directory
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pd_addr
argument_list|,
literal|0
argument_list|,
name|pd_size
argument_list|)
expr_stmt|;
name|pts_size
operator|=
name|radeon_vm_num_pdes
argument_list|(
name|rdev
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|radeon_sa_bo
operator|*
argument_list|)
expr_stmt|;
name|vm
operator|->
name|page_tables
operator|=
name|malloc
argument_list|(
name|pts_size
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|page_tables
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Cannot allocate memory for page table array\n"
argument_list|)
expr_stmt|;
name|radeon_sa_bo_free
argument_list|(
name|rdev
argument_list|,
operator|&
name|vm
operator|->
name|page_directory
argument_list|,
name|vm
operator|->
name|fence
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_add_to_lru - add VMs page table to LRU list  *  * @rdev: radeon_device pointer  * @vm: vm to add to LRU  *  * Add the allocated page table to the LRU list (cayman+).  *  * Global mutex must be locked!  */
end_comment

begin_function
name|void
name|radeon_vm_add_to_lru
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_vm
modifier|*
name|vm
parameter_list|)
block|{
name|list_del_init
argument_list|(
operator|&
name|vm
operator|->
name|list
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|vm
operator|->
name|list
argument_list|,
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|lru_vm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_grab_id - allocate the next free VMID  *  * @rdev: radeon_device pointer  * @vm: vm to allocate id for  * @ring: ring we want to submit job to  *  * Allocate an id for the vm (cayman+).  * Returns the fence we need to sync to (if any).  *  * Global and local mutex must be locked!  */
end_comment

begin_function
name|struct
name|radeon_fence
modifier|*
name|radeon_vm_grab_id
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_vm
modifier|*
name|vm
parameter_list|,
name|int
name|ring
parameter_list|)
block|{
name|struct
name|radeon_fence
modifier|*
name|best
index|[
name|RADEON_NUM_RINGS
index|]
init|=
block|{}
decl_stmt|;
name|unsigned
name|choices
index|[
literal|2
index|]
init|=
block|{}
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* check if the id is still valid */
if|if
condition|(
name|vm
operator|->
name|fence
operator|&&
name|vm
operator|->
name|fence
operator|==
name|rdev
operator|->
name|vm_manager
operator|.
name|active
index|[
name|vm
operator|->
name|id
index|]
condition|)
return|return
name|NULL
return|;
comment|/* we definately need to flush */
name|radeon_fence_unref
argument_list|(
operator|&
name|vm
operator|->
name|last_flush
argument_list|)
expr_stmt|;
comment|/* skip over VMID 0, since it is the system VM */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rdev
operator|->
name|vm_manager
operator|.
name|nvm
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|radeon_fence
modifier|*
name|fence
init|=
name|rdev
operator|->
name|vm_manager
operator|.
name|active
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|fence
operator|==
name|NULL
condition|)
block|{
comment|/* found a free one */
name|vm
operator|->
name|id
operator|=
name|i
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|radeon_fence_is_earlier
argument_list|(
name|fence
argument_list|,
name|best
index|[
name|fence
operator|->
name|ring
index|]
argument_list|)
condition|)
block|{
name|best
index|[
name|fence
operator|->
name|ring
index|]
operator|=
name|fence
expr_stmt|;
name|choices
index|[
name|fence
operator|->
name|ring
operator|==
name|ring
condition|?
literal|0
else|:
literal|1
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|choices
index|[
name|i
index|]
condition|)
block|{
name|vm
operator|->
name|id
operator|=
name|choices
index|[
name|i
index|]
expr_stmt|;
return|return
name|rdev
operator|->
name|vm_manager
operator|.
name|active
index|[
name|choices
index|[
name|i
index|]
index|]
return|;
block|}
block|}
comment|/* should never happen */
name|panic
argument_list|(
literal|"%s: failed to allocate next VMID"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_fence - remember fence for vm  *  * @rdev: radeon_device pointer  * @vm: vm we want to fence  * @fence: fence to remember  *  * Fence the vm (cayman+).  * Set the fence used to protect page table and id.  *  * Global and local mutex must be locked!  */
end_comment

begin_function
name|void
name|radeon_vm_fence
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_vm
modifier|*
name|vm
parameter_list|,
name|struct
name|radeon_fence
modifier|*
name|fence
parameter_list|)
block|{
name|radeon_fence_unref
argument_list|(
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|active
index|[
name|vm
operator|->
name|id
index|]
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|vm_manager
operator|.
name|active
index|[
name|vm
operator|->
name|id
index|]
operator|=
name|radeon_fence_ref
argument_list|(
name|fence
argument_list|)
expr_stmt|;
name|radeon_fence_unref
argument_list|(
operator|&
name|vm
operator|->
name|fence
argument_list|)
expr_stmt|;
name|vm
operator|->
name|fence
operator|=
name|radeon_fence_ref
argument_list|(
name|fence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_bo_find - find the bo_va for a specific vm& bo  *  * @vm: requested vm  * @bo: requested buffer object  *  * Find @bo inside the requested vm (cayman+).  * Search inside the @bos vm list for the requested vm  * Returns the found bo_va or NULL if none is found  *  * Object has to be reserved!  */
end_comment

begin_function
name|struct
name|radeon_bo_va
modifier|*
name|radeon_vm_bo_find
parameter_list|(
name|struct
name|radeon_vm
modifier|*
name|vm
parameter_list|,
name|struct
name|radeon_bo
modifier|*
name|bo
parameter_list|)
block|{
name|struct
name|radeon_bo_va
modifier|*
name|bo_va
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|bo_va
argument_list|,
argument|&bo->va
argument_list|,
argument|bo_list
argument_list|)
block|{
if|if
condition|(
name|bo_va
operator|->
name|vm
operator|==
name|vm
condition|)
block|{
return|return
name|bo_va
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_bo_add - add a bo to a specific vm  *  * @rdev: radeon_device pointer  * @vm: requested vm  * @bo: radeon buffer object  *  * Add @bo into the requested vm (cayman+).  * Add @bo to the list of bos associated with the vm  * Returns newly added bo_va or NULL for failure  *  * Object has to be reserved!  */
end_comment

begin_function
name|struct
name|radeon_bo_va
modifier|*
name|radeon_vm_bo_add
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_vm
modifier|*
name|vm
parameter_list|,
name|struct
name|radeon_bo
modifier|*
name|bo
parameter_list|)
block|{
name|struct
name|radeon_bo_va
modifier|*
name|bo_va
decl_stmt|;
name|bo_va
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|radeon_bo_va
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bo_va
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|bo_va
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|bo_va
operator|->
name|bo
operator|=
name|bo
expr_stmt|;
name|bo_va
operator|->
name|soffset
operator|=
literal|0
expr_stmt|;
name|bo_va
operator|->
name|eoffset
operator|=
literal|0
expr_stmt|;
name|bo_va
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|bo_va
operator|->
name|valid
operator|=
name|false
expr_stmt|;
name|bo_va
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|bo_va
operator|->
name|bo_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|bo_va
operator|->
name|vm_list
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|vm
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|bo_va
operator|->
name|vm_list
argument_list|,
operator|&
name|vm
operator|->
name|va
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|bo_va
operator|->
name|bo_list
argument_list|,
operator|&
name|bo
operator|->
name|va
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|vm
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|bo_va
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_bo_set_addr - set bos virtual address inside a vm  *  * @rdev: radeon_device pointer  * @bo_va: bo_va to store the address  * @soffset: requested offset of the buffer in the VM address space  * @flags: attributes of pages (read/write/valid/etc.)  *  * Set offset of @bo_va (cayman+).  * Validate and set the offset requested within the vm address space.  * Returns 0 for success, error for failure.  *  * Object has to be reserved!  */
end_comment

begin_function
name|int
name|radeon_vm_bo_set_addr
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_bo_va
modifier|*
name|bo_va
parameter_list|,
name|uint64_t
name|soffset
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|uint64_t
name|size
init|=
name|radeon_bo_size
argument_list|(
name|bo_va
operator|->
name|bo
argument_list|)
decl_stmt|;
name|uint64_t
name|eoffset
decl_stmt|,
name|last_offset
init|=
literal|0
decl_stmt|;
name|struct
name|radeon_vm
modifier|*
name|vm
init|=
name|bo_va
operator|->
name|vm
decl_stmt|;
name|struct
name|radeon_bo_va
modifier|*
name|tmp
decl_stmt|;
name|struct
name|list_head
modifier|*
name|head
decl_stmt|;
name|unsigned
name|last_pfn
decl_stmt|;
if|if
condition|(
name|soffset
condition|)
block|{
comment|/* make sure object fit at this offset */
name|eoffset
operator|=
name|soffset
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|soffset
operator|>=
name|eoffset
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
name|last_pfn
operator|=
name|eoffset
operator|/
name|RADEON_GPU_PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|last_pfn
operator|>
name|rdev
operator|->
name|vm_manager
operator|.
name|max_pfn
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"va above limit (0x%08X> 0x%08X)\n"
argument_list|,
name|last_pfn
argument_list|,
name|rdev
operator|->
name|vm_manager
operator|.
name|max_pfn
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
else|else
block|{
name|eoffset
operator|=
name|last_pfn
operator|=
literal|0
expr_stmt|;
block|}
name|sx_xlock
argument_list|(
operator|&
name|vm
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|head
operator|=
operator|&
name|vm
operator|->
name|va
expr_stmt|;
name|last_offset
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|tmp
argument_list|,
argument|&vm->va
argument_list|,
argument|vm_list
argument_list|)
block|{
if|if
condition|(
name|bo_va
operator|==
name|tmp
condition|)
block|{
comment|/* skip over currently modified bo */
continue|continue;
block|}
if|if
condition|(
name|soffset
operator|>=
name|last_offset
operator|&&
name|eoffset
operator|<=
name|tmp
operator|->
name|soffset
condition|)
block|{
comment|/* bo can be added before this one */
break|break;
block|}
if|if
condition|(
name|eoffset
operator|>
name|tmp
operator|->
name|soffset
operator|&&
name|soffset
operator|<
name|tmp
operator|->
name|eoffset
condition|)
block|{
comment|/* bo and tmp overlap, invalid offset */
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"bo %p va 0x%08X conflict with (bo %p 0x%08X 0x%08X)\n"
argument_list|,
name|bo_va
operator|->
name|bo
argument_list|,
operator|(
name|unsigned
operator|)
name|bo_va
operator|->
name|soffset
argument_list|,
name|tmp
operator|->
name|bo
argument_list|,
operator|(
name|unsigned
operator|)
name|tmp
operator|->
name|soffset
argument_list|,
operator|(
name|unsigned
operator|)
name|tmp
operator|->
name|eoffset
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|vm
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|last_offset
operator|=
name|tmp
operator|->
name|eoffset
expr_stmt|;
name|head
operator|=
operator|&
name|tmp
operator|->
name|vm_list
expr_stmt|;
block|}
name|bo_va
operator|->
name|soffset
operator|=
name|soffset
expr_stmt|;
name|bo_va
operator|->
name|eoffset
operator|=
name|eoffset
expr_stmt|;
name|bo_va
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|bo_va
operator|->
name|valid
operator|=
name|false
expr_stmt|;
name|list_move
argument_list|(
operator|&
name|bo_va
operator|->
name|vm_list
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|vm
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_map_gart - get the physical address of a gart page  *  * @rdev: radeon_device pointer  * @addr: the unmapped addr  *  * Look up the physical address of the page that the pte resolves  * to (cayman+).  * Returns the physical address of the page.  */
end_comment

begin_function
name|uint64_t
name|radeon_vm_map_gart
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|uint64_t
name|addr
parameter_list|)
block|{
name|uint64_t
name|result
decl_stmt|;
comment|/* page table offset */
name|result
operator|=
name|rdev
operator|->
name|gart
operator|.
name|pages_addr
index|[
name|addr
operator|>>
name|PAGE_SHIFT
index|]
expr_stmt|;
comment|/* in case cpu page size != gpu page size*/
comment|/* 	 * FreeBSD port note: FreeBSD's PAGE_MASK is the inverse of 	 * Linux's one. That's why the test below doesn't inverse the 	 * constant. 	 */
name|result
operator||=
name|addr
operator|&
operator|(
name|PAGE_MASK
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_update_pdes - make sure that page directory is valid  *  * @rdev: radeon_device pointer  * @vm: requested vm  * @start: start of GPU address range  * @end: end of GPU address range  *  * Allocates new page tables if necessary  * and updates the page directory (cayman+).  * Returns 0 for success, error for failure.  *  * Global and local mutex must be locked!  */
end_comment

begin_function
specifier|static
name|int
name|radeon_vm_update_pdes
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_vm
modifier|*
name|vm
parameter_list|,
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|end
parameter_list|)
block|{
specifier|static
specifier|const
name|uint32_t
name|incr
init|=
name|RADEON_VM_PTE_COUNT
operator|*
literal|8
decl_stmt|;
name|uint64_t
name|last_pde
init|=
operator|~
literal|0
decl_stmt|,
name|last_pt
init|=
operator|~
literal|0
decl_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
name|uint64_t
name|pt_idx
decl_stmt|;
name|int
name|r
decl_stmt|;
name|start
operator|=
operator|(
name|start
operator|/
name|RADEON_GPU_PAGE_SIZE
operator|)
operator|>>
name|RADEON_VM_BLOCK_SIZE
expr_stmt|;
name|end
operator|=
operator|(
name|end
operator|/
name|RADEON_GPU_PAGE_SIZE
operator|)
operator|>>
name|RADEON_VM_BLOCK_SIZE
expr_stmt|;
comment|/* walk over the address space and update the page directory */
for|for
control|(
name|pt_idx
operator|=
name|start
init|;
name|pt_idx
operator|<=
name|end
condition|;
operator|++
name|pt_idx
control|)
block|{
name|uint64_t
name|pde
decl_stmt|,
name|pt
decl_stmt|;
if|if
condition|(
name|vm
operator|->
name|page_tables
index|[
name|pt_idx
index|]
condition|)
continue|continue;
name|retry
label|:
name|r
operator|=
name|radeon_sa_bo_new
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|sa_manager
argument_list|,
operator|&
name|vm
operator|->
name|page_tables
index|[
name|pt_idx
index|]
argument_list|,
name|RADEON_VM_PTE_COUNT
operator|*
literal|8
argument_list|,
name|RADEON_GPU_PAGE_SIZE
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
name|ENOMEM
condition|)
block|{
name|r
operator|=
name|radeon_vm_evict
argument_list|(
name|rdev
argument_list|,
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|r
condition|)
block|{
return|return
name|r
return|;
block|}
name|pde
operator|=
name|vm
operator|->
name|pd_gpu_addr
operator|+
name|pt_idx
operator|*
literal|8
expr_stmt|;
name|pt
operator|=
name|radeon_sa_bo_gpu_addr
argument_list|(
name|vm
operator|->
name|page_tables
index|[
name|pt_idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|last_pde
operator|+
literal|8
operator|*
name|count
operator|)
operator|!=
name|pde
operator|)
operator|||
operator|(
operator|(
name|last_pt
operator|+
name|incr
operator|*
name|count
operator|)
operator|!=
name|pt
operator|)
condition|)
block|{
if|if
condition|(
name|count
condition|)
block|{
name|radeon_asic_vm_set_page
argument_list|(
name|rdev
argument_list|,
name|last_pde
argument_list|,
name|last_pt
argument_list|,
name|count
argument_list|,
name|incr
argument_list|,
name|RADEON_VM_PAGE_VALID
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
literal|1
expr_stmt|;
name|last_pde
operator|=
name|pde
expr_stmt|;
name|last_pt
operator|=
name|pt
expr_stmt|;
block|}
else|else
block|{
operator|++
name|count
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
condition|)
block|{
name|radeon_asic_vm_set_page
argument_list|(
name|rdev
argument_list|,
name|last_pde
argument_list|,
name|last_pt
argument_list|,
name|count
argument_list|,
name|incr
argument_list|,
name|RADEON_VM_PAGE_VALID
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_update_ptes - make sure that page tables are valid  *  * @rdev: radeon_device pointer  * @vm: requested vm  * @start: start of GPU address range  * @end: end of GPU address range  * @dst: destination address to map to  * @flags: mapping flags  *  * Update the page tables in the range @start - @end (cayman+).  *  * Global and local mutex must be locked!  */
end_comment

begin_function
specifier|static
name|void
name|radeon_vm_update_ptes
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_vm
modifier|*
name|vm
parameter_list|,
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|end
parameter_list|,
name|uint64_t
name|dst
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
specifier|static
specifier|const
name|uint64_t
name|mask
init|=
name|RADEON_VM_PTE_COUNT
operator|-
literal|1
decl_stmt|;
name|uint64_t
name|last_pte
init|=
operator|~
literal|0
decl_stmt|,
name|last_dst
init|=
operator|~
literal|0
decl_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|start
operator|=
name|start
operator|/
name|RADEON_GPU_PAGE_SIZE
expr_stmt|;
name|end
operator|=
name|end
operator|/
name|RADEON_GPU_PAGE_SIZE
expr_stmt|;
comment|/* walk over the address space and update the page tables */
for|for
control|(
name|addr
operator|=
name|start
init|;
name|addr
operator|<
name|end
condition|;
control|)
block|{
name|uint64_t
name|pt_idx
init|=
name|addr
operator|>>
name|RADEON_VM_BLOCK_SIZE
decl_stmt|;
name|unsigned
name|nptes
decl_stmt|;
name|uint64_t
name|pte
decl_stmt|;
if|if
condition|(
operator|(
name|addr
operator|&
operator|~
name|mask
operator|)
operator|==
operator|(
name|end
operator|&
operator|~
name|mask
operator|)
condition|)
name|nptes
operator|=
name|end
operator|-
name|addr
expr_stmt|;
else|else
name|nptes
operator|=
name|RADEON_VM_PTE_COUNT
operator|-
operator|(
name|addr
operator|&
name|mask
operator|)
expr_stmt|;
name|pte
operator|=
name|radeon_sa_bo_gpu_addr
argument_list|(
name|vm
operator|->
name|page_tables
index|[
name|pt_idx
index|]
argument_list|)
expr_stmt|;
name|pte
operator|+=
operator|(
name|addr
operator|&
name|mask
operator|)
operator|*
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|last_pte
operator|+
literal|8
operator|*
name|count
operator|)
operator|!=
name|pte
condition|)
block|{
if|if
condition|(
name|count
condition|)
block|{
name|radeon_asic_vm_set_page
argument_list|(
name|rdev
argument_list|,
name|last_pte
argument_list|,
name|last_dst
argument_list|,
name|count
argument_list|,
name|RADEON_GPU_PAGE_SIZE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|nptes
expr_stmt|;
name|last_pte
operator|=
name|pte
expr_stmt|;
name|last_dst
operator|=
name|dst
expr_stmt|;
block|}
else|else
block|{
name|count
operator|+=
name|nptes
expr_stmt|;
block|}
name|addr
operator|+=
name|nptes
expr_stmt|;
name|dst
operator|+=
name|nptes
operator|*
name|RADEON_GPU_PAGE_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
block|{
name|radeon_asic_vm_set_page
argument_list|(
name|rdev
argument_list|,
name|last_pte
argument_list|,
name|last_dst
argument_list|,
name|count
argument_list|,
name|RADEON_GPU_PAGE_SIZE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_vm_bo_update_pte - map a bo into the vm page table  *  * @rdev: radeon_device pointer  * @vm: requested vm  * @bo: radeon buffer object  * @mem: ttm mem  *  * Fill in the page table entries for @bo (cayman+).  * Returns 0 for success, -EINVAL for failure.  *  * Object have to be reserved& global and local mutex must be locked!  */
end_comment

begin_function
name|int
name|radeon_vm_bo_update_pte
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_vm
modifier|*
name|vm
parameter_list|,
name|struct
name|radeon_bo
modifier|*
name|bo
parameter_list|,
name|struct
name|ttm_mem_reg
modifier|*
name|mem
parameter_list|)
block|{
name|unsigned
name|ridx
init|=
name|rdev
operator|->
name|asic
operator|->
name|vm
operator|.
name|pt_ring_index
decl_stmt|;
name|struct
name|radeon_ring
modifier|*
name|ring
init|=
operator|&
name|rdev
operator|->
name|ring
index|[
name|ridx
index|]
decl_stmt|;
name|struct
name|radeon_semaphore
modifier|*
name|sem
init|=
name|NULL
decl_stmt|;
name|struct
name|radeon_bo_va
modifier|*
name|bo_va
decl_stmt|;
name|unsigned
name|nptes
decl_stmt|,
name|npdes
decl_stmt|,
name|ndw
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* nothing to do if vm isn't bound */
if|if
condition|(
name|vm
operator|->
name|page_directory
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|bo_va
operator|=
name|radeon_vm_bo_find
argument_list|(
name|vm
argument_list|,
name|bo
argument_list|)
expr_stmt|;
if|if
condition|(
name|bo_va
operator|==
name|NULL
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"bo %p not in vm %p\n"
argument_list|,
name|bo
argument_list|,
name|vm
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
name|bo_va
operator|->
name|soffset
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"bo %p don't has a mapping in vm %p\n"
argument_list|,
name|bo
argument_list|,
name|vm
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
name|bo_va
operator|->
name|valid
operator|&&
name|mem
operator|)
operator|||
operator|(
operator|!
name|bo_va
operator|->
name|valid
operator|&&
name|mem
operator|==
name|NULL
operator|)
condition|)
return|return
literal|0
return|;
name|bo_va
operator|->
name|flags
operator|&=
operator|~
name|RADEON_VM_PAGE_VALID
expr_stmt|;
name|bo_va
operator|->
name|flags
operator|&=
operator|~
name|RADEON_VM_PAGE_SYSTEM
expr_stmt|;
if|if
condition|(
name|mem
condition|)
block|{
name|addr
operator|=
name|mem
operator|->
name|start
operator|<<
name|PAGE_SHIFT
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|mem_type
operator|!=
name|TTM_PL_SYSTEM
condition|)
block|{
name|bo_va
operator|->
name|flags
operator||=
name|RADEON_VM_PAGE_VALID
expr_stmt|;
name|bo_va
operator|->
name|valid
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|mem
operator|->
name|mem_type
operator|==
name|TTM_PL_TT
condition|)
block|{
name|bo_va
operator|->
name|flags
operator||=
name|RADEON_VM_PAGE_SYSTEM
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|+=
name|rdev
operator|->
name|vm_manager
operator|.
name|vram_base_offset
expr_stmt|;
block|}
block|}
else|else
block|{
name|addr
operator|=
literal|0
expr_stmt|;
name|bo_va
operator|->
name|valid
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|vm
operator|->
name|fence
operator|&&
name|radeon_fence_signaled
argument_list|(
name|vm
operator|->
name|fence
argument_list|)
condition|)
block|{
name|radeon_fence_unref
argument_list|(
operator|&
name|vm
operator|->
name|fence
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vm
operator|->
name|fence
operator|&&
name|vm
operator|->
name|fence
operator|->
name|ring
operator|!=
name|ridx
condition|)
block|{
name|r
operator|=
name|radeon_semaphore_create
argument_list|(
name|rdev
argument_list|,
operator|&
name|sem
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
return|return
name|r
return|;
block|}
block|}
name|nptes
operator|=
name|radeon_bo_ngpu_pages
argument_list|(
name|bo
argument_list|)
expr_stmt|;
comment|/* assume two extra pdes in case the mapping overlaps the borders */
name|npdes
operator|=
operator|(
name|nptes
operator|>>
name|RADEON_VM_BLOCK_SIZE
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* estimate number of dw needed */
comment|/* semaphore, fence and padding */
name|ndw
operator|=
literal|32
expr_stmt|;
if|if
condition|(
name|RADEON_VM_BLOCK_SIZE
operator|>
literal|11
condition|)
comment|/* reserve space for one header for every 2k dwords */
name|ndw
operator|+=
operator|(
name|nptes
operator|>>
literal|11
operator|)
operator|*
literal|4
expr_stmt|;
else|else
comment|/* reserve space for one header for 		    every (1<< BLOCK_SIZE) entries */
name|ndw
operator|+=
operator|(
name|nptes
operator|>>
name|RADEON_VM_BLOCK_SIZE
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* reserve space for pte addresses */
name|ndw
operator|+=
name|nptes
operator|*
literal|2
expr_stmt|;
comment|/* reserve space for one header for every 2k dwords */
name|ndw
operator|+=
operator|(
name|npdes
operator|>>
literal|11
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* reserve space for pde addresses */
name|ndw
operator|+=
name|npdes
operator|*
literal|2
expr_stmt|;
name|r
operator|=
name|radeon_ring_lock
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|,
name|ndw
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
return|return
name|r
return|;
block|}
if|if
condition|(
name|sem
operator|&&
name|radeon_fence_need_sync
argument_list|(
name|vm
operator|->
name|fence
argument_list|,
name|ridx
argument_list|)
condition|)
block|{
name|radeon_semaphore_sync_rings
argument_list|(
name|rdev
argument_list|,
name|sem
argument_list|,
name|vm
operator|->
name|fence
operator|->
name|ring
argument_list|,
name|ridx
argument_list|)
expr_stmt|;
name|radeon_fence_note_sync
argument_list|(
name|vm
operator|->
name|fence
argument_list|,
name|ridx
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|radeon_vm_update_pdes
argument_list|(
name|rdev
argument_list|,
name|vm
argument_list|,
name|bo_va
operator|->
name|soffset
argument_list|,
name|bo_va
operator|->
name|eoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|radeon_ring_unlock_undo
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|radeon_vm_update_ptes
argument_list|(
name|rdev
argument_list|,
name|vm
argument_list|,
name|bo_va
operator|->
name|soffset
argument_list|,
name|bo_va
operator|->
name|eoffset
argument_list|,
name|addr
argument_list|,
name|bo_va
operator|->
name|flags
argument_list|)
expr_stmt|;
name|radeon_fence_unref
argument_list|(
operator|&
name|vm
operator|->
name|fence
argument_list|)
expr_stmt|;
name|r
operator|=
name|radeon_fence_emit
argument_list|(
name|rdev
argument_list|,
operator|&
name|vm
operator|->
name|fence
argument_list|,
name|ridx
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|radeon_ring_unlock_undo
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|radeon_ring_unlock_commit
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|radeon_semaphore_free
argument_list|(
name|rdev
argument_list|,
operator|&
name|sem
argument_list|,
name|vm
operator|->
name|fence
argument_list|)
expr_stmt|;
name|radeon_fence_unref
argument_list|(
operator|&
name|vm
operator|->
name|last_flush
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_bo_rmv - remove a bo to a specific vm  *  * @rdev: radeon_device pointer  * @bo_va: requested bo_va  *  * Remove @bo_va->bo from the requested vm (cayman+).  * Remove @bo_va->bo from the list of bos associated with the bo_va->vm and  * remove the ptes for @bo_va in the page table.  * Returns 0 for success.  *  * Object have to be reserved!  */
end_comment

begin_function
name|int
name|radeon_vm_bo_rmv
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_bo_va
modifier|*
name|bo_va
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|lock
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|bo_va
operator|->
name|vm
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|r
operator|=
name|radeon_vm_bo_update_pte
argument_list|(
name|rdev
argument_list|,
name|bo_va
operator|->
name|vm
argument_list|,
name|bo_va
operator|->
name|bo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|lock
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|bo_va
operator|->
name|vm_list
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|bo_va
operator|->
name|vm
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|bo_va
operator|->
name|bo_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bo_va
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_bo_invalidate - mark the bo as invalid  *  * @rdev: radeon_device pointer  * @vm: requested vm  * @bo: radeon buffer object  *  * Mark @bo as invalid (cayman+).  */
end_comment

begin_function
name|void
name|radeon_vm_bo_invalidate
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_bo
modifier|*
name|bo
parameter_list|)
block|{
name|struct
name|radeon_bo_va
modifier|*
name|bo_va
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|bo_va
argument_list|,
argument|&bo->va
argument_list|,
argument|bo_list
argument_list|)
block|{
name|bo_va
operator|->
name|valid
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_vm_init - initialize a vm instance  *  * @rdev: radeon_device pointer  * @vm: requested vm  *  * Init @vm fields (cayman+).  */
end_comment

begin_function
name|void
name|radeon_vm_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_vm
modifier|*
name|vm
parameter_list|)
block|{
name|vm
operator|->
name|id
operator|=
literal|0
expr_stmt|;
name|vm
operator|->
name|fence
operator|=
name|NULL
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|vm
operator|->
name|mutex
argument_list|,
literal|"drm__radeon_vm__mutex"
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|vm
operator|->
name|list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|vm
operator|->
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_vm_fini - tear down a vm instance  *  * @rdev: radeon_device pointer  * @vm: requested vm  *  * Tear down @vm (cayman+).  * Unbind the VM and remove all bos from the vm bo list  */
end_comment

begin_function
name|void
name|radeon_vm_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_vm
modifier|*
name|vm
parameter_list|)
block|{
name|struct
name|radeon_bo_va
modifier|*
name|bo_va
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|r
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|lock
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|vm
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|radeon_vm_free_pt
argument_list|(
name|rdev
argument_list|,
name|vm
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|vm
operator|->
name|va
argument_list|)
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"still active bo inside vm\n"
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|bo_va
argument_list|,
argument|tmp
argument_list|,
argument|&vm->va
argument_list|,
argument|vm_list
argument_list|)
block|{
name|list_del_init
argument_list|(
operator|&
name|bo_va
operator|->
name|vm_list
argument_list|)
expr_stmt|;
name|r
operator|=
name|radeon_bo_reserve
argument_list|(
name|bo_va
operator|->
name|bo
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|list_del_init
argument_list|(
operator|&
name|bo_va
operator|->
name|bo_list
argument_list|)
expr_stmt|;
name|radeon_bo_unreserve
argument_list|(
name|bo_va
operator|->
name|bo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bo_va
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
block|}
block|}
name|radeon_fence_unref
argument_list|(
operator|&
name|vm
operator|->
name|fence
argument_list|)
expr_stmt|;
name|radeon_fence_unref
argument_list|(
operator|&
name|vm
operator|->
name|last_flush
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|vm
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

