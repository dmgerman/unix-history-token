begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008 Advanced Micro Devices, Inc.  * Copyright 2008 Red Hat Inc.  * Copyright 2009 Jerome Glisse.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *  * Authors: Dave Airlie  *          Alex Deucher  *          Jerome Glisse  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc_helper.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/radeon/radeon_drm.h>
end_include

begin_include
include|#
directive|include
file|"radeon_reg.h"
end_include

begin_include
include|#
directive|include
file|"radeon.h"
end_include

begin_include
include|#
directive|include
file|"atom.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|radeon_family_name
index|[]
index|[
literal|16
index|]
init|=
block|{
literal|"R100"
block|,
literal|"RV100"
block|,
literal|"RS100"
block|,
literal|"RV200"
block|,
literal|"RS200"
block|,
literal|"R200"
block|,
literal|"RV250"
block|,
literal|"RS300"
block|,
literal|"RV280"
block|,
literal|"R300"
block|,
literal|"R350"
block|,
literal|"RV350"
block|,
literal|"RV380"
block|,
literal|"R420"
block|,
literal|"R423"
block|,
literal|"RV410"
block|,
literal|"RS400"
block|,
literal|"RS480"
block|,
literal|"RS600"
block|,
literal|"RS690"
block|,
literal|"RS740"
block|,
literal|"RV515"
block|,
literal|"R520"
block|,
literal|"RV530"
block|,
literal|"RV560"
block|,
literal|"RV570"
block|,
literal|"R580"
block|,
literal|"R600"
block|,
literal|"RV610"
block|,
literal|"RV630"
block|,
literal|"RV670"
block|,
literal|"RV620"
block|,
literal|"RV635"
block|,
literal|"RS780"
block|,
literal|"RS880"
block|,
literal|"RV770"
block|,
literal|"RV730"
block|,
literal|"RV710"
block|,
literal|"RV740"
block|,
literal|"CEDAR"
block|,
literal|"REDWOOD"
block|,
literal|"JUNIPER"
block|,
literal|"CYPRESS"
block|,
literal|"HEMLOCK"
block|,
literal|"PALM"
block|,
literal|"SUMO"
block|,
literal|"SUMO2"
block|,
literal|"BARTS"
block|,
literal|"TURKS"
block|,
literal|"CAICOS"
block|,
literal|"CAYMAN"
block|,
literal|"ARUBA"
block|,
literal|"TAHITI"
block|,
literal|"PITCAIRN"
block|,
literal|"VERDE"
block|,
literal|"LAST"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * radeon_surface_init - Clear GPU surface registers.  *  * @rdev: radeon_device pointer  *  * Clear GPU surface registers (r1xx-r5xx).  */
end_comment

begin_function
name|void
name|radeon_surface_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
comment|/* FIXME: check this out */
if|if
condition|(
name|rdev
operator|->
name|family
operator|<
name|CHIP_R600
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_GEM_MAX_SURFACES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rdev
operator|->
name|surface_regs
index|[
name|i
index|]
operator|.
name|bo
condition|)
name|radeon_bo_get_surface_reg
argument_list|(
name|rdev
operator|->
name|surface_regs
index|[
name|i
index|]
operator|.
name|bo
argument_list|)
expr_stmt|;
else|else
name|radeon_clear_surface_reg
argument_list|(
name|rdev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* enable surfaces */
name|WREG32
argument_list|(
name|RADEON_SURFACE_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * GPU scratch registers helpers function.  */
end_comment

begin_comment
comment|/**  * radeon_scratch_init - Init scratch register driver information.  *  * @rdev: radeon_device pointer  *  * Init CP scratch register driver information (r1xx-r5xx)  */
end_comment

begin_function
name|void
name|radeon_scratch_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* FIXME: check this out */
if|if
condition|(
name|rdev
operator|->
name|family
operator|<
name|CHIP_R300
condition|)
block|{
name|rdev
operator|->
name|scratch
operator|.
name|num_reg
operator|=
literal|5
expr_stmt|;
block|}
else|else
block|{
name|rdev
operator|->
name|scratch
operator|.
name|num_reg
operator|=
literal|7
expr_stmt|;
block|}
name|rdev
operator|->
name|scratch
operator|.
name|reg_base
operator|=
name|RADEON_SCRATCH_REG0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdev
operator|->
name|scratch
operator|.
name|num_reg
condition|;
name|i
operator|++
control|)
block|{
name|rdev
operator|->
name|scratch
operator|.
name|free
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
name|rdev
operator|->
name|scratch
operator|.
name|reg
index|[
name|i
index|]
operator|=
name|rdev
operator|->
name|scratch
operator|.
name|reg_base
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_scratch_get - Allocate a scratch register  *  * @rdev: radeon_device pointer  * @reg: scratch register mmio offset  *  * Allocate a CP scratch register for use by the driver (all asics).  * Returns 0 on success or -EINVAL on failure.  */
end_comment

begin_function
name|int
name|radeon_scratch_get
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|uint32_t
modifier|*
name|reg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdev
operator|->
name|scratch
operator|.
name|num_reg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rdev
operator|->
name|scratch
operator|.
name|free
index|[
name|i
index|]
condition|)
block|{
name|rdev
operator|->
name|scratch
operator|.
name|free
index|[
name|i
index|]
operator|=
name|false
expr_stmt|;
operator|*
name|reg
operator|=
name|rdev
operator|->
name|scratch
operator|.
name|reg
index|[
name|i
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_scratch_free - Free a scratch register  *  * @rdev: radeon_device pointer  * @reg: scratch register mmio offset  *  * Free a CP scratch register allocated for use by the driver (all asics)  */
end_comment

begin_function
name|void
name|radeon_scratch_free
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdev
operator|->
name|scratch
operator|.
name|num_reg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rdev
operator|->
name|scratch
operator|.
name|reg
index|[
name|i
index|]
operator|==
name|reg
condition|)
block|{
name|rdev
operator|->
name|scratch
operator|.
name|free
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * radeon_wb_*()  * Writeback is the the method by which the the GPU updates special pages  * in memory with the status of certain GPU events (fences, ring pointers,  * etc.).  */
end_comment

begin_comment
comment|/**  * radeon_wb_disable - Disable Writeback  *  * @rdev: radeon_device pointer  *  * Disables Writeback (all asics).  Used for suspend.  */
end_comment

begin_function
name|void
name|radeon_wb_disable
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
condition|)
block|{
name|r
operator|=
name|radeon_bo_reserve
argument_list|(
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
operator|!=
literal|0
argument_list|)
condition|)
return|return;
name|radeon_bo_kunmap
argument_list|(
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
argument_list|)
expr_stmt|;
name|radeon_bo_unpin
argument_list|(
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
argument_list|)
expr_stmt|;
name|radeon_bo_unreserve
argument_list|(
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
argument_list|)
expr_stmt|;
block|}
name|rdev
operator|->
name|wb
operator|.
name|enabled
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_wb_fini - Disable Writeback and free memory  *  * @rdev: radeon_device pointer  *  * Disables Writeback and frees the Writeback memory (all asics).  * Used at driver shutdown.  */
end_comment

begin_function
name|void
name|radeon_wb_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|radeon_wb_disable
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
condition|)
block|{
name|radeon_bo_unref
argument_list|(
operator|&
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|wb
operator|.
name|wb
operator|=
name|NULL
expr_stmt|;
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_wb_init- Init Writeback driver info and allocate memory  *  * @rdev: radeon_device pointer  *  * Disables Writeback and frees the Writeback memory (all asics).  * Used at driver startup.  * Returns 0 on success or an -error on failure.  */
end_comment

begin_function
name|int
name|radeon_wb_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|void
modifier|*
name|wb_ptr
decl_stmt|;
comment|/* FreeBSD: to please GCC 4.2. */
if|if
condition|(
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|radeon_bo_create
argument_list|(
name|rdev
argument_list|,
name|RADEON_GPU_PAGE_SIZE
argument_list|,
name|PAGE_SIZE
argument_list|,
name|true
argument_list|,
name|RADEON_GEM_DOMAIN_GTT
argument_list|,
name|NULL
argument_list|,
operator|&
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|dev_warn
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"(%d) create WB bo failed\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
name|r
operator|=
name|radeon_bo_reserve
argument_list|(
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|radeon_wb_fini
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|r
operator|=
name|radeon_bo_pin
argument_list|(
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
argument_list|,
name|RADEON_GEM_DOMAIN_GTT
argument_list|,
operator|&
name|rdev
operator|->
name|wb
operator|.
name|gpu_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|radeon_bo_unreserve
argument_list|(
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
argument_list|)
expr_stmt|;
name|dev_warn
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"(%d) pin WB bo failed\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|radeon_wb_fini
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|wb_ptr
operator|=
operator|&
name|rdev
operator|->
name|wb
operator|.
name|wb
expr_stmt|;
name|r
operator|=
name|radeon_bo_kmap
argument_list|(
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
argument_list|,
name|wb_ptr
argument_list|)
expr_stmt|;
name|radeon_bo_unreserve
argument_list|(
name|rdev
operator|->
name|wb
operator|.
name|wb_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|dev_warn
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"(%d) map WB bo failed\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|radeon_wb_fini
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/* clear wb memory */
name|memset
argument_list|(
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|wb_ptr
argument_list|,
literal|0
argument_list|,
name|RADEON_GPU_PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* disable event_write fences */
name|rdev
operator|->
name|wb
operator|.
name|use_event
operator|=
name|false
expr_stmt|;
comment|/* disabled via module param */
if|if
condition|(
name|radeon_no_wb
operator|==
literal|1
condition|)
block|{
name|rdev
operator|->
name|wb
operator|.
name|enabled
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_AGP
condition|)
block|{
comment|/* often unreliable on AGP */
name|rdev
operator|->
name|wb
operator|.
name|enabled
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdev
operator|->
name|family
operator|<
name|CHIP_R300
condition|)
block|{
comment|/* often unreliable on pre-r300 */
name|rdev
operator|->
name|wb
operator|.
name|enabled
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|rdev
operator|->
name|wb
operator|.
name|enabled
operator|=
name|true
expr_stmt|;
comment|/* event_write fences are only available on r600+ */
if|if
condition|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_R600
condition|)
block|{
name|rdev
operator|->
name|wb
operator|.
name|use_event
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
comment|/* always use writeback/events on NI, APUs */
if|if
condition|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_PALM
condition|)
block|{
name|rdev
operator|->
name|wb
operator|.
name|enabled
operator|=
name|true
expr_stmt|;
name|rdev
operator|->
name|wb
operator|.
name|use_event
operator|=
name|true
expr_stmt|;
block|}
name|dev_info
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"WB %sabled\n"
argument_list|,
name|rdev
operator|->
name|wb
operator|.
name|enabled
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_vram_location - try to find VRAM location  * @rdev: radeon device structure holding all necessary informations  * @mc: memory controller structure holding memory informations  * @base: base address at which to put VRAM  *  * Function will place try to place VRAM at base address provided  * as parameter (which is so far either PCI aperture address or  * for IGP TOM base address).  *  * If there is not enough space to fit the unvisible VRAM in the 32bits  * address space then we limit the VRAM size to the aperture.  *  * If we are using AGP and if the AGP aperture doesn't allow us to have  * room for all the VRAM than we restrict the VRAM to the PCI aperture  * size and print a warning.  *  * This function will never fails, worst case are limiting VRAM.  *  * Note: GTT start, end, size should be initialized before calling this  * function on AGP platform.  *  * Note: We don't explicitly enforce VRAM start to be aligned on VRAM size,  * this shouldn't be a problem as we are using the PCI aperture as a reference.  * Otherwise this would be needed for rv280, all r3xx, and all r4xx, but  * not IGP.  *  * Note: we use mc_vram_size as on some board we need to program the mc to  * cover the whole aperture even if VRAM size is inferior to aperture size  * Novell bug 204882 + along with lots of ubuntu ones  *  * Note: when limiting vram it's safe to overwritte real_vram_size because  * we are not in case where real_vram_size is inferior to mc_vram_size (ie  * note afected by bogus hw of Novell bug 204882 + along with lots of ubuntu  * ones)  *  * Note: IGP TOM addr should be the same as the aperture addr, we don't  * explicitly check for that thought.  *  * FIXME: when reducing VRAM size align new size on power of 2.  */
end_comment

begin_function
name|void
name|radeon_vram_location
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_mc
modifier|*
name|mc
parameter_list|,
name|u64
name|base
parameter_list|)
block|{
name|uint64_t
name|limit
init|=
operator|(
name|uint64_t
operator|)
name|radeon_vram_limit
operator|<<
literal|20
decl_stmt|;
name|mc
operator|->
name|vram_start
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mc_vram_size
operator|>
operator|(
literal|0xFFFFFFFF
operator|-
name|base
operator|+
literal|1
operator|)
condition|)
block|{
name|dev_warn
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"limiting VRAM to PCI aperture size\n"
argument_list|)
expr_stmt|;
name|mc
operator|->
name|real_vram_size
operator|=
name|mc
operator|->
name|aper_size
expr_stmt|;
name|mc
operator|->
name|mc_vram_size
operator|=
name|mc
operator|->
name|aper_size
expr_stmt|;
block|}
name|mc
operator|->
name|vram_end
operator|=
name|mc
operator|->
name|vram_start
operator|+
name|mc
operator|->
name|mc_vram_size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_AGP
operator|&&
name|mc
operator|->
name|vram_end
operator|>
name|mc
operator|->
name|gtt_start
operator|&&
name|mc
operator|->
name|vram_start
operator|<=
name|mc
operator|->
name|gtt_end
condition|)
block|{
name|dev_warn
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"limiting VRAM to PCI aperture size\n"
argument_list|)
expr_stmt|;
name|mc
operator|->
name|real_vram_size
operator|=
name|mc
operator|->
name|aper_size
expr_stmt|;
name|mc
operator|->
name|mc_vram_size
operator|=
name|mc
operator|->
name|aper_size
expr_stmt|;
block|}
name|mc
operator|->
name|vram_end
operator|=
name|mc
operator|->
name|vram_start
operator|+
name|mc
operator|->
name|mc_vram_size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|limit
operator|&&
name|limit
operator|<
name|mc
operator|->
name|real_vram_size
condition|)
name|mc
operator|->
name|real_vram_size
operator|=
name|limit
expr_stmt|;
name|dev_info
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"VRAM: %juM 0x%016jX - 0x%016jX (%juM used)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mc
operator|->
name|mc_vram_size
operator|>>
literal|20
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mc
operator|->
name|vram_start
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mc
operator|->
name|vram_end
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mc
operator|->
name|real_vram_size
operator|>>
literal|20
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_gtt_location - try to find GTT location  * @rdev: radeon device structure holding all necessary informations  * @mc: memory controller structure holding memory informations  *  * Function will place try to place GTT before or after VRAM.  *  * If GTT size is bigger than space left then we ajust GTT size.  * Thus function will never fails.  *  * FIXME: when reducing GTT size align new size on power of 2.  */
end_comment

begin_function
name|void
name|radeon_gtt_location
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_mc
modifier|*
name|mc
parameter_list|)
block|{
name|u64
name|size_af
decl_stmt|,
name|size_bf
decl_stmt|;
name|size_af
operator|=
operator|(
operator|(
literal|0xFFFFFFFF
operator|-
name|mc
operator|->
name|vram_end
operator|)
operator|+
name|mc
operator|->
name|gtt_base_align
operator|)
operator|&
operator|~
name|mc
operator|->
name|gtt_base_align
expr_stmt|;
name|size_bf
operator|=
name|mc
operator|->
name|vram_start
operator|&
operator|~
name|mc
operator|->
name|gtt_base_align
expr_stmt|;
if|if
condition|(
name|size_bf
operator|>
name|size_af
condition|)
block|{
if|if
condition|(
name|mc
operator|->
name|gtt_size
operator|>
name|size_bf
condition|)
block|{
name|dev_warn
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"limiting GTT\n"
argument_list|)
expr_stmt|;
name|mc
operator|->
name|gtt_size
operator|=
name|size_bf
expr_stmt|;
block|}
name|mc
operator|->
name|gtt_start
operator|=
operator|(
name|mc
operator|->
name|vram_start
operator|&
operator|~
name|mc
operator|->
name|gtt_base_align
operator|)
operator|-
name|mc
operator|->
name|gtt_size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mc
operator|->
name|gtt_size
operator|>
name|size_af
condition|)
block|{
name|dev_warn
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"limiting GTT\n"
argument_list|)
expr_stmt|;
name|mc
operator|->
name|gtt_size
operator|=
name|size_af
expr_stmt|;
block|}
name|mc
operator|->
name|gtt_start
operator|=
operator|(
name|mc
operator|->
name|vram_end
operator|+
literal|1
operator|+
name|mc
operator|->
name|gtt_base_align
operator|)
operator|&
operator|~
name|mc
operator|->
name|gtt_base_align
expr_stmt|;
block|}
name|mc
operator|->
name|gtt_end
operator|=
name|mc
operator|->
name|gtt_start
operator|+
name|mc
operator|->
name|gtt_size
operator|-
literal|1
expr_stmt|;
name|dev_info
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"GTT: %juM 0x%016jX - 0x%016jX\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mc
operator|->
name|gtt_size
operator|>>
literal|20
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mc
operator|->
name|gtt_start
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mc
operator|->
name|gtt_end
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * GPU helpers function.  */
end_comment

begin_comment
comment|/**  * radeon_card_posted - check if the hw has already been initialized  *  * @rdev: radeon_device pointer  *  * Check if the asic has been initialized (all asics).  * Used at driver startup.  * Returns true if initialized or false if not.  */
end_comment

begin_function
name|bool
name|radeon_card_posted
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
if|if
condition|(
name|efi_enabled
argument_list|(
name|EFI_BOOT
argument_list|)
operator|&&
name|rdev
operator|->
name|dev
operator|->
name|pci_subvendor
operator|==
name|PCI_VENDOR_ID_APPLE
condition|)
return|return
name|false
return|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
comment|/* first check CRTCs */
if|if
condition|(
name|ASIC_IS_DCE41
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|reg
operator|=
name|RREG32
argument_list|(
name|EVERGREEN_CRTC_CONTROL
operator|+
name|EVERGREEN_CRTC0_REGISTER_OFFSET
argument_list|)
operator||
name|RREG32
argument_list|(
name|EVERGREEN_CRTC_CONTROL
operator|+
name|EVERGREEN_CRTC1_REGISTER_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|EVERGREEN_CRTC_MASTER_EN
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|reg
operator|=
name|RREG32
argument_list|(
name|EVERGREEN_CRTC_CONTROL
operator|+
name|EVERGREEN_CRTC0_REGISTER_OFFSET
argument_list|)
operator||
name|RREG32
argument_list|(
name|EVERGREEN_CRTC_CONTROL
operator|+
name|EVERGREEN_CRTC1_REGISTER_OFFSET
argument_list|)
operator||
name|RREG32
argument_list|(
name|EVERGREEN_CRTC_CONTROL
operator|+
name|EVERGREEN_CRTC2_REGISTER_OFFSET
argument_list|)
operator||
name|RREG32
argument_list|(
name|EVERGREEN_CRTC_CONTROL
operator|+
name|EVERGREEN_CRTC3_REGISTER_OFFSET
argument_list|)
operator||
name|RREG32
argument_list|(
name|EVERGREEN_CRTC_CONTROL
operator|+
name|EVERGREEN_CRTC4_REGISTER_OFFSET
argument_list|)
operator||
name|RREG32
argument_list|(
name|EVERGREEN_CRTC_CONTROL
operator|+
name|EVERGREEN_CRTC5_REGISTER_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|EVERGREEN_CRTC_MASTER_EN
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|reg
operator|=
name|RREG32
argument_list|(
name|AVIVO_D1CRTC_CONTROL
argument_list|)
operator||
name|RREG32
argument_list|(
name|AVIVO_D2CRTC_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|AVIVO_CRTC_EN
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
else|else
block|{
name|reg
operator|=
name|RREG32
argument_list|(
name|RADEON_CRTC_GEN_CNTL
argument_list|)
operator||
name|RREG32
argument_list|(
name|RADEON_CRTC2_GEN_CNTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|RADEON_CRTC_EN
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
comment|/* then check MEM_SIZE, in case the crtcs are off */
if|if
condition|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_R600
condition|)
name|reg
operator|=
name|RREG32
argument_list|(
name|R600_CONFIG_MEMSIZE
argument_list|)
expr_stmt|;
else|else
name|reg
operator|=
name|RREG32
argument_list|(
name|RADEON_CONFIG_MEMSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_update_bandwidth_info - update display bandwidth params  *  * @rdev: radeon_device pointer  *  * Used when sclk/mclk are switched or display modes are set.  * params are used to calculate display watermarks (all asics)  */
end_comment

begin_function
name|void
name|radeon_update_bandwidth_info
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|fixed20_12
name|a
decl_stmt|;
name|u32
name|sclk
init|=
name|rdev
operator|->
name|pm
operator|.
name|current_sclk
decl_stmt|;
name|u32
name|mclk
init|=
name|rdev
operator|->
name|pm
operator|.
name|current_mclk
decl_stmt|;
comment|/* sclk/mclk in Mhz */
name|a
operator|.
name|full
operator|=
name|dfixed_const
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|sclk
operator|.
name|full
operator|=
name|dfixed_const
argument_list|(
name|sclk
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|sclk
operator|.
name|full
operator|=
name|dfixed_div
argument_list|(
name|rdev
operator|->
name|pm
operator|.
name|sclk
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|mclk
operator|.
name|full
operator|=
name|dfixed_const
argument_list|(
name|mclk
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|pm
operator|.
name|mclk
operator|.
name|full
operator|=
name|dfixed_div
argument_list|(
name|rdev
operator|->
name|pm
operator|.
name|mclk
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_IGP
condition|)
block|{
name|a
operator|.
name|full
operator|=
name|dfixed_const
argument_list|(
literal|16
argument_list|)
expr_stmt|;
comment|/* core_bandwidth = sclk(Mhz) * 16 */
name|rdev
operator|->
name|pm
operator|.
name|core_bandwidth
operator|.
name|full
operator|=
name|dfixed_div
argument_list|(
name|rdev
operator|->
name|pm
operator|.
name|sclk
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_boot_test_post_card - check and possibly initialize the hw  *  * @rdev: radeon_device pointer  *  * Check if the asic is initialized and if not, attempt to initialize  * it (all asics).  * Returns true if initialized or false if not.  */
end_comment

begin_function
name|bool
name|radeon_boot_test_post_card
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|if
condition|(
name|radeon_card_posted
argument_list|(
name|rdev
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|rdev
operator|->
name|bios
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"GPU not posted. posting now...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|is_atom_bios
condition|)
name|atom_asic_init
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|)
expr_stmt|;
else|else
name|radeon_combios_asic_init
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"Card not posted and no BIOS - ignoring\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_dummy_page_init - init dummy page used by the driver  *  * @rdev: radeon_device pointer  *  * Allocate the dummy page used by the driver (all asics).  * This dummy page is used by the driver as a filler for gart entries  * when pages are taken out of the GART  * Returns 0 on success, -ENOMEM on failure.  */
end_comment

begin_function
name|int
name|radeon_dummy_page_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|if
condition|(
name|rdev
operator|->
name|dummy_page
operator|.
name|dmah
condition|)
return|return
literal|0
return|;
name|rdev
operator|->
name|dummy_page
operator|.
name|dmah
operator|=
name|drm_pci_alloc
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PAGE_SIZE
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|dummy_page
operator|.
name|dmah
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|rdev
operator|->
name|dummy_page
operator|.
name|addr
operator|=
name|rdev
operator|->
name|dummy_page
operator|.
name|dmah
operator|->
name|busaddr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_dummy_page_fini - free dummy page used by the driver  *  * @rdev: radeon_device pointer  *  * Frees the dummy page used by the driver (all asics).  */
end_comment

begin_function
name|void
name|radeon_dummy_page_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|if
condition|(
name|rdev
operator|->
name|dummy_page
operator|.
name|dmah
operator|==
name|NULL
condition|)
return|return;
name|drm_pci_free
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|,
name|rdev
operator|->
name|dummy_page
operator|.
name|dmah
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|dummy_page
operator|.
name|dmah
operator|=
name|NULL
expr_stmt|;
name|rdev
operator|->
name|dummy_page
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ATOM accessor methods */
end_comment

begin_comment
comment|/*  * ATOM is an interpreted byte code stored in tables in the vbios.  The  * driver registers callbacks to access registers and the interpreter  * in the driver parses the tables and executes then to program specific  * actions (set display modes, asic init, etc.).  See radeon_atombios.c,  * atombios.h, and atom.c  */
end_comment

begin_comment
comment|/**  * cail_pll_read - read PLL register  *  * @info: atom card_info pointer  * @reg: PLL register offset  *  * Provides a PLL register accessor for the atom interpreter (r4xx+).  * Returns the value of the PLL register.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|cail_pll_read
parameter_list|(
name|struct
name|card_info
modifier|*
name|info
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|info
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|r
decl_stmt|;
name|r
operator|=
name|rdev
operator|->
name|pll_rreg
argument_list|(
name|rdev
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/**  * cail_pll_write - write PLL register  *  * @info: atom card_info pointer  * @reg: PLL register offset  * @val: value to write to the pll register  *  * Provides a PLL register accessor for the atom interpreter (r4xx+).  */
end_comment

begin_function
specifier|static
name|void
name|cail_pll_write
parameter_list|(
name|struct
name|card_info
modifier|*
name|info
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|info
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|rdev
operator|->
name|pll_wreg
argument_list|(
name|rdev
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * cail_mc_read - read MC (Memory Controller) register  *  * @info: atom card_info pointer  * @reg: MC register offset  *  * Provides an MC register accessor for the atom interpreter (r4xx+).  * Returns the value of the MC register.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|cail_mc_read
parameter_list|(
name|struct
name|card_info
modifier|*
name|info
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|info
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|r
decl_stmt|;
name|r
operator|=
name|rdev
operator|->
name|mc_rreg
argument_list|(
name|rdev
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/**  * cail_mc_write - write MC (Memory Controller) register  *  * @info: atom card_info pointer  * @reg: MC register offset  * @val: value to write to the pll register  *  * Provides a MC register accessor for the atom interpreter (r4xx+).  */
end_comment

begin_function
specifier|static
name|void
name|cail_mc_write
parameter_list|(
name|struct
name|card_info
modifier|*
name|info
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|info
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|rdev
operator|->
name|mc_wreg
argument_list|(
name|rdev
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * cail_reg_write - write MMIO register  *  * @info: atom card_info pointer  * @reg: MMIO register offset  * @val: value to write to the pll register  *  * Provides a MMIO register accessor for the atom interpreter (r4xx+).  */
end_comment

begin_function
specifier|static
name|void
name|cail_reg_write
parameter_list|(
name|struct
name|card_info
modifier|*
name|info
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|info
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|WREG32
argument_list|(
name|reg
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * cail_reg_read - read MMIO register  *  * @info: atom card_info pointer  * @reg: MMIO register offset  *  * Provides an MMIO register accessor for the atom interpreter (r4xx+).  * Returns the value of the MMIO register.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|cail_reg_read
parameter_list|(
name|struct
name|card_info
modifier|*
name|info
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|info
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|r
decl_stmt|;
name|r
operator|=
name|RREG32
argument_list|(
name|reg
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/**  * cail_ioreg_write - write IO register  *  * @info: atom card_info pointer  * @reg: IO register offset  * @val: value to write to the pll register  *  * Provides a IO register accessor for the atom interpreter (r4xx+).  */
end_comment

begin_function
specifier|static
name|void
name|cail_ioreg_write
parameter_list|(
name|struct
name|card_info
modifier|*
name|info
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|info
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|WREG32_IO
argument_list|(
name|reg
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * cail_ioreg_read - read IO register  *  * @info: atom card_info pointer  * @reg: IO register offset  *  * Provides an IO register accessor for the atom interpreter (r4xx+).  * Returns the value of the IO register.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|cail_ioreg_read
parameter_list|(
name|struct
name|card_info
modifier|*
name|info
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|info
operator|->
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|r
decl_stmt|;
name|r
operator|=
name|RREG32_IO
argument_list|(
name|reg
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_atombios_init - init the driver info and callbacks for atombios  *  * @rdev: radeon_device pointer  *  * Initializes the driver info and register access callbacks for the  * ATOM interpreter (r4xx+).  * Returns 0 on success, -ENOMEM on failure.  * Called at driver startup.  */
end_comment

begin_function
name|int
name|radeon_atombios_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|struct
name|card_info
modifier|*
name|atom_card_info
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|card_info
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|atom_card_info
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|rdev
operator|->
name|mode_info
operator|.
name|atom_card_info
operator|=
name|atom_card_info
expr_stmt|;
name|atom_card_info
operator|->
name|dev
operator|=
name|rdev
operator|->
name|ddev
expr_stmt|;
name|atom_card_info
operator|->
name|reg_read
operator|=
name|cail_reg_read
expr_stmt|;
name|atom_card_info
operator|->
name|reg_write
operator|=
name|cail_reg_write
expr_stmt|;
comment|/* needed for iio ops */
if|if
condition|(
name|rdev
operator|->
name|rio_mem
condition|)
block|{
name|atom_card_info
operator|->
name|ioreg_read
operator|=
name|cail_ioreg_read
expr_stmt|;
name|atom_card_info
operator|->
name|ioreg_write
operator|=
name|cail_ioreg_write
expr_stmt|;
block|}
else|else
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to find PCI I/O BAR; using MMIO for ATOM IIO\n"
argument_list|)
expr_stmt|;
name|atom_card_info
operator|->
name|ioreg_read
operator|=
name|cail_reg_read
expr_stmt|;
name|atom_card_info
operator|->
name|ioreg_write
operator|=
name|cail_reg_write
expr_stmt|;
block|}
name|atom_card_info
operator|->
name|mc_read
operator|=
name|cail_mc_read
expr_stmt|;
name|atom_card_info
operator|->
name|mc_write
operator|=
name|cail_mc_write
expr_stmt|;
name|atom_card_info
operator|->
name|pll_read
operator|=
name|cail_pll_read
expr_stmt|;
name|atom_card_info
operator|->
name|pll_write
operator|=
name|cail_pll_write
expr_stmt|;
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
operator|=
name|atom_parse
argument_list|(
name|atom_card_info
argument_list|,
name|rdev
operator|->
name|bios
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
operator|->
name|mutex
argument_list|,
literal|"drm__radeon_device__mode_info__atom_context__mutex"
argument_list|)
expr_stmt|;
name|radeon_atom_initialize_bios_scratch_regs
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|)
expr_stmt|;
name|atom_allocate_fb_scratch
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_atombios_fini - free the driver info and callbacks for atombios  *  * @rdev: radeon_device pointer  *  * Frees the driver info and register access callbacks for the ATOM  * interpreter (r4xx+).  * Called at driver shutdown.  */
end_comment

begin_function
name|void
name|radeon_atombios_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|if
condition|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
condition|)
block|{
name|free
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
operator|->
name|scratch
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|atom_destroy
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_card_info
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* COMBIOS */
end_comment

begin_comment
comment|/*  * COMBIOS is the bios format prior to ATOM. It provides  * command tables similar to ATOM, but doesn't have a unified  * parser.  See radeon_combios.c  */
end_comment

begin_comment
comment|/**  * radeon_combios_init - init the driver info for combios  *  * @rdev: radeon_device pointer  *  * Initializes the driver info for combios (r1xx-r3xx).  * Returns 0 on success.  * Called at driver startup.  */
end_comment

begin_function
name|int
name|radeon_combios_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|radeon_combios_initialize_bios_scratch_regs
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_combios_fini - free the driver info for combios  *  * @rdev: radeon_device pointer  *  * Frees the driver info for combios (r1xx-r3xx).  * Called at driver shutdown.  */
end_comment

begin_function
name|void
name|radeon_combios_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{ }
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREEBSD_WIP
end_ifdef

begin_comment
comment|/* if we get transitioned to only one device, take VGA back */
end_comment

begin_comment
comment|/**  * radeon_vga_set_decode - enable/disable vga decode  *  * @cookie: radeon_device pointer  * @state: enable/disable vga decode  *  * Enable/disable vga decode (all asics).  * Returns VGA resource flags.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|radeon_vga_set_decode
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|cookie
decl_stmt|;
name|radeon_vga_set_state
argument_list|(
name|rdev
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
return|return
name|VGA_RSRC_LEGACY_IO
operator||
name|VGA_RSRC_LEGACY_MEM
operator||
name|VGA_RSRC_NORMAL_IO
operator||
name|VGA_RSRC_NORMAL_MEM
return|;
else|else
return|return
name|VGA_RSRC_NORMAL_IO
operator||
name|VGA_RSRC_NORMAL_MEM
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREEBSD_WIP */
end_comment

begin_comment
comment|/**  * radeon_check_pot_argument - check that argument is a power of two  *  * @arg: value to check  *  * Validates that a certain argument is a power of two (all asics).  * Returns true if argument is valid.  */
end_comment

begin_function
specifier|static
name|bool
name|radeon_check_pot_argument
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
return|return
operator|(
name|arg
operator|&
operator|(
name|arg
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_check_arguments - validate module params  *  * @rdev: radeon_device pointer  *  * Validates certain module parameters and updates  * the associated values used by the driver (all asics).  */
end_comment

begin_function
specifier|static
name|void
name|radeon_check_arguments
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
comment|/* vramlimit must be a power of two */
if|if
condition|(
operator|!
name|radeon_check_pot_argument
argument_list|(
name|radeon_vram_limit
argument_list|)
condition|)
block|{
name|dev_warn
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"vram limit (%d) must be a power of 2\n"
argument_list|,
name|radeon_vram_limit
argument_list|)
expr_stmt|;
name|radeon_vram_limit
operator|=
literal|0
expr_stmt|;
block|}
comment|/* gtt size must be power of two and greater or equal to 32M */
if|if
condition|(
name|radeon_gart_size
operator|<
literal|32
condition|)
block|{
name|dev_warn
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"gart size (%d) too small forcing to 512M\n"
argument_list|,
name|radeon_gart_size
argument_list|)
expr_stmt|;
name|radeon_gart_size
operator|=
literal|512
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|radeon_check_pot_argument
argument_list|(
name|radeon_gart_size
argument_list|)
condition|)
block|{
name|dev_warn
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"gart size (%d) must be a power of 2\n"
argument_list|,
name|radeon_gart_size
argument_list|)
expr_stmt|;
name|radeon_gart_size
operator|=
literal|512
expr_stmt|;
block|}
name|rdev
operator|->
name|mc
operator|.
name|gtt_size
operator|=
operator|(
name|uint64_t
operator|)
name|radeon_gart_size
operator|<<
literal|20
expr_stmt|;
comment|/* AGP mode can only be -1, 1, 2, 4, 8 */
switch|switch
condition|(
name|radeon_agpmode
condition|)
block|{
case|case
operator|-
literal|1
case|:
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|8
case|:
break|break;
default|default:
name|dev_warn
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"invalid AGP mode %d (valid mode: "
literal|"-1, 0, 1, 2, 4, 8)\n"
argument_list|,
name|radeon_agpmode
argument_list|)
expr_stmt|;
name|radeon_agpmode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_switcheroo_quirk_long_wakeup - return true if longer d3 delay is  * needed for waking up.  *  * @pdev: pci dev pointer  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREEBSD_WIP
end_ifdef

begin_function
specifier|static
name|bool
name|radeon_switcheroo_quirk_long_wakeup
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
comment|/* 6600m in a macbook pro */
if|if
condition|(
name|pdev
operator|->
name|subsystem_vendor
operator|==
name|PCI_VENDOR_ID_APPLE
operator|&&
name|pdev
operator|->
name|subsystem_device
operator|==
literal|0x00e2
condition|)
block|{
name|printk
argument_list|(
name|KERN_INFO
literal|"radeon: quirking longer d3 wakeup delay\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREEBSD_WIP */
end_comment

begin_comment
comment|/**  * radeon_switcheroo_set_state - set switcheroo state  *  * @pdev: pci dev pointer  * @state: vga switcheroo state  *  * Callback for the switcheroo driver.  Suspends or resumes the  * the asics before or after it is powered up using ACPI methods.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREEBSD_WIP
end_ifdef

begin_function
specifier|static
name|void
name|radeon_switcheroo_set_state
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|enum
name|vga_switcheroo_state
name|state
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|pm_message_t
name|pmm
init|=
block|{
operator|.
name|event
operator|=
name|PM_EVENT_SUSPEND
block|}
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|VGA_SWITCHEROO_ON
condition|)
block|{
name|unsigned
name|d3_delay
init|=
name|dev
operator|->
name|pdev
operator|->
name|d3_delay
decl_stmt|;
name|printk
argument_list|(
name|KERN_INFO
literal|"radeon: switched on\n"
argument_list|)
expr_stmt|;
comment|/* don't suspend or resume card normally */
name|dev
operator|->
name|switch_power_state
operator|=
name|DRM_SWITCH_POWER_CHANGING
expr_stmt|;
if|if
condition|(
name|d3_delay
operator|<
literal|20
operator|&&
name|radeon_switcheroo_quirk_long_wakeup
argument_list|(
name|pdev
argument_list|)
condition|)
name|dev
operator|->
name|pdev
operator|->
name|d3_delay
operator|=
literal|20
expr_stmt|;
name|radeon_resume_kms
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|pdev
operator|->
name|d3_delay
operator|=
name|d3_delay
expr_stmt|;
name|dev
operator|->
name|switch_power_state
operator|=
name|DRM_SWITCH_POWER_ON
expr_stmt|;
name|drm_kms_helper_poll_enable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printk
argument_list|(
name|KERN_INFO
literal|"radeon: switched off\n"
argument_list|)
expr_stmt|;
name|drm_kms_helper_poll_disable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|switch_power_state
operator|=
name|DRM_SWITCH_POWER_CHANGING
expr_stmt|;
name|radeon_suspend_kms
argument_list|(
name|dev
argument_list|,
name|pmm
argument_list|)
expr_stmt|;
name|dev
operator|->
name|switch_power_state
operator|=
name|DRM_SWITCH_POWER_OFF
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREEBSD_WIP */
end_comment

begin_comment
comment|/**  * radeon_switcheroo_can_switch - see if switcheroo state can change  *  * @pdev: pci dev pointer  *  * Callback for the switcheroo driver.  Check of the switcheroo  * state can be changed.  * Returns true if the state can be changed, false if not.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREEBSD_WIP
end_ifdef

begin_function
specifier|static
name|bool
name|radeon_switcheroo_can_switch
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|bool
name|can_switch
decl_stmt|;
name|spin_lock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
name|can_switch
operator|=
operator|(
name|dev
operator|->
name|open_count
operator|==
literal|0
operator|)
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
return|return
name|can_switch
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|vga_switcheroo_client_ops
name|radeon_switcheroo_ops
init|=
block|{
operator|.
name|set_gpu_state
operator|=
name|radeon_switcheroo_set_state
block|,
operator|.
name|reprobe
operator|=
name|NULL
block|,
operator|.
name|can_switch
operator|=
name|radeon_switcheroo_can_switch
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREEBSD_WIP */
end_comment

begin_comment
comment|/**  * radeon_device_init - initialize the driver  *  * @rdev: radeon_device pointer  * @pdev: drm dev pointer  * @flags: driver flags  *  * Initializes the driver info and hw (all asics).  * Returns 0 for success or an error on failure.  * Called at driver startup.  */
end_comment

begin_function
name|int
name|radeon_device_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|drm_device
modifier|*
name|ddev
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|i
decl_stmt|;
name|int
name|dma_bits
decl_stmt|;
name|rdev
operator|->
name|shutdown
operator|=
name|false
expr_stmt|;
name|rdev
operator|->
name|dev
operator|=
name|ddev
operator|->
name|dev
expr_stmt|;
name|rdev
operator|->
name|ddev
operator|=
name|ddev
expr_stmt|;
name|rdev
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|rdev
operator|->
name|family
operator|=
name|flags
operator|&
name|RADEON_FAMILY_MASK
expr_stmt|;
name|rdev
operator|->
name|is_atom_bios
operator|=
name|false
expr_stmt|;
name|rdev
operator|->
name|usec_timeout
operator|=
name|RADEON_MAX_USEC_TIMEOUT
expr_stmt|;
name|rdev
operator|->
name|mc
operator|.
name|gtt_size
operator|=
name|radeon_gart_size
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
name|rdev
operator|->
name|accel_working
operator|=
name|false
expr_stmt|;
name|rdev
operator|->
name|fictitious_range_registered
operator|=
name|false
expr_stmt|;
name|rdev
operator|->
name|fictitious_agp_range_registered
operator|=
name|false
expr_stmt|;
comment|/* set up ring ids */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
name|i
operator|++
control|)
block|{
name|rdev
operator|->
name|ring
index|[
name|i
index|]
operator|.
name|idx
operator|=
name|i
expr_stmt|;
block|}
name|DRM_INFO
argument_list|(
literal|"initializing kernel modesetting (%s 0x%04X:0x%04X 0x%04X:0x%04X).\n"
argument_list|,
name|radeon_family_name
index|[
name|rdev
operator|->
name|family
index|]
argument_list|,
name|ddev
operator|->
name|pci_vendor
argument_list|,
name|ddev
operator|->
name|pci_device
argument_list|,
name|ddev
operator|->
name|pci_subvendor
argument_list|,
name|ddev
operator|->
name|pci_subdevice
argument_list|)
expr_stmt|;
comment|/* mutex initialization are all done here so we 	 * can recall function without having locking issues */
name|sx_init
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|,
literal|"drm__radeon_device__ring_lock"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|rdev
operator|->
name|dc_hw_i2c_mutex
argument_list|,
literal|"drm__radeon_device__dc_hw_i2c_mutex"
argument_list|)
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|rdev
operator|->
name|ih
operator|.
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|rdev
operator|->
name|gem
operator|.
name|mutex
argument_list|,
literal|"drm__radeon_device__gem__mutex"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mutex
argument_list|,
literal|"drm__radeon_device__pm__mutex"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|rdev
operator|->
name|gpu_clock_mutex
argument_list|,
literal|"drm__radeon_device__gpu_clock_mutex"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mclk_lock
argument_list|,
literal|"drm__radeon_device__pm__mclk_lock"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|rdev
operator|->
name|exclusive_lock
argument_list|,
literal|"drm__radeon_device__exclusive_lock"
argument_list|)
expr_stmt|;
name|DRM_INIT_WAITQUEUE
argument_list|(
operator|&
name|rdev
operator|->
name|irq
operator|.
name|vblank_queue
argument_list|)
expr_stmt|;
name|r
operator|=
name|radeon_gem_init
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
comment|/* initialize vm here */
name|sx_init
argument_list|(
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|lock
argument_list|,
literal|"drm__radeon_device__vm_manager__lock"
argument_list|)
expr_stmt|;
comment|/* Adjust VM size here. 	 * Currently set to 4GB ((1<< 20) 4k pages). 	 * Max GPUVM size for cayman and SI is 40 bits. 	 */
name|rdev
operator|->
name|vm_manager
operator|.
name|max_pfn
operator|=
literal|1
operator|<<
literal|20
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|rdev
operator|->
name|vm_manager
operator|.
name|lru_vm
argument_list|)
expr_stmt|;
comment|/* Set asic functions */
name|r
operator|=
name|radeon_asic_init
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|radeon_check_arguments
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
comment|/* all of the newer IGP chips have an internal gart 	 * However some rs4xx report as AGP, so remove that here. 	 */
if|if
condition|(
operator|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_RS400
operator|)
operator|&&
operator|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_IGP
operator|)
condition|)
block|{
name|rdev
operator|->
name|flags
operator|&=
operator|~
name|RADEON_IS_AGP
expr_stmt|;
block|}
if|if
condition|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_AGP
operator|&&
name|radeon_agpmode
operator|==
operator|-
literal|1
condition|)
block|{
name|radeon_agp_disable
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
comment|/* set DMA mask + need_dma32 flags. 	 * PCIE - can handle 40-bits. 	 * IGP - can handle 40-bits 	 * AGP - generally dma32 is safest 	 * PCI - dma32 for legacy pci gart, 40 bits on newer asics 	 */
name|rdev
operator|->
name|need_dma32
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_AGP
condition|)
name|rdev
operator|->
name|need_dma32
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_PCI
operator|)
operator|&&
operator|(
name|rdev
operator|->
name|family
operator|<=
name|CHIP_RS740
operator|)
condition|)
name|rdev
operator|->
name|need_dma32
operator|=
name|true
expr_stmt|;
name|dma_bits
operator|=
name|rdev
operator|->
name|need_dma32
condition|?
literal|32
else|:
literal|40
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|r
operator|=
name|pci_set_dma_mask
argument_list|(
name|rdev
operator|->
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
name|dma_bits
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|rdev
operator|->
name|need_dma32
operator|=
name|true
expr_stmt|;
name|dma_bits
operator|=
literal|32
expr_stmt|;
name|printk
argument_list|(
name|KERN_WARNING
literal|"radeon: No suitable DMA available.\n"
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|pci_set_consistent_dma_mask
argument_list|(
name|rdev
operator|->
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
name|dma_bits
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|pci_set_consistent_dma_mask
argument_list|(
name|rdev
operator|->
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|printk
argument_list|(
name|KERN_WARNING
literal|"radeon: No coherent DMA available.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FREEBSD_WIP */
comment|/* Registers mapping */
comment|/* TODO: block userspace mapping of io register */
name|DRM_SPININIT
argument_list|(
operator|&
name|rdev
operator|->
name|mmio_idx_lock
argument_list|,
literal|"drm__radeon_device__mmio_idx_lock"
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|rmmio_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|rmmio
operator|=
name|bus_alloc_resource_any
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rdev
operator|->
name|rmmio_rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|rmmio
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
name|ENOMEM
return|;
block|}
name|rdev
operator|->
name|rmmio_base
operator|=
name|rman_get_start
argument_list|(
name|rdev
operator|->
name|rmmio
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|rmmio_size
operator|=
name|rman_get_size
argument_list|(
name|rdev
operator|->
name|rmmio
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"register mmio base: 0x%08X\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|rdev
operator|->
name|rmmio_base
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"register mmio size: %u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|rdev
operator|->
name|rmmio_size
argument_list|)
expr_stmt|;
comment|/* io port mapping */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_MAX_PCI_RESOURCE
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|data
decl_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_BAR_IO
argument_list|(
name|data
argument_list|)
condition|)
block|{
name|rdev
operator|->
name|rio_rid
operator|=
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|rio_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rdev
operator|->
name|rio_rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rdev
operator|->
name|rio_mem
operator|==
name|NULL
condition|)
name|DRM_ERROR
argument_list|(
literal|"Unable to find PCI I/O BAR\n"
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|tq
operator|=
name|taskqueue_create
argument_list|(
literal|"radeonkms"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|rdev
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|rdev
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PWAIT
argument_list|,
literal|"radeon taskq"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
comment|/* if we have> 1 VGA cards, then disable the radeon VGA resources */
comment|/* this will fail for cards that aren't VGA class devices, just 	 * ignore it */
name|vga_client_register
argument_list|(
name|rdev
operator|->
name|pdev
argument_list|,
name|rdev
argument_list|,
name|NULL
argument_list|,
name|radeon_vga_set_decode
argument_list|)
expr_stmt|;
name|vga_switcheroo_register_client
argument_list|(
name|rdev
operator|->
name|pdev
argument_list|,
operator|&
name|radeon_switcheroo_ops
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|r
operator|=
name|radeon_init
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|r
operator|=
name|radeon_ib_ring_tests
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|DRM_ERROR
argument_list|(
literal|"ib ring test failed (%d).\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_AGP
operator|&&
operator|!
name|rdev
operator|->
name|accel_working
condition|)
block|{
comment|/* Acceleration not working on AGP card try again 		 * with fallback to PCI or PCIE GART 		 */
name|radeon_asic_reset
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_fini
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_agp_disable
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|r
operator|=
name|radeon_init
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
block|}
name|DRM_INFO
argument_list|(
literal|"%s: Taking over the fictitious range 0x%jx-0x%jx\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rdev
operator|->
name|mc
operator|.
name|aper_base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rdev
operator|->
name|mc
operator|.
name|aper_base
operator|+
name|rdev
operator|->
name|mc
operator|.
name|visible_vram_size
argument_list|)
expr_stmt|;
name|r
operator|=
name|vm_phys_fictitious_reg_range
argument_list|(
name|rdev
operator|->
name|mc
operator|.
name|aper_base
argument_list|,
name|rdev
operator|->
name|mc
operator|.
name|aper_base
operator|+
name|rdev
operator|->
name|mc
operator|.
name|visible_vram_size
argument_list|,
name|VM_MEMATTR_WRITE_COMBINING
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed to register fictitious range "
literal|"0x%jx-0x%jx (%d).\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rdev
operator|->
name|mc
operator|.
name|aper_base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rdev
operator|->
name|mc
operator|.
name|aper_base
operator|+
name|rdev
operator|->
name|mc
operator|.
name|visible_vram_size
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|r
operator|)
return|;
block|}
name|rdev
operator|->
name|fictitious_range_registered
operator|=
name|true
expr_stmt|;
if|#
directive|if
name|__OS_HAS_AGP
if|if
condition|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_AGP
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"%s: Taking over the fictitious range 0x%jx-0x%jx\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rdev
operator|->
name|mc
operator|.
name|agp_base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rdev
operator|->
name|mc
operator|.
name|agp_base
operator|+
name|rdev
operator|->
name|mc
operator|.
name|gtt_size
argument_list|)
expr_stmt|;
name|r
operator|=
name|vm_phys_fictitious_reg_range
argument_list|(
name|rdev
operator|->
name|mc
operator|.
name|agp_base
argument_list|,
name|rdev
operator|->
name|mc
operator|.
name|agp_base
operator|+
name|rdev
operator|->
name|mc
operator|.
name|gtt_size
argument_list|,
name|VM_MEMATTR_WRITE_COMBINING
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed to register fictitious range "
literal|"0x%jx-0x%jx (%d).\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rdev
operator|->
name|mc
operator|.
name|agp_base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rdev
operator|->
name|mc
operator|.
name|agp_base
operator|+
name|rdev
operator|->
name|mc
operator|.
name|gtt_size
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|r
operator|)
return|;
block|}
name|rdev
operator|->
name|fictitious_agp_range_registered
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|radeon_testing
operator|&
literal|1
operator|)
condition|)
block|{
name|radeon_test_moves
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|radeon_testing
operator|&
literal|2
operator|)
condition|)
block|{
name|radeon_test_syncing
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|radeon_benchmarking
condition|)
block|{
name|radeon_benchmark
argument_list|(
name|rdev
argument_list|,
name|radeon_benchmarking
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREEBSD_WIP
end_ifdef

begin_function_decl
specifier|static
name|void
name|radeon_debugfs_remove_files
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREEBSD_WIP */
end_comment

begin_comment
comment|/**  * radeon_device_fini - tear down the driver  *  * @rdev: radeon_device pointer  *  * Tear down the driver info (all asics).  * Called at driver shutdown.  */
end_comment

begin_function
name|void
name|radeon_device_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|DRM_INFO
argument_list|(
literal|"radeon: finishing device.\n"
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|shutdown
operator|=
name|true
expr_stmt|;
comment|/* evict vram memory */
name|radeon_bo_evict_vram
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|fictitious_range_registered
condition|)
block|{
name|vm_phys_fictitious_unreg_range
argument_list|(
name|rdev
operator|->
name|mc
operator|.
name|aper_base
argument_list|,
name|rdev
operator|->
name|mc
operator|.
name|aper_base
operator|+
name|rdev
operator|->
name|mc
operator|.
name|visible_vram_size
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|__OS_HAS_AGP
if|if
condition|(
name|rdev
operator|->
name|fictitious_agp_range_registered
condition|)
block|{
name|vm_phys_fictitious_unreg_range
argument_list|(
name|rdev
operator|->
name|mc
operator|.
name|agp_base
argument_list|,
name|rdev
operator|->
name|mc
operator|.
name|agp_base
operator|+
name|rdev
operator|->
name|mc
operator|.
name|gtt_size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|radeon_fini
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|vga_switcheroo_unregister_client
argument_list|(
name|rdev
operator|->
name|pdev
argument_list|)
expr_stmt|;
name|vga_client_register
argument_list|(
name|rdev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
if|if
condition|(
name|rdev
operator|->
name|tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_free
argument_list|(
name|rdev
operator|->
name|tq
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rdev
operator|->
name|rio_mem
condition|)
name|bus_release_resource
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|rdev
operator|->
name|rio_rid
argument_list|,
name|rdev
operator|->
name|rio_mem
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|rio_mem
operator|=
name|NULL
expr_stmt|;
name|bus_release_resource
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rdev
operator|->
name|rmmio_rid
argument_list|,
name|rdev
operator|->
name|rmmio
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|rmmio
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|radeon_debugfs_remove_files
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
block|}
end_function

begin_comment
comment|/*  * Suspend& resume.  */
end_comment

begin_comment
comment|/**  * radeon_suspend_kms - initiate device suspend  *  * @pdev: drm dev pointer  * @state: suspend state  *  * Puts the hw in the suspend state (all asics).  * Returns 0 for success or an error on failure.  * Called at driver suspend.  */
end_comment

begin_function
name|int
name|radeon_suspend_kms
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|bool
name|force_completion
init|=
name|false
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
operator|||
name|dev
operator|->
name|dev_private
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
name|ENODEV
return|;
block|}
ifdef|#
directive|ifdef
name|FREEBSD_WIP
if|if
condition|(
name|state
operator|.
name|event
operator|==
name|PM_EVENT_PRETHAW
condition|)
block|{
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|rdev
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|switch_power_state
operator|==
name|DRM_SWITCH_POWER_OFF
condition|)
return|return
literal|0
return|;
name|drm_kms_helper_poll_disable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* turn off display hw */
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
name|drm_helper_connector_dpms
argument_list|(
name|connector
argument_list|,
name|DRM_MODE_DPMS_OFF
argument_list|)
expr_stmt|;
block|}
comment|/* unpin the front buffers */
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
name|struct
name|radeon_framebuffer
modifier|*
name|rfb
init|=
name|to_radeon_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
decl_stmt|;
name|struct
name|radeon_bo
modifier|*
name|robj
decl_stmt|;
if|if
condition|(
name|rfb
operator|==
name|NULL
operator|||
name|rfb
operator|->
name|obj
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
name|robj
operator|=
name|gem_to_radeon_bo
argument_list|(
name|rfb
operator|->
name|obj
argument_list|)
expr_stmt|;
comment|/* don't unpin kernel fb objects */
if|if
condition|(
operator|!
name|radeon_fbdev_robj_is_fb
argument_list|(
name|rdev
argument_list|,
name|robj
argument_list|)
condition|)
block|{
name|r
operator|=
name|radeon_bo_reserve
argument_list|(
name|robj
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|radeon_bo_unpin
argument_list|(
name|robj
argument_list|)
expr_stmt|;
name|radeon_bo_unreserve
argument_list|(
name|robj
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* evict vram memory */
name|radeon_bo_evict_vram
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
comment|/* wait for gpu to finish processing current batch */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|radeon_fence_wait_empty_locked
argument_list|(
name|rdev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
comment|/* delay GPU reset to resume */
name|force_completion
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|force_completion
condition|)
block|{
name|radeon_fence_driver_force_completion
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
name|radeon_save_bios_scratch_regs
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_pm_suspend
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_suspend
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_hpd_fini
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
comment|/* evict remaining vram memory */
name|radeon_bo_evict_vram
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_agp_suspend
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
if|if
condition|(
name|state
operator|.
name|event
operator|==
name|PM_EVENT_SUSPEND
condition|)
block|{
comment|/* Shut down the device */
name|pci_disable_device
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
expr_stmt|;
block|}
name|console_lock
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|radeon_fbdev_set_suspend
argument_list|(
name|rdev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|console_unlock
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_resume_kms - initiate device resume  *  * @pdev: drm dev pointer  *  * Bring the hw back to operating state (all asics).  * Returns 0 for success or an error on failure.  * Called at driver resume.  */
end_comment

begin_function
name|int
name|radeon_resume_kms
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|switch_power_state
operator|==
name|DRM_SWITCH_POWER_OFF
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|console_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|pci_enable_device
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
condition|)
block|{
name|console_unlock
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* FREEBSD_WIP */
comment|/* resume AGP if in use */
name|radeon_agp_resume
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_resume
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|r
operator|=
name|radeon_ib_ring_tests
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|DRM_ERROR
argument_list|(
literal|"ib ring test failed (%d).\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|radeon_pm_resume
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_restore_bios_scratch_regs
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_fbdev_set_suspend
argument_list|(
name|rdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|console_unlock
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
comment|/* init dig PHYs, disp eng pll */
if|if
condition|(
name|rdev
operator|->
name|is_atom_bios
condition|)
block|{
name|radeon_atom_encoder_init
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_atom_disp_eng_pll_init
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
comment|/* turn on the BL */
if|if
condition|(
name|rdev
operator|->
name|mode_info
operator|.
name|bl_encoder
condition|)
block|{
name|u8
name|bl_level
init|=
name|radeon_get_backlight_level
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|bl_encoder
argument_list|)
decl_stmt|;
name|radeon_set_backlight_level
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|mode_info
operator|.
name|bl_encoder
argument_list|,
name|bl_level
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* reset hpd state */
name|radeon_hpd_init
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
comment|/* blat the mode back in */
name|drm_helper_resume_force_mode
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* turn on display hw */
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
name|drm_helper_connector_dpms
argument_list|(
name|connector
argument_list|,
name|DRM_MODE_DPMS_ON
argument_list|)
expr_stmt|;
block|}
name|drm_kms_helper_poll_enable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_gpu_reset - reset the asic  *  * @rdev: radeon device pointer  *  * Attempt the reset the GPU if it has hung (all asics).  * Returns 0 for success or an error on failure.  */
end_comment

begin_function
name|int
name|radeon_gpu_reset
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|unsigned
name|ring_sizes
index|[
name|RADEON_NUM_RINGS
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|ring_data
index|[
name|RADEON_NUM_RINGS
index|]
decl_stmt|;
name|bool
name|saved
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|int
name|resched
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|exclusive_lock
argument_list|)
expr_stmt|;
name|radeon_save_bios_scratch_regs
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
comment|/* block TTM */
name|resched
operator|=
name|ttm_bo_lock_delayed_workqueue
argument_list|(
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bdev
argument_list|)
expr_stmt|;
name|radeon_suspend
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
name|ring_sizes
index|[
name|i
index|]
operator|=
name|radeon_ring_backup
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|ring
index|[
name|i
index|]
argument_list|,
operator|&
name|ring_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring_sizes
index|[
name|i
index|]
condition|)
block|{
name|saved
operator|=
name|true
expr_stmt|;
name|dev_info
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"Saved %d dwords of commands "
literal|"on ring %d.\n"
argument_list|,
name|ring_sizes
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|retry
label|:
name|r
operator|=
name|radeon_asic_reset
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|dev_info
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"GPU reset succeeded, trying to resume\n"
argument_list|)
expr_stmt|;
name|radeon_resume
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
name|radeon_restore_bios_scratch_regs
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
name|radeon_ring_restore
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|ring
index|[
name|i
index|]
argument_list|,
name|ring_sizes
index|[
name|i
index|]
argument_list|,
name|ring_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ring_sizes
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ring_data
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|r
operator|=
name|radeon_ib_ring_tests
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"ib ring test failed (%d).\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved
condition|)
block|{
name|saved
operator|=
name|false
expr_stmt|;
name|radeon_suspend
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
block|}
else|else
block|{
name|radeon_fence_driver_force_completion
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
name|free
argument_list|(
name|ring_data
index|[
name|i
index|]
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
block|}
block|}
name|drm_helper_resume_force_mode
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|)
expr_stmt|;
name|ttm_bo_unlock_delayed_workqueue
argument_list|(
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bdev
argument_list|,
name|resched
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
comment|/* bad news, how to tell it to userspace ? */
name|dev_info
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"GPU reset failed\n"
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|exclusive_lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Debugfs  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREEBSD_WIP
end_ifdef

begin_function
name|int
name|radeon_debugfs_add_files
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|drm_info_list
modifier|*
name|files
parameter_list|,
name|unsigned
name|nfiles
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdev
operator|->
name|debugfs_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rdev
operator|->
name|debugfs
index|[
name|i
index|]
operator|.
name|files
operator|==
name|files
condition|)
block|{
comment|/* Already registered */
return|return
literal|0
return|;
block|}
block|}
name|i
operator|=
name|rdev
operator|->
name|debugfs_count
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|RADEON_DEBUGFS_MAX_COMPONENTS
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Reached maximum number of debugfs components.\n"
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"Report so we increase "
literal|"RADEON_DEBUGFS_MAX_COMPONENTS.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|rdev
operator|->
name|debugfs
index|[
name|rdev
operator|->
name|debugfs_count
index|]
operator|.
name|files
operator|=
name|files
expr_stmt|;
name|rdev
operator|->
name|debugfs
index|[
name|rdev
operator|->
name|debugfs_count
index|]
operator|.
name|num_files
operator|=
name|nfiles
expr_stmt|;
name|rdev
operator|->
name|debugfs_count
operator|=
name|i
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DEBUG_FS
argument_list|)
name|drm_debugfs_create_files
argument_list|(
name|files
argument_list|,
name|nfiles
argument_list|,
name|rdev
operator|->
name|ddev
operator|->
name|control
operator|->
name|debugfs_root
argument_list|,
name|rdev
operator|->
name|ddev
operator|->
name|control
argument_list|)
expr_stmt|;
name|drm_debugfs_create_files
argument_list|(
name|files
argument_list|,
name|nfiles
argument_list|,
name|rdev
operator|->
name|ddev
operator|->
name|primary
operator|->
name|debugfs_root
argument_list|,
name|rdev
operator|->
name|ddev
operator|->
name|primary
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_debugfs_remove_files
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DEBUG_FS
argument_list|)
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdev
operator|->
name|debugfs_count
condition|;
name|i
operator|++
control|)
block|{
name|drm_debugfs_remove_files
argument_list|(
name|rdev
operator|->
name|debugfs
index|[
name|i
index|]
operator|.
name|files
argument_list|,
name|rdev
operator|->
name|debugfs
index|[
name|i
index|]
operator|.
name|num_files
argument_list|,
name|rdev
operator|->
name|ddev
operator|->
name|control
argument_list|)
expr_stmt|;
name|drm_debugfs_remove_files
argument_list|(
name|rdev
operator|->
name|debugfs
index|[
name|i
index|]
operator|.
name|files
argument_list|,
name|rdev
operator|->
name|debugfs
index|[
name|i
index|]
operator|.
name|num_files
argument_list|,
name|rdev
operator|->
name|ddev
operator|->
name|primary
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DEBUG_FS
argument_list|)
end_if

begin_function
name|int
name|radeon_debugfs_init
parameter_list|(
name|struct
name|drm_minor
modifier|*
name|minor
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|radeon_debugfs_cleanup
parameter_list|(
name|struct
name|drm_minor
modifier|*
name|minor
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREEBSD_WIP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

