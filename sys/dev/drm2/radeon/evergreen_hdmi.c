begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008 Advanced Micro Devices, Inc.  * Copyright 2008 Red Hat Inc.  * Copyright 2009 Christian KÃ¶nig.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *  * Authors: Christian KÃ¶nig  *          RafaÅ MiÅecki  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/radeon/radeon_drm.h>
end_include

begin_include
include|#
directive|include
file|"radeon.h"
end_include

begin_include
include|#
directive|include
file|"radeon_asic.h"
end_include

begin_include
include|#
directive|include
file|"evergreend.h"
end_include

begin_include
include|#
directive|include
file|"atom.h"
end_include

begin_comment
comment|/*  * update the N and CTS parameters for a given pixel clock rate  */
end_comment

begin_function
specifier|static
name|void
name|evergreen_hdmi_update_ACR
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|uint32_t
name|clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_hdmi_acr
name|acr
init|=
name|r600_hdmi_acr
argument_list|(
name|clock
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|uint32_t
name|offset
init|=
name|dig
operator|->
name|afmt
operator|->
name|offset
decl_stmt|;
name|WREG32
argument_list|(
name|HDMI_ACR_32_0
operator|+
name|offset
argument_list|,
name|HDMI_ACR_CTS_32
argument_list|(
name|acr
operator|.
name|cts_32khz
argument_list|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI_ACR_32_1
operator|+
name|offset
argument_list|,
name|acr
operator|.
name|n_32khz
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI_ACR_44_0
operator|+
name|offset
argument_list|,
name|HDMI_ACR_CTS_44
argument_list|(
name|acr
operator|.
name|cts_44_1khz
argument_list|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI_ACR_44_1
operator|+
name|offset
argument_list|,
name|acr
operator|.
name|n_44_1khz
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI_ACR_48_0
operator|+
name|offset
argument_list|,
name|HDMI_ACR_CTS_48
argument_list|(
name|acr
operator|.
name|cts_48khz
argument_list|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI_ACR_48_1
operator|+
name|offset
argument_list|,
name|acr
operator|.
name|n_48khz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * calculate the crc for a given info frame  */
end_comment

begin_function
specifier|static
name|void
name|evergreen_hdmi_infoframe_checksum
parameter_list|(
name|uint8_t
name|packetType
parameter_list|,
name|uint8_t
name|versionNumber
parameter_list|,
name|uint8_t
name|length
parameter_list|,
name|uint8_t
modifier|*
name|frame
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|frame
index|[
literal|0
index|]
operator|=
name|packetType
operator|+
name|versionNumber
operator|+
name|length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|length
condition|;
name|i
operator|++
control|)
name|frame
index|[
literal|0
index|]
operator|+=
name|frame
index|[
name|i
index|]
expr_stmt|;
name|frame
index|[
literal|0
index|]
operator|=
literal|0x100
operator|-
name|frame
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * build a HDMI Video Info Frame  */
end_comment

begin_function
specifier|static
name|void
name|evergreen_hdmi_videoinfoframe
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|uint8_t
name|color_format
parameter_list|,
name|int
name|active_information_present
parameter_list|,
name|uint8_t
name|active_format_aspect_ratio
parameter_list|,
name|uint8_t
name|scan_information
parameter_list|,
name|uint8_t
name|colorimetry
parameter_list|,
name|uint8_t
name|ex_colorimetry
parameter_list|,
name|uint8_t
name|quantization
parameter_list|,
name|int
name|ITC
parameter_list|,
name|uint8_t
name|picture_aspect_ratio
parameter_list|,
name|uint8_t
name|video_format_identification
parameter_list|,
name|uint8_t
name|pixel_repetition
parameter_list|,
name|uint8_t
name|non_uniform_picture_scaling
parameter_list|,
name|uint8_t
name|bar_info_data_valid
parameter_list|,
name|uint16_t
name|top_bar
parameter_list|,
name|uint16_t
name|bottom_bar
parameter_list|,
name|uint16_t
name|left_bar
parameter_list|,
name|uint16_t
name|right_bar
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|uint32_t
name|offset
init|=
name|dig
operator|->
name|afmt
operator|->
name|offset
decl_stmt|;
name|uint8_t
name|frame
index|[
literal|14
index|]
decl_stmt|;
name|frame
index|[
literal|0x0
index|]
operator|=
literal|0
expr_stmt|;
name|frame
index|[
literal|0x1
index|]
operator|=
operator|(
name|scan_information
operator|&
literal|0x3
operator|)
operator||
operator|(
operator|(
name|bar_info_data_valid
operator|&
literal|0x3
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|active_information_present
operator|&
literal|0x1
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|color_format
operator|&
literal|0x3
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
name|frame
index|[
literal|0x2
index|]
operator|=
operator|(
name|active_format_aspect_ratio
operator|&
literal|0xF
operator|)
operator||
operator|(
operator|(
name|picture_aspect_ratio
operator|&
literal|0x3
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|colorimetry
operator|&
literal|0x3
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
name|frame
index|[
literal|0x3
index|]
operator|=
operator|(
name|non_uniform_picture_scaling
operator|&
literal|0x3
operator|)
operator||
operator|(
operator|(
name|quantization
operator|&
literal|0x3
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|ex_colorimetry
operator|&
literal|0x7
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|ITC
operator|&
literal|0x1
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
name|frame
index|[
literal|0x4
index|]
operator|=
operator|(
name|video_format_identification
operator|&
literal|0x7F
operator|)
expr_stmt|;
name|frame
index|[
literal|0x5
index|]
operator|=
operator|(
name|pixel_repetition
operator|&
literal|0xF
operator|)
expr_stmt|;
name|frame
index|[
literal|0x6
index|]
operator|=
operator|(
name|top_bar
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|frame
index|[
literal|0x7
index|]
operator|=
operator|(
name|top_bar
operator|>>
literal|8
operator|)
expr_stmt|;
name|frame
index|[
literal|0x8
index|]
operator|=
operator|(
name|bottom_bar
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|frame
index|[
literal|0x9
index|]
operator|=
operator|(
name|bottom_bar
operator|>>
literal|8
operator|)
expr_stmt|;
name|frame
index|[
literal|0xA
index|]
operator|=
operator|(
name|left_bar
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|frame
index|[
literal|0xB
index|]
operator|=
operator|(
name|left_bar
operator|>>
literal|8
operator|)
expr_stmt|;
name|frame
index|[
literal|0xC
index|]
operator|=
operator|(
name|right_bar
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|frame
index|[
literal|0xD
index|]
operator|=
operator|(
name|right_bar
operator|>>
literal|8
operator|)
expr_stmt|;
name|evergreen_hdmi_infoframe_checksum
argument_list|(
literal|0x82
argument_list|,
literal|0x02
argument_list|,
literal|0x0D
argument_list|,
name|frame
argument_list|)
expr_stmt|;
comment|/* Our header values (type, version, length) should be alright, Intel 	 * is using the same. Checksum function also seems to be OK, it works 	 * fine for audio infoframe. However calculated value is always lower 	 * by 2 in comparison to fglrx. It breaks displaying anything in case 	 * of TVs that strictly check the checksum. Hack it manually here to 	 * workaround this issue. */
name|frame
index|[
literal|0x0
index|]
operator|+=
literal|2
expr_stmt|;
name|WREG32
argument_list|(
name|AFMT_AVI_INFO0
operator|+
name|offset
argument_list|,
name|frame
index|[
literal|0x0
index|]
operator||
operator|(
name|frame
index|[
literal|0x1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|frame
index|[
literal|0x2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|frame
index|[
literal|0x3
index|]
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AFMT_AVI_INFO1
operator|+
name|offset
argument_list|,
name|frame
index|[
literal|0x4
index|]
operator||
operator|(
name|frame
index|[
literal|0x5
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|frame
index|[
literal|0x6
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|frame
index|[
literal|0x7
index|]
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AFMT_AVI_INFO2
operator|+
name|offset
argument_list|,
name|frame
index|[
literal|0x8
index|]
operator||
operator|(
name|frame
index|[
literal|0x9
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|frame
index|[
literal|0xA
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|frame
index|[
literal|0xB
index|]
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AFMT_AVI_INFO3
operator|+
name|offset
argument_list|,
name|frame
index|[
literal|0xC
index|]
operator||
operator|(
name|frame
index|[
literal|0xD
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * update the info frames with the data from the current display mode  */
end_comment

begin_function
name|void
name|evergreen_hdmi_setmode
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
comment|/* Silent, r600_hdmi_enable will raise WARN for us */
if|if
condition|(
operator|!
name|dig
operator|->
name|afmt
operator|->
name|enabled
condition|)
return|return;
name|offset
operator|=
name|dig
operator|->
name|afmt
operator|->
name|offset
expr_stmt|;
name|r600_audio_set_clock
argument_list|(
name|encoder
argument_list|,
name|mode
operator|->
name|clock
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI_VBI_PACKET_CONTROL
operator|+
name|offset
argument_list|,
name|HDMI_NULL_SEND
argument_list|)
expr_stmt|;
comment|/* send null packets when required */
name|WREG32
argument_list|(
name|AFMT_AUDIO_CRC_CONTROL
operator|+
name|offset
argument_list|,
literal|0x1000
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI_AUDIO_PACKET_CONTROL
operator|+
name|offset
argument_list|,
name|HDMI_AUDIO_DELAY_EN
argument_list|(
literal|1
argument_list|)
operator||
comment|/* set the default audio delay */
name|HDMI_AUDIO_PACKETS_PER_LINE
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* should be suffient for all audio modes and small enough for all hblanks */
name|WREG32
argument_list|(
name|AFMT_AUDIO_PACKET_CONTROL
operator|+
name|offset
argument_list|,
name|AFMT_AUDIO_SAMPLE_SEND
operator||
comment|/* send audio packets */
name|AFMT_60958_CS_UPDATE
argument_list|)
expr_stmt|;
comment|/* allow 60958 channel status fields to be updated */
name|WREG32
argument_list|(
name|HDMI_ACR_PACKET_CONTROL
operator|+
name|offset
argument_list|,
name|HDMI_ACR_AUTO_SEND
operator||
comment|/* allow hw to sent ACR packets when required */
name|HDMI_ACR_SOURCE
argument_list|)
expr_stmt|;
comment|/* select SW CTS value */
name|WREG32
argument_list|(
name|HDMI_VBI_PACKET_CONTROL
operator|+
name|offset
argument_list|,
name|HDMI_NULL_SEND
operator||
comment|/* send null packets when required */
name|HDMI_GC_SEND
operator||
comment|/* send general control packets */
name|HDMI_GC_CONT
argument_list|)
expr_stmt|;
comment|/* send general control packets every frame */
name|WREG32
argument_list|(
name|HDMI_INFOFRAME_CONTROL0
operator|+
name|offset
argument_list|,
name|HDMI_AVI_INFO_SEND
operator||
comment|/* enable AVI info frames */
name|HDMI_AVI_INFO_CONT
operator||
comment|/* send AVI info frames every frame/field */
name|HDMI_AUDIO_INFO_SEND
operator||
comment|/* enable audio info frames (frames won't be set until audio is enabled) */
name|HDMI_AUDIO_INFO_CONT
argument_list|)
expr_stmt|;
comment|/* required for audio info values to be updated */
name|WREG32
argument_list|(
name|AFMT_INFOFRAME_CONTROL0
operator|+
name|offset
argument_list|,
name|AFMT_AUDIO_INFO_UPDATE
argument_list|)
expr_stmt|;
comment|/* required for audio info values to be updated */
name|WREG32
argument_list|(
name|HDMI_INFOFRAME_CONTROL1
operator|+
name|offset
argument_list|,
name|HDMI_AVI_INFO_LINE
argument_list|(
literal|2
argument_list|)
operator||
comment|/* anything other than 0 */
name|HDMI_AUDIO_INFO_LINE
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* anything other than 0 */
name|WREG32
argument_list|(
name|HDMI_GC
operator|+
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unset HDMI_GC_AVMUTE */
name|evergreen_hdmi_videoinfoframe
argument_list|(
name|encoder
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evergreen_hdmi_update_ACR
argument_list|(
name|encoder
argument_list|,
name|mode
operator|->
name|clock
argument_list|)
expr_stmt|;
comment|/* it's unknown what these bits do excatly, but it's indeed quite useful for debugging */
name|WREG32
argument_list|(
name|AFMT_RAMP_CONTROL0
operator|+
name|offset
argument_list|,
literal|0x00FFFFFF
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AFMT_RAMP_CONTROL1
operator|+
name|offset
argument_list|,
literal|0x007FFFFF
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AFMT_RAMP_CONTROL2
operator|+
name|offset
argument_list|,
literal|0x00000001
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AFMT_RAMP_CONTROL3
operator|+
name|offset
argument_list|,
literal|0x00000001
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

