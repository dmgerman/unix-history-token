begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008 Advanced Micro Devices, Inc.  * Copyright 2008 Red Hat Inc.  * Copyright 2009 Jerome Glisse.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *  * Authors: Dave Airlie  *          Alex Deucher  *          Jerome Glisse  *          Christian KÃ¶nig  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/radeon/radeon_drm.h>
end_include

begin_include
include|#
directive|include
file|"radeon_reg.h"
end_include

begin_include
include|#
directive|include
file|"radeon.h"
end_include

begin_include
include|#
directive|include
file|"atom.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
end_ifdef

begin_comment
comment|/*  * IB  * IBs (Indirect Buffers) and areas of GPU accessible memory where  * commands are stored.  You can put a pointer to the IB in the  * command ring and the hw will fetch the commands from the IB  * and execute them.  Generally userspace acceleration drivers  * produce command buffers which are send to the kernel and  * put in IBs for execution by the requested ring.  */
end_comment

begin_function_decl
specifier|static
name|int
name|radeon_debugfs_sa_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DUMBBELL_WIP */
end_comment

begin_comment
comment|/**  * radeon_ib_get - request an IB (Indirect Buffer)  *  * @rdev: radeon_device pointer  * @ring: ring index the IB is associated with  * @ib: IB object returned  * @size: requested IB size  *  * Request an IB (all asics).  IBs are allocated using the  * suballocator.  * Returns 0 on success, error on failure.  */
end_comment

begin_function
name|int
name|radeon_ib_get
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|int
name|ring
parameter_list|,
name|struct
name|radeon_ib
modifier|*
name|ib
parameter_list|,
name|struct
name|radeon_vm
modifier|*
name|vm
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|r
operator|=
name|radeon_sa_bo_new
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|ring_tmp_bo
argument_list|,
operator|&
name|ib
operator|->
name|sa_bo
argument_list|,
name|size
argument_list|,
literal|256
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"failed to get a new IB (%d)\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|r
operator|=
name|radeon_semaphore_create
argument_list|(
name|rdev
argument_list|,
operator|&
name|ib
operator|->
name|semaphore
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
return|return
name|r
return|;
block|}
name|ib
operator|->
name|ring
operator|=
name|ring
expr_stmt|;
name|ib
operator|->
name|fence
operator|=
name|NULL
expr_stmt|;
name|ib
operator|->
name|ptr
operator|=
name|radeon_sa_bo_cpu_addr
argument_list|(
name|ib
operator|->
name|sa_bo
argument_list|)
expr_stmt|;
name|ib
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
if|if
condition|(
name|vm
condition|)
block|{
comment|/* ib pool is bound at RADEON_VA_IB_OFFSET in virtual address 		 * space and soffset is the offset inside the pool bo 		 */
name|ib
operator|->
name|gpu_addr
operator|=
name|ib
operator|->
name|sa_bo
operator|->
name|soffset
operator|+
name|RADEON_VA_IB_OFFSET
expr_stmt|;
block|}
else|else
block|{
name|ib
operator|->
name|gpu_addr
operator|=
name|radeon_sa_bo_gpu_addr
argument_list|(
name|ib
operator|->
name|sa_bo
argument_list|)
expr_stmt|;
block|}
name|ib
operator|->
name|is_const_ib
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
name|ib
operator|->
name|sync_to
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_ib_free - free an IB (Indirect Buffer)  *  * @rdev: radeon_device pointer  * @ib: IB object to free  *  * Free an IB (all asics).  */
end_comment

begin_function
name|void
name|radeon_ib_free
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ib
modifier|*
name|ib
parameter_list|)
block|{
name|radeon_semaphore_free
argument_list|(
name|rdev
argument_list|,
operator|&
name|ib
operator|->
name|semaphore
argument_list|,
name|ib
operator|->
name|fence
argument_list|)
expr_stmt|;
name|radeon_sa_bo_free
argument_list|(
name|rdev
argument_list|,
operator|&
name|ib
operator|->
name|sa_bo
argument_list|,
name|ib
operator|->
name|fence
argument_list|)
expr_stmt|;
name|radeon_fence_unref
argument_list|(
operator|&
name|ib
operator|->
name|fence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_ib_schedule - schedule an IB (Indirect Buffer) on the ring  *  * @rdev: radeon_device pointer  * @ib: IB object to schedule  * @const_ib: Const IB to schedule (SI only)  *  * Schedule an IB on the associated ring (all asics).  * Returns 0 on success, error on failure.  *  * On SI, there are two parallel engines fed from the primary ring,  * the CE (Constant Engine) and the DE (Drawing Engine).  Since  * resource descriptors have moved to memory, the CE allows you to  * prime the caches while the DE is updating register state so that  * the resource descriptors will be already in cache when the draw is  * processed.  To accomplish this, the userspace driver submits two  * IBs, one for the CE and one for the DE.  If there is a CE IB (called  * a CONST_IB), it will be put on the ring prior to the DE IB.  Prior  * to SI there was just a DE IB.  */
end_comment

begin_function
name|int
name|radeon_ib_schedule
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ib
modifier|*
name|ib
parameter_list|,
name|struct
name|radeon_ib
modifier|*
name|const_ib
parameter_list|)
block|{
name|struct
name|radeon_ring
modifier|*
name|ring
init|=
operator|&
name|rdev
operator|->
name|ring
index|[
name|ib
operator|->
name|ring
index|]
decl_stmt|;
name|bool
name|need_sync
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ib
operator|->
name|length_dw
operator|||
operator|!
name|ring
operator|->
name|ready
condition|)
block|{
comment|/* TODO: Nothings in the ib we should report. */
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"couldn't schedule ib\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* 64 dwords should be enough for fence too */
name|r
operator|=
name|radeon_ring_lock
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|,
literal|64
operator|+
name|RADEON_NUM_RINGS
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"scheduling IB failed (%d).\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|radeon_fence
modifier|*
name|fence
init|=
name|ib
operator|->
name|sync_to
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|radeon_fence_need_sync
argument_list|(
name|fence
argument_list|,
name|ib
operator|->
name|ring
argument_list|)
condition|)
block|{
name|need_sync
operator|=
name|true
expr_stmt|;
name|radeon_semaphore_sync_rings
argument_list|(
name|rdev
argument_list|,
name|ib
operator|->
name|semaphore
argument_list|,
name|fence
operator|->
name|ring
argument_list|,
name|ib
operator|->
name|ring
argument_list|)
expr_stmt|;
name|radeon_fence_note_sync
argument_list|(
name|fence
argument_list|,
name|ib
operator|->
name|ring
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* immediately free semaphore when we don't need to sync */
if|if
condition|(
operator|!
name|need_sync
condition|)
block|{
name|radeon_semaphore_free
argument_list|(
name|rdev
argument_list|,
operator|&
name|ib
operator|->
name|semaphore
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* if we can't remember our last VM flush then flush now! */
if|if
condition|(
name|ib
operator|->
name|vm
operator|&&
operator|!
name|ib
operator|->
name|vm
operator|->
name|last_flush
condition|)
block|{
name|radeon_ring_vm_flush
argument_list|(
name|rdev
argument_list|,
name|ib
operator|->
name|ring
argument_list|,
name|ib
operator|->
name|vm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|const_ib
condition|)
block|{
name|radeon_ring_ib_execute
argument_list|(
name|rdev
argument_list|,
name|const_ib
operator|->
name|ring
argument_list|,
name|const_ib
argument_list|)
expr_stmt|;
name|radeon_semaphore_free
argument_list|(
name|rdev
argument_list|,
operator|&
name|const_ib
operator|->
name|semaphore
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|radeon_ring_ib_execute
argument_list|(
name|rdev
argument_list|,
name|ib
operator|->
name|ring
argument_list|,
name|ib
argument_list|)
expr_stmt|;
name|r
operator|=
name|radeon_fence_emit
argument_list|(
name|rdev
argument_list|,
operator|&
name|ib
operator|->
name|fence
argument_list|,
name|ib
operator|->
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"failed to emit fence for new IB (%d)\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|radeon_ring_unlock_undo
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|const_ib
condition|)
block|{
name|const_ib
operator|->
name|fence
operator|=
name|radeon_fence_ref
argument_list|(
name|ib
operator|->
name|fence
argument_list|)
expr_stmt|;
block|}
comment|/* we just flushed the VM, remember that */
if|if
condition|(
name|ib
operator|->
name|vm
operator|&&
operator|!
name|ib
operator|->
name|vm
operator|->
name|last_flush
condition|)
block|{
name|ib
operator|->
name|vm
operator|->
name|last_flush
operator|=
name|radeon_fence_ref
argument_list|(
name|ib
operator|->
name|fence
argument_list|)
expr_stmt|;
block|}
name|radeon_ring_unlock_commit
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_ib_pool_init - Init the IB (Indirect Buffer) pool  *  * @rdev: radeon_device pointer  *  * Initialize the suballocator to manage a pool of memory  * for use as IBs (all asics).  * Returns 0 on success, error on failure.  */
end_comment

begin_function
name|int
name|radeon_ib_pool_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|rdev
operator|->
name|ib_pool_ready
condition|)
block|{
return|return
literal|0
return|;
block|}
name|r
operator|=
name|radeon_sa_bo_manager_init
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|ring_tmp_bo
argument_list|,
name|RADEON_IB_POOL_SIZE
operator|*
literal|64
operator|*
literal|1024
argument_list|,
name|RADEON_GEM_DOMAIN_GTT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
return|return
name|r
return|;
block|}
name|r
operator|=
name|radeon_sa_bo_manager_start
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|ring_tmp_bo
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
return|return
name|r
return|;
block|}
name|rdev
operator|->
name|ib_pool_ready
operator|=
name|true
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
if|if
condition|(
name|radeon_debugfs_sa_init
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"failed to register debugfs file for SA\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_ib_pool_fini - Free the IB (Indirect Buffer) pool  *  * @rdev: radeon_device pointer  *  * Tear down the suballocator managing the pool of memory  * for use as IBs (all asics).  */
end_comment

begin_function
name|void
name|radeon_ib_pool_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|if
condition|(
name|rdev
operator|->
name|ib_pool_ready
condition|)
block|{
name|radeon_sa_bo_manager_suspend
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|ring_tmp_bo
argument_list|)
expr_stmt|;
name|radeon_sa_bo_manager_fini
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|ring_tmp_bo
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|ib_pool_ready
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_ib_ring_tests - test IBs on the rings  *  * @rdev: radeon_device pointer  *  * Test an IB (Indirect Buffer) on each ring.  * If the test fails, disable the ring.  * Returns 0 on success, error if the primary GFX ring  * IB test fails.  */
end_comment

begin_function
name|int
name|radeon_ib_ring_tests
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|int
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|radeon_ring
modifier|*
name|ring
init|=
operator|&
name|rdev
operator|->
name|ring
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ring
operator|->
name|ready
condition|)
continue|continue;
name|r
operator|=
name|radeon_ib_test
argument_list|(
name|rdev
argument_list|,
name|i
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|ring
operator|->
name|ready
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|RADEON_RING_TYPE_GFX_INDEX
condition|)
block|{
comment|/* oh, oh, that's really bad */
name|DRM_ERROR
argument_list|(
literal|"radeon: failed testing IB on GFX ring (%d).\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|accel_working
operator|=
name|false
expr_stmt|;
return|return
name|r
return|;
block|}
else|else
block|{
comment|/* still not good, but we can live with it */
name|DRM_ERROR
argument_list|(
literal|"radeon: failed testing IB on ring %d (%d).\n"
argument_list|,
name|i
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
end_ifdef

begin_comment
comment|/*  * Rings  * Most engines on the GPU are fed via ring buffers.  Ring  * buffers are areas of GPU accessible memory that the host  * writes commands into and the GPU reads commands out of.  * There is a rptr (read pointer) that determines where the  * GPU is currently reading, and a wptr (write pointer)  * which determines where the host has written.  When the  * pointers are equal, the ring is idle.  When the host  * writes commands to the ring buffer, it increments the  * wptr.  The GPU then starts fetching commands and executes  * them until the pointers are equal again.  */
end_comment

begin_function_decl
specifier|static
name|int
name|radeon_debugfs_ring_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DUMBBELL_WIP */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DRM_DEBUG_CODE
argument_list|)
operator|&&
name|DRM_DEBUG_CODE
operator|!=
literal|0
end_if

begin_comment
comment|/**  * radeon_ring_write - write a value to the ring  *  * @ring: radeon_ring structure holding ring information  * @v: dword (dw) value to write  *  * Write a value to the requested ring buffer (all asics).  */
end_comment

begin_function
name|void
name|radeon_ring_write
parameter_list|(
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|,
name|uint32_t
name|v
parameter_list|)
block|{
if|#
directive|if
name|DRM_DEBUG_CODE
if|if
condition|(
name|ring
operator|->
name|count_dw
operator|<=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"radeon: writing more dwords to the ring than expected!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ring
operator|->
name|ring
index|[
name|ring
operator|->
name|wptr
operator|++
index|]
operator|=
name|v
expr_stmt|;
name|ring
operator|->
name|wptr
operator|&=
name|ring
operator|->
name|ptr_mask
expr_stmt|;
name|ring
operator|->
name|count_dw
operator|--
expr_stmt|;
name|ring
operator|->
name|ring_free_dw
operator|--
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * radeon_ring_supports_scratch_reg - check if the ring supports  * writing to scratch registers  *  * @rdev: radeon_device pointer  * @ring: radeon_ring structure holding ring information  *  * Check if a specific ring supports writing to scratch registers (all asics).  * Returns true if the ring supports writing to scratch regs, false if not.  */
end_comment

begin_function
name|bool
name|radeon_ring_supports_scratch_reg
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|)
block|{
switch|switch
condition|(
name|ring
operator|->
name|idx
condition|)
block|{
case|case
name|RADEON_RING_TYPE_GFX_INDEX
case|:
case|case
name|CAYMAN_RING_TYPE_CP1_INDEX
case|:
case|case
name|CAYMAN_RING_TYPE_CP2_INDEX
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_ring_free_size - update the free size  *  * @rdev: radeon_device pointer  * @ring: radeon_ring structure holding ring information  *  * Update the free dw slots in the ring buffer (all asics).  */
end_comment

begin_function
name|void
name|radeon_ring_free_size
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|)
block|{
name|u32
name|rptr
decl_stmt|;
if|if
condition|(
name|rdev
operator|->
name|wb
operator|.
name|enabled
condition|)
name|rptr
operator|=
name|le32_to_cpu
argument_list|(
name|rdev
operator|->
name|wb
operator|.
name|wb
index|[
name|ring
operator|->
name|rptr_offs
operator|/
literal|4
index|]
argument_list|)
expr_stmt|;
else|else
name|rptr
operator|=
name|RREG32
argument_list|(
name|ring
operator|->
name|rptr_reg
argument_list|)
expr_stmt|;
name|ring
operator|->
name|rptr
operator|=
operator|(
name|rptr
operator|&
name|ring
operator|->
name|ptr_reg_mask
operator|)
operator|>>
name|ring
operator|->
name|ptr_reg_shift
expr_stmt|;
comment|/* This works because ring_size is a power of 2 */
name|ring
operator|->
name|ring_free_dw
operator|=
operator|(
name|ring
operator|->
name|rptr
operator|+
operator|(
name|ring
operator|->
name|ring_size
operator|/
literal|4
operator|)
operator|)
expr_stmt|;
name|ring
operator|->
name|ring_free_dw
operator|-=
name|ring
operator|->
name|wptr
expr_stmt|;
name|ring
operator|->
name|ring_free_dw
operator|&=
name|ring
operator|->
name|ptr_mask
expr_stmt|;
if|if
condition|(
operator|!
name|ring
operator|->
name|ring_free_dw
condition|)
block|{
name|ring
operator|->
name|ring_free_dw
operator|=
name|ring
operator|->
name|ring_size
operator|/
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_ring_alloc - allocate space on the ring buffer  *  * @rdev: radeon_device pointer  * @ring: radeon_ring structure holding ring information  * @ndw: number of dwords to allocate in the ring buffer  *  * Allocate @ndw dwords in the ring buffer (all asics).  * Returns 0 on success, error on failure.  */
end_comment

begin_function
name|int
name|radeon_ring_alloc
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|,
name|unsigned
name|ndw
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
comment|/* make sure we aren't trying to allocate more space than there is on the ring */
if|if
condition|(
name|ndw
operator|>
operator|(
name|ring
operator|->
name|ring_size
operator|/
literal|4
operator|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
comment|/* Align requested size with padding so unlock_commit can 	 * pad safely */
name|ndw
operator|=
operator|(
name|ndw
operator|+
name|ring
operator|->
name|align_mask
operator|)
operator|&
operator|~
name|ring
operator|->
name|align_mask
expr_stmt|;
while|while
condition|(
name|ndw
operator|>
operator|(
name|ring
operator|->
name|ring_free_dw
operator|-
literal|1
operator|)
condition|)
block|{
name|radeon_ring_free_size
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndw
operator|<
name|ring
operator|->
name|ring_free_dw
condition|)
block|{
break|break;
block|}
name|r
operator|=
name|radeon_fence_wait_next_locked
argument_list|(
name|rdev
argument_list|,
name|ring
operator|->
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
block|}
name|ring
operator|->
name|count_dw
operator|=
name|ndw
expr_stmt|;
name|ring
operator|->
name|wptr_old
operator|=
name|ring
operator|->
name|wptr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_ring_lock - lock the ring and allocate space on it  *  * @rdev: radeon_device pointer  * @ring: radeon_ring structure holding ring information  * @ndw: number of dwords to allocate in the ring buffer  *  * Lock the ring and allocate @ndw dwords in the ring buffer  * (all asics).  * Returns 0 on success, error on failure.  */
end_comment

begin_function
name|int
name|radeon_ring_lock
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|,
name|unsigned
name|ndw
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
name|r
operator|=
name|radeon_ring_alloc
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|,
name|ndw
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_ring_commit - tell the GPU to execute the new  * commands on the ring buffer  *  * @rdev: radeon_device pointer  * @ring: radeon_ring structure holding ring information  *  * Update the wptr (write pointer) to tell the GPU to  * execute new commands on the ring buffer (all asics).  */
end_comment

begin_function
name|void
name|radeon_ring_commit
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|)
block|{
comment|/* We pad to match fetch size */
while|while
condition|(
name|ring
operator|->
name|wptr
operator|&
name|ring
operator|->
name|align_mask
condition|)
block|{
name|radeon_ring_write
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|nop
argument_list|)
expr_stmt|;
block|}
name|DRM_MEMORYBARRIER
argument_list|()
expr_stmt|;
name|WREG32
argument_list|(
name|ring
operator|->
name|wptr_reg
argument_list|,
operator|(
name|ring
operator|->
name|wptr
operator|<<
name|ring
operator|->
name|ptr_reg_shift
operator|)
operator|&
name|ring
operator|->
name|ptr_reg_mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|RREG32
argument_list|(
name|ring
operator|->
name|wptr_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_ring_unlock_commit - tell the GPU to execute the new  * commands on the ring buffer and unlock it  *  * @rdev: radeon_device pointer  * @ring: radeon_ring structure holding ring information  *  * Call radeon_ring_commit() then unlock the ring (all asics).  */
end_comment

begin_function
name|void
name|radeon_ring_unlock_commit
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|)
block|{
name|radeon_ring_commit
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_ring_undo - reset the wptr  *  * @ring: radeon_ring structure holding ring information  *  * Reset the driver's copy of the wptr (all asics).  */
end_comment

begin_function
name|void
name|radeon_ring_undo
parameter_list|(
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|)
block|{
name|ring
operator|->
name|wptr
operator|=
name|ring
operator|->
name|wptr_old
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_ring_unlock_undo - reset the wptr and unlock the ring  *  * @ring: radeon_ring structure holding ring information  *  * Call radeon_ring_undo() then unlock the ring (all asics).  */
end_comment

begin_function
name|void
name|radeon_ring_unlock_undo
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|)
block|{
name|radeon_ring_undo
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_ring_force_activity - add some nop packets to the ring  *  * @rdev: radeon_device pointer  * @ring: radeon_ring structure holding ring information  *  * Add some nop packets to the ring to force activity (all asics).  * Used for lockup detection to see if the rptr is advancing.  */
end_comment

begin_function
name|void
name|radeon_ring_force_activity
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|radeon_ring_free_size
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|rptr
operator|==
name|ring
operator|->
name|wptr
condition|)
block|{
name|r
operator|=
name|radeon_ring_alloc
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|radeon_ring_write
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|nop
argument_list|)
expr_stmt|;
name|radeon_ring_commit
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_ring_lockup_update - update lockup variables  *  * @ring: radeon_ring structure holding ring information  *  * Update the last rptr value and timestamp (all asics).  */
end_comment

begin_function
name|void
name|radeon_ring_lockup_update
parameter_list|(
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|)
block|{
name|ring
operator|->
name|last_rptr
operator|=
name|ring
operator|->
name|rptr
expr_stmt|;
name|ring
operator|->
name|last_activity
operator|=
name|jiffies
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_ring_test_lockup() - check if ring is lockedup by recording information  * @rdev:       radeon device structure  * @ring:       radeon_ring structure holding ring information  *  * We don't need to initialize the lockup tracking information as we will either  * have CP rptr to a different value of jiffies wrap around which will force  * initialization of the lockup tracking informations.  *  * A possible false positivie is if we get call after while and last_cp_rptr ==  * the current CP rptr, even if it's unlikely it might happen. To avoid this  * if the elapsed time since last call is bigger than 2 second than we return  * false and update the tracking information. Due to this the caller must call  * radeon_ring_test_lockup several time in less than 2sec for lockup to be reported  * the fencing code should be cautious about that.  *  * Caller should write to the ring to force CP to do something so we don't get  * false positive when CP is just gived nothing to do.  *  **/
end_comment

begin_function
name|bool
name|radeon_ring_test_lockup
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|)
block|{
name|unsigned
name|long
name|cjiffies
decl_stmt|,
name|elapsed
decl_stmt|;
name|uint32_t
name|rptr
decl_stmt|;
name|cjiffies
operator|=
name|jiffies
expr_stmt|;
if|if
condition|(
operator|!
name|time_after
argument_list|(
name|cjiffies
argument_list|,
name|ring
operator|->
name|last_activity
argument_list|)
condition|)
block|{
comment|/* likely a wrap around */
name|radeon_ring_lockup_update
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|rptr
operator|=
name|RREG32
argument_list|(
name|ring
operator|->
name|rptr_reg
argument_list|)
expr_stmt|;
name|ring
operator|->
name|rptr
operator|=
operator|(
name|rptr
operator|&
name|ring
operator|->
name|ptr_reg_mask
operator|)
operator|>>
name|ring
operator|->
name|ptr_reg_shift
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|rptr
operator|!=
name|ring
operator|->
name|last_rptr
condition|)
block|{
comment|/* CP is still working no lockup */
name|radeon_ring_lockup_update
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|elapsed
operator|=
name|jiffies_to_msecs
argument_list|(
name|cjiffies
operator|-
name|ring
operator|->
name|last_activity
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_lockup_timeout
operator|&&
name|elapsed
operator|>=
name|radeon_lockup_timeout
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"GPU lockup CP stall for more than %lumsec\n"
argument_list|,
name|elapsed
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* give a chance to the GPU ... */
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_ring_backup - Back up the content of a ring  *  * @rdev: radeon_device pointer  * @ring: the ring we want to back up  *  * Saves all unprocessed commits from a ring, returns the number of dwords saved.  */
end_comment

begin_function
name|unsigned
name|radeon_ring_backup
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|size
decl_stmt|,
name|ptr
decl_stmt|,
name|i
decl_stmt|;
comment|/* just in case lock the ring */
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|ring_obj
operator|==
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* it doesn't make sense to save anything if all fences are signaled */
if|if
condition|(
operator|!
name|radeon_fence_count_emitted
argument_list|(
name|rdev
argument_list|,
name|ring
operator|->
name|idx
argument_list|)
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* calculate the number of dw on the ring */
if|if
condition|(
name|ring
operator|->
name|rptr_save_reg
condition|)
name|ptr
operator|=
name|RREG32
argument_list|(
name|ring
operator|->
name|rptr_save_reg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rdev
operator|->
name|wb
operator|.
name|enabled
condition|)
name|ptr
operator|=
name|le32_to_cpu
argument_list|(
operator|*
name|ring
operator|->
name|next_rptr_cpu_addr
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* no way to read back the next rptr */
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|size
operator|=
name|ring
operator|->
name|wptr
operator|+
operator|(
name|ring
operator|->
name|ring_size
operator|/
literal|4
operator|)
expr_stmt|;
name|size
operator|-=
name|ptr
expr_stmt|;
name|size
operator|&=
name|ring
operator|->
name|ptr_mask
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* and then save the content of the ring */
operator|*
name|data
operator|=
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|data
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
operator|(
operator|*
name|data
operator|)
index|[
name|i
index|]
operator|=
name|ring
operator|->
name|ring
index|[
name|ptr
operator|++
index|]
expr_stmt|;
name|ptr
operator|&=
name|ring
operator|->
name|ptr_mask
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_ring_restore - append saved commands to the ring again  *  * @rdev: radeon_device pointer  * @ring: ring to append commands to  * @size: number of dwords we want to write  * @data: saved commands  *  * Allocates space on the ring and restore the previously saved commands.  */
end_comment

begin_function
name|int
name|radeon_ring_restore
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|,
name|unsigned
name|size
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|size
operator|||
operator|!
name|data
condition|)
return|return
literal|0
return|;
comment|/* restore the saved ring content */
name|r
operator|=
name|radeon_ring_lock
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|radeon_ring_write
argument_list|(
name|ring
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|radeon_ring_unlock_commit
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_ring_init - init driver ring struct.  *  * @rdev: radeon_device pointer  * @ring: radeon_ring structure holding ring information  * @ring_size: size of the ring  * @rptr_offs: offset of the rptr writeback location in the WB buffer  * @rptr_reg: MMIO offset of the rptr register  * @wptr_reg: MMIO offset of the wptr register  * @ptr_reg_shift: bit offset of the rptr/wptr values  * @ptr_reg_mask: bit mask of the rptr/wptr values  * @nop: nop packet for this ring  *  * Initialize the driver information for the selected ring (all asics).  * Returns 0 on success, error on failure.  */
end_comment

begin_function
name|int
name|radeon_ring_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|,
name|unsigned
name|ring_size
parameter_list|,
name|unsigned
name|rptr_offs
parameter_list|,
name|unsigned
name|rptr_reg
parameter_list|,
name|unsigned
name|wptr_reg
parameter_list|,
name|u32
name|ptr_reg_shift
parameter_list|,
name|u32
name|ptr_reg_mask
parameter_list|,
name|u32
name|nop
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|void
modifier|*
name|ring_ptr
decl_stmt|;
name|ring
operator|->
name|ring_size
operator|=
name|ring_size
expr_stmt|;
name|ring
operator|->
name|rptr_offs
operator|=
name|rptr_offs
expr_stmt|;
name|ring
operator|->
name|rptr_reg
operator|=
name|rptr_reg
expr_stmt|;
name|ring
operator|->
name|wptr_reg
operator|=
name|wptr_reg
expr_stmt|;
name|ring
operator|->
name|ptr_reg_shift
operator|=
name|ptr_reg_shift
expr_stmt|;
name|ring
operator|->
name|ptr_reg_mask
operator|=
name|ptr_reg_mask
expr_stmt|;
name|ring
operator|->
name|nop
operator|=
name|nop
expr_stmt|;
comment|/* Allocate ring buffer */
if|if
condition|(
name|ring
operator|->
name|ring_obj
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|radeon_bo_create
argument_list|(
name|rdev
argument_list|,
name|ring
operator|->
name|ring_size
argument_list|,
name|PAGE_SIZE
argument_list|,
name|true
argument_list|,
name|RADEON_GEM_DOMAIN_GTT
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|ring_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"(%d) ring create failed\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|r
operator|=
name|radeon_bo_reserve
argument_list|(
name|ring
operator|->
name|ring_obj
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|radeon_bo_unref
argument_list|(
operator|&
name|ring
operator|->
name|ring_obj
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|r
operator|=
name|radeon_bo_pin
argument_list|(
name|ring
operator|->
name|ring_obj
argument_list|,
name|RADEON_GEM_DOMAIN_GTT
argument_list|,
operator|&
name|ring
operator|->
name|gpu_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|radeon_bo_unreserve
argument_list|(
name|ring
operator|->
name|ring_obj
argument_list|)
expr_stmt|;
name|radeon_bo_unref
argument_list|(
operator|&
name|ring
operator|->
name|ring_obj
argument_list|)
expr_stmt|;
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"(%d) ring pin failed\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|ring_ptr
operator|=
operator|&
name|ring
operator|->
name|ring
expr_stmt|;
name|r
operator|=
name|radeon_bo_kmap
argument_list|(
name|ring
operator|->
name|ring_obj
argument_list|,
name|ring_ptr
argument_list|)
expr_stmt|;
name|radeon_bo_unreserve
argument_list|(
name|ring
operator|->
name|ring_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"(%d) ring map failed\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|radeon_bo_unref
argument_list|(
operator|&
name|ring
operator|->
name|ring_obj
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
name|ring
operator|->
name|ptr_mask
operator|=
operator|(
name|ring
operator|->
name|ring_size
operator|/
literal|4
operator|)
operator|-
literal|1
expr_stmt|;
name|ring
operator|->
name|ring_free_dw
operator|=
name|ring
operator|->
name|ring_size
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|wb
operator|.
name|enabled
condition|)
block|{
name|u32
name|index
init|=
name|RADEON_WB_RING0_NEXT_RPTR
operator|+
operator|(
name|ring
operator|->
name|idx
operator|*
literal|4
operator|)
decl_stmt|;
name|ring
operator|->
name|next_rptr_gpu_addr
operator|=
name|rdev
operator|->
name|wb
operator|.
name|gpu_addr
operator|+
name|index
expr_stmt|;
name|ring
operator|->
name|next_rptr_cpu_addr
operator|=
operator|&
name|rdev
operator|->
name|wb
operator|.
name|wb
index|[
name|index
operator|/
literal|4
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
if|if
condition|(
name|radeon_debugfs_ring_init
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed to register debugfs file for rings !\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DUMBBELL_WIP */
name|radeon_ring_lockup_update
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_ring_fini - tear down the driver ring struct.  *  * @rdev: radeon_device pointer  * @ring: radeon_ring structure holding ring information  *  * Tear down the driver information for the selected ring (all asics).  */
end_comment

begin_function
name|void
name|radeon_ring_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|radeon_bo
modifier|*
name|ring_obj
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
name|ring_obj
operator|=
name|ring
operator|->
name|ring_obj
expr_stmt|;
name|ring
operator|->
name|ready
operator|=
name|false
expr_stmt|;
name|ring
operator|->
name|ring
operator|=
name|NULL
expr_stmt|;
name|ring
operator|->
name|ring_obj
operator|=
name|NULL
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring_obj
condition|)
block|{
name|r
operator|=
name|radeon_bo_reserve
argument_list|(
name|ring_obj
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|r
operator|==
literal|0
argument_list|)
condition|)
block|{
name|radeon_bo_kunmap
argument_list|(
name|ring_obj
argument_list|)
expr_stmt|;
name|radeon_bo_unpin
argument_list|(
name|ring_obj
argument_list|)
expr_stmt|;
name|radeon_bo_unreserve
argument_list|(
name|ring_obj
argument_list|)
expr_stmt|;
block|}
name|radeon_bo_unref
argument_list|(
operator|&
name|ring_obj
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Debugfs info  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DEBUG_FS
argument_list|)
end_if

begin_function
specifier|static
name|int
name|radeon_debugfs_ring_info
parameter_list|(
name|struct
name|seq_file
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|drm_info_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|drm_info_node
operator|*
operator|)
name|m
operator|->
name|private
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|node
operator|->
name|minor
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ridx
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|node
operator|->
name|info_ent
operator|->
name|data
decl_stmt|;
name|struct
name|radeon_ring
modifier|*
name|ring
init|=
operator|&
name|rdev
operator|->
name|ring
index|[
name|ridx
index|]
decl_stmt|;
name|unsigned
name|count
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u32
name|tmp
decl_stmt|;
name|radeon_ring_free_size
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
name|ring
operator|->
name|ring_size
operator|/
literal|4
operator|)
operator|-
name|ring
operator|->
name|ring_free_dw
expr_stmt|;
name|tmp
operator|=
name|RREG32
argument_list|(
name|ring
operator|->
name|wptr_reg
argument_list|)
operator|>>
name|ring
operator|->
name|ptr_reg_shift
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"wptr(0x%04x): 0x%08x [%5d]\n"
argument_list|,
name|ring
operator|->
name|wptr_reg
argument_list|,
name|tmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|RREG32
argument_list|(
name|ring
operator|->
name|rptr_reg
argument_list|)
operator|>>
name|ring
operator|->
name|ptr_reg_shift
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"rptr(0x%04x): 0x%08x [%5d]\n"
argument_list|,
name|ring
operator|->
name|rptr_reg
argument_list|,
name|tmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|rptr_save_reg
condition|)
block|{
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"rptr next(0x%04x): 0x%08x\n"
argument_list|,
name|ring
operator|->
name|rptr_save_reg
argument_list|,
name|RREG32
argument_list|(
name|ring
operator|->
name|rptr_save_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"driver's copy of the wptr: 0x%08x [%5d]\n"
argument_list|,
name|ring
operator|->
name|wptr
argument_list|,
name|ring
operator|->
name|wptr
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"driver's copy of the rptr: 0x%08x [%5d]\n"
argument_list|,
name|ring
operator|->
name|rptr
argument_list|,
name|ring
operator|->
name|rptr
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"last semaphore signal addr : 0x%016llx\n"
argument_list|,
name|ring
operator|->
name|last_semaphore_signal_addr
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"last semaphore wait addr   : 0x%016llx\n"
argument_list|,
name|ring
operator|->
name|last_semaphore_wait_addr
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"%u free dwords in ring\n"
argument_list|,
name|ring
operator|->
name|ring_free_dw
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"%u dwords in ring\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* print 8 dw before current rptr as often it's the last executed 	 * packet that is the root issue 	 */
name|i
operator|=
operator|(
name|ring
operator|->
name|rptr
operator|+
name|ring
operator|->
name|ptr_mask
operator|+
literal|1
operator|-
literal|32
operator|)
operator|&
name|ring
operator|->
name|ptr_mask
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
operator|(
name|count
operator|+
literal|32
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"r[%5d]=0x%08x\n"
argument_list|,
name|i
argument_list|,
name|ring
operator|->
name|ring
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|ring
operator|->
name|ptr_mask
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|radeon_ring_type_gfx_index
init|=
name|RADEON_RING_TYPE_GFX_INDEX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cayman_ring_type_cp1_index
init|=
name|CAYMAN_RING_TYPE_CP1_INDEX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cayman_ring_type_cp2_index
init|=
name|CAYMAN_RING_TYPE_CP2_INDEX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|radeon_ring_type_dma1_index
init|=
name|R600_RING_TYPE_DMA_INDEX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|radeon_ring_type_dma2_index
init|=
name|CAYMAN_RING_TYPE_DMA1_INDEX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|drm_info_list
name|radeon_debugfs_ring_info_list
index|[]
init|=
block|{
block|{
literal|"radeon_ring_gfx"
block|,
name|radeon_debugfs_ring_info
block|,
literal|0
block|,
operator|&
name|radeon_ring_type_gfx_index
block|}
block|,
block|{
literal|"radeon_ring_cp1"
block|,
name|radeon_debugfs_ring_info
block|,
literal|0
block|,
operator|&
name|cayman_ring_type_cp1_index
block|}
block|,
block|{
literal|"radeon_ring_cp2"
block|,
name|radeon_debugfs_ring_info
block|,
literal|0
block|,
operator|&
name|cayman_ring_type_cp2_index
block|}
block|,
block|{
literal|"radeon_ring_dma1"
block|,
name|radeon_debugfs_ring_info
block|,
literal|0
block|,
operator|&
name|radeon_ring_type_dma1_index
block|}
block|,
block|{
literal|"radeon_ring_dma2"
block|,
name|radeon_debugfs_ring_info
block|,
literal|0
block|,
operator|&
name|radeon_ring_type_dma2_index
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|radeon_debugfs_sa_info
parameter_list|(
name|struct
name|seq_file
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|drm_info_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|drm_info_node
operator|*
operator|)
name|m
operator|->
name|private
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|node
operator|->
name|minor
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|radeon_sa_bo_dump_debug_info
argument_list|(
operator|&
name|rdev
operator|->
name|ring_tmp_bo
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|drm_info_list
name|radeon_debugfs_sa_list
index|[]
init|=
block|{
block|{
literal|"radeon_sa_info"
block|,
operator|&
name|radeon_debugfs_sa_info
block|,
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
end_ifdef

begin_function
specifier|static
name|int
name|radeon_debugfs_ring_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_ring
modifier|*
name|ring
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DEBUG_FS
argument_list|)
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|radeon_debugfs_ring_info_list
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|drm_info_list
modifier|*
name|info
init|=
operator|&
name|radeon_debugfs_ring_info_list
index|[
name|i
index|]
decl_stmt|;
name|int
name|ridx
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|radeon_debugfs_ring_info_list
index|[
name|i
index|]
operator|.
name|data
decl_stmt|;
name|unsigned
name|r
decl_stmt|;
if|if
condition|(
operator|&
name|rdev
operator|->
name|ring
index|[
name|ridx
index|]
operator|!=
name|ring
condition|)
continue|continue;
name|r
operator|=
name|radeon_debugfs_add_files
argument_list|(
name|rdev
argument_list|,
name|info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_debugfs_sa_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DEBUG_FS
argument_list|)
return|return
name|radeon_debugfs_add_files
argument_list|(
name|rdev
argument_list|,
name|radeon_debugfs_sa_list
argument_list|,
literal|1
argument_list|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DUMBBELL_WIP */
end_comment

end_unit

