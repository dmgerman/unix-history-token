begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2009 Jerome Glisse.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the  * "Software"), to deal in the Software without restriction, including  * without limitation the rights to use, copy, modify, merge, publish,  * distribute, sub license, and/or sell copies of the Software, and to  * permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE  * USE OR OTHER DEALINGS IN THE SOFTWARE.  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  */
end_comment

begin_comment
comment|/*  * Authors:  *    Jerome Glisse<glisse@freedesktop.org>  *    Dave Airlie  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|"radeon_reg.h"
end_include

begin_include
include|#
directive|include
file|"radeon.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DUMBBELL_WIP
end_ifdef

begin_include
include|#
directive|include
file|"radeon_trace.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DUMBBELL_WIP */
end_comment

begin_comment
comment|/*  * Fences  * Fences mark an event in the GPUs pipeline and are used  * for GPU/CPU synchronization.  When the fence is written,  * it is expected that all buffers associated with that fence  * are no longer in use by the associated ring on the GPU and  * that the the relevant GPU caches have been flushed.  Whether  * we use a scratch register or memory location depends on the asic  * and whether writeback is enabled.  */
end_comment

begin_comment
comment|/**  * radeon_fence_write - write a fence value  *  * @rdev: radeon_device pointer  * @seq: sequence number to write  * @ring: ring index the fence is associated with  *  * Writes a fence value to memory or a scratch register (all asics).  */
end_comment

begin_function
specifier|static
name|void
name|radeon_fence_write
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|u32
name|seq
parameter_list|,
name|int
name|ring
parameter_list|)
block|{
name|struct
name|radeon_fence_driver
modifier|*
name|drv
init|=
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
decl_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|rdev
operator|->
name|wb
operator|.
name|enabled
operator|||
operator|!
name|drv
operator|->
name|scratch_reg
argument_list|)
condition|)
block|{
operator|*
name|drv
operator|->
name|cpu_addr
operator|=
name|cpu_to_le32
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WREG32
argument_list|(
name|drv
operator|->
name|scratch_reg
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_fence_read - read a fence value  *  * @rdev: radeon_device pointer  * @ring: ring index the fence is associated with  *  * Reads a fence value from memory or a scratch register (all asics).  * Returns the value of the fence read from memory or register.  */
end_comment

begin_function
specifier|static
name|u32
name|radeon_fence_read
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|int
name|ring
parameter_list|)
block|{
name|struct
name|radeon_fence_driver
modifier|*
name|drv
init|=
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
decl_stmt|;
name|u32
name|seq
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|rdev
operator|->
name|wb
operator|.
name|enabled
operator|||
operator|!
name|drv
operator|->
name|scratch_reg
argument_list|)
condition|)
block|{
name|seq
operator|=
name|le32_to_cpu
argument_list|(
operator|*
name|drv
operator|->
name|cpu_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seq
operator|=
name|RREG32
argument_list|(
name|drv
operator|->
name|scratch_reg
argument_list|)
expr_stmt|;
block|}
return|return
name|seq
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_emit - emit a fence on the requested ring  *  * @rdev: radeon_device pointer  * @fence: radeon fence object  * @ring: ring index the fence is associated with  *  * Emits a fence command on the requested ring (all asics).  * Returns 0 on success, -ENOMEM on failure.  */
end_comment

begin_function
name|int
name|radeon_fence_emit
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_fence
modifier|*
modifier|*
name|fence
parameter_list|,
name|int
name|ring
parameter_list|)
block|{
comment|/* we are protected by the ring emission mutex */
operator|*
name|fence
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|radeon_fence
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|fence
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
name|ENOMEM
return|;
block|}
name|refcount_init
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|fence
operator|)
operator|->
name|kref
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|fence
operator|)
operator|->
name|rdev
operator|=
name|rdev
expr_stmt|;
operator|(
operator|*
name|fence
operator|)
operator|->
name|seq
operator|=
operator|++
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|sync_seq
index|[
name|ring
index|]
expr_stmt|;
operator|(
operator|*
name|fence
operator|)
operator|->
name|ring
operator|=
name|ring
expr_stmt|;
name|radeon_fence_ring_emit
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|,
operator|*
name|fence
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"radeon fence: emit (ring=%d, seq=%d)"
argument_list|,
name|ring
argument_list|,
operator|(
operator|*
name|fence
operator|)
operator|->
name|seq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_process - process a fence  *  * @rdev: radeon_device pointer  * @ring: ring index the fence is associated with  *  * Checks the current fence value and wakes the fence queue  * if the sequence number has increased (all asics).  */
end_comment

begin_function
name|void
name|radeon_fence_process
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|int
name|ring
parameter_list|)
block|{
name|uint64_t
name|seq
decl_stmt|,
name|last_seq
decl_stmt|,
name|last_emitted
decl_stmt|;
name|unsigned
name|count_loop
init|=
literal|0
decl_stmt|;
name|bool
name|wake
init|=
name|false
decl_stmt|;
comment|/* Note there is a scenario here for an infinite loop but it's 	 * very unlikely to happen. For it to happen, the current polling 	 * process need to be interrupted by another process and another 	 * process needs to update the last_seq btw the atomic read and 	 * xchg of the current process. 	 * 	 * More over for this to go in infinite loop there need to be 	 * continuously new fence signaled ie radeon_fence_read needs 	 * to return a different value each time for both the currently 	 * polling process and the other process that xchg the last_seq 	 * btw atomic read and xchg of the current process. And the 	 * value the other process set as last seq must be higher than 	 * the seq value we just read. Which means that current process 	 * need to be interrupted after radeon_fence_read and before 	 * atomic xchg. 	 * 	 * To be even more safe we count the number of time we loop and 	 * we bail after 10 loop just accepting the fact that we might 	 * have temporarly set the last_seq not to the true real last 	 * seq but to an older one. 	 */
name|last_seq
operator|=
name|atomic_load_acq_64
argument_list|(
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_seq
argument_list|)
expr_stmt|;
do|do
block|{
name|last_emitted
operator|=
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|sync_seq
index|[
name|ring
index|]
expr_stmt|;
name|seq
operator|=
name|radeon_fence_read
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|seq
operator||=
name|last_seq
operator|&
literal|0xffffffff00000000LL
expr_stmt|;
if|if
condition|(
name|seq
operator|<
name|last_seq
condition|)
block|{
name|seq
operator|&=
literal|0xffffffff
expr_stmt|;
name|seq
operator||=
name|last_emitted
operator|&
literal|0xffffffff00000000LL
expr_stmt|;
block|}
if|if
condition|(
name|seq
operator|<=
name|last_seq
operator|||
name|seq
operator|>
name|last_emitted
condition|)
block|{
break|break;
block|}
comment|/* If we loop over we don't want to return without 		 * checking if a fence is signaled as it means that the 		 * seq we just read is different from the previous on. 		 */
name|wake
operator|=
name|true
expr_stmt|;
name|last_seq
operator|=
name|seq
expr_stmt|;
if|if
condition|(
operator|(
name|count_loop
operator|++
operator|)
operator|>
literal|10
condition|)
block|{
comment|/* We looped over too many time leave with the 			 * fact that we might have set an older fence 			 * seq then the current real last seq as signaled 			 * by the hw. 			 */
break|break;
block|}
block|}
do|while
condition|(
name|atomic64_xchg
argument_list|(
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_seq
argument_list|,
name|seq
argument_list|)
operator|>
name|seq
condition|)
do|;
if|if
condition|(
name|wake
condition|)
block|{
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_activity
operator|=
name|jiffies
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|rdev
operator|->
name|fence_queue
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_fence_destroy - destroy a fence  *  * @kref: fence kref  *  * Frees the fence object (all asics).  */
end_comment

begin_function
specifier|static
name|void
name|radeon_fence_destroy
parameter_list|(
name|struct
name|radeon_fence
modifier|*
name|fence
parameter_list|)
block|{
name|free
argument_list|(
name|fence
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_seq_signaled - check if a fence sequeuce number has signaled  *  * @rdev: radeon device pointer  * @seq: sequence number  * @ring: ring index the fence is associated with  *  * Check if the last singled fence sequnce number is>= the requested  * sequence number (all asics).  * Returns true if the fence has signaled (current fence value  * is>= requested value) or false if it has not (current fence  * value is< the requested value.  Helper function for  * radeon_fence_signaled().  */
end_comment

begin_function
specifier|static
name|bool
name|radeon_fence_seq_signaled
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|u64
name|seq
parameter_list|,
name|unsigned
name|ring
parameter_list|)
block|{
if|if
condition|(
name|atomic_load_acq_64
argument_list|(
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_seq
argument_list|)
operator|>=
name|seq
condition|)
block|{
return|return
name|true
return|;
block|}
comment|/* poll new last sequence at least once */
name|radeon_fence_process
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_64
argument_list|(
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_seq
argument_list|)
operator|>=
name|seq
condition|)
block|{
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_signaled - check if a fence has signaled  *  * @fence: radeon fence object  *  * Check if the requested fence has signaled (all asics).  * Returns true if the fence has signaled or false if it has not.  */
end_comment

begin_function
name|bool
name|radeon_fence_signaled
parameter_list|(
name|struct
name|radeon_fence
modifier|*
name|fence
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fence
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|fence
operator|->
name|seq
operator|==
name|RADEON_FENCE_SIGNALED_SEQ
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|radeon_fence_seq_signaled
argument_list|(
name|fence
operator|->
name|rdev
argument_list|,
name|fence
operator|->
name|seq
argument_list|,
name|fence
operator|->
name|ring
argument_list|)
condition|)
block|{
name|fence
operator|->
name|seq
operator|=
name|RADEON_FENCE_SIGNALED_SEQ
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_wait_seq - wait for a specific sequence number  *  * @rdev: radeon device pointer  * @target_seq: sequence number we want to wait for  * @ring: ring index the fence is associated with  * @intr: use interruptable sleep  * @lock_ring: whether the ring should be locked or not  *  * Wait for the requested sequence number to be written (all asics).  * @intr selects whether to use interruptable (true) or non-interruptable  * (false) sleep when waiting for the sequence number.  Helper function  * for radeon_fence_wait(), et al.  * Returns 0 if the sequence number has passed, error for all other cases.  * -EDEADLK is returned when a GPU lockup has been detected and the ring is  * marked as not ready so no further jobs get scheduled until a successful  * reset.  */
end_comment

begin_function
specifier|static
name|int
name|radeon_fence_wait_seq
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|u64
name|target_seq
parameter_list|,
name|unsigned
name|ring
parameter_list|,
name|bool
name|intr
parameter_list|,
name|bool
name|lock_ring
parameter_list|)
block|{
name|unsigned
name|long
name|timeout
decl_stmt|,
name|last_activity
decl_stmt|;
name|uint64_t
name|seq
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bool
name|signaled
decl_stmt|,
name|fence_queue_locked
decl_stmt|;
name|int
name|r
decl_stmt|;
while|while
condition|(
name|target_seq
operator|>
name|atomic_load_acq_64
argument_list|(
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_seq
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rdev
operator|->
name|ring
index|[
name|ring
index|]
operator|.
name|ready
condition|)
block|{
return|return
operator|-
name|EBUSY
return|;
block|}
name|timeout
operator|=
name|jiffies
operator|-
name|RADEON_FENCE_JIFFIES_TIMEOUT
expr_stmt|;
if|if
condition|(
name|time_after
argument_list|(
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_activity
argument_list|,
name|timeout
argument_list|)
condition|)
block|{
comment|/* the normal case, timeout is somewhere before last_activity */
name|timeout
operator|=
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_activity
operator|-
name|timeout
expr_stmt|;
block|}
else|else
block|{
comment|/* either jiffies wrapped around, or no fence was signaled in the last 500ms 			 * anyway we will just wait for the minimum amount and then check for a lockup 			 */
name|timeout
operator|=
literal|1
expr_stmt|;
block|}
name|seq
operator|=
name|atomic_load_acq_64
argument_list|(
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_seq
argument_list|)
expr_stmt|;
comment|/* Save current last activity valuee, used to check for GPU lockups */
name|last_activity
operator|=
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_activity
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"radeon fence: wait begin (ring=%d, seq=%d)"
argument_list|,
name|ring
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|radeon_irq_kms_sw_irq_get
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|fence_queue_locked
operator|=
name|false
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|signaled
operator|=
name|radeon_fence_seq_signaled
argument_list|(
name|rdev
argument_list|,
name|target_seq
argument_list|,
name|ring
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|fence_queue_locked
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|rdev
operator|->
name|fence_queue_mtx
argument_list|)
expr_stmt|;
name|fence_queue_locked
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|intr
condition|)
block|{
name|r
operator|=
name|cv_timedwait_sig
argument_list|(
operator|&
name|rdev
operator|->
name|fence_queue
argument_list|,
operator|&
name|rdev
operator|->
name|fence_queue_mtx
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|cv_timedwait
argument_list|(
operator|&
name|rdev
operator|->
name|fence_queue
argument_list|,
operator|&
name|rdev
operator|->
name|fence_queue_mtx
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|EINTR
condition|)
name|r
operator|=
name|ERESTARTSYS
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|signaled
operator|=
name|radeon_fence_seq_signaled
argument_list|(
name|rdev
argument_list|,
name|target_seq
argument_list|,
name|ring
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|fence_queue_locked
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rdev
operator|->
name|fence_queue_mtx
argument_list|)
expr_stmt|;
block|}
name|radeon_irq_kms_sw_irq_put
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
operator|==
name|ERESTARTSYS
argument_list|)
condition|)
block|{
return|return
operator|-
name|r
return|;
block|}
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"radeon fence: wait end (ring=%d, seq=%d)"
argument_list|,
name|ring
argument_list|,
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|signaled
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|__FreeBSD__
comment|/* we were interrupted for some reason and fence 			 * isn't signaled yet, resume waiting */
if|if
condition|(
name|r
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
comment|/* check if sequence value has changed since last_activity */
if|if
condition|(
name|seq
operator|!=
name|atomic_load_acq_64
argument_list|(
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_seq
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|lock_ring
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
block|}
comment|/* test if somebody else has already decided that this is a lockup */
if|if
condition|(
name|last_activity
operator|!=
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_activity
condition|)
block|{
if|if
condition|(
name|lock_ring
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|radeon_ring_is_lockup
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|,
operator|&
name|rdev
operator|->
name|ring
index|[
name|ring
index|]
argument_list|)
condition|)
block|{
comment|/* good news we believe it's a lockup */
name|dev_warn
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"GPU lockup (waiting for 0x%016jx last fence id 0x%016jx)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|target_seq
argument_list|,
operator|(
name|uintmax_t
operator|)
name|seq
argument_list|)
expr_stmt|;
comment|/* change last activity so nobody else think there is a lockup */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
name|rdev
operator|->
name|fence_drv
index|[
name|i
index|]
operator|.
name|last_activity
operator|=
name|jiffies
expr_stmt|;
block|}
comment|/* mark the ring as not ready any more */
name|rdev
operator|->
name|ring
index|[
name|ring
index|]
operator|.
name|ready
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|lock_ring
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
name|EDEADLK
return|;
block|}
if|if
condition|(
name|lock_ring
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_wait - wait for a fence to signal  *  * @fence: radeon fence object  * @intr: use interruptable sleep  *  * Wait for the requested fence to signal (all asics).  * @intr selects whether to use interruptable (true) or non-interruptable  * (false) sleep when waiting for the fence.  * Returns 0 if the fence has passed, error for all other cases.  */
end_comment

begin_function
name|int
name|radeon_fence_wait
parameter_list|(
name|struct
name|radeon_fence
modifier|*
name|fence
parameter_list|,
name|bool
name|intr
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|fence
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Querying an invalid fence : %p !\n"
argument_list|,
name|fence
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|r
operator|=
name|radeon_fence_wait_seq
argument_list|(
name|fence
operator|->
name|rdev
argument_list|,
name|fence
operator|->
name|seq
argument_list|,
name|fence
operator|->
name|ring
argument_list|,
name|intr
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
return|return
name|r
return|;
block|}
name|fence
operator|->
name|seq
operator|=
name|RADEON_FENCE_SIGNALED_SEQ
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|radeon_fence_any_seq_signaled
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|u64
modifier|*
name|seq
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|seq
index|[
name|i
index|]
operator|&&
name|radeon_fence_seq_signaled
argument_list|(
name|rdev
argument_list|,
name|seq
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_wait_any_seq - wait for a sequence number on any ring  *  * @rdev: radeon device pointer  * @target_seq: sequence number(s) we want to wait for  * @intr: use interruptable sleep  *  * Wait for the requested sequence number(s) to be written by any ring  * (all asics).  Sequnce number array is indexed by ring id.  * @intr selects whether to use interruptable (true) or non-interruptable  * (false) sleep when waiting for the sequence number.  Helper function  * for radeon_fence_wait_any(), et al.  * Returns 0 if the sequence number has passed, error for all other cases.  */
end_comment

begin_function
specifier|static
name|int
name|radeon_fence_wait_any_seq
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|u64
modifier|*
name|target_seq
parameter_list|,
name|bool
name|intr
parameter_list|)
block|{
name|unsigned
name|long
name|timeout
decl_stmt|,
name|last_activity
decl_stmt|,
name|tmp
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|ring
init|=
name|RADEON_NUM_RINGS
decl_stmt|;
name|bool
name|signaled
decl_stmt|,
name|fence_queue_locked
decl_stmt|;
name|int
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|last_activity
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|target_seq
index|[
name|i
index|]
condition|)
block|{
continue|continue;
block|}
comment|/* use the most recent one as indicator */
if|if
condition|(
name|time_after
argument_list|(
name|rdev
operator|->
name|fence_drv
index|[
name|i
index|]
operator|.
name|last_activity
argument_list|,
name|last_activity
argument_list|)
condition|)
block|{
name|last_activity
operator|=
name|rdev
operator|->
name|fence_drv
index|[
name|i
index|]
operator|.
name|last_activity
expr_stmt|;
block|}
comment|/* For lockup detection just pick the lowest ring we are 		 * actively waiting for 		 */
if|if
condition|(
name|i
operator|<
name|ring
condition|)
block|{
name|ring
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* nothing to wait for ? */
if|if
condition|(
name|ring
operator|==
name|RADEON_NUM_RINGS
condition|)
block|{
return|return
operator|-
name|ENOENT
return|;
block|}
while|while
condition|(
operator|!
name|radeon_fence_any_seq_signaled
argument_list|(
name|rdev
argument_list|,
name|target_seq
argument_list|)
condition|)
block|{
name|timeout
operator|=
name|jiffies
operator|-
name|RADEON_FENCE_JIFFIES_TIMEOUT
expr_stmt|;
if|if
condition|(
name|time_after
argument_list|(
name|last_activity
argument_list|,
name|timeout
argument_list|)
condition|)
block|{
comment|/* the normal case, timeout is somewhere before last_activity */
name|timeout
operator|=
name|last_activity
operator|-
name|timeout
expr_stmt|;
block|}
else|else
block|{
comment|/* either jiffies wrapped around, or no fence was signaled in the last 500ms 			 * anyway we will just wait for the minimum amount and then check for a lockup 			 */
name|timeout
operator|=
literal|1
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"radeon fence: wait begin (ring=%d, target_seq=%d)"
argument_list|,
name|ring
argument_list|,
name|target_seq
index|[
name|ring
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|target_seq
index|[
name|i
index|]
condition|)
block|{
name|radeon_irq_kms_sw_irq_get
argument_list|(
name|rdev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|fence_queue_locked
operator|=
name|false
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|signaled
operator|=
name|radeon_fence_any_seq_signaled
argument_list|(
name|rdev
argument_list|,
name|target_seq
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|fence_queue_locked
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|rdev
operator|->
name|fence_queue_mtx
argument_list|)
expr_stmt|;
name|fence_queue_locked
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|intr
condition|)
block|{
name|r
operator|=
name|cv_timedwait_sig
argument_list|(
operator|&
name|rdev
operator|->
name|fence_queue
argument_list|,
operator|&
name|rdev
operator|->
name|fence_queue_mtx
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|cv_timedwait
argument_list|(
operator|&
name|rdev
operator|->
name|fence_queue
argument_list|,
operator|&
name|rdev
operator|->
name|fence_queue_mtx
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|EINTR
condition|)
name|r
operator|=
name|ERESTARTSYS
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|signaled
operator|=
name|radeon_fence_any_seq_signaled
argument_list|(
name|rdev
argument_list|,
name|target_seq
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|fence_queue_locked
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rdev
operator|->
name|fence_queue_mtx
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|target_seq
index|[
name|i
index|]
condition|)
block|{
name|radeon_irq_kms_sw_irq_put
argument_list|(
name|rdev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|r
operator|==
name|ERESTARTSYS
argument_list|)
condition|)
block|{
return|return
operator|-
name|r
return|;
block|}
name|CTR2
argument_list|(
name|KTR_DRM
argument_list|,
literal|"radeon fence: wait end (ring=%d, target_seq=%d)"
argument_list|,
name|ring
argument_list|,
name|target_seq
index|[
name|ring
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|signaled
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|__FreeBSD__
comment|/* we were interrupted for some reason and fence 			 * isn't signaled yet, resume waiting */
if|if
condition|(
name|r
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmp
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|time_after
argument_list|(
name|rdev
operator|->
name|fence_drv
index|[
name|i
index|]
operator|.
name|last_activity
argument_list|,
name|tmp
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|rdev
operator|->
name|fence_drv
index|[
name|i
index|]
operator|.
name|last_activity
expr_stmt|;
block|}
block|}
comment|/* test if somebody else has already decided that this is a lockup */
if|if
condition|(
name|last_activity
operator|!=
name|tmp
condition|)
block|{
name|last_activity
operator|=
name|tmp
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|radeon_ring_is_lockup
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|,
operator|&
name|rdev
operator|->
name|ring
index|[
name|ring
index|]
argument_list|)
condition|)
block|{
comment|/* good news we believe it's a lockup */
name|dev_warn
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"GPU lockup (waiting for 0x%016jx)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|target_seq
index|[
name|ring
index|]
argument_list|)
expr_stmt|;
comment|/* change last activity so nobody else think there is a lockup */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
name|rdev
operator|->
name|fence_drv
index|[
name|i
index|]
operator|.
name|last_activity
operator|=
name|jiffies
expr_stmt|;
block|}
comment|/* mark the ring as not ready any more */
name|rdev
operator|->
name|ring
index|[
name|ring
index|]
operator|.
name|ready
operator|=
name|false
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
return|return
operator|-
name|EDEADLK
return|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_wait_any - wait for a fence to signal on any ring  *  * @rdev: radeon device pointer  * @fences: radeon fence object(s)  * @intr: use interruptable sleep  *  * Wait for any requested fence to signal (all asics).  Fence  * array is indexed by ring id.  @intr selects whether to use  * interruptable (true) or non-interruptable (false) sleep when  * waiting for the fences. Used by the suballocator.  * Returns 0 if any fence has passed, error for all other cases.  */
end_comment

begin_function
name|int
name|radeon_fence_wait_any
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|struct
name|radeon_fence
modifier|*
modifier|*
name|fences
parameter_list|,
name|bool
name|intr
parameter_list|)
block|{
name|uint64_t
name|seq
index|[
name|RADEON_NUM_RINGS
index|]
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
name|seq
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fences
index|[
name|i
index|]
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|fences
index|[
name|i
index|]
operator|->
name|seq
operator|==
name|RADEON_FENCE_SIGNALED_SEQ
condition|)
block|{
comment|/* something was allready signaled */
return|return
literal|0
return|;
block|}
name|seq
index|[
name|i
index|]
operator|=
name|fences
index|[
name|i
index|]
operator|->
name|seq
expr_stmt|;
block|}
name|r
operator|=
name|radeon_fence_wait_any_seq
argument_list|(
name|rdev
argument_list|,
name|seq
argument_list|,
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
return|return
name|r
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_wait_next_locked - wait for the next fence to signal  *  * @rdev: radeon device pointer  * @ring: ring index the fence is associated with  *  * Wait for the next fence on the requested ring to signal (all asics).  * Returns 0 if the next fence has passed, error for all other cases.  * Caller must hold ring lock.  */
end_comment

begin_function
name|int
name|radeon_fence_wait_next_locked
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|int
name|ring
parameter_list|)
block|{
name|uint64_t
name|seq
decl_stmt|;
name|seq
operator|=
name|atomic_load_acq_64
argument_list|(
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_seq
argument_list|)
operator|+
literal|1ULL
expr_stmt|;
if|if
condition|(
name|seq
operator|>=
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|sync_seq
index|[
name|ring
index|]
condition|)
block|{
comment|/* nothing to wait for, last_seq is 		   already the last emited fence */
return|return
operator|-
name|ENOENT
return|;
block|}
return|return
name|radeon_fence_wait_seq
argument_list|(
name|rdev
argument_list|,
name|seq
argument_list|,
name|ring
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_wait_empty_locked - wait for all fences to signal  *  * @rdev: radeon device pointer  * @ring: ring index the fence is associated with  *  * Wait for all fences on the requested ring to signal (all asics).  * Returns 0 if the fences have passed, error for all other cases.  * Caller must hold ring lock.  */
end_comment

begin_function
name|int
name|radeon_fence_wait_empty_locked
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|int
name|ring
parameter_list|)
block|{
name|uint64_t
name|seq
init|=
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|sync_seq
index|[
name|ring
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|radeon_fence_wait_seq
argument_list|(
name|rdev
argument_list|,
name|seq
argument_list|,
name|ring
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
if|if
condition|(
name|r
operator|==
operator|-
name|EDEADLK
condition|)
block|{
return|return
operator|-
name|EDEADLK
return|;
block|}
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"error waiting for ring[%d] to become idle (%d)\n"
argument_list|,
name|ring
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_ref - take a ref on a fence  *  * @fence: radeon fence object  *  * Take a reference on a fence (all asics).  * Returns the fence.  */
end_comment

begin_function
name|struct
name|radeon_fence
modifier|*
name|radeon_fence_ref
parameter_list|(
name|struct
name|radeon_fence
modifier|*
name|fence
parameter_list|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|fence
operator|->
name|kref
argument_list|)
expr_stmt|;
return|return
name|fence
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_unref - remove a ref on a fence  *  * @fence: radeon fence object  *  * Remove a reference on a fence (all asics).  */
end_comment

begin_function
name|void
name|radeon_fence_unref
parameter_list|(
name|struct
name|radeon_fence
modifier|*
modifier|*
name|fence
parameter_list|)
block|{
name|struct
name|radeon_fence
modifier|*
name|tmp
init|=
operator|*
name|fence
decl_stmt|;
operator|*
name|fence
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|tmp
operator|->
name|kref
argument_list|)
condition|)
block|{
name|radeon_fence_destroy
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_fence_count_emitted - get the count of emitted fences  *  * @rdev: radeon device pointer  * @ring: ring index the fence is associated with  *  * Get the number of fences emitted on the requested ring (all asics).  * Returns the number of emitted fences on the ring.  Used by the  * dynpm code to ring track activity.  */
end_comment

begin_function
name|unsigned
name|radeon_fence_count_emitted
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|int
name|ring
parameter_list|)
block|{
name|uint64_t
name|emitted
decl_stmt|;
comment|/* We are not protected by ring lock when reading the last sequence 	 * but it's ok to report slightly wrong fence count here. 	 */
name|radeon_fence_process
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|emitted
operator|=
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|sync_seq
index|[
name|ring
index|]
operator|-
name|atomic_load_acq_64
argument_list|(
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_seq
argument_list|)
expr_stmt|;
comment|/* to avoid 32bits warp around */
if|if
condition|(
name|emitted
operator|>
literal|0x10000000
condition|)
block|{
name|emitted
operator|=
literal|0x10000000
expr_stmt|;
block|}
return|return
operator|(
name|unsigned
operator|)
name|emitted
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_need_sync - do we need a semaphore  *  * @fence: radeon fence object  * @dst_ring: which ring to check against  *  * Check if the fence needs to be synced against another ring  * (all asics).  If so, we need to emit a semaphore.  * Returns true if we need to sync with another ring, false if  * not.  */
end_comment

begin_function
name|bool
name|radeon_fence_need_sync
parameter_list|(
name|struct
name|radeon_fence
modifier|*
name|fence
parameter_list|,
name|int
name|dst_ring
parameter_list|)
block|{
name|struct
name|radeon_fence_driver
modifier|*
name|fdrv
decl_stmt|;
if|if
condition|(
operator|!
name|fence
condition|)
block|{
return|return
name|false
return|;
block|}
if|if
condition|(
name|fence
operator|->
name|ring
operator|==
name|dst_ring
condition|)
block|{
return|return
name|false
return|;
block|}
comment|/* we are protected by the ring mutex */
name|fdrv
operator|=
operator|&
name|fence
operator|->
name|rdev
operator|->
name|fence_drv
index|[
name|dst_ring
index|]
expr_stmt|;
if|if
condition|(
name|fence
operator|->
name|seq
operator|<=
name|fdrv
operator|->
name|sync_seq
index|[
name|fence
operator|->
name|ring
index|]
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_note_sync - record the sync point  *  * @fence: radeon fence object  * @dst_ring: which ring to check against  *  * Note the sequence number at which point the fence will  * be synced with the requested ring (all asics).  */
end_comment

begin_function
name|void
name|radeon_fence_note_sync
parameter_list|(
name|struct
name|radeon_fence
modifier|*
name|fence
parameter_list|,
name|int
name|dst_ring
parameter_list|)
block|{
name|struct
name|radeon_fence_driver
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fence
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|fence
operator|->
name|ring
operator|==
name|dst_ring
condition|)
block|{
return|return;
block|}
comment|/* we are protected by the ring mutex */
name|src
operator|=
operator|&
name|fence
operator|->
name|rdev
operator|->
name|fence_drv
index|[
name|fence
operator|->
name|ring
index|]
expr_stmt|;
name|dst
operator|=
operator|&
name|fence
operator|->
name|rdev
operator|->
name|fence_drv
index|[
name|dst_ring
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
name|dst_ring
condition|)
block|{
continue|continue;
block|}
name|dst
operator|->
name|sync_seq
index|[
name|i
index|]
operator|=
name|max
argument_list|(
name|dst
operator|->
name|sync_seq
index|[
name|i
index|]
argument_list|,
name|src
operator|->
name|sync_seq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_fence_driver_start_ring - make the fence driver  * ready for use on the requested ring.  *  * @rdev: radeon device pointer  * @ring: ring index to start the fence driver on  *  * Make the fence driver ready for processing (all asics).  * Not all asics have all rings, so each asic will only  * start the fence driver on the rings it has.  * Returns 0 for success, errors for failure.  */
end_comment

begin_function
name|int
name|radeon_fence_driver_start_ring
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|int
name|ring
parameter_list|)
block|{
name|uint64_t
name|index
decl_stmt|;
name|int
name|r
decl_stmt|;
name|radeon_scratch_free
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|scratch_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|wb
operator|.
name|use_event
operator|||
operator|!
name|radeon_ring_supports_scratch_reg
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|ring
index|[
name|ring
index|]
argument_list|)
condition|)
block|{
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|scratch_reg
operator|=
literal|0
expr_stmt|;
name|index
operator|=
name|R600_WB_EVENT_OFFSET
operator|+
name|ring
operator|*
literal|4
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|radeon_scratch_get
argument_list|(
name|rdev
argument_list|,
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|scratch_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"fence failed to get scratch register\n"
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|index
operator|=
name|RADEON_WB_SCRATCH_OFFSET
operator|+
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|scratch_reg
operator|-
name|rdev
operator|->
name|scratch
operator|.
name|reg_base
expr_stmt|;
block|}
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|cpu_addr
operator|=
operator|&
name|rdev
operator|->
name|wb
operator|.
name|wb
index|[
name|index
operator|/
literal|4
index|]
expr_stmt|;
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|gpu_addr
operator|=
name|rdev
operator|->
name|wb
operator|.
name|gpu_addr
operator|+
name|index
expr_stmt|;
name|radeon_fence_write
argument_list|(
name|rdev
argument_list|,
name|atomic_load_acq_64
argument_list|(
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_seq
argument_list|)
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|initialized
operator|=
name|true
expr_stmt|;
name|dev_info
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"fence driver on ring %d use gpu addr 0x%016jx and cpu addr 0x%p\n"
argument_list|,
name|ring
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|gpu_addr
argument_list|,
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|cpu_addr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_driver_init_ring - init the fence driver  * for the requested ring.  *  * @rdev: radeon device pointer  * @ring: ring index to start the fence driver on  *  * Init the fence driver for the requested ring (all asics).  * Helper function for radeon_fence_driver_init().  */
end_comment

begin_function
specifier|static
name|void
name|radeon_fence_driver_init_ring
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|int
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|scratch_reg
operator|=
operator|-
literal|1
expr_stmt|;
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|cpu_addr
operator|=
name|NULL
expr_stmt|;
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|gpu_addr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|sync_seq
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|atomic_store_rel_64
argument_list|(
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_seq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|last_activity
operator|=
name|jiffies
expr_stmt|;
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|initialized
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_driver_init - init the fence driver  * for all possible rings.  *  * @rdev: radeon device pointer  *  * Init the fence driver for all possible rings (all asics).  * Not all asics have all rings, so each asic will only  * start the fence driver on the rings it has using  * radeon_fence_driver_start_ring().  * Returns 0 for success.  */
end_comment

begin_function
name|int
name|radeon_fence_driver_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|ring
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rdev
operator|->
name|fence_queue_mtx
argument_list|,
literal|"drm__radeon_device__fence_queue_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|rdev
operator|->
name|fence_queue
argument_list|,
literal|"drm__radeon_device__fence_queue"
argument_list|)
expr_stmt|;
for|for
control|(
name|ring
operator|=
literal|0
init|;
name|ring
operator|<
name|RADEON_NUM_RINGS
condition|;
name|ring
operator|++
control|)
block|{
name|radeon_fence_driver_init_ring
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|radeon_debugfs_fence_init
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"fence debugfs file creation failed\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_driver_fini - tear down the fence driver  * for all possible rings.  *  * @rdev: radeon device pointer  *  * Tear down the fence driver for all possible rings (all asics).  */
end_comment

begin_function
name|void
name|radeon_fence_driver_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|ring
decl_stmt|,
name|r
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|ring
operator|=
literal|0
init|;
name|ring
operator|<
name|RADEON_NUM_RINGS
condition|;
name|ring
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|initialized
condition|)
continue|continue;
name|r
operator|=
name|radeon_fence_wait_empty_locked
argument_list|(
name|rdev
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
comment|/* no need to trigger GPU reset as we are unloading */
name|radeon_fence_driver_force_completion
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
block|}
name|cv_broadcast
argument_list|(
operator|&
name|rdev
operator|->
name|fence_queue
argument_list|)
expr_stmt|;
name|radeon_scratch_free
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|scratch_reg
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|initialized
operator|=
name|false
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|rdev
operator|->
name|fence_queue
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|rdev
operator|->
name|ring_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * radeon_fence_driver_force_completion - force all fence waiter to complete  *  * @rdev: radeon device pointer  *  * In case of GPU reset failure make sure no process keep waiting on fence  * that will never complete.  */
end_comment

begin_function
name|void
name|radeon_fence_driver_force_completion
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|ring
decl_stmt|;
for|for
control|(
name|ring
operator|=
literal|0
init|;
name|ring
operator|<
name|RADEON_NUM_RINGS
condition|;
name|ring
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|initialized
condition|)
continue|continue;
name|radeon_fence_write
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|fence_drv
index|[
name|ring
index|]
operator|.
name|sync_seq
index|[
name|ring
index|]
argument_list|,
name|ring
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Fence debugfs  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DEBUG_FS
argument_list|)
end_if

begin_function
specifier|static
name|int
name|radeon_debugfs_fence_info
parameter_list|(
name|struct
name|seq_file
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|drm_info_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|drm_info_node
operator|*
operator|)
name|m
operator|->
name|private
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|node
operator|->
name|minor
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|rdev
operator|->
name|fence_drv
index|[
name|i
index|]
operator|.
name|initialized
condition|)
continue|continue;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"--- ring %d ---\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"Last signaled fence 0x%016llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|atomic_load_acq_64
argument_list|(
operator|&
name|rdev
operator|->
name|fence_drv
index|[
name|i
index|]
operator|.
name|last_seq
argument_list|)
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"Last emitted        0x%016llx\n"
argument_list|,
name|rdev
operator|->
name|fence_drv
index|[
name|i
index|]
operator|.
name|sync_seq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|RADEON_NUM_RINGS
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|j
operator|&&
name|rdev
operator|->
name|fence_drv
index|[
name|j
index|]
operator|.
name|initialized
condition|)
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|"Last sync to ring %d 0x%016llx\n"
argument_list|,
name|j
argument_list|,
name|rdev
operator|->
name|fence_drv
index|[
name|i
index|]
operator|.
name|sync_seq
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|drm_info_list
name|radeon_debugfs_fence_list
index|[]
init|=
block|{
block|{
literal|"radeon_fence_info"
block|,
operator|&
name|radeon_debugfs_fence_info
block|,
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|radeon_debugfs_fence_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DEBUG_FS
argument_list|)
return|return
name|radeon_debugfs_add_files
argument_list|(
name|rdev
argument_list|,
name|radeon_debugfs_fence_list
argument_list|,
literal|1
argument_list|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

end_unit

