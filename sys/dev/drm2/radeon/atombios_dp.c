begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2007-8 Advanced Micro Devices, Inc.  * Copyright 2008 Red Hat Inc.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *  * Authors: Dave Airlie  *          Alex Deucher  *          Jerome Glisse  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/radeon/radeon_drm.h>
end_include

begin_include
include|#
directive|include
file|"radeon.h"
end_include

begin_include
include|#
directive|include
file|"atom.h"
end_include

begin_include
include|#
directive|include
file|"atom-bits.h"
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_dp_helper.h>
end_include

begin_comment
comment|/* move these to drm_dp_helper.c/h */
end_comment

begin_define
define|#
directive|define
name|DP_LINK_CONFIGURATION_SIZE
value|9
end_define

begin_define
define|#
directive|define
name|DP_DPCD_SIZE
value|DP_RECEIVER_CAP_SIZE
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|voltage_names
index|[]
init|=
block|{
literal|"0.4V"
block|,
literal|"0.6V"
block|,
literal|"0.8V"
block|,
literal|"1.2V"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pre_emph_names
index|[]
init|=
block|{
literal|"0dB"
block|,
literal|"3.5dB"
block|,
literal|"6dB"
block|,
literal|"9.5dB"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***** radeon AUX functions *****/
end_comment

begin_union
union|union
name|aux_channel_transaction
block|{
name|PROCESS_AUX_CHANNEL_TRANSACTION_PS_ALLOCATION
name|v1
decl_stmt|;
name|PROCESS_AUX_CHANNEL_TRANSACTION_PARAMETERS_V2
name|v2
decl_stmt|;
block|}
union|;
end_union

begin_function
specifier|static
name|int
name|radeon_process_aux_ch
parameter_list|(
name|struct
name|radeon_i2c_chan
modifier|*
name|chan
parameter_list|,
name|u8
modifier|*
name|send
parameter_list|,
name|int
name|send_bytes
parameter_list|,
name|u8
modifier|*
name|recv
parameter_list|,
name|int
name|recv_size
parameter_list|,
name|u8
name|delay
parameter_list|,
name|u8
modifier|*
name|ack
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|chan
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|union
name|aux_channel_transaction
name|args
decl_stmt|;
name|int
name|index
init|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|ProcessAuxChannelTransaction
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|recv_bytes
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
operator|->
name|scratch
operator|+
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|base
argument_list|,
name|send
argument_list|,
name|send_bytes
argument_list|)
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|lpAuxRequest
operator|=
literal|0
operator|+
literal|4
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|lpDataOut
operator|=
literal|16
operator|+
literal|4
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucDataOutLen
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucChannelID
operator|=
name|chan
operator|->
name|rec
operator|.
name|i2c_id
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucDelay
operator|=
name|delay
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
name|args
operator|.
name|v2
operator|.
name|ucHPD_ID
operator|=
name|chan
operator|->
name|rec
operator|.
name|hpd
expr_stmt|;
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
operator|*
name|ack
operator|=
name|args
operator|.
name|v1
operator|.
name|ucReplyStatus
expr_stmt|;
comment|/* timeout */
if|if
condition|(
name|args
operator|.
name|v1
operator|.
name|ucReplyStatus
operator|==
literal|1
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"dp_aux_ch timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ETIMEDOUT
return|;
block|}
comment|/* flags not zero */
if|if
condition|(
name|args
operator|.
name|v1
operator|.
name|ucReplyStatus
operator|==
literal|2
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"dp_aux_ch flags not zero\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
comment|/* error */
if|if
condition|(
name|args
operator|.
name|v1
operator|.
name|ucReplyStatus
operator|==
literal|3
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"dp_aux_ch error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
name|recv_bytes
operator|=
name|args
operator|.
name|v1
operator|.
name|ucDataOutLen
expr_stmt|;
if|if
condition|(
name|recv_bytes
operator|>
name|recv_size
condition|)
name|recv_bytes
operator|=
name|recv_size
expr_stmt|;
if|if
condition|(
name|recv
operator|&&
name|recv_size
condition|)
name|memcpy
argument_list|(
name|recv
argument_list|,
name|base
operator|+
literal|16
argument_list|,
name|recv_bytes
argument_list|)
expr_stmt|;
return|return
name|recv_bytes
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_dp_aux_native_write
parameter_list|(
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
parameter_list|,
name|u16
name|address
parameter_list|,
name|u8
modifier|*
name|send
parameter_list|,
name|u8
name|send_bytes
parameter_list|,
name|u8
name|delay
parameter_list|)
block|{
name|struct
name|radeon_connector_atom_dig
modifier|*
name|dig_connector
init|=
name|radeon_connector
operator|->
name|con_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|u8
name|msg
index|[
literal|20
index|]
decl_stmt|;
name|int
name|msg_bytes
init|=
name|send_bytes
operator|+
literal|4
decl_stmt|;
name|u8
name|ack
decl_stmt|;
name|unsigned
name|retry
decl_stmt|;
if|if
condition|(
name|send_bytes
operator|>
literal|16
condition|)
return|return
operator|-
literal|1
return|;
name|msg
index|[
literal|0
index|]
operator|=
name|address
expr_stmt|;
name|msg
index|[
literal|1
index|]
operator|=
name|address
operator|>>
literal|8
expr_stmt|;
name|msg
index|[
literal|2
index|]
operator|=
name|AUX_NATIVE_WRITE
operator|<<
literal|4
expr_stmt|;
name|msg
index|[
literal|3
index|]
operator|=
operator|(
name|msg_bytes
operator|<<
literal|4
operator|)
operator||
operator|(
name|send_bytes
operator|-
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|msg
index|[
literal|4
index|]
argument_list|,
name|send
argument_list|,
name|send_bytes
argument_list|)
expr_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
literal|4
condition|;
name|retry
operator|++
control|)
block|{
name|ret
operator|=
name|radeon_process_aux_ch
argument_list|(
name|dig_connector
operator|->
name|dp_i2c_bus
argument_list|,
name|msg
argument_list|,
name|msg_bytes
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|delay
argument_list|,
operator|&
name|ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|EBUSY
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|ack
operator|&
name|AUX_NATIVE_REPLY_MASK
operator|)
operator|==
name|AUX_NATIVE_REPLY_ACK
condition|)
return|return
name|send_bytes
return|;
elseif|else
if|if
condition|(
operator|(
name|ack
operator|&
name|AUX_NATIVE_REPLY_MASK
operator|)
operator|==
name|AUX_NATIVE_REPLY_DEFER
condition|)
name|DRM_UDELAY
argument_list|(
literal|400
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
name|EIO
return|;
block|}
return|return
operator|-
name|EIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_dp_aux_native_read
parameter_list|(
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
parameter_list|,
name|u16
name|address
parameter_list|,
name|u8
modifier|*
name|recv
parameter_list|,
name|int
name|recv_bytes
parameter_list|,
name|u8
name|delay
parameter_list|)
block|{
name|struct
name|radeon_connector_atom_dig
modifier|*
name|dig_connector
init|=
name|radeon_connector
operator|->
name|con_priv
decl_stmt|;
name|u8
name|msg
index|[
literal|4
index|]
decl_stmt|;
name|int
name|msg_bytes
init|=
literal|4
decl_stmt|;
name|u8
name|ack
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|retry
decl_stmt|;
name|msg
index|[
literal|0
index|]
operator|=
name|address
expr_stmt|;
name|msg
index|[
literal|1
index|]
operator|=
name|address
operator|>>
literal|8
expr_stmt|;
name|msg
index|[
literal|2
index|]
operator|=
name|AUX_NATIVE_READ
operator|<<
literal|4
expr_stmt|;
name|msg
index|[
literal|3
index|]
operator|=
operator|(
name|msg_bytes
operator|<<
literal|4
operator|)
operator||
operator|(
name|recv_bytes
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
literal|4
condition|;
name|retry
operator|++
control|)
block|{
name|ret
operator|=
name|radeon_process_aux_ch
argument_list|(
name|dig_connector
operator|->
name|dp_i2c_bus
argument_list|,
name|msg
argument_list|,
name|msg_bytes
argument_list|,
name|recv
argument_list|,
name|recv_bytes
argument_list|,
name|delay
argument_list|,
operator|&
name|ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|EBUSY
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|ack
operator|&
name|AUX_NATIVE_REPLY_MASK
operator|)
operator|==
name|AUX_NATIVE_REPLY_ACK
condition|)
return|return
name|ret
return|;
elseif|else
if|if
condition|(
operator|(
name|ack
operator|&
name|AUX_NATIVE_REPLY_MASK
operator|)
operator|==
name|AUX_NATIVE_REPLY_DEFER
condition|)
name|DRM_UDELAY
argument_list|(
literal|400
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
operator|-
name|EPROTO
return|;
else|else
return|return
operator|-
name|EIO
return|;
block|}
return|return
operator|-
name|EIO
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_write_dpcd_reg
parameter_list|(
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
parameter_list|,
name|u16
name|reg
parameter_list|,
name|u8
name|val
parameter_list|)
block|{
name|radeon_dp_aux_native_write
argument_list|(
name|radeon_connector
argument_list|,
name|reg
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u8
name|radeon_read_dpcd_reg
parameter_list|(
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
parameter_list|,
name|u16
name|reg
parameter_list|)
block|{
name|u8
name|val
init|=
literal|0
decl_stmt|;
name|radeon_dp_aux_native_read
argument_list|(
name|radeon_connector
argument_list|,
name|reg
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|radeon_dp_i2c_aux_ch
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|mode
parameter_list|,
name|u8
name|write_byte
parameter_list|,
name|u8
modifier|*
name|read_byte
parameter_list|)
block|{
name|struct
name|iic_dp_aux_data
modifier|*
name|algo_data
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|radeon_i2c_chan
modifier|*
name|auxch
init|=
name|algo_data
operator|->
name|priv
decl_stmt|;
name|u16
name|address
init|=
name|algo_data
operator|->
name|address
decl_stmt|;
name|u8
name|msg
index|[
literal|5
index|]
decl_stmt|;
name|u8
name|reply
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|retry
decl_stmt|;
name|int
name|msg_bytes
decl_stmt|;
name|int
name|reply_bytes
init|=
literal|1
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|u8
name|ack
decl_stmt|;
comment|/* Set up the command byte */
if|if
condition|(
name|mode
operator|&
name|MODE_I2C_READ
condition|)
name|msg
index|[
literal|2
index|]
operator|=
name|AUX_I2C_READ
operator|<<
literal|4
expr_stmt|;
else|else
name|msg
index|[
literal|2
index|]
operator|=
name|AUX_I2C_WRITE
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|MODE_I2C_STOP
operator|)
condition|)
name|msg
index|[
literal|2
index|]
operator||=
name|AUX_I2C_MOT
operator|<<
literal|4
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|=
name|address
expr_stmt|;
name|msg
index|[
literal|1
index|]
operator|=
name|address
operator|>>
literal|8
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_I2C_WRITE
case|:
name|msg_bytes
operator|=
literal|5
expr_stmt|;
name|msg
index|[
literal|3
index|]
operator|=
name|msg_bytes
operator|<<
literal|4
expr_stmt|;
name|msg
index|[
literal|4
index|]
operator|=
name|write_byte
expr_stmt|;
break|break;
case|case
name|MODE_I2C_READ
case|:
name|msg_bytes
operator|=
literal|4
expr_stmt|;
name|msg
index|[
literal|3
index|]
operator|=
name|msg_bytes
operator|<<
literal|4
expr_stmt|;
break|break;
default|default:
name|msg_bytes
operator|=
literal|4
expr_stmt|;
name|msg
index|[
literal|3
index|]
operator|=
literal|3
operator|<<
literal|4
expr_stmt|;
break|break;
block|}
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
literal|4
condition|;
name|retry
operator|++
control|)
block|{
name|ret
operator|=
name|radeon_process_aux_ch
argument_list|(
name|auxch
argument_list|,
name|msg
argument_list|,
name|msg_bytes
argument_list|,
name|reply
argument_list|,
name|reply_bytes
argument_list|,
literal|0
argument_list|,
operator|&
name|ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|EBUSY
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"aux_ch failed %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
switch|switch
condition|(
name|ack
operator|&
name|AUX_NATIVE_REPLY_MASK
condition|)
block|{
case|case
name|AUX_NATIVE_REPLY_ACK
case|:
comment|/* I2C-over-AUX Reply field is only valid 			 * when paired with AUX ACK. 			 */
break|break;
case|case
name|AUX_NATIVE_REPLY_NACK
case|:
name|DRM_DEBUG_KMS
argument_list|(
literal|"aux_ch native nack\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EREMOTEIO
return|;
case|case
name|AUX_NATIVE_REPLY_DEFER
case|:
name|DRM_DEBUG_KMS
argument_list|(
literal|"aux_ch native defer\n"
argument_list|)
expr_stmt|;
name|DRM_UDELAY
argument_list|(
literal|400
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|DRM_ERROR
argument_list|(
literal|"aux_ch invalid native reply 0x%02x\n"
argument_list|,
name|ack
argument_list|)
expr_stmt|;
return|return
operator|-
name|EREMOTEIO
return|;
block|}
switch|switch
condition|(
name|ack
operator|&
name|AUX_I2C_REPLY_MASK
condition|)
block|{
case|case
name|AUX_I2C_REPLY_ACK
case|:
if|if
condition|(
name|mode
operator|==
name|MODE_I2C_READ
condition|)
operator|*
name|read_byte
operator|=
name|reply
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Return ret on Linux. */
case|case
name|AUX_I2C_REPLY_NACK
case|:
name|DRM_DEBUG_KMS
argument_list|(
literal|"aux_i2c nack\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EREMOTEIO
return|;
case|case
name|AUX_I2C_REPLY_DEFER
case|:
name|DRM_DEBUG_KMS
argument_list|(
literal|"aux_i2c defer\n"
argument_list|)
expr_stmt|;
name|DRM_UDELAY
argument_list|(
literal|400
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"aux_i2c invalid reply 0x%02x\n"
argument_list|,
name|ack
argument_list|)
expr_stmt|;
return|return
operator|-
name|EREMOTEIO
return|;
block|}
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"aux i2c too many retries, giving up\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EREMOTEIO
return|;
block|}
end_function

begin_comment
comment|/***** general DP utility functions *****/
end_comment

begin_define
define|#
directive|define
name|DP_VOLTAGE_MAX
value|DP_TRAIN_VOLTAGE_SWING_1200
end_define

begin_define
define|#
directive|define
name|DP_PRE_EMPHASIS_MAX
value|DP_TRAIN_PRE_EMPHASIS_9_5
end_define

begin_function
specifier|static
name|void
name|dp_get_adjust_train
parameter_list|(
name|u8
name|link_status
index|[
name|DP_LINK_STATUS_SIZE
index|]
parameter_list|,
name|int
name|lane_count
parameter_list|,
name|u8
name|train_set
index|[
literal|4
index|]
parameter_list|)
block|{
name|u8
name|v
init|=
literal|0
decl_stmt|;
name|u8
name|p
init|=
literal|0
decl_stmt|;
name|int
name|lane
decl_stmt|;
for|for
control|(
name|lane
operator|=
literal|0
init|;
name|lane
operator|<
name|lane_count
condition|;
name|lane
operator|++
control|)
block|{
name|u8
name|this_v
init|=
name|drm_dp_get_adjust_request_voltage
argument_list|(
name|link_status
argument_list|,
name|lane
argument_list|)
decl_stmt|;
name|u8
name|this_p
init|=
name|drm_dp_get_adjust_request_pre_emphasis
argument_list|(
name|link_status
argument_list|,
name|lane
argument_list|)
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"requested signal parameters: lane %d voltage %s pre_emph %s\n"
argument_list|,
name|lane
argument_list|,
name|voltage_names
index|[
name|this_v
operator|>>
name|DP_TRAIN_VOLTAGE_SWING_SHIFT
index|]
argument_list|,
name|pre_emph_names
index|[
name|this_p
operator|>>
name|DP_TRAIN_PRE_EMPHASIS_SHIFT
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_v
operator|>
name|v
condition|)
name|v
operator|=
name|this_v
expr_stmt|;
if|if
condition|(
name|this_p
operator|>
name|p
condition|)
name|p
operator|=
name|this_p
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|>=
name|DP_VOLTAGE_MAX
condition|)
name|v
operator||=
name|DP_TRAIN_MAX_SWING_REACHED
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|DP_PRE_EMPHASIS_MAX
condition|)
name|p
operator||=
name|DP_TRAIN_MAX_PRE_EMPHASIS_REACHED
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"using signal parameters: voltage %s pre_emph %s\n"
argument_list|,
name|voltage_names
index|[
operator|(
name|v
operator|&
name|DP_TRAIN_VOLTAGE_SWING_MASK
operator|)
operator|>>
name|DP_TRAIN_VOLTAGE_SWING_SHIFT
index|]
argument_list|,
name|pre_emph_names
index|[
operator|(
name|p
operator|&
name|DP_TRAIN_PRE_EMPHASIS_MASK
operator|)
operator|>>
name|DP_TRAIN_PRE_EMPHASIS_SHIFT
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|lane
operator|=
literal|0
init|;
name|lane
operator|<
literal|4
condition|;
name|lane
operator|++
control|)
name|train_set
index|[
name|lane
index|]
operator|=
name|v
operator||
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* convert bits per color to bits per pixel */
end_comment

begin_comment
comment|/* get bpc from the EDID */
end_comment

begin_function
specifier|static
name|int
name|convert_bpc_to_bpp
parameter_list|(
name|int
name|bpc
parameter_list|)
block|{
if|if
condition|(
name|bpc
operator|==
literal|0
condition|)
return|return
literal|24
return|;
else|else
return|return
name|bpc
operator|*
literal|3
return|;
block|}
end_function

begin_comment
comment|/* get the max pix clock supported by the link rate and lane num */
end_comment

begin_function
specifier|static
name|int
name|dp_get_max_dp_pix_clock
parameter_list|(
name|int
name|link_rate
parameter_list|,
name|int
name|lane_num
parameter_list|,
name|int
name|bpp
parameter_list|)
block|{
return|return
operator|(
name|link_rate
operator|*
name|lane_num
operator|*
literal|8
operator|)
operator|/
name|bpp
return|;
block|}
end_function

begin_comment
comment|/***** radeon specific DP functions *****/
end_comment

begin_comment
comment|/* First get the min lane# when low rate is used according to pixel clock  * (prefer low rate), second check max lane# supported by DP panel,  * if the max lane#< low rate lane# then use max lane# instead.  */
end_comment

begin_function
specifier|static
name|int
name|radeon_dp_get_dp_lane_number
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|u8
name|dpcd
index|[
name|DP_DPCD_SIZE
index|]
parameter_list|,
name|int
name|pix_clock
parameter_list|)
block|{
name|int
name|bpp
init|=
name|convert_bpc_to_bpp
argument_list|(
name|radeon_get_monitor_bpc
argument_list|(
name|connector
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|max_link_rate
init|=
name|drm_dp_max_link_rate
argument_list|(
name|dpcd
argument_list|)
decl_stmt|;
name|int
name|max_lane_num
init|=
name|drm_dp_max_lane_count
argument_list|(
name|dpcd
argument_list|)
decl_stmt|;
name|int
name|lane_num
decl_stmt|;
name|int
name|max_dp_pix_clock
decl_stmt|;
for|for
control|(
name|lane_num
operator|=
literal|1
init|;
name|lane_num
operator|<
name|max_lane_num
condition|;
name|lane_num
operator|<<=
literal|1
control|)
block|{
name|max_dp_pix_clock
operator|=
name|dp_get_max_dp_pix_clock
argument_list|(
name|max_link_rate
argument_list|,
name|lane_num
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pix_clock
operator|<=
name|max_dp_pix_clock
condition|)
break|break;
block|}
return|return
name|lane_num
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_dp_get_dp_link_clock
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|u8
name|dpcd
index|[
name|DP_DPCD_SIZE
index|]
parameter_list|,
name|int
name|pix_clock
parameter_list|)
block|{
name|int
name|bpp
init|=
name|convert_bpc_to_bpp
argument_list|(
name|radeon_get_monitor_bpc
argument_list|(
name|connector
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|lane_num
decl_stmt|,
name|max_pix_clock
decl_stmt|;
if|if
condition|(
name|radeon_connector_encoder_get_dp_bridge_encoder_id
argument_list|(
name|connector
argument_list|)
operator|==
name|ENCODER_OBJECT_ID_NUTMEG
condition|)
return|return
literal|270000
return|;
name|lane_num
operator|=
name|radeon_dp_get_dp_lane_number
argument_list|(
name|connector
argument_list|,
name|dpcd
argument_list|,
name|pix_clock
argument_list|)
expr_stmt|;
name|max_pix_clock
operator|=
name|dp_get_max_dp_pix_clock
argument_list|(
literal|162000
argument_list|,
name|lane_num
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pix_clock
operator|<=
name|max_pix_clock
condition|)
return|return
literal|162000
return|;
name|max_pix_clock
operator|=
name|dp_get_max_dp_pix_clock
argument_list|(
literal|270000
argument_list|,
name|lane_num
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pix_clock
operator|<=
name|max_pix_clock
condition|)
return|return
literal|270000
return|;
if|if
condition|(
name|radeon_connector_is_dp12_capable
argument_list|(
name|connector
argument_list|)
condition|)
block|{
name|max_pix_clock
operator|=
name|dp_get_max_dp_pix_clock
argument_list|(
literal|540000
argument_list|,
name|lane_num
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pix_clock
operator|<=
name|max_pix_clock
condition|)
return|return
literal|540000
return|;
block|}
return|return
name|drm_dp_max_link_rate
argument_list|(
name|dpcd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u8
name|radeon_dp_encoder_service
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|int
name|action
parameter_list|,
name|int
name|dp_clock
parameter_list|,
name|u8
name|ucconfig
parameter_list|,
name|u8
name|lane_num
parameter_list|)
block|{
name|DP_ENCODER_SERVICE_PARAMETERS
name|args
decl_stmt|;
name|int
name|index
init|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|DPEncoderService
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|ucLinkClock
operator|=
name|dp_clock
operator|/
literal|10
expr_stmt|;
name|args
operator|.
name|ucConfig
operator|=
name|ucconfig
expr_stmt|;
name|args
operator|.
name|ucAction
operator|=
name|action
expr_stmt|;
name|args
operator|.
name|ucLaneNum
operator|=
name|lane_num
expr_stmt|;
name|args
operator|.
name|ucStatus
operator|=
literal|0
expr_stmt|;
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
return|return
name|args
operator|.
name|ucStatus
return|;
block|}
end_function

begin_function
name|u8
name|radeon_dp_getsinktype
parameter_list|(
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
parameter_list|)
block|{
name|struct
name|radeon_connector_atom_dig
modifier|*
name|dig_connector
init|=
name|radeon_connector
operator|->
name|con_priv
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|radeon_connector
operator|->
name|base
operator|.
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
name|radeon_dp_encoder_service
argument_list|(
name|rdev
argument_list|,
name|ATOM_DP_ACTION_GET_SINK_TYPE
argument_list|,
literal|0
argument_list|,
name|dig_connector
operator|->
name|dp_i2c_bus
operator|->
name|rec
operator|.
name|i2c_id
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_dp_probe_oui
parameter_list|(
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
parameter_list|)
block|{
name|struct
name|radeon_connector_atom_dig
modifier|*
name|dig_connector
init|=
name|radeon_connector
operator|->
name|con_priv
decl_stmt|;
name|u8
name|buf
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dig_connector
operator|->
name|dpcd
index|[
name|DP_DOWN_STREAM_PORT_COUNT
index|]
operator|&
name|DP_OUI_SUPPORT
operator|)
condition|)
return|return;
if|if
condition|(
name|radeon_dp_aux_native_read
argument_list|(
name|radeon_connector
argument_list|,
name|DP_SINK_OUI
argument_list|,
name|buf
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"Sink OUI: %02hhx%02hhx%02hhx\n"
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_dp_aux_native_read
argument_list|(
name|radeon_connector
argument_list|,
name|DP_BRANCH_OUI
argument_list|,
name|buf
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"Branch OUI: %02hhx%02hhx%02hhx\n"
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|radeon_dp_getdpcd
parameter_list|(
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
parameter_list|)
block|{
name|struct
name|radeon_connector_atom_dig
modifier|*
name|dig_connector
init|=
name|radeon_connector
operator|->
name|con_priv
decl_stmt|;
name|u8
name|msg
index|[
name|DP_DPCD_SIZE
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|ret
operator|=
name|radeon_dp_aux_native_read
argument_list|(
name|radeon_connector
argument_list|,
name|DP_DPCD_REV
argument_list|,
name|msg
argument_list|,
name|DP_DPCD_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|dig_connector
operator|->
name|dpcd
argument_list|,
name|msg
argument_list|,
name|DP_DPCD_SIZE
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"DPCD: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DP_DPCD_SIZE
condition|;
name|i
operator|++
control|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"%02x "
argument_list|,
name|msg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|radeon_dp_probe_oui
argument_list|(
name|radeon_connector
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|dig_connector
operator|->
name|dpcd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|int
name|radeon_dp_get_panel_mode
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|int
name|panel_mode
init|=
name|DP_PANEL_MODE_EXTERNAL_DP_MODE
decl_stmt|;
name|u16
name|dp_bridge
init|=
name|radeon_connector_encoder_get_dp_bridge_encoder_id
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|u8
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
return|return
name|panel_mode
return|;
if|if
condition|(
name|dp_bridge
operator|!=
name|ENCODER_OBJECT_ID_NONE
condition|)
block|{
comment|/* DP bridge chips */
name|tmp
operator|=
name|radeon_read_dpcd_reg
argument_list|(
name|radeon_connector
argument_list|,
name|DP_EDP_CONFIGURATION_CAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
literal|1
condition|)
name|panel_mode
operator|=
name|DP_PANEL_MODE_INTERNAL_DP2_MODE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dp_bridge
operator|==
name|ENCODER_OBJECT_ID_NUTMEG
operator|)
operator|||
operator|(
name|dp_bridge
operator|==
name|ENCODER_OBJECT_ID_TRAVIS
operator|)
condition|)
name|panel_mode
operator|=
name|DP_PANEL_MODE_INTERNAL_DP1_MODE
expr_stmt|;
else|else
name|panel_mode
operator|=
name|DP_PANEL_MODE_EXTERNAL_DP_MODE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|connector
operator|->
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_eDP
condition|)
block|{
comment|/* eDP */
name|tmp
operator|=
name|radeon_read_dpcd_reg
argument_list|(
name|radeon_connector
argument_list|,
name|DP_EDP_CONFIGURATION_CAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
literal|1
condition|)
name|panel_mode
operator|=
name|DP_PANEL_MODE_INTERNAL_DP2_MODE
expr_stmt|;
block|}
return|return
name|panel_mode
return|;
block|}
end_function

begin_function
name|void
name|radeon_dp_set_link_config
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
specifier|const
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|radeon_connector_atom_dig
modifier|*
name|dig_connector
decl_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|con_priv
condition|)
return|return;
name|dig_connector
operator|=
name|radeon_connector
operator|->
name|con_priv
expr_stmt|;
if|if
condition|(
operator|(
name|dig_connector
operator|->
name|dp_sink_type
operator|==
name|CONNECTOR_OBJECT_ID_DISPLAYPORT
operator|)
operator|||
operator|(
name|dig_connector
operator|->
name|dp_sink_type
operator|==
name|CONNECTOR_OBJECT_ID_eDP
operator|)
condition|)
block|{
name|dig_connector
operator|->
name|dp_clock
operator|=
name|radeon_dp_get_dp_link_clock
argument_list|(
name|connector
argument_list|,
name|dig_connector
operator|->
name|dpcd
argument_list|,
name|mode
operator|->
name|clock
argument_list|)
expr_stmt|;
name|dig_connector
operator|->
name|dp_lane_count
operator|=
name|radeon_dp_get_dp_lane_number
argument_list|(
name|connector
argument_list|,
name|dig_connector
operator|->
name|dpcd
argument_list|,
name|mode
operator|->
name|clock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|radeon_dp_mode_valid_helper
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|radeon_connector_atom_dig
modifier|*
name|dig_connector
decl_stmt|;
name|int
name|dp_clock
decl_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|con_priv
condition|)
return|return
name|MODE_CLOCK_HIGH
return|;
name|dig_connector
operator|=
name|radeon_connector
operator|->
name|con_priv
expr_stmt|;
name|dp_clock
operator|=
name|radeon_dp_get_dp_link_clock
argument_list|(
name|connector
argument_list|,
name|dig_connector
operator|->
name|dpcd
argument_list|,
name|mode
operator|->
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp_clock
operator|==
literal|540000
operator|)
operator|&&
operator|(
operator|!
name|radeon_connector_is_dp12_capable
argument_list|(
name|connector
argument_list|)
operator|)
condition|)
return|return
name|MODE_CLOCK_HIGH
return|;
return|return
name|MODE_OK
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|radeon_dp_get_link_status
parameter_list|(
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
parameter_list|,
name|u8
name|link_status
index|[
name|DP_LINK_STATUS_SIZE
index|]
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|radeon_dp_aux_native_read
argument_list|(
name|radeon_connector
argument_list|,
name|DP_LANE0_1_STATUS
argument_list|,
name|link_status
argument_list|,
name|DP_LINK_STATUS_SIZE
argument_list|,
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
block|{
return|return
name|false
return|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"link status %*ph\n"
argument_list|,
literal|6
argument_list|,
name|link_status
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|radeon_dp_needs_link_train
parameter_list|(
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
parameter_list|)
block|{
name|u8
name|link_status
index|[
name|DP_LINK_STATUS_SIZE
index|]
decl_stmt|;
name|struct
name|radeon_connector_atom_dig
modifier|*
name|dig
init|=
name|radeon_connector
operator|->
name|con_priv
decl_stmt|;
if|if
condition|(
operator|!
name|radeon_dp_get_link_status
argument_list|(
name|radeon_connector
argument_list|,
name|link_status
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|drm_dp_channel_eq_ok
argument_list|(
name|link_status
argument_list|,
name|dig
operator|->
name|dp_lane_count
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_struct
struct|struct
name|radeon_dp_link_train_info
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
decl_stmt|;
name|int
name|enc_id
decl_stmt|;
name|int
name|dp_clock
decl_stmt|;
name|int
name|dp_lane_count
decl_stmt|;
name|bool
name|tp3_supported
decl_stmt|;
name|u8
name|dpcd
index|[
name|DP_RECEIVER_CAP_SIZE
index|]
decl_stmt|;
name|u8
name|train_set
index|[
literal|4
index|]
decl_stmt|;
name|u8
name|link_status
index|[
name|DP_LINK_STATUS_SIZE
index|]
decl_stmt|;
name|u8
name|tries
decl_stmt|;
name|bool
name|use_dpencoder
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|radeon_dp_update_vs_emph
parameter_list|(
name|struct
name|radeon_dp_link_train_info
modifier|*
name|dp_info
parameter_list|)
block|{
comment|/* set the initial vs/emph on the source */
name|atombios_dig_transmitter_setup
argument_list|(
name|dp_info
operator|->
name|encoder
argument_list|,
name|ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH
argument_list|,
literal|0
argument_list|,
name|dp_info
operator|->
name|train_set
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* sets all lanes at once */
comment|/* set the vs/emph on the sink */
name|radeon_dp_aux_native_write
argument_list|(
name|dp_info
operator|->
name|radeon_connector
argument_list|,
name|DP_TRAINING_LANE0_SET
argument_list|,
name|dp_info
operator|->
name|train_set
argument_list|,
name|dp_info
operator|->
name|dp_lane_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_dp_set_tp
parameter_list|(
name|struct
name|radeon_dp_link_train_info
modifier|*
name|dp_info
parameter_list|,
name|int
name|tp
parameter_list|)
block|{
name|int
name|rtp
init|=
literal|0
decl_stmt|;
comment|/* set training pattern on the source */
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|dp_info
operator|->
name|rdev
argument_list|)
operator|||
operator|!
name|dp_info
operator|->
name|use_dpencoder
condition|)
block|{
switch|switch
condition|(
name|tp
condition|)
block|{
case|case
name|DP_TRAINING_PATTERN_1
case|:
name|rtp
operator|=
name|ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN1
expr_stmt|;
break|break;
case|case
name|DP_TRAINING_PATTERN_2
case|:
name|rtp
operator|=
name|ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN2
expr_stmt|;
break|break;
case|case
name|DP_TRAINING_PATTERN_3
case|:
name|rtp
operator|=
name|ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN3
expr_stmt|;
break|break;
block|}
name|atombios_dig_encoder_setup
argument_list|(
name|dp_info
operator|->
name|encoder
argument_list|,
name|rtp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|tp
condition|)
block|{
case|case
name|DP_TRAINING_PATTERN_1
case|:
name|rtp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DP_TRAINING_PATTERN_2
case|:
name|rtp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|radeon_dp_encoder_service
argument_list|(
name|dp_info
operator|->
name|rdev
argument_list|,
name|ATOM_DP_ACTION_TRAINING_PATTERN_SEL
argument_list|,
name|dp_info
operator|->
name|dp_clock
argument_list|,
name|dp_info
operator|->
name|enc_id
argument_list|,
name|rtp
argument_list|)
expr_stmt|;
block|}
comment|/* enable training pattern on the sink */
name|radeon_write_dpcd_reg
argument_list|(
name|dp_info
operator|->
name|radeon_connector
argument_list|,
name|DP_TRAINING_PATTERN_SET
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_dp_link_train_init
parameter_list|(
name|struct
name|radeon_dp_link_train_info
modifier|*
name|dp_info
parameter_list|)
block|{
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|dp_info
operator|->
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|u8
name|tmp
decl_stmt|;
comment|/* power up the sink */
if|if
condition|(
name|dp_info
operator|->
name|dpcd
index|[
literal|0
index|]
operator|>=
literal|0x11
condition|)
name|radeon_write_dpcd_reg
argument_list|(
name|dp_info
operator|->
name|radeon_connector
argument_list|,
name|DP_SET_POWER
argument_list|,
name|DP_SET_POWER_D0
argument_list|)
expr_stmt|;
comment|/* possibly enable downspread on the sink */
if|if
condition|(
name|dp_info
operator|->
name|dpcd
index|[
literal|3
index|]
operator|&
literal|0x1
condition|)
name|radeon_write_dpcd_reg
argument_list|(
name|dp_info
operator|->
name|radeon_connector
argument_list|,
name|DP_DOWNSPREAD_CTRL
argument_list|,
name|DP_SPREAD_AMP_0_5
argument_list|)
expr_stmt|;
else|else
name|radeon_write_dpcd_reg
argument_list|(
name|dp_info
operator|->
name|radeon_connector
argument_list|,
name|DP_DOWNSPREAD_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp_info
operator|->
name|connector
operator|->
name|connector_type
operator|==
name|DRM_MODE_CONNECTOR_eDP
operator|)
operator|&&
operator|(
name|dig
operator|->
name|panel_mode
operator|==
name|DP_PANEL_MODE_INTERNAL_DP2_MODE
operator|)
condition|)
block|{
name|radeon_write_dpcd_reg
argument_list|(
name|dp_info
operator|->
name|radeon_connector
argument_list|,
name|DP_EDP_CONFIGURATION_SET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* set the lane count on the sink */
name|tmp
operator|=
name|dp_info
operator|->
name|dp_lane_count
expr_stmt|;
if|if
condition|(
name|dp_info
operator|->
name|dpcd
index|[
name|DP_DPCD_REV
index|]
operator|>=
literal|0x11
operator|&&
name|dp_info
operator|->
name|dpcd
index|[
name|DP_MAX_LANE_COUNT
index|]
operator|&
name|DP_ENHANCED_FRAME_CAP
condition|)
name|tmp
operator||=
name|DP_LANE_COUNT_ENHANCED_FRAME_EN
expr_stmt|;
name|radeon_write_dpcd_reg
argument_list|(
name|dp_info
operator|->
name|radeon_connector
argument_list|,
name|DP_LANE_COUNT_SET
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* set the link rate on the sink */
name|tmp
operator|=
name|drm_dp_link_rate_to_bw_code
argument_list|(
name|dp_info
operator|->
name|dp_clock
argument_list|)
expr_stmt|;
name|radeon_write_dpcd_reg
argument_list|(
name|dp_info
operator|->
name|radeon_connector
argument_list|,
name|DP_LINK_BW_SET
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* start training on the source */
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|dp_info
operator|->
name|rdev
argument_list|)
operator|||
operator|!
name|dp_info
operator|->
name|use_dpencoder
condition|)
name|atombios_dig_encoder_setup
argument_list|(
name|dp_info
operator|->
name|encoder
argument_list|,
name|ATOM_ENCODER_CMD_DP_LINK_TRAINING_START
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|radeon_dp_encoder_service
argument_list|(
name|dp_info
operator|->
name|rdev
argument_list|,
name|ATOM_DP_ACTION_TRAINING_START
argument_list|,
name|dp_info
operator|->
name|dp_clock
argument_list|,
name|dp_info
operator|->
name|enc_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable the training pattern on the sink */
name|radeon_write_dpcd_reg
argument_list|(
name|dp_info
operator|->
name|radeon_connector
argument_list|,
name|DP_TRAINING_PATTERN_SET
argument_list|,
name|DP_TRAINING_PATTERN_DISABLE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_dp_link_train_finish
parameter_list|(
name|struct
name|radeon_dp_link_train_info
modifier|*
name|dp_info
parameter_list|)
block|{
name|DRM_UDELAY
argument_list|(
literal|400
argument_list|)
expr_stmt|;
comment|/* disable the training pattern on the sink */
name|radeon_write_dpcd_reg
argument_list|(
name|dp_info
operator|->
name|radeon_connector
argument_list|,
name|DP_TRAINING_PATTERN_SET
argument_list|,
name|DP_TRAINING_PATTERN_DISABLE
argument_list|)
expr_stmt|;
comment|/* disable the training pattern on the source */
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|dp_info
operator|->
name|rdev
argument_list|)
operator|||
operator|!
name|dp_info
operator|->
name|use_dpencoder
condition|)
name|atombios_dig_encoder_setup
argument_list|(
name|dp_info
operator|->
name|encoder
argument_list|,
name|ATOM_ENCODER_CMD_DP_LINK_TRAINING_COMPLETE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|radeon_dp_encoder_service
argument_list|(
name|dp_info
operator|->
name|rdev
argument_list|,
name|ATOM_DP_ACTION_TRAINING_COMPLETE
argument_list|,
name|dp_info
operator|->
name|dp_clock
argument_list|,
name|dp_info
operator|->
name|enc_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_dp_link_train_cr
parameter_list|(
name|struct
name|radeon_dp_link_train_info
modifier|*
name|dp_info
parameter_list|)
block|{
name|bool
name|clock_recovery
decl_stmt|;
name|u8
name|voltage
decl_stmt|;
name|int
name|i
decl_stmt|;
name|radeon_dp_set_tp
argument_list|(
name|dp_info
argument_list|,
name|DP_TRAINING_PATTERN_1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dp_info
operator|->
name|train_set
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|radeon_dp_update_vs_emph
argument_list|(
name|dp_info
argument_list|)
expr_stmt|;
name|DRM_UDELAY
argument_list|(
literal|400
argument_list|)
expr_stmt|;
comment|/* clock recovery loop */
name|clock_recovery
operator|=
name|false
expr_stmt|;
name|dp_info
operator|->
name|tries
operator|=
literal|0
expr_stmt|;
name|voltage
operator|=
literal|0xff
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|drm_dp_link_train_clock_recovery_delay
argument_list|(
name|dp_info
operator|->
name|dpcd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_dp_get_link_status
argument_list|(
name|dp_info
operator|->
name|radeon_connector
argument_list|,
name|dp_info
operator|->
name|link_status
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"displayport link status failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|drm_dp_clock_recovery_ok
argument_list|(
name|dp_info
operator|->
name|link_status
argument_list|,
name|dp_info
operator|->
name|dp_lane_count
argument_list|)
condition|)
block|{
name|clock_recovery
operator|=
name|true
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp_info
operator|->
name|dp_lane_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dp_info
operator|->
name|train_set
index|[
name|i
index|]
operator|&
name|DP_TRAIN_MAX_SWING_REACHED
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|dp_info
operator|->
name|dp_lane_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"clock recovery reached max voltage\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|dp_info
operator|->
name|train_set
index|[
literal|0
index|]
operator|&
name|DP_TRAIN_VOLTAGE_SWING_MASK
operator|)
operator|==
name|voltage
condition|)
block|{
operator|++
name|dp_info
operator|->
name|tries
expr_stmt|;
if|if
condition|(
name|dp_info
operator|->
name|tries
operator|==
literal|5
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"clock recovery tried 5 times\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|dp_info
operator|->
name|tries
operator|=
literal|0
expr_stmt|;
name|voltage
operator|=
name|dp_info
operator|->
name|train_set
index|[
literal|0
index|]
operator|&
name|DP_TRAIN_VOLTAGE_SWING_MASK
expr_stmt|;
comment|/* Compute new train_set as requested by sink */
name|dp_get_adjust_train
argument_list|(
name|dp_info
operator|->
name|link_status
argument_list|,
name|dp_info
operator|->
name|dp_lane_count
argument_list|,
name|dp_info
operator|->
name|train_set
argument_list|)
expr_stmt|;
name|radeon_dp_update_vs_emph
argument_list|(
name|dp_info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|clock_recovery
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"clock recovery failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"clock recovery at voltage %d pre-emphasis %d\n"
argument_list|,
name|dp_info
operator|->
name|train_set
index|[
literal|0
index|]
operator|&
name|DP_TRAIN_VOLTAGE_SWING_MASK
argument_list|,
operator|(
name|dp_info
operator|->
name|train_set
index|[
literal|0
index|]
operator|&
name|DP_TRAIN_PRE_EMPHASIS_MASK
operator|)
operator|>>
name|DP_TRAIN_PRE_EMPHASIS_SHIFT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_dp_link_train_ce
parameter_list|(
name|struct
name|radeon_dp_link_train_info
modifier|*
name|dp_info
parameter_list|)
block|{
name|bool
name|channel_eq
decl_stmt|;
if|if
condition|(
name|dp_info
operator|->
name|tp3_supported
condition|)
name|radeon_dp_set_tp
argument_list|(
name|dp_info
argument_list|,
name|DP_TRAINING_PATTERN_3
argument_list|)
expr_stmt|;
else|else
name|radeon_dp_set_tp
argument_list|(
name|dp_info
argument_list|,
name|DP_TRAINING_PATTERN_2
argument_list|)
expr_stmt|;
comment|/* channel equalization loop */
name|dp_info
operator|->
name|tries
operator|=
literal|0
expr_stmt|;
name|channel_eq
operator|=
name|false
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|drm_dp_link_train_channel_eq_delay
argument_list|(
name|dp_info
operator|->
name|dpcd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_dp_get_link_status
argument_list|(
name|dp_info
operator|->
name|radeon_connector
argument_list|,
name|dp_info
operator|->
name|link_status
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"displayport link status failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|drm_dp_channel_eq_ok
argument_list|(
name|dp_info
operator|->
name|link_status
argument_list|,
name|dp_info
operator|->
name|dp_lane_count
argument_list|)
condition|)
block|{
name|channel_eq
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|/* Try 5 times */
if|if
condition|(
name|dp_info
operator|->
name|tries
operator|>
literal|5
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"channel eq failed: 5 tries\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Compute new train_set as requested by sink */
name|dp_get_adjust_train
argument_list|(
name|dp_info
operator|->
name|link_status
argument_list|,
name|dp_info
operator|->
name|dp_lane_count
argument_list|,
name|dp_info
operator|->
name|train_set
argument_list|)
expr_stmt|;
name|radeon_dp_update_vs_emph
argument_list|(
name|dp_info
argument_list|)
expr_stmt|;
name|dp_info
operator|->
name|tries
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|channel_eq
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"channel eq failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"channel eq at voltage %d pre-emphasis %d\n"
argument_list|,
name|dp_info
operator|->
name|train_set
index|[
literal|0
index|]
operator|&
name|DP_TRAIN_VOLTAGE_SWING_MASK
argument_list|,
operator|(
name|dp_info
operator|->
name|train_set
index|[
literal|0
index|]
operator|&
name|DP_TRAIN_PRE_EMPHASIS_MASK
operator|)
operator|>>
name|DP_TRAIN_PRE_EMPHASIS_SHIFT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|void
name|radeon_dp_link_train
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
decl_stmt|;
name|struct
name|radeon_connector_atom_dig
modifier|*
name|dig_connector
decl_stmt|;
name|struct
name|radeon_dp_link_train_info
name|dp_info
decl_stmt|;
name|int
name|index
decl_stmt|;
name|u8
name|tmp
decl_stmt|,
name|frev
decl_stmt|,
name|crev
decl_stmt|;
if|if
condition|(
operator|!
name|radeon_encoder
operator|->
name|enc_priv
condition|)
return|return;
name|dig
operator|=
name|radeon_encoder
operator|->
name|enc_priv
expr_stmt|;
name|radeon_connector
operator|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_connector
operator|->
name|con_priv
condition|)
return|return;
name|dig_connector
operator|=
name|radeon_connector
operator|->
name|con_priv
expr_stmt|;
if|if
condition|(
operator|(
name|dig_connector
operator|->
name|dp_sink_type
operator|!=
name|CONNECTOR_OBJECT_ID_DISPLAYPORT
operator|)
operator|&&
operator|(
name|dig_connector
operator|->
name|dp_sink_type
operator|!=
name|CONNECTOR_OBJECT_ID_eDP
operator|)
condition|)
return|return;
comment|/* DPEncoderService newer than 1.1 can't program properly the 	 * training pattern. When facing such version use the 	 * DIGXEncoderControl (X== 1 | 2) 	 */
name|dp_info
operator|.
name|use_dpencoder
operator|=
name|true
expr_stmt|;
name|index
operator|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|DPEncoderService
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom_parse_cmd_header
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|&
name|frev
argument_list|,
operator|&
name|crev
argument_list|)
condition|)
block|{
if|if
condition|(
name|crev
operator|>
literal|1
condition|)
block|{
name|dp_info
operator|.
name|use_dpencoder
operator|=
name|false
expr_stmt|;
block|}
block|}
name|dp_info
operator|.
name|enc_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dig
operator|->
name|dig_encoder
condition|)
name|dp_info
operator|.
name|enc_id
operator||=
name|ATOM_DP_CONFIG_DIG2_ENCODER
expr_stmt|;
else|else
name|dp_info
operator|.
name|enc_id
operator||=
name|ATOM_DP_CONFIG_DIG1_ENCODER
expr_stmt|;
if|if
condition|(
name|dig
operator|->
name|linkb
condition|)
name|dp_info
operator|.
name|enc_id
operator||=
name|ATOM_DP_CONFIG_LINK_B
expr_stmt|;
else|else
name|dp_info
operator|.
name|enc_id
operator||=
name|ATOM_DP_CONFIG_LINK_A
expr_stmt|;
name|tmp
operator|=
name|radeon_read_dpcd_reg
argument_list|(
name|radeon_connector
argument_list|,
name|DP_MAX_LANE_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASIC_IS_DCE5
argument_list|(
name|rdev
argument_list|)
operator|&&
operator|(
name|tmp
operator|&
name|DP_TPS3_SUPPORTED
operator|)
condition|)
name|dp_info
operator|.
name|tp3_supported
operator|=
name|true
expr_stmt|;
else|else
name|dp_info
operator|.
name|tp3_supported
operator|=
name|false
expr_stmt|;
name|memcpy
argument_list|(
name|dp_info
operator|.
name|dpcd
argument_list|,
name|dig_connector
operator|->
name|dpcd
argument_list|,
name|DP_RECEIVER_CAP_SIZE
argument_list|)
expr_stmt|;
name|dp_info
operator|.
name|rdev
operator|=
name|rdev
expr_stmt|;
name|dp_info
operator|.
name|encoder
operator|=
name|encoder
expr_stmt|;
name|dp_info
operator|.
name|connector
operator|=
name|connector
expr_stmt|;
name|dp_info
operator|.
name|radeon_connector
operator|=
name|radeon_connector
expr_stmt|;
name|dp_info
operator|.
name|dp_lane_count
operator|=
name|dig_connector
operator|->
name|dp_lane_count
expr_stmt|;
name|dp_info
operator|.
name|dp_clock
operator|=
name|dig_connector
operator|->
name|dp_clock
expr_stmt|;
if|if
condition|(
name|radeon_dp_link_train_init
argument_list|(
operator|&
name|dp_info
argument_list|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|radeon_dp_link_train_cr
argument_list|(
operator|&
name|dp_info
argument_list|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|radeon_dp_link_train_ce
argument_list|(
operator|&
name|dp_info
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|done
label|:
if|if
condition|(
name|radeon_dp_link_train_finish
argument_list|(
operator|&
name|dp_info
argument_list|)
condition|)
return|return;
block|}
end_function

end_unit

