begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2009 Jerome Glisse.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the  * "Software"), to deal in the Software without restriction, including  * without limitation the rights to use, copy, modify, merge, publish,  * distribute, sub license, and/or sell copies of the Software, and to  * permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE  * USE OR OTHER DEALINGS IN THE SOFTWARE.  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  */
end_comment

begin_comment
comment|/*  * Authors:  *    Jerome Glisse<glisse@freedesktop.org>  *    Thomas Hellstrom<thomas-at-tungstengraphics-dot-com>  *    Dave Airlie  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_bo_api.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_bo_driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_placement.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_module.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/ttm/ttm_page_alloc.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/radeon/radeon_drm.h>
end_include

begin_include
include|#
directive|include
file|"radeon_reg.h"
end_include

begin_include
include|#
directive|include
file|"radeon.h"
end_include

begin_define
define|#
directive|define
name|DRM_FILE_PAGE_OFFSET
value|(0x100000000ULL>> PAGE_SHIFT)
end_define

begin_function_decl
specifier|static
name|int
name|radeon_ttm_debugfs_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|radeon_device
modifier|*
name|radeon_get_rdev
parameter_list|(
name|struct
name|ttm_bo_device
modifier|*
name|bdev
parameter_list|)
block|{
name|struct
name|radeon_mman
modifier|*
name|mman
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|mman
operator|=
name|container_of
argument_list|(
name|bdev
argument_list|,
expr|struct
name|radeon_mman
argument_list|,
name|bdev
argument_list|)
expr_stmt|;
name|rdev
operator|=
name|container_of
argument_list|(
name|mman
argument_list|,
expr|struct
name|radeon_device
argument_list|,
name|mman
argument_list|)
expr_stmt|;
return|return
name|rdev
return|;
block|}
end_function

begin_comment
comment|/*  * Global memory.  */
end_comment

begin_function
specifier|static
name|int
name|radeon_ttm_mem_global_init
parameter_list|(
name|struct
name|drm_global_reference
modifier|*
name|ref
parameter_list|)
block|{
return|return
name|ttm_mem_global_init
argument_list|(
name|ref
operator|->
name|object
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_ttm_mem_global_release
parameter_list|(
name|struct
name|drm_global_reference
modifier|*
name|ref
parameter_list|)
block|{
name|ttm_mem_global_release
argument_list|(
name|ref
operator|->
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_ttm_global_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|struct
name|drm_global_reference
modifier|*
name|global_ref
decl_stmt|;
name|int
name|r
decl_stmt|;
name|rdev
operator|->
name|mman
operator|.
name|mem_global_referenced
operator|=
name|false
expr_stmt|;
name|global_ref
operator|=
operator|&
name|rdev
operator|->
name|mman
operator|.
name|mem_global_ref
expr_stmt|;
name|global_ref
operator|->
name|global_type
operator|=
name|DRM_GLOBAL_TTM_MEM
expr_stmt|;
name|global_ref
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ttm_mem_global
argument_list|)
expr_stmt|;
name|global_ref
operator|->
name|init
operator|=
operator|&
name|radeon_ttm_mem_global_init
expr_stmt|;
name|global_ref
operator|->
name|release
operator|=
operator|&
name|radeon_ttm_mem_global_release
expr_stmt|;
name|r
operator|=
name|drm_global_item_ref
argument_list|(
name|global_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed setting up TTM memory accounting "
literal|"subsystem.\n"
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|rdev
operator|->
name|mman
operator|.
name|bo_global_ref
operator|.
name|mem_glob
operator|=
name|rdev
operator|->
name|mman
operator|.
name|mem_global_ref
operator|.
name|object
expr_stmt|;
name|global_ref
operator|=
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bo_global_ref
operator|.
name|ref
expr_stmt|;
name|global_ref
operator|->
name|global_type
operator|=
name|DRM_GLOBAL_TTM_BO
expr_stmt|;
name|global_ref
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ttm_bo_global
argument_list|)
expr_stmt|;
name|global_ref
operator|->
name|init
operator|=
operator|&
name|ttm_bo_global_init
expr_stmt|;
name|global_ref
operator|->
name|release
operator|=
operator|&
name|ttm_bo_global_release
expr_stmt|;
name|r
operator|=
name|drm_global_item_ref
argument_list|(
name|global_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed setting up TTM BO subsystem.\n"
argument_list|)
expr_stmt|;
name|drm_global_item_unref
argument_list|(
operator|&
name|rdev
operator|->
name|mman
operator|.
name|mem_global_ref
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|rdev
operator|->
name|mman
operator|.
name|mem_global_referenced
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_ttm_global_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|if
condition|(
name|rdev
operator|->
name|mman
operator|.
name|mem_global_referenced
condition|)
block|{
name|drm_global_item_unref
argument_list|(
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bo_global_ref
operator|.
name|ref
argument_list|)
expr_stmt|;
name|drm_global_item_unref
argument_list|(
operator|&
name|rdev
operator|->
name|mman
operator|.
name|mem_global_ref
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|mman
operator|.
name|mem_global_referenced
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_invalidate_caches
parameter_list|(
name|struct
name|ttm_bo_device
modifier|*
name|bdev
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_init_mem_type
parameter_list|(
name|struct
name|ttm_bo_device
modifier|*
name|bdev
parameter_list|,
name|uint32_t
name|type
parameter_list|,
name|struct
name|ttm_mem_type_manager
modifier|*
name|man
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|rdev
operator|=
name|radeon_get_rdev
argument_list|(
name|bdev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TTM_PL_SYSTEM
case|:
comment|/* System memory */
name|man
operator|->
name|flags
operator|=
name|TTM_MEMTYPE_FLAG_MAPPABLE
expr_stmt|;
name|man
operator|->
name|available_caching
operator|=
name|TTM_PL_MASK_CACHING
expr_stmt|;
name|man
operator|->
name|default_caching
operator|=
name|TTM_PL_FLAG_CACHED
expr_stmt|;
break|break;
case|case
name|TTM_PL_TT
case|:
name|man
operator|->
name|func
operator|=
operator|&
name|ttm_bo_manager_func
expr_stmt|;
name|man
operator|->
name|gpu_offset
operator|=
name|rdev
operator|->
name|mc
operator|.
name|gtt_start
expr_stmt|;
name|man
operator|->
name|available_caching
operator|=
name|TTM_PL_MASK_CACHING
expr_stmt|;
name|man
operator|->
name|default_caching
operator|=
name|TTM_PL_FLAG_CACHED
expr_stmt|;
name|man
operator|->
name|flags
operator|=
name|TTM_MEMTYPE_FLAG_MAPPABLE
operator||
name|TTM_MEMTYPE_FLAG_CMA
expr_stmt|;
if|#
directive|if
name|__OS_HAS_AGP
if|if
condition|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_AGP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|drm_core_has_AGP
argument_list|(
name|rdev
operator|->
name|ddev
argument_list|)
operator|&&
name|rdev
operator|->
name|ddev
operator|->
name|agp
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"AGP is not enabled for memory type %u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|type
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
name|rdev
operator|->
name|ddev
operator|->
name|agp
operator|->
name|cant_use_aperture
condition|)
name|man
operator|->
name|flags
operator|=
name|TTM_MEMTYPE_FLAG_MAPPABLE
expr_stmt|;
name|man
operator|->
name|available_caching
operator|=
name|TTM_PL_FLAG_UNCACHED
operator||
name|TTM_PL_FLAG_WC
expr_stmt|;
name|man
operator|->
name|default_caching
operator|=
name|TTM_PL_FLAG_WC
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|TTM_PL_VRAM
case|:
comment|/* "On-card" video ram */
name|man
operator|->
name|func
operator|=
operator|&
name|ttm_bo_manager_func
expr_stmt|;
name|man
operator|->
name|gpu_offset
operator|=
name|rdev
operator|->
name|mc
operator|.
name|vram_start
expr_stmt|;
name|man
operator|->
name|flags
operator|=
name|TTM_MEMTYPE_FLAG_FIXED
operator||
name|TTM_MEMTYPE_FLAG_MAPPABLE
expr_stmt|;
name|man
operator|->
name|available_caching
operator|=
name|TTM_PL_FLAG_UNCACHED
operator||
name|TTM_PL_FLAG_WC
expr_stmt|;
name|man
operator|->
name|default_caching
operator|=
name|TTM_PL_FLAG_WC
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unsupported memory type %u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|type
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_evict_flags
parameter_list|(
name|struct
name|ttm_buffer_object
modifier|*
name|bo
parameter_list|,
name|struct
name|ttm_placement
modifier|*
name|placement
parameter_list|)
block|{
name|struct
name|radeon_bo
modifier|*
name|rbo
decl_stmt|;
specifier|static
name|u32
name|placements
init|=
name|TTM_PL_MASK_CACHING
operator||
name|TTM_PL_FLAG_SYSTEM
decl_stmt|;
if|if
condition|(
operator|!
name|radeon_ttm_bo_is_radeon_bo
argument_list|(
name|bo
argument_list|)
condition|)
block|{
name|placement
operator|->
name|fpfn
operator|=
literal|0
expr_stmt|;
name|placement
operator|->
name|lpfn
operator|=
literal|0
expr_stmt|;
name|placement
operator|->
name|placement
operator|=
operator|&
name|placements
expr_stmt|;
name|placement
operator|->
name|busy_placement
operator|=
operator|&
name|placements
expr_stmt|;
name|placement
operator|->
name|num_placement
operator|=
literal|1
expr_stmt|;
name|placement
operator|->
name|num_busy_placement
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|rbo
operator|=
name|container_of
argument_list|(
name|bo
argument_list|,
expr|struct
name|radeon_bo
argument_list|,
name|tbo
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bo
operator|->
name|mem
operator|.
name|mem_type
condition|)
block|{
case|case
name|TTM_PL_VRAM
case|:
if|if
condition|(
name|rbo
operator|->
name|rdev
operator|->
name|ring
index|[
name|RADEON_RING_TYPE_GFX_INDEX
index|]
operator|.
name|ready
operator|==
name|false
condition|)
name|radeon_ttm_placement_from_domain
argument_list|(
name|rbo
argument_list|,
name|RADEON_GEM_DOMAIN_CPU
argument_list|)
expr_stmt|;
else|else
name|radeon_ttm_placement_from_domain
argument_list|(
name|rbo
argument_list|,
name|RADEON_GEM_DOMAIN_GTT
argument_list|)
expr_stmt|;
break|break;
case|case
name|TTM_PL_TT
case|:
default|default:
name|radeon_ttm_placement_from_domain
argument_list|(
name|rbo
argument_list|,
name|RADEON_GEM_DOMAIN_CPU
argument_list|)
expr_stmt|;
block|}
operator|*
name|placement
operator|=
name|rbo
operator|->
name|placement
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_verify_access
parameter_list|(
name|struct
name|ttm_buffer_object
modifier|*
name|bo
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_move_null
parameter_list|(
name|struct
name|ttm_buffer_object
modifier|*
name|bo
parameter_list|,
name|struct
name|ttm_mem_reg
modifier|*
name|new_mem
parameter_list|)
block|{
name|struct
name|ttm_mem_reg
modifier|*
name|old_mem
init|=
operator|&
name|bo
operator|->
name|mem
decl_stmt|;
name|KASSERT
argument_list|(
name|old_mem
operator|->
name|mm_node
operator|==
name|NULL
argument_list|,
operator|(
literal|"old_mem->mm_node != NULL"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|old_mem
operator|=
operator|*
name|new_mem
expr_stmt|;
name|new_mem
operator|->
name|mm_node
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_move_blit
parameter_list|(
name|struct
name|ttm_buffer_object
modifier|*
name|bo
parameter_list|,
name|bool
name|evict
parameter_list|,
name|bool
name|no_wait_gpu
parameter_list|,
name|struct
name|ttm_mem_reg
modifier|*
name|new_mem
parameter_list|,
name|struct
name|ttm_mem_reg
modifier|*
name|old_mem
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|uint64_t
name|old_start
decl_stmt|,
name|new_start
decl_stmt|;
name|struct
name|radeon_fence
modifier|*
name|fence
decl_stmt|;
name|int
name|r
decl_stmt|,
name|ridx
decl_stmt|;
name|rdev
operator|=
name|radeon_get_rdev
argument_list|(
name|bo
operator|->
name|bdev
argument_list|)
expr_stmt|;
name|ridx
operator|=
name|radeon_copy_ring_index
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|old_start
operator|=
name|old_mem
operator|->
name|start
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|new_start
operator|=
name|new_mem
operator|->
name|start
operator|<<
name|PAGE_SHIFT
expr_stmt|;
switch|switch
condition|(
name|old_mem
operator|->
name|mem_type
condition|)
block|{
case|case
name|TTM_PL_VRAM
case|:
name|old_start
operator|+=
name|rdev
operator|->
name|mc
operator|.
name|vram_start
expr_stmt|;
break|break;
case|case
name|TTM_PL_TT
case|:
name|old_start
operator|+=
name|rdev
operator|->
name|mc
operator|.
name|gtt_start
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown placement %d\n"
argument_list|,
name|old_mem
operator|->
name|mem_type
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|new_mem
operator|->
name|mem_type
condition|)
block|{
case|case
name|TTM_PL_VRAM
case|:
name|new_start
operator|+=
name|rdev
operator|->
name|mc
operator|.
name|vram_start
expr_stmt|;
break|break;
case|case
name|TTM_PL_TT
case|:
name|new_start
operator|+=
name|rdev
operator|->
name|mc
operator|.
name|gtt_start
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown placement %d\n"
argument_list|,
name|old_mem
operator|->
name|mem_type
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
name|rdev
operator|->
name|ring
index|[
name|ridx
index|]
operator|.
name|ready
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Trying to move memory with ring turned off.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|CTASSERT
argument_list|(
operator|(
name|PAGE_SIZE
operator|%
name|RADEON_GPU_PAGE_SIZE
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* sync other rings */
name|fence
operator|=
name|bo
operator|->
name|sync_obj
expr_stmt|;
name|r
operator|=
name|radeon_copy
argument_list|(
name|rdev
argument_list|,
name|old_start
argument_list|,
name|new_start
argument_list|,
name|new_mem
operator|->
name|num_pages
operator|*
operator|(
name|PAGE_SIZE
operator|/
name|RADEON_GPU_PAGE_SIZE
operator|)
argument_list|,
comment|/* GPU pages */
operator|&
name|fence
argument_list|)
expr_stmt|;
comment|/* FIXME: handle copy error */
name|r
operator|=
name|ttm_bo_move_accel_cleanup
argument_list|(
name|bo
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fence
argument_list|,
name|evict
argument_list|,
name|no_wait_gpu
argument_list|,
name|new_mem
argument_list|)
expr_stmt|;
name|radeon_fence_unref
argument_list|(
operator|&
name|fence
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_move_vram_ram
parameter_list|(
name|struct
name|ttm_buffer_object
modifier|*
name|bo
parameter_list|,
name|bool
name|evict
parameter_list|,
name|bool
name|interruptible
parameter_list|,
name|bool
name|no_wait_gpu
parameter_list|,
name|struct
name|ttm_mem_reg
modifier|*
name|new_mem
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|struct
name|ttm_mem_reg
modifier|*
name|old_mem
init|=
operator|&
name|bo
operator|->
name|mem
decl_stmt|;
name|struct
name|ttm_mem_reg
name|tmp_mem
decl_stmt|;
name|u32
name|placements
decl_stmt|;
name|struct
name|ttm_placement
name|placement
decl_stmt|;
name|int
name|r
decl_stmt|;
name|rdev
operator|=
name|radeon_get_rdev
argument_list|(
name|bo
operator|->
name|bdev
argument_list|)
expr_stmt|;
name|tmp_mem
operator|=
operator|*
name|new_mem
expr_stmt|;
name|tmp_mem
operator|.
name|mm_node
operator|=
name|NULL
expr_stmt|;
name|placement
operator|.
name|fpfn
operator|=
literal|0
expr_stmt|;
name|placement
operator|.
name|lpfn
operator|=
literal|0
expr_stmt|;
name|placement
operator|.
name|num_placement
operator|=
literal|1
expr_stmt|;
name|placement
operator|.
name|placement
operator|=
operator|&
name|placements
expr_stmt|;
name|placement
operator|.
name|num_busy_placement
operator|=
literal|1
expr_stmt|;
name|placement
operator|.
name|busy_placement
operator|=
operator|&
name|placements
expr_stmt|;
name|placements
operator|=
name|TTM_PL_MASK_CACHING
operator||
name|TTM_PL_FLAG_TT
expr_stmt|;
name|r
operator|=
name|ttm_bo_mem_space
argument_list|(
name|bo
argument_list|,
operator|&
name|placement
argument_list|,
operator|&
name|tmp_mem
argument_list|,
name|interruptible
argument_list|,
name|no_wait_gpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
argument_list|)
condition|)
block|{
return|return
name|r
return|;
block|}
name|r
operator|=
name|ttm_tt_set_placement_caching
argument_list|(
name|bo
operator|->
name|ttm
argument_list|,
name|tmp_mem
operator|.
name|placement
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
argument_list|)
condition|)
block|{
goto|goto
name|out_cleanup
goto|;
block|}
name|r
operator|=
name|ttm_tt_bind
argument_list|(
name|bo
operator|->
name|ttm
argument_list|,
operator|&
name|tmp_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
argument_list|)
condition|)
block|{
goto|goto
name|out_cleanup
goto|;
block|}
name|r
operator|=
name|radeon_move_blit
argument_list|(
name|bo
argument_list|,
name|true
argument_list|,
name|no_wait_gpu
argument_list|,
operator|&
name|tmp_mem
argument_list|,
name|old_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
argument_list|)
condition|)
block|{
goto|goto
name|out_cleanup
goto|;
block|}
name|r
operator|=
name|ttm_bo_move_ttm
argument_list|(
name|bo
argument_list|,
name|true
argument_list|,
name|no_wait_gpu
argument_list|,
name|new_mem
argument_list|)
expr_stmt|;
name|out_cleanup
label|:
name|ttm_bo_mem_put
argument_list|(
name|bo
argument_list|,
operator|&
name|tmp_mem
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_move_ram_vram
parameter_list|(
name|struct
name|ttm_buffer_object
modifier|*
name|bo
parameter_list|,
name|bool
name|evict
parameter_list|,
name|bool
name|interruptible
parameter_list|,
name|bool
name|no_wait_gpu
parameter_list|,
name|struct
name|ttm_mem_reg
modifier|*
name|new_mem
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|struct
name|ttm_mem_reg
modifier|*
name|old_mem
init|=
operator|&
name|bo
operator|->
name|mem
decl_stmt|;
name|struct
name|ttm_mem_reg
name|tmp_mem
decl_stmt|;
name|struct
name|ttm_placement
name|placement
decl_stmt|;
name|u32
name|placements
decl_stmt|;
name|int
name|r
decl_stmt|;
name|rdev
operator|=
name|radeon_get_rdev
argument_list|(
name|bo
operator|->
name|bdev
argument_list|)
expr_stmt|;
name|tmp_mem
operator|=
operator|*
name|new_mem
expr_stmt|;
name|tmp_mem
operator|.
name|mm_node
operator|=
name|NULL
expr_stmt|;
name|placement
operator|.
name|fpfn
operator|=
literal|0
expr_stmt|;
name|placement
operator|.
name|lpfn
operator|=
literal|0
expr_stmt|;
name|placement
operator|.
name|num_placement
operator|=
literal|1
expr_stmt|;
name|placement
operator|.
name|placement
operator|=
operator|&
name|placements
expr_stmt|;
name|placement
operator|.
name|num_busy_placement
operator|=
literal|1
expr_stmt|;
name|placement
operator|.
name|busy_placement
operator|=
operator|&
name|placements
expr_stmt|;
name|placements
operator|=
name|TTM_PL_MASK_CACHING
operator||
name|TTM_PL_FLAG_TT
expr_stmt|;
name|r
operator|=
name|ttm_bo_mem_space
argument_list|(
name|bo
argument_list|,
operator|&
name|placement
argument_list|,
operator|&
name|tmp_mem
argument_list|,
name|interruptible
argument_list|,
name|no_wait_gpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
argument_list|)
condition|)
block|{
return|return
name|r
return|;
block|}
name|r
operator|=
name|ttm_bo_move_ttm
argument_list|(
name|bo
argument_list|,
name|true
argument_list|,
name|no_wait_gpu
argument_list|,
operator|&
name|tmp_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
argument_list|)
condition|)
block|{
goto|goto
name|out_cleanup
goto|;
block|}
name|r
operator|=
name|radeon_move_blit
argument_list|(
name|bo
argument_list|,
name|true
argument_list|,
name|no_wait_gpu
argument_list|,
name|new_mem
argument_list|,
name|old_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
argument_list|)
condition|)
block|{
goto|goto
name|out_cleanup
goto|;
block|}
name|out_cleanup
label|:
name|ttm_bo_mem_put
argument_list|(
name|bo
argument_list|,
operator|&
name|tmp_mem
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_bo_move
parameter_list|(
name|struct
name|ttm_buffer_object
modifier|*
name|bo
parameter_list|,
name|bool
name|evict
parameter_list|,
name|bool
name|interruptible
parameter_list|,
name|bool
name|no_wait_gpu
parameter_list|,
name|struct
name|ttm_mem_reg
modifier|*
name|new_mem
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|struct
name|ttm_mem_reg
modifier|*
name|old_mem
init|=
operator|&
name|bo
operator|->
name|mem
decl_stmt|;
name|int
name|r
decl_stmt|;
name|rdev
operator|=
name|radeon_get_rdev
argument_list|(
name|bo
operator|->
name|bdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_mem
operator|->
name|mem_type
operator|==
name|TTM_PL_SYSTEM
operator|&&
name|bo
operator|->
name|ttm
operator|==
name|NULL
condition|)
block|{
name|radeon_move_null
argument_list|(
name|bo
argument_list|,
name|new_mem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|old_mem
operator|->
name|mem_type
operator|==
name|TTM_PL_TT
operator|&&
name|new_mem
operator|->
name|mem_type
operator|==
name|TTM_PL_SYSTEM
operator|)
operator|||
operator|(
name|old_mem
operator|->
name|mem_type
operator|==
name|TTM_PL_SYSTEM
operator|&&
name|new_mem
operator|->
name|mem_type
operator|==
name|TTM_PL_TT
operator|)
condition|)
block|{
comment|/* bind is enough */
name|radeon_move_null
argument_list|(
name|bo
argument_list|,
name|new_mem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|rdev
operator|->
name|ring
index|[
name|radeon_copy_ring_index
argument_list|(
name|rdev
argument_list|)
index|]
operator|.
name|ready
operator|||
name|rdev
operator|->
name|asic
operator|->
name|copy
operator|.
name|copy
operator|==
name|NULL
condition|)
block|{
comment|/* use memcpy */
goto|goto
name|memcpy
goto|;
block|}
if|if
condition|(
name|old_mem
operator|->
name|mem_type
operator|==
name|TTM_PL_VRAM
operator|&&
name|new_mem
operator|->
name|mem_type
operator|==
name|TTM_PL_SYSTEM
condition|)
block|{
name|r
operator|=
name|radeon_move_vram_ram
argument_list|(
name|bo
argument_list|,
name|evict
argument_list|,
name|interruptible
argument_list|,
name|no_wait_gpu
argument_list|,
name|new_mem
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_mem
operator|->
name|mem_type
operator|==
name|TTM_PL_SYSTEM
operator|&&
name|new_mem
operator|->
name|mem_type
operator|==
name|TTM_PL_VRAM
condition|)
block|{
name|r
operator|=
name|radeon_move_ram_vram
argument_list|(
name|bo
argument_list|,
name|evict
argument_list|,
name|interruptible
argument_list|,
name|no_wait_gpu
argument_list|,
name|new_mem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|radeon_move_blit
argument_list|(
name|bo
argument_list|,
name|evict
argument_list|,
name|no_wait_gpu
argument_list|,
name|new_mem
argument_list|,
name|old_mem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
condition|)
block|{
name|memcpy
label|:
name|r
operator|=
name|ttm_bo_move_memcpy
argument_list|(
name|bo
argument_list|,
name|evict
argument_list|,
name|no_wait_gpu
argument_list|,
name|new_mem
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_ttm_io_mem_reserve
parameter_list|(
name|struct
name|ttm_bo_device
modifier|*
name|bdev
parameter_list|,
name|struct
name|ttm_mem_reg
modifier|*
name|mem
parameter_list|)
block|{
name|struct
name|ttm_mem_type_manager
modifier|*
name|man
init|=
operator|&
name|bdev
operator|->
name|man
index|[
name|mem
operator|->
name|mem_type
index|]
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|radeon_get_rdev
argument_list|(
name|bdev
argument_list|)
decl_stmt|;
name|mem
operator|->
name|bus
operator|.
name|addr
operator|=
name|NULL
expr_stmt|;
name|mem
operator|->
name|bus
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|mem
operator|->
name|bus
operator|.
name|size
operator|=
name|mem
operator|->
name|num_pages
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|mem
operator|->
name|bus
operator|.
name|base
operator|=
literal|0
expr_stmt|;
name|mem
operator|->
name|bus
operator|.
name|is_iomem
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|man
operator|->
name|flags
operator|&
name|TTM_MEMTYPE_FLAG_MAPPABLE
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
switch|switch
condition|(
name|mem
operator|->
name|mem_type
condition|)
block|{
case|case
name|TTM_PL_SYSTEM
case|:
comment|/* system memory */
return|return
literal|0
return|;
case|case
name|TTM_PL_TT
case|:
if|#
directive|if
name|__OS_HAS_AGP
if|if
condition|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_AGP
condition|)
block|{
comment|/* RADEON_IS_AGP is set only if AGP is active */
name|mem
operator|->
name|bus
operator|.
name|offset
operator|=
name|mem
operator|->
name|start
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|mem
operator|->
name|bus
operator|.
name|base
operator|=
name|rdev
operator|->
name|mc
operator|.
name|agp_base
expr_stmt|;
name|mem
operator|->
name|bus
operator|.
name|is_iomem
operator|=
operator|!
name|rdev
operator|->
name|ddev
operator|->
name|agp
operator|->
name|cant_use_aperture
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|TTM_PL_VRAM
case|:
name|mem
operator|->
name|bus
operator|.
name|offset
operator|=
name|mem
operator|->
name|start
operator|<<
name|PAGE_SHIFT
expr_stmt|;
comment|/* check if it's visible */
if|if
condition|(
operator|(
name|mem
operator|->
name|bus
operator|.
name|offset
operator|+
name|mem
operator|->
name|bus
operator|.
name|size
operator|)
operator|>
name|rdev
operator|->
name|mc
operator|.
name|visible_vram_size
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mem
operator|->
name|bus
operator|.
name|base
operator|=
name|rdev
operator|->
name|mc
operator|.
name|aper_base
expr_stmt|;
name|mem
operator|->
name|bus
operator|.
name|is_iomem
operator|=
name|true
expr_stmt|;
ifdef|#
directive|ifdef
name|__alpha__
comment|/* 		 * Alpha: use bus.addr to hold the ioremap() return, 		 * so we can modify bus.base below. 		 */
if|if
condition|(
name|mem
operator|->
name|placement
operator|&
name|TTM_PL_FLAG_WC
condition|)
name|mem
operator|->
name|bus
operator|.
name|addr
operator|=
name|ioremap_wc
argument_list|(
name|mem
operator|->
name|bus
operator|.
name|base
operator|+
name|mem
operator|->
name|bus
operator|.
name|offset
argument_list|,
name|mem
operator|->
name|bus
operator|.
name|size
argument_list|)
expr_stmt|;
else|else
name|mem
operator|->
name|bus
operator|.
name|addr
operator|=
name|ioremap_nocache
argument_list|(
name|mem
operator|->
name|bus
operator|.
name|base
operator|+
name|mem
operator|->
name|bus
operator|.
name|offset
argument_list|,
name|mem
operator|->
name|bus
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/* 		 * Alpha: Use just the bus offset plus 		 * the hose/domain memory base for bus.base. 		 * It then can be used to build PTEs for VRAM 		 * access, as done in ttm_bo_vm_fault(). 		 */
name|mem
operator|->
name|bus
operator|.
name|base
operator|=
operator|(
name|mem
operator|->
name|bus
operator|.
name|base
operator|&
literal|0x0ffffffffUL
operator|)
operator|+
name|rdev
operator|->
name|ddev
operator|->
name|hose
operator|->
name|dense_mem_base
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_ttm_io_mem_free
parameter_list|(
name|struct
name|ttm_bo_device
modifier|*
name|bdev
parameter_list|,
name|struct
name|ttm_mem_reg
modifier|*
name|mem
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|radeon_sync_obj_wait
parameter_list|(
name|void
modifier|*
name|sync_obj
parameter_list|,
name|bool
name|lazy
parameter_list|,
name|bool
name|interruptible
parameter_list|)
block|{
return|return
name|radeon_fence_wait
argument_list|(
operator|(
expr|struct
name|radeon_fence
operator|*
operator|)
name|sync_obj
argument_list|,
name|interruptible
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_sync_obj_flush
parameter_list|(
name|void
modifier|*
name|sync_obj
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_sync_obj_unref
parameter_list|(
name|void
modifier|*
modifier|*
name|sync_obj
parameter_list|)
block|{
name|radeon_fence_unref
argument_list|(
operator|(
expr|struct
name|radeon_fence
operator|*
operator|*
operator|)
name|sync_obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|radeon_sync_obj_ref
parameter_list|(
name|void
modifier|*
name|sync_obj
parameter_list|)
block|{
return|return
name|radeon_fence_ref
argument_list|(
operator|(
expr|struct
name|radeon_fence
operator|*
operator|)
name|sync_obj
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|radeon_sync_obj_signaled
parameter_list|(
name|void
modifier|*
name|sync_obj
parameter_list|)
block|{
return|return
name|radeon_fence_signaled
argument_list|(
operator|(
expr|struct
name|radeon_fence
operator|*
operator|)
name|sync_obj
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * TTM backend functions.  */
end_comment

begin_struct
struct|struct
name|radeon_ttm_tt
block|{
name|struct
name|ttm_dma_tt
name|ttm
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|u64
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|radeon_ttm_backend_bind
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|,
name|struct
name|ttm_mem_reg
modifier|*
name|bo_mem
parameter_list|)
block|{
name|struct
name|radeon_ttm_tt
modifier|*
name|gtt
init|=
operator|(
name|void
operator|*
operator|)
name|ttm
decl_stmt|;
name|int
name|r
decl_stmt|;
name|gtt
operator|->
name|offset
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|bo_mem
operator|->
name|start
operator|<<
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ttm
operator|->
name|num_pages
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"nothing to bind %lu pages for mreg %p back %p!\n"
argument_list|,
name|ttm
operator|->
name|num_pages
argument_list|,
name|bo_mem
argument_list|,
name|ttm
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|radeon_gart_bind
argument_list|(
name|gtt
operator|->
name|rdev
argument_list|,
name|gtt
operator|->
name|offset
argument_list|,
name|ttm
operator|->
name|num_pages
argument_list|,
name|ttm
operator|->
name|pages
argument_list|,
name|gtt
operator|->
name|ttm
operator|.
name|dma_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to bind %lu pages at 0x%08X\n"
argument_list|,
name|ttm
operator|->
name|num_pages
argument_list|,
operator|(
name|unsigned
operator|)
name|gtt
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_ttm_backend_unbind
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|)
block|{
name|struct
name|radeon_ttm_tt
modifier|*
name|gtt
init|=
operator|(
name|void
operator|*
operator|)
name|ttm
decl_stmt|;
name|radeon_gart_unbind
argument_list|(
name|gtt
operator|->
name|rdev
argument_list|,
name|gtt
operator|->
name|offset
argument_list|,
name|ttm
operator|->
name|num_pages
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_ttm_backend_destroy
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|)
block|{
name|struct
name|radeon_ttm_tt
modifier|*
name|gtt
init|=
operator|(
name|void
operator|*
operator|)
name|ttm
decl_stmt|;
name|ttm_dma_tt_fini
argument_list|(
operator|&
name|gtt
operator|->
name|ttm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gtt
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ttm_backend_func
name|radeon_backend_func
init|=
block|{
operator|.
name|bind
operator|=
operator|&
name|radeon_ttm_backend_bind
block|,
operator|.
name|unbind
operator|=
operator|&
name|radeon_ttm_backend_unbind
block|,
operator|.
name|destroy
operator|=
operator|&
name|radeon_ttm_backend_destroy
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|ttm_tt
modifier|*
name|radeon_ttm_tt_create
parameter_list|(
name|struct
name|ttm_bo_device
modifier|*
name|bdev
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|uint32_t
name|page_flags
parameter_list|,
name|vm_page_t
name|dummy_read_page
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|struct
name|radeon_ttm_tt
modifier|*
name|gtt
decl_stmt|;
name|rdev
operator|=
name|radeon_get_rdev
argument_list|(
name|bdev
argument_list|)
expr_stmt|;
if|#
directive|if
name|__OS_HAS_AGP
if|if
condition|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_AGP
condition|)
block|{
return|return
name|ttm_agp_tt_create
argument_list|(
name|bdev
argument_list|,
name|rdev
operator|->
name|ddev
operator|->
name|agp
operator|->
name|bridge
argument_list|,
name|size
argument_list|,
name|page_flags
argument_list|,
name|dummy_read_page
argument_list|)
return|;
block|}
endif|#
directive|endif
name|gtt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|radeon_ttm_tt
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtt
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|gtt
operator|->
name|ttm
operator|.
name|ttm
operator|.
name|func
operator|=
operator|&
name|radeon_backend_func
expr_stmt|;
name|gtt
operator|->
name|rdev
operator|=
name|rdev
expr_stmt|;
if|if
condition|(
name|ttm_dma_tt_init
argument_list|(
operator|&
name|gtt
operator|->
name|ttm
argument_list|,
name|bdev
argument_list|,
name|size
argument_list|,
name|page_flags
argument_list|,
name|dummy_read_page
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|gtt
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|gtt
operator|->
name|ttm
operator|.
name|ttm
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_ttm_tt_populate
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|struct
name|radeon_ttm_tt
modifier|*
name|gtt
init|=
operator|(
name|void
operator|*
operator|)
name|ttm
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|bool
name|slave
init|=
operator|!
operator|!
operator|(
name|ttm
operator|->
name|page_flags
operator|&
name|TTM_PAGE_FLAG_SG
operator|)
decl_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
if|if
condition|(
name|ttm
operator|->
name|state
operator|!=
name|tt_unpopulated
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
if|if
condition|(
name|slave
operator|&&
name|ttm
operator|->
name|sg
condition|)
block|{
name|drm_prime_sg_to_page_addr_arrays
argument_list|(
name|ttm
operator|->
name|sg
argument_list|,
name|ttm
operator|->
name|pages
argument_list|,
name|gtt
operator|->
name|ttm
operator|.
name|dma_address
argument_list|,
name|ttm
operator|->
name|num_pages
argument_list|)
expr_stmt|;
name|ttm
operator|->
name|state
operator|=
name|tt_unbound
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* FREEBSD_WIP */
name|rdev
operator|=
name|radeon_get_rdev
argument_list|(
name|ttm
operator|->
name|bdev
argument_list|)
expr_stmt|;
if|#
directive|if
name|__OS_HAS_AGP
if|if
condition|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_AGP
condition|)
block|{
return|return
name|ttm_agp_tt_populate
argument_list|(
name|ttm
argument_list|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_SWIOTLB
if|if
condition|(
name|swiotlb_nr_tbl
argument_list|()
condition|)
block|{
return|return
name|ttm_dma_populate
argument_list|(
operator|&
name|gtt
operator|->
name|ttm
argument_list|,
name|rdev
operator|->
name|dev
argument_list|)
return|;
block|}
endif|#
directive|endif
name|r
operator|=
name|ttm_pool_populate
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
return|return
name|r
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ttm
operator|->
name|num_pages
condition|;
name|i
operator|++
control|)
block|{
name|gtt
operator|->
name|ttm
operator|.
name|dma_address
index|[
name|i
index|]
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|ttm
operator|->
name|pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|gtt
operator|->
name|ttm
operator|.
name|dma_address
index|[
name|i
index|]
operator|=
name|pci_map_page
argument_list|(
name|rdev
operator|->
name|pdev
argument_list|,
name|ttm
operator|->
name|pages
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_dma_mapping_error
argument_list|(
name|rdev
operator|->
name|pdev
argument_list|,
name|gtt
operator|->
name|ttm
operator|.
name|dma_address
index|[
name|i
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
operator|--
name|i
condition|)
block|{
name|pci_unmap_page
argument_list|(
name|rdev
operator|->
name|pdev
argument_list|,
name|gtt
operator|->
name|ttm
operator|.
name|dma_address
index|[
name|i
index|]
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
name|gtt
operator|->
name|ttm
operator|.
name|dma_address
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ttm_pool_unpopulate
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
endif|#
directive|endif
comment|/* FREEBSD_WIP */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_ttm_tt_unpopulate
parameter_list|(
name|struct
name|ttm_tt
modifier|*
name|ttm
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|struct
name|radeon_ttm_tt
modifier|*
name|gtt
init|=
operator|(
name|void
operator|*
operator|)
name|ttm
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bool
name|slave
init|=
operator|!
operator|!
operator|(
name|ttm
operator|->
name|page_flags
operator|&
name|TTM_PAGE_FLAG_SG
operator|)
decl_stmt|;
if|if
condition|(
name|slave
condition|)
return|return;
name|rdev
operator|=
name|radeon_get_rdev
argument_list|(
name|ttm
operator|->
name|bdev
argument_list|)
expr_stmt|;
if|#
directive|if
name|__OS_HAS_AGP
if|if
condition|(
name|rdev
operator|->
name|flags
operator|&
name|RADEON_IS_AGP
condition|)
block|{
name|ttm_agp_tt_unpopulate
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_SWIOTLB
if|if
condition|(
name|swiotlb_nr_tbl
argument_list|()
condition|)
block|{
name|ttm_dma_unpopulate
argument_list|(
operator|&
name|gtt
operator|->
name|ttm
argument_list|,
name|rdev
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ttm
operator|->
name|num_pages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gtt
operator|->
name|ttm
operator|.
name|dma_address
index|[
name|i
index|]
condition|)
block|{
name|gtt
operator|->
name|ttm
operator|.
name|dma_address
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_WIP
name|pci_unmap_page
argument_list|(
name|rdev
operator|->
name|pdev
argument_list|,
name|gtt
operator|->
name|ttm
operator|.
name|dma_address
index|[
name|i
index|]
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_WIP */
block|}
block|}
name|ttm_pool_unpopulate
argument_list|(
name|ttm
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ttm_bo_driver
name|radeon_bo_driver
init|=
block|{
operator|.
name|ttm_tt_create
operator|=
operator|&
name|radeon_ttm_tt_create
block|,
operator|.
name|ttm_tt_populate
operator|=
operator|&
name|radeon_ttm_tt_populate
block|,
operator|.
name|ttm_tt_unpopulate
operator|=
operator|&
name|radeon_ttm_tt_unpopulate
block|,
operator|.
name|invalidate_caches
operator|=
operator|&
name|radeon_invalidate_caches
block|,
operator|.
name|init_mem_type
operator|=
operator|&
name|radeon_init_mem_type
block|,
operator|.
name|evict_flags
operator|=
operator|&
name|radeon_evict_flags
block|,
operator|.
name|move
operator|=
operator|&
name|radeon_bo_move
block|,
operator|.
name|verify_access
operator|=
operator|&
name|radeon_verify_access
block|,
operator|.
name|sync_obj_signaled
operator|=
operator|&
name|radeon_sync_obj_signaled
block|,
operator|.
name|sync_obj_wait
operator|=
operator|&
name|radeon_sync_obj_wait
block|,
operator|.
name|sync_obj_flush
operator|=
operator|&
name|radeon_sync_obj_flush
block|,
operator|.
name|sync_obj_unref
operator|=
operator|&
name|radeon_sync_obj_unref
block|,
operator|.
name|sync_obj_ref
operator|=
operator|&
name|radeon_sync_obj_ref
block|,
operator|.
name|move_notify
operator|=
operator|&
name|radeon_bo_move_notify
block|,
operator|.
name|fault_reserve_notify
operator|=
operator|&
name|radeon_bo_fault_reserve_notify
block|,
operator|.
name|io_mem_reserve
operator|=
operator|&
name|radeon_ttm_io_mem_reserve
block|,
operator|.
name|io_mem_free
operator|=
operator|&
name|radeon_ttm_io_mem_free
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|radeon_ttm_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|radeon_ttm_global_init
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
return|return
name|r
return|;
block|}
comment|/* No others user of address space so set it to 0 */
name|r
operator|=
name|ttm_bo_device_init
argument_list|(
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bdev
argument_list|,
name|rdev
operator|->
name|mman
operator|.
name|bo_global_ref
operator|.
name|ref
operator|.
name|object
argument_list|,
operator|&
name|radeon_bo_driver
argument_list|,
name|DRM_FILE_PAGE_OFFSET
argument_list|,
name|rdev
operator|->
name|need_dma32
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed initializing buffer object driver(%d).\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|rdev
operator|->
name|mman
operator|.
name|initialized
operator|=
name|true
expr_stmt|;
name|rdev
operator|->
name|ddev
operator|->
name|drm_ttm_bdev
operator|=
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bdev
expr_stmt|;
name|r
operator|=
name|ttm_bo_init_mm
argument_list|(
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bdev
argument_list|,
name|TTM_PL_VRAM
argument_list|,
name|rdev
operator|->
name|mc
operator|.
name|real_vram_size
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed initializing VRAM heap.\n"
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|r
operator|=
name|radeon_bo_create
argument_list|(
name|rdev
argument_list|,
literal|256
operator|*
literal|1024
argument_list|,
name|PAGE_SIZE
argument_list|,
name|true
argument_list|,
name|RADEON_GEM_DOMAIN_VRAM
argument_list|,
name|NULL
argument_list|,
operator|&
name|rdev
operator|->
name|stollen_vga_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
return|return
name|r
return|;
block|}
name|r
operator|=
name|radeon_bo_reserve
argument_list|(
name|rdev
operator|->
name|stollen_vga_memory
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|radeon_bo_unref
argument_list|(
operator|&
name|rdev
operator|->
name|stollen_vga_memory
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|r
operator|=
name|radeon_bo_pin
argument_list|(
name|rdev
operator|->
name|stollen_vga_memory
argument_list|,
name|RADEON_GEM_DOMAIN_VRAM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|radeon_bo_unreserve
argument_list|(
name|rdev
operator|->
name|stollen_vga_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|radeon_bo_unref
argument_list|(
operator|&
name|rdev
operator|->
name|stollen_vga_memory
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|DRM_INFO
argument_list|(
literal|"radeon: %uM of VRAM memory ready\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|rdev
operator|->
name|mc
operator|.
name|real_vram_size
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|ttm_bo_init_mm
argument_list|(
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bdev
argument_list|,
name|TTM_PL_TT
argument_list|,
name|rdev
operator|->
name|mc
operator|.
name|gtt_size
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed initializing GTT heap.\n"
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|DRM_INFO
argument_list|(
literal|"radeon: %uM of GTT memory ready.\n"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|rdev
operator|->
name|mc
operator|.
name|gtt_size
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|radeon_ttm_debugfs_init
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Failed to init debugfs\n"
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|radeon_ttm_fini
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|rdev
operator|->
name|mman
operator|.
name|initialized
condition|)
return|return;
if|if
condition|(
name|rdev
operator|->
name|stollen_vga_memory
condition|)
block|{
name|r
operator|=
name|radeon_bo_reserve
argument_list|(
name|rdev
operator|->
name|stollen_vga_memory
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|radeon_bo_unpin
argument_list|(
name|rdev
operator|->
name|stollen_vga_memory
argument_list|)
expr_stmt|;
name|radeon_bo_unreserve
argument_list|(
name|rdev
operator|->
name|stollen_vga_memory
argument_list|)
expr_stmt|;
block|}
name|radeon_bo_unref
argument_list|(
operator|&
name|rdev
operator|->
name|stollen_vga_memory
argument_list|)
expr_stmt|;
block|}
name|ttm_bo_clean_mm
argument_list|(
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bdev
argument_list|,
name|TTM_PL_VRAM
argument_list|)
expr_stmt|;
name|ttm_bo_clean_mm
argument_list|(
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bdev
argument_list|,
name|TTM_PL_TT
argument_list|)
expr_stmt|;
name|ttm_bo_device_release
argument_list|(
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bdev
argument_list|)
expr_stmt|;
name|radeon_gart_fini
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|radeon_ttm_global_fini
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|rdev
operator|->
name|mman
operator|.
name|initialized
operator|=
name|false
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"radeon: ttm finalized\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* this should only be called at bootup or when userspace  * isn't running */
end_comment

begin_function
name|void
name|radeon_ttm_set_active_vram_size
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|u64
name|size
parameter_list|)
block|{
name|struct
name|ttm_mem_type_manager
modifier|*
name|man
decl_stmt|;
if|if
condition|(
operator|!
name|rdev
operator|->
name|mman
operator|.
name|initialized
condition|)
return|return;
name|man
operator|=
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bdev
operator|.
name|man
index|[
name|TTM_PL_VRAM
index|]
expr_stmt|;
comment|/* this just adjusts TTM size idea, which sets lpfn to the correct value */
name|man
operator|->
name|size
operator|=
name|size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREEBSD_WIP
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|vm_operations_struct
name|radeon_ttm_vm_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|vm_operations_struct
modifier|*
name|ttm_vm_ops
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|radeon_ttm_fault
parameter_list|(
name|struct
name|vm_area_struct
modifier|*
name|vma
parameter_list|,
name|struct
name|vm_fault
modifier|*
name|vmf
parameter_list|)
block|{
name|struct
name|ttm_buffer_object
modifier|*
name|bo
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|int
name|r
decl_stmt|;
name|bo
operator|=
operator|(
expr|struct
name|ttm_buffer_object
operator|*
operator|)
name|vma
operator|->
name|vm_private_data
expr_stmt|;
if|if
condition|(
name|bo
operator|==
name|NULL
condition|)
block|{
return|return
name|VM_FAULT_NOPAGE
return|;
block|}
name|rdev
operator|=
name|radeon_get_rdev
argument_list|(
name|bo
operator|->
name|bdev
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mclk_lock
argument_list|)
expr_stmt|;
name|r
operator|=
name|ttm_vm_ops
operator|->
name|fault
argument_list|(
name|vma
argument_list|,
name|vmf
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|rdev
operator|->
name|pm
operator|.
name|mclk_lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|radeon_mmap
parameter_list|(
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|struct
name|vm_area_struct
modifier|*
name|vma
parameter_list|)
block|{
name|struct
name|drm_file
modifier|*
name|file_priv
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|vma
operator|->
name|vm_pgoff
operator|<
name|DRM_FILE_PAGE_OFFSET
argument_list|)
condition|)
block|{
return|return
name|drm_mmap
argument_list|(
name|filp
argument_list|,
name|vma
argument_list|)
return|;
block|}
name|file_priv
operator|=
name|filp
operator|->
name|private_data
expr_stmt|;
name|rdev
operator|=
name|file_priv
operator|->
name|minor
operator|->
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|rdev
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
name|r
operator|=
name|ttm_bo_mmap
argument_list|(
name|filp
argument_list|,
name|vma
argument_list|,
operator|&
name|rdev
operator|->
name|mman
operator|.
name|bdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
operator|!=
literal|0
argument_list|)
condition|)
block|{
return|return
name|r
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|ttm_vm_ops
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|ttm_vm_ops
operator|=
name|vma
operator|->
name|vm_ops
expr_stmt|;
name|radeon_ttm_vm_ops
operator|=
operator|*
name|ttm_vm_ops
expr_stmt|;
name|radeon_ttm_vm_ops
operator|.
name|fault
operator|=
operator|&
name|radeon_ttm_fault
expr_stmt|;
block|}
name|vma
operator|->
name|vm_ops
operator|=
operator|&
name|radeon_ttm_vm_ops
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREEBSD_WIP */
end_comment

begin_define
define|#
directive|define
name|RADEON_DEBUGFS_MEM_TYPES
value|2
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DEBUG_FS
argument_list|)
end_if

begin_function
specifier|static
name|int
name|radeon_mm_dump_table
parameter_list|(
name|struct
name|seq_file
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|drm_info_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|drm_info_node
operator|*
operator|)
name|m
operator|->
name|private
decl_stmt|;
name|struct
name|drm_mm
modifier|*
name|mm
init|=
operator|(
expr|struct
name|drm_mm
operator|*
operator|)
name|node
operator|->
name|info_ent
operator|->
name|data
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|node
operator|->
name|minor
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|ttm_bo_global
modifier|*
name|glob
init|=
name|rdev
operator|->
name|mman
operator|.
name|bdev
operator|.
name|glob
decl_stmt|;
name|spin_lock
argument_list|(
operator|&
name|glob
operator|->
name|lru_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_mm_dump_table
argument_list|(
name|m
argument_list|,
name|mm
argument_list|)
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|glob
operator|->
name|lru_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|radeon_ttm_debugfs_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_DEBUG_FS
argument_list|)
specifier|static
name|struct
name|drm_info_list
name|radeon_mem_types_list
index|[
name|RADEON_DEBUGFS_MEM_TYPES
operator|+
literal|2
index|]
decl_stmt|;
specifier|static
name|char
name|radeon_mem_types_names
index|[
name|RADEON_DEBUGFS_MEM_TYPES
operator|+
literal|2
index|]
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_DEBUGFS_MEM_TYPES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|radeon_mem_types_names
index|[
name|i
index|]
argument_list|,
literal|"radeon_vram_mm"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|radeon_mem_types_names
index|[
name|i
index|]
argument_list|,
literal|"radeon_gtt_mm"
argument_list|)
expr_stmt|;
name|radeon_mem_types_list
index|[
name|i
index|]
operator|.
name|name
operator|=
name|radeon_mem_types_names
index|[
name|i
index|]
expr_stmt|;
name|radeon_mem_types_list
index|[
name|i
index|]
operator|.
name|show
operator|=
operator|&
name|radeon_mm_dump_table
expr_stmt|;
name|radeon_mem_types_list
index|[
name|i
index|]
operator|.
name|driver_features
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|radeon_mem_types_list
index|[
name|i
index|]
operator|.
name|data
operator|=
name|rdev
operator|->
name|mman
operator|.
name|bdev
operator|.
name|man
index|[
name|TTM_PL_VRAM
index|]
operator|.
name|priv
expr_stmt|;
else|else
name|radeon_mem_types_list
index|[
name|i
index|]
operator|.
name|data
operator|=
name|rdev
operator|->
name|mman
operator|.
name|bdev
operator|.
name|man
index|[
name|TTM_PL_TT
index|]
operator|.
name|priv
expr_stmt|;
block|}
comment|/* Add ttm page pool to debugfs */
name|sprintf
argument_list|(
name|radeon_mem_types_names
index|[
name|i
index|]
argument_list|,
literal|"ttm_page_pool"
argument_list|)
expr_stmt|;
name|radeon_mem_types_list
index|[
name|i
index|]
operator|.
name|name
operator|=
name|radeon_mem_types_names
index|[
name|i
index|]
expr_stmt|;
name|radeon_mem_types_list
index|[
name|i
index|]
operator|.
name|show
operator|=
operator|&
name|ttm_page_alloc_debugfs
expr_stmt|;
name|radeon_mem_types_list
index|[
name|i
index|]
operator|.
name|driver_features
operator|=
literal|0
expr_stmt|;
name|radeon_mem_types_list
index|[
name|i
operator|++
index|]
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_SWIOTLB
if|if
condition|(
name|swiotlb_nr_tbl
argument_list|()
condition|)
block|{
name|sprintf
argument_list|(
name|radeon_mem_types_names
index|[
name|i
index|]
argument_list|,
literal|"ttm_dma_page_pool"
argument_list|)
expr_stmt|;
name|radeon_mem_types_list
index|[
name|i
index|]
operator|.
name|name
operator|=
name|radeon_mem_types_names
index|[
name|i
index|]
expr_stmt|;
name|radeon_mem_types_list
index|[
name|i
index|]
operator|.
name|show
operator|=
operator|&
name|ttm_dma_page_alloc_debugfs
expr_stmt|;
name|radeon_mem_types_list
index|[
name|i
index|]
operator|.
name|driver_features
operator|=
literal|0
expr_stmt|;
name|radeon_mem_types_list
index|[
name|i
operator|++
index|]
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|radeon_debugfs_add_files
argument_list|(
name|rdev
argument_list|,
name|radeon_mem_types_list
argument_list|,
name|i
argument_list|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

end_unit

