begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008 Advanced Micro Devices, Inc.  * Copyright 2008 Red Hat Inc.  * Copyright 2009 Christian KÃ¶nig.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *  * Authors: Christian KÃ¶nig  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/radeon/radeon_drm.h>
end_include

begin_include
include|#
directive|include
file|"radeon.h"
end_include

begin_include
include|#
directive|include
file|"radeon_asic.h"
end_include

begin_include
include|#
directive|include
file|"r600d.h"
end_include

begin_include
include|#
directive|include
file|"atom.h"
end_include

begin_comment
comment|/*  * HDMI color format  */
end_comment

begin_enum
enum|enum
name|r600_hdmi_color_format
block|{
name|RGB
init|=
literal|0
block|,
name|YCC_422
init|=
literal|1
block|,
name|YCC_444
init|=
literal|2
block|}
enum|;
end_enum

begin_comment
comment|/*  * IEC60958 status bits  */
end_comment

begin_enum
enum|enum
name|r600_hdmi_iec_status_bits
block|{
name|AUDIO_STATUS_DIG_ENABLE
init|=
literal|0x01
block|,
name|AUDIO_STATUS_V
init|=
literal|0x02
block|,
name|AUDIO_STATUS_VCFG
init|=
literal|0x04
block|,
name|AUDIO_STATUS_EMPHASIS
init|=
literal|0x08
block|,
name|AUDIO_STATUS_COPYRIGHT
init|=
literal|0x10
block|,
name|AUDIO_STATUS_NONAUDIO
init|=
literal|0x20
block|,
name|AUDIO_STATUS_PROFESSIONAL
init|=
literal|0x40
block|,
name|AUDIO_STATUS_LEVEL
init|=
literal|0x80
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|radeon_hdmi_acr
name|r600_hdmi_predefined_acr
index|[]
init|=
block|{
comment|/*	     32kHz	  44.1kHz	48kHz    */
comment|/* Clock      N     CTS      N     CTS      N     CTS */
block|{
literal|25174
block|,
literal|4576
block|,
literal|28125
block|,
literal|7007
block|,
literal|31250
block|,
literal|6864
block|,
literal|28125
block|}
block|,
comment|/*  25,20/1.001 MHz */
block|{
literal|25200
block|,
literal|4096
block|,
literal|25200
block|,
literal|6272
block|,
literal|28000
block|,
literal|6144
block|,
literal|25200
block|}
block|,
comment|/*  25.20       MHz */
block|{
literal|27000
block|,
literal|4096
block|,
literal|27000
block|,
literal|6272
block|,
literal|30000
block|,
literal|6144
block|,
literal|27000
block|}
block|,
comment|/*  27.00       MHz */
block|{
literal|27027
block|,
literal|4096
block|,
literal|27027
block|,
literal|6272
block|,
literal|30030
block|,
literal|6144
block|,
literal|27027
block|}
block|,
comment|/*  27.00*1.001 MHz */
block|{
literal|54000
block|,
literal|4096
block|,
literal|54000
block|,
literal|6272
block|,
literal|60000
block|,
literal|6144
block|,
literal|54000
block|}
block|,
comment|/*  54.00       MHz */
block|{
literal|54054
block|,
literal|4096
block|,
literal|54054
block|,
literal|6272
block|,
literal|60060
block|,
literal|6144
block|,
literal|54054
block|}
block|,
comment|/*  54.00*1.001 MHz */
block|{
literal|74175
block|,
literal|11648
block|,
literal|210937
block|,
literal|17836
block|,
literal|234375
block|,
literal|11648
block|,
literal|140625
block|}
block|,
comment|/*  74.25/1.001 MHz */
block|{
literal|74250
block|,
literal|4096
block|,
literal|74250
block|,
literal|6272
block|,
literal|82500
block|,
literal|6144
block|,
literal|74250
block|}
block|,
comment|/*  74.25       MHz */
block|{
literal|148351
block|,
literal|11648
block|,
literal|421875
block|,
literal|8918
block|,
literal|234375
block|,
literal|5824
block|,
literal|140625
block|}
block|,
comment|/* 148.50/1.001 MHz */
block|{
literal|148500
block|,
literal|4096
block|,
literal|148500
block|,
literal|6272
block|,
literal|165000
block|,
literal|6144
block|,
literal|148500
block|}
block|,
comment|/* 148.50       MHz */
block|{
literal|0
block|,
literal|4096
block|,
literal|0
block|,
literal|6272
block|,
literal|0
block|,
literal|6144
block|,
literal|0
block|}
comment|/* Other */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * calculate CTS value if it's not found in the table  */
end_comment

begin_function
specifier|static
name|void
name|r600_hdmi_calc_cts
parameter_list|(
name|uint32_t
name|clock
parameter_list|,
name|int
modifier|*
name|CTS
parameter_list|,
name|int
name|N
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
if|if
condition|(
operator|*
name|CTS
operator|==
literal|0
condition|)
operator|*
name|CTS
operator|=
name|clock
operator|*
name|N
operator|/
operator|(
literal|128
operator|*
name|freq
operator|)
operator|*
literal|1000
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"Using ACR timing N=%d CTS=%d for frequency %d\n"
argument_list|,
name|N
argument_list|,
operator|*
name|CTS
argument_list|,
name|freq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|radeon_hdmi_acr
name|r600_hdmi_acr
parameter_list|(
name|uint32_t
name|clock
parameter_list|)
block|{
name|struct
name|radeon_hdmi_acr
name|res
decl_stmt|;
name|u8
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|r600_hdmi_predefined_acr
index|[
name|i
index|]
operator|.
name|clock
operator|!=
name|clock
operator|&&
name|r600_hdmi_predefined_acr
index|[
name|i
index|]
operator|.
name|clock
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|res
operator|=
name|r600_hdmi_predefined_acr
index|[
name|i
index|]
expr_stmt|;
comment|/* In case some CTS are missing */
name|r600_hdmi_calc_cts
argument_list|(
name|clock
argument_list|,
operator|&
name|res
operator|.
name|cts_32khz
argument_list|,
name|res
operator|.
name|n_32khz
argument_list|,
literal|32000
argument_list|)
expr_stmt|;
name|r600_hdmi_calc_cts
argument_list|(
name|clock
argument_list|,
operator|&
name|res
operator|.
name|cts_44_1khz
argument_list|,
name|res
operator|.
name|n_44_1khz
argument_list|,
literal|44100
argument_list|)
expr_stmt|;
name|r600_hdmi_calc_cts
argument_list|(
name|clock
argument_list|,
operator|&
name|res
operator|.
name|cts_48khz
argument_list|,
name|res
operator|.
name|n_48khz
argument_list|,
literal|48000
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * update the N and CTS parameters for a given pixel clock rate  */
end_comment

begin_function
specifier|static
name|void
name|r600_hdmi_update_ACR
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|uint32_t
name|clock
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_hdmi_acr
name|acr
init|=
name|r600_hdmi_acr
argument_list|(
name|clock
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|uint32_t
name|offset
init|=
name|dig
operator|->
name|afmt
operator|->
name|offset
decl_stmt|;
name|WREG32
argument_list|(
name|HDMI0_ACR_32_0
operator|+
name|offset
argument_list|,
name|HDMI0_ACR_CTS_32
argument_list|(
name|acr
operator|.
name|cts_32khz
argument_list|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_ACR_32_1
operator|+
name|offset
argument_list|,
name|acr
operator|.
name|n_32khz
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_ACR_44_0
operator|+
name|offset
argument_list|,
name|HDMI0_ACR_CTS_44
argument_list|(
name|acr
operator|.
name|cts_44_1khz
argument_list|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_ACR_44_1
operator|+
name|offset
argument_list|,
name|acr
operator|.
name|n_44_1khz
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_ACR_48_0
operator|+
name|offset
argument_list|,
name|HDMI0_ACR_CTS_48
argument_list|(
name|acr
operator|.
name|cts_48khz
argument_list|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_ACR_48_1
operator|+
name|offset
argument_list|,
name|acr
operator|.
name|n_48khz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * calculate the crc for a given info frame  */
end_comment

begin_function
specifier|static
name|void
name|r600_hdmi_infoframe_checksum
parameter_list|(
name|uint8_t
name|packetType
parameter_list|,
name|uint8_t
name|versionNumber
parameter_list|,
name|uint8_t
name|length
parameter_list|,
name|uint8_t
modifier|*
name|frame
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|frame
index|[
literal|0
index|]
operator|=
name|packetType
operator|+
name|versionNumber
operator|+
name|length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|length
condition|;
name|i
operator|++
control|)
name|frame
index|[
literal|0
index|]
operator|+=
name|frame
index|[
name|i
index|]
expr_stmt|;
name|frame
index|[
literal|0
index|]
operator|=
literal|0x100
operator|-
name|frame
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * build a HDMI Video Info Frame  */
end_comment

begin_function
specifier|static
name|void
name|r600_hdmi_videoinfoframe
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|enum
name|r600_hdmi_color_format
name|color_format
parameter_list|,
name|int
name|active_information_present
parameter_list|,
name|uint8_t
name|active_format_aspect_ratio
parameter_list|,
name|uint8_t
name|scan_information
parameter_list|,
name|uint8_t
name|colorimetry
parameter_list|,
name|uint8_t
name|ex_colorimetry
parameter_list|,
name|uint8_t
name|quantization
parameter_list|,
name|int
name|ITC
parameter_list|,
name|uint8_t
name|picture_aspect_ratio
parameter_list|,
name|uint8_t
name|video_format_identification
parameter_list|,
name|uint8_t
name|pixel_repetition
parameter_list|,
name|uint8_t
name|non_uniform_picture_scaling
parameter_list|,
name|uint8_t
name|bar_info_data_valid
parameter_list|,
name|uint16_t
name|top_bar
parameter_list|,
name|uint16_t
name|bottom_bar
parameter_list|,
name|uint16_t
name|left_bar
parameter_list|,
name|uint16_t
name|right_bar
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|uint32_t
name|offset
init|=
name|dig
operator|->
name|afmt
operator|->
name|offset
decl_stmt|;
name|uint8_t
name|frame
index|[
literal|14
index|]
decl_stmt|;
name|frame
index|[
literal|0x0
index|]
operator|=
literal|0
expr_stmt|;
name|frame
index|[
literal|0x1
index|]
operator|=
operator|(
name|scan_information
operator|&
literal|0x3
operator|)
operator||
operator|(
operator|(
name|bar_info_data_valid
operator|&
literal|0x3
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|active_information_present
operator|&
literal|0x1
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|color_format
operator|&
literal|0x3
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
name|frame
index|[
literal|0x2
index|]
operator|=
operator|(
name|active_format_aspect_ratio
operator|&
literal|0xF
operator|)
operator||
operator|(
operator|(
name|picture_aspect_ratio
operator|&
literal|0x3
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|colorimetry
operator|&
literal|0x3
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
name|frame
index|[
literal|0x3
index|]
operator|=
operator|(
name|non_uniform_picture_scaling
operator|&
literal|0x3
operator|)
operator||
operator|(
operator|(
name|quantization
operator|&
literal|0x3
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|ex_colorimetry
operator|&
literal|0x7
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|ITC
operator|&
literal|0x1
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
name|frame
index|[
literal|0x4
index|]
operator|=
operator|(
name|video_format_identification
operator|&
literal|0x7F
operator|)
expr_stmt|;
name|frame
index|[
literal|0x5
index|]
operator|=
operator|(
name|pixel_repetition
operator|&
literal|0xF
operator|)
expr_stmt|;
name|frame
index|[
literal|0x6
index|]
operator|=
operator|(
name|top_bar
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|frame
index|[
literal|0x7
index|]
operator|=
operator|(
name|top_bar
operator|>>
literal|8
operator|)
expr_stmt|;
name|frame
index|[
literal|0x8
index|]
operator|=
operator|(
name|bottom_bar
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|frame
index|[
literal|0x9
index|]
operator|=
operator|(
name|bottom_bar
operator|>>
literal|8
operator|)
expr_stmt|;
name|frame
index|[
literal|0xA
index|]
operator|=
operator|(
name|left_bar
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|frame
index|[
literal|0xB
index|]
operator|=
operator|(
name|left_bar
operator|>>
literal|8
operator|)
expr_stmt|;
name|frame
index|[
literal|0xC
index|]
operator|=
operator|(
name|right_bar
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|frame
index|[
literal|0xD
index|]
operator|=
operator|(
name|right_bar
operator|>>
literal|8
operator|)
expr_stmt|;
name|r600_hdmi_infoframe_checksum
argument_list|(
literal|0x82
argument_list|,
literal|0x02
argument_list|,
literal|0x0D
argument_list|,
name|frame
argument_list|)
expr_stmt|;
comment|/* Our header values (type, version, length) should be alright, Intel 	 * is using the same. Checksum function also seems to be OK, it works 	 * fine for audio infoframe. However calculated value is always lower 	 * by 2 in comparison to fglrx. It breaks displaying anything in case 	 * of TVs that strictly check the checksum. Hack it manually here to 	 * workaround this issue. */
name|frame
index|[
literal|0x0
index|]
operator|+=
literal|2
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_AVI_INFO0
operator|+
name|offset
argument_list|,
name|frame
index|[
literal|0x0
index|]
operator||
operator|(
name|frame
index|[
literal|0x1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|frame
index|[
literal|0x2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|frame
index|[
literal|0x3
index|]
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_AVI_INFO1
operator|+
name|offset
argument_list|,
name|frame
index|[
literal|0x4
index|]
operator||
operator|(
name|frame
index|[
literal|0x5
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|frame
index|[
literal|0x6
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|frame
index|[
literal|0x7
index|]
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_AVI_INFO2
operator|+
name|offset
argument_list|,
name|frame
index|[
literal|0x8
index|]
operator||
operator|(
name|frame
index|[
literal|0x9
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|frame
index|[
literal|0xA
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|frame
index|[
literal|0xB
index|]
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_AVI_INFO3
operator|+
name|offset
argument_list|,
name|frame
index|[
literal|0xC
index|]
operator||
operator|(
name|frame
index|[
literal|0xD
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * build a Audio Info Frame  */
end_comment

begin_function
specifier|static
name|void
name|r600_hdmi_audioinfoframe
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|uint8_t
name|channel_count
parameter_list|,
name|uint8_t
name|coding_type
parameter_list|,
name|uint8_t
name|sample_size
parameter_list|,
name|uint8_t
name|sample_frequency
parameter_list|,
name|uint8_t
name|format
parameter_list|,
name|uint8_t
name|channel_allocation
parameter_list|,
name|uint8_t
name|level_shift
parameter_list|,
name|int
name|downmix_inhibit
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|uint32_t
name|offset
init|=
name|dig
operator|->
name|afmt
operator|->
name|offset
decl_stmt|;
name|uint8_t
name|frame
index|[
literal|11
index|]
decl_stmt|;
name|frame
index|[
literal|0x0
index|]
operator|=
literal|0
expr_stmt|;
name|frame
index|[
literal|0x1
index|]
operator|=
operator|(
name|channel_count
operator|&
literal|0x7
operator|)
operator||
operator|(
operator|(
name|coding_type
operator|&
literal|0xF
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|frame
index|[
literal|0x2
index|]
operator|=
operator|(
name|sample_size
operator|&
literal|0x3
operator|)
operator||
operator|(
operator|(
name|sample_frequency
operator|&
literal|0x7
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|frame
index|[
literal|0x3
index|]
operator|=
name|format
expr_stmt|;
name|frame
index|[
literal|0x4
index|]
operator|=
name|channel_allocation
expr_stmt|;
name|frame
index|[
literal|0x5
index|]
operator|=
operator|(
operator|(
name|level_shift
operator|&
literal|0xF
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|downmix_inhibit
operator|&
literal|0x1
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
name|frame
index|[
literal|0x6
index|]
operator|=
literal|0
expr_stmt|;
name|frame
index|[
literal|0x7
index|]
operator|=
literal|0
expr_stmt|;
name|frame
index|[
literal|0x8
index|]
operator|=
literal|0
expr_stmt|;
name|frame
index|[
literal|0x9
index|]
operator|=
literal|0
expr_stmt|;
name|frame
index|[
literal|0xA
index|]
operator|=
literal|0
expr_stmt|;
name|r600_hdmi_infoframe_checksum
argument_list|(
literal|0x84
argument_list|,
literal|0x01
argument_list|,
literal|0x0A
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_AUDIO_INFO0
operator|+
name|offset
argument_list|,
name|frame
index|[
literal|0x0
index|]
operator||
operator|(
name|frame
index|[
literal|0x1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|frame
index|[
literal|0x2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|frame
index|[
literal|0x3
index|]
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_AUDIO_INFO1
operator|+
name|offset
argument_list|,
name|frame
index|[
literal|0x4
index|]
operator||
operator|(
name|frame
index|[
literal|0x5
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|frame
index|[
literal|0x6
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|frame
index|[
literal|0x8
index|]
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * test if audio buffer is filled enough to start playing  */
end_comment

begin_function
specifier|static
name|bool
name|r600_hdmi_is_audio_buffer_filled
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|uint32_t
name|offset
init|=
name|dig
operator|->
name|afmt
operator|->
name|offset
decl_stmt|;
return|return
operator|(
name|RREG32
argument_list|(
name|HDMI0_STATUS
operator|+
name|offset
argument_list|)
operator|&
literal|0x10
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * have buffer status changed since last call?  */
end_comment

begin_function
name|int
name|r600_hdmi_buffer_status_changed
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|int
name|status
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|dig
operator|->
name|afmt
operator|||
operator|!
name|dig
operator|->
name|afmt
operator|->
name|enabled
condition|)
return|return
literal|0
return|;
name|status
operator|=
name|r600_hdmi_is_audio_buffer_filled
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|result
operator|=
name|dig
operator|->
name|afmt
operator|->
name|last_buffer_filled_status
operator|!=
name|status
expr_stmt|;
name|dig
operator|->
name|afmt
operator|->
name|last_buffer_filled_status
operator|=
name|status
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * write the audio workaround status to the hardware  */
end_comment

begin_function
specifier|static
name|void
name|r600_hdmi_audio_workaround
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|uint32_t
name|offset
init|=
name|dig
operator|->
name|afmt
operator|->
name|offset
decl_stmt|;
name|bool
name|hdmi_audio_workaround
init|=
name|false
decl_stmt|;
comment|/* FIXME */
name|u32
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|hdmi_audio_workaround
operator|||
name|r600_hdmi_is_audio_buffer_filled
argument_list|(
name|encoder
argument_list|)
condition|)
name|value
operator|=
literal|0
expr_stmt|;
comment|/* disable workaround */
else|else
name|value
operator|=
name|HDMI0_AUDIO_TEST_EN
expr_stmt|;
comment|/* enable workaround */
name|WREG32_P
argument_list|(
name|HDMI0_AUDIO_PACKET_CONTROL
operator|+
name|offset
argument_list|,
name|value
argument_list|,
operator|~
name|HDMI0_AUDIO_TEST_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * update the info frames with the data from the current display mode  */
end_comment

begin_function
name|void
name|r600_hdmi_setmode
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
comment|/* Silent, r600_hdmi_enable will raise WARN for us */
if|if
condition|(
operator|!
name|dig
operator|->
name|afmt
operator|->
name|enabled
condition|)
return|return;
name|offset
operator|=
name|dig
operator|->
name|afmt
operator|->
name|offset
expr_stmt|;
name|r600_audio_set_clock
argument_list|(
name|encoder
argument_list|,
name|mode
operator|->
name|clock
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_VBI_PACKET_CONTROL
operator|+
name|offset
argument_list|,
name|HDMI0_NULL_SEND
argument_list|)
expr_stmt|;
comment|/* send null packets when required */
name|WREG32
argument_list|(
name|HDMI0_AUDIO_CRC_CONTROL
operator|+
name|offset
argument_list|,
literal|0x1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASIC_IS_DCE32
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|WREG32
argument_list|(
name|HDMI0_AUDIO_PACKET_CONTROL
operator|+
name|offset
argument_list|,
name|HDMI0_AUDIO_DELAY_EN
argument_list|(
literal|1
argument_list|)
operator||
comment|/* default audio delay */
name|HDMI0_AUDIO_PACKETS_PER_LINE
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* should be suffient for all audio modes and small enough for all hblanks */
name|WREG32
argument_list|(
name|AFMT_AUDIO_PACKET_CONTROL
operator|+
name|offset
argument_list|,
name|AFMT_AUDIO_SAMPLE_SEND
operator||
comment|/* send audio packets */
name|AFMT_60958_CS_UPDATE
argument_list|)
expr_stmt|;
comment|/* allow 60958 channel status fields to be updated */
block|}
else|else
block|{
name|WREG32
argument_list|(
name|HDMI0_AUDIO_PACKET_CONTROL
operator|+
name|offset
argument_list|,
name|HDMI0_AUDIO_SAMPLE_SEND
operator||
comment|/* send audio packets */
name|HDMI0_AUDIO_DELAY_EN
argument_list|(
literal|1
argument_list|)
operator||
comment|/* default audio delay */
name|HDMI0_AUDIO_PACKETS_PER_LINE
argument_list|(
literal|3
argument_list|)
operator||
comment|/* should be suffient for all audio modes and small enough for all hblanks */
name|HDMI0_60958_CS_UPDATE
argument_list|)
expr_stmt|;
comment|/* allow 60958 channel status fields to be updated */
block|}
name|WREG32
argument_list|(
name|HDMI0_ACR_PACKET_CONTROL
operator|+
name|offset
argument_list|,
name|HDMI0_ACR_AUTO_SEND
operator||
comment|/* allow hw to sent ACR packets when required */
name|HDMI0_ACR_SOURCE
argument_list|)
expr_stmt|;
comment|/* select SW CTS value */
name|WREG32
argument_list|(
name|HDMI0_VBI_PACKET_CONTROL
operator|+
name|offset
argument_list|,
name|HDMI0_NULL_SEND
operator||
comment|/* send null packets when required */
name|HDMI0_GC_SEND
operator||
comment|/* send general control packets */
name|HDMI0_GC_CONT
argument_list|)
expr_stmt|;
comment|/* send general control packets every frame */
comment|/* TODO: HDMI0_AUDIO_INFO_UPDATE */
name|WREG32
argument_list|(
name|HDMI0_INFOFRAME_CONTROL0
operator|+
name|offset
argument_list|,
name|HDMI0_AVI_INFO_SEND
operator||
comment|/* enable AVI info frames */
name|HDMI0_AVI_INFO_CONT
operator||
comment|/* send AVI info frames every frame/field */
name|HDMI0_AUDIO_INFO_SEND
operator||
comment|/* enable audio info frames (frames won't be set until audio is enabled) */
name|HDMI0_AUDIO_INFO_CONT
argument_list|)
expr_stmt|;
comment|/* send audio info frames every frame/field */
name|WREG32
argument_list|(
name|HDMI0_INFOFRAME_CONTROL1
operator|+
name|offset
argument_list|,
name|HDMI0_AVI_INFO_LINE
argument_list|(
literal|2
argument_list|)
operator||
comment|/* anything other than 0 */
name|HDMI0_AUDIO_INFO_LINE
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* anything other than 0 */
name|WREG32
argument_list|(
name|HDMI0_GC
operator|+
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unset HDMI0_GC_AVMUTE */
name|r600_hdmi_videoinfoframe
argument_list|(
name|encoder
argument_list|,
name|RGB
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r600_hdmi_update_ACR
argument_list|(
name|encoder
argument_list|,
name|mode
operator|->
name|clock
argument_list|)
expr_stmt|;
comment|/* it's unknown what these bits do excatly, but it's indeed quite useful for debugging */
name|WREG32
argument_list|(
name|HDMI0_RAMP_CONTROL0
operator|+
name|offset
argument_list|,
literal|0x00FFFFFF
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_RAMP_CONTROL1
operator|+
name|offset
argument_list|,
literal|0x007FFFFF
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_RAMP_CONTROL2
operator|+
name|offset
argument_list|,
literal|0x00000001
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|HDMI0_RAMP_CONTROL3
operator|+
name|offset
argument_list|,
literal|0x00000001
argument_list|)
expr_stmt|;
name|r600_hdmi_audio_workaround
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * update settings with current parameters from audio engine  */
end_comment

begin_function
name|void
name|r600_hdmi_update_audio_settings
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|struct
name|r600_audio
name|audio
init|=
name|r600_audio_status
argument_list|(
name|rdev
argument_list|)
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|uint32_t
name|iec
decl_stmt|;
if|if
condition|(
operator|!
name|dig
operator|->
name|afmt
operator|||
operator|!
name|dig
operator|->
name|afmt
operator|->
name|enabled
condition|)
return|return;
name|offset
operator|=
name|dig
operator|->
name|afmt
operator|->
name|offset
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s with %d channels, %d Hz sampling rate, %d bits per sample,\n"
argument_list|,
name|r600_hdmi_is_audio_buffer_filled
argument_list|(
name|encoder
argument_list|)
condition|?
literal|"playing"
else|:
literal|"stopped"
argument_list|,
name|audio
operator|.
name|channels
argument_list|,
name|audio
operator|.
name|rate
argument_list|,
name|audio
operator|.
name|bits_per_sample
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"0x%02X IEC60958 status bits and 0x%02X category code\n"
argument_list|,
operator|(
name|int
operator|)
name|audio
operator|.
name|status_bits
argument_list|,
operator|(
name|int
operator|)
name|audio
operator|.
name|category_code
argument_list|)
expr_stmt|;
name|iec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|audio
operator|.
name|status_bits
operator|&
name|AUDIO_STATUS_PROFESSIONAL
condition|)
name|iec
operator||=
literal|1
operator|<<
literal|0
expr_stmt|;
if|if
condition|(
name|audio
operator|.
name|status_bits
operator|&
name|AUDIO_STATUS_NONAUDIO
condition|)
name|iec
operator||=
literal|1
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|audio
operator|.
name|status_bits
operator|&
name|AUDIO_STATUS_COPYRIGHT
condition|)
name|iec
operator||=
literal|1
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|audio
operator|.
name|status_bits
operator|&
name|AUDIO_STATUS_EMPHASIS
condition|)
name|iec
operator||=
literal|1
operator|<<
literal|3
expr_stmt|;
name|iec
operator||=
name|HDMI0_60958_CS_CATEGORY_CODE
argument_list|(
name|audio
operator|.
name|category_code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|audio
operator|.
name|rate
condition|)
block|{
case|case
literal|32000
case|:
name|iec
operator||=
name|HDMI0_60958_CS_SAMPLING_FREQUENCY
argument_list|(
literal|0x3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|44100
case|:
name|iec
operator||=
name|HDMI0_60958_CS_SAMPLING_FREQUENCY
argument_list|(
literal|0x0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|48000
case|:
name|iec
operator||=
name|HDMI0_60958_CS_SAMPLING_FREQUENCY
argument_list|(
literal|0x2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|88200
case|:
name|iec
operator||=
name|HDMI0_60958_CS_SAMPLING_FREQUENCY
argument_list|(
literal|0x8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|96000
case|:
name|iec
operator||=
name|HDMI0_60958_CS_SAMPLING_FREQUENCY
argument_list|(
literal|0xa
argument_list|)
expr_stmt|;
break|break;
case|case
literal|176400
case|:
name|iec
operator||=
name|HDMI0_60958_CS_SAMPLING_FREQUENCY
argument_list|(
literal|0xc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|192000
case|:
name|iec
operator||=
name|HDMI0_60958_CS_SAMPLING_FREQUENCY
argument_list|(
literal|0xe
argument_list|)
expr_stmt|;
break|break;
block|}
name|WREG32
argument_list|(
name|HDMI0_60958_0
operator|+
name|offset
argument_list|,
name|iec
argument_list|)
expr_stmt|;
name|iec
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|audio
operator|.
name|bits_per_sample
condition|)
block|{
case|case
literal|16
case|:
name|iec
operator||=
name|HDMI0_60958_CS_WORD_LENGTH
argument_list|(
literal|0x2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|20
case|:
name|iec
operator||=
name|HDMI0_60958_CS_WORD_LENGTH
argument_list|(
literal|0x3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|iec
operator||=
name|HDMI0_60958_CS_WORD_LENGTH
argument_list|(
literal|0xb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|audio
operator|.
name|status_bits
operator|&
name|AUDIO_STATUS_V
condition|)
name|iec
operator||=
literal|0x5
operator|<<
literal|16
expr_stmt|;
name|WREG32_P
argument_list|(
name|HDMI0_60958_1
operator|+
name|offset
argument_list|,
name|iec
argument_list|,
operator|~
literal|0x5000f
argument_list|)
expr_stmt|;
name|r600_hdmi_audioinfoframe
argument_list|(
name|encoder
argument_list|,
name|audio
operator|.
name|channels
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r600_hdmi_audio_workaround
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * enable the HDMI engine  */
end_comment

begin_function
name|void
name|r600_hdmi_enable
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|u32
name|hdmi
decl_stmt|;
if|if
condition|(
name|ASIC_IS_DCE6
argument_list|(
name|rdev
argument_list|)
condition|)
return|return;
comment|/* Silent, r600_hdmi_enable will raise WARN for us */
if|if
condition|(
name|dig
operator|->
name|afmt
operator|->
name|enabled
condition|)
return|return;
name|offset
operator|=
name|dig
operator|->
name|afmt
operator|->
name|offset
expr_stmt|;
comment|/* Older chipsets require setting HDMI and routing manually */
if|if
condition|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_R600
operator|&&
operator|!
name|ASIC_IS_DCE3
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|hdmi
operator|=
name|HDMI0_ERROR_ACK
operator||
name|HDMI0_ENABLE
expr_stmt|;
switch|switch
condition|(
name|radeon_encoder
operator|->
name|encoder_id
condition|)
block|{
case|case
name|ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1
case|:
name|WREG32_P
argument_list|(
name|AVIVO_TMDSA_CNTL
argument_list|,
name|AVIVO_TMDSA_CNTL_HDMI_EN
argument_list|,
operator|~
name|AVIVO_TMDSA_CNTL_HDMI_EN
argument_list|)
expr_stmt|;
name|hdmi
operator||=
name|HDMI0_STREAM
argument_list|(
name|HDMI0_STREAM_TMDSA
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODER_OBJECT_ID_INTERNAL_LVTM1
case|:
name|WREG32_P
argument_list|(
name|AVIVO_LVTMA_CNTL
argument_list|,
name|AVIVO_LVTMA_CNTL_HDMI_EN
argument_list|,
operator|~
name|AVIVO_LVTMA_CNTL_HDMI_EN
argument_list|)
expr_stmt|;
name|hdmi
operator||=
name|HDMI0_STREAM
argument_list|(
name|HDMI0_STREAM_LVTMA
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODER_OBJECT_ID_INTERNAL_DDI
case|:
name|WREG32_P
argument_list|(
name|DDIA_CNTL
argument_list|,
name|DDIA_HDMI_EN
argument_list|,
operator|~
name|DDIA_HDMI_EN
argument_list|)
expr_stmt|;
name|hdmi
operator||=
name|HDMI0_STREAM
argument_list|(
name|HDMI0_STREAM_DDIA
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1
case|:
name|hdmi
operator||=
name|HDMI0_STREAM
argument_list|(
name|HDMI0_STREAM_DVOA
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"Invalid encoder for HDMI: 0x%X\n"
argument_list|,
name|radeon_encoder
operator|->
name|encoder_id
argument_list|)
expr_stmt|;
break|break;
block|}
name|WREG32
argument_list|(
name|HDMI0_CONTROL
operator|+
name|offset
argument_list|,
name|hdmi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdev
operator|->
name|irq
operator|.
name|installed
condition|)
block|{
comment|/* if irq is available use it */
name|radeon_irq_kms_enable_afmt
argument_list|(
name|rdev
argument_list|,
name|dig
operator|->
name|afmt
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|dig
operator|->
name|afmt
operator|->
name|enabled
operator|=
name|true
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"Enabling HDMI interface @ 0x%04X for encoder 0x%x\n"
argument_list|,
name|offset
argument_list|,
name|radeon_encoder
operator|->
name|encoder_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * disable the HDMI engine  */
end_comment

begin_function
name|void
name|r600_hdmi_disable
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
if|if
condition|(
name|ASIC_IS_DCE6
argument_list|(
name|rdev
argument_list|)
condition|)
return|return;
comment|/* Called for ATOM_ENCODER_MODE_HDMI only */
if|if
condition|(
operator|!
name|dig
operator|||
operator|!
name|dig
operator|->
name|afmt
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"%s: !dig || !dig->afmt"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|dig
operator|->
name|afmt
operator|->
name|enabled
condition|)
return|return;
name|offset
operator|=
name|dig
operator|->
name|afmt
operator|->
name|offset
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"Disabling HDMI interface @ 0x%04X for encoder 0x%x\n"
argument_list|,
name|offset
argument_list|,
name|radeon_encoder
operator|->
name|encoder_id
argument_list|)
expr_stmt|;
comment|/* disable irq */
name|radeon_irq_kms_disable_afmt
argument_list|(
name|rdev
argument_list|,
name|dig
operator|->
name|afmt
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* Older chipsets not handled by AtomBIOS */
if|if
condition|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_R600
operator|&&
operator|!
name|ASIC_IS_DCE3
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|radeon_encoder
operator|->
name|encoder_id
condition|)
block|{
case|case
name|ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1
case|:
name|WREG32_P
argument_list|(
name|AVIVO_TMDSA_CNTL
argument_list|,
literal|0
argument_list|,
operator|~
name|AVIVO_TMDSA_CNTL_HDMI_EN
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODER_OBJECT_ID_INTERNAL_LVTM1
case|:
name|WREG32_P
argument_list|(
name|AVIVO_LVTMA_CNTL
argument_list|,
literal|0
argument_list|,
operator|~
name|AVIVO_LVTMA_CNTL_HDMI_EN
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODER_OBJECT_ID_INTERNAL_DDI
case|:
name|WREG32_P
argument_list|(
name|DDIA_CNTL
argument_list|,
literal|0
argument_list|,
operator|~
name|DDIA_HDMI_EN
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1
case|:
break|break;
default|default:
name|dev_err
argument_list|(
name|rdev
operator|->
name|dev
argument_list|,
literal|"Invalid encoder for HDMI: 0x%X\n"
argument_list|,
name|radeon_encoder
operator|->
name|encoder_id
argument_list|)
expr_stmt|;
break|break;
block|}
name|WREG32
argument_list|(
name|HDMI0_CONTROL
operator|+
name|offset
argument_list|,
name|HDMI0_ERROR_ACK
argument_list|)
expr_stmt|;
block|}
name|dig
operator|->
name|afmt
operator|->
name|enabled
operator|=
name|false
expr_stmt|;
block|}
end_function

end_unit

