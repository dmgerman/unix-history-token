begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/agp/agpreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_decl_stmt
name|devclass_t
name|drm_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_DMA
argument_list|,
literal|"drm_dma"
argument_list|,
literal|"DRM DMA Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_SAREA
argument_list|,
literal|"drm_sarea"
argument_list|,
literal|"DRM SAREA Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_DRIVER
argument_list|,
literal|"drm_driver"
argument_list|,
literal|"DRM DRIVER Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_MAGIC
argument_list|,
literal|"drm_magic"
argument_list|,
literal|"DRM MAGIC Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_MINOR
argument_list|,
literal|"drm_minor"
argument_list|,
literal|"DRM MINOR Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_IOCTLS
argument_list|,
literal|"drm_ioctls"
argument_list|,
literal|"DRM IOCTL Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_MAPS
argument_list|,
literal|"drm_maps"
argument_list|,
literal|"DRM MAP Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_SEGS
argument_list|,
literal|"drm_segs"
argument_list|,
literal|"DRM SEGMENTS Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_PAGES
argument_list|,
literal|"drm_pages"
argument_list|,
literal|"DRM PAGES Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_FILES
argument_list|,
literal|"drm_files"
argument_list|,
literal|"DRM FILE Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_QUEUES
argument_list|,
literal|"drm_queues"
argument_list|,
literal|"DRM QUEUE Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_CMDS
argument_list|,
literal|"drm_cmds"
argument_list|,
literal|"DRM COMMAND Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_MAPPINGS
argument_list|,
literal|"drm_mapping"
argument_list|,
literal|"DRM MAPPING Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_BUFLISTS
argument_list|,
literal|"drm_buflists"
argument_list|,
literal|"DRM BUFLISTS Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_AGPLISTS
argument_list|,
literal|"drm_agplists"
argument_list|,
literal|"DRM AGPLISTS Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_CTXBITMAP
argument_list|,
literal|"drm_ctxbitmap"
argument_list|,
literal|"DRM CTXBITMAP Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_SGLISTS
argument_list|,
literal|"drm_sglists"
argument_list|,
literal|"DRM SGLISTS Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_MM
argument_list|,
literal|"drm_sman"
argument_list|,
literal|"DRM MEMORY MANAGER Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_HASHTAB
argument_list|,
literal|"drm_hashtab"
argument_list|,
literal|"DRM HASHTABLE Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_KMS
argument_list|,
literal|"drm_kms"
argument_list|,
literal|"DRM KMS Data Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|DRM_MEM_VBLANK
argument_list|,
literal|"drm_vblank"
argument_list|,
literal|"DRM VBLANK Handling Data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|fb_mode_option
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NSEC_PER_USEC
value|1000L
end_define

begin_define
define|#
directive|define
name|NSEC_PER_SEC
value|1000000000L
end_define

begin_function
name|int64_t
name|timeval_to_ns
parameter_list|(
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
return|return
operator|(
operator|(
name|int64_t
operator|)
name|tv
operator|->
name|tv_sec
operator|*
name|NSEC_PER_SEC
operator|)
operator|+
name|tv
operator|->
name|tv_usec
operator|*
name|NSEC_PER_USEC
return|;
block|}
end_function

begin_function
name|struct
name|timeval
name|ns_to_timeval
parameter_list|(
specifier|const
name|int64_t
name|nsec
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|long
name|rem
decl_stmt|;
if|if
condition|(
name|nsec
operator|==
literal|0
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|tv
operator|)
return|;
block|}
name|tv
operator|.
name|tv_sec
operator|=
name|nsec
operator|/
name|NSEC_PER_SEC
expr_stmt|;
name|rem
operator|=
name|nsec
operator|%
name|NSEC_PER_SEC
expr_stmt|;
if|if
condition|(
name|rem
operator|<
literal|0
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|rem
operator|+=
name|NSEC_PER_SEC
expr_stmt|;
block|}
name|tv
operator|.
name|tv_usec
operator|=
name|rem
operator|/
literal|1000
expr_stmt|;
return|return
operator|(
name|tv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Copied from OFED. */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|drm_linux_timer_hz_mask
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|drm_linux_timer_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/*          * Compute an internal HZ value which can divide 2**32 to          * avoid timer rounding problems when the tick value wraps          * around 2**32:          */
name|drm_linux_timer_hz_mask
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|drm_linux_timer_hz_mask
operator|<
operator|(
name|unsigned
name|long
operator|)
name|hz
condition|)
name|drm_linux_timer_hz_mask
operator|*=
literal|2
expr_stmt|;
name|drm_linux_timer_hz_mask
operator|--
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|drm_linux_timer
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|drm_linux_timer_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|const
name|drm_pci_id_list_t
modifier|*
name|drm_find_description
parameter_list|(
name|int
name|vendor
parameter_list|,
name|int
name|device
parameter_list|,
specifier|const
name|drm_pci_id_list_t
modifier|*
name|idlist
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|idlist
index|[
name|i
index|]
operator|.
name|vendor
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|idlist
index|[
name|i
index|]
operator|.
name|vendor
operator|==
name|vendor
operator|)
operator|&&
operator|(
operator|(
name|idlist
index|[
name|i
index|]
operator|.
name|device
operator|==
name|device
operator|)
operator|||
operator|(
name|idlist
index|[
name|i
index|]
operator|.
name|device
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
return|return
operator|(
operator|&
name|idlist
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * drm_probe_helper: called by a driver at the end of its probe  * method.  */
end_comment

begin_function
name|int
name|drm_probe_helper
parameter_list|(
name|device_t
name|kdev
parameter_list|,
specifier|const
name|drm_pci_id_list_t
modifier|*
name|idlist
parameter_list|)
block|{
specifier|const
name|drm_pci_id_list_t
modifier|*
name|id_entry
decl_stmt|;
name|int
name|vendor
decl_stmt|,
name|device
decl_stmt|;
name|vendor
operator|=
name|pci_get_vendor
argument_list|(
name|kdev
argument_list|)
expr_stmt|;
name|device
operator|=
name|pci_get_device
argument_list|(
name|kdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_get_class
argument_list|(
name|kdev
argument_list|)
operator|!=
name|PCIC_DISPLAY
operator|||
operator|(
name|pci_get_subclass
argument_list|(
name|kdev
argument_list|)
operator|!=
name|PCIS_DISPLAY_VGA
operator|&&
name|pci_get_subclass
argument_list|(
name|kdev
argument_list|)
operator|!=
name|PCIS_DISPLAY_OTHER
operator|)
condition|)
return|return
operator|(
operator|-
name|ENXIO
operator|)
return|;
name|id_entry
operator|=
name|drm_find_description
argument_list|(
name|vendor
argument_list|,
name|device
argument_list|,
name|idlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|id_entry
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|device_get_desc
argument_list|(
name|kdev
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"%s desc: %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|kdev
argument_list|)
argument_list|,
name|id_entry
operator|->
name|name
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|kdev
argument_list|,
name|id_entry
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * drm_attach_helper: called by a driver at the end of its attach  * method.  */
end_comment

begin_function
name|int
name|drm_attach_helper
parameter_list|(
name|device_t
name|kdev
parameter_list|,
specifier|const
name|drm_pci_id_list_t
modifier|*
name|idlist
parameter_list|,
name|struct
name|drm_driver
modifier|*
name|driver
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|int
name|vendor
decl_stmt|,
name|device
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dev
operator|=
name|device_get_softc
argument_list|(
name|kdev
argument_list|)
expr_stmt|;
name|vendor
operator|=
name|pci_get_vendor
argument_list|(
name|kdev
argument_list|)
expr_stmt|;
name|device
operator|=
name|pci_get_device
argument_list|(
name|kdev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|id_entry
operator|=
name|drm_find_description
argument_list|(
name|vendor
argument_list|,
name|device
argument_list|,
name|idlist
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_get_pci_dev
argument_list|(
name|kdev
argument_list|,
name|dev
argument_list|,
name|driver
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|drm_generic_suspend
parameter_list|(
name|device_t
name|kdev
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Starting suspend\n"
argument_list|)
expr_stmt|;
name|dev
operator|=
name|device_get_softc
argument_list|(
name|kdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|driver
operator|->
name|suspend
condition|)
block|{
name|pm_message_t
name|state
decl_stmt|;
name|state
operator|.
name|event
operator|=
name|PM_EVENT_SUSPEND
expr_stmt|;
name|error
operator|=
operator|-
name|dev
operator|->
name|driver
operator|->
name|suspend
argument_list|(
name|dev
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|bus_generic_suspend
argument_list|(
name|kdev
argument_list|)
expr_stmt|;
name|out
label|:
name|DRM_DEBUG_KMS
argument_list|(
literal|"Finished suspend: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|drm_generic_resume
parameter_list|(
name|device_t
name|kdev
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Starting resume\n"
argument_list|)
expr_stmt|;
name|dev
operator|=
name|device_get_softc
argument_list|(
name|kdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|driver
operator|->
name|resume
condition|)
block|{
name|error
operator|=
operator|-
name|dev
operator|->
name|driver
operator|->
name|resume
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|bus_generic_resume
argument_list|(
name|kdev
argument_list|)
expr_stmt|;
name|out
label|:
name|DRM_DEBUG_KMS
argument_list|(
literal|"Finished resume: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|drm_generic_detach
parameter_list|(
name|device_t
name|kdev
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dev
operator|=
name|device_get_softc
argument_list|(
name|kdev
argument_list|)
expr_stmt|;
name|drm_put_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Clean up PCI resources allocated by drm_bufs.c.  We're not really 	 * worried about resource consumption while the DRM is inactive (between 	 * lastclose and firstopen or unload) because these aren't actually 	 * taking up KVA, just keeping the PCI resource allocated. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_MAX_PCI_RESOURCE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dev
operator|->
name|pcir
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|bus_release_resource
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|dev
operator|->
name|pcirid
index|[
name|i
index|]
argument_list|,
name|dev
operator|->
name|pcir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dev
operator|->
name|pcir
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pci_disable_busmaster
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"Request to disable bus-master failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|drm_add_busid_modesetting
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
name|top
parameter_list|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|snprintf
argument_list|(
name|dev
operator|->
name|busid_str
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|busid_str
argument_list|)
argument_list|,
literal|"pci:%04x:%02x:%02x.%d"
argument_list|,
name|dev
operator|->
name|pci_domain
argument_list|,
name|dev
operator|->
name|pci_bus
argument_list|,
name|dev
operator|->
name|pci_slot
argument_list|,
name|dev
operator|->
name|pci_func
argument_list|)
expr_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|top
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"busid"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|dev
operator|->
name|busid_str
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|oid
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|dev
operator|->
name|modesetting
operator|=
operator|(
name|dev
operator|->
name|driver
operator|->
name|driver_features
operator|&
name|DRIVER_MODESET
operator|)
operator|!=
literal|0
expr_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|top
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"modesetting"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|dev
operator|->
name|modesetting
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|oid
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_device_find_capability
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|cap
parameter_list|)
block|{
return|return
operator|(
name|pci_find_cap
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|cap
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|drm_pci_device_is_agp
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|driver
operator|->
name|device_is_agp
operator|!=
name|NULL
condition|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* device_is_agp returns a tristate, 0 = not AGP, 1 = definitely 		 * AGP, 2 = fall back to PCI capability 		 */
name|ret
operator|=
call|(
modifier|*
name|dev
operator|->
name|driver
operator|->
name|device_is_agp
call|)
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|DRM_MIGHT_BE_AGP
condition|)
return|return
name|ret
return|;
block|}
return|return
operator|(
name|drm_device_find_capability
argument_list|(
name|dev
argument_list|,
name|PCIY_AGP
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|drm_pci_device_is_pcie
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
operator|(
name|drm_device_find_capability
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|dmi_found
parameter_list|(
specifier|const
name|struct
name|dmi_system_id
modifier|*
name|dsi
parameter_list|)
block|{
name|char
modifier|*
name|hw_vendor
decl_stmt|,
modifier|*
name|hw_prod
decl_stmt|;
name|int
name|i
decl_stmt|,
name|slot
decl_stmt|;
name|bool
name|res
decl_stmt|;
name|hw_vendor
operator|=
name|kern_getenv
argument_list|(
literal|"smbios.planar.maker"
argument_list|)
expr_stmt|;
name|hw_prod
operator|=
name|kern_getenv
argument_list|(
literal|"smbios.planar.product"
argument_list|)
expr_stmt|;
name|res
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|dsi
operator|->
name|matches
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|slot
operator|=
name|dsi
operator|->
name|matches
index|[
name|i
index|]
operator|.
name|slot
expr_stmt|;
switch|switch
condition|(
name|slot
condition|)
block|{
case|case
name|DMI_NONE
case|:
break|break;
case|case
name|DMI_SYS_VENDOR
case|:
case|case
name|DMI_BOARD_VENDOR
case|:
if|if
condition|(
name|hw_vendor
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|hw_vendor
argument_list|,
name|dsi
operator|->
name|matches
index|[
name|i
index|]
operator|.
name|substr
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|res
operator|=
name|false
expr_stmt|;
goto|goto
name|out
goto|;
block|}
case|case
name|DMI_PRODUCT_NAME
case|:
case|case
name|DMI_BOARD_NAME
case|:
if|if
condition|(
name|hw_prod
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|hw_prod
argument_list|,
name|dsi
operator|->
name|matches
index|[
name|i
index|]
operator|.
name|substr
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|res
operator|=
name|false
expr_stmt|;
goto|goto
name|out
goto|;
block|}
default|default:
name|res
operator|=
name|false
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|freeenv
argument_list|(
name|hw_vendor
argument_list|)
expr_stmt|;
name|freeenv
argument_list|(
name|hw_prod
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|dmi_check_system
parameter_list|(
specifier|const
name|struct
name|dmi_system_id
modifier|*
name|sysid
parameter_list|)
block|{
specifier|const
name|struct
name|dmi_system_id
modifier|*
name|dsi
decl_stmt|;
name|bool
name|res
decl_stmt|;
for|for
control|(
name|res
operator|=
name|false
operator|,
name|dsi
operator|=
name|sysid
init|;
name|dsi
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|slot
operator|!=
literal|0
condition|;
name|dsi
operator|++
control|)
block|{
if|if
condition|(
name|dmi_found
argument_list|(
name|dsi
argument_list|)
condition|)
block|{
name|res
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|dsi
operator|->
name|callback
operator|!=
name|NULL
operator|&&
name|dsi
operator|->
name|callback
argument_list|(
name|dsi
argument_list|)
condition|)
break|break;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__OS_HAS_MTRR
end_if

begin_function
name|int
name|drm_mtrr_add
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|int
name|act
decl_stmt|;
name|struct
name|mem_range_desc
name|mrdesc
decl_stmt|;
name|mrdesc
operator|.
name|mr_base
operator|=
name|offset
expr_stmt|;
name|mrdesc
operator|.
name|mr_len
operator|=
name|size
expr_stmt|;
name|mrdesc
operator|.
name|mr_flags
operator|=
name|flags
expr_stmt|;
name|act
operator|=
name|MEMRANGE_SET_UPDATE
expr_stmt|;
name|strlcpy
argument_list|(
name|mrdesc
operator|.
name|mr_owner
argument_list|,
literal|"drm"
argument_list|,
sizeof|sizeof
argument_list|(
name|mrdesc
operator|.
name|mr_owner
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|mem_range_attr_set
argument_list|(
operator|&
name|mrdesc
argument_list|,
operator|&
name|act
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|drm_mtrr_del
parameter_list|(
name|int
name|handle
name|__unused
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|int
name|act
decl_stmt|;
name|struct
name|mem_range_desc
name|mrdesc
decl_stmt|;
name|mrdesc
operator|.
name|mr_base
operator|=
name|offset
expr_stmt|;
name|mrdesc
operator|.
name|mr_len
operator|=
name|size
expr_stmt|;
name|mrdesc
operator|.
name|mr_flags
operator|=
name|flags
expr_stmt|;
name|act
operator|=
name|MEMRANGE_SET_REMOVE
expr_stmt|;
name|strlcpy
argument_list|(
name|mrdesc
operator|.
name|mr_owner
argument_list|,
literal|"drm"
argument_list|,
sizeof|sizeof
argument_list|(
name|mrdesc
operator|.
name|mr_owner
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|mem_range_attr_set
argument_list|(
operator|&
name|mrdesc
argument_list|,
operator|&
name|act
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|drm_clflush_pages
parameter_list|(
name|vm_page_t
modifier|*
name|pages
parameter_list|,
name|unsigned
name|long
name|num_pages
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|pmap_invalidate_cache_pages
argument_list|(
name|pages
argument_list|,
name|num_pages
argument_list|)
expr_stmt|;
else|#
directive|else
name|DRM_ERROR
argument_list|(
literal|"drm_clflush_pages not implemented on this architecture"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|drm_clflush_virt_range
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|,
name|unsigned
name|long
name|length
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|pmap_invalidate_cache_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|addr
operator|+
name|length
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|#
directive|else
name|DRM_ERROR
argument_list|(
literal|"drm_clflush_virt_range not implemented on this architecture"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|hex_dump_to_buffer
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|rowsize
parameter_list|,
name|int
name|groupsize
parameter_list|,
name|char
modifier|*
name|linebuf
parameter_list|,
name|size_t
name|linebuflen
parameter_list|,
name|bool
name|ascii
name|__unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|c
decl_stmt|;
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
operator|&&
name|j
operator|<=
name|linebuflen
condition|)
block|{
name|c
operator|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|%
name|rowsize
operator|==
literal|0
condition|)
block|{
comment|/* Newline required. */
name|sprintf
argument_list|(
name|linebuf
operator|+
name|j
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|%
name|groupsize
operator|==
literal|0
condition|)
block|{
comment|/* Space required. */
name|sprintf
argument_list|(
name|linebuf
operator|+
name|j
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|>
name|linebuflen
operator|-
literal|4
condition|)
break|break;
name|sprintf
argument_list|(
name|linebuf
operator|+
name|j
argument_list|,
literal|"%02X"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<=
name|linebuflen
condition|)
name|sprintf
argument_list|(
name|linebuf
operator|+
name|j
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|DRM_LINUX
end_if

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|DRIVER_NAME
argument_list|,
name|linux
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|LINUX_IOCTL_DRM_MIN
value|0x6400
end_define

begin_define
define|#
directive|define
name|LINUX_IOCTL_DRM_MAX
value|0x64ff
end_define

begin_decl_stmt
specifier|static
name|linux_ioctl_function_t
name|drm_linux_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linux_ioctl_handler
name|drm_handler
init|=
block|{
name|drm_linux_ioctl
block|,
name|LINUX_IOCTL_DRM_MIN
block|,
name|LINUX_IOCTL_DRM_MAX
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The bits for in/out are switched on Linux */
end_comment

begin_define
define|#
directive|define
name|LINUX_IOC_IN
value|IOC_OUT
end_define

begin_define
define|#
directive|define
name|LINUX_IOC_OUT
value|IOC_IN
end_define

begin_function
specifier|static
name|int
name|drm_linux_ioctl
parameter_list|(
name|DRM_STRUCTPROC
modifier|*
name|p
parameter_list|,
name|struct
name|linux_ioctl_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|cmd
init|=
name|args
operator|->
name|cmd
decl_stmt|;
name|args
operator|->
name|cmd
operator|&=
operator|~
operator|(
name|LINUX_IOC_IN
operator||
name|LINUX_IOC_OUT
operator|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
name|LINUX_IOC_IN
condition|)
name|args
operator|->
name|cmd
operator||=
name|IOC_IN
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
name|LINUX_IOC_OUT
condition|)
name|args
operator|->
name|cmd
operator||=
name|IOC_OUT
expr_stmt|;
name|error
operator|=
name|ioctl
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|ioctl_args
operator|*
operator|)
name|args
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DRM_LINUX */
end_comment

begin_function
specifier|static
name|int
name|drm_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|TUNABLE_INT_FETCH
argument_list|(
literal|"drm.debug"
argument_list|,
operator|&
name|drm_debug
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"drm.notyet"
argument_list|,
operator|&
name|drm_notyet
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|drm_mod
init|=
block|{
literal|"drmn"
block|,
name|drm_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|drmn
argument_list|,
name|drm_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|drmn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|drmn
argument_list|,
name|agp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|drmn
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|drmn
argument_list|,
name|mem
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|drmn
argument_list|,
name|iicbus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

