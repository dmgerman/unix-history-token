begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006 Luc Verhaegen (quirks list)  * Copyright (c) 2007-2008 Intel Corporation  *   Jesse Barnes<jesse.barnes@intel.com>  * Copyright 2010 Red Hat, Inc.  *  * DDC probing routines (drm_ddc_read& drm_do_probe_ddc_edid) originally from  * FB layer.  *   Copyright (C) 2006 Dennis Munsie<dmunsie@cecropia.com>  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sub license,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_edid.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_edid_modes.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iic.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iiconf.h>
end_include

begin_include
include|#
directive|include
file|"iicbus_if.h"
end_include

begin_define
define|#
directive|define
name|version_greater
parameter_list|(
name|edid
parameter_list|,
name|maj
parameter_list|,
name|min
parameter_list|)
define|\
value|(((edid)->version> (maj)) || \ 	 ((edid)->version == (maj)&& (edid)->revision> (min)))
end_define

begin_define
define|#
directive|define
name|EDID_EST_TIMINGS
value|16
end_define

begin_define
define|#
directive|define
name|EDID_STD_TIMINGS
value|8
end_define

begin_define
define|#
directive|define
name|EDID_DETAILED_TIMINGS
value|4
end_define

begin_comment
comment|/*  * EDID blocks out in the wild have a variety of bugs, try to collect  * them here (note that userspace may work around broken monitors first,  * but fixes should make their way here so that the kernel "just works"  * on as many displays as possible).  */
end_comment

begin_comment
comment|/* First detailed mode wrong, use largest 60Hz mode */
end_comment

begin_define
define|#
directive|define
name|EDID_QUIRK_PREFER_LARGE_60
value|(1<< 0)
end_define

begin_comment
comment|/* Reported 135MHz pixel clock is too high, needs adjustment */
end_comment

begin_define
define|#
directive|define
name|EDID_QUIRK_135_CLOCK_TOO_HIGH
value|(1<< 1)
end_define

begin_comment
comment|/* Prefer the largest mode at 75 Hz */
end_comment

begin_define
define|#
directive|define
name|EDID_QUIRK_PREFER_LARGE_75
value|(1<< 2)
end_define

begin_comment
comment|/* Detail timing is in cm not mm */
end_comment

begin_define
define|#
directive|define
name|EDID_QUIRK_DETAILED_IN_CM
value|(1<< 3)
end_define

begin_comment
comment|/* Detailed timing descriptors have bogus size values, so just take the  * maximum size and use that.  */
end_comment

begin_define
define|#
directive|define
name|EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE
value|(1<< 4)
end_define

begin_comment
comment|/* Monitor forgot to set the first detailed is preferred bit. */
end_comment

begin_define
define|#
directive|define
name|EDID_QUIRK_FIRST_DETAILED_PREFERRED
value|(1<< 5)
end_define

begin_comment
comment|/* use +hsync +vsync for detailed mode */
end_comment

begin_define
define|#
directive|define
name|EDID_QUIRK_DETAILED_SYNC_PP
value|(1<< 6)
end_define

begin_struct
struct|struct
name|detailed_mode_closure
block|{
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|edid
modifier|*
name|edid
decl_stmt|;
name|bool
name|preferred
decl_stmt|;
name|u32
name|quirks
decl_stmt|;
name|int
name|modes
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LEVEL_DMT
value|0
end_define

begin_define
define|#
directive|define
name|LEVEL_GTF
value|1
end_define

begin_define
define|#
directive|define
name|LEVEL_GTF2
value|2
end_define

begin_define
define|#
directive|define
name|LEVEL_CVT
value|3
end_define

begin_struct
specifier|static
struct|struct
name|edid_quirk
block|{
name|char
modifier|*
name|vendor
decl_stmt|;
name|int
name|product_id
decl_stmt|;
name|u32
name|quirks
decl_stmt|;
block|}
name|edid_quirk_list
index|[]
init|=
block|{
comment|/* Acer AL1706 */
block|{
literal|"ACR"
block|,
literal|44358
block|,
name|EDID_QUIRK_PREFER_LARGE_60
block|}
block|,
comment|/* Acer F51 */
block|{
literal|"API"
block|,
literal|0x7602
block|,
name|EDID_QUIRK_PREFER_LARGE_60
block|}
block|,
comment|/* Unknown Acer */
block|{
literal|"ACR"
block|,
literal|2423
block|,
name|EDID_QUIRK_FIRST_DETAILED_PREFERRED
block|}
block|,
comment|/* Belinea 10 15 55 */
block|{
literal|"MAX"
block|,
literal|1516
block|,
name|EDID_QUIRK_PREFER_LARGE_60
block|}
block|,
block|{
literal|"MAX"
block|,
literal|0x77e
block|,
name|EDID_QUIRK_PREFER_LARGE_60
block|}
block|,
comment|/* Envision Peripherals, Inc. EN-7100e */
block|{
literal|"EPI"
block|,
literal|59264
block|,
name|EDID_QUIRK_135_CLOCK_TOO_HIGH
block|}
block|,
comment|/* Envision EN2028 */
block|{
literal|"EPI"
block|,
literal|8232
block|,
name|EDID_QUIRK_PREFER_LARGE_60
block|}
block|,
comment|/* Funai Electronics PM36B */
block|{
literal|"FCM"
block|,
literal|13600
block|,
name|EDID_QUIRK_PREFER_LARGE_75
operator||
name|EDID_QUIRK_DETAILED_IN_CM
block|}
block|,
comment|/* LG Philips LCD LP154W01-A5 */
block|{
literal|"LPL"
block|,
literal|0
block|,
name|EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE
block|}
block|,
block|{
literal|"LPL"
block|,
literal|0x2a00
block|,
name|EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE
block|}
block|,
comment|/* Philips 107p5 CRT */
block|{
literal|"PHL"
block|,
literal|57364
block|,
name|EDID_QUIRK_FIRST_DETAILED_PREFERRED
block|}
block|,
comment|/* Proview AY765C */
block|{
literal|"PTS"
block|,
literal|765
block|,
name|EDID_QUIRK_FIRST_DETAILED_PREFERRED
block|}
block|,
comment|/* Samsung SyncMaster 205BW.  Note: irony */
block|{
literal|"SAM"
block|,
literal|541
block|,
name|EDID_QUIRK_DETAILED_SYNC_PP
block|}
block|,
comment|/* Samsung SyncMaster 22[5-6]BW */
block|{
literal|"SAM"
block|,
literal|596
block|,
name|EDID_QUIRK_PREFER_LARGE_60
block|}
block|,
block|{
literal|"SAM"
block|,
literal|638
block|,
name|EDID_QUIRK_PREFER_LARGE_60
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/*** DDC fetch and block validation ***/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u8
name|edid_header
index|[]
init|=
block|{
literal|0x00
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Sanity check the header of the base EDID block.  Return 8 if the header  * is perfect, down to 0 if it's totally wrong.  */
end_comment

begin_function
name|int
name|drm_edid_header_is_valid
parameter_list|(
specifier|const
name|u8
modifier|*
name|raw_edid
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|score
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|edid_header
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|raw_edid
index|[
name|i
index|]
operator|==
name|edid_header
index|[
name|i
index|]
condition|)
name|score
operator|++
expr_stmt|;
return|return
name|score
return|;
block|}
end_function

begin_comment
comment|/*  * Sanity check the EDID block (base or extension).  Return 0 if the block  * doesn't check out, or 1 if it's valid.  */
end_comment

begin_function
specifier|static
name|bool
name|drm_edid_block_valid
parameter_list|(
name|u8
modifier|*
name|raw_edid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u8
name|csum
init|=
literal|0
decl_stmt|;
name|struct
name|edid
modifier|*
name|edid
init|=
operator|(
expr|struct
name|edid
operator|*
operator|)
name|raw_edid
decl_stmt|;
if|if
condition|(
name|raw_edid
index|[
literal|0
index|]
operator|==
literal|0x00
condition|)
block|{
name|int
name|score
init|=
name|drm_edid_header_is_valid
argument_list|(
name|raw_edid
argument_list|)
decl_stmt|;
if|if
condition|(
name|score
operator|==
literal|8
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|score
operator|>=
literal|6
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"Fixing EDID header, your hardware may be failing\n"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|raw_edid
argument_list|,
name|edid_header
argument_list|,
sizeof|sizeof
argument_list|(
name|edid_header
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|bad
goto|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EDID_LENGTH
condition|;
name|i
operator|++
control|)
name|csum
operator|+=
name|raw_edid
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|csum
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"EDID checksum is invalid, remainder is %d\n"
argument_list|,
name|csum
argument_list|)
expr_stmt|;
comment|/* allow CEA to slide through, switches mangle this */
if|if
condition|(
name|raw_edid
index|[
literal|0
index|]
operator|!=
literal|0x02
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* per-block-type checks */
switch|switch
condition|(
name|raw_edid
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
comment|/* base */
if|if
condition|(
name|edid
operator|->
name|version
operator|!=
literal|1
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"EDID has major version %d, instead of 1\n"
argument_list|,
name|edid
operator|->
name|version
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|edid
operator|->
name|revision
operator|>
literal|4
condition|)
name|DRM_DEBUG
argument_list|(
literal|"EDID minor> 4, assuming backward compatibility\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|1
return|;
name|bad
label|:
if|if
condition|(
name|raw_edid
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Raw EDID:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|drm_debug_flag
operator|&
name|DRM_DEBUGBITS_KMS
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EDID_LENGTH
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|raw_edid
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|0
operator|||
name|i
operator|==
name|EDID_LENGTH
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * drm_edid_is_valid - sanity check EDID data  * @edid: EDID data  *  * Sanity-check an entire EDID record (including extensions)  */
end_comment

begin_function
name|bool
name|drm_edid_is_valid
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u8
modifier|*
name|raw
init|=
operator|(
name|u8
operator|*
operator|)
name|edid
decl_stmt|;
if|if
condition|(
operator|!
name|edid
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|edid
operator|->
name|extensions
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|drm_edid_block_valid
argument_list|(
name|raw
operator|+
name|i
operator|*
name|EDID_LENGTH
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DDC_ADDR
value|0x50
end_define

begin_define
define|#
directive|define
name|DDC_SEGMENT_ADDR
value|0x30
end_define

begin_comment
comment|/**  * Get EDID information via I2C.  *  * \param adapter : i2c device adaptor  * \param buf     : EDID data buffer to be filled  * \param len     : EDID data buffer length  * \return 0 on success or -1 on failure.  *  * Try to fetch EDID information by calling i2c driver function.  */
end_comment

begin_function
specifier|static
name|int
name|drm_do_probe_ddc_edid
parameter_list|(
name|device_t
name|adapter
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|block
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|char
name|start
init|=
name|block
operator|*
name|EDID_LENGTH
decl_stmt|;
name|unsigned
name|char
name|segment
init|=
name|block
operator|>>
literal|1
decl_stmt|;
name|unsigned
name|char
name|xfers
init|=
name|segment
condition|?
literal|3
else|:
literal|2
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|retries
init|=
literal|5
decl_stmt|;
comment|/* The core i2c driver will automatically retry the transfer if the 	 * adapter reports EAGAIN. However, we find that bit-banging transfers 	 * are susceptible to errors under a heavily loaded machine and 	 * generate spurious NAKs and timeouts. Retrying the transfer 	 * of the individual block a few times seems to overcome this. 	 */
do|do
block|{
name|struct
name|iic_msg
name|msgs
index|[]
init|=
block|{
block|{
operator|.
name|slave
operator|=
name|DDC_SEGMENT_ADDR
operator|<<
literal|1
block|,
operator|.
name|flags
operator|=
literal|0
block|,
operator|.
name|len
operator|=
literal|1
block|,
operator|.
name|buf
operator|=
operator|&
name|segment
block|, 			}
block|,
block|{
operator|.
name|slave
operator|=
name|DDC_ADDR
operator|<<
literal|1
block|,
operator|.
name|flags
operator|=
name|IIC_M_WR
block|,
operator|.
name|len
operator|=
literal|1
block|,
operator|.
name|buf
operator|=
operator|&
name|start
block|, 			}
block|,
block|{
operator|.
name|slave
operator|=
name|DDC_ADDR
operator|<<
literal|1
block|,
operator|.
name|flags
operator|=
name|IIC_M_RD
block|,
operator|.
name|len
operator|=
name|len
block|,
operator|.
name|buf
operator|=
name|buf
block|, 			}
block|}
decl_stmt|;
comment|/* 	 * Avoid sending the segment addr to not upset non-compliant ddc 	 * monitors. 	 */
name|ret
operator|=
name|iicbus_transfer
argument_list|(
name|adapter
argument_list|,
operator|&
name|msgs
index|[
literal|3
operator|-
name|xfers
index|]
argument_list|,
name|xfers
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"iicbus_transfer countdown %d error %d\n"
argument_list|,
name|retries
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|!=
literal|0
operator|&&
operator|--
name|retries
condition|)
do|;
return|return
operator|(
name|ret
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|drm_edid_is_zero
parameter_list|(
name|u8
modifier|*
name|in_edid
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
modifier|*
name|raw_edid
init|=
operator|(
name|u32
operator|*
operator|)
name|in_edid
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|/
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
operator|(
name|raw_edid
operator|+
name|i
operator|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|drm_do_get_edid
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|device_t
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|valid_extensions
init|=
literal|0
decl_stmt|;
name|u8
modifier|*
name|block
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|block
operator|=
name|malloc
argument_list|(
name|EDID_LENGTH
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* base block fetch */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|drm_do_probe_ddc_edid
argument_list|(
name|adapter
argument_list|,
name|block
argument_list|,
literal|0
argument_list|,
name|EDID_LENGTH
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|drm_edid_block_valid
argument_list|(
name|block
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|drm_edid_is_zero
argument_list|(
name|block
argument_list|,
name|EDID_LENGTH
argument_list|)
condition|)
block|{
name|connector
operator|->
name|null_edid_counter
operator|++
expr_stmt|;
goto|goto
name|carp
goto|;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
goto|goto
name|carp
goto|;
comment|/* if there's no extensions, we're done */
if|if
condition|(
name|block
index|[
literal|0x7e
index|]
operator|==
literal|0
condition|)
return|return
name|block
return|;
name|new
operator|=
name|reallocf
argument_list|(
name|block
argument_list|,
operator|(
name|block
index|[
literal|0x7e
index|]
operator|+
literal|1
operator|)
operator|*
name|EDID_LENGTH
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|block
operator|=
name|new
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|block
index|[
literal|0x7e
index|]
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|drm_do_probe_ddc_edid
argument_list|(
name|adapter
argument_list|,
name|block
operator|+
operator|(
name|valid_extensions
operator|+
literal|1
operator|)
operator|*
name|EDID_LENGTH
argument_list|,
name|j
argument_list|,
name|EDID_LENGTH
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|drm_edid_block_valid
argument_list|(
name|block
operator|+
operator|(
name|valid_extensions
operator|+
literal|1
operator|)
operator|*
name|EDID_LENGTH
argument_list|)
condition|)
block|{
name|valid_extensions
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"%s: Ignoring invalid EDID block %d.\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valid_extensions
operator|!=
name|block
index|[
literal|0x7e
index|]
condition|)
block|{
name|block
index|[
name|EDID_LENGTH
operator|-
literal|1
index|]
operator|+=
name|block
index|[
literal|0x7e
index|]
operator|-
name|valid_extensions
expr_stmt|;
name|block
index|[
literal|0x7e
index|]
operator|=
name|valid_extensions
expr_stmt|;
name|new
operator|=
name|reallocf
argument_list|(
name|block
argument_list|,
operator|(
name|valid_extensions
operator|+
literal|1
operator|)
operator|*
name|EDID_LENGTH
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|block
operator|=
name|new
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"got EDID from %s\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|block
return|;
name|carp
label|:
name|DRM_ERROR
argument_list|(
literal|"%s: EDID block %d invalid.\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|block
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Probe DDC presence.  *  * \param adapter : i2c device adaptor  * \return 1 on success  */
end_comment

begin_function
specifier|static
name|bool
name|drm_probe_ddc
parameter_list|(
name|device_t
name|adapter
parameter_list|)
block|{
name|unsigned
name|char
name|out
decl_stmt|;
return|return
operator|(
name|drm_do_probe_ddc_edid
argument_list|(
name|adapter
argument_list|,
operator|&
name|out
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * drm_get_edid - get EDID data, if available  * @connector: connector we're probing  * @adapter: i2c adapter to use for DDC  *  * Poke the given i2c channel to grab EDID data if possible.  If found,  * attach it to the connector.  *  * Return edid data or NULL if we couldn't find any.  */
end_comment

begin_function
name|struct
name|edid
modifier|*
name|drm_get_edid
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|device_t
name|adapter
parameter_list|)
block|{
name|struct
name|edid
modifier|*
name|edid
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|drm_probe_ddc
argument_list|(
name|adapter
argument_list|)
condition|)
name|edid
operator|=
operator|(
expr|struct
name|edid
operator|*
operator|)
name|drm_do_get_edid
argument_list|(
name|connector
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|connector
operator|->
name|display_info
operator|.
name|raw_edid
operator|=
operator|(
name|char
operator|*
operator|)
name|edid
expr_stmt|;
return|return
name|edid
return|;
block|}
end_function

begin_comment
comment|/*** EDID parsing ***/
end_comment

begin_comment
comment|/**  * edid_vendor - match a string against EDID's obfuscated vendor field  * @edid: EDID to match  * @vendor: vendor string  *  * Returns true if @vendor is in @edid, false otherwise  */
end_comment

begin_function
specifier|static
name|bool
name|edid_vendor
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|,
name|char
modifier|*
name|vendor
parameter_list|)
block|{
name|char
name|edid_vendor
index|[
literal|3
index|]
decl_stmt|;
name|edid_vendor
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|edid
operator|->
name|mfg_id
index|[
literal|0
index|]
operator|&
literal|0x7c
operator|)
operator|>>
literal|2
operator|)
operator|+
literal|'@'
expr_stmt|;
name|edid_vendor
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|edid
operator|->
name|mfg_id
index|[
literal|0
index|]
operator|&
literal|0x3
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|edid
operator|->
name|mfg_id
index|[
literal|1
index|]
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
operator|)
operator|)
operator|+
literal|'@'
expr_stmt|;
name|edid_vendor
index|[
literal|2
index|]
operator|=
operator|(
name|edid
operator|->
name|mfg_id
index|[
literal|1
index|]
operator|&
literal|0x1f
operator|)
operator|+
literal|'@'
expr_stmt|;
return|return
operator|!
name|strncmp
argument_list|(
name|edid_vendor
argument_list|,
name|vendor
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * edid_get_quirks - return quirk flags for a given EDID  * @edid: EDID to process  *  * This tells subsequent routines what fixes they need to apply.  */
end_comment

begin_function
specifier|static
name|u32
name|edid_get_quirks
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|struct
name|edid_quirk
modifier|*
name|quirk
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_ARRAY_SIZE
argument_list|(
name|edid_quirk_list
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|quirk
operator|=
operator|&
name|edid_quirk_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|edid_vendor
argument_list|(
name|edid
argument_list|,
name|quirk
operator|->
name|vendor
argument_list|)
operator|&&
operator|(
name|EDID_PRODUCT_ID
argument_list|(
name|edid
argument_list|)
operator|==
name|quirk
operator|->
name|product_id
operator|)
condition|)
return|return
name|quirk
operator|->
name|quirks
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MODE_SIZE
parameter_list|(
name|m
parameter_list|)
value|((m)->hdisplay * (m)->vdisplay)
end_define

begin_define
define|#
directive|define
name|MODE_REFRESH_DIFF
parameter_list|(
name|m
parameter_list|,
name|r
parameter_list|)
value|(abs((m)->vrefresh - target_refresh))
end_define

begin_comment
comment|/**  * edid_fixup_preferred - set preferred modes based on quirk list  * @connector: has mode list to fix up  * @quirks: quirks list  *  * Walk the mode list for @connector, clearing the preferred status  * on existing modes and setting it anew for the right mode ala @quirks.  */
end_comment

begin_function
specifier|static
name|void
name|edid_fixup_preferred
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|u32
name|quirks
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|t
decl_stmt|,
modifier|*
name|cur_mode
decl_stmt|,
modifier|*
name|preferred_mode
decl_stmt|;
name|int
name|target_refresh
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|connector
operator|->
name|probed_modes
argument_list|)
condition|)
return|return;
if|if
condition|(
name|quirks
operator|&
name|EDID_QUIRK_PREFER_LARGE_60
condition|)
name|target_refresh
operator|=
literal|60
expr_stmt|;
if|if
condition|(
name|quirks
operator|&
name|EDID_QUIRK_PREFER_LARGE_75
condition|)
name|target_refresh
operator|=
literal|75
expr_stmt|;
name|preferred_mode
operator|=
name|list_first_entry
argument_list|(
operator|&
name|connector
operator|->
name|probed_modes
argument_list|,
expr|struct
name|drm_display_mode
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|cur_mode
argument_list|,
argument|t
argument_list|,
argument|&connector->probed_modes
argument_list|,
argument|head
argument_list|)
block|{
name|cur_mode
operator|->
name|type
operator|&=
operator|~
name|DRM_MODE_TYPE_PREFERRED
expr_stmt|;
if|if
condition|(
name|cur_mode
operator|==
name|preferred_mode
condition|)
continue|continue;
comment|/* Largest mode is preferred */
if|if
condition|(
name|MODE_SIZE
argument_list|(
name|cur_mode
argument_list|)
operator|>
name|MODE_SIZE
argument_list|(
name|preferred_mode
argument_list|)
condition|)
name|preferred_mode
operator|=
name|cur_mode
expr_stmt|;
comment|/* At a given size, try to get closest to target refresh */
if|if
condition|(
operator|(
name|MODE_SIZE
argument_list|(
name|cur_mode
argument_list|)
operator|==
name|MODE_SIZE
argument_list|(
name|preferred_mode
argument_list|)
operator|)
operator|&&
name|MODE_REFRESH_DIFF
argument_list|(
name|cur_mode
argument_list|,
name|target_refresh
argument_list|)
operator|<
name|MODE_REFRESH_DIFF
argument_list|(
name|preferred_mode
argument_list|,
name|target_refresh
argument_list|)
condition|)
block|{
name|preferred_mode
operator|=
name|cur_mode
expr_stmt|;
block|}
block|}
name|preferred_mode
operator|->
name|type
operator||=
name|DRM_MODE_TYPE_PREFERRED
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|drm_display_mode
modifier|*
name|drm_mode_find_dmt
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|hsize
parameter_list|,
name|int
name|vsize
parameter_list|,
name|int
name|fresh
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|drm_num_dmt_modes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|ptr
init|=
operator|&
name|drm_dmt_modes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|hsize
operator|==
name|ptr
operator|->
name|hdisplay
operator|&&
name|vsize
operator|==
name|ptr
operator|->
name|vdisplay
operator|&&
name|fresh
operator|==
name|drm_mode_vrefresh
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
comment|/* get the expected default mode */
name|mode
operator|=
name|drm_mode_duplicate
argument_list|(
name|dev
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|mode
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|void
name|detailed_cb
parameter_list|(
name|struct
name|detailed_timing
modifier|*
name|timing
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
function_decl|;
end_typedef

begin_function
specifier|static
name|void
name|cea_for_each_detailed_block
parameter_list|(
name|u8
modifier|*
name|ext
parameter_list|,
name|detailed_cb
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|u8
name|rev
init|=
name|ext
index|[
literal|0x01
index|]
decl_stmt|,
name|d
init|=
name|ext
index|[
literal|0x02
index|]
decl_stmt|;
name|u8
modifier|*
name|det_base
init|=
name|ext
operator|+
name|d
decl_stmt|;
switch|switch
condition|(
name|rev
condition|)
block|{
case|case
literal|0
case|:
comment|/* can't happen */
return|return;
case|case
literal|1
case|:
comment|/* have to infer how many blocks we have, check pixel clock */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|det_base
index|[
literal|18
operator|*
name|i
index|]
operator|||
name|det_base
index|[
literal|18
operator|*
name|i
operator|+
literal|1
index|]
condition|)
name|n
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* explicit count */
name|n
operator|=
name|min
argument_list|(
name|ext
index|[
literal|0x03
index|]
operator|&
literal|0x0f
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|cb
argument_list|(
operator|(
expr|struct
name|detailed_timing
operator|*
operator|)
operator|(
name|det_base
operator|+
literal|18
operator|*
name|i
operator|)
argument_list|,
name|closure
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtb_for_each_detailed_block
parameter_list|(
name|u8
modifier|*
name|ext
parameter_list|,
name|detailed_cb
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|n
init|=
name|min
argument_list|(
operator|(
name|int
operator|)
name|ext
index|[
literal|0x02
index|]
argument_list|,
literal|6
argument_list|)
decl_stmt|;
name|u8
modifier|*
name|det_base
init|=
name|ext
operator|+
literal|5
decl_stmt|;
if|if
condition|(
name|ext
index|[
literal|0x01
index|]
operator|!=
literal|1
condition|)
return|return;
comment|/* unknown version */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|cb
argument_list|(
operator|(
expr|struct
name|detailed_timing
operator|*
operator|)
operator|(
name|det_base
operator|+
literal|18
operator|*
name|i
operator|)
argument_list|,
name|closure
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|drm_for_each_detailed_block
parameter_list|(
name|u8
modifier|*
name|raw_edid
parameter_list|,
name|detailed_cb
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|edid
modifier|*
name|edid
init|=
operator|(
expr|struct
name|edid
operator|*
operator|)
name|raw_edid
decl_stmt|;
if|if
condition|(
name|edid
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EDID_DETAILED_TIMINGS
condition|;
name|i
operator|++
control|)
name|cb
argument_list|(
operator|&
operator|(
name|edid
operator|->
name|detailed_timings
index|[
name|i
index|]
operator|)
argument_list|,
name|closure
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|raw_edid
index|[
literal|0x7e
index|]
condition|;
name|i
operator|++
control|)
block|{
name|u8
modifier|*
name|ext
init|=
name|raw_edid
operator|+
operator|(
name|i
operator|*
name|EDID_LENGTH
operator|)
decl_stmt|;
switch|switch
condition|(
operator|*
name|ext
condition|)
block|{
case|case
name|CEA_EXT
case|:
name|cea_for_each_detailed_block
argument_list|(
name|ext
argument_list|,
name|cb
argument_list|,
name|closure
argument_list|)
expr_stmt|;
break|break;
case|case
name|VTB_EXT
case|:
name|vtb_for_each_detailed_block
argument_list|(
name|ext
argument_list|,
name|cb
argument_list|,
name|closure
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|is_rb
parameter_list|(
name|struct
name|detailed_timing
modifier|*
name|t
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|u8
modifier|*
name|r
init|=
operator|(
name|u8
operator|*
operator|)
name|t
decl_stmt|;
if|if
condition|(
name|r
index|[
literal|3
index|]
operator|==
name|EDID_DETAIL_MONITOR_RANGE
condition|)
if|if
condition|(
name|r
index|[
literal|15
index|]
operator|&
literal|0x10
condition|)
operator|*
operator|(
name|bool
operator|*
operator|)
name|data
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EDID 1.4 defines this explicitly.  For EDID 1.3, we guess, badly. */
end_comment

begin_function
specifier|static
name|bool
name|drm_monitor_supports_rb
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
if|if
condition|(
name|edid
operator|->
name|revision
operator|>=
literal|4
condition|)
block|{
name|bool
name|ret
decl_stmt|;
name|drm_for_each_detailed_block
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|edid
argument_list|,
name|is_rb
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
operator|(
operator|(
name|edid
operator|->
name|input
operator|&
name|DRM_EDID_INPUT_DIGITAL
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|find_gtf2
parameter_list|(
name|struct
name|detailed_timing
modifier|*
name|t
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|u8
modifier|*
name|r
init|=
operator|(
name|u8
operator|*
operator|)
name|t
decl_stmt|;
if|if
condition|(
name|r
index|[
literal|3
index|]
operator|==
name|EDID_DETAIL_MONITOR_RANGE
operator|&&
name|r
index|[
literal|10
index|]
operator|==
literal|0x02
condition|)
operator|*
operator|(
name|u8
operator|*
operator|*
operator|)
name|data
operator|=
name|r
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Secondary GTF curve kicks in above some break frequency */
end_comment

begin_function
specifier|static
name|int
name|drm_gtf2_hbreak
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|u8
modifier|*
name|r
init|=
name|NULL
decl_stmt|;
name|drm_for_each_detailed_block
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|edid
argument_list|,
name|find_gtf2
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|r
condition|?
operator|(
name|r
index|[
literal|12
index|]
operator|*
literal|2
operator|)
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_gtf2_2c
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|u8
modifier|*
name|r
init|=
name|NULL
decl_stmt|;
name|drm_for_each_detailed_block
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|edid
argument_list|,
name|find_gtf2
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|r
condition|?
name|r
index|[
literal|13
index|]
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_gtf2_m
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|u8
modifier|*
name|r
init|=
name|NULL
decl_stmt|;
name|drm_for_each_detailed_block
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|edid
argument_list|,
name|find_gtf2
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|r
condition|?
operator|(
name|r
index|[
literal|15
index|]
operator|<<
literal|8
operator|)
operator|+
name|r
index|[
literal|14
index|]
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_gtf2_k
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|u8
modifier|*
name|r
init|=
name|NULL
decl_stmt|;
name|drm_for_each_detailed_block
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|edid
argument_list|,
name|find_gtf2
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|r
condition|?
name|r
index|[
literal|16
index|]
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_gtf2_2j
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|u8
modifier|*
name|r
init|=
name|NULL
decl_stmt|;
name|drm_for_each_detailed_block
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|edid
argument_list|,
name|find_gtf2
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|r
condition|?
name|r
index|[
literal|17
index|]
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * standard_timing_level - get std. timing level(CVT/GTF/DMT)  * @edid: EDID block to scan  */
end_comment

begin_function
specifier|static
name|int
name|standard_timing_level
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
if|if
condition|(
name|edid
operator|->
name|revision
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|edid
operator|->
name|revision
operator|>=
literal|4
operator|&&
operator|(
name|edid
operator|->
name|features
operator|&
name|DRM_EDID_FEATURE_DEFAULT_GTF
operator|)
condition|)
return|return
name|LEVEL_CVT
return|;
if|if
condition|(
name|drm_gtf2_hbreak
argument_list|(
name|edid
argument_list|)
condition|)
return|return
name|LEVEL_GTF2
return|;
return|return
name|LEVEL_GTF
return|;
block|}
return|return
name|LEVEL_DMT
return|;
block|}
end_function

begin_comment
comment|/*  * 0 is reserved.  The spec says 0x01 fill for unused timings.  Some old  * monitors fill with ascii space (0x20) instead.  */
end_comment

begin_function
specifier|static
name|int
name|bad_std_timing
parameter_list|(
name|u8
name|a
parameter_list|,
name|u8
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|==
literal|0x00
operator|&&
name|b
operator|==
literal|0x00
operator|)
operator|||
operator|(
name|a
operator|==
literal|0x01
operator|&&
name|b
operator|==
literal|0x01
operator|)
operator|||
operator|(
name|a
operator|==
literal|0x20
operator|&&
name|b
operator|==
literal|0x20
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_std - convert standard mode info (width, height, refresh) into mode  * @t: standard timing params  * @timing_level: standard timing level  *  * Take the standard timing params (in this case width, aspect, and refresh)  * and convert them into a real mode using CVT/GTF/DMT.  */
end_comment

begin_function
specifier|static
name|struct
name|drm_display_mode
modifier|*
name|drm_mode_std
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|edid
modifier|*
name|edid
parameter_list|,
name|struct
name|std_timing
modifier|*
name|t
parameter_list|,
name|int
name|revision
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|m
decl_stmt|,
modifier|*
name|mode
init|=
name|NULL
decl_stmt|;
name|int
name|hsize
decl_stmt|,
name|vsize
decl_stmt|;
name|int
name|vrefresh_rate
decl_stmt|;
name|unsigned
name|aspect_ratio
init|=
operator|(
name|t
operator|->
name|vfreq_aspect
operator|&
name|EDID_TIMING_ASPECT_MASK
operator|)
operator|>>
name|EDID_TIMING_ASPECT_SHIFT
decl_stmt|;
name|unsigned
name|vfreq
init|=
operator|(
name|t
operator|->
name|vfreq_aspect
operator|&
name|EDID_TIMING_VFREQ_MASK
operator|)
operator|>>
name|EDID_TIMING_VFREQ_SHIFT
decl_stmt|;
name|int
name|timing_level
init|=
name|standard_timing_level
argument_list|(
name|edid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bad_std_timing
argument_list|(
name|t
operator|->
name|hsize
argument_list|,
name|t
operator|->
name|vfreq_aspect
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* According to the EDID spec, the hdisplay = hsize * 8 + 248 */
name|hsize
operator|=
name|t
operator|->
name|hsize
operator|*
literal|8
operator|+
literal|248
expr_stmt|;
comment|/* vrefresh_rate = vfreq + 60 */
name|vrefresh_rate
operator|=
name|vfreq
operator|+
literal|60
expr_stmt|;
comment|/* the vdisplay is calculated based on the aspect ratio */
if|if
condition|(
name|aspect_ratio
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|revision
operator|<
literal|3
condition|)
name|vsize
operator|=
name|hsize
expr_stmt|;
else|else
name|vsize
operator|=
operator|(
name|hsize
operator|*
literal|10
operator|)
operator|/
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aspect_ratio
operator|==
literal|1
condition|)
name|vsize
operator|=
operator|(
name|hsize
operator|*
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|aspect_ratio
operator|==
literal|2
condition|)
name|vsize
operator|=
operator|(
name|hsize
operator|*
literal|4
operator|)
operator|/
literal|5
expr_stmt|;
else|else
name|vsize
operator|=
operator|(
name|hsize
operator|*
literal|9
operator|)
operator|/
literal|16
expr_stmt|;
comment|/* HDTV hack, part 1 */
if|if
condition|(
name|vrefresh_rate
operator|==
literal|60
operator|&&
operator|(
operator|(
name|hsize
operator|==
literal|1360
operator|&&
name|vsize
operator|==
literal|765
operator|)
operator|||
operator|(
name|hsize
operator|==
literal|1368
operator|&&
name|vsize
operator|==
literal|769
operator|)
operator|)
condition|)
block|{
name|hsize
operator|=
literal|1366
expr_stmt|;
name|vsize
operator|=
literal|768
expr_stmt|;
block|}
comment|/* 	 * If this connector already has a mode for this size and refresh 	 * rate (because it came from detailed or CVT info), use that 	 * instead.  This way we don't have to guess at interlace or 	 * reduced blanking. 	 */
name|list_for_each_entry
argument_list|(
argument|m
argument_list|,
argument|&connector->probed_modes
argument_list|,
argument|head
argument_list|)
if|if
condition|(
name|m
operator|->
name|hdisplay
operator|==
name|hsize
operator|&&
name|m
operator|->
name|vdisplay
operator|==
name|vsize
operator|&&
name|drm_mode_vrefresh
argument_list|(
name|m
argument_list|)
operator|==
name|vrefresh_rate
condition|)
return|return
name|NULL
return|;
comment|/* HDTV hack, part 2 */
if|if
condition|(
name|hsize
operator|==
literal|1366
operator|&&
name|vsize
operator|==
literal|768
operator|&&
name|vrefresh_rate
operator|==
literal|60
condition|)
block|{
name|mode
operator|=
name|drm_cvt_mode
argument_list|(
name|dev
argument_list|,
literal|1366
argument_list|,
literal|768
argument_list|,
name|vrefresh_rate
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|mode
operator|->
name|hdisplay
operator|=
literal|1366
expr_stmt|;
name|mode
operator|->
name|hsync_start
operator|=
name|mode
operator|->
name|hsync_start
operator|-
literal|1
expr_stmt|;
name|mode
operator|->
name|hsync_end
operator|=
name|mode
operator|->
name|hsync_end
operator|-
literal|1
expr_stmt|;
return|return
name|mode
return|;
block|}
comment|/* check whether it can be found in default mode table */
name|mode
operator|=
name|drm_mode_find_dmt
argument_list|(
name|dev
argument_list|,
name|hsize
argument_list|,
name|vsize
argument_list|,
name|vrefresh_rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
condition|)
return|return
name|mode
return|;
switch|switch
condition|(
name|timing_level
condition|)
block|{
case|case
name|LEVEL_DMT
case|:
break|break;
case|case
name|LEVEL_GTF
case|:
name|mode
operator|=
name|drm_gtf_mode
argument_list|(
name|dev
argument_list|,
name|hsize
argument_list|,
name|vsize
argument_list|,
name|vrefresh_rate
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEVEL_GTF2
case|:
comment|/* 		 * This is potentially wrong if there's ever a monitor with 		 * more than one ranges section, each claiming a different 		 * secondary GTF curve.  Please don't do that. 		 */
name|mode
operator|=
name|drm_gtf_mode
argument_list|(
name|dev
argument_list|,
name|hsize
argument_list|,
name|vsize
argument_list|,
name|vrefresh_rate
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|drm_mode_hsync
argument_list|(
name|mode
argument_list|)
operator|>
name|drm_gtf2_hbreak
argument_list|(
name|edid
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|mode
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|mode
operator|=
name|drm_gtf_mode_complex
argument_list|(
name|dev
argument_list|,
name|hsize
argument_list|,
name|vsize
argument_list|,
name|vrefresh_rate
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drm_gtf2_m
argument_list|(
name|edid
argument_list|)
argument_list|,
name|drm_gtf2_2c
argument_list|(
name|edid
argument_list|)
argument_list|,
name|drm_gtf2_k
argument_list|(
name|edid
argument_list|)
argument_list|,
name|drm_gtf2_2j
argument_list|(
name|edid
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LEVEL_CVT
case|:
name|mode
operator|=
name|drm_cvt_mode
argument_list|(
name|dev
argument_list|,
name|hsize
argument_list|,
name|vsize
argument_list|,
name|vrefresh_rate
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_comment
comment|/*  * EDID is delightfully ambiguous about how interlaced modes are to be  * encoded.  Our internal representation is of frame height, but some  * HDTV detailed timings are encoded as field height.  *  * The format list here is from CEA, in frame size.  Technically we  * should be checking refresh rate too.  Whatever.  */
end_comment

begin_function
specifier|static
name|void
name|drm_mode_do_interlace_quirk
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|detailed_pixel_timing
modifier|*
name|pt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
struct|struct
block|{
name|int
name|w
decl_stmt|,
name|h
decl_stmt|;
block|}
name|cea_interlaced
index|[]
init|=
block|{
block|{
literal|1920
block|,
literal|1080
block|}
block|,
block|{
literal|720
block|,
literal|480
block|}
block|,
block|{
literal|1440
block|,
literal|480
block|}
block|,
block|{
literal|2880
block|,
literal|480
block|}
block|,
block|{
literal|720
block|,
literal|576
block|}
block|,
block|{
literal|1440
block|,
literal|576
block|}
block|,
block|{
literal|2880
block|,
literal|576
block|}
block|, 	}
struct|;
if|if
condition|(
operator|!
operator|(
name|pt
operator|->
name|misc
operator|&
name|DRM_EDID_PT_INTERLACED
operator|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_ARRAY_SIZE
argument_list|(
name|cea_interlaced
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mode
operator|->
name|hdisplay
operator|==
name|cea_interlaced
index|[
name|i
index|]
operator|.
name|w
operator|)
operator|&&
operator|(
name|mode
operator|->
name|vdisplay
operator|==
name|cea_interlaced
index|[
name|i
index|]
operator|.
name|h
operator|/
literal|2
operator|)
condition|)
block|{
name|mode
operator|->
name|vdisplay
operator|*=
literal|2
expr_stmt|;
name|mode
operator|->
name|vsync_start
operator|*=
literal|2
expr_stmt|;
name|mode
operator|->
name|vsync_end
operator|*=
literal|2
expr_stmt|;
name|mode
operator|->
name|vtotal
operator|*=
literal|2
expr_stmt|;
name|mode
operator|->
name|vtotal
operator||=
literal|1
expr_stmt|;
block|}
block|}
name|mode
operator|->
name|flags
operator||=
name|DRM_MODE_FLAG_INTERLACE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_detailed - create a new mode from an EDID detailed timing section  * @dev: DRM device (needed to create new mode)  * @edid: EDID block  * @timing: EDID detailed timing info  * @quirks: quirks to apply  *  * An EDID detailed timing block contains enough info for us to create and  * return a new struct drm_display_mode.  */
end_comment

begin_function
specifier|static
name|struct
name|drm_display_mode
modifier|*
name|drm_mode_detailed
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|edid
modifier|*
name|edid
parameter_list|,
name|struct
name|detailed_timing
modifier|*
name|timing
parameter_list|,
name|u32
name|quirks
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|struct
name|detailed_pixel_timing
modifier|*
name|pt
init|=
operator|&
name|timing
operator|->
name|data
operator|.
name|pixel_data
decl_stmt|;
name|unsigned
name|hactive
init|=
operator|(
name|pt
operator|->
name|hactive_hblank_hi
operator|&
literal|0xf0
operator|)
operator|<<
literal|4
operator||
name|pt
operator|->
name|hactive_lo
decl_stmt|;
name|unsigned
name|vactive
init|=
operator|(
name|pt
operator|->
name|vactive_vblank_hi
operator|&
literal|0xf0
operator|)
operator|<<
literal|4
operator||
name|pt
operator|->
name|vactive_lo
decl_stmt|;
name|unsigned
name|hblank
init|=
operator|(
name|pt
operator|->
name|hactive_hblank_hi
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator||
name|pt
operator|->
name|hblank_lo
decl_stmt|;
name|unsigned
name|vblank
init|=
operator|(
name|pt
operator|->
name|vactive_vblank_hi
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator||
name|pt
operator|->
name|vblank_lo
decl_stmt|;
name|unsigned
name|hsync_offset
init|=
operator|(
name|pt
operator|->
name|hsync_vsync_offset_pulse_width_hi
operator|&
literal|0xc0
operator|)
operator|<<
literal|2
operator||
name|pt
operator|->
name|hsync_offset_lo
decl_stmt|;
name|unsigned
name|hsync_pulse_width
init|=
operator|(
name|pt
operator|->
name|hsync_vsync_offset_pulse_width_hi
operator|&
literal|0x30
operator|)
operator|<<
literal|4
operator||
name|pt
operator|->
name|hsync_pulse_width_lo
decl_stmt|;
name|unsigned
name|vsync_offset
init|=
operator|(
name|pt
operator|->
name|hsync_vsync_offset_pulse_width_hi
operator|&
literal|0xc
operator|)
operator|>>
literal|2
operator||
name|pt
operator|->
name|vsync_offset_pulse_width_lo
operator|>>
literal|4
decl_stmt|;
name|unsigned
name|vsync_pulse_width
init|=
operator|(
name|pt
operator|->
name|hsync_vsync_offset_pulse_width_hi
operator|&
literal|0x3
operator|)
operator|<<
literal|4
operator||
operator|(
name|pt
operator|->
name|vsync_offset_pulse_width_lo
operator|&
literal|0xf
operator|)
decl_stmt|;
comment|/* ignore tiny modes */
if|if
condition|(
name|hactive
operator|<
literal|64
operator|||
name|vactive
operator|<
literal|64
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|pt
operator|->
name|misc
operator|&
name|DRM_EDID_PT_STEREO
condition|)
block|{
name|printf
argument_list|(
literal|"stereo mode not supported\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|pt
operator|->
name|misc
operator|&
name|DRM_EDID_PT_SEPARATE_SYNC
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"composite sync not supported\n"
argument_list|)
expr_stmt|;
block|}
comment|/* it is incorrect if hsync/vsync width is zero */
if|if
condition|(
operator|!
name|hsync_pulse_width
operator|||
operator|!
name|vsync_pulse_width
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Incorrect Detailed timing. "
literal|"Wrong Hsync/Vsync pulse width\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|mode
operator|=
name|drm_mode_create
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
return|return
name|NULL
return|;
name|mode
operator|->
name|type
operator|=
name|DRM_MODE_TYPE_DRIVER
expr_stmt|;
if|if
condition|(
name|quirks
operator|&
name|EDID_QUIRK_135_CLOCK_TOO_HIGH
condition|)
name|timing
operator|->
name|pixel_clock
operator|=
name|htole16
argument_list|(
literal|1088
argument_list|)
expr_stmt|;
name|mode
operator|->
name|clock
operator|=
name|le16toh
argument_list|(
name|timing
operator|->
name|pixel_clock
argument_list|)
operator|*
literal|10
expr_stmt|;
name|mode
operator|->
name|hdisplay
operator|=
name|hactive
expr_stmt|;
name|mode
operator|->
name|hsync_start
operator|=
name|mode
operator|->
name|hdisplay
operator|+
name|hsync_offset
expr_stmt|;
name|mode
operator|->
name|hsync_end
operator|=
name|mode
operator|->
name|hsync_start
operator|+
name|hsync_pulse_width
expr_stmt|;
name|mode
operator|->
name|htotal
operator|=
name|mode
operator|->
name|hdisplay
operator|+
name|hblank
expr_stmt|;
name|mode
operator|->
name|vdisplay
operator|=
name|vactive
expr_stmt|;
name|mode
operator|->
name|vsync_start
operator|=
name|mode
operator|->
name|vdisplay
operator|+
name|vsync_offset
expr_stmt|;
name|mode
operator|->
name|vsync_end
operator|=
name|mode
operator|->
name|vsync_start
operator|+
name|vsync_pulse_width
expr_stmt|;
name|mode
operator|->
name|vtotal
operator|=
name|mode
operator|->
name|vdisplay
operator|+
name|vblank
expr_stmt|;
comment|/* Some EDIDs have bogus h/vtotal values */
if|if
condition|(
name|mode
operator|->
name|hsync_end
operator|>
name|mode
operator|->
name|htotal
condition|)
name|mode
operator|->
name|htotal
operator|=
name|mode
operator|->
name|hsync_end
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|vsync_end
operator|>
name|mode
operator|->
name|vtotal
condition|)
name|mode
operator|->
name|vtotal
operator|=
name|mode
operator|->
name|vsync_end
operator|+
literal|1
expr_stmt|;
name|drm_mode_do_interlace_quirk
argument_list|(
name|mode
argument_list|,
name|pt
argument_list|)
expr_stmt|;
name|drm_mode_set_name
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|quirks
operator|&
name|EDID_QUIRK_DETAILED_SYNC_PP
condition|)
block|{
name|pt
operator|->
name|misc
operator||=
name|DRM_EDID_PT_HSYNC_POSITIVE
operator||
name|DRM_EDID_PT_VSYNC_POSITIVE
expr_stmt|;
block|}
name|mode
operator|->
name|flags
operator||=
operator|(
name|pt
operator|->
name|misc
operator|&
name|DRM_EDID_PT_HSYNC_POSITIVE
operator|)
condition|?
name|DRM_MODE_FLAG_PHSYNC
else|:
name|DRM_MODE_FLAG_NHSYNC
expr_stmt|;
name|mode
operator|->
name|flags
operator||=
operator|(
name|pt
operator|->
name|misc
operator|&
name|DRM_EDID_PT_VSYNC_POSITIVE
operator|)
condition|?
name|DRM_MODE_FLAG_PVSYNC
else|:
name|DRM_MODE_FLAG_NVSYNC
expr_stmt|;
name|mode
operator|->
name|width_mm
operator|=
name|pt
operator|->
name|width_mm_lo
operator||
operator|(
name|pt
operator|->
name|width_height_mm_hi
operator|&
literal|0xf0
operator|)
operator|<<
literal|4
expr_stmt|;
name|mode
operator|->
name|height_mm
operator|=
name|pt
operator|->
name|height_mm_lo
operator||
operator|(
name|pt
operator|->
name|width_height_mm_hi
operator|&
literal|0xf
operator|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|quirks
operator|&
name|EDID_QUIRK_DETAILED_IN_CM
condition|)
block|{
name|mode
operator|->
name|width_mm
operator|*=
literal|10
expr_stmt|;
name|mode
operator|->
name|height_mm
operator|*=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|quirks
operator|&
name|EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE
condition|)
block|{
name|mode
operator|->
name|width_mm
operator|=
name|edid
operator|->
name|width_cm
operator|*
literal|10
expr_stmt|;
name|mode
operator|->
name|height_mm
operator|=
name|edid
operator|->
name|height_cm
operator|*
literal|10
expr_stmt|;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|mode_is_rb
parameter_list|(
specifier|const
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
return|return
operator|(
name|mode
operator|->
name|htotal
operator|-
name|mode
operator|->
name|hdisplay
operator|==
literal|160
operator|)
operator|&&
operator|(
name|mode
operator|->
name|hsync_end
operator|-
name|mode
operator|->
name|hdisplay
operator|==
literal|80
operator|)
operator|&&
operator|(
name|mode
operator|->
name|hsync_end
operator|-
name|mode
operator|->
name|hsync_start
operator|==
literal|32
operator|)
operator|&&
operator|(
name|mode
operator|->
name|vsync_start
operator|-
name|mode
operator|->
name|vdisplay
operator|==
literal|3
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|mode_in_hsync_range
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|edid
modifier|*
name|edid
parameter_list|,
name|u8
modifier|*
name|t
parameter_list|)
block|{
name|int
name|hsync
decl_stmt|,
name|hmin
decl_stmt|,
name|hmax
decl_stmt|;
name|hmin
operator|=
name|t
index|[
literal|7
index|]
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|revision
operator|>=
literal|4
condition|)
name|hmin
operator|+=
operator|(
operator|(
name|t
index|[
literal|4
index|]
operator|&
literal|0x04
operator|)
condition|?
literal|255
else|:
literal|0
operator|)
expr_stmt|;
name|hmax
operator|=
name|t
index|[
literal|8
index|]
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|revision
operator|>=
literal|4
condition|)
name|hmax
operator|+=
operator|(
operator|(
name|t
index|[
literal|4
index|]
operator|&
literal|0x08
operator|)
condition|?
literal|255
else|:
literal|0
operator|)
expr_stmt|;
name|hsync
operator|=
name|drm_mode_hsync
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|hsync
operator|<=
name|hmax
operator|&&
name|hsync
operator|>=
name|hmin
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|mode_in_vsync_range
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|edid
modifier|*
name|edid
parameter_list|,
name|u8
modifier|*
name|t
parameter_list|)
block|{
name|int
name|vsync
decl_stmt|,
name|vmin
decl_stmt|,
name|vmax
decl_stmt|;
name|vmin
operator|=
name|t
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|revision
operator|>=
literal|4
condition|)
name|vmin
operator|+=
operator|(
operator|(
name|t
index|[
literal|4
index|]
operator|&
literal|0x01
operator|)
condition|?
literal|255
else|:
literal|0
operator|)
expr_stmt|;
name|vmax
operator|=
name|t
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|revision
operator|>=
literal|4
condition|)
name|vmax
operator|+=
operator|(
operator|(
name|t
index|[
literal|4
index|]
operator|&
literal|0x02
operator|)
condition|?
literal|255
else|:
literal|0
operator|)
expr_stmt|;
name|vsync
operator|=
name|drm_mode_vrefresh
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|vsync
operator|<=
name|vmax
operator|&&
name|vsync
operator|>=
name|vmin
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|range_pixel_clock
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|,
name|u8
modifier|*
name|t
parameter_list|)
block|{
comment|/* unspecified */
if|if
condition|(
name|t
index|[
literal|9
index|]
operator|==
literal|0
operator|||
name|t
index|[
literal|9
index|]
operator|==
literal|255
condition|)
return|return
literal|0
return|;
comment|/* 1.4 with CVT support gives us real precision, yay */
if|if
condition|(
name|edid
operator|->
name|revision
operator|>=
literal|4
operator|&&
name|t
index|[
literal|10
index|]
operator|==
literal|0x04
condition|)
return|return
operator|(
name|t
index|[
literal|9
index|]
operator|*
literal|10000
operator|)
operator|-
operator|(
operator|(
name|t
index|[
literal|12
index|]
operator|>>
literal|2
operator|)
operator|*
literal|250
operator|)
return|;
comment|/* 1.3 is pathetic, so fuzz up a bit */
return|return
name|t
index|[
literal|9
index|]
operator|*
literal|10000
operator|+
literal|5001
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|mode_in_range
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|edid
modifier|*
name|edid
parameter_list|,
name|struct
name|detailed_timing
modifier|*
name|timing
parameter_list|)
block|{
name|u32
name|max_clock
decl_stmt|;
name|u8
modifier|*
name|t
init|=
operator|(
name|u8
operator|*
operator|)
name|timing
decl_stmt|;
if|if
condition|(
operator|!
name|mode_in_hsync_range
argument_list|(
name|mode
argument_list|,
name|edid
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|mode_in_vsync_range
argument_list|(
name|mode
argument_list|,
name|edid
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|max_clock
operator|=
name|range_pixel_clock
argument_list|(
name|edid
argument_list|,
name|t
argument_list|)
operator|)
condition|)
if|if
condition|(
name|mode
operator|->
name|clock
operator|>
name|max_clock
condition|)
return|return
name|false
return|;
comment|/* 1.4 max horizontal check */
if|if
condition|(
name|edid
operator|->
name|revision
operator|>=
literal|4
operator|&&
name|t
index|[
literal|10
index|]
operator|==
literal|0x04
condition|)
if|if
condition|(
name|t
index|[
literal|13
index|]
operator|&&
name|mode
operator|->
name|hdisplay
operator|>
literal|8
operator|*
operator|(
name|t
index|[
literal|13
index|]
operator|+
operator|(
literal|256
operator|*
operator|(
name|t
index|[
literal|12
index|]
operator|&
literal|0x3
operator|)
operator|)
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|mode_is_rb
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|drm_monitor_supports_rb
argument_list|(
name|edid
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * XXX If drm_dmt_modes ever regrows the CVT-R modes (and it will) this will  * need to account for them.  */
end_comment

begin_function
specifier|static
name|int
name|drm_gtf_modes_for_range
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|edid
modifier|*
name|edid
parameter_list|,
name|struct
name|detailed_timing
modifier|*
name|timing
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|modes
init|=
literal|0
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|newmode
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|drm_num_dmt_modes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mode_in_range
argument_list|(
name|drm_dmt_modes
operator|+
name|i
argument_list|,
name|edid
argument_list|,
name|timing
argument_list|)
condition|)
block|{
name|newmode
operator|=
name|drm_mode_duplicate
argument_list|(
name|dev
argument_list|,
operator|&
name|drm_dmt_modes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmode
condition|)
block|{
name|drm_mode_probed_add
argument_list|(
name|connector
argument_list|,
name|newmode
argument_list|)
expr_stmt|;
name|modes
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|modes
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_inferred_modes
parameter_list|(
name|struct
name|detailed_timing
modifier|*
name|timing
parameter_list|,
name|void
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|detailed_mode_closure
modifier|*
name|closure
init|=
name|c
decl_stmt|;
name|struct
name|detailed_non_pixel
modifier|*
name|data
init|=
operator|&
name|timing
operator|->
name|data
operator|.
name|other_data
decl_stmt|;
name|int
name|gtf
init|=
operator|(
name|closure
operator|->
name|edid
operator|->
name|features
operator|&
name|DRM_EDID_FEATURE_DEFAULT_GTF
operator|)
decl_stmt|;
if|if
condition|(
name|gtf
operator|&&
name|data
operator|->
name|type
operator|==
name|EDID_DETAIL_MONITOR_RANGE
condition|)
name|closure
operator|->
name|modes
operator|+=
name|drm_gtf_modes_for_range
argument_list|(
name|closure
operator|->
name|connector
argument_list|,
name|closure
operator|->
name|edid
argument_list|,
name|timing
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_inferred_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|struct
name|detailed_mode_closure
name|closure
init|=
block|{
name|connector
block|,
name|edid
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|version_greater
argument_list|(
name|edid
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|drm_for_each_detailed_block
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|edid
argument_list|,
name|do_inferred_modes
argument_list|,
operator|&
name|closure
argument_list|)
expr_stmt|;
return|return
name|closure
operator|.
name|modes
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_est3_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|detailed_timing
modifier|*
name|timing
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|m
decl_stmt|,
name|modes
init|=
literal|0
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|u8
modifier|*
name|est
init|=
operator|(
operator|(
name|u8
operator|*
operator|)
name|timing
operator|)
operator|+
literal|5
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|7
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|m
operator|=
operator|(
name|i
operator|*
literal|8
operator|)
operator|+
operator|(
literal|7
operator|-
name|j
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|>=
name|DRM_ARRAY_SIZE
argument_list|(
name|est3_modes
argument_list|)
condition|)
break|break;
if|if
condition|(
name|est
index|[
name|i
index|]
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
block|{
name|mode
operator|=
name|drm_mode_find_dmt
argument_list|(
name|connector
operator|->
name|dev
argument_list|,
name|est3_modes
index|[
name|m
index|]
operator|.
name|w
argument_list|,
name|est3_modes
index|[
name|m
index|]
operator|.
name|h
argument_list|,
name|est3_modes
index|[
name|m
index|]
operator|.
name|r
comment|/*, est3_modes[m].rb */
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
condition|)
block|{
name|drm_mode_probed_add
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|modes
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|modes
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_established_modes
parameter_list|(
name|struct
name|detailed_timing
modifier|*
name|timing
parameter_list|,
name|void
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|detailed_mode_closure
modifier|*
name|closure
init|=
name|c
decl_stmt|;
name|struct
name|detailed_non_pixel
modifier|*
name|data
init|=
operator|&
name|timing
operator|->
name|data
operator|.
name|other_data
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|type
operator|==
name|EDID_DETAIL_EST_TIMINGS
condition|)
name|closure
operator|->
name|modes
operator|+=
name|drm_est3_modes
argument_list|(
name|closure
operator|->
name|connector
argument_list|,
name|timing
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * add_established_modes - get est. modes from EDID and add them  * @edid: EDID block to scan  *  * Each EDID block contains a bitmap of the supported "established modes" list  * (defined above).  Tease them out and add them to the global modes list.  */
end_comment

begin_function
specifier|static
name|int
name|add_established_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|unsigned
name|long
name|est_bits
init|=
name|edid
operator|->
name|established_timings
operator|.
name|t1
operator||
operator|(
name|edid
operator|->
name|established_timings
operator|.
name|t2
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|edid
operator|->
name|established_timings
operator|.
name|mfg_rsvd
operator|&
literal|0x80
operator|)
operator|<<
literal|9
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|modes
init|=
literal|0
decl_stmt|;
name|struct
name|detailed_mode_closure
name|closure
init|=
block|{
name|connector
block|,
name|edid
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|EDID_EST_TIMINGS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|est_bits
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|newmode
decl_stmt|;
name|newmode
operator|=
name|drm_mode_duplicate
argument_list|(
name|dev
argument_list|,
operator|&
name|edid_est_modes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmode
condition|)
block|{
name|drm_mode_probed_add
argument_list|(
name|connector
argument_list|,
name|newmode
argument_list|)
expr_stmt|;
name|modes
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|version_greater
argument_list|(
name|edid
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|drm_for_each_detailed_block
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|edid
argument_list|,
name|do_established_modes
argument_list|,
operator|&
name|closure
argument_list|)
expr_stmt|;
return|return
name|modes
operator|+
name|closure
operator|.
name|modes
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_standard_modes
parameter_list|(
name|struct
name|detailed_timing
modifier|*
name|timing
parameter_list|,
name|void
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|detailed_mode_closure
modifier|*
name|closure
init|=
name|c
decl_stmt|;
name|struct
name|detailed_non_pixel
modifier|*
name|data
init|=
operator|&
name|timing
operator|->
name|data
operator|.
name|other_data
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
init|=
name|closure
operator|->
name|connector
decl_stmt|;
name|struct
name|edid
modifier|*
name|edid
init|=
name|closure
operator|->
name|edid
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|type
operator|==
name|EDID_DETAIL_STD_MODES
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|std_timing
modifier|*
name|std
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|newmode
decl_stmt|;
name|std
operator|=
operator|&
name|data
operator|->
name|data
operator|.
name|timings
index|[
name|i
index|]
expr_stmt|;
name|newmode
operator|=
name|drm_mode_std
argument_list|(
name|connector
argument_list|,
name|edid
argument_list|,
name|std
argument_list|,
name|edid
operator|->
name|revision
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmode
condition|)
block|{
name|drm_mode_probed_add
argument_list|(
name|connector
argument_list|,
name|newmode
argument_list|)
expr_stmt|;
name|closure
operator|->
name|modes
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * add_standard_modes - get std. modes from EDID and add them  * @edid: EDID block to scan  *  * Standard modes can be calculated using the appropriate standard (DMT,  * GTF or CVT. Grab them from @edid and add them to the list.  */
end_comment

begin_function
specifier|static
name|int
name|add_standard_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|modes
init|=
literal|0
decl_stmt|;
name|struct
name|detailed_mode_closure
name|closure
init|=
block|{
name|connector
block|,
name|edid
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EDID_STD_TIMINGS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|newmode
decl_stmt|;
name|newmode
operator|=
name|drm_mode_std
argument_list|(
name|connector
argument_list|,
name|edid
argument_list|,
operator|&
name|edid
operator|->
name|standard_timings
index|[
name|i
index|]
argument_list|,
name|edid
operator|->
name|revision
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmode
condition|)
block|{
name|drm_mode_probed_add
argument_list|(
name|connector
argument_list|,
name|newmode
argument_list|)
expr_stmt|;
name|modes
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|version_greater
argument_list|(
name|edid
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|drm_for_each_detailed_block
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|edid
argument_list|,
name|do_standard_modes
argument_list|,
operator|&
name|closure
argument_list|)
expr_stmt|;
comment|/* XXX should also look for standard codes in VTB blocks */
return|return
name|modes
operator|+
name|closure
operator|.
name|modes
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_cvt_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|detailed_timing
modifier|*
name|timing
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|modes
init|=
literal|0
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|newmode
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|cvt_timing
modifier|*
name|cvt
decl_stmt|;
specifier|const
name|int
name|rates
index|[]
init|=
block|{
literal|60
block|,
literal|85
block|,
literal|75
block|,
literal|60
block|,
literal|50
block|}
decl_stmt|;
specifier|const
name|u8
name|empty
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|int
name|width
init|=
literal|0
decl_stmt|,
name|height
decl_stmt|;
name|cvt
operator|=
operator|&
operator|(
name|timing
operator|->
name|data
operator|.
name|other_data
operator|.
name|data
operator|.
name|cvt
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|cvt
operator|->
name|code
argument_list|,
name|empty
argument_list|,
literal|3
argument_list|)
condition|)
continue|continue;
name|height
operator|=
operator|(
name|cvt
operator|->
name|code
index|[
literal|0
index|]
operator|+
operator|(
operator|(
name|cvt
operator|->
name|code
index|[
literal|1
index|]
operator|&
literal|0xf0
operator|)
operator|<<
literal|4
operator|)
operator|+
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
switch|switch
condition|(
name|cvt
operator|->
name|code
index|[
literal|1
index|]
operator|&
literal|0x0c
condition|)
block|{
case|case
literal|0x00
case|:
name|width
operator|=
name|height
operator|*
literal|4
operator|/
literal|3
expr_stmt|;
break|break;
case|case
literal|0x04
case|:
name|width
operator|=
name|height
operator|*
literal|16
operator|/
literal|9
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
name|width
operator|=
name|height
operator|*
literal|16
operator|/
literal|10
expr_stmt|;
break|break;
case|case
literal|0x0c
case|:
name|width
operator|=
name|height
operator|*
literal|15
operator|/
literal|9
expr_stmt|;
break|break;
block|}
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|5
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cvt
operator|->
name|code
index|[
literal|2
index|]
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
block|{
name|newmode
operator|=
name|drm_cvt_mode
argument_list|(
name|dev
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|rates
index|[
name|j
index|]
argument_list|,
name|j
operator|==
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmode
condition|)
block|{
name|drm_mode_probed_add
argument_list|(
name|connector
argument_list|,
name|newmode
argument_list|)
expr_stmt|;
name|modes
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|modes
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_cvt_mode
parameter_list|(
name|struct
name|detailed_timing
modifier|*
name|timing
parameter_list|,
name|void
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|detailed_mode_closure
modifier|*
name|closure
init|=
name|c
decl_stmt|;
name|struct
name|detailed_non_pixel
modifier|*
name|data
init|=
operator|&
name|timing
operator|->
name|data
operator|.
name|other_data
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|type
operator|==
name|EDID_DETAIL_CVT_3BYTE
condition|)
name|closure
operator|->
name|modes
operator|+=
name|drm_cvt_modes
argument_list|(
name|closure
operator|->
name|connector
argument_list|,
name|timing
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_cvt_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|struct
name|detailed_mode_closure
name|closure
init|=
block|{
name|connector
block|,
name|edid
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|version_greater
argument_list|(
name|edid
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
name|drm_for_each_detailed_block
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|edid
argument_list|,
name|do_cvt_mode
argument_list|,
operator|&
name|closure
argument_list|)
expr_stmt|;
comment|/* XXX should also look for CVT codes in VTB blocks */
return|return
name|closure
operator|.
name|modes
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_detailed_mode
parameter_list|(
name|struct
name|detailed_timing
modifier|*
name|timing
parameter_list|,
name|void
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|detailed_mode_closure
modifier|*
name|closure
init|=
name|c
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|newmode
decl_stmt|;
if|if
condition|(
name|timing
operator|->
name|pixel_clock
condition|)
block|{
name|newmode
operator|=
name|drm_mode_detailed
argument_list|(
name|closure
operator|->
name|connector
operator|->
name|dev
argument_list|,
name|closure
operator|->
name|edid
argument_list|,
name|timing
argument_list|,
name|closure
operator|->
name|quirks
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newmode
condition|)
return|return;
if|if
condition|(
name|closure
operator|->
name|preferred
condition|)
name|newmode
operator|->
name|type
operator||=
name|DRM_MODE_TYPE_PREFERRED
expr_stmt|;
name|drm_mode_probed_add
argument_list|(
name|closure
operator|->
name|connector
argument_list|,
name|newmode
argument_list|)
expr_stmt|;
name|closure
operator|->
name|modes
operator|++
expr_stmt|;
name|closure
operator|->
name|preferred
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * add_detailed_modes - Add modes from detailed timings  * @connector: attached connector  * @edid: EDID block to scan  * @quirks: quirks to apply  */
end_comment

begin_function
specifier|static
name|int
name|add_detailed_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|edid
modifier|*
name|edid
parameter_list|,
name|u32
name|quirks
parameter_list|)
block|{
name|struct
name|detailed_mode_closure
name|closure
init|=
block|{
name|connector
block|,
name|edid
block|,
literal|1
block|,
name|quirks
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|closure
operator|.
name|preferred
operator|&&
operator|!
name|version_greater
argument_list|(
name|edid
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
condition|)
name|closure
operator|.
name|preferred
operator|=
operator|(
name|edid
operator|->
name|features
operator|&
name|DRM_EDID_FEATURE_PREFERRED_TIMING
operator|)
expr_stmt|;
name|drm_for_each_detailed_block
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|edid
argument_list|,
name|do_detailed_mode
argument_list|,
operator|&
name|closure
argument_list|)
expr_stmt|;
return|return
name|closure
operator|.
name|modes
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HDMI_IDENTIFIER
value|0x000C03
end_define

begin_define
define|#
directive|define
name|AUDIO_BLOCK
value|0x01
end_define

begin_define
define|#
directive|define
name|VENDOR_BLOCK
value|0x03
end_define

begin_define
define|#
directive|define
name|SPEAKER_BLOCK
value|0x04
end_define

begin_define
define|#
directive|define
name|EDID_BASIC_AUDIO
value|(1<< 6)
end_define

begin_comment
comment|/**  * Search EDID for CEA extension block.  */
end_comment

begin_function
name|u8
modifier|*
name|drm_find_cea_extension
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|u8
modifier|*
name|edid_ext
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* No EDID or EDID extensions */
if|if
condition|(
name|edid
operator|==
name|NULL
operator|||
name|edid
operator|->
name|extensions
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* Find CEA extension */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|edid
operator|->
name|extensions
condition|;
name|i
operator|++
control|)
block|{
name|edid_ext
operator|=
operator|(
name|u8
operator|*
operator|)
name|edid
operator|+
name|EDID_LENGTH
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|edid_ext
index|[
literal|0
index|]
operator|==
name|CEA_EXT
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|edid
operator|->
name|extensions
condition|)
return|return
name|NULL
return|;
return|return
name|edid_ext
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_hdmi_vsdb
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|uint8_t
modifier|*
name|db
parameter_list|)
block|{
name|connector
operator|->
name|eld
index|[
literal|5
index|]
operator||=
operator|(
name|db
index|[
literal|6
index|]
operator|>>
literal|7
operator|)
operator|<<
literal|1
expr_stmt|;
comment|/* Supports_AI */
name|connector
operator|->
name|dvi_dual
operator|=
name|db
index|[
literal|6
index|]
operator|&
literal|1
expr_stmt|;
name|connector
operator|->
name|max_tmds_clock
operator|=
name|db
index|[
literal|7
index|]
operator|*
literal|5
expr_stmt|;
name|connector
operator|->
name|latency_present
index|[
literal|0
index|]
operator|=
name|db
index|[
literal|8
index|]
operator|>>
literal|7
expr_stmt|;
name|connector
operator|->
name|latency_present
index|[
literal|1
index|]
operator|=
operator|(
name|db
index|[
literal|8
index|]
operator|>>
literal|6
operator|)
operator|&
literal|1
expr_stmt|;
name|connector
operator|->
name|video_latency
index|[
literal|0
index|]
operator|=
name|db
index|[
literal|9
index|]
expr_stmt|;
name|connector
operator|->
name|audio_latency
index|[
literal|0
index|]
operator|=
name|db
index|[
literal|10
index|]
expr_stmt|;
name|connector
operator|->
name|video_latency
index|[
literal|1
index|]
operator|=
name|db
index|[
literal|11
index|]
expr_stmt|;
name|connector
operator|->
name|audio_latency
index|[
literal|1
index|]
operator|=
name|db
index|[
literal|12
index|]
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"HDMI: DVI dual %d, "
literal|"max TMDS clock %d, "
literal|"latency present %d %d, "
literal|"video latency %d %d, "
literal|"audio latency %d %d\n"
argument_list|,
name|connector
operator|->
name|dvi_dual
argument_list|,
name|connector
operator|->
name|max_tmds_clock
argument_list|,
operator|(
name|int
operator|)
name|connector
operator|->
name|latency_present
index|[
literal|0
index|]
argument_list|,
operator|(
name|int
operator|)
name|connector
operator|->
name|latency_present
index|[
literal|1
index|]
argument_list|,
name|connector
operator|->
name|video_latency
index|[
literal|0
index|]
argument_list|,
name|connector
operator|->
name|video_latency
index|[
literal|1
index|]
argument_list|,
name|connector
operator|->
name|audio_latency
index|[
literal|0
index|]
argument_list|,
name|connector
operator|->
name|audio_latency
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_name
parameter_list|(
name|struct
name|detailed_timing
modifier|*
name|t
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|data
operator|.
name|other_data
operator|.
name|type
operator|==
name|EDID_DETAIL_MONITOR_NAME
condition|)
operator|*
operator|(
name|u8
operator|*
operator|*
operator|)
name|data
operator|=
name|t
operator|->
name|data
operator|.
name|other_data
operator|.
name|data
operator|.
name|str
operator|.
name|str
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_edid_to_eld - build ELD from EDID  * @connector: connector corresponding to the HDMI/DP sink  * @edid: EDID to parse  *  * Fill the ELD (EDID-Like Data) buffer for passing to the audio driver.  * Some ELD fields are left to the graphics driver caller:  * - Conn_Type  * - HDCP  * - Port_ID  */
end_comment

begin_function
name|void
name|drm_edid_to_eld
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|uint8_t
modifier|*
name|eld
init|=
name|connector
operator|->
name|eld
decl_stmt|;
name|u8
modifier|*
name|cea
decl_stmt|;
name|u8
modifier|*
name|name
decl_stmt|;
name|u8
modifier|*
name|db
decl_stmt|;
name|int
name|sad_count
init|=
literal|0
decl_stmt|;
name|int
name|mnl
decl_stmt|;
name|int
name|dbl
decl_stmt|;
name|memset
argument_list|(
name|eld
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|connector
operator|->
name|eld
argument_list|)
argument_list|)
expr_stmt|;
name|cea
operator|=
name|drm_find_cea_extension
argument_list|(
name|edid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cea
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"ELD: no CEA Extension found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|NULL
expr_stmt|;
name|drm_for_each_detailed_block
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|edid
argument_list|,
name|monitor_name
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|mnl
operator|=
literal|0
init|;
name|name
operator|&&
name|mnl
operator|<
literal|13
condition|;
name|mnl
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
name|mnl
index|]
operator|==
literal|0x0a
condition|)
break|break;
name|eld
index|[
literal|20
operator|+
name|mnl
index|]
operator|=
name|name
index|[
name|mnl
index|]
expr_stmt|;
block|}
name|eld
index|[
literal|4
index|]
operator|=
operator|(
name|cea
index|[
literal|1
index|]
operator|<<
literal|5
operator|)
operator||
name|mnl
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"ELD monitor %s\n"
argument_list|,
name|eld
operator|+
literal|20
argument_list|)
expr_stmt|;
name|eld
index|[
literal|0
index|]
operator|=
literal|2
operator|<<
literal|3
expr_stmt|;
comment|/* ELD version: 2 */
name|eld
index|[
literal|16
index|]
operator|=
name|edid
operator|->
name|mfg_id
index|[
literal|0
index|]
expr_stmt|;
name|eld
index|[
literal|17
index|]
operator|=
name|edid
operator|->
name|mfg_id
index|[
literal|1
index|]
expr_stmt|;
name|eld
index|[
literal|18
index|]
operator|=
name|edid
operator|->
name|prod_code
index|[
literal|0
index|]
expr_stmt|;
name|eld
index|[
literal|19
index|]
operator|=
name|edid
operator|->
name|prod_code
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|db
operator|=
name|cea
operator|+
literal|4
init|;
name|db
operator|<
name|cea
operator|+
name|cea
index|[
literal|2
index|]
condition|;
name|db
operator|+=
name|dbl
operator|+
literal|1
control|)
block|{
name|dbl
operator|=
name|db
index|[
literal|0
index|]
operator|&
literal|0x1f
expr_stmt|;
switch|switch
condition|(
operator|(
name|db
index|[
literal|0
index|]
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
condition|)
block|{
case|case
name|AUDIO_BLOCK
case|:
comment|/* Audio Data Block, contains SADs */
name|sad_count
operator|=
name|dbl
operator|/
literal|3
expr_stmt|;
name|memcpy
argument_list|(
name|eld
operator|+
literal|20
operator|+
name|mnl
argument_list|,
operator|&
name|db
index|[
literal|1
index|]
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPEAKER_BLOCK
case|:
comment|/* Speaker Allocation Data Block */
name|eld
index|[
literal|7
index|]
operator|=
name|db
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|VENDOR_BLOCK
case|:
comment|/* HDMI Vendor-Specific Data Block */
if|if
condition|(
name|db
index|[
literal|1
index|]
operator|==
literal|0x03
operator|&&
name|db
index|[
literal|2
index|]
operator|==
literal|0x0c
operator|&&
name|db
index|[
literal|3
index|]
operator|==
literal|0
condition|)
name|parse_hdmi_vsdb
argument_list|(
name|connector
argument_list|,
name|db
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|eld
index|[
literal|5
index|]
operator||=
name|sad_count
operator|<<
literal|4
expr_stmt|;
name|eld
index|[
literal|2
index|]
operator|=
operator|(
literal|20
operator|+
name|mnl
operator|+
name|sad_count
operator|*
literal|3
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"ELD size %d, SAD count %d\n"
argument_list|,
operator|(
name|int
operator|)
name|eld
index|[
literal|2
index|]
argument_list|,
name|sad_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_av_sync_delay - HDMI/DP sink audio-video sync delay in millisecond  * @connector: connector associated with the HDMI/DP sink  * @mode: the display mode  */
end_comment

begin_function
name|int
name|drm_av_sync_delay
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|int
name|i
init|=
operator|!
operator|!
operator|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
operator|)
decl_stmt|;
name|int
name|a
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|connector
operator|->
name|latency_present
index|[
literal|0
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|connector
operator|->
name|latency_present
index|[
literal|1
index|]
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|a
operator|=
name|connector
operator|->
name|audio_latency
index|[
name|i
index|]
expr_stmt|;
name|v
operator|=
name|connector
operator|->
name|video_latency
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * HDMI/DP sink doesn't support audio or video? 	 */
if|if
condition|(
name|a
operator|==
literal|255
operator|||
name|v
operator|==
literal|255
condition|)
return|return
literal|0
return|;
comment|/* 	 * Convert raw EDID values to millisecond. 	 * Treat unknown latency as 0ms. 	 */
if|if
condition|(
name|a
condition|)
name|a
operator|=
name|min
argument_list|(
literal|2
operator|*
operator|(
name|a
operator|-
literal|1
operator|)
argument_list|,
literal|500
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
name|v
operator|=
name|min
argument_list|(
literal|2
operator|*
operator|(
name|v
operator|-
literal|1
operator|)
argument_list|,
literal|500
argument_list|)
expr_stmt|;
return|return
name|max
argument_list|(
name|v
operator|-
name|a
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * drm_select_eld - select one ELD from multiple HDMI/DP sinks  * @encoder: the encoder just changed display mode  * @mode: the adjusted display mode  *  * It's possible for one encoder to be associated with multiple HDMI/DP sinks.  * The policy is now hard coded to simply use the first HDMI/DP sink's ELD.  */
end_comment

begin_function
name|struct
name|drm_connector
modifier|*
name|drm_select_eld
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
if|if
condition|(
name|connector
operator|->
name|encoder
operator|==
name|encoder
operator|&&
name|connector
operator|->
name|eld
index|[
literal|0
index|]
condition|)
return|return
name|connector
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * drm_detect_hdmi_monitor - detect whether monitor is hdmi.  * @edid: monitor EDID information  *  * Parse the CEA extension according to CEA-861-B.  * Return true if HDMI, false if not or unknown.  */
end_comment

begin_function
name|bool
name|drm_detect_hdmi_monitor
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|u8
modifier|*
name|edid_ext
decl_stmt|;
name|int
name|i
decl_stmt|,
name|hdmi_id
decl_stmt|;
name|int
name|start_offset
decl_stmt|,
name|end_offset
decl_stmt|;
name|bool
name|is_hdmi
init|=
name|false
decl_stmt|;
name|edid_ext
operator|=
name|drm_find_cea_extension
argument_list|(
name|edid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edid_ext
condition|)
goto|goto
name|end
goto|;
comment|/* Data block offset in CEA extension block */
name|start_offset
operator|=
literal|4
expr_stmt|;
name|end_offset
operator|=
name|edid_ext
index|[
literal|2
index|]
expr_stmt|;
comment|/* 	 * Because HDMI identifier is in Vendor Specific Block, 	 * search it from all data blocks of CEA extension. 	 */
for|for
control|(
name|i
operator|=
name|start_offset
init|;
name|i
operator|<
name|end_offset
condition|;
comment|/* Increased by data block len */
name|i
operator|+=
operator|(
operator|(
name|edid_ext
index|[
name|i
index|]
operator|&
literal|0x1f
operator|)
operator|+
literal|1
operator|)
control|)
block|{
comment|/* Find vendor specific block */
if|if
condition|(
operator|(
name|edid_ext
index|[
name|i
index|]
operator|>>
literal|5
operator|)
operator|==
name|VENDOR_BLOCK
condition|)
block|{
name|hdmi_id
operator|=
name|edid_ext
index|[
name|i
operator|+
literal|1
index|]
operator||
operator|(
name|edid_ext
index|[
name|i
operator|+
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|edid_ext
index|[
name|i
operator|+
literal|3
index|]
operator|<<
literal|16
expr_stmt|;
comment|/* Find HDMI identifier */
if|if
condition|(
name|hdmi_id
operator|==
name|HDMI_IDENTIFIER
condition|)
name|is_hdmi
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
name|end
label|:
return|return
name|is_hdmi
return|;
block|}
end_function

begin_comment
comment|/**  * drm_detect_monitor_audio - check monitor audio capability  *  * Monitor should have CEA extension block.  * If monitor has 'basic audio', but no CEA audio blocks, it's 'basic  * audio' only. If there is any audio extension block and supported  * audio format, assume at least 'basic audio' support, even if 'basic  * audio' is not defined in EDID.  *  */
end_comment

begin_function
name|bool
name|drm_detect_monitor_audio
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|u8
modifier|*
name|edid_ext
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bool
name|has_audio
init|=
name|false
decl_stmt|;
name|int
name|start_offset
decl_stmt|,
name|end_offset
decl_stmt|;
name|edid_ext
operator|=
name|drm_find_cea_extension
argument_list|(
name|edid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edid_ext
condition|)
goto|goto
name|end
goto|;
name|has_audio
operator|=
operator|(
operator|(
name|edid_ext
index|[
literal|3
index|]
operator|&
name|EDID_BASIC_AUDIO
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|has_audio
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Monitor has basic audio support\n"
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* Data block offset in CEA extension block */
name|start_offset
operator|=
literal|4
expr_stmt|;
name|end_offset
operator|=
name|edid_ext
index|[
literal|2
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start_offset
init|;
name|i
operator|<
name|end_offset
condition|;
name|i
operator|+=
operator|(
operator|(
name|edid_ext
index|[
name|i
index|]
operator|&
literal|0x1f
operator|)
operator|+
literal|1
operator|)
control|)
block|{
if|if
condition|(
operator|(
name|edid_ext
index|[
name|i
index|]
operator|>>
literal|5
operator|)
operator|==
name|AUDIO_BLOCK
condition|)
block|{
name|has_audio
operator|=
name|true
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
operator|(
name|edid_ext
index|[
name|i
index|]
operator|&
literal|0x1f
operator|)
condition|;
name|j
operator|+=
literal|3
control|)
name|DRM_DEBUG_KMS
argument_list|(
literal|"CEA audio format %d\n"
argument_list|,
operator|(
name|edid_ext
index|[
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
name|end
label|:
return|return
name|has_audio
return|;
block|}
end_function

begin_comment
comment|/**  * drm_add_display_info - pull display info out if present  * @edid: EDID data  * @info: display info (attached to connector)  *  * Grab any available display info and stuff it into the drm_display_info  * structure that's part of the connector.  Useful for tracking bpp and  * color spaces.  */
end_comment

begin_function
specifier|static
name|void
name|drm_add_display_info
parameter_list|(
name|struct
name|edid
modifier|*
name|edid
parameter_list|,
name|struct
name|drm_display_info
modifier|*
name|info
parameter_list|)
block|{
name|u8
modifier|*
name|edid_ext
decl_stmt|;
name|info
operator|->
name|width_mm
operator|=
name|edid
operator|->
name|width_cm
operator|*
literal|10
expr_stmt|;
name|info
operator|->
name|height_mm
operator|=
name|edid
operator|->
name|height_cm
operator|*
literal|10
expr_stmt|;
comment|/* driver figures it out in this case */
name|info
operator|->
name|bpc
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|color_formats
operator|=
literal|0
expr_stmt|;
comment|/* Only defined for 1.4 with digital displays */
if|if
condition|(
name|edid
operator|->
name|revision
operator|<
literal|4
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|edid
operator|->
name|input
operator|&
name|DRM_EDID_INPUT_DIGITAL
operator|)
condition|)
return|return;
switch|switch
condition|(
name|edid
operator|->
name|input
operator|&
name|DRM_EDID_DIGITAL_DEPTH_MASK
condition|)
block|{
case|case
name|DRM_EDID_DIGITAL_DEPTH_6
case|:
name|info
operator|->
name|bpc
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|DRM_EDID_DIGITAL_DEPTH_8
case|:
name|info
operator|->
name|bpc
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|DRM_EDID_DIGITAL_DEPTH_10
case|:
name|info
operator|->
name|bpc
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|DRM_EDID_DIGITAL_DEPTH_12
case|:
name|info
operator|->
name|bpc
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|DRM_EDID_DIGITAL_DEPTH_14
case|:
name|info
operator|->
name|bpc
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|DRM_EDID_DIGITAL_DEPTH_16
case|:
name|info
operator|->
name|bpc
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|DRM_EDID_DIGITAL_DEPTH_UNDEF
case|:
default|default:
name|info
operator|->
name|bpc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|info
operator|->
name|color_formats
operator|=
name|DRM_COLOR_FORMAT_RGB444
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|color_formats
operator|&
name|DRM_EDID_FEATURE_RGB_YCRCB444
condition|)
name|info
operator|->
name|color_formats
operator|=
name|DRM_COLOR_FORMAT_YCRCB444
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|color_formats
operator|&
name|DRM_EDID_FEATURE_RGB_YCRCB422
condition|)
name|info
operator|->
name|color_formats
operator|=
name|DRM_COLOR_FORMAT_YCRCB422
expr_stmt|;
comment|/* Get data from CEA blocks if present */
name|edid_ext
operator|=
name|drm_find_cea_extension
argument_list|(
name|edid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edid_ext
condition|)
return|return;
name|info
operator|->
name|cea_rev
operator|=
name|edid_ext
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_add_edid_modes - add modes from EDID data, if available  * @connector: connector we're probing  * @edid: edid data  *  * Add the specified modes to the connector's mode list.  *  * Return number of modes added or 0 if we couldn't find any.  */
end_comment

begin_function
name|int
name|drm_add_edid_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|int
name|num_modes
init|=
literal|0
decl_stmt|;
name|u32
name|quirks
decl_stmt|;
if|if
condition|(
name|edid
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|drm_edid_is_valid
argument_list|(
name|edid
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|connector
operator|->
name|dev
operator|->
name|device
argument_list|,
literal|"%s: EDID invalid.\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|quirks
operator|=
name|edid_get_quirks
argument_list|(
name|edid
argument_list|)
expr_stmt|;
comment|/* 	 * EDID spec says modes should be preferred in this order: 	 * - preferred detailed mode 	 * - other detailed modes from base block 	 * - detailed modes from extension blocks 	 * - CVT 3-byte code modes 	 * - standard timing codes 	 * - established timing codes 	 * - modes inferred from GTF or CVT range information 	 * 	 * We get this pretty much right. 	 * 	 * XXX order for additional mode types in extension blocks? 	 */
name|num_modes
operator|+=
name|add_detailed_modes
argument_list|(
name|connector
argument_list|,
name|edid
argument_list|,
name|quirks
argument_list|)
expr_stmt|;
name|num_modes
operator|+=
name|add_cvt_modes
argument_list|(
name|connector
argument_list|,
name|edid
argument_list|)
expr_stmt|;
name|num_modes
operator|+=
name|add_standard_modes
argument_list|(
name|connector
argument_list|,
name|edid
argument_list|)
expr_stmt|;
name|num_modes
operator|+=
name|add_established_modes
argument_list|(
name|connector
argument_list|,
name|edid
argument_list|)
expr_stmt|;
name|num_modes
operator|+=
name|add_inferred_modes
argument_list|(
name|connector
argument_list|,
name|edid
argument_list|)
expr_stmt|;
if|if
condition|(
name|quirks
operator|&
operator|(
name|EDID_QUIRK_PREFER_LARGE_60
operator||
name|EDID_QUIRK_PREFER_LARGE_75
operator|)
condition|)
name|edid_fixup_preferred
argument_list|(
name|connector
argument_list|,
name|quirks
argument_list|)
expr_stmt|;
name|drm_add_display_info
argument_list|(
name|edid
argument_list|,
operator|&
name|connector
operator|->
name|display_info
argument_list|)
expr_stmt|;
return|return
name|num_modes
return|;
block|}
end_function

begin_comment
comment|/**  * drm_add_modes_noedid - add modes for the connectors without EDID  * @connector: connector we're probing  * @hdisplay: the horizontal display limit  * @vdisplay: the vertical display limit  *  * Add the specified modes to the connector's mode list. Only when the  * hdisplay/vdisplay is not beyond the given limit, it will be added.  *  * Return number of modes added or 0 if we couldn't find any.  */
end_comment

begin_function
name|int
name|drm_add_modes_noedid
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|int
name|hdisplay
parameter_list|,
name|int
name|vdisplay
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|num_modes
init|=
literal|0
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|count
operator|=
sizeof|sizeof
argument_list|(
name|drm_dmt_modes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|drm_display_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdisplay
operator|<
literal|0
condition|)
name|hdisplay
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vdisplay
operator|<
literal|0
condition|)
name|vdisplay
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|ptr
init|=
operator|&
name|drm_dmt_modes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|hdisplay
operator|&&
name|vdisplay
condition|)
block|{
comment|/* 			 * Only when two are valid, they will be used to check 			 * whether the mode should be added to the mode list of 			 * the connector. 			 */
if|if
condition|(
name|ptr
operator|->
name|hdisplay
operator|>
name|hdisplay
operator|||
name|ptr
operator|->
name|vdisplay
operator|>
name|vdisplay
condition|)
continue|continue;
block|}
if|if
condition|(
name|drm_mode_vrefresh
argument_list|(
name|ptr
argument_list|)
operator|>
literal|61
condition|)
continue|continue;
name|mode
operator|=
name|drm_mode_duplicate
argument_list|(
name|dev
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
condition|)
block|{
name|drm_mode_probed_add
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|num_modes
operator|++
expr_stmt|;
block|}
block|}
return|return
name|num_modes
return|;
block|}
end_function

end_unit

