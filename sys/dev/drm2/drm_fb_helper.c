begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006-2009 Red Hat Inc.  * Copyright (c) 2006-2008 Intel Corporation  * Copyright (c) 2007 Dave Airlie<airlied@linux.ie>  *  * DRM framebuffer helper functions  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting documentation, and  * that the name of the copyright holders not be used in advertising or  * publicity pertaining to distribution of the software without specific,  * written prior permission.  The copyright holders make no representations  * about the suitability of this software for any purpose.  It is provided "as  * is" without express or implied warranty.  *  * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO  * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR  * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  * OF THIS SOFTWARE.  *  * Authors:  *      Dave Airlie<airlied@linux.ie>  *      Jesse Barnes<jesse.barnes@intel.com>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_fb_helper.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc_helper.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_struct
struct|struct
name|vt_kms_softc
block|{
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
decl_stmt|;
name|struct
name|task
name|fb_mode_task
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|fb_enter_t
name|vt_kms_postswitch
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|vt_restore_fbdev_mode
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Call restore out of vt(9) locks. */
end_comment

begin_function
specifier|static
name|void
name|vt_restore_fbdev_mode
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
decl_stmt|;
name|struct
name|vt_kms_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|vt_kms_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|fb_helper
operator|=
name|sc
operator|->
name|fb_helper
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|fb_helper
operator|->
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|drm_fb_helper_restore_fbdev_mode
argument_list|(
name|fb_helper
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|fb_helper
operator|->
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vt_kms_postswitch
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vt_kms_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|vt_kms_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|kdb_active
operator|&&
name|panicstr
operator|==
name|NULL
condition|)
name|taskqueue_enqueue_fast
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|sc
operator|->
name|fb_mode_task
argument_list|)
expr_stmt|;
else|else
name|drm_fb_helper_restore_fbdev_mode
argument_list|(
name|sc
operator|->
name|fb_helper
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|DRM_LIST_HEAD
argument_list|(
name|kernel_fb_helper_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* simple single crtc case helper function */
end_comment

begin_function
name|int
name|drm_fb_helper_single_add_all_connectors
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|fb_helper
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_helper_connector
decl_stmt|;
name|fb_helper_connector
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_connector
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|fb_helper_connector
operator|->
name|connector
operator|=
name|connector
expr_stmt|;
name|fb_helper
operator|->
name|connector_info
index|[
name|fb_helper
operator|->
name|connector_count
operator|++
index|]
operator|=
name|fb_helper_connector
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fb_get_options
parameter_list|(
specifier|const
name|char
modifier|*
name|connector_name
parameter_list|,
name|char
modifier|*
modifier|*
name|option
parameter_list|)
block|{
name|char
name|tunable
index|[
literal|64
index|]
decl_stmt|;
comment|/* 	 * A user may use loader tunables to set a specific mode for the 	 * console. Tunables are read in the following order: 	 *     1. kern.vt.fb.modes.$connector_name 	 *     2. kern.vt.fb.default_mode 	 * 	 * Example of a mode specific to the LVDS connector: 	 *     kern.vt.fb.modes.LVDS="1024x768" 	 * 	 * Example of a mode applied to all connectors not having a 	 * connector-specific mode: 	 *     kern.vt.fb.default_mode="640x480" 	 */
name|snprintf
argument_list|(
name|tunable
argument_list|,
sizeof|sizeof
argument_list|(
name|tunable
argument_list|)
argument_list|,
literal|"kern.vt.fb.modes.%s"
argument_list|,
name|connector_name
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"Connector %s: get mode from tunables:\n"
argument_list|,
name|connector_name
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"  - %s\n"
argument_list|,
name|tunable
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"  - kern.vt.fb.default_mode\n"
argument_list|)
expr_stmt|;
operator|*
name|option
operator|=
name|getenv
argument_list|(
name|tunable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|option
operator|==
name|NULL
condition|)
operator|*
name|option
operator|=
name|getenv
argument_list|(
literal|"kern.vt.fb.default_mode"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|option
operator|!=
name|NULL
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_fb_helper_parse_command_line
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|)
block|{
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_helper_conn
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_cmdline_mode
modifier|*
name|mode
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|char
modifier|*
name|option
init|=
name|NULL
decl_stmt|;
name|fb_helper_conn
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
expr_stmt|;
name|connector
operator|=
name|fb_helper_conn
operator|->
name|connector
expr_stmt|;
name|mode
operator|=
operator|&
name|fb_helper_conn
operator|->
name|cmdline_mode
expr_stmt|;
comment|/* do something on return - turn off connector maybe */
if|if
condition|(
name|fb_get_options
argument_list|(
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
operator|&
name|option
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|drm_mode_parse_command_line_for_connector
argument_list|(
name|option
argument_list|,
name|connector
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|->
name|force
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|mode
operator|->
name|force
condition|)
block|{
case|case
name|DRM_FORCE_OFF
case|:
name|s
operator|=
literal|"OFF"
expr_stmt|;
break|break;
case|case
name|DRM_FORCE_ON_DIGITAL
case|:
name|s
operator|=
literal|"ON - dig"
expr_stmt|;
break|break;
default|default:
case|case
name|DRM_FORCE_ON
case|:
name|s
operator|=
literal|"ON"
expr_stmt|;
break|break;
block|}
name|DRM_INFO
argument_list|(
literal|"forcing %s connector %s\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|connector
operator|->
name|force
operator|=
name|mode
operator|->
name|force
expr_stmt|;
block|}
name|DRM_INFO
argument_list|(
literal|"cmdline mode for connector %s %dx%d@%dHz%s%s%s\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|mode
operator|->
name|xres
argument_list|,
name|mode
operator|->
name|yres
argument_list|,
name|mode
operator|->
name|refresh_specified
condition|?
name|mode
operator|->
name|refresh
else|:
literal|60
argument_list|,
name|mode
operator|->
name|rb
condition|?
literal|" reduced blanking"
else|:
literal|""
argument_list|,
name|mode
operator|->
name|margins
condition|?
literal|" with margins"
else|:
literal|""
argument_list|,
name|mode
operator|->
name|interlace
condition|?
literal|" interlaced"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|freeenv
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void drm_fb_helper_save_lut_atomic(struct drm_crtc *crtc, struct drm_fb_helper *helper) { 	uint16_t *r_base, *g_base, *b_base; 	int i;  	r_base = crtc->gamma_store; 	g_base = r_base + crtc->gamma_size; 	b_base = g_base + crtc->gamma_size;  	for (i = 0; i< crtc->gamma_size; i++) 		helper->funcs->gamma_get(crtc,&r_base[i],&g_base[i],&b_base[i], i); }  static void drm_fb_helper_restore_lut_atomic(struct drm_crtc *crtc) { 	uint16_t *r_base, *g_base, *b_base;  	if (crtc->funcs->gamma_set == NULL) 		return;  	r_base = crtc->gamma_store; 	g_base = r_base + crtc->gamma_size; 	b_base = g_base + crtc->gamma_size;  	crtc->funcs->gamma_set(crtc, r_base, g_base, b_base, 0, crtc->gamma_size); }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|int drm_fb_helper_debug_enter(struct fb_info *info) { 	struct drm_fb_helper *helper = info->par; 	struct drm_crtc_helper_funcs *funcs; 	int i;  	if (list_empty(&kernel_fb_helper_list)) 		return false;  	list_for_each_entry(helper,&kernel_fb_helper_list, kernel_fb_list) { 		for (i = 0; i< helper->crtc_count; i++) { 			struct drm_mode_set *mode_set =&helper->crtc_info[i].mode_set;  			if (!mode_set->crtc->enabled) 				continue;  			funcs =	mode_set->crtc->helper_private; 			drm_fb_helper_save_lut_atomic(mode_set->crtc, helper); 			funcs->mode_set_base_atomic(mode_set->crtc, 						    mode_set->fb, 						    mode_set->x, 						    mode_set->y, 						    ENTER_ATOMIC_MODE_SET); 		} 	}  	return 0; }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Find the real fb for a given fb helper CRTC */
end_comment

begin_endif
unit|static struct drm_framebuffer *drm_mode_config_fb(struct drm_crtc *crtc) { 	struct drm_device *dev = crtc->dev; 	struct drm_crtc *c;  	list_for_each_entry(c,&dev->mode_config.crtc_list, head) { 		if (crtc->base.id == c->base.id) 			return c->fb; 	}  	return NULL; }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|int drm_fb_helper_debug_leave(struct fb_info *info) { 	struct drm_fb_helper *helper = info->par; 	struct drm_crtc *crtc; 	struct drm_crtc_helper_funcs *funcs; 	struct drm_framebuffer *fb; 	int i;  	for (i = 0; i< helper->crtc_count; i++) { 		struct drm_mode_set *mode_set =&helper->crtc_info[i].mode_set; 		crtc = mode_set->crtc; 		funcs = crtc->helper_private; 		fb = drm_mode_config_fb(crtc);  		if (!crtc->enabled) 			continue;  		if (!fb) { 			DRM_ERROR("no fb to restore??\n"); 			continue; 		}  		drm_fb_helper_restore_lut_atomic(mode_set->crtc); 		funcs->mode_set_base_atomic(mode_set->crtc, fb, crtc->x, 					    crtc->y, LEAVE_ATOMIC_MODE_SET); 	}  	return 0; }
endif|#
directive|endif
end_endif

begin_function
name|bool
name|drm_fb_helper_restore_fbdev_mode
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|)
block|{
name|bool
name|error
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|crtc_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_mode_set
modifier|*
name|mode_set
init|=
operator|&
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
decl_stmt|;
name|ret
operator|=
name|drm_crtc_helper_set_config
argument_list|(
name|mode_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|error
operator|=
name|true
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|bool drm_fb_helper_force_kernel_mode(void) { 	bool ret, error = false; 	struct drm_fb_helper *helper;  	if (list_empty(&kernel_fb_helper_list)) 		return false;  	list_for_each_entry(helper,&kernel_fb_helper_list, kernel_fb_list) { 		if (helper->dev->switch_power_state == DRM_SWITCH_POWER_OFF) 			continue;  		ret = drm_fb_helper_restore_fbdev_mode(helper); 		if (ret) 			error = true; 	} 	return error; }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|int drm_fb_helper_panic(struct notifier_block *n, unsigned long ununsed, 			void *panic_str) { 	printf("panic occurred, switching back to text console\n"); 	return drm_fb_helper_force_kernel_mode(); 	return 0; }  static struct notifier_block paniced = { 	.notifier_call = drm_fb_helper_panic, };
comment|/**  * drm_fb_helper_restore - restore the framebuffer console (kernel) config  *  * Restore's the kernel's fbcon mode, used for lastclose& panic paths.  */
end_comment

begin_ifdef
unit|void drm_fb_helper_restore(void) { 	bool ret; 	ret = drm_fb_helper_force_kernel_mode(); 	if (ret == true) 		DRM_ERROR("Failed to restore crtc configuration\n"); }
ifdef|#
directive|ifdef
name|CONFIG_MAGIC_SYSRQ
end_ifdef

begin_else
unit|static void drm_fb_helper_restore_work_fn(struct work_struct *ignored) { 	drm_fb_helper_restore(); } static DECLARE_WORK(drm_fb_helper_restore_work, drm_fb_helper_restore_work_fn);  static void drm_fb_helper_sysrq(int dummy1) { 	schedule_work(&drm_fb_helper_restore_work); }  static struct sysrq_key_op sysrq_drm_fb_helper_restore_op = { 	.handler = drm_fb_helper_sysrq, 	.help_msg = "force-fb(V)", 	.action_msg = "Restore framebuffer console", };
else|#
directive|else
end_else

begin_endif
unit|static struct sysrq_key_op sysrq_drm_fb_helper_restore_op = { };
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void drm_fb_helper_on(struct fb_info *info) { 	struct drm_fb_helper *fb_helper = info->par; 	struct drm_device *dev = fb_helper->dev; 	struct drm_crtc *crtc; 	struct drm_crtc_helper_funcs *crtc_funcs; 	struct drm_connector *connector; 	struct drm_encoder *encoder; 	int i, j;
comment|/* 	 * For each CRTC in this fb, turn the crtc on then, 	 * find all associated encoders and turn them on. 	 */
end_comment

begin_comment
unit|sx_xlock(&dev->mode_config.mutex); 	for (i = 0; i< fb_helper->crtc_count; i++) { 		crtc = fb_helper->crtc_info[i].mode_set.crtc; 		crtc_funcs = crtc->helper_private;  		if (!crtc->enabled) 			continue;  		crtc_funcs->dpms(crtc, DRM_MODE_DPMS_ON);
comment|/* Walk the connectors& encoders on this fb turning them on */
end_comment

begin_comment
unit|for (j = 0; j< fb_helper->connector_count; j++) { 			connector = fb_helper->connector_info[j]->connector; 			connector->dpms = DRM_MODE_DPMS_ON; 			drm_connector_property_set_value(connector, 							 dev->mode_config.dpms_property, 							 DRM_MODE_DPMS_ON); 		}
comment|/* Found a CRTC on this fb, now find encoders */
end_comment

begin_endif
unit|list_for_each_entry(encoder,&dev->mode_config.encoder_list, head) { 			if (encoder->crtc == crtc) { 				struct drm_encoder_helper_funcs *encoder_funcs;  				encoder_funcs = encoder->helper_private; 				encoder_funcs->dpms(encoder, DRM_MODE_DPMS_ON); 			} 		} 	} 	sx_xunlock(&dev->mode_config.mutex); }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void drm_fb_helper_off(struct fb_info *info, int dpms_mode) { 	struct drm_fb_helper *fb_helper = info->par; 	struct drm_device *dev = fb_helper->dev; 	struct drm_crtc *crtc; 	struct drm_crtc_helper_funcs *crtc_funcs; 	struct drm_connector *connector; 	struct drm_encoder *encoder; 	int i, j;
comment|/* 	 * For each CRTC in this fb, find all associated encoders 	 * and turn them off, then turn off the CRTC. 	 */
end_comment

begin_comment
unit|sx_xlock(&dev->mode_config.mutex); 	for (i = 0; i< fb_helper->crtc_count; i++) { 		crtc = fb_helper->crtc_info[i].mode_set.crtc; 		crtc_funcs = crtc->helper_private;  		if (!crtc->enabled) 			continue;
comment|/* Walk the connectors on this fb and mark them off */
end_comment

begin_comment
unit|for (j = 0; j< fb_helper->connector_count; j++) { 			connector = fb_helper->connector_info[j]->connector; 			connector->dpms = dpms_mode; 			drm_connector_property_set_value(connector, 							 dev->mode_config.dpms_property, 							 dpms_mode); 		}
comment|/* Found a CRTC on this fb, now find encoders */
end_comment

begin_endif
unit|list_for_each_entry(encoder,&dev->mode_config.encoder_list, head) { 			if (encoder->crtc == crtc) { 				struct drm_encoder_helper_funcs *encoder_funcs;  				encoder_funcs = encoder->helper_private; 				encoder_funcs->dpms(encoder, dpms_mode); 			} 		} 		crtc_funcs->dpms(crtc, DRM_MODE_DPMS_OFF); 	} 	sx_xunlock(&dev->mode_config.mutex); }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|int drm_fb_helper_blank(int blank, struct fb_info *info) { 	switch (blank) {
comment|/* Display: On; HSync: On, VSync: On */
end_comment

begin_comment
unit|case FB_BLANK_UNBLANK: 		drm_fb_helper_on(info); 		break;
comment|/* Display: Off; HSync: On, VSync: On */
end_comment

begin_comment
unit|case FB_BLANK_NORMAL: 		drm_fb_helper_off(info, DRM_MODE_DPMS_STANDBY); 		break;
comment|/* Display: Off; HSync: Off, VSync: On */
end_comment

begin_comment
unit|case FB_BLANK_HSYNC_SUSPEND: 		drm_fb_helper_off(info, DRM_MODE_DPMS_STANDBY); 		break;
comment|/* Display: Off; HSync: On, VSync: Off */
end_comment

begin_comment
unit|case FB_BLANK_VSYNC_SUSPEND: 		drm_fb_helper_off(info, DRM_MODE_DPMS_SUSPEND); 		break;
comment|/* Display: Off; HSync: Off, VSync: Off */
end_comment

begin_endif
unit|case FB_BLANK_POWERDOWN: 		drm_fb_helper_off(info, DRM_MODE_DPMS_OFF); 		break; 	} 	return 0; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|drm_fb_helper_crtc_free
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|helper
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|helper
operator|->
name|connector_info
index|[
name|i
index|]
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|helper
operator|->
name|connector_info
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|helper
operator|->
name|crtc_count
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|connectors
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|mode
condition|)
name|drm_mode_destroy
argument_list|(
name|helper
operator|->
name|dev
argument_list|,
name|helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|helper
operator|->
name|crtc_info
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|drm_fb_helper_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|int
name|crtc_count
parameter_list|,
name|int
name|max_conn_count
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fb_helper
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|fb_helper
operator|->
name|kernel_fb_list
argument_list|)
expr_stmt|;
name|fb_helper
operator|->
name|crtc_info
operator|=
name|malloc
argument_list|(
name|crtc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_crtc
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|fb_helper
operator|->
name|crtc_count
operator|=
name|crtc_count
expr_stmt|;
name|fb_helper
operator|->
name|connector_info
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_connector
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|fb_helper
operator|->
name|connector_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|crtc_count
condition|;
name|i
operator|++
control|)
block|{
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|connectors
operator|=
name|malloc
argument_list|(
name|max_conn_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_connector
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|num_connectors
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|crtc_id
operator|=
name|crtc
operator|->
name|base
operator|.
name|id
expr_stmt|;
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|crtc
operator|=
name|crtc
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|fb_helper
operator|->
name|conn_limit
operator|=
name|max_conn_count
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|drm_fb_helper_fini
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|)
block|{
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|fb_helper
operator|->
name|kernel_fb_list
argument_list|)
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|fb_helper
operator|->
name|kernel_fb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|kernel_fb_helper_list
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|printk(KERN_INFO "drm: unregistered panic notifier\n"); 			atomic_notifier_chain_unregister(&panic_notifier_list,&paniced); 			unregister_sysrq_key('v',&sysrq_drm_fb_helper_restore_op);
endif|#
directive|endif
block|}
block|}
name|drm_fb_helper_crtc_free
argument_list|(
name|fb_helper
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int setcolreg(struct drm_crtc *crtc, u16 red, u16 green, 		     u16 blue, u16 regno, struct fb_info *info) { 	struct drm_fb_helper *fb_helper = info->par; 	struct drm_framebuffer *fb = fb_helper->fb; 	int pindex;  	if (info->fix.visual == FB_VISUAL_trueCOLOR) { 		u32 *palette; 		u32 value;
comment|/* place color in psuedopalette */
end_comment

begin_endif
unit|if (regno> 16) 			return -EINVAL; 		palette = (u32 *)info->pseudo_palette; 		red>>= (16 - info->var.red.length); 		green>>= (16 - info->var.green.length); 		blue>>= (16 - info->var.blue.length); 		value = (red<< info->var.red.offset) | 			(green<< info->var.green.offset) | 			(blue<< info->var.blue.offset); 		if (info->var.transp.length> 0) { 			u32 mask = (1<< info->var.transp.length) - 1; 			mask<<= info->var.transp.offset; 			value |= mask; 		} 		palette[regno] = value; 		return 0; 	}  	pindex = regno;  	if (fb->bits_per_pixel == 16) { 		pindex = regno<< 3;  		if (fb->depth == 16&& regno> 63) 			return -EINVAL; 		if (fb->depth == 15&& regno> 31) 			return -EINVAL;  		if (fb->depth == 16) { 			u16 r, g, b; 			int i; 			if (regno< 32) { 				for (i = 0; i< 8; i++) 					fb_helper->funcs->gamma_set(crtc, red, 						green, blue, pindex + i); 			}  			fb_helper->funcs->gamma_get(crtc,&r,&g,&b, 						    pindex>> 1);  			for (i = 0; i< 4; i++) 				fb_helper->funcs->gamma_set(crtc, r, 							    green, b, 							    (pindex>> 1) + i); 		} 	}  	if (fb->depth != 16) 		fb_helper->funcs->gamma_set(crtc, red, green, blue, pindex); 	return 0; }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|int drm_fb_helper_setcmap(struct fb_cmap *cmap, struct fb_info *info) { 	struct drm_fb_helper *fb_helper = info->par; 	struct drm_crtc_helper_funcs *crtc_funcs; 	u16 *red, *green, *blue, *transp; 	struct drm_crtc *crtc; 	int i, j, rc = 0; 	int start;  	for (i = 0; i< fb_helper->crtc_count; i++) { 		crtc = fb_helper->crtc_info[i].mode_set.crtc; 		crtc_funcs = crtc->helper_private;  		red = cmap->red; 		green = cmap->green; 		blue = cmap->blue; 		transp = cmap->transp; 		start = cmap->start;  		for (j = 0; j< cmap->len; j++) { 			u16 hred, hgreen, hblue, htransp = 0xffff;  			hred = *red++; 			hgreen = *green++; 			hblue = *blue++;  			if (transp) 				htransp = *transp++;  			rc = setcolreg(crtc, hred, hgreen, hblue, start++, info); 			if (rc) 				return rc; 		} 		crtc_funcs->load_lut(crtc); 	} 	return rc; }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|int drm_fb_helper_check_var(struct fb_var_screeninfo *var, 			    struct fb_info *info) { 	struct drm_fb_helper *fb_helper = info->par; 	struct drm_framebuffer *fb = fb_helper->fb; 	int depth;  	if (var->pixclock != 0 || in_dbg_master()) 		return -EINVAL;
comment|/* Need to resize the fb object !!! */
end_comment

begin_endif
unit|if (var->bits_per_pixel> fb->bits_per_pixel || 	    var->xres> fb->width || var->yres> fb->height || 	    var->xres_virtual> fb->width || var->yres_virtual> fb->height) { 		DRM_DEBUG("fb userspace requested width/height/bpp is greater than current fb " 			  "request %dx%d-%d (virtual %dx%d)> %dx%d-%d\n", 			  var->xres, var->yres, var->bits_per_pixel, 			  var->xres_virtual, var->yres_virtual, 			  fb->width, fb->height, fb->bits_per_pixel); 		return -EINVAL; 	}  	switch (var->bits_per_pixel) { 	case 16: 		depth = (var->green.length == 6) ? 16 : 15; 		break; 	case 32: 		depth = (var->transp.length> 0) ? 32 : 24; 		break; 	default: 		depth = var->bits_per_pixel; 		break; 	}  	switch (depth) { 	case 8: 		var->red.offset = 0; 		var->green.offset = 0; 		var->blue.offset = 0; 		var->red.length = 8; 		var->green.length = 8; 		var->blue.length = 8; 		var->transp.length = 0; 		var->transp.offset = 0; 		break; 	case 15: 		var->red.offset = 10; 		var->green.offset = 5; 		var->blue.offset = 0; 		var->red.length = 5; 		var->green.length = 5; 		var->blue.length = 5; 		var->transp.length = 1; 		var->transp.offset = 15; 		break; 	case 16: 		var->red.offset = 11; 		var->green.offset = 5; 		var->blue.offset = 0; 		var->red.length = 5; 		var->green.length = 6; 		var->blue.length = 5; 		var->transp.length = 0; 		var->transp.offset = 0; 		break; 	case 24: 		var->red.offset = 16; 		var->green.offset = 8; 		var->blue.offset = 0; 		var->red.length = 8; 		var->green.length = 8; 		var->blue.length = 8; 		var->transp.length = 0; 		var->transp.offset = 0; 		break; 	case 32: 		var->red.offset = 16; 		var->green.offset = 8; 		var->blue.offset = 0; 		var->red.length = 8; 		var->green.length = 8; 		var->blue.length = 8; 		var->transp.length = 8; 		var->transp.offset = 24; 		break; 	default: 		return -EINVAL; 	} 	return 0; }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* this will let fbcon do the mode init */
end_comment

begin_endif
unit|int drm_fb_helper_set_par(struct fb_info *info) { 	struct drm_fb_helper *fb_helper = info->par; 	struct drm_device *dev = fb_helper->dev; 	struct fb_var_screeninfo *var =&info->var; 	struct drm_crtc *crtc; 	int ret; 	int i;  	if (var->pixclock != 0) { 		DRM_ERROR("PIXEL CLOCK SET\n"); 		return -EINVAL; 	}  	mutex_lock(&dev->mode_config.mutex); 	for (i = 0; i< fb_helper->crtc_count; i++) { 		crtc = fb_helper->crtc_info[i].mode_set.crtc; 		ret = crtc->funcs->set_config(&fb_helper->crtc_info[i].mode_set); 		if (ret) { 			mutex_unlock(&dev->mode_config.mutex); 			return ret; 		} 	} 	mutex_unlock(&dev->mode_config.mutex);  	if (fb_helper->delayed_hotplug) { 		fb_helper->delayed_hotplug = false; 		drm_fb_helper_hotplug_event(fb_helper); 	} 	return 0; }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|int drm_fb_helper_pan_display(struct fb_var_screeninfo *var, 			      struct fb_info *info) { 	struct drm_fb_helper *fb_helper = info->par; 	struct drm_device *dev = fb_helper->dev; 	struct drm_mode_set *modeset; 	struct drm_crtc *crtc; 	int ret = 0; 	int i;  	mutex_lock(&dev->mode_config.mutex); 	for (i = 0; i< fb_helper->crtc_count; i++) { 		crtc = fb_helper->crtc_info[i].mode_set.crtc;  		modeset =&fb_helper->crtc_info[i].mode_set;  		modeset->x = var->xoffset; 		modeset->y = var->yoffset;  		if (modeset->num_connectors) { 			ret = crtc->funcs->set_config(modeset); 			if (!ret) { 				info->var.xoffset = var->xoffset; 				info->var.yoffset = var->yoffset; 			} 		} 	} 	mutex_unlock(&dev->mode_config.mutex); 	return ret; }
endif|#
directive|endif
end_endif

begin_function
name|int
name|drm_fb_helper_single_fb_probe
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|int
name|preferred_bpp
parameter_list|)
block|{
name|int
name|new_fb
init|=
literal|0
decl_stmt|;
name|int
name|crtc_count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|fb_info
modifier|*
name|info
decl_stmt|;
name|struct
name|drm_fb_helper_surface_size
name|sizes
decl_stmt|;
name|int
name|gamma_size
init|=
literal|0
decl_stmt|;
name|struct
name|vt_kms_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|kdev
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sizes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_surface_size
argument_list|)
argument_list|)
expr_stmt|;
name|sizes
operator|.
name|surface_depth
operator|=
literal|24
expr_stmt|;
name|sizes
operator|.
name|surface_bpp
operator|=
literal|32
expr_stmt|;
name|sizes
operator|.
name|fb_width
operator|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
name|sizes
operator|.
name|fb_height
operator|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* if driver picks 8 or 16 by default use that 	   for both depth/bpp */
if|if
condition|(
name|preferred_bpp
operator|!=
name|sizes
operator|.
name|surface_bpp
condition|)
block|{
name|sizes
operator|.
name|surface_depth
operator|=
name|sizes
operator|.
name|surface_bpp
operator|=
name|preferred_bpp
expr_stmt|;
block|}
comment|/* first up get a count of crtcs now in use and new min/maxes width/heights */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_helper_conn
init|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
decl_stmt|;
name|struct
name|drm_cmdline_mode
modifier|*
name|cmdline_mode
decl_stmt|;
name|cmdline_mode
operator|=
operator|&
name|fb_helper_conn
operator|->
name|cmdline_mode
expr_stmt|;
if|if
condition|(
name|cmdline_mode
operator|->
name|bpp_specified
condition|)
block|{
switch|switch
condition|(
name|cmdline_mode
operator|->
name|bpp
condition|)
block|{
case|case
literal|8
case|:
name|sizes
operator|.
name|surface_depth
operator|=
name|sizes
operator|.
name|surface_bpp
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|sizes
operator|.
name|surface_depth
operator|=
literal|15
expr_stmt|;
name|sizes
operator|.
name|surface_bpp
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|sizes
operator|.
name|surface_depth
operator|=
name|sizes
operator|.
name|surface_bpp
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|sizes
operator|.
name|surface_depth
operator|=
name|sizes
operator|.
name|surface_bpp
operator|=
literal|24
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|sizes
operator|.
name|surface_depth
operator|=
literal|24
expr_stmt|;
name|sizes
operator|.
name|surface_bpp
operator|=
literal|32
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
name|crtc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|crtc_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|desired_mode
decl_stmt|;
name|desired_mode
operator|=
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|desired_mode
expr_stmt|;
if|if
condition|(
name|desired_mode
condition|)
block|{
if|if
condition|(
name|gamma_size
operator|==
literal|0
condition|)
name|gamma_size
operator|=
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|crtc
operator|->
name|gamma_size
expr_stmt|;
if|if
condition|(
name|desired_mode
operator|->
name|hdisplay
operator|<
name|sizes
operator|.
name|fb_width
condition|)
name|sizes
operator|.
name|fb_width
operator|=
name|desired_mode
operator|->
name|hdisplay
expr_stmt|;
if|if
condition|(
name|desired_mode
operator|->
name|vdisplay
operator|<
name|sizes
operator|.
name|fb_height
condition|)
name|sizes
operator|.
name|fb_height
operator|=
name|desired_mode
operator|->
name|vdisplay
expr_stmt|;
if|if
condition|(
name|desired_mode
operator|->
name|hdisplay
operator|>
name|sizes
operator|.
name|surface_width
condition|)
name|sizes
operator|.
name|surface_width
operator|=
name|desired_mode
operator|->
name|hdisplay
expr_stmt|;
if|if
condition|(
name|desired_mode
operator|->
name|vdisplay
operator|>
name|sizes
operator|.
name|surface_height
condition|)
name|sizes
operator|.
name|surface_height
operator|=
name|desired_mode
operator|->
name|vdisplay
expr_stmt|;
name|crtc_count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|crtc_count
operator|==
literal|0
operator|||
name|sizes
operator|.
name|fb_width
operator|==
operator|-
literal|1
operator|||
name|sizes
operator|.
name|fb_height
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* hmm everyone went away - assume VGA cable just fell out 		   and will come back later. */
name|DRM_INFO
argument_list|(
literal|"Cannot find any crtc or sizes - going 1024x768\n"
argument_list|)
expr_stmt|;
name|sizes
operator|.
name|fb_width
operator|=
name|sizes
operator|.
name|surface_width
operator|=
literal|1024
expr_stmt|;
name|sizes
operator|.
name|fb_height
operator|=
name|sizes
operator|.
name|surface_height
operator|=
literal|768
expr_stmt|;
block|}
comment|/* push down into drivers */
name|new_fb
operator|=
call|(
modifier|*
name|fb_helper
operator|->
name|funcs
operator|->
name|fb_probe
call|)
argument_list|(
name|fb_helper
argument_list|,
operator|&
name|sizes
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_fb
operator|<
literal|0
condition|)
return|return
name|new_fb
return|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vt_kms_softc
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fb_helper
operator|=
name|fb_helper
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|fb_mode_task
argument_list|,
literal|0
argument_list|,
name|vt_restore_fbdev_mode
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|info
operator|=
name|fb_helper
operator|->
name|fbdev
expr_stmt|;
name|info
operator|->
name|fb_name
operator|=
name|device_get_nameunit
argument_list|(
name|fb_helper
operator|->
name|dev
operator|->
name|device
argument_list|)
expr_stmt|;
name|info
operator|->
name|fb_depth
operator|=
name|fb_helper
operator|->
name|fb
operator|->
name|bits_per_pixel
expr_stmt|;
name|info
operator|->
name|fb_height
operator|=
name|fb_helper
operator|->
name|fb
operator|->
name|height
expr_stmt|;
name|info
operator|->
name|fb_width
operator|=
name|fb_helper
operator|->
name|fb
operator|->
name|width
expr_stmt|;
name|info
operator|->
name|fb_stride
operator|=
name|fb_helper
operator|->
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
expr_stmt|;
name|info
operator|->
name|fb_priv
operator|=
name|sc
expr_stmt|;
name|info
operator|->
name|enter
operator|=
operator|&
name|vt_kms_postswitch
expr_stmt|;
comment|/* set the fb pointer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|crtc_count
condition|;
name|i
operator|++
control|)
block|{
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|fb
operator|=
name|fb_helper
operator|->
name|fb
expr_stmt|;
block|}
if|if
condition|(
name|new_fb
condition|)
block|{
name|device_t
name|fbd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|kdev
operator|=
name|fb_helper
operator|->
name|dev
operator|->
name|device
expr_stmt|;
name|fbd
operator|=
name|device_add_child
argument_list|(
name|kdev
argument_list|,
literal|"fbd"
argument_list|,
name|device_get_unit
argument_list|(
name|kdev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fbd
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|device_probe_and_attach
argument_list|(
name|fbd
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|ENODEV
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_VT
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|DRM_ERROR
argument_list|(
literal|"Failed to attach fbd device: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|void drm_fb_helper_fill_fix(struct fb_info *info, uint32_t pitch, 			    uint32_t depth) { 	info->fix.type = FB_TYPE_PACKED_PIXELS; 	info->fix.visual = depth == 8 ? FB_VISUAL_PSEUDOCOLOR : 		FB_VISUAL_trueCOLOR; 	info->fix.mmio_start = 0; 	info->fix.mmio_len = 0; 	info->fix.type_aux = 0; 	info->fix.xpanstep = 1;
comment|/* doing it in hw */
end_comment

begin_comment
unit|info->fix.ypanstep = 1;
comment|/* doing it in hw */
end_comment

begin_comment
unit|info->fix.ywrapstep = 0; 	info->fix.accel = FB_ACCEL_NONE; 	info->fix.type_aux = 0;  	info->fix.line_length = pitch; 	return; }  void drm_fb_helper_fill_var(struct fb_info *info, struct drm_fb_helper *fb_helper, 			    uint32_t fb_width, uint32_t fb_height) { 	struct drm_framebuffer *fb = fb_helper->fb; 	info->pseudo_palette = fb_helper->pseudo_palette; 	info->var.xres_virtual = fb->width; 	info->var.yres_virtual = fb->height; 	info->var.bits_per_pixel = fb->bits_per_pixel; 	info->var.accel_flags = FB_ACCELF_TEXT; 	info->var.xoffset = 0; 	info->var.yoffset = 0; 	info->var.activate = FB_ACTIVATE_NOW; 	info->var.height = -1; 	info->var.width = -1;  	switch (fb->depth) { 	case 8: 		info->var.red.offset = 0; 		info->var.green.offset = 0; 		info->var.blue.offset = 0; 		info->var.red.length = 8;
comment|/* 8bit DAC */
end_comment

begin_endif
unit|info->var.green.length = 8; 		info->var.blue.length = 8; 		info->var.transp.offset = 0; 		info->var.transp.length = 0; 		break; 	case 15: 		info->var.red.offset = 10; 		info->var.green.offset = 5; 		info->var.blue.offset = 0; 		info->var.red.length = 5; 		info->var.green.length = 5; 		info->var.blue.length = 5; 		info->var.transp.offset = 15; 		info->var.transp.length = 1; 		break; 	case 16: 		info->var.red.offset = 11; 		info->var.green.offset = 5; 		info->var.blue.offset = 0; 		info->var.red.length = 5; 		info->var.green.length = 6; 		info->var.blue.length = 5; 		info->var.transp.offset = 0; 		break; 	case 24: 		info->var.red.offset = 16; 		info->var.green.offset = 8; 		info->var.blue.offset = 0; 		info->var.red.length = 8; 		info->var.green.length = 8; 		info->var.blue.length = 8; 		info->var.transp.offset = 0; 		info->var.transp.length = 0; 		break; 	case 32: 		info->var.red.offset = 16; 		info->var.green.offset = 8; 		info->var.blue.offset = 0; 		info->var.red.length = 8; 		info->var.green.length = 8; 		info->var.blue.length = 8; 		info->var.transp.offset = 24; 		info->var.transp.length = 8; 		break; 	default: 		break; 	}  	info->var.xres = fb_width; 	info->var.yres = fb_height; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|drm_fb_helper_probe_connector_modes
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|uint32_t
name|maxX
parameter_list|,
name|uint32_t
name|maxY
parameter_list|)
block|{
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|connector
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
operator|->
name|connector
expr_stmt|;
name|count
operator|+=
name|connector
operator|->
name|funcs
operator|->
name|fill_modes
argument_list|(
name|connector
argument_list|,
name|maxX
argument_list|,
name|maxY
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_display_mode
modifier|*
name|drm_has_preferred_mode
parameter_list|(
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_connector
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|mode
argument_list|,
argument|&fb_connector->connector->modes
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|drm_mode_width
argument_list|(
name|mode
argument_list|)
operator|>
name|width
operator|||
name|drm_mode_height
argument_list|(
name|mode
argument_list|)
operator|>
name|height
condition|)
continue|continue;
if|if
condition|(
name|mode
operator|->
name|type
operator|&
name|DRM_MODE_TYPE_PREFERRED
condition|)
return|return
name|mode
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|drm_has_cmdline_mode
parameter_list|(
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_connector
parameter_list|)
block|{
name|struct
name|drm_cmdline_mode
modifier|*
name|cmdline_mode
decl_stmt|;
name|cmdline_mode
operator|=
operator|&
name|fb_connector
operator|->
name|cmdline_mode
expr_stmt|;
return|return
name|cmdline_mode
operator|->
name|specified
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_display_mode
modifier|*
name|drm_pick_cmdline_mode
parameter_list|(
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_helper_conn
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|struct
name|drm_cmdline_mode
modifier|*
name|cmdline_mode
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
init|=
name|NULL
decl_stmt|;
name|cmdline_mode
operator|=
operator|&
name|fb_helper_conn
operator|->
name|cmdline_mode
expr_stmt|;
if|if
condition|(
name|cmdline_mode
operator|->
name|specified
operator|==
name|false
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* attempt to find a matching mode in the list of modes 	 *  we have gotten so far, if not add a CVT mode that conforms 	 */
if|if
condition|(
name|cmdline_mode
operator|->
name|rb
operator|||
name|cmdline_mode
operator|->
name|margins
condition|)
goto|goto
name|create_mode
goto|;
name|list_for_each_entry
argument_list|(
argument|mode
argument_list|,
argument|&fb_helper_conn->connector->modes
argument_list|,
argument|head
argument_list|)
block|{
comment|/* check width/height */
if|if
condition|(
name|mode
operator|->
name|hdisplay
operator|!=
name|cmdline_mode
operator|->
name|xres
operator|||
name|mode
operator|->
name|vdisplay
operator|!=
name|cmdline_mode
operator|->
name|yres
condition|)
continue|continue;
if|if
condition|(
name|cmdline_mode
operator|->
name|refresh_specified
condition|)
block|{
if|if
condition|(
name|mode
operator|->
name|vrefresh
operator|!=
name|cmdline_mode
operator|->
name|refresh
condition|)
continue|continue;
block|}
if|if
condition|(
name|cmdline_mode
operator|->
name|interlace
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
operator|)
condition|)
continue|continue;
block|}
return|return
name|mode
return|;
block|}
name|create_mode
label|:
if|if
condition|(
name|cmdline_mode
operator|->
name|cvt
condition|)
name|mode
operator|=
name|drm_cvt_mode
argument_list|(
name|fb_helper_conn
operator|->
name|connector
operator|->
name|dev
argument_list|,
name|cmdline_mode
operator|->
name|xres
argument_list|,
name|cmdline_mode
operator|->
name|yres
argument_list|,
name|cmdline_mode
operator|->
name|refresh_specified
condition|?
name|cmdline_mode
operator|->
name|refresh
else|:
literal|60
argument_list|,
name|cmdline_mode
operator|->
name|rb
argument_list|,
name|cmdline_mode
operator|->
name|interlace
argument_list|,
name|cmdline_mode
operator|->
name|margins
argument_list|)
expr_stmt|;
else|else
name|mode
operator|=
name|drm_gtf_mode
argument_list|(
name|fb_helper_conn
operator|->
name|connector
operator|->
name|dev
argument_list|,
name|cmdline_mode
operator|->
name|xres
argument_list|,
name|cmdline_mode
operator|->
name|yres
argument_list|,
name|cmdline_mode
operator|->
name|refresh_specified
condition|?
name|cmdline_mode
operator|->
name|refresh
else|:
literal|60
argument_list|,
name|cmdline_mode
operator|->
name|interlace
argument_list|,
name|cmdline_mode
operator|->
name|margins
argument_list|)
expr_stmt|;
name|drm_mode_set_crtcinfo
argument_list|(
name|mode
argument_list|,
name|CRTC_INTERLACE_HALVE_V
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|mode
operator|->
name|head
argument_list|,
operator|&
name|fb_helper_conn
operator|->
name|connector
operator|->
name|modes
argument_list|)
expr_stmt|;
return|return
name|mode
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|drm_connector_enabled
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|bool
name|strict
parameter_list|)
block|{
name|bool
name|enable
decl_stmt|;
if|if
condition|(
name|strict
condition|)
block|{
name|enable
operator|=
name|connector
operator|->
name|status
operator|==
name|connector_status_connected
expr_stmt|;
block|}
else|else
block|{
name|enable
operator|=
name|connector
operator|->
name|status
operator|!=
name|connector_status_disconnected
expr_stmt|;
block|}
return|return
name|enable
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drm_enable_connectors
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|bool
modifier|*
name|enabled
parameter_list|)
block|{
name|bool
name|any_enabled
init|=
name|false
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|connector
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
operator|->
name|connector
expr_stmt|;
name|enabled
index|[
name|i
index|]
operator|=
name|drm_connector_enabled
argument_list|(
name|connector
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"connector %d enabled? %s\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|enabled
index|[
name|i
index|]
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|any_enabled
operator||=
name|enabled
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|any_enabled
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|connector
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
operator|->
name|connector
expr_stmt|;
name|enabled
index|[
name|i
index|]
operator|=
name|drm_connector_enabled
argument_list|(
name|connector
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|drm_target_cloned
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
modifier|*
name|modes
parameter_list|,
name|bool
modifier|*
name|enabled
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bool
name|can_clone
init|=
name|false
decl_stmt|;
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_helper_conn
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|dmt_mode
decl_stmt|,
modifier|*
name|mode
decl_stmt|;
comment|/* only contemplate cloning in the single crtc case */
if|if
condition|(
name|fb_helper
operator|->
name|crtc_count
operator|>
literal|1
condition|)
return|return
name|false
return|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|enabled
index|[
name|i
index|]
condition|)
name|count
operator|++
expr_stmt|;
block|}
comment|/* only contemplate cloning if more than one connector is enabled */
if|if
condition|(
name|count
operator|<=
literal|1
condition|)
return|return
name|false
return|;
comment|/* check the command line or if nothing common pick 1024x768 */
name|can_clone
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|enabled
index|[
name|i
index|]
condition|)
continue|continue;
name|fb_helper_conn
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
expr_stmt|;
name|modes
index|[
name|i
index|]
operator|=
name|drm_pick_cmdline_mode
argument_list|(
name|fb_helper_conn
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|modes
index|[
name|i
index|]
condition|)
block|{
name|can_clone
operator|=
name|false
expr_stmt|;
break|break;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|enabled
index|[
name|j
index|]
condition|)
continue|continue;
if|if
condition|(
operator|!
name|drm_mode_equal
argument_list|(
name|modes
index|[
name|j
index|]
argument_list|,
name|modes
index|[
name|i
index|]
argument_list|)
condition|)
name|can_clone
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|can_clone
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"can clone using command line\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* try and find a 1024x768 mode on each connector */
name|can_clone
operator|=
name|true
expr_stmt|;
name|dmt_mode
operator|=
name|drm_mode_find_dmt
argument_list|(
name|fb_helper
operator|->
name|dev
argument_list|,
literal|1024
argument_list|,
literal|768
argument_list|,
literal|60
argument_list|,
name|false
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|enabled
index|[
name|i
index|]
condition|)
continue|continue;
name|fb_helper_conn
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|mode
argument_list|,
argument|&fb_helper_conn->connector->modes
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|drm_mode_equal
argument_list|(
name|mode
argument_list|,
name|dmt_mode
argument_list|)
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|mode
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|modes
index|[
name|i
index|]
condition|)
name|can_clone
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|can_clone
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"can clone using 1024x768\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|DRM_INFO
argument_list|(
literal|"kms: can't enable cloning when we probably wanted to.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|drm_target_preferred
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
modifier|*
name|modes
parameter_list|,
name|bool
modifier|*
name|enabled
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_helper_conn
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|fb_helper_conn
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|enabled
index|[
name|i
index|]
operator|==
name|false
condition|)
continue|continue;
name|DRM_DEBUG_KMS
argument_list|(
literal|"looking for cmdline mode on connector %d\n"
argument_list|,
name|fb_helper_conn
operator|->
name|connector
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
comment|/* got for command line mode first */
name|modes
index|[
name|i
index|]
operator|=
name|drm_pick_cmdline_mode
argument_list|(
name|fb_helper_conn
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|modes
index|[
name|i
index|]
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"looking for preferred mode on connector %d\n"
argument_list|,
name|fb_helper_conn
operator|->
name|connector
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
name|modes
index|[
name|i
index|]
operator|=
name|drm_has_preferred_mode
argument_list|(
name|fb_helper_conn
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
comment|/* No preferred modes, pick one off the list */
if|if
condition|(
operator|!
name|modes
index|[
name|i
index|]
operator|&&
operator|!
name|list_empty
argument_list|(
operator|&
name|fb_helper_conn
operator|->
name|connector
operator|->
name|modes
argument_list|)
condition|)
block|{
name|list_for_each_entry
argument_list|(
argument|modes[i]
argument_list|,
argument|&fb_helper_conn->connector->modes
argument_list|,
argument|head
argument_list|)
break|break;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"found mode %s\n"
argument_list|,
name|modes
index|[
name|i
index|]
condition|?
name|modes
index|[
name|i
index|]
operator|->
name|name
else|:
literal|"none"
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_pick_crtcs
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|struct
name|drm_fb_helper_crtc
modifier|*
modifier|*
name|best_crtcs
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
modifier|*
name|modes
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|o
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|fb_helper
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_connector_helper_funcs
modifier|*
name|connector_funcs
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_fb_helper_crtc
modifier|*
name|best_crtc
decl_stmt|;
name|int
name|my_score
decl_stmt|,
name|best_score
decl_stmt|,
name|score
decl_stmt|;
name|struct
name|drm_fb_helper_crtc
modifier|*
modifier|*
name|crtcs
decl_stmt|,
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_helper_conn
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|fb_helper
operator|->
name|connector_count
condition|)
return|return
literal|0
return|;
name|fb_helper_conn
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|n
index|]
expr_stmt|;
name|connector
operator|=
name|fb_helper_conn
operator|->
name|connector
expr_stmt|;
name|best_crtcs
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
name|best_crtc
operator|=
name|NULL
expr_stmt|;
name|best_score
operator|=
name|drm_pick_crtcs
argument_list|(
name|fb_helper
argument_list|,
name|best_crtcs
argument_list|,
name|modes
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
index|[
name|n
index|]
operator|==
name|NULL
condition|)
return|return
name|best_score
return|;
name|crtcs
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_crtc
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|my_score
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|connector
operator|->
name|status
operator|==
name|connector_status_connected
condition|)
name|my_score
operator|++
expr_stmt|;
if|if
condition|(
name|drm_has_cmdline_mode
argument_list|(
name|fb_helper_conn
argument_list|)
condition|)
name|my_score
operator|++
expr_stmt|;
if|if
condition|(
name|drm_has_preferred_mode
argument_list|(
name|fb_helper_conn
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
condition|)
name|my_score
operator|++
expr_stmt|;
name|connector_funcs
operator|=
name|connector
operator|->
name|helper_private
expr_stmt|;
name|encoder
operator|=
name|connector_funcs
operator|->
name|best_encoder
argument_list|(
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoder
condition|)
goto|goto
name|out
goto|;
comment|/* select a crtc for this connector and then attempt to configure 	   remaining connectors */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|fb_helper
operator|->
name|crtc_count
condition|;
name|c
operator|++
control|)
block|{
name|crtc
operator|=
operator|&
name|fb_helper
operator|->
name|crtc_info
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|encoder
operator|->
name|possible_crtcs
operator|&
operator|(
literal|1
operator|<<
name|c
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|n
condition|;
name|o
operator|++
control|)
if|if
condition|(
name|best_crtcs
index|[
name|o
index|]
operator|==
name|crtc
condition|)
break|break;
if|if
condition|(
name|o
operator|<
name|n
condition|)
block|{
comment|/* ignore cloning unless only a single crtc */
if|if
condition|(
name|fb_helper
operator|->
name|crtc_count
operator|>
literal|1
condition|)
continue|continue;
if|if
condition|(
operator|!
name|drm_mode_equal
argument_list|(
name|modes
index|[
name|o
index|]
argument_list|,
name|modes
index|[
name|n
index|]
argument_list|)
condition|)
continue|continue;
block|}
name|crtcs
index|[
name|n
index|]
operator|=
name|crtc
expr_stmt|;
name|memcpy
argument_list|(
name|crtcs
argument_list|,
name|best_crtcs
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_crtc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|score
operator|=
name|my_score
operator|+
name|drm_pick_crtcs
argument_list|(
name|fb_helper
argument_list|,
name|crtcs
argument_list|,
name|modes
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|score
operator|>
name|best_score
condition|)
block|{
name|best_crtc
operator|=
name|crtc
expr_stmt|;
name|best_score
operator|=
name|score
expr_stmt|;
name|memcpy
argument_list|(
name|best_crtcs
argument_list|,
name|crtcs
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_crtc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|free
argument_list|(
name|crtcs
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
name|best_score
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drm_setup_crtcs
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|fb_helper
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_fb_helper_crtc
modifier|*
modifier|*
name|crtcs
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
modifier|*
name|modes
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_mode_set
modifier|*
name|modeset
decl_stmt|;
name|bool
modifier|*
name|enabled
decl_stmt|;
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|width
operator|=
name|dev
operator|->
name|mode_config
operator|.
name|max_width
expr_stmt|;
name|height
operator|=
name|dev
operator|->
name|mode_config
operator|.
name|max_height
expr_stmt|;
comment|/* clean out all the encoder/crtc combos */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
name|encoder
operator|->
name|crtc
operator|=
name|NULL
expr_stmt|;
block|}
name|crtcs
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_crtc
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|modes
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_display_mode
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|enabled
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|*
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|drm_enable_connectors
argument_list|(
name|fb_helper
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_target_cloned
argument_list|(
name|fb_helper
argument_list|,
name|modes
argument_list|,
name|enabled
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ret
operator|=
name|drm_target_preferred
argument_list|(
name|fb_helper
argument_list|,
name|modes
argument_list|,
name|enabled
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|DRM_ERROR
argument_list|(
literal|"Unable to find initial modes\n"
argument_list|)
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"picking CRTCs for %dx%d config\n"
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|drm_pick_crtcs
argument_list|(
name|fb_helper
argument_list|,
name|crtcs
argument_list|,
name|modes
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* need to set the modesets up here for use later */
comment|/* fill out the connector<->crtc mappings into the modesets */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|crtc_count
condition|;
name|i
operator|++
control|)
block|{
name|modeset
operator|=
operator|&
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
expr_stmt|;
name|modeset
operator|->
name|num_connectors
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
init|=
name|modes
index|[
name|i
index|]
decl_stmt|;
name|struct
name|drm_fb_helper_crtc
modifier|*
name|fb_crtc
init|=
name|crtcs
index|[
name|i
index|]
decl_stmt|;
name|modeset
operator|=
operator|&
name|fb_crtc
operator|->
name|mode_set
expr_stmt|;
if|if
condition|(
name|mode
operator|&&
name|fb_crtc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"desired mode %s set on crtc %d\n"
argument_list|,
name|mode
operator|->
name|name
argument_list|,
name|fb_crtc
operator|->
name|mode_set
operator|.
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
name|fb_crtc
operator|->
name|desired_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|modeset
operator|->
name|mode
condition|)
name|drm_mode_destroy
argument_list|(
name|dev
argument_list|,
name|modeset
operator|->
name|mode
argument_list|)
expr_stmt|;
name|modeset
operator|->
name|mode
operator|=
name|drm_mode_duplicate
argument_list|(
name|dev
argument_list|,
name|fb_crtc
operator|->
name|desired_mode
argument_list|)
expr_stmt|;
name|modeset
operator|->
name|connectors
index|[
name|modeset
operator|->
name|num_connectors
operator|++
index|]
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
operator|->
name|connector
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|crtcs
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|modes
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|enabled
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_helper_initial_config - setup a sane initial connector configuration  * @dev: DRM device  *  * LOCKING:  * Called at init time, must take mode config lock.  *  * Scan the CRTCs and connectors and try to put together an initial setup.  * At the moment, this is a cloned configuration across all heads with  * a new framebuffer object as the backing store.  *  * RETURNS:  * Zero if everything went ok, nonzero otherwise.  */
end_comment

begin_function
name|bool
name|drm_fb_helper_initial_config
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|int
name|bpp_sel
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|fb_helper
operator|->
name|dev
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* disable all the possible outputs/crtcs before entering KMS mode */
name|drm_helper_disable_unused_functions
argument_list|(
name|fb_helper
operator|->
name|dev
argument_list|)
expr_stmt|;
name|drm_fb_helper_parse_command_line
argument_list|(
name|fb_helper
argument_list|)
expr_stmt|;
name|count
operator|=
name|drm_fb_helper_probe_connector_modes
argument_list|(
name|fb_helper
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|max_width
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|max_height
argument_list|)
expr_stmt|;
comment|/* 	 * we shouldn't end up with no modes here. 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"No connectors reported connected with modes\n"
argument_list|)
expr_stmt|;
block|}
name|drm_setup_crtcs
argument_list|(
name|fb_helper
argument_list|)
expr_stmt|;
return|return
name|drm_fb_helper_single_fb_probe
argument_list|(
name|fb_helper
argument_list|,
name|bpp_sel
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|drm_fb_helper_hotplug_event
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|fb_helper
operator|->
name|dev
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|u32
name|max_width
decl_stmt|,
name|max_height
decl_stmt|,
name|bpp_sel
decl_stmt|;
name|bool
name|bound
init|=
name|false
decl_stmt|,
name|crtcs_bound
init|=
name|false
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
if|if
condition|(
operator|!
name|fb_helper
operator|->
name|fb
condition|)
return|return
literal|0
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|crtc
operator|->
name|fb
condition|)
name|crtcs_bound
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|fb
operator|==
name|fb_helper
operator|->
name|fb
condition|)
name|bound
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bound
operator|&&
name|crtcs_bound
condition|)
block|{
name|fb_helper
operator|->
name|delayed_hotplug
operator|=
name|true
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|max_width
operator|=
name|fb_helper
operator|->
name|fb
operator|->
name|width
expr_stmt|;
name|max_height
operator|=
name|fb_helper
operator|->
name|fb
operator|->
name|height
expr_stmt|;
name|bpp_sel
operator|=
name|fb_helper
operator|->
name|fb
operator|->
name|bits_per_pixel
expr_stmt|;
name|count
operator|=
name|drm_fb_helper_probe_connector_modes
argument_list|(
name|fb_helper
argument_list|,
name|max_width
argument_list|,
name|max_height
argument_list|)
expr_stmt|;
name|drm_setup_crtcs
argument_list|(
name|fb_helper
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|drm_fb_helper_single_fb_probe
argument_list|(
name|fb_helper
argument_list|,
name|bpp_sel
argument_list|)
return|;
block|}
end_function

end_unit

