begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006-2009 Red Hat Inc.  * Copyright (c) 2006-2008 Intel Corporation  * Copyright (c) 2007 Dave Airlie<airlied@linux.ie>  *  * DRM framebuffer helper functions  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting documentation, and  * that the name of the copyright holders not be used in advertising or  * publicity pertaining to distribution of the software without specific,  * written prior permission.  The copyright holders make no representations  * about the suitability of this software for any purpose.  It is provided "as  * is" without express or implied warranty.  *  * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO  * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR  * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  * OF THIS SOFTWARE.  *  * Authors:  *      Dave Airlie<airlied@linux.ie>  *      Jesse Barnes<jesse.barnes@intel.com>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|pr_fmt
parameter_list|(
name|fmt
parameter_list|)
value|KBUILD_MODNAME ": " fmt
end_define

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_fb_helper.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc_helper.h>
end_include

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"David Airlie, Jesse Barnes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"DRM KMS helper"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"GPL and additional rights"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|DRM_LIST_HEAD
argument_list|(
name|kernel_fb_helper_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_struct
struct|struct
name|vt_kms_softc
block|{
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
decl_stmt|;
name|struct
name|task
name|fb_mode_task
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Call restore out of vt(9) locks. */
end_comment

begin_function
specifier|static
name|void
name|vt_restore_fbdev_mode
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
decl_stmt|;
name|struct
name|vt_kms_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|vt_kms_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|fb_helper
operator|=
name|sc
operator|->
name|fb_helper
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|fb_helper
operator|->
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|drm_fb_helper_restore_fbdev_mode
argument_list|(
name|fb_helper
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|fb_helper
operator|->
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vt_kms_postswitch
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vt_kms_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|vt_kms_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|kdb_active
operator|&&
name|panicstr
operator|==
name|NULL
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|sc
operator|->
name|fb_mode_task
argument_list|)
expr_stmt|;
else|else
name|drm_fb_helper_restore_fbdev_mode
argument_list|(
name|sc
operator|->
name|fb_helper
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|fb_info
modifier|*
name|framebuffer_alloc
parameter_list|()
block|{
name|struct
name|fb_info
modifier|*
name|info
decl_stmt|;
name|struct
name|vt_kms_softc
modifier|*
name|sc
decl_stmt|;
name|info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|fb_mode_task
argument_list|,
literal|0
argument_list|,
name|vt_restore_fbdev_mode
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|info
operator|->
name|fb_priv
operator|=
name|sc
expr_stmt|;
name|info
operator|->
name|enter
operator|=
operator|&
name|vt_kms_postswitch
expr_stmt|;
return|return
operator|(
name|info
operator|)
return|;
block|}
end_function

begin_function
name|void
name|framebuffer_release
parameter_list|(
name|struct
name|fb_info
modifier|*
name|info
parameter_list|)
block|{
name|free
argument_list|(
name|info
operator|->
name|fb_priv
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fb_get_options
parameter_list|(
specifier|const
name|char
modifier|*
name|connector_name
parameter_list|,
name|char
modifier|*
modifier|*
name|option
parameter_list|)
block|{
name|char
name|tunable
index|[
literal|64
index|]
decl_stmt|;
comment|/* 	 * A user may use loader tunables to set a specific mode for the 	 * console. Tunables are read in the following order: 	 *     1. kern.vt.fb.modes.$connector_name 	 *     2. kern.vt.fb.default_mode 	 * 	 * Example of a mode specific to the LVDS connector: 	 *     kern.vt.fb.modes.LVDS="1024x768" 	 * 	 * Example of a mode applied to all connectors not having a 	 * connector-specific mode: 	 *     kern.vt.fb.default_mode="640x480" 	 */
name|snprintf
argument_list|(
name|tunable
argument_list|,
sizeof|sizeof
argument_list|(
name|tunable
argument_list|)
argument_list|,
literal|"kern.vt.fb.modes.%s"
argument_list|,
name|connector_name
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"Connector %s: get mode from tunables:\n"
argument_list|,
name|connector_name
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"  - %s\n"
argument_list|,
name|tunable
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"  - kern.vt.fb.default_mode\n"
argument_list|)
expr_stmt|;
operator|*
name|option
operator|=
name|kern_getenv
argument_list|(
name|tunable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|option
operator|==
name|NULL
condition|)
operator|*
name|option
operator|=
name|kern_getenv
argument_list|(
literal|"kern.vt.fb.default_mode"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|option
operator|!=
name|NULL
condition|?
literal|0
else|:
operator|-
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * DOC: fbdev helpers  *  * The fb helper functions are useful to provide an fbdev on top of a drm kernel  * mode setting driver. They can be used mostly independantely from the crtc  * helper functions used by many drivers to implement the kernel mode setting  * interfaces.  */
end_comment

begin_comment
comment|/* simple single crtc case helper function */
end_comment

begin_function
name|int
name|drm_fb_helper_single_add_all_connectors
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|fb_helper
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|int
name|i
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_helper_connector
decl_stmt|;
name|fb_helper_connector
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_connector
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fb_helper_connector
condition|)
goto|goto
name|fail
goto|;
name|fb_helper_connector
operator|->
name|connector
operator|=
name|connector
expr_stmt|;
name|fb_helper
operator|->
name|connector_info
index|[
name|fb_helper
operator|->
name|connector_count
operator|++
index|]
operator|=
name|fb_helper_connector
expr_stmt|;
block|}
return|return
literal|0
return|;
name|fail
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|fb_helper
operator|->
name|connector_count
operator|=
literal|0
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_fb_helper_single_add_all_connectors
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|drm_fb_helper_parse_command_line
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|)
block|{
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_helper_conn
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_cmdline_mode
modifier|*
name|mode
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|char
modifier|*
name|option
init|=
name|NULL
decl_stmt|;
name|fb_helper_conn
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
expr_stmt|;
name|connector
operator|=
name|fb_helper_conn
operator|->
name|connector
expr_stmt|;
name|mode
operator|=
operator|&
name|fb_helper_conn
operator|->
name|cmdline_mode
expr_stmt|;
comment|/* do something on return - turn off connector maybe */
if|if
condition|(
name|fb_get_options
argument_list|(
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
operator|&
name|option
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|drm_mode_parse_command_line_for_connector
argument_list|(
name|option
argument_list|,
name|connector
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|->
name|force
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|mode
operator|->
name|force
condition|)
block|{
case|case
name|DRM_FORCE_OFF
case|:
name|s
operator|=
literal|"OFF"
expr_stmt|;
break|break;
case|case
name|DRM_FORCE_ON_DIGITAL
case|:
name|s
operator|=
literal|"ON - dig"
expr_stmt|;
break|break;
default|default:
case|case
name|DRM_FORCE_ON
case|:
name|s
operator|=
literal|"ON"
expr_stmt|;
break|break;
block|}
name|DRM_INFO
argument_list|(
literal|"forcing %s connector %s\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|connector
operator|->
name|force
operator|=
name|mode
operator|->
name|force
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"cmdline mode for connector %s %dx%d@%dHz%s%s%s\n"
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|mode
operator|->
name|xres
argument_list|,
name|mode
operator|->
name|yres
argument_list|,
name|mode
operator|->
name|refresh_specified
condition|?
name|mode
operator|->
name|refresh
else|:
literal|60
argument_list|,
name|mode
operator|->
name|rb
condition|?
literal|" reduced blanking"
else|:
literal|""
argument_list|,
name|mode
operator|->
name|margins
condition|?
literal|" with margins"
else|:
literal|""
argument_list|,
name|mode
operator|->
name|interlace
condition|?
literal|" interlaced"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|freeenv
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|FREEBSD_NOTYET
argument_list|)
end_if

begin_comment
unit|static void drm_fb_helper_save_lut_atomic(struct drm_crtc *crtc, struct drm_fb_helper *helper) { 	uint16_t *r_base, *g_base, *b_base; 	int i;  	r_base = crtc->gamma_store; 	g_base = r_base + crtc->gamma_size; 	b_base = g_base + crtc->gamma_size;  	for (i = 0; i< crtc->gamma_size; i++) 		helper->funcs->gamma_get(crtc,&r_base[i],&g_base[i],&b_base[i], i); }  static void drm_fb_helper_restore_lut_atomic(struct drm_crtc *crtc) { 	uint16_t *r_base, *g_base, *b_base;  	if (crtc->funcs->gamma_set == NULL) 		return;  	r_base = crtc->gamma_store; 	g_base = r_base + crtc->gamma_size; 	b_base = g_base + crtc->gamma_size;  	crtc->funcs->gamma_set(crtc, r_base, g_base, b_base, 0, crtc->gamma_size); }  int drm_fb_helper_debug_enter(struct fb_info *info) { 	struct drm_fb_helper *helper = info->par; 	struct drm_crtc_helper_funcs *funcs; 	int i;  	if (list_empty(&kernel_fb_helper_list)) 		return false;  	list_for_each_entry(helper,&kernel_fb_helper_list, kernel_fb_list) { 		for (i = 0; i< helper->crtc_count; i++) { 			struct drm_mode_set *mode_set =&helper->crtc_info[i].mode_set;  			if (!mode_set->crtc->enabled) 				continue;  			funcs =	mode_set->crtc->helper_private; 			drm_fb_helper_save_lut_atomic(mode_set->crtc, helper); 			funcs->mode_set_base_atomic(mode_set->crtc, 						    mode_set->fb, 						    mode_set->x, 						    mode_set->y, 						    ENTER_ATOMIC_MODE_SET); 		} 	}  	return 0; } EXPORT_SYMBOL(drm_fb_helper_debug_enter);
comment|/* Find the real fb for a given fb helper CRTC */
end_comment

begin_endif
unit|static struct drm_framebuffer *drm_mode_config_fb(struct drm_crtc *crtc) { 	struct drm_device *dev = crtc->dev; 	struct drm_crtc *c;  	list_for_each_entry(c,&dev->mode_config.crtc_list, head) { 		if (crtc->base.id == c->base.id) 			return c->fb; 	}  	return NULL; }  int drm_fb_helper_debug_leave(struct fb_info *info) { 	struct drm_fb_helper *helper = info->par; 	struct drm_crtc *crtc; 	struct drm_crtc_helper_funcs *funcs; 	struct drm_framebuffer *fb; 	int i;  	for (i = 0; i< helper->crtc_count; i++) { 		struct drm_mode_set *mode_set =&helper->crtc_info[i].mode_set; 		crtc = mode_set->crtc; 		funcs = crtc->helper_private; 		fb = drm_mode_config_fb(crtc);  		if (!crtc->enabled) 			continue;  		if (!fb) { 			DRM_ERROR("no fb to restore??\n"); 			continue; 		}  		drm_fb_helper_restore_lut_atomic(mode_set->crtc); 		funcs->mode_set_base_atomic(mode_set->crtc, fb, crtc->x, 					    crtc->y, LEAVE_ATOMIC_MODE_SET); 	}  	return 0; } EXPORT_SYMBOL(drm_fb_helper_debug_leave);
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREEBSD_NOTYET */
end_comment

begin_function
name|bool
name|drm_fb_helper_restore_fbdev_mode
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|)
block|{
name|bool
name|error
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|crtc_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_mode_set
modifier|*
name|mode_set
init|=
operator|&
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
decl_stmt|;
name|ret
operator|=
name|mode_set
operator|->
name|crtc
operator|->
name|funcs
operator|->
name|set_config
argument_list|(
name|mode_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|error
operator|=
name|true
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_fb_helper_restore_fbdev_mode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|bool
name|drm_fb_helper_force_kernel_mode
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|,
name|error
init|=
name|false
decl_stmt|;
name|struct
name|drm_fb_helper
modifier|*
name|helper
decl_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|kernel_fb_helper_list
argument_list|)
condition|)
return|return
name|false
return|;
name|list_for_each_entry
argument_list|(
argument|helper
argument_list|,
argument|&kernel_fb_helper_list
argument_list|,
argument|kernel_fb_list
argument_list|)
block|{
if|if
condition|(
name|helper
operator|->
name|dev
operator|->
name|switch_power_state
operator|==
name|DRM_SWITCH_POWER_OFF
condition|)
continue|continue;
name|ret
operator|=
name|drm_fb_helper_restore_fbdev_mode
argument_list|(
name|helper
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|error
operator|=
name|true
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|FREEBSD_NOTYET
argument_list|)
end_if

begin_comment
unit|int drm_fb_helper_panic(struct notifier_block *n, unsigned long ununsed, 			void *panic_str) {
comment|/* 	 * It's a waste of time and effort to switch back to text console 	 * if the kernel should reboot before panic messages can be seen. 	 */
end_comment

begin_endif
unit|if (panic_timeout< 0) 		return 0;  	pr_err("panic occurred, switching back to text console\n"); 	return drm_fb_helper_force_kernel_mode(); } EXPORT_SYMBOL(drm_fb_helper_panic);  static struct notifier_block paniced = { 	.notifier_call = drm_fb_helper_panic, };
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREEBSD_NOTYET */
end_comment

begin_comment
comment|/**  * drm_fb_helper_restore - restore the framebuffer console (kernel) config  *  * Restore's the kernel's fbcon mode, used for lastclose& panic paths.  */
end_comment

begin_function
name|void
name|drm_fb_helper_restore
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|ret
operator|=
name|drm_fb_helper_force_kernel_mode
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|true
condition|)
name|DRM_ERROR
argument_list|(
literal|"Failed to restore crtc configuration\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_fb_helper_restore
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_MAGIC_SYSRQ
end_ifdef

begin_function
specifier|static
name|void
name|drm_fb_helper_restore_work_fn
parameter_list|(
name|struct
name|work_struct
modifier|*
name|ignored
parameter_list|)
block|{
name|drm_fb_helper_restore
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|DECLARE_WORK
argument_list|(
name|drm_fb_helper_restore_work
argument_list|,
name|drm_fb_helper_restore_work_fn
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|drm_fb_helper_sysrq
parameter_list|(
name|int
name|dummy1
parameter_list|)
block|{
name|schedule_work
argument_list|(
operator|&
name|drm_fb_helper_restore_work
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|sysrq_key_op
name|sysrq_drm_fb_helper_restore_op
init|=
block|{
operator|.
name|handler
operator|=
name|drm_fb_helper_sysrq
block|,
operator|.
name|help_msg
operator|=
literal|"force-fb(V)"
block|,
operator|.
name|action_msg
operator|=
literal|"Restore framebuffer console"
block|, }
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|sysrq_key_op
name|sysrq_drm_fb_helper_restore_op
init|=
block|{ }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|FREEBSD_NOTYET
argument_list|)
end_if

begin_comment
unit|static void drm_fb_helper_dpms(struct fb_info *info, int dpms_mode) { 	struct drm_fb_helper *fb_helper = info->par; 	struct drm_device *dev = fb_helper->dev; 	struct drm_crtc *crtc; 	struct drm_connector *connector; 	int i, j;
comment|/* 	 * For each CRTC in this fb, turn the connectors on/off. 	 */
end_comment

begin_comment
unit|sx_xlock(&dev->mode_config.mutex); 	for (i = 0; i< fb_helper->crtc_count; i++) { 		crtc = fb_helper->crtc_info[i].mode_set.crtc;  		if (!crtc->enabled) 			continue;
comment|/* Walk the connectors& encoders on this fb turning them on/off */
end_comment

begin_comment
unit|for (j = 0; j< fb_helper->connector_count; j++) { 			connector = fb_helper->connector_info[j]->connector; 			connector->funcs->dpms(connector, dpms_mode); 			drm_object_property_set_value(&connector->base, 				dev->mode_config.dpms_property, dpms_mode); 		} 	} 	sx_xunlock(&dev->mode_config.mutex); }  int drm_fb_helper_blank(int blank, struct fb_info *info) { 	switch (blank) {
comment|/* Display: On; HSync: On, VSync: On */
end_comment

begin_comment
unit|case FB_BLANK_UNBLANK: 		drm_fb_helper_dpms(info, DRM_MODE_DPMS_ON); 		break;
comment|/* Display: Off; HSync: On, VSync: On */
end_comment

begin_comment
unit|case FB_BLANK_NORMAL: 		drm_fb_helper_dpms(info, DRM_MODE_DPMS_STANDBY); 		break;
comment|/* Display: Off; HSync: Off, VSync: On */
end_comment

begin_comment
unit|case FB_BLANK_HSYNC_SUSPEND: 		drm_fb_helper_dpms(info, DRM_MODE_DPMS_STANDBY); 		break;
comment|/* Display: Off; HSync: On, VSync: Off */
end_comment

begin_comment
unit|case FB_BLANK_VSYNC_SUSPEND: 		drm_fb_helper_dpms(info, DRM_MODE_DPMS_SUSPEND); 		break;
comment|/* Display: Off; HSync: Off, VSync: Off */
end_comment

begin_endif
unit|case FB_BLANK_POWERDOWN: 		drm_fb_helper_dpms(info, DRM_MODE_DPMS_OFF); 		break; 	} 	return 0; } EXPORT_SYMBOL(drm_fb_helper_blank);
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREEBSD_NOTYET */
end_comment

begin_function
specifier|static
name|void
name|drm_fb_helper_crtc_free
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|helper
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|helper
operator|->
name|connector_info
index|[
name|i
index|]
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|helper
operator|->
name|connector_info
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|helper
operator|->
name|crtc_count
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|connectors
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|mode
condition|)
name|drm_mode_destroy
argument_list|(
name|helper
operator|->
name|dev
argument_list|,
name|helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|helper
operator|->
name|crtc_info
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|drm_fb_helper_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|int
name|crtc_count
parameter_list|,
name|int
name|max_conn_count
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fb_helper
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|fb_helper
operator|->
name|kernel_fb_list
argument_list|)
expr_stmt|;
name|fb_helper
operator|->
name|crtc_info
operator|=
name|malloc
argument_list|(
name|crtc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_crtc
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fb_helper
operator|->
name|crtc_info
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|fb_helper
operator|->
name|crtc_count
operator|=
name|crtc_count
expr_stmt|;
name|fb_helper
operator|->
name|connector_info
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_connector
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fb_helper
operator|->
name|connector_info
condition|)
block|{
name|free
argument_list|(
name|fb_helper
operator|->
name|crtc_info
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|fb_helper
operator|->
name|connector_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|crtc_count
condition|;
name|i
operator|++
control|)
block|{
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|connectors
operator|=
name|malloc
argument_list|(
name|max_conn_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_connector
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|connectors
condition|)
goto|goto
name|out_free
goto|;
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|num_connectors
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|crtc
operator|=
name|crtc
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
name|out_free
label|:
name|drm_fb_helper_crtc_free
argument_list|(
name|fb_helper
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_fb_helper_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|drm_fb_helper_fini
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|)
block|{
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|fb_helper
operator|->
name|kernel_fb_list
argument_list|)
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|fb_helper
operator|->
name|kernel_fb_list
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|FREEBSD_NOTYET
argument_list|)
block|if (list_empty(&kernel_fb_helper_list)) { 			pr_info("drm: unregistered panic notifier\n"); 			atomic_notifier_chain_unregister(&panic_notifier_list,&paniced); 			unregister_sysrq_key('v',&sysrq_drm_fb_helper_restore_op); 		}
endif|#
directive|endif
comment|/* FREEBSD_NOTYET */
block|}
name|drm_fb_helper_crtc_free
argument_list|(
name|fb_helper
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_fb_helper_fini
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|FREEBSD_NOTYET
argument_list|)
end_if

begin_comment
unit|static int setcolreg(struct drm_crtc *crtc, u16 red, u16 green, 		     u16 blue, u16 regno, struct fb_info *info) { 	struct drm_fb_helper *fb_helper = info->par; 	struct drm_framebuffer *fb = fb_helper->fb; 	int pindex;  	if (info->fix.visual == FB_VISUAL_TRUECOLOR) { 		u32 *palette; 		u32 value;
comment|/* place color in psuedopalette */
end_comment

begin_comment
unit|if (regno> 16) 			return -EINVAL; 		palette = (u32 *)info->pseudo_palette; 		red>>= (16 - info->var.red.length); 		green>>= (16 - info->var.green.length); 		blue>>= (16 - info->var.blue.length); 		value = (red<< info->var.red.offset) | 			(green<< info->var.green.offset) | 			(blue<< info->var.blue.offset); 		if (info->var.transp.length> 0) { 			u32 mask = (1<< info->var.transp.length) - 1; 			mask<<= info->var.transp.offset; 			value |= mask; 		} 		palette[regno] = value; 		return 0; 	}  	pindex = regno;  	if (fb->bits_per_pixel == 16) { 		pindex = regno<< 3;  		if (fb->depth == 16&& regno> 63) 			return -EINVAL; 		if (fb->depth == 15&& regno> 31) 			return -EINVAL;  		if (fb->depth == 16) { 			u16 r, g, b; 			int i; 			if (regno< 32) { 				for (i = 0; i< 8; i++) 					fb_helper->funcs->gamma_set(crtc, red, 						green, blue, pindex + i); 			}  			fb_helper->funcs->gamma_get(crtc,&r,&g,&b, 						    pindex>> 1);  			for (i = 0; i< 4; i++) 				fb_helper->funcs->gamma_set(crtc, r, 							    green, b, 							    (pindex>> 1) + i); 		} 	}  	if (fb->depth != 16) 		fb_helper->funcs->gamma_set(crtc, red, green, blue, pindex); 	return 0; }  int drm_fb_helper_setcmap(struct fb_cmap *cmap, struct fb_info *info) { 	struct drm_fb_helper *fb_helper = info->par; 	struct drm_crtc_helper_funcs *crtc_funcs; 	u16 *red, *green, *blue, *transp; 	struct drm_crtc *crtc; 	int i, j, rc = 0; 	int start;  	for (i = 0; i< fb_helper->crtc_count; i++) { 		crtc = fb_helper->crtc_info[i].mode_set.crtc; 		crtc_funcs = crtc->helper_private;  		red = cmap->red; 		green = cmap->green; 		blue = cmap->blue; 		transp = cmap->transp; 		start = cmap->start;  		for (j = 0; j< cmap->len; j++) { 			u16 hred, hgreen, hblue, htransp = 0xffff;  			hred = *red++; 			hgreen = *green++; 			hblue = *blue++;  			if (transp) 				htransp = *transp++;  			rc = setcolreg(crtc, hred, hgreen, hblue, start++, info); 			if (rc) 				return rc; 		} 		crtc_funcs->load_lut(crtc); 	} 	return rc; } EXPORT_SYMBOL(drm_fb_helper_setcmap);  int drm_fb_helper_check_var(struct fb_var_screeninfo *var, 			    struct fb_info *info) { 	struct drm_fb_helper *fb_helper = info->par; 	struct drm_framebuffer *fb = fb_helper->fb; 	int depth;  	if (var->pixclock != 0 || in_dbg_master()) 		return -EINVAL;
comment|/* Need to resize the fb object !!! */
end_comment

begin_comment
unit|if (var->bits_per_pixel> fb->bits_per_pixel || 	    var->xres> fb->width || var->yres> fb->height || 	    var->xres_virtual> fb->width || var->yres_virtual> fb->height) { 		DRM_DEBUG("fb userspace requested width/height/bpp is greater than current fb " 			  "request %dx%d-%d (virtual %dx%d)> %dx%d-%d\n", 			  var->xres, var->yres, var->bits_per_pixel, 			  var->xres_virtual, var->yres_virtual, 			  fb->width, fb->height, fb->bits_per_pixel); 		return -EINVAL; 	}  	switch (var->bits_per_pixel) { 	case 16: 		depth = (var->green.length == 6) ? 16 : 15; 		break; 	case 32: 		depth = (var->transp.length> 0) ? 32 : 24; 		break; 	default: 		depth = var->bits_per_pixel; 		break; 	}  	switch (depth) { 	case 8: 		var->red.offset = 0; 		var->green.offset = 0; 		var->blue.offset = 0; 		var->red.length = 8; 		var->green.length = 8; 		var->blue.length = 8; 		var->transp.length = 0; 		var->transp.offset = 0; 		break; 	case 15: 		var->red.offset = 10; 		var->green.offset = 5; 		var->blue.offset = 0; 		var->red.length = 5; 		var->green.length = 5; 		var->blue.length = 5; 		var->transp.length = 1; 		var->transp.offset = 15; 		break; 	case 16: 		var->red.offset = 11; 		var->green.offset = 5; 		var->blue.offset = 0; 		var->red.length = 5; 		var->green.length = 6; 		var->blue.length = 5; 		var->transp.length = 0; 		var->transp.offset = 0; 		break; 	case 24: 		var->red.offset = 16; 		var->green.offset = 8; 		var->blue.offset = 0; 		var->red.length = 8; 		var->green.length = 8; 		var->blue.length = 8; 		var->transp.length = 0; 		var->transp.offset = 0; 		break; 	case 32: 		var->red.offset = 16; 		var->green.offset = 8; 		var->blue.offset = 0; 		var->red.length = 8; 		var->green.length = 8; 		var->blue.length = 8; 		var->transp.length = 8; 		var->transp.offset = 24; 		break; 	default: 		return -EINVAL; 	} 	return 0; } EXPORT_SYMBOL(drm_fb_helper_check_var);
comment|/* this will let fbcon do the mode init */
end_comment

begin_endif
unit|int drm_fb_helper_set_par(struct fb_info *info) { 	struct drm_fb_helper *fb_helper = info->par; 	struct drm_device *dev = fb_helper->dev; 	struct fb_var_screeninfo *var =&info->var; 	struct drm_crtc *crtc; 	int ret; 	int i;  	if (var->pixclock != 0) { 		DRM_ERROR("PIXEL CLOCK SET\n"); 		return -EINVAL; 	}  	sx_xlock(&dev->mode_config.mutex); 	for (i = 0; i< fb_helper->crtc_count; i++) { 		crtc = fb_helper->crtc_info[i].mode_set.crtc; 		ret = crtc->funcs->set_config(&fb_helper->crtc_info[i].mode_set); 		if (ret) { 			sx_xunlock(&dev->mode_config.mutex); 			return ret; 		} 	} 	sx_xunlock(&dev->mode_config.mutex);  	if (fb_helper->delayed_hotplug) { 		fb_helper->delayed_hotplug = false; 		drm_fb_helper_hotplug_event(fb_helper); 	} 	return 0; } EXPORT_SYMBOL(drm_fb_helper_set_par);  int drm_fb_helper_pan_display(struct fb_var_screeninfo *var, 			      struct fb_info *info) { 	struct drm_fb_helper *fb_helper = info->par; 	struct drm_device *dev = fb_helper->dev; 	struct drm_mode_set *modeset; 	struct drm_crtc *crtc; 	int ret = 0; 	int i;  	sx_xlock(&dev->mode_config.mutex); 	for (i = 0; i< fb_helper->crtc_count; i++) { 		crtc = fb_helper->crtc_info[i].mode_set.crtc;  		modeset =&fb_helper->crtc_info[i].mode_set;  		modeset->x = var->xoffset; 		modeset->y = var->yoffset;  		if (modeset->num_connectors) { 			ret = crtc->funcs->set_config(modeset); 			if (!ret) { 				info->var.xoffset = var->xoffset; 				info->var.yoffset = var->yoffset; 			} 		} 	} 	sx_xunlock(&dev->mode_config.mutex); 	return ret; } EXPORT_SYMBOL(drm_fb_helper_pan_display);
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREEBSD_NOTYET */
end_comment

begin_function
name|int
name|drm_fb_helper_single_fb_probe
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|int
name|preferred_bpp
parameter_list|)
block|{
name|int
name|new_fb
init|=
literal|0
decl_stmt|;
name|int
name|crtc_count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|fb_info
modifier|*
name|info
decl_stmt|;
name|struct
name|drm_fb_helper_surface_size
name|sizes
decl_stmt|;
name|int
name|gamma_size
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|device_t
name|kdev
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|sizes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_surface_size
argument_list|)
argument_list|)
expr_stmt|;
name|sizes
operator|.
name|surface_depth
operator|=
literal|24
expr_stmt|;
name|sizes
operator|.
name|surface_bpp
operator|=
literal|32
expr_stmt|;
name|sizes
operator|.
name|fb_width
operator|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
name|sizes
operator|.
name|fb_height
operator|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* if driver picks 8 or 16 by default use that 	   for both depth/bpp */
if|if
condition|(
name|preferred_bpp
operator|!=
name|sizes
operator|.
name|surface_bpp
condition|)
name|sizes
operator|.
name|surface_depth
operator|=
name|sizes
operator|.
name|surface_bpp
operator|=
name|preferred_bpp
expr_stmt|;
comment|/* first up get a count of crtcs now in use and new min/maxes width/heights */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_helper_conn
init|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
decl_stmt|;
name|struct
name|drm_cmdline_mode
modifier|*
name|cmdline_mode
decl_stmt|;
name|cmdline_mode
operator|=
operator|&
name|fb_helper_conn
operator|->
name|cmdline_mode
expr_stmt|;
if|if
condition|(
name|cmdline_mode
operator|->
name|bpp_specified
condition|)
block|{
switch|switch
condition|(
name|cmdline_mode
operator|->
name|bpp
condition|)
block|{
case|case
literal|8
case|:
name|sizes
operator|.
name|surface_depth
operator|=
name|sizes
operator|.
name|surface_bpp
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|sizes
operator|.
name|surface_depth
operator|=
literal|15
expr_stmt|;
name|sizes
operator|.
name|surface_bpp
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|sizes
operator|.
name|surface_depth
operator|=
name|sizes
operator|.
name|surface_bpp
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|sizes
operator|.
name|surface_depth
operator|=
name|sizes
operator|.
name|surface_bpp
operator|=
literal|24
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|sizes
operator|.
name|surface_depth
operator|=
literal|24
expr_stmt|;
name|sizes
operator|.
name|surface_bpp
operator|=
literal|32
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
name|crtc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|crtc_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|desired_mode
decl_stmt|;
name|desired_mode
operator|=
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|desired_mode
expr_stmt|;
if|if
condition|(
name|desired_mode
condition|)
block|{
if|if
condition|(
name|gamma_size
operator|==
literal|0
condition|)
name|gamma_size
operator|=
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|crtc
operator|->
name|gamma_size
expr_stmt|;
if|if
condition|(
name|desired_mode
operator|->
name|hdisplay
operator|<
name|sizes
operator|.
name|fb_width
condition|)
name|sizes
operator|.
name|fb_width
operator|=
name|desired_mode
operator|->
name|hdisplay
expr_stmt|;
if|if
condition|(
name|desired_mode
operator|->
name|vdisplay
operator|<
name|sizes
operator|.
name|fb_height
condition|)
name|sizes
operator|.
name|fb_height
operator|=
name|desired_mode
operator|->
name|vdisplay
expr_stmt|;
if|if
condition|(
name|desired_mode
operator|->
name|hdisplay
operator|>
name|sizes
operator|.
name|surface_width
condition|)
name|sizes
operator|.
name|surface_width
operator|=
name|desired_mode
operator|->
name|hdisplay
expr_stmt|;
if|if
condition|(
name|desired_mode
operator|->
name|vdisplay
operator|>
name|sizes
operator|.
name|surface_height
condition|)
name|sizes
operator|.
name|surface_height
operator|=
name|desired_mode
operator|->
name|vdisplay
expr_stmt|;
name|crtc_count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|crtc_count
operator|==
literal|0
operator|||
name|sizes
operator|.
name|fb_width
operator|==
operator|-
literal|1
operator|||
name|sizes
operator|.
name|fb_height
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* hmm everyone went away - assume VGA cable just fell out 		   and will come back later. */
name|DRM_INFO
argument_list|(
literal|"Cannot find any crtc or sizes - going 1024x768\n"
argument_list|)
expr_stmt|;
name|sizes
operator|.
name|fb_width
operator|=
name|sizes
operator|.
name|surface_width
operator|=
literal|1024
expr_stmt|;
name|sizes
operator|.
name|fb_height
operator|=
name|sizes
operator|.
name|surface_height
operator|=
literal|768
expr_stmt|;
block|}
comment|/* push down into drivers */
name|new_fb
operator|=
call|(
modifier|*
name|fb_helper
operator|->
name|funcs
operator|->
name|fb_probe
call|)
argument_list|(
name|fb_helper
argument_list|,
operator|&
name|sizes
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_fb
operator|<
literal|0
condition|)
return|return
name|new_fb
return|;
name|info
operator|=
name|fb_helper
operator|->
name|fbdev
expr_stmt|;
name|kdev
operator|=
name|fb_helper
operator|->
name|dev
operator|->
name|dev
expr_stmt|;
name|info
operator|->
name|fb_video_dev
operator|=
name|device_get_parent
argument_list|(
name|kdev
argument_list|)
expr_stmt|;
comment|/* set the fb pointer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|crtc_count
condition|;
name|i
operator|++
control|)
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|fb
operator|=
name|fb_helper
operator|->
name|fb
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|new_fb
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|info
operator|->
name|fb_fbd_dev
operator|=
name|device_add_child
argument_list|(
name|kdev
argument_list|,
literal|"fbd"
argument_list|,
name|device_get_unit
argument_list|(
name|kdev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|fb_fbd_dev
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|device_probe_and_attach
argument_list|(
name|info
operator|->
name|fb_fbd_dev
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|ENODEV
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_VT
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|DRM_ERROR
argument_list|(
literal|"Failed to attach fbd device: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Modified version of drm_fb_helper_set_par() */
name|dev
operator|=
name|fb_helper
operator|->
name|dev
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|crtc_count
condition|;
name|i
operator|++
control|)
block|{
name|crtc
operator|=
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
operator|.
name|crtc
expr_stmt|;
name|ret
operator|=
name|crtc
operator|->
name|funcs
operator|->
name|set_config
argument_list|(
operator|&
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb_helper
operator|->
name|delayed_hotplug
condition|)
block|{
name|fb_helper
operator|->
name|delayed_hotplug
operator|=
name|false
expr_stmt|;
name|drm_fb_helper_hotplug_event
argument_list|(
name|fb_helper
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|new_fb
condition|)
block|{
name|info
operator|->
name|var
operator|.
name|pixclock
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|register_framebuffer
argument_list|(
name|info
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|dev_info
argument_list|(
name|fb_helper
operator|->
name|dev
operator|->
name|dev
argument_list|,
literal|"fb%d: %s frame buffer device\n"
argument_list|,
name|info
operator|->
name|node
argument_list|,
name|info
operator|->
name|fix
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drm_fb_helper_set_par
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|FREEBSD_NOTYET
argument_list|)
comment|/* Switch back to kernel console on panic */
comment|/* multi card linked list maybe */
block|if (list_empty(&kernel_fb_helper_list)) { 		dev_info(fb_helper->dev->dev, "registered panic notifier\n"); 		atomic_notifier_chain_register(&panic_notifier_list,&paniced); 		register_sysrq_key('v',&sysrq_drm_fb_helper_restore_op); 	}
endif|#
directive|endif
comment|/* FREEBSD_NOTYET */
if|if
condition|(
name|new_fb
condition|)
name|list_add
argument_list|(
operator|&
name|fb_helper
operator|->
name|kernel_fb_list
argument_list|,
operator|&
name|kernel_fb_helper_list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_fb_helper_single_fb_probe
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|drm_fb_helper_fill_fix
parameter_list|(
name|struct
name|fb_info
modifier|*
name|info
parameter_list|,
name|uint32_t
name|pitch
parameter_list|,
name|uint32_t
name|depth
parameter_list|)
block|{
name|info
operator|->
name|fb_stride
operator|=
name|pitch
expr_stmt|;
return|return;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_fb_helper_fill_fix
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|drm_fb_helper_fill_var
parameter_list|(
name|struct
name|fb_info
modifier|*
name|info
parameter_list|,
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|uint32_t
name|fb_width
parameter_list|,
name|uint32_t
name|fb_height
parameter_list|)
block|{
name|struct
name|drm_framebuffer
modifier|*
name|fb
init|=
name|fb_helper
operator|->
name|fb
decl_stmt|;
name|struct
name|vt_kms_softc
modifier|*
name|sc
decl_stmt|;
name|info
operator|->
name|fb_name
operator|=
name|device_get_nameunit
argument_list|(
name|fb_helper
operator|->
name|dev
operator|->
name|dev
argument_list|)
expr_stmt|;
name|info
operator|->
name|fb_width
operator|=
name|fb
operator|->
name|width
expr_stmt|;
name|info
operator|->
name|fb_height
operator|=
name|fb
operator|->
name|height
expr_stmt|;
name|info
operator|->
name|fb_depth
operator|=
name|fb
operator|->
name|bits_per_pixel
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|vt_kms_softc
operator|*
operator|)
name|info
operator|->
name|fb_priv
expr_stmt|;
name|sc
operator|->
name|fb_helper
operator|=
name|fb_helper
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_fb_helper_fill_var
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|drm_fb_helper_probe_connector_modes
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|uint32_t
name|maxX
parameter_list|,
name|uint32_t
name|maxY
parameter_list|)
block|{
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|connector
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
operator|->
name|connector
expr_stmt|;
name|count
operator|+=
name|connector
operator|->
name|funcs
operator|->
name|fill_modes
argument_list|(
name|connector
argument_list|,
name|maxX
argument_list|,
name|maxY
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_display_mode
modifier|*
name|drm_has_preferred_mode
parameter_list|(
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_connector
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|mode
argument_list|,
argument|&fb_connector->connector->modes
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|drm_mode_width
argument_list|(
name|mode
argument_list|)
operator|>
name|width
operator|||
name|drm_mode_height
argument_list|(
name|mode
argument_list|)
operator|>
name|height
condition|)
continue|continue;
if|if
condition|(
name|mode
operator|->
name|type
operator|&
name|DRM_MODE_TYPE_PREFERRED
condition|)
return|return
name|mode
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|drm_has_cmdline_mode
parameter_list|(
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_connector
parameter_list|)
block|{
name|struct
name|drm_cmdline_mode
modifier|*
name|cmdline_mode
decl_stmt|;
name|cmdline_mode
operator|=
operator|&
name|fb_connector
operator|->
name|cmdline_mode
expr_stmt|;
return|return
name|cmdline_mode
operator|->
name|specified
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_display_mode
modifier|*
name|drm_pick_cmdline_mode
parameter_list|(
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_helper_conn
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|struct
name|drm_cmdline_mode
modifier|*
name|cmdline_mode
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
init|=
name|NULL
decl_stmt|;
name|cmdline_mode
operator|=
operator|&
name|fb_helper_conn
operator|->
name|cmdline_mode
expr_stmt|;
if|if
condition|(
name|cmdline_mode
operator|->
name|specified
operator|==
name|false
condition|)
return|return
name|mode
return|;
comment|/* attempt to find a matching mode in the list of modes 	 *  we have gotten so far, if not add a CVT mode that conforms 	 */
if|if
condition|(
name|cmdline_mode
operator|->
name|rb
operator|||
name|cmdline_mode
operator|->
name|margins
condition|)
goto|goto
name|create_mode
goto|;
name|list_for_each_entry
argument_list|(
argument|mode
argument_list|,
argument|&fb_helper_conn->connector->modes
argument_list|,
argument|head
argument_list|)
block|{
comment|/* check width/height */
if|if
condition|(
name|mode
operator|->
name|hdisplay
operator|!=
name|cmdline_mode
operator|->
name|xres
operator|||
name|mode
operator|->
name|vdisplay
operator|!=
name|cmdline_mode
operator|->
name|yres
condition|)
continue|continue;
if|if
condition|(
name|cmdline_mode
operator|->
name|refresh_specified
condition|)
block|{
if|if
condition|(
name|mode
operator|->
name|vrefresh
operator|!=
name|cmdline_mode
operator|->
name|refresh
condition|)
continue|continue;
block|}
if|if
condition|(
name|cmdline_mode
operator|->
name|interlace
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
operator|)
condition|)
continue|continue;
block|}
return|return
name|mode
return|;
block|}
name|create_mode
label|:
name|mode
operator|=
name|drm_mode_create_from_cmdline_mode
argument_list|(
name|fb_helper_conn
operator|->
name|connector
operator|->
name|dev
argument_list|,
name|cmdline_mode
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|mode
operator|->
name|head
argument_list|,
operator|&
name|fb_helper_conn
operator|->
name|connector
operator|->
name|modes
argument_list|)
expr_stmt|;
return|return
name|mode
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|drm_connector_enabled
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|bool
name|strict
parameter_list|)
block|{
name|bool
name|enable
decl_stmt|;
if|if
condition|(
name|strict
condition|)
name|enable
operator|=
name|connector
operator|->
name|status
operator|==
name|connector_status_connected
expr_stmt|;
else|else
name|enable
operator|=
name|connector
operator|->
name|status
operator|!=
name|connector_status_disconnected
expr_stmt|;
return|return
name|enable
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drm_enable_connectors
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|bool
modifier|*
name|enabled
parameter_list|)
block|{
name|bool
name|any_enabled
init|=
name|false
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|connector
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
operator|->
name|connector
expr_stmt|;
name|enabled
index|[
name|i
index|]
operator|=
name|drm_connector_enabled
argument_list|(
name|connector
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"connector %d enabled? %s\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|enabled
index|[
name|i
index|]
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|any_enabled
operator||=
name|enabled
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|any_enabled
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|connector
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
operator|->
name|connector
expr_stmt|;
name|enabled
index|[
name|i
index|]
operator|=
name|drm_connector_enabled
argument_list|(
name|connector
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|drm_target_cloned
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
modifier|*
name|modes
parameter_list|,
name|bool
modifier|*
name|enabled
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bool
name|can_clone
init|=
name|false
decl_stmt|;
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_helper_conn
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|dmt_mode
decl_stmt|,
modifier|*
name|mode
decl_stmt|;
comment|/* only contemplate cloning in the single crtc case */
if|if
condition|(
name|fb_helper
operator|->
name|crtc_count
operator|>
literal|1
condition|)
return|return
name|false
return|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|enabled
index|[
name|i
index|]
condition|)
name|count
operator|++
expr_stmt|;
block|}
comment|/* only contemplate cloning if more than one connector is enabled */
if|if
condition|(
name|count
operator|<=
literal|1
condition|)
return|return
name|false
return|;
comment|/* check the command line or if nothing common pick 1024x768 */
name|can_clone
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|enabled
index|[
name|i
index|]
condition|)
continue|continue;
name|fb_helper_conn
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
expr_stmt|;
name|modes
index|[
name|i
index|]
operator|=
name|drm_pick_cmdline_mode
argument_list|(
name|fb_helper_conn
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|modes
index|[
name|i
index|]
condition|)
block|{
name|can_clone
operator|=
name|false
expr_stmt|;
break|break;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|enabled
index|[
name|j
index|]
condition|)
continue|continue;
if|if
condition|(
operator|!
name|drm_mode_equal
argument_list|(
name|modes
index|[
name|j
index|]
argument_list|,
name|modes
index|[
name|i
index|]
argument_list|)
condition|)
name|can_clone
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|can_clone
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"can clone using command line\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* try and find a 1024x768 mode on each connector */
name|can_clone
operator|=
name|true
expr_stmt|;
name|dmt_mode
operator|=
name|drm_mode_find_dmt
argument_list|(
name|fb_helper
operator|->
name|dev
argument_list|,
literal|1024
argument_list|,
literal|768
argument_list|,
literal|60
argument_list|,
name|false
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|enabled
index|[
name|i
index|]
condition|)
continue|continue;
name|fb_helper_conn
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|mode
argument_list|,
argument|&fb_helper_conn->connector->modes
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|drm_mode_equal
argument_list|(
name|mode
argument_list|,
name|dmt_mode
argument_list|)
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|mode
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|modes
index|[
name|i
index|]
condition|)
name|can_clone
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|can_clone
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"can clone using 1024x768\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|DRM_INFO
argument_list|(
literal|"kms: can't enable cloning when we probably wanted to.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|drm_target_preferred
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
modifier|*
name|modes
parameter_list|,
name|bool
modifier|*
name|enabled
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_helper_conn
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|fb_helper_conn
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|enabled
index|[
name|i
index|]
operator|==
name|false
condition|)
continue|continue;
name|DRM_DEBUG_KMS
argument_list|(
literal|"looking for cmdline mode on connector %d\n"
argument_list|,
name|fb_helper_conn
operator|->
name|connector
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
comment|/* got for command line mode first */
name|modes
index|[
name|i
index|]
operator|=
name|drm_pick_cmdline_mode
argument_list|(
name|fb_helper_conn
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|modes
index|[
name|i
index|]
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"looking for preferred mode on connector %d\n"
argument_list|,
name|fb_helper_conn
operator|->
name|connector
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
name|modes
index|[
name|i
index|]
operator|=
name|drm_has_preferred_mode
argument_list|(
name|fb_helper_conn
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
comment|/* No preferred modes, pick one off the list */
if|if
condition|(
operator|!
name|modes
index|[
name|i
index|]
operator|&&
operator|!
name|list_empty
argument_list|(
operator|&
name|fb_helper_conn
operator|->
name|connector
operator|->
name|modes
argument_list|)
condition|)
block|{
name|list_for_each_entry
argument_list|(
argument|modes[i]
argument_list|,
argument|&fb_helper_conn->connector->modes
argument_list|,
argument|head
argument_list|)
break|break;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"found mode %s\n"
argument_list|,
name|modes
index|[
name|i
index|]
condition|?
name|modes
index|[
name|i
index|]
operator|->
name|name
else|:
literal|"none"
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_pick_crtcs
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|struct
name|drm_fb_helper_crtc
modifier|*
modifier|*
name|best_crtcs
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
modifier|*
name|modes
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|o
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|fb_helper
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_connector_helper_funcs
modifier|*
name|connector_funcs
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_fb_helper_crtc
modifier|*
name|best_crtc
decl_stmt|;
name|int
name|my_score
decl_stmt|,
name|best_score
decl_stmt|,
name|score
decl_stmt|;
name|struct
name|drm_fb_helper_crtc
modifier|*
modifier|*
name|crtcs
decl_stmt|,
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_fb_helper_connector
modifier|*
name|fb_helper_conn
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|fb_helper
operator|->
name|connector_count
condition|)
return|return
literal|0
return|;
name|fb_helper_conn
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|n
index|]
expr_stmt|;
name|connector
operator|=
name|fb_helper_conn
operator|->
name|connector
expr_stmt|;
name|best_crtcs
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
name|best_crtc
operator|=
name|NULL
expr_stmt|;
name|best_score
operator|=
name|drm_pick_crtcs
argument_list|(
name|fb_helper
argument_list|,
name|best_crtcs
argument_list|,
name|modes
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
index|[
name|n
index|]
operator|==
name|NULL
condition|)
return|return
name|best_score
return|;
name|crtcs
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_crtc
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|crtcs
condition|)
return|return
name|best_score
return|;
name|my_score
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|connector
operator|->
name|status
operator|==
name|connector_status_connected
condition|)
name|my_score
operator|++
expr_stmt|;
if|if
condition|(
name|drm_has_cmdline_mode
argument_list|(
name|fb_helper_conn
argument_list|)
condition|)
name|my_score
operator|++
expr_stmt|;
if|if
condition|(
name|drm_has_preferred_mode
argument_list|(
name|fb_helper_conn
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
condition|)
name|my_score
operator|++
expr_stmt|;
name|connector_funcs
operator|=
name|connector
operator|->
name|helper_private
expr_stmt|;
name|encoder
operator|=
name|connector_funcs
operator|->
name|best_encoder
argument_list|(
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoder
condition|)
goto|goto
name|out
goto|;
comment|/* select a crtc for this connector and then attempt to configure 	   remaining connectors */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|fb_helper
operator|->
name|crtc_count
condition|;
name|c
operator|++
control|)
block|{
name|crtc
operator|=
operator|&
name|fb_helper
operator|->
name|crtc_info
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|encoder
operator|->
name|possible_crtcs
operator|&
operator|(
literal|1
operator|<<
name|c
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|n
condition|;
name|o
operator|++
control|)
if|if
condition|(
name|best_crtcs
index|[
name|o
index|]
operator|==
name|crtc
condition|)
break|break;
if|if
condition|(
name|o
operator|<
name|n
condition|)
block|{
comment|/* ignore cloning unless only a single crtc */
if|if
condition|(
name|fb_helper
operator|->
name|crtc_count
operator|>
literal|1
condition|)
continue|continue;
if|if
condition|(
operator|!
name|drm_mode_equal
argument_list|(
name|modes
index|[
name|o
index|]
argument_list|,
name|modes
index|[
name|n
index|]
argument_list|)
condition|)
continue|continue;
block|}
name|crtcs
index|[
name|n
index|]
operator|=
name|crtc
expr_stmt|;
name|memcpy
argument_list|(
name|crtcs
argument_list|,
name|best_crtcs
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_crtc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|score
operator|=
name|my_score
operator|+
name|drm_pick_crtcs
argument_list|(
name|fb_helper
argument_list|,
name|crtcs
argument_list|,
name|modes
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|score
operator|>
name|best_score
condition|)
block|{
name|best_crtc
operator|=
name|crtc
expr_stmt|;
name|best_score
operator|=
name|score
expr_stmt|;
name|memcpy
argument_list|(
name|best_crtcs
argument_list|,
name|crtcs
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_crtc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|free
argument_list|(
name|crtcs
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
name|best_score
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drm_setup_crtcs
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|fb_helper
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_fb_helper_crtc
modifier|*
modifier|*
name|crtcs
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
modifier|*
name|modes
decl_stmt|;
name|struct
name|drm_mode_set
modifier|*
name|modeset
decl_stmt|;
name|bool
modifier|*
name|enabled
decl_stmt|;
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|width
operator|=
name|dev
operator|->
name|mode_config
operator|.
name|max_width
expr_stmt|;
name|height
operator|=
name|dev
operator|->
name|mode_config
operator|.
name|max_height
expr_stmt|;
name|crtcs
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_fb_helper_crtc
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|modes
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_display_mode
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|enabled
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|*
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|crtcs
operator|||
operator|!
name|modes
operator|||
operator|!
name|enabled
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Memory allocation failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|drm_enable_connectors
argument_list|(
name|fb_helper
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_target_cloned
argument_list|(
name|fb_helper
argument_list|,
name|modes
argument_list|,
name|enabled
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ret
operator|=
name|drm_target_preferred
argument_list|(
name|fb_helper
argument_list|,
name|modes
argument_list|,
name|enabled
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|DRM_ERROR
argument_list|(
literal|"Unable to find initial modes\n"
argument_list|)
expr_stmt|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"picking CRTCs for %dx%d config\n"
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|drm_pick_crtcs
argument_list|(
name|fb_helper
argument_list|,
name|crtcs
argument_list|,
name|modes
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* need to set the modesets up here for use later */
comment|/* fill out the connector<->crtc mappings into the modesets */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|crtc_count
condition|;
name|i
operator|++
control|)
block|{
name|modeset
operator|=
operator|&
name|fb_helper
operator|->
name|crtc_info
index|[
name|i
index|]
operator|.
name|mode_set
expr_stmt|;
name|modeset
operator|->
name|num_connectors
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fb_helper
operator|->
name|connector_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
init|=
name|modes
index|[
name|i
index|]
decl_stmt|;
name|struct
name|drm_fb_helper_crtc
modifier|*
name|fb_crtc
init|=
name|crtcs
index|[
name|i
index|]
decl_stmt|;
name|modeset
operator|=
operator|&
name|fb_crtc
operator|->
name|mode_set
expr_stmt|;
if|if
condition|(
name|mode
operator|&&
name|fb_crtc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"desired mode %s set on crtc %d\n"
argument_list|,
name|mode
operator|->
name|name
argument_list|,
name|fb_crtc
operator|->
name|mode_set
operator|.
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
name|fb_crtc
operator|->
name|desired_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|modeset
operator|->
name|mode
condition|)
name|drm_mode_destroy
argument_list|(
name|dev
argument_list|,
name|modeset
operator|->
name|mode
argument_list|)
expr_stmt|;
name|modeset
operator|->
name|mode
operator|=
name|drm_mode_duplicate
argument_list|(
name|dev
argument_list|,
name|fb_crtc
operator|->
name|desired_mode
argument_list|)
expr_stmt|;
name|modeset
operator|->
name|connectors
index|[
name|modeset
operator|->
name|num_connectors
operator|++
index|]
operator|=
name|fb_helper
operator|->
name|connector_info
index|[
name|i
index|]
operator|->
name|connector
expr_stmt|;
block|}
block|}
name|out
label|:
name|free
argument_list|(
name|crtcs
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|modes
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|enabled
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_helper_initial_config - setup a sane initial connector configuration  * @fb_helper: fb_helper device struct  * @bpp_sel: bpp value to use for the framebuffer configuration  *  * LOCKING:  * Called at init time by the driver to set up the @fb_helper initial  * configuration, must take the mode config lock.  *  * Scans the CRTCs and connectors and tries to put together an initial setup.  * At the moment, this is a cloned configuration across all heads with  * a new framebuffer object as the backing store.  *  * RETURNS:  * Zero if everything went ok, nonzero otherwise.  */
end_comment

begin_function
name|bool
name|drm_fb_helper_initial_config
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|,
name|int
name|bpp_sel
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|fb_helper
operator|->
name|dev
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* disable all the possible outputs/crtcs before entering KMS mode */
name|drm_helper_disable_unused_functions
argument_list|(
name|fb_helper
operator|->
name|dev
argument_list|)
expr_stmt|;
name|drm_fb_helper_parse_command_line
argument_list|(
name|fb_helper
argument_list|)
expr_stmt|;
name|count
operator|=
name|drm_fb_helper_probe_connector_modes
argument_list|(
name|fb_helper
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|max_width
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|max_height
argument_list|)
expr_stmt|;
comment|/* 	 * we shouldn't end up with no modes here. 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|dev_info
argument_list|(
name|fb_helper
operator|->
name|dev
operator|->
name|dev
argument_list|,
literal|"No connectors reported connected with modes\n"
argument_list|)
expr_stmt|;
name|drm_setup_crtcs
argument_list|(
name|fb_helper
argument_list|)
expr_stmt|;
return|return
name|drm_fb_helper_single_fb_probe
argument_list|(
name|fb_helper
argument_list|,
name|bpp_sel
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_fb_helper_initial_config
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * drm_fb_helper_hotplug_event - respond to a hotplug notification by  *                               probing all the outputs attached to the fb  * @fb_helper: the drm_fb_helper  *  * LOCKING:  * Called at runtime, must take mode config lock.  *  * Scan the connectors attached to the fb_helper and try to put together a  * setup after *notification of a change in output configuration.  *  * RETURNS:  * 0 on success and a non-zero error code otherwise.  */
end_comment

begin_function
name|int
name|drm_fb_helper_hotplug_event
parameter_list|(
name|struct
name|drm_fb_helper
modifier|*
name|fb_helper
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|fb_helper
operator|->
name|dev
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|u32
name|max_width
decl_stmt|,
name|max_height
decl_stmt|,
name|bpp_sel
decl_stmt|;
name|int
name|bound
init|=
literal|0
decl_stmt|,
name|crtcs_bound
init|=
literal|0
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
if|if
condition|(
operator|!
name|fb_helper
operator|->
name|fb
condition|)
return|return
literal|0
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|crtc
operator|->
name|fb
condition|)
name|crtcs_bound
operator|++
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|fb
operator|==
name|fb_helper
operator|->
name|fb
condition|)
name|bound
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bound
operator|<
name|crtcs_bound
condition|)
block|{
name|fb_helper
operator|->
name|delayed_hotplug
operator|=
name|true
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|max_width
operator|=
name|fb_helper
operator|->
name|fb
operator|->
name|width
expr_stmt|;
name|max_height
operator|=
name|fb_helper
operator|->
name|fb
operator|->
name|height
expr_stmt|;
name|bpp_sel
operator|=
name|fb_helper
operator|->
name|fb
operator|->
name|bits_per_pixel
expr_stmt|;
name|count
operator|=
name|drm_fb_helper_probe_connector_modes
argument_list|(
name|fb_helper
argument_list|,
name|max_width
argument_list|,
name|max_height
argument_list|)
expr_stmt|;
name|drm_setup_crtcs
argument_list|(
name|fb_helper
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|drm_fb_helper_single_fb_probe
argument_list|(
name|fb_helper
argument_list|,
name|bpp_sel
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|drm_fb_helper_hotplug_event
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

