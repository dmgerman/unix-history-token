begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006-2008 Intel Corporation  * Copyright (c) 2007 Dave Airlie<airlied@linux.ie>  * Copyright (c) 2008 Red Hat Inc.  *  * DRM core CRTC related functions  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting documentation, and  * that the name of the copyright holders not be used in advertising or  * publicity pertaining to distribution of the software without specific,  * written prior permission.  The copyright holders make no representations  * about the suitability of this software for any purpose.  It is provided "as  * is" without express or implied warranty.  *  * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO  * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR  * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  * OF THIS SOFTWARE.  *  * Authors:  *      Keith Packard  *	Eric Anholt<eric@anholt.net>  *      Dave Airlie<airlied@linux.ie>  *      Jesse Barnes<jesse.barnes@intel.com>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_edid.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_fourcc.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_comment
comment|/* Avoid boilerplate.  I'm tired of typing. */
end_comment

begin_define
define|#
directive|define
name|DRM_ENUM_NAME_FN
parameter_list|(
name|fnname
parameter_list|,
name|list
parameter_list|)
define|\
value|char *fnname(int val)					\ 	{							\ 		int i;						\ 		for (i = 0; i< DRM_ARRAY_SIZE(list); i++) {	\ 			if (list[i].type == val)		\ 				return list[i].name;		\ 		}						\ 		return "(unknown)";				\ 	}
end_define

begin_comment
comment|/*  * Global properties  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|drm_prop_enum_list
name|drm_dpms_enum_list
index|[]
init|=
block|{
block|{
name|DRM_MODE_DPMS_ON
block|,
literal|"On"
block|}
block|,
block|{
name|DRM_MODE_DPMS_STANDBY
block|,
literal|"Standby"
block|}
block|,
block|{
name|DRM_MODE_DPMS_SUSPEND
block|,
literal|"Suspend"
block|}
block|,
block|{
name|DRM_MODE_DPMS_OFF
block|,
literal|"Off"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|DRM_ENUM_NAME_FN
argument_list|(
argument|drm_get_dpms_name
argument_list|,
argument|drm_dpms_enum_list
argument_list|)
end_macro

begin_comment
comment|/*  * Optional properties  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|drm_prop_enum_list
name|drm_scaling_mode_enum_list
index|[]
init|=
block|{
block|{
name|DRM_MODE_SCALE_NONE
block|,
literal|"None"
block|}
block|,
block|{
name|DRM_MODE_SCALE_FULLSCREEN
block|,
literal|"Full"
block|}
block|,
block|{
name|DRM_MODE_SCALE_CENTER
block|,
literal|"Center"
block|}
block|,
block|{
name|DRM_MODE_SCALE_ASPECT
block|,
literal|"Full aspect"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|drm_prop_enum_list
name|drm_dithering_mode_enum_list
index|[]
init|=
block|{
block|{
name|DRM_MODE_DITHERING_OFF
block|,
literal|"Off"
block|}
block|,
block|{
name|DRM_MODE_DITHERING_ON
block|,
literal|"On"
block|}
block|,
block|{
name|DRM_MODE_DITHERING_AUTO
block|,
literal|"Automatic"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Non-global properties, but "required" for certain connectors.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|drm_prop_enum_list
name|drm_dvi_i_select_enum_list
index|[]
init|=
block|{
block|{
name|DRM_MODE_SUBCONNECTOR_Automatic
block|,
literal|"Automatic"
block|}
block|,
comment|/* DVI-I and TV-out */
block|{
name|DRM_MODE_SUBCONNECTOR_DVID
block|,
literal|"DVI-D"
block|}
block|,
comment|/* DVI-I  */
block|{
name|DRM_MODE_SUBCONNECTOR_DVIA
block|,
literal|"DVI-A"
block|}
block|,
comment|/* DVI-I  */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|DRM_ENUM_NAME_FN
argument_list|(
argument|drm_get_dvi_i_select_name
argument_list|,
argument|drm_dvi_i_select_enum_list
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|struct
name|drm_prop_enum_list
name|drm_dvi_i_subconnector_enum_list
index|[]
init|=
block|{
block|{
name|DRM_MODE_SUBCONNECTOR_Unknown
block|,
literal|"Unknown"
block|}
block|,
comment|/* DVI-I and TV-out */
block|{
name|DRM_MODE_SUBCONNECTOR_DVID
block|,
literal|"DVI-D"
block|}
block|,
comment|/* DVI-I  */
block|{
name|DRM_MODE_SUBCONNECTOR_DVIA
block|,
literal|"DVI-A"
block|}
block|,
comment|/* DVI-I  */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|DRM_ENUM_NAME_FN
argument_list|(
argument|drm_get_dvi_i_subconnector_name
argument_list|,
argument|drm_dvi_i_subconnector_enum_list
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|struct
name|drm_prop_enum_list
name|drm_tv_select_enum_list
index|[]
init|=
block|{
block|{
name|DRM_MODE_SUBCONNECTOR_Automatic
block|,
literal|"Automatic"
block|}
block|,
comment|/* DVI-I and TV-out */
block|{
name|DRM_MODE_SUBCONNECTOR_Composite
block|,
literal|"Composite"
block|}
block|,
comment|/* TV-out */
block|{
name|DRM_MODE_SUBCONNECTOR_SVIDEO
block|,
literal|"SVIDEO"
block|}
block|,
comment|/* TV-out */
block|{
name|DRM_MODE_SUBCONNECTOR_Component
block|,
literal|"Component"
block|}
block|,
comment|/* TV-out */
block|{
name|DRM_MODE_SUBCONNECTOR_SCART
block|,
literal|"SCART"
block|}
block|,
comment|/* TV-out */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|DRM_ENUM_NAME_FN
argument_list|(
argument|drm_get_tv_select_name
argument_list|,
argument|drm_tv_select_enum_list
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|struct
name|drm_prop_enum_list
name|drm_tv_subconnector_enum_list
index|[]
init|=
block|{
block|{
name|DRM_MODE_SUBCONNECTOR_Unknown
block|,
literal|"Unknown"
block|}
block|,
comment|/* DVI-I and TV-out */
block|{
name|DRM_MODE_SUBCONNECTOR_Composite
block|,
literal|"Composite"
block|}
block|,
comment|/* TV-out */
block|{
name|DRM_MODE_SUBCONNECTOR_SVIDEO
block|,
literal|"SVIDEO"
block|}
block|,
comment|/* TV-out */
block|{
name|DRM_MODE_SUBCONNECTOR_Component
block|,
literal|"Component"
block|}
block|,
comment|/* TV-out */
block|{
name|DRM_MODE_SUBCONNECTOR_SCART
block|,
literal|"SCART"
block|}
block|,
comment|/* TV-out */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|DRM_ENUM_NAME_FN
argument_list|(
argument|drm_get_tv_subconnector_name
argument_list|,
argument|drm_tv_subconnector_enum_list
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|struct
name|drm_prop_enum_list
name|drm_dirty_info_enum_list
index|[]
init|=
block|{
block|{
name|DRM_MODE_DIRTY_OFF
block|,
literal|"Off"
block|}
block|,
block|{
name|DRM_MODE_DIRTY_ON
block|,
literal|"On"
block|}
block|,
block|{
name|DRM_MODE_DIRTY_ANNOTATE
block|,
literal|"Annotate"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_macro
name|DRM_ENUM_NAME_FN
argument_list|(
argument|drm_get_dirty_info_name
argument_list|,
argument|drm_dirty_info_enum_list
argument_list|)
end_macro

begin_struct
struct|struct
name|drm_conn_prop_enum_list
block|{
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Connector and encoder types.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|drm_conn_prop_enum_list
name|drm_connector_enum_list
index|[]
init|=
block|{
block|{
name|DRM_MODE_CONNECTOR_Unknown
block|,
literal|"Unknown"
block|,
literal|0
block|}
block|,
block|{
name|DRM_MODE_CONNECTOR_VGA
block|,
literal|"VGA"
block|,
literal|0
block|}
block|,
block|{
name|DRM_MODE_CONNECTOR_DVII
block|,
literal|"DVI-I"
block|,
literal|0
block|}
block|,
block|{
name|DRM_MODE_CONNECTOR_DVID
block|,
literal|"DVI-D"
block|,
literal|0
block|}
block|,
block|{
name|DRM_MODE_CONNECTOR_DVIA
block|,
literal|"DVI-A"
block|,
literal|0
block|}
block|,
block|{
name|DRM_MODE_CONNECTOR_Composite
block|,
literal|"Composite"
block|,
literal|0
block|}
block|,
block|{
name|DRM_MODE_CONNECTOR_SVIDEO
block|,
literal|"SVIDEO"
block|,
literal|0
block|}
block|,
block|{
name|DRM_MODE_CONNECTOR_LVDS
block|,
literal|"LVDS"
block|,
literal|0
block|}
block|,
block|{
name|DRM_MODE_CONNECTOR_Component
block|,
literal|"Component"
block|,
literal|0
block|}
block|,
block|{
name|DRM_MODE_CONNECTOR_9PinDIN
block|,
literal|"DIN"
block|,
literal|0
block|}
block|,
block|{
name|DRM_MODE_CONNECTOR_DisplayPort
block|,
literal|"DP"
block|,
literal|0
block|}
block|,
block|{
name|DRM_MODE_CONNECTOR_HDMIA
block|,
literal|"HDMI-A"
block|,
literal|0
block|}
block|,
block|{
name|DRM_MODE_CONNECTOR_HDMIB
block|,
literal|"HDMI-B"
block|,
literal|0
block|}
block|,
block|{
name|DRM_MODE_CONNECTOR_TV
block|,
literal|"TV"
block|,
literal|0
block|}
block|,
block|{
name|DRM_MODE_CONNECTOR_eDP
block|,
literal|"eDP"
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|drm_prop_enum_list
name|drm_encoder_enum_list
index|[]
init|=
block|{
block|{
name|DRM_MODE_ENCODER_NONE
block|,
literal|"None"
block|}
block|,
block|{
name|DRM_MODE_ENCODER_DAC
block|,
literal|"DAC"
block|}
block|,
block|{
name|DRM_MODE_ENCODER_TMDS
block|,
literal|"TMDS"
block|}
block|,
block|{
name|DRM_MODE_ENCODER_LVDS
block|,
literal|"LVDS"
block|}
block|,
block|{
name|DRM_MODE_ENCODER_TVDAC
block|,
literal|"TV"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|drm_property_destroy_blob
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_property_blob
modifier|*
name|blob
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|char
modifier|*
name|drm_get_encoder_name
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
literal|32
argument_list|,
literal|"%s-%d"
argument_list|,
name|drm_encoder_enum_list
index|[
name|encoder
operator|->
name|encoder_type
index|]
operator|.
name|name
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|drm_get_connector_name
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
literal|32
argument_list|,
literal|"%s-%d"
argument_list|,
name|drm_connector_enum_list
index|[
name|connector
operator|->
name|connector_type
index|]
operator|.
name|name
argument_list|,
name|connector
operator|->
name|connector_type_id
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|drm_get_connector_status_name
parameter_list|(
name|enum
name|drm_connector_status
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|==
name|connector_status_connected
condition|)
return|return
literal|"connected"
return|;
elseif|else
if|if
condition|(
name|status
operator|==
name|connector_status_disconnected
condition|)
return|return
literal|"disconnected"
return|;
else|else
return|return
literal|"unknown"
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_object_get - allocate a new identifier  * @dev: DRM device  * @ptr: object pointer, used to generate unique ID  * @type: object type  *  * LOCKING:  *  * Create a unique identifier based on @ptr in @dev's identifier space.  Used  * for tracking modes, CRTCs and connectors.  *  * RETURNS:  * New unique (relative to other objects in @dev) integer identifier for the  * object.  */
end_comment

begin_function
specifier|static
name|int
name|drm_mode_object_get
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_mode_object
modifier|*
name|obj
parameter_list|,
name|uint32_t
name|obj_type
parameter_list|)
block|{
name|int
name|new_id
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|new_id
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|drm_gem_name_create
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|crtc_names
argument_list|,
name|obj
argument_list|,
operator|&
name|new_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|obj
operator|->
name|id
operator|=
name|new_id
expr_stmt|;
name|obj
operator|->
name|type
operator|=
name|obj_type
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_object_put - free an identifer  * @dev: DRM device  * @id: ID to free  *  * LOCKING:  * Caller must hold DRM mode_config lock.  *  * Free @id from @dev's unique identifier pool.  */
end_comment

begin_function
specifier|static
name|void
name|drm_mode_object_put
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_mode_object
modifier|*
name|object
parameter_list|)
block|{
name|drm_gem_names_remove
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|crtc_names
argument_list|,
name|object
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|drm_mode_object
modifier|*
name|drm_mode_object_find
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|id
parameter_list|,
name|uint32_t
name|type
parameter_list|)
block|{
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|drm_gem_name_ref
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|crtc_names
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
operator|||
operator|(
name|obj
operator|->
name|type
operator|!=
name|type
operator|)
operator|||
operator|(
name|obj
operator|->
name|id
operator|!=
name|id
operator|)
condition|)
name|obj
operator|=
name|NULL
expr_stmt|;
return|return
name|obj
return|;
block|}
end_function

begin_comment
comment|/**  * drm_framebuffer_init - initialize a framebuffer  * @dev: DRM device  *  * LOCKING:  * Caller must hold mode config lock.  *  * Allocates an ID for the framebuffer's parent mode object, sets its mode  * functions& device file and adds it to the master fd list.  *  * RETURNS:  * Zero on success, error code on failure.  */
end_comment

begin_function
name|int
name|drm_framebuffer_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
specifier|const
name|struct
name|drm_framebuffer_funcs
modifier|*
name|funcs
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|DRM_MODE_CONFIG_ASSERT_LOCKED
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_mode_object_get
argument_list|(
name|dev
argument_list|,
operator|&
name|fb
operator|->
name|base
argument_list|,
name|DRM_MODE_OBJECT_FB
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|fb
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|fb
operator|->
name|funcs
operator|=
name|funcs
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|num_fb
operator|++
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|fb
operator|->
name|head
argument_list|,
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|fb_list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * drm_framebuffer_cleanup - remove a framebuffer object  * @fb: framebuffer to remove  *  * LOCKING:  * Caller must hold mode config lock.  *  * Scans all the CRTCs in @dev's mode_config.  If they're using @fb, removes  * it, setting it to NULL.  */
end_comment

begin_function
name|void
name|drm_framebuffer_cleanup
parameter_list|(
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|fb
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_plane
modifier|*
name|plane
decl_stmt|;
name|struct
name|drm_mode_set
name|set
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_MODE_CONFIG_ASSERT_LOCKED
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* remove from any CRTC */
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|crtc
operator|->
name|fb
operator|==
name|fb
condition|)
block|{
comment|/* should turn off the crtc */
name|memset
argument_list|(
operator|&
name|set
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|drm_mode_set
argument_list|)
argument_list|)
expr_stmt|;
name|set
operator|.
name|crtc
operator|=
name|crtc
expr_stmt|;
name|set
operator|.
name|fb
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|crtc
operator|->
name|funcs
operator|->
name|set_config
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to reset crtc %p when fb was deleted\n"
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
block|}
block|}
name|list_for_each_entry
argument_list|(
argument|plane
argument_list|,
argument|&dev->mode_config.plane_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|plane
operator|->
name|fb
operator|==
name|fb
condition|)
block|{
comment|/* should turn off the crtc */
name|ret
operator|=
name|plane
operator|->
name|funcs
operator|->
name|disable_plane
argument_list|(
name|plane
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to disable plane with busy fb\n"
argument_list|)
expr_stmt|;
comment|/* disconnect the plane from the fb and crtc: */
name|plane
operator|->
name|fb
operator|=
name|NULL
expr_stmt|;
name|plane
operator|->
name|crtc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|drm_mode_object_put
argument_list|(
name|dev
argument_list|,
operator|&
name|fb
operator|->
name|base
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|fb
operator|->
name|head
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|num_fb
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_crtc_init - Initialise a new CRTC object  * @dev: DRM device  * @crtc: CRTC object to init  * @funcs: callbacks for the new CRTC  *  * LOCKING:  * Caller must hold mode config lock.  *  * Inits a new object created as base part of an driver crtc object.  *  * RETURNS:  * Zero on success, error code on failure.  */
end_comment

begin_function
name|int
name|drm_crtc_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
specifier|const
name|struct
name|drm_crtc_funcs
modifier|*
name|funcs
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|crtc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|crtc
operator|->
name|funcs
operator|=
name|funcs
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_mode_object_get
argument_list|(
name|dev
argument_list|,
operator|&
name|crtc
operator|->
name|base
argument_list|,
name|DRM_MODE_OBJECT_CRTC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|list_add_tail
argument_list|(
operator|&
name|crtc
operator|->
name|head
argument_list|,
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|crtc_list
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|num_crtc
operator|++
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * drm_crtc_cleanup - Cleans up the core crtc usage.  * @crtc: CRTC to cleanup  *  * LOCKING:  * Caller must hold mode config lock.  *  * Cleanup @crtc. Removes from drm modesetting space  * does NOT free object, caller does that.  */
end_comment

begin_function
name|void
name|drm_crtc_cleanup
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|DRM_MODE_CONFIG_ASSERT_LOCKED
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|gamma_store
condition|)
block|{
name|free
argument_list|(
name|crtc
operator|->
name|gamma_store
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|gamma_store
operator|=
name|NULL
expr_stmt|;
block|}
name|drm_mode_object_put
argument_list|(
name|dev
argument_list|,
operator|&
name|crtc
operator|->
name|base
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|crtc
operator|->
name|head
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|num_crtc
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_probed_add - add a mode to a connector's probed mode list  * @connector: connector the new mode  * @mode: mode data  *  * LOCKING:  * Caller must hold mode config lock.  *  * Add @mode to @connector's mode list for later use.  */
end_comment

begin_function
name|void
name|drm_mode_probed_add
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|DRM_MODE_CONFIG_ASSERT_LOCKED
argument_list|(
name|connector
operator|->
name|dev
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|mode
operator|->
name|head
argument_list|,
operator|&
name|connector
operator|->
name|probed_modes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_remove - remove and free a mode  * @connector: connector list to modify  * @mode: mode to remove  *  * LOCKING:  * Caller must hold mode config lock.  *  * Remove @mode from @connector's mode list, then free it.  */
end_comment

begin_function
name|void
name|drm_mode_remove
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|DRM_MODE_CONFIG_ASSERT_LOCKED
argument_list|(
name|connector
operator|->
name|dev
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mode
operator|->
name|head
argument_list|)
expr_stmt|;
name|drm_mode_destroy
argument_list|(
name|connector
operator|->
name|dev
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_connector_init - Init a preallocated connector  * @dev: DRM device  * @connector: the connector to init  * @funcs: callbacks for this connector  * @name: user visible name of the connector  *  * LOCKING:  * Takes mode config lock.  *  * Initialises a preallocated connector. Connectors should be  * subclassed as part of driver connector objects.  *  * RETURNS:  * Zero on success, error code on failure.  */
end_comment

begin_function
name|int
name|drm_connector_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
specifier|const
name|struct
name|drm_connector_funcs
modifier|*
name|funcs
parameter_list|,
name|int
name|connector_type
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_mode_object_get
argument_list|(
name|dev
argument_list|,
operator|&
name|connector
operator|->
name|base
argument_list|,
name|DRM_MODE_OBJECT_CONNECTOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|connector
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|connector
operator|->
name|funcs
operator|=
name|funcs
expr_stmt|;
name|connector
operator|->
name|connector_type
operator|=
name|connector_type
expr_stmt|;
name|connector
operator|->
name|connector_type_id
operator|=
operator|++
name|drm_connector_enum_list
index|[
name|connector_type
index|]
operator|.
name|count
expr_stmt|;
comment|/* TODO */
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|connector
operator|->
name|user_modes
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|connector
operator|->
name|probed_modes
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|connector
operator|->
name|modes
argument_list|)
expr_stmt|;
name|connector
operator|->
name|edid_blob_ptr
operator|=
name|NULL
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|connector
operator|->
name|head
argument_list|,
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|connector_list
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|++
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
name|connector
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|edid_property
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drm_connector_attach_property
argument_list|(
name|connector
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|dpms_property
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * drm_connector_cleanup - cleans up an initialised connector  * @connector: connector to cleanup  *  * LOCKING:  * Takes mode config lock.  *  * Cleans up the connector but doesn't free the object.  */
end_comment

begin_function
name|void
name|drm_connector_cleanup
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|mode
argument_list|,
argument|t
argument_list|,
argument|&connector->probed_modes
argument_list|,
argument|head
argument_list|)
name|drm_mode_remove
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|mode
argument_list|,
argument|t
argument_list|,
argument|&connector->modes
argument_list|,
argument|head
argument_list|)
name|drm_mode_remove
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|mode
argument_list|,
argument|t
argument_list|,
argument|&connector->user_modes
argument_list|,
argument|head
argument_list|)
name|drm_mode_remove
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|connector
operator|->
name|edid_blob_ptr
condition|)
name|drm_property_destroy_blob
argument_list|(
name|dev
argument_list|,
name|connector
operator|->
name|edid_blob_ptr
argument_list|)
expr_stmt|;
name|drm_mode_object_put
argument_list|(
name|dev
argument_list|,
operator|&
name|connector
operator|->
name|base
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|connector
operator|->
name|head
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|--
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|drm_encoder_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
specifier|const
name|struct
name|drm_encoder_funcs
modifier|*
name|funcs
parameter_list|,
name|int
name|encoder_type
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_mode_object_get
argument_list|(
name|dev
argument_list|,
operator|&
name|encoder
operator|->
name|base
argument_list|,
name|DRM_MODE_OBJECT_ENCODER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|encoder
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|encoder
operator|->
name|encoder_type
operator|=
name|encoder_type
expr_stmt|;
name|encoder
operator|->
name|funcs
operator|=
name|funcs
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|encoder
operator|->
name|head
argument_list|,
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|encoder_list
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|num_encoder
operator|++
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|drm_encoder_cleanup
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|drm_mode_object_put
argument_list|(
name|dev
argument_list|,
operator|&
name|encoder
operator|->
name|base
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|encoder
operator|->
name|head
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|num_encoder
operator|--
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|drm_plane_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_plane
modifier|*
name|plane
parameter_list|,
name|unsigned
name|long
name|possible_crtcs
parameter_list|,
specifier|const
name|struct
name|drm_plane_funcs
modifier|*
name|funcs
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|formats
parameter_list|,
name|uint32_t
name|format_count
parameter_list|,
name|bool
name|priv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_mode_object_get
argument_list|(
name|dev
argument_list|,
operator|&
name|plane
operator|->
name|base
argument_list|,
name|DRM_MODE_OBJECT_PLANE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|plane
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|plane
operator|->
name|funcs
operator|=
name|funcs
expr_stmt|;
name|plane
operator|->
name|format_types
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|format_count
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|plane
operator|->
name|format_types
argument_list|,
name|formats
argument_list|,
name|format_count
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|plane
operator|->
name|format_count
operator|=
name|format_count
expr_stmt|;
name|plane
operator|->
name|possible_crtcs
operator|=
name|possible_crtcs
expr_stmt|;
comment|/* private planes are not exposed to userspace, but depending on 	 * display hardware, might be convenient to allow sharing programming 	 * for the scanout engine with the crtc implementation. 	 */
if|if
condition|(
operator|!
name|priv
condition|)
block|{
name|list_add_tail
argument_list|(
operator|&
name|plane
operator|->
name|head
argument_list|,
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|plane_list
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|num_plane
operator|++
expr_stmt|;
block|}
else|else
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|plane
operator|->
name|head
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|drm_plane_cleanup
parameter_list|(
name|struct
name|drm_plane
modifier|*
name|plane
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|plane
operator|->
name|dev
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|plane
operator|->
name|format_types
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|drm_mode_object_put
argument_list|(
name|dev
argument_list|,
operator|&
name|plane
operator|->
name|base
argument_list|)
expr_stmt|;
comment|/* if not added to a list, it must be a private plane */
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|plane
operator|->
name|head
argument_list|)
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|plane
operator|->
name|head
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|num_plane
operator|--
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_create - create a new display mode  * @dev: DRM device  *  * LOCKING:  * Caller must hold DRM mode_config lock.  *  * Create a new drm_display_mode, give it an ID, and return it.  *  * RETURNS:  * Pointer to new mode on success, NULL on error.  */
end_comment

begin_function
name|struct
name|drm_display_mode
modifier|*
name|drm_mode_create
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|nmode
decl_stmt|;
name|nmode
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|drm_display_mode
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|drm_mode_object_get
argument_list|(
name|dev
argument_list|,
operator|&
name|nmode
operator|->
name|base
argument_list|,
name|DRM_MODE_OBJECT_MODE
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|nmode
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
name|nmode
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_destroy - remove a mode  * @dev: DRM device  * @mode: mode to remove  *  * LOCKING:  * Caller must hold mode config lock.  *  * Free @mode's unique identifier, then free it.  */
end_comment

begin_function
name|void
name|drm_mode_destroy
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mode
condition|)
return|return;
name|drm_mode_object_put
argument_list|(
name|dev
argument_list|,
operator|&
name|mode
operator|->
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_mode_create_standard_connector_properties
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_property
modifier|*
name|edid
decl_stmt|;
name|struct
name|drm_property
modifier|*
name|dpms
decl_stmt|;
comment|/* 	 * Standard properties (apply to all connectors) 	 */
name|edid
operator|=
name|drm_property_create
argument_list|(
name|dev
argument_list|,
name|DRM_MODE_PROP_BLOB
operator||
name|DRM_MODE_PROP_IMMUTABLE
argument_list|,
literal|"EDID"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|edid_property
operator|=
name|edid
expr_stmt|;
name|dpms
operator|=
name|drm_property_create_enum
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"DPMS"
argument_list|,
name|drm_dpms_enum_list
argument_list|,
name|DRM_ARRAY_SIZE
argument_list|(
name|drm_dpms_enum_list
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|dpms_property
operator|=
name|dpms
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_create_dvi_i_properties - create DVI-I specific connector properties  * @dev: DRM device  *  * Called by a driver the first time a DVI-I connector is made.  */
end_comment

begin_function
name|int
name|drm_mode_create_dvi_i_properties
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_property
modifier|*
name|dvi_i_selector
decl_stmt|;
name|struct
name|drm_property
modifier|*
name|dvi_i_subconnector
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|mode_config
operator|.
name|dvi_i_select_subconnector_property
condition|)
return|return
literal|0
return|;
name|dvi_i_selector
operator|=
name|drm_property_create_enum
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"select subconnector"
argument_list|,
name|drm_dvi_i_select_enum_list
argument_list|,
name|DRM_ARRAY_SIZE
argument_list|(
name|drm_dvi_i_select_enum_list
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|dvi_i_select_subconnector_property
operator|=
name|dvi_i_selector
expr_stmt|;
name|dvi_i_subconnector
operator|=
name|drm_property_create_enum
argument_list|(
name|dev
argument_list|,
name|DRM_MODE_PROP_IMMUTABLE
argument_list|,
literal|"subconnector"
argument_list|,
name|drm_dvi_i_subconnector_enum_list
argument_list|,
name|DRM_ARRAY_SIZE
argument_list|(
name|drm_dvi_i_subconnector_enum_list
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|dvi_i_subconnector_property
operator|=
name|dvi_i_subconnector
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * drm_create_tv_properties - create TV specific connector properties  * @dev: DRM device  * @num_modes: number of different TV formats (modes) supported  * @modes: array of pointers to strings containing name of each format  *  * Called by a driver's TV initialization routine, this function creates  * the TV specific connector properties for a given device.  Caller is  * responsible for allocating a list of format names and passing them to  * this routine.  */
end_comment

begin_function
name|int
name|drm_mode_create_tv_properties
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|num_modes
parameter_list|,
name|char
modifier|*
name|modes
index|[]
parameter_list|)
block|{
name|struct
name|drm_property
modifier|*
name|tv_selector
decl_stmt|;
name|struct
name|drm_property
modifier|*
name|tv_subconnector
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|mode_config
operator|.
name|tv_select_subconnector_property
condition|)
return|return
literal|0
return|;
comment|/* 	 * Basic connector properties 	 */
name|tv_selector
operator|=
name|drm_property_create_enum
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"select subconnector"
argument_list|,
name|drm_tv_select_enum_list
argument_list|,
name|DRM_ARRAY_SIZE
argument_list|(
name|drm_tv_select_enum_list
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|tv_select_subconnector_property
operator|=
name|tv_selector
expr_stmt|;
name|tv_subconnector
operator|=
name|drm_property_create_enum
argument_list|(
name|dev
argument_list|,
name|DRM_MODE_PROP_IMMUTABLE
argument_list|,
literal|"subconnector"
argument_list|,
name|drm_tv_subconnector_enum_list
argument_list|,
name|DRM_ARRAY_SIZE
argument_list|(
name|drm_tv_subconnector_enum_list
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|tv_subconnector_property
operator|=
name|tv_subconnector
expr_stmt|;
comment|/* 	 * Other, TV specific properties: margins& TV modes. 	 */
name|dev
operator|->
name|mode_config
operator|.
name|tv_left_margin_property
operator|=
name|drm_property_create_range
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"left margin"
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|tv_right_margin_property
operator|=
name|drm_property_create_range
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"right margin"
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|tv_top_margin_property
operator|=
name|drm_property_create_range
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"top margin"
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|tv_bottom_margin_property
operator|=
name|drm_property_create_range
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"bottom margin"
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|tv_mode_property
operator|=
name|drm_property_create
argument_list|(
name|dev
argument_list|,
name|DRM_MODE_PROP_ENUM
argument_list|,
literal|"mode"
argument_list|,
name|num_modes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_modes
condition|;
name|i
operator|++
control|)
name|drm_property_add_enum
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|tv_mode_property
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|modes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|tv_brightness_property
operator|=
name|drm_property_create_range
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"brightness"
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|tv_contrast_property
operator|=
name|drm_property_create_range
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"contrast"
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|tv_flicker_reduction_property
operator|=
name|drm_property_create_range
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"flicker reduction"
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|tv_overscan_property
operator|=
name|drm_property_create_range
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"overscan"
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|tv_saturation_property
operator|=
name|drm_property_create_range
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"saturation"
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|tv_hue_property
operator|=
name|drm_property_create_range
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"hue"
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_create_scaling_mode_property - create scaling mode property  * @dev: DRM device  *  * Called by a driver the first time it's needed, must be attached to desired  * connectors.  */
end_comment

begin_function
name|int
name|drm_mode_create_scaling_mode_property
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_property
modifier|*
name|scaling_mode
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|mode_config
operator|.
name|scaling_mode_property
condition|)
return|return
literal|0
return|;
name|scaling_mode
operator|=
name|drm_property_create_enum
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"scaling mode"
argument_list|,
name|drm_scaling_mode_enum_list
argument_list|,
name|DRM_ARRAY_SIZE
argument_list|(
name|drm_scaling_mode_enum_list
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|scaling_mode_property
operator|=
name|scaling_mode
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_create_dithering_property - create dithering property  * @dev: DRM device  *  * Called by a driver the first time it's needed, must be attached to desired  * connectors.  */
end_comment

begin_function
name|int
name|drm_mode_create_dithering_property
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_property
modifier|*
name|dithering_mode
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|mode_config
operator|.
name|dithering_mode_property
condition|)
return|return
literal|0
return|;
name|dithering_mode
operator|=
name|drm_property_create_enum
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"dithering"
argument_list|,
name|drm_dithering_mode_enum_list
argument_list|,
name|DRM_ARRAY_SIZE
argument_list|(
name|drm_dithering_mode_enum_list
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|dithering_mode_property
operator|=
name|dithering_mode
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_create_dirty_property - create dirty property  * @dev: DRM device  *  * Called by a driver the first time it's needed, must be attached to desired  * connectors.  */
end_comment

begin_function
name|int
name|drm_mode_create_dirty_info_property
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_property
modifier|*
name|dirty_info
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|mode_config
operator|.
name|dirty_info_property
condition|)
return|return
literal|0
return|;
name|dirty_info
operator|=
name|drm_property_create_enum
argument_list|(
name|dev
argument_list|,
name|DRM_MODE_PROP_IMMUTABLE
argument_list|,
literal|"dirty"
argument_list|,
name|drm_dirty_info_enum_list
argument_list|,
name|DRM_ARRAY_SIZE
argument_list|(
name|drm_dirty_info_enum_list
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|dirty_info_property
operator|=
name|dirty_info
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_config_init - initialize DRM mode_configuration structure  * @dev: DRM device  *  * LOCKING:  * None, should happen single threaded at init time.  *  * Initialize @dev's mode_config structure, used for tracking the graphics  * configuration of @dev.  */
end_comment

begin_function
name|void
name|drm_mode_config_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|sx_init
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|,
literal|"kmslk"
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|fb_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|crtc_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|connector_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|encoder_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|property_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|property_blob_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|plane_list
argument_list|)
expr_stmt|;
name|drm_gem_names_init
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|crtc_names
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|drm_mode_create_standard_connector_properties
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
comment|/* Just to be sure */
name|dev
operator|->
name|mode_config
operator|.
name|num_fb
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|num_crtc
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|num_encoder
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_mode_group_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_mode_group
modifier|*
name|group
parameter_list|)
block|{
name|uint32_t
name|total_objects
init|=
literal|0
decl_stmt|;
name|total_objects
operator|+=
name|dev
operator|->
name|mode_config
operator|.
name|num_crtc
expr_stmt|;
name|total_objects
operator|+=
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
expr_stmt|;
name|total_objects
operator|+=
name|dev
operator|->
name|mode_config
operator|.
name|num_encoder
expr_stmt|;
name|group
operator|->
name|id_list
operator|=
name|malloc
argument_list|(
name|total_objects
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|group
operator|->
name|num_crtcs
operator|=
literal|0
expr_stmt|;
name|group
operator|->
name|num_connectors
operator|=
literal|0
expr_stmt|;
name|group
operator|->
name|num_encoders
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|drm_mode_group_init_legacy_group
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_mode_group
modifier|*
name|group
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|drm_mode_group_init
argument_list|(
name|dev
argument_list|,
name|group
argument_list|)
operator|)
condition|)
return|return
name|ret
return|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
name|group
operator|->
name|id_list
index|[
name|group
operator|->
name|num_crtcs
operator|++
index|]
operator|=
name|crtc
operator|->
name|base
operator|.
name|id
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
name|group
operator|->
name|id_list
index|[
name|group
operator|->
name|num_crtcs
operator|+
name|group
operator|->
name|num_encoders
operator|++
index|]
operator|=
name|encoder
operator|->
name|base
operator|.
name|id
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
name|group
operator|->
name|id_list
index|[
name|group
operator|->
name|num_crtcs
operator|+
name|group
operator|->
name|num_encoders
operator|+
name|group
operator|->
name|num_connectors
operator|++
index|]
operator|=
name|connector
operator|->
name|base
operator|.
name|id
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_config_cleanup - free up DRM mode_config info  * @dev: DRM device  *  * LOCKING:  * Caller must hold mode config lock.  *  * Free up all the connectors and CRTCs associated with this DRM device, then  * free up the framebuffers and associated buffer objects.  *  * FIXME: cleanup any dangling user buffer objects too  */
end_comment

begin_function
name|void
name|drm_mode_config_cleanup
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|,
modifier|*
name|ot
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|,
modifier|*
name|ct
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|,
modifier|*
name|enct
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|,
modifier|*
name|fbt
decl_stmt|;
name|struct
name|drm_property
modifier|*
name|property
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
name|struct
name|drm_plane
modifier|*
name|plane
decl_stmt|,
modifier|*
name|plt
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|encoder
argument_list|,
argument|enct
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
name|encoder
operator|->
name|funcs
operator|->
name|destroy
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|connector
argument_list|,
argument|ot
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
name|connector
operator|->
name|funcs
operator|->
name|destroy
argument_list|(
name|connector
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|property
argument_list|,
argument|pt
argument_list|,
argument|&dev->mode_config.property_list
argument_list|,
argument|head
argument_list|)
block|{
name|drm_property_destroy
argument_list|(
name|dev
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|fb
argument_list|,
argument|fbt
argument_list|,
argument|&dev->mode_config.fb_list
argument_list|,
argument|head
argument_list|)
block|{
name|fb
operator|->
name|funcs
operator|->
name|destroy
argument_list|(
name|fb
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|crtc
argument_list|,
argument|ct
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
name|crtc
operator|->
name|funcs
operator|->
name|destroy
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|plane
argument_list|,
argument|plt
argument_list|,
argument|&dev->mode_config.plane_list
argument_list|,
argument|head
argument_list|)
block|{
name|plane
operator|->
name|funcs
operator|->
name|destroy
argument_list|(
name|plane
argument_list|)
expr_stmt|;
block|}
name|drm_gem_names_fini
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|crtc_names
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_crtc_convert_to_umode - convert a drm_display_mode into a modeinfo  * @out: drm_mode_modeinfo struct to return to the user  * @in: drm_display_mode to use  *  * LOCKING:  * None.  *  * Convert a drm_display_mode into a drm_mode_modeinfo structure to return to  * the user.  */
end_comment

begin_function
specifier|static
name|void
name|drm_crtc_convert_to_umode
parameter_list|(
name|struct
name|drm_mode_modeinfo
modifier|*
name|out
parameter_list|,
specifier|const
name|struct
name|drm_display_mode
modifier|*
name|in
parameter_list|)
block|{
if|if
condition|(
name|in
operator|->
name|hdisplay
operator|>
name|USHRT_MAX
operator|||
name|in
operator|->
name|hsync_start
operator|>
name|USHRT_MAX
operator|||
name|in
operator|->
name|hsync_end
operator|>
name|USHRT_MAX
operator|||
name|in
operator|->
name|htotal
operator|>
name|USHRT_MAX
operator|||
name|in
operator|->
name|hskew
operator|>
name|USHRT_MAX
operator|||
name|in
operator|->
name|vdisplay
operator|>
name|USHRT_MAX
operator|||
name|in
operator|->
name|vsync_start
operator|>
name|USHRT_MAX
operator|||
name|in
operator|->
name|vsync_end
operator|>
name|USHRT_MAX
operator|||
name|in
operator|->
name|vtotal
operator|>
name|USHRT_MAX
operator|||
name|in
operator|->
name|vscan
operator|>
name|USHRT_MAX
condition|)
name|printf
argument_list|(
literal|"timing values too large for mode info\n"
argument_list|)
expr_stmt|;
name|out
operator|->
name|clock
operator|=
name|in
operator|->
name|clock
expr_stmt|;
name|out
operator|->
name|hdisplay
operator|=
name|in
operator|->
name|hdisplay
expr_stmt|;
name|out
operator|->
name|hsync_start
operator|=
name|in
operator|->
name|hsync_start
expr_stmt|;
name|out
operator|->
name|hsync_end
operator|=
name|in
operator|->
name|hsync_end
expr_stmt|;
name|out
operator|->
name|htotal
operator|=
name|in
operator|->
name|htotal
expr_stmt|;
name|out
operator|->
name|hskew
operator|=
name|in
operator|->
name|hskew
expr_stmt|;
name|out
operator|->
name|vdisplay
operator|=
name|in
operator|->
name|vdisplay
expr_stmt|;
name|out
operator|->
name|vsync_start
operator|=
name|in
operator|->
name|vsync_start
expr_stmt|;
name|out
operator|->
name|vsync_end
operator|=
name|in
operator|->
name|vsync_end
expr_stmt|;
name|out
operator|->
name|vtotal
operator|=
name|in
operator|->
name|vtotal
expr_stmt|;
name|out
operator|->
name|vscan
operator|=
name|in
operator|->
name|vscan
expr_stmt|;
name|out
operator|->
name|vrefresh
operator|=
name|in
operator|->
name|vrefresh
expr_stmt|;
name|out
operator|->
name|flags
operator|=
name|in
operator|->
name|flags
expr_stmt|;
name|out
operator|->
name|type
operator|=
name|in
operator|->
name|type
expr_stmt|;
name|strncpy
argument_list|(
name|out
operator|->
name|name
argument_list|,
name|in
operator|->
name|name
argument_list|,
name|DRM_DISPLAY_MODE_LEN
argument_list|)
expr_stmt|;
name|out
operator|->
name|name
index|[
name|DRM_DISPLAY_MODE_LEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_crtc_convert_to_umode - convert a modeinfo into a drm_display_mode  * @out: drm_display_mode to return to the user  * @in: drm_mode_modeinfo to use  *  * LOCKING:  * None.  *  * Convert a drm_mode_modeinfo into a drm_display_mode structure to return to  * the caller.  *  * RETURNS:  * Zero on success, errno on failure.  */
end_comment

begin_function
specifier|static
name|int
name|drm_crtc_convert_umode
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|out
parameter_list|,
specifier|const
name|struct
name|drm_mode_modeinfo
modifier|*
name|in
parameter_list|)
block|{
if|if
condition|(
name|in
operator|->
name|clock
operator|>
name|INT_MAX
operator|||
name|in
operator|->
name|vrefresh
operator|>
name|INT_MAX
condition|)
return|return
name|ERANGE
return|;
name|out
operator|->
name|clock
operator|=
name|in
operator|->
name|clock
expr_stmt|;
name|out
operator|->
name|hdisplay
operator|=
name|in
operator|->
name|hdisplay
expr_stmt|;
name|out
operator|->
name|hsync_start
operator|=
name|in
operator|->
name|hsync_start
expr_stmt|;
name|out
operator|->
name|hsync_end
operator|=
name|in
operator|->
name|hsync_end
expr_stmt|;
name|out
operator|->
name|htotal
operator|=
name|in
operator|->
name|htotal
expr_stmt|;
name|out
operator|->
name|hskew
operator|=
name|in
operator|->
name|hskew
expr_stmt|;
name|out
operator|->
name|vdisplay
operator|=
name|in
operator|->
name|vdisplay
expr_stmt|;
name|out
operator|->
name|vsync_start
operator|=
name|in
operator|->
name|vsync_start
expr_stmt|;
name|out
operator|->
name|vsync_end
operator|=
name|in
operator|->
name|vsync_end
expr_stmt|;
name|out
operator|->
name|vtotal
operator|=
name|in
operator|->
name|vtotal
expr_stmt|;
name|out
operator|->
name|vscan
operator|=
name|in
operator|->
name|vscan
expr_stmt|;
name|out
operator|->
name|vrefresh
operator|=
name|in
operator|->
name|vrefresh
expr_stmt|;
name|out
operator|->
name|flags
operator|=
name|in
operator|->
name|flags
expr_stmt|;
name|out
operator|->
name|type
operator|=
name|in
operator|->
name|type
expr_stmt|;
name|strncpy
argument_list|(
name|out
operator|->
name|name
argument_list|,
name|in
operator|->
name|name
argument_list|,
name|DRM_DISPLAY_MODE_LEN
argument_list|)
expr_stmt|;
name|out
operator|->
name|name
index|[
name|DRM_DISPLAY_MODE_LEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_getresources - get graphics configuration  * @inode: inode from the ioctl  * @filp: file * from the ioctl  * @cmd: cmd from ioctl  * @arg: arg from ioctl  *  * LOCKING:  * Takes mode config lock.  *  * Construct a set of configuration description structures and return  * them to the user, including CRTC, connector and framebuffer configuration.  *  * Called by the user via ioctl.  *  * RETURNS:  * Zero on success, errno on failure.  */
end_comment

begin_function
name|int
name|drm_mode_getresources
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_card_res
modifier|*
name|card_res
init|=
name|data
decl_stmt|;
name|struct
name|list_head
modifier|*
name|lh
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|connector_count
init|=
literal|0
decl_stmt|;
name|int
name|crtc_count
init|=
literal|0
decl_stmt|;
name|int
name|fb_count
init|=
literal|0
decl_stmt|;
name|int
name|encoder_count
init|=
literal|0
decl_stmt|;
name|int
name|copied
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|__user
modifier|*
name|fb_id
decl_stmt|;
name|uint32_t
name|__user
modifier|*
name|crtc_id
decl_stmt|;
name|uint32_t
name|__user
modifier|*
name|connector_id
decl_stmt|;
name|uint32_t
name|__user
modifier|*
name|encoder_id
decl_stmt|;
name|struct
name|drm_mode_group
modifier|*
name|mode_group
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
comment|/* 	 * For the non-control nodes we need to limit the list of resources 	 * by IDs in the group list for this node 	 */
name|list_for_each
argument_list|(
argument|lh
argument_list|,
argument|&file_priv->fbs
argument_list|)
name|fb_count
operator|++
expr_stmt|;
if|#
directive|if
literal|1
name|mode_group
operator|=
name|NULL
expr_stmt|;
comment|/* XXXKIB */
if|if
condition|(
literal|1
operator|||
name|file_priv
operator|->
name|master
condition|)
block|{
else|#
directive|else
name|mode_group
operator|=
operator|&
name|file_priv
operator|->
name|masterp
operator|->
name|minor
operator|->
name|mode_group
expr_stmt|;
if|if
condition|(
name|file_priv
operator|->
name|masterp
operator|->
name|minor
operator|->
name|type
operator|==
name|DRM_MINOR_CONTROL
condition|)
block|{
endif|#
directive|endif
name|list_for_each
argument_list|(
argument|lh
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|)
name|crtc_count
operator|++
expr_stmt|;
name|list_for_each
argument_list|(
argument|lh
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|)
name|connector_count
operator|++
expr_stmt|;
name|list_for_each
argument_list|(
argument|lh
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|)
name|encoder_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|crtc_count
operator|=
name|mode_group
operator|->
name|num_crtcs
expr_stmt|;
name|connector_count
operator|=
name|mode_group
operator|->
name|num_connectors
expr_stmt|;
name|encoder_count
operator|=
name|mode_group
operator|->
name|num_encoders
expr_stmt|;
block|}
name|card_res
operator|->
name|max_height
operator|=
name|dev
operator|->
name|mode_config
operator|.
name|max_height
expr_stmt|;
name|card_res
operator|->
name|min_height
operator|=
name|dev
operator|->
name|mode_config
operator|.
name|min_height
expr_stmt|;
name|card_res
operator|->
name|max_width
operator|=
name|dev
operator|->
name|mode_config
operator|.
name|max_width
expr_stmt|;
name|card_res
operator|->
name|min_width
operator|=
name|dev
operator|->
name|mode_config
operator|.
name|min_width
expr_stmt|;
comment|/* handle this in 4 parts */
comment|/* FBs */
if|if
condition|(
name|card_res
operator|->
name|count_fbs
operator|>=
name|fb_count
condition|)
block|{
name|copied
operator|=
literal|0
expr_stmt|;
name|fb_id
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|card_res
operator|->
name|fb_id_ptr
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|fb
argument_list|,
argument|&file_priv->fbs
argument_list|,
argument|filp_head
argument_list|)
block|{
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|fb
operator|->
name|base
operator|.
name|id
argument_list|,
name|fb_id
operator|+
name|copied
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|copied
operator|++
expr_stmt|;
block|}
block|}
name|card_res
operator|->
name|count_fbs
operator|=
name|fb_count
expr_stmt|;
comment|/* CRTCs */
if|if
condition|(
name|card_res
operator|->
name|count_crtcs
operator|>=
name|crtc_count
condition|)
block|{
name|copied
operator|=
literal|0
expr_stmt|;
name|crtc_id
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|card_res
operator|->
name|crtc_id_ptr
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
literal|1
operator|||
name|file_priv
operator|->
name|master
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|file_priv
operator|->
name|masterp
operator|->
name|minor
operator|->
name|type
operator|==
name|DRM_MINOR_CONTROL
condition|)
block|{
endif|#
directive|endif
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CRTC:%d]\n"
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|,
name|crtc_id
operator|+
name|copied
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|copied
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mode_group
operator|->
name|num_crtcs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|mode_group
operator|->
name|id_list
index|[
name|i
index|]
argument_list|,
name|crtc_id
operator|+
name|copied
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|copied
operator|++
expr_stmt|;
block|}
block|}
block|}
name|card_res
operator|->
name|count_crtcs
operator|=
name|crtc_count
expr_stmt|;
comment|/* Encoders */
if|if
condition|(
name|card_res
operator|->
name|count_encoders
operator|>=
name|encoder_count
condition|)
block|{
name|copied
operator|=
literal|0
expr_stmt|;
name|encoder_id
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|card_res
operator|->
name|encoder_id_ptr
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|file_priv
operator|->
name|master
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|file_priv
operator|->
name|masterp
operator|->
name|minor
operator|->
name|type
operator|==
name|DRM_MINOR_CONTROL
condition|)
block|{
endif|#
directive|endif
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"[ENCODER:%d:%s]\n"
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
name|encoder
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|encoder
operator|->
name|base
operator|.
name|id
argument_list|,
name|encoder_id
operator|+
name|copied
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|copied
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|mode_group
operator|->
name|num_crtcs
init|;
name|i
operator|<
name|mode_group
operator|->
name|num_crtcs
operator|+
name|mode_group
operator|->
name|num_encoders
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|mode_group
operator|->
name|id_list
index|[
name|i
index|]
argument_list|,
name|encoder_id
operator|+
name|copied
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|copied
operator|++
expr_stmt|;
block|}
block|}
block|}
name|card_res
operator|->
name|count_encoders
operator|=
name|encoder_count
expr_stmt|;
comment|/* Connectors */
if|if
condition|(
name|card_res
operator|->
name|count_connectors
operator|>=
name|connector_count
condition|)
block|{
name|copied
operator|=
literal|0
expr_stmt|;
name|connector_id
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|card_res
operator|->
name|connector_id_ptr
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|file_priv
operator|->
name|master
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|file_priv
operator|->
name|masterp
operator|->
name|minor
operator|->
name|type
operator|==
name|DRM_MINOR_CONTROL
condition|)
block|{
endif|#
directive|endif
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|connector_id
operator|+
name|copied
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|copied
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|start
init|=
name|mode_group
operator|->
name|num_crtcs
operator|+
name|mode_group
operator|->
name|num_encoders
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|start
operator|+
name|mode_group
operator|->
name|num_connectors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|mode_group
operator|->
name|id_list
index|[
name|i
index|]
argument_list|,
name|connector_id
operator|+
name|copied
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|copied
operator|++
expr_stmt|;
block|}
block|}
block|}
name|card_res
operator|->
name|count_connectors
operator|=
name|connector_count
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"CRTC[%d] CONNECTORS[%d] ENCODERS[%d]\n"
argument_list|,
name|card_res
operator|->
name|count_crtcs
argument_list|,
name|card_res
operator|->
name|count_connectors
argument_list|,
name|card_res
operator|->
name|count_encoders
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**  * drm_mode_getcrtc - get CRTC configuration  * @inode: inode from the ioctl  * @filp: file * from the ioctl  * @cmd: cmd from ioctl  * @arg: arg from ioctl  *  * LOCKING:  * Takes mode config lock.  *  * Construct a CRTC configuration structure to return to the user.  *  * Called by the user via ioctl.  *  * RETURNS:  * Zero on success, errno on failure.  */
name|int
name|drm_mode_getcrtc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_crtc
modifier|*
name|crtc_resp
init|=
name|data
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|crtc_resp
operator|->
name|crtc_id
argument_list|,
name|DRM_MODE_OBJECT_CRTC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|ret
operator|=
operator|(
name|EINVAL
operator|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|crtc
operator|=
name|obj_to_crtc
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|crtc_resp
operator|->
name|x
operator|=
name|crtc
operator|->
name|x
expr_stmt|;
name|crtc_resp
operator|->
name|y
operator|=
name|crtc
operator|->
name|y
expr_stmt|;
name|crtc_resp
operator|->
name|gamma_size
operator|=
name|crtc
operator|->
name|gamma_size
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|fb
condition|)
name|crtc_resp
operator|->
name|fb_id
operator|=
name|crtc
operator|->
name|fb
operator|->
name|base
operator|.
name|id
expr_stmt|;
else|else
name|crtc_resp
operator|->
name|fb_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|enabled
condition|)
block|{
name|drm_crtc_convert_to_umode
argument_list|(
operator|&
name|crtc_resp
operator|->
name|mode
argument_list|,
operator|&
name|crtc
operator|->
name|mode
argument_list|)
expr_stmt|;
name|crtc_resp
operator|->
name|mode_valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|crtc_resp
operator|->
name|mode_valid
operator|=
literal|0
expr_stmt|;
block|}
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**  * drm_mode_getconnector - get connector configuration  * @inode: inode from the ioctl  * @filp: file * from the ioctl  * @cmd: cmd from ioctl  * @arg: arg from ioctl  *  * LOCKING:  * Takes mode config lock.  *  * Construct a connector configuration structure to return to the user.  *  * Called by the user via ioctl.  *  * RETURNS:  * Zero on success, errno on failure.  */
name|int
name|drm_mode_getconnector
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_get_connector
modifier|*
name|out_resp
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|int
name|mode_count
init|=
literal|0
decl_stmt|;
name|int
name|props_count
init|=
literal|0
decl_stmt|;
name|int
name|encoders_count
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|copied
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|drm_mode_modeinfo
name|u_mode
decl_stmt|;
name|struct
name|drm_mode_modeinfo
name|__user
modifier|*
name|mode_ptr
decl_stmt|;
name|uint32_t
modifier|*
name|prop_ptr
decl_stmt|;
name|uint64_t
modifier|*
name|prop_values
decl_stmt|;
name|uint32_t
modifier|*
name|encoder_ptr
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memset
argument_list|(
operator|&
name|u_mode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|drm_mode_modeinfo
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:?]\n"
argument_list|,
name|out_resp
operator|->
name|connector_id
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|out_resp
operator|->
name|connector_id
argument_list|,
name|DRM_MODE_OBJECT_CONNECTOR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|connector
operator|=
name|obj_to_connector
argument_list|(
name|obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_PROPERTY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|property_ids
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|props_count
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_ENCODER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|encoders_count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out_resp
operator|->
name|count_modes
operator|==
literal|0
condition|)
block|{
name|connector
operator|->
name|funcs
operator|->
name|fill_modes
argument_list|(
name|connector
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|max_width
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|max_height
argument_list|)
expr_stmt|;
block|}
comment|/* delayed so we get modes regardless of pre-fill_modes state */
name|list_for_each_entry
argument_list|(
argument|mode
argument_list|,
argument|&connector->modes
argument_list|,
argument|head
argument_list|)
name|mode_count
operator|++
expr_stmt|;
name|out_resp
operator|->
name|connector_id
operator|=
name|connector
operator|->
name|base
operator|.
name|id
expr_stmt|;
name|out_resp
operator|->
name|connector_type
operator|=
name|connector
operator|->
name|connector_type
expr_stmt|;
name|out_resp
operator|->
name|connector_type_id
operator|=
name|connector
operator|->
name|connector_type_id
expr_stmt|;
name|out_resp
operator|->
name|mm_width
operator|=
name|connector
operator|->
name|display_info
operator|.
name|width_mm
expr_stmt|;
name|out_resp
operator|->
name|mm_height
operator|=
name|connector
operator|->
name|display_info
operator|.
name|height_mm
expr_stmt|;
name|out_resp
operator|->
name|subpixel
operator|=
name|connector
operator|->
name|display_info
operator|.
name|subpixel_order
expr_stmt|;
name|out_resp
operator|->
name|connection
operator|=
name|connector
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|connector
operator|->
name|encoder
condition|)
name|out_resp
operator|->
name|encoder_id
operator|=
name|connector
operator|->
name|encoder
operator|->
name|base
operator|.
name|id
expr_stmt|;
else|else
name|out_resp
operator|->
name|encoder_id
operator|=
literal|0
expr_stmt|;
comment|/* 	 * This ioctl is called twice, once to determine how much space is 	 * needed, and the 2nd time to fill it. 	 */
if|if
condition|(
operator|(
name|out_resp
operator|->
name|count_modes
operator|>=
name|mode_count
operator|)
operator|&&
name|mode_count
condition|)
block|{
name|copied
operator|=
literal|0
expr_stmt|;
name|mode_ptr
operator|=
operator|(
expr|struct
name|drm_mode_modeinfo
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|out_resp
operator|->
name|modes_ptr
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|mode
argument_list|,
argument|&connector->modes
argument_list|,
argument|head
argument_list|)
block|{
name|drm_crtc_convert_to_umode
argument_list|(
operator|&
name|u_mode
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|u_mode
argument_list|,
name|mode_ptr
operator|+
name|copied
argument_list|,
sizeof|sizeof
argument_list|(
name|u_mode
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|copied
operator|++
expr_stmt|;
block|}
block|}
name|out_resp
operator|->
name|count_modes
operator|=
name|mode_count
expr_stmt|;
if|if
condition|(
operator|(
name|out_resp
operator|->
name|count_props
operator|>=
name|props_count
operator|)
operator|&&
name|props_count
condition|)
block|{
name|copied
operator|=
literal|0
expr_stmt|;
name|prop_ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|out_resp
operator|->
name|props_ptr
argument_list|)
expr_stmt|;
name|prop_values
operator|=
operator|(
name|uint64_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|out_resp
operator|->
name|prop_values_ptr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_PROPERTY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|property_ids
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|connector
operator|->
name|property_ids
index|[
name|i
index|]
argument_list|,
name|prop_ptr
operator|+
name|copied
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|connector
operator|->
name|property_values
index|[
name|i
index|]
argument_list|,
name|prop_values
operator|+
name|copied
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|copied
operator|++
expr_stmt|;
block|}
block|}
block|}
name|out_resp
operator|->
name|count_props
operator|=
name|props_count
expr_stmt|;
if|if
condition|(
operator|(
name|out_resp
operator|->
name|count_encoders
operator|>=
name|encoders_count
operator|)
operator|&&
name|encoders_count
condition|)
block|{
name|copied
operator|=
literal|0
expr_stmt|;
name|encoder_ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|out_resp
operator|->
name|encoders_ptr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_ENCODER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
argument_list|,
name|encoder_ptr
operator|+
name|copied
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|copied
operator|++
expr_stmt|;
block|}
block|}
block|}
name|out_resp
operator|->
name|count_encoders
operator|=
name|encoders_count
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|int
name|drm_mode_getencoder
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_get_encoder
modifier|*
name|enc_resp
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|enc_resp
operator|->
name|encoder_id
argument_list|,
name|DRM_MODE_OBJECT_ENCODER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|encoder
operator|=
name|obj_to_encoder
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoder
operator|->
name|crtc
condition|)
name|enc_resp
operator|->
name|crtc_id
operator|=
name|encoder
operator|->
name|crtc
operator|->
name|base
operator|.
name|id
expr_stmt|;
else|else
name|enc_resp
operator|->
name|crtc_id
operator|=
literal|0
expr_stmt|;
name|enc_resp
operator|->
name|encoder_type
operator|=
name|encoder
operator|->
name|encoder_type
expr_stmt|;
name|enc_resp
operator|->
name|encoder_id
operator|=
name|encoder
operator|->
name|base
operator|.
name|id
expr_stmt|;
name|enc_resp
operator|->
name|possible_crtcs
operator|=
name|encoder
operator|->
name|possible_crtcs
expr_stmt|;
name|enc_resp
operator|->
name|possible_clones
operator|=
name|encoder
operator|->
name|possible_clones
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**  * drm_mode_getplane_res - get plane info  * @dev: DRM device  * @data: ioctl data  * @file_priv: DRM file info  *  * LOCKING:  * Takes mode config lock.  *  * Return an plane count and set of IDs.  */
name|int
name|drm_mode_getplane_res
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_get_plane_res
modifier|*
name|plane_resp
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|config
decl_stmt|;
name|struct
name|drm_plane
modifier|*
name|plane
decl_stmt|;
name|uint32_t
modifier|*
name|plane_ptr
decl_stmt|;
name|int
name|copied
init|=
literal|0
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|config
operator|=
operator|&
name|dev
operator|->
name|mode_config
expr_stmt|;
comment|/* 	 * This ioctl is called twice, once to determine how much space is 	 * needed, and the 2nd time to fill it. 	 */
if|if
condition|(
name|config
operator|->
name|num_plane
operator|&&
operator|(
name|plane_resp
operator|->
name|count_planes
operator|>=
name|config
operator|->
name|num_plane
operator|)
condition|)
block|{
name|plane_ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|plane_resp
operator|->
name|plane_id_ptr
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|plane
argument_list|,
argument|&config->plane_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|plane
operator|->
name|base
operator|.
name|id
argument_list|,
name|plane_ptr
operator|+
name|copied
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|copied
operator|++
expr_stmt|;
block|}
block|}
name|plane_resp
operator|->
name|count_planes
operator|=
name|config
operator|->
name|num_plane
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**  * drm_mode_getplane - get plane info  * @dev: DRM device  * @data: ioctl data  * @file_priv: DRM file info  *  * LOCKING:  * Takes mode config lock.  *  * Return plane info, including formats supported, gamma size, any  * current fb, etc.  */
name|int
name|drm_mode_getplane
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_get_plane
modifier|*
name|plane_resp
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_plane
modifier|*
name|plane
decl_stmt|;
name|uint32_t
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|plane_resp
operator|->
name|plane_id
argument_list|,
name|DRM_MODE_OBJECT_PLANE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|ret
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|plane
operator|=
name|obj_to_plane
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|plane
operator|->
name|crtc
condition|)
name|plane_resp
operator|->
name|crtc_id
operator|=
name|plane
operator|->
name|crtc
operator|->
name|base
operator|.
name|id
expr_stmt|;
else|else
name|plane_resp
operator|->
name|crtc_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|plane
operator|->
name|fb
condition|)
name|plane_resp
operator|->
name|fb_id
operator|=
name|plane
operator|->
name|fb
operator|->
name|base
operator|.
name|id
expr_stmt|;
else|else
name|plane_resp
operator|->
name|fb_id
operator|=
literal|0
expr_stmt|;
name|plane_resp
operator|->
name|plane_id
operator|=
name|plane
operator|->
name|base
operator|.
name|id
expr_stmt|;
name|plane_resp
operator|->
name|possible_crtcs
operator|=
name|plane
operator|->
name|possible_crtcs
expr_stmt|;
name|plane_resp
operator|->
name|gamma_size
operator|=
name|plane
operator|->
name|gamma_size
expr_stmt|;
comment|/* 	 * This ioctl is called twice, once to determine how much space is 	 * needed, and the 2nd time to fill it. 	 */
if|if
condition|(
name|plane
operator|->
name|format_count
operator|&&
operator|(
name|plane_resp
operator|->
name|count_format_types
operator|>=
name|plane
operator|->
name|format_count
operator|)
condition|)
block|{
name|format_ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|plane_resp
operator|->
name|format_type_ptr
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|format_ptr
argument_list|,
name|plane
operator|->
name|format_types
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|plane
operator|->
name|format_count
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|plane_resp
operator|->
name|count_format_types
operator|=
name|plane
operator|->
name|format_count
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**  * drm_mode_setplane - set up or tear down an plane  * @dev: DRM device  * @data: ioctl data*  * @file_prive: DRM file info  *  * LOCKING:  * Takes mode config lock.  *  * Set plane info, including placement, fb, scaling, and other factors.  * Or pass a NULL fb to disable.  */
name|int
name|drm_mode_setplane
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_set_plane
modifier|*
name|plane_req
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_plane
modifier|*
name|plane
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|fb_width
decl_stmt|,
name|fb_height
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
comment|/* 	 * First, find the plane, crtc, and fb objects.  If not available, 	 * we don't bother to call the driver. 	 */
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|plane_req
operator|->
name|plane_id
argument_list|,
name|DRM_MODE_OBJECT_PLANE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unknown plane ID %d\n"
argument_list|,
name|plane_req
operator|->
name|plane_id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|plane
operator|=
name|obj_to_plane
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|/* No fb means shut it down */
if|if
condition|(
operator|!
name|plane_req
operator|->
name|fb_id
condition|)
block|{
name|plane
operator|->
name|funcs
operator|->
name|disable_plane
argument_list|(
name|plane
argument_list|)
expr_stmt|;
name|plane
operator|->
name|crtc
operator|=
name|NULL
expr_stmt|;
name|plane
operator|->
name|fb
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|plane_req
operator|->
name|crtc_id
argument_list|,
name|DRM_MODE_OBJECT_CRTC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unknown crtc ID %d\n"
argument_list|,
name|plane_req
operator|->
name|crtc_id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|crtc
operator|=
name|obj_to_crtc
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|plane_req
operator|->
name|fb_id
argument_list|,
name|DRM_MODE_OBJECT_FB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unknown framebuffer ID %d\n"
argument_list|,
name|plane_req
operator|->
name|fb_id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fb
operator|=
name|obj_to_fb
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|/* Check whether this plane supports the fb pixel format. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|plane
operator|->
name|format_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fb
operator|->
name|pixel_format
operator|==
name|plane
operator|->
name|format_types
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|plane
operator|->
name|format_count
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Invalid pixel format 0x%08x\n"
argument_list|,
name|fb
operator|->
name|pixel_format
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fb_width
operator|=
name|fb
operator|->
name|width
operator|<<
literal|16
expr_stmt|;
name|fb_height
operator|=
name|fb
operator|->
name|height
operator|<<
literal|16
expr_stmt|;
comment|/* Make sure source coordinates are inside the fb. */
if|if
condition|(
name|plane_req
operator|->
name|src_w
operator|>
name|fb_width
operator|||
name|plane_req
operator|->
name|src_x
operator|>
name|fb_width
operator|-
name|plane_req
operator|->
name|src_w
operator|||
name|plane_req
operator|->
name|src_h
operator|>
name|fb_height
operator|||
name|plane_req
operator|->
name|src_y
operator|>
name|fb_height
operator|-
name|plane_req
operator|->
name|src_h
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Invalid source coordinates "
literal|"%u.%06ux%u.%06u+%u.%06u+%u.%06u\n"
argument_list|,
name|plane_req
operator|->
name|src_w
operator|>>
literal|16
argument_list|,
operator|(
operator|(
name|plane_req
operator|->
name|src_w
operator|&
literal|0xffff
operator|)
operator|*
literal|15625
operator|)
operator|>>
literal|10
argument_list|,
name|plane_req
operator|->
name|src_h
operator|>>
literal|16
argument_list|,
operator|(
operator|(
name|plane_req
operator|->
name|src_h
operator|&
literal|0xffff
operator|)
operator|*
literal|15625
operator|)
operator|>>
literal|10
argument_list|,
name|plane_req
operator|->
name|src_x
operator|>>
literal|16
argument_list|,
operator|(
operator|(
name|plane_req
operator|->
name|src_x
operator|&
literal|0xffff
operator|)
operator|*
literal|15625
operator|)
operator|>>
literal|10
argument_list|,
name|plane_req
operator|->
name|src_y
operator|>>
literal|16
argument_list|,
operator|(
operator|(
name|plane_req
operator|->
name|src_y
operator|&
literal|0xffff
operator|)
operator|*
literal|15625
operator|)
operator|>>
literal|10
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Give drivers some help against integer overflows */
if|if
condition|(
name|plane_req
operator|->
name|crtc_w
operator|>
name|INT_MAX
operator|||
name|plane_req
operator|->
name|crtc_x
operator|>
name|INT_MAX
operator|-
operator|(
name|int32_t
operator|)
name|plane_req
operator|->
name|crtc_w
operator|||
name|plane_req
operator|->
name|crtc_h
operator|>
name|INT_MAX
operator|||
name|plane_req
operator|->
name|crtc_y
operator|>
name|INT_MAX
operator|-
operator|(
name|int32_t
operator|)
name|plane_req
operator|->
name|crtc_h
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Invalid CRTC coordinates %ux%u+%d+%d\n"
argument_list|,
name|plane_req
operator|->
name|crtc_w
argument_list|,
name|plane_req
operator|->
name|crtc_h
argument_list|,
name|plane_req
operator|->
name|crtc_x
argument_list|,
name|plane_req
operator|->
name|crtc_y
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ERANGE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
operator|-
name|plane
operator|->
name|funcs
operator|->
name|update_plane
argument_list|(
name|plane
argument_list|,
name|crtc
argument_list|,
name|fb
argument_list|,
name|plane_req
operator|->
name|crtc_x
argument_list|,
name|plane_req
operator|->
name|crtc_y
argument_list|,
name|plane_req
operator|->
name|crtc_w
argument_list|,
name|plane_req
operator|->
name|crtc_h
argument_list|,
name|plane_req
operator|->
name|src_x
argument_list|,
name|plane_req
operator|->
name|src_y
argument_list|,
name|plane_req
operator|->
name|src_w
argument_list|,
name|plane_req
operator|->
name|src_h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|plane
operator|->
name|crtc
operator|=
name|crtc
expr_stmt|;
name|plane
operator|->
name|fb
operator|=
name|fb
expr_stmt|;
block|}
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**  * drm_mode_setcrtc - set CRTC configuration  * @inode: inode from the ioctl  * @filp: file * from the ioctl  * @cmd: cmd from ioctl  * @arg: arg from ioctl  *  * LOCKING:  * Takes mode config lock.  *  * Build a new CRTC configuration based on user request.  *  * Called by the user via ioctl.  *  * RETURNS:  * Zero on success, errno on failure.  */
name|int
name|drm_mode_setcrtc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_config
modifier|*
name|config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|drm_mode_crtc
modifier|*
name|crtc_req
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_connector
modifier|*
modifier|*
name|connector_set
init|=
name|NULL
decl_stmt|,
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_mode_set
name|set
decl_stmt|;
name|uint32_t
modifier|*
name|set_connectors_ptr
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* For some reason crtc x/y offsets are signed internally. */
if|if
condition|(
name|crtc_req
operator|->
name|x
operator|>
name|INT_MAX
operator|||
name|crtc_req
operator|->
name|y
operator|>
name|INT_MAX
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|crtc_req
operator|->
name|crtc_id
argument_list|,
name|DRM_MODE_OBJECT_CRTC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unknown CRTC ID %d\n"
argument_list|,
name|crtc_req
operator|->
name|crtc_id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|crtc
operator|=
name|obj_to_crtc
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CRTC:%d]\n"
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc_req
operator|->
name|mode_valid
condition|)
block|{
comment|/* If we have a mode we need a framebuffer. */
comment|/* If we pass -1, set the mode with the currently bound fb */
if|if
condition|(
name|crtc_req
operator|->
name|fb_id
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|crtc
operator|->
name|fb
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"CRTC doesn't have current FB\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fb
operator|=
name|crtc
operator|->
name|fb
expr_stmt|;
block|}
else|else
block|{
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|crtc_req
operator|->
name|fb_id
argument_list|,
name|DRM_MODE_OBJECT_FB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unknown FB ID%d\n"
argument_list|,
name|crtc_req
operator|->
name|fb_id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fb
operator|=
name|obj_to_fb
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
name|mode
operator|=
name|drm_mode_create
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|drm_crtc_convert_umode
argument_list|(
name|mode
argument_list|,
operator|&
name|crtc_req
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Invalid mode\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|drm_mode_set_crtcinfo
argument_list|(
name|mode
argument_list|,
name|CRTC_INTERLACE_HALVE_V
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|hdisplay
operator|>
name|fb
operator|->
name|width
operator|||
name|mode
operator|->
name|vdisplay
operator|>
name|fb
operator|->
name|height
operator|||
name|crtc_req
operator|->
name|x
operator|>
name|fb
operator|->
name|width
operator|-
name|mode
operator|->
name|hdisplay
operator|||
name|crtc_req
operator|->
name|y
operator|>
name|fb
operator|->
name|height
operator|-
name|mode
operator|->
name|vdisplay
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Invalid CRTC viewport %ux%u+%u+%u for fb size %ux%u.\n"
argument_list|,
name|mode
operator|->
name|hdisplay
argument_list|,
name|mode
operator|->
name|vdisplay
argument_list|,
name|crtc_req
operator|->
name|x
argument_list|,
name|crtc_req
operator|->
name|y
argument_list|,
name|fb
operator|->
name|width
argument_list|,
name|fb
operator|->
name|height
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|crtc_req
operator|->
name|count_connectors
operator|==
literal|0
operator|&&
name|mode
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Count connectors is 0 but mode set\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|crtc_req
operator|->
name|count_connectors
operator|>
literal|0
operator|&&
operator|(
operator|!
name|mode
operator|||
operator|!
name|fb
operator|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Count connectors is %d but no mode or fb set\n"
argument_list|,
name|crtc_req
operator|->
name|count_connectors
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|crtc_req
operator|->
name|count_connectors
operator|>
literal|0
condition|)
block|{
name|u32
name|out_id
decl_stmt|;
comment|/* Avoid unbounded kernel memory allocation */
if|if
condition|(
name|crtc_req
operator|->
name|count_connectors
operator|>
name|config
operator|->
name|num_connector
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|connector_set
operator|=
name|malloc
argument_list|(
name|crtc_req
operator|->
name|count_connectors
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_connector
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|crtc_req
operator|->
name|count_connectors
condition|;
name|i
operator|++
control|)
block|{
name|set_connectors_ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|crtc_req
operator|->
name|set_connectors_ptr
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|&
name|set_connectors_ptr
index|[
name|i
index|]
argument_list|,
operator|&
name|out_id
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|out_id
argument_list|,
name|DRM_MODE_OBJECT_CONNECTOR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Connector id %d unknown\n"
argument_list|,
name|out_id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|connector
operator|=
name|obj_to_connector
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
name|connector_set
index|[
name|i
index|]
operator|=
name|connector
expr_stmt|;
block|}
block|}
name|set
operator|.
name|crtc
operator|=
name|crtc
expr_stmt|;
name|set
operator|.
name|x
operator|=
name|crtc_req
operator|->
name|x
expr_stmt|;
name|set
operator|.
name|y
operator|=
name|crtc_req
operator|->
name|y
expr_stmt|;
name|set
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|set
operator|.
name|connectors
operator|=
name|connector_set
expr_stmt|;
name|set
operator|.
name|num_connectors
operator|=
name|crtc_req
operator|->
name|count_connectors
expr_stmt|;
name|set
operator|.
name|fb
operator|=
name|fb
expr_stmt|;
name|ret
operator|=
name|crtc
operator|->
name|funcs
operator|->
name|set_config
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|connector_set
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|drm_mode_destroy
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|int
name|drm_mode_cursor_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_cursor
modifier|*
name|req
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|req
operator|->
name|flags
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|req
operator|->
name|crtc_id
argument_list|,
name|DRM_MODE_OBJECT_CRTC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Unknown CRTC ID %d\n"
argument_list|,
name|req
operator|->
name|crtc_id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|crtc
operator|=
name|obj_to_crtc
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|flags
operator|&
name|DRM_MODE_CURSOR_BO
condition|)
block|{
if|if
condition|(
operator|!
name|crtc
operator|->
name|funcs
operator|->
name|cursor_set
condition|)
block|{
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Turns off the cursor if handle is 0 */
name|ret
operator|=
operator|-
name|crtc
operator|->
name|funcs
operator|->
name|cursor_set
argument_list|(
name|crtc
argument_list|,
name|file_priv
argument_list|,
name|req
operator|->
name|handle
argument_list|,
name|req
operator|->
name|width
argument_list|,
name|req
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|req
operator|->
name|flags
operator|&
name|DRM_MODE_CURSOR_MOVE
condition|)
block|{
if|if
condition|(
name|crtc
operator|->
name|funcs
operator|->
name|cursor_move
condition|)
block|{
name|ret
operator|=
name|crtc
operator|->
name|funcs
operator|->
name|cursor_move
argument_list|(
name|crtc
argument_list|,
name|req
operator|->
name|x
argument_list|,
name|req
operator|->
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* Original addfb only supported RGB formats, so figure out which one */
name|uint32_t
name|drm_mode_legacy_fb_format
parameter_list|(
name|uint32_t
name|bpp
parameter_list|,
name|uint32_t
name|depth
parameter_list|)
block|{
name|uint32_t
name|fmt
decl_stmt|;
switch|switch
condition|(
name|bpp
condition|)
block|{
case|case
literal|8
case|:
name|fmt
operator|=
name|DRM_FORMAT_RGB332
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|depth
operator|==
literal|15
condition|)
name|fmt
operator|=
name|DRM_FORMAT_XRGB1555
expr_stmt|;
else|else
name|fmt
operator|=
name|DRM_FORMAT_RGB565
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|fmt
operator|=
name|DRM_FORMAT_RGB888
expr_stmt|;
break|break;
case|case
literal|32
case|:
if|if
condition|(
name|depth
operator|==
literal|24
condition|)
name|fmt
operator|=
name|DRM_FORMAT_XRGB8888
expr_stmt|;
elseif|else
if|if
condition|(
name|depth
operator|==
literal|30
condition|)
name|fmt
operator|=
name|DRM_FORMAT_XRGB2101010
expr_stmt|;
else|else
name|fmt
operator|=
name|DRM_FORMAT_ARGB8888
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"bad bpp, assuming RGB24 pixel format\n"
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|DRM_FORMAT_XRGB8888
expr_stmt|;
break|break;
block|}
return|return
name|fmt
return|;
block|}
comment|/**  * drm_mode_addfb - add an FB to the graphics configuration  * @inode: inode from the ioctl  * @filp: file * from the ioctl  * @cmd: cmd from ioctl  * @arg: arg from ioctl  *  * LOCKING:  * Takes mode config lock.  *  * Add a new FB to the specified CRTC, given a user request.  *  * Called by the user via ioctl.  *  * RETURNS:  * Zero on success, errno on failure.  */
name|int
name|drm_mode_addfb
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_fb_cmd
modifier|*
name|or
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_fb_cmd2
name|r
init|=
block|{}
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* Use new struct with format internally */
name|r
operator|.
name|fb_id
operator|=
name|or
operator|->
name|fb_id
expr_stmt|;
name|r
operator|.
name|width
operator|=
name|or
operator|->
name|width
expr_stmt|;
name|r
operator|.
name|height
operator|=
name|or
operator|->
name|height
expr_stmt|;
name|r
operator|.
name|pitches
index|[
literal|0
index|]
operator|=
name|or
operator|->
name|pitch
expr_stmt|;
name|r
operator|.
name|pixel_format
operator|=
name|drm_mode_legacy_fb_format
argument_list|(
name|or
operator|->
name|bpp
argument_list|,
name|or
operator|->
name|depth
argument_list|)
expr_stmt|;
name|r
operator|.
name|handles
index|[
literal|0
index|]
operator|=
name|or
operator|->
name|handle
expr_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|config
operator|->
name|min_width
operator|>
name|r
operator|.
name|width
operator|)
operator|||
operator|(
name|r
operator|.
name|width
operator|>
name|config
operator|->
name|max_width
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|config
operator|->
name|min_height
operator|>
name|r
operator|.
name|height
operator|)
operator|||
operator|(
name|r
operator|.
name|height
operator|>
name|config
operator|->
name|max_height
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|dev
operator|->
name|mode_config
operator|.
name|funcs
operator|->
name|fb_create
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not create framebuffer, error %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|or
operator|->
name|fb_id
operator|=
name|fb
operator|->
name|base
operator|.
name|id
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|fb
operator|->
name|filp_head
argument_list|,
operator|&
name|file_priv
operator|->
name|fbs
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[FB:%d]\n"
argument_list|,
name|fb
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
specifier|static
name|int
name|format_check
parameter_list|(
name|struct
name|drm_mode_fb_cmd2
modifier|*
name|r
parameter_list|)
block|{
name|uint32_t
name|format
init|=
name|r
operator|->
name|pixel_format
operator|&
operator|~
name|DRM_FORMAT_BIG_ENDIAN
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|DRM_FORMAT_C8
case|:
case|case
name|DRM_FORMAT_RGB332
case|:
case|case
name|DRM_FORMAT_BGR233
case|:
case|case
name|DRM_FORMAT_XRGB4444
case|:
case|case
name|DRM_FORMAT_XBGR4444
case|:
case|case
name|DRM_FORMAT_RGBX4444
case|:
case|case
name|DRM_FORMAT_BGRX4444
case|:
case|case
name|DRM_FORMAT_ARGB4444
case|:
case|case
name|DRM_FORMAT_ABGR4444
case|:
case|case
name|DRM_FORMAT_RGBA4444
case|:
case|case
name|DRM_FORMAT_BGRA4444
case|:
case|case
name|DRM_FORMAT_XRGB1555
case|:
case|case
name|DRM_FORMAT_XBGR1555
case|:
case|case
name|DRM_FORMAT_RGBX5551
case|:
case|case
name|DRM_FORMAT_BGRX5551
case|:
case|case
name|DRM_FORMAT_ARGB1555
case|:
case|case
name|DRM_FORMAT_ABGR1555
case|:
case|case
name|DRM_FORMAT_RGBA5551
case|:
case|case
name|DRM_FORMAT_BGRA5551
case|:
case|case
name|DRM_FORMAT_RGB565
case|:
case|case
name|DRM_FORMAT_BGR565
case|:
case|case
name|DRM_FORMAT_RGB888
case|:
case|case
name|DRM_FORMAT_BGR888
case|:
case|case
name|DRM_FORMAT_XRGB8888
case|:
case|case
name|DRM_FORMAT_XBGR8888
case|:
case|case
name|DRM_FORMAT_RGBX8888
case|:
case|case
name|DRM_FORMAT_BGRX8888
case|:
case|case
name|DRM_FORMAT_ARGB8888
case|:
case|case
name|DRM_FORMAT_ABGR8888
case|:
case|case
name|DRM_FORMAT_RGBA8888
case|:
case|case
name|DRM_FORMAT_BGRA8888
case|:
case|case
name|DRM_FORMAT_XRGB2101010
case|:
case|case
name|DRM_FORMAT_XBGR2101010
case|:
case|case
name|DRM_FORMAT_RGBX1010102
case|:
case|case
name|DRM_FORMAT_BGRX1010102
case|:
case|case
name|DRM_FORMAT_ARGB2101010
case|:
case|case
name|DRM_FORMAT_ABGR2101010
case|:
case|case
name|DRM_FORMAT_RGBA1010102
case|:
case|case
name|DRM_FORMAT_BGRA1010102
case|:
case|case
name|DRM_FORMAT_YUYV
case|:
case|case
name|DRM_FORMAT_YVYU
case|:
case|case
name|DRM_FORMAT_UYVY
case|:
case|case
name|DRM_FORMAT_VYUY
case|:
case|case
name|DRM_FORMAT_AYUV
case|:
case|case
name|DRM_FORMAT_NV12
case|:
case|case
name|DRM_FORMAT_NV21
case|:
case|case
name|DRM_FORMAT_NV16
case|:
case|case
name|DRM_FORMAT_NV61
case|:
case|case
name|DRM_FORMAT_YUV410
case|:
case|case
name|DRM_FORMAT_YVU410
case|:
case|case
name|DRM_FORMAT_YUV411
case|:
case|case
name|DRM_FORMAT_YVU411
case|:
case|case
name|DRM_FORMAT_YUV420
case|:
case|case
name|DRM_FORMAT_YVU420
case|:
case|case
name|DRM_FORMAT_YUV422
case|:
case|case
name|DRM_FORMAT_YVU422
case|:
case|case
name|DRM_FORMAT_YUV444
case|:
case|case
name|DRM_FORMAT_YVU444
case|:
return|return
literal|0
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/**  * drm_mode_addfb2 - add an FB to the graphics configuration  * @inode: inode from the ioctl  * @filp: file * from the ioctl  * @cmd: cmd from ioctl  * @arg: arg from ioctl  *  * LOCKING:  * Takes mode config lock.  *  * Add a new FB to the specified CRTC, given a user request with format.  *  * Called by the user via ioctl.  *  * RETURNS:  * Zero on success, errno on failure.  */
name|int
name|drm_mode_addfb2
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_fb_cmd2
modifier|*
name|r
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_config
modifier|*
name|config
init|=
operator|&
name|dev
operator|->
name|mode_config
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|config
operator|->
name|min_width
operator|>
name|r
operator|->
name|width
operator|)
operator|||
operator|(
name|r
operator|->
name|width
operator|>
name|config
operator|->
name|max_width
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"bad framebuffer width %d, should be>= %d&&<= %d\n"
argument_list|,
name|r
operator|->
name|width
argument_list|,
name|config
operator|->
name|min_width
argument_list|,
name|config
operator|->
name|max_width
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|config
operator|->
name|min_height
operator|>
name|r
operator|->
name|height
operator|)
operator|||
operator|(
name|r
operator|->
name|height
operator|>
name|config
operator|->
name|max_height
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"bad framebuffer height %d, should be>= %d&&<= %d\n"
argument_list|,
name|r
operator|->
name|height
argument_list|,
name|config
operator|->
name|min_height
argument_list|,
name|config
operator|->
name|max_height
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ret
operator|=
name|format_check
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"bad framebuffer format 0x%08x\n"
argument_list|,
name|r
operator|->
name|pixel_format
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
comment|/* TODO check buffer is sufficiently large */
comment|/* TODO setup destructor callback */
name|ret
operator|=
operator|-
name|dev
operator|->
name|mode_config
operator|.
name|funcs
operator|->
name|fb_create
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|,
name|r
argument_list|,
operator|&
name|fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not create framebuffer, error %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|r
operator|->
name|fb_id
operator|=
name|fb
operator|->
name|base
operator|.
name|id
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|fb
operator|->
name|filp_head
argument_list|,
operator|&
name|file_priv
operator|->
name|fbs
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[FB:%d]\n"
argument_list|,
name|fb
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/**  * drm_mode_rmfb - remove an FB from the configuration  * @inode: inode from the ioctl  * @filp: file * from the ioctl  * @cmd: cmd from ioctl  * @arg: arg from ioctl  *  * LOCKING:  * Takes mode config lock.  *  * Remove the FB specified by the user.  *  * Called by the user via ioctl.  *  * RETURNS:  * Zero on success, errno on failure.  */
name|int
name|drm_mode_rmfb
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fbl
init|=
name|NULL
decl_stmt|;
name|uint32_t
modifier|*
name|id
init|=
name|data
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
operator|*
name|id
argument_list|,
name|DRM_MODE_OBJECT_FB
argument_list|)
expr_stmt|;
comment|/* TODO check that we really get a framebuffer back. */
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fb
operator|=
name|obj_to_fb
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|fbl
argument_list|,
argument|&file_priv->fbs
argument_list|,
argument|filp_head
argument_list|)
if|if
condition|(
name|fb
operator|==
name|fbl
condition|)
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* TODO release all crtc connected to the framebuffer */
comment|/* TODO unhock the destructor from the buffer object */
name|list_del
argument_list|(
operator|&
name|fb
operator|->
name|filp_head
argument_list|)
expr_stmt|;
name|fb
operator|->
name|funcs
operator|->
name|destroy
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**  * drm_mode_getfb - get FB info  * @inode: inode from the ioctl  * @filp: file * from the ioctl  * @cmd: cmd from ioctl  * @arg: arg from ioctl  *  * LOCKING:  * Takes mode config lock.  *  * Lookup the FB given its ID and return info about it.  *  * Called by the user via ioctl.  *  * RETURNS:  * Zero on success, errno on failure.  */
name|int
name|drm_mode_getfb
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_fb_cmd
modifier|*
name|r
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|r
operator|->
name|fb_id
argument_list|,
name|DRM_MODE_OBJECT_FB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fb
operator|=
name|obj_to_fb
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|r
operator|->
name|height
operator|=
name|fb
operator|->
name|height
expr_stmt|;
name|r
operator|->
name|width
operator|=
name|fb
operator|->
name|width
expr_stmt|;
name|r
operator|->
name|depth
operator|=
name|fb
operator|->
name|depth
expr_stmt|;
name|r
operator|->
name|bpp
operator|=
name|fb
operator|->
name|bits_per_pixel
expr_stmt|;
name|r
operator|->
name|pitch
operator|=
name|fb
operator|->
name|pitches
index|[
literal|0
index|]
expr_stmt|;
name|r
operator|->
name|handle
operator|=
literal|0
expr_stmt|;
name|fb
operator|->
name|funcs
operator|->
name|create_handle
argument_list|(
name|fb
argument_list|,
name|file_priv
argument_list|,
operator|&
name|r
operator|->
name|handle
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|int
name|drm_mode_dirtyfb_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_clip_rect
name|__user
modifier|*
name|clips_ptr
decl_stmt|;
name|struct
name|drm_clip_rect
modifier|*
name|clips
init|=
name|NULL
decl_stmt|;
name|struct
name|drm_mode_fb_dirty_cmd
modifier|*
name|r
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|;
name|unsigned
name|flags
decl_stmt|;
name|int
name|num_clips
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|r
operator|->
name|fb_id
argument_list|,
name|DRM_MODE_OBJECT_FB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_err1
goto|;
block|}
name|fb
operator|=
name|obj_to_fb
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|num_clips
operator|=
name|r
operator|->
name|num_clips
expr_stmt|;
name|clips_ptr
operator|=
operator|(
expr|struct
name|drm_clip_rect
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|r
operator|->
name|clips_ptr
expr_stmt|;
if|if
condition|(
operator|!
name|num_clips
operator|!=
operator|!
name|clips_ptr
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_err1
goto|;
block|}
name|flags
operator|=
name|DRM_MODE_FB_DIRTY_FLAGS
operator|&
name|r
operator|->
name|flags
expr_stmt|;
comment|/* If userspace annotates copy, clips must come in pairs */
if|if
condition|(
name|flags
operator|&
name|DRM_MODE_FB_DIRTY_ANNOTATE_COPY
operator|&&
operator|(
name|num_clips
operator|%
literal|2
operator|)
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_err1
goto|;
block|}
if|if
condition|(
name|num_clips
operator|&&
name|clips_ptr
condition|)
block|{
if|if
condition|(
name|num_clips
operator|<
literal|0
operator|||
name|num_clips
operator|>
name|DRM_MODE_FB_DIRTY_MAX_CLIPS
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_err1
goto|;
block|}
name|clips
operator|=
name|malloc
argument_list|(
name|num_clips
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|clips
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ret
operator|=
name|copyin
argument_list|(
name|clips_ptr
argument_list|,
name|clips
argument_list|,
name|num_clips
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|clips
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out_err2
goto|;
block|}
if|if
condition|(
name|fb
operator|->
name|funcs
operator|->
name|dirty
condition|)
block|{
name|ret
operator|=
operator|-
name|fb
operator|->
name|funcs
operator|->
name|dirty
argument_list|(
name|fb
argument_list|,
name|file_priv
argument_list|,
name|flags
argument_list|,
name|r
operator|->
name|color
argument_list|,
name|clips
argument_list|,
name|num_clips
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|ENOSYS
expr_stmt|;
goto|goto
name|out_err2
goto|;
block|}
name|out_err2
label|:
name|free
argument_list|(
name|clips
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|out_err1
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**  * drm_fb_release - remove and free the FBs on this file  * @filp: file * from the ioctl  *  * LOCKING:  * Takes mode config lock.  *  * Destroy all the FBs associated with @filp.  *  * Called by the user via ioctl.  *  * RETURNS:  * Zero on success, errno on failure.  */
name|void
name|drm_fb_release
parameter_list|(
name|struct
name|drm_file
modifier|*
name|priv
parameter_list|)
block|{
if|#
directive|if
literal|1
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|priv
operator|->
name|dev
decl_stmt|;
else|#
directive|else
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|priv
operator|->
name|minor
operator|->
name|dev
decl_stmt|;
endif|#
directive|endif
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|,
modifier|*
name|tfb
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|fb
argument_list|,
argument|tfb
argument_list|,
argument|&priv->fbs
argument_list|,
argument|filp_head
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|fb
operator|->
name|filp_head
argument_list|)
expr_stmt|;
name|fb
operator|->
name|funcs
operator|->
name|destroy
argument_list|(
name|fb
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
comment|/**  * drm_mode_attachmode - add a mode to the user mode list  * @dev: DRM device  * @connector: connector to add the mode to  * @mode: mode to add  *  * Add @mode to @connector's user mode list.  */
specifier|static
name|void
name|drm_mode_attachmode
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|list_add_tail
argument_list|(
operator|&
name|mode
operator|->
name|head
argument_list|,
operator|&
name|connector
operator|->
name|user_modes
argument_list|)
expr_stmt|;
block|}
name|int
name|drm_mode_attachmode_crtc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
specifier|const
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|dup_mode
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|DRM_LIST_HEAD
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|!
name|connector
operator|->
name|encoder
condition|)
continue|continue;
if|if
condition|(
name|connector
operator|->
name|encoder
operator|->
name|crtc
operator|==
name|crtc
condition|)
block|{
name|dup_mode
operator|=
name|drm_mode_duplicate
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dup_mode
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|list_add_tail
argument_list|(
operator|&
name|dup_mode
operator|->
name|head
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
block|}
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|!
name|connector
operator|->
name|encoder
condition|)
continue|continue;
if|if
condition|(
name|connector
operator|->
name|encoder
operator|->
name|crtc
operator|==
name|crtc
condition|)
name|list_move_tail
argument_list|(
name|list
operator|.
name|next
argument_list|,
operator|&
name|connector
operator|->
name|user_modes
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
operator|!
name|list_empty
argument_list|(
operator|&
name|list
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
name|list_for_each_entry_safe
argument_list|(
argument|dup_mode
argument_list|,
argument|next
argument_list|,
argument|&list
argument_list|,
argument|head
argument_list|)
name|drm_mode_destroy
argument_list|(
name|dev
argument_list|,
name|dup_mode
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
specifier|static
name|int
name|drm_mode_detachmode
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|match_mode
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|match_mode
argument_list|,
argument|t
argument_list|,
argument|&connector->user_modes
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|drm_mode_equal
argument_list|(
name|match_mode
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|match_mode
operator|->
name|head
argument_list|)
expr_stmt|;
name|drm_mode_destroy
argument_list|(
name|dev
argument_list|,
name|match_mode
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
return|return
name|ret
return|;
block|}
name|int
name|drm_mode_detachmode_crtc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
name|drm_mode_detachmode
argument_list|(
name|dev
argument_list|,
name|connector
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/**  * drm_fb_attachmode - Attach a user mode to an connector  * @inode: inode from the ioctl  * @filp: file * from the ioctl  * @cmd: cmd from ioctl  * @arg: arg from ioctl  *  * This attaches a user specified mode to an connector.  * Called by the user via ioctl.  *  * RETURNS:  * Zero on success, errno on failure.  */
name|int
name|drm_mode_attachmode_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_mode_cmd
modifier|*
name|mode_cmd
init|=
name|data
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_mode_modeinfo
modifier|*
name|umode
init|=
operator|&
name|mode_cmd
operator|->
name|mode
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|mode_cmd
operator|->
name|connector_id
argument_list|,
name|DRM_MODE_OBJECT_CONNECTOR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|connector
operator|=
name|obj_to_connector
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|mode
operator|=
name|drm_mode_create
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|drm_crtc_convert_umode
argument_list|(
name|mode
argument_list|,
name|umode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Invalid mode\n"
argument_list|)
expr_stmt|;
name|drm_mode_destroy
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|drm_mode_attachmode
argument_list|(
name|dev
argument_list|,
name|connector
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**  * drm_fb_detachmode - Detach a user specified mode from an connector  * @inode: inode from the ioctl  * @filp: file * from the ioctl  * @cmd: cmd from ioctl  * @arg: arg from ioctl  *  * Called by the user via ioctl.  *  * RETURNS:  * Zero on success, errno on failure.  */
name|int
name|drm_mode_detachmode_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_mode_mode_cmd
modifier|*
name|mode_cmd
init|=
name|data
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_display_mode
name|mode
decl_stmt|;
name|struct
name|drm_mode_modeinfo
modifier|*
name|umode
init|=
operator|&
name|mode_cmd
operator|->
name|mode
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|mode_cmd
operator|->
name|connector_id
argument_list|,
name|DRM_MODE_OBJECT_CONNECTOR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|connector
operator|=
name|obj_to_connector
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_crtc_convert_umode
argument_list|(
operator|&
name|mode
argument_list|,
name|umode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Invalid mode\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|drm_mode_detachmode
argument_list|(
name|dev
argument_list|,
name|connector
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|struct
name|drm_property
modifier|*
name|drm_property_create
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|num_values
parameter_list|)
block|{
name|struct
name|drm_property
modifier|*
name|property
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|property
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|drm_property
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_values
condition|)
block|{
name|property
operator|->
name|values
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|num_values
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|drm_mode_object_get
argument_list|(
name|dev
argument_list|,
operator|&
name|property
operator|->
name|base
argument_list|,
name|DRM_MODE_OBJECT_PROPERTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
name|property
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|property
operator|->
name|num_values
operator|=
name|num_values
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|property
operator|->
name|enum_blob_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|strncpy
argument_list|(
name|property
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|DRM_PROP_NAME_LEN
argument_list|)
expr_stmt|;
name|property
operator|->
name|name
index|[
name|DRM_PROP_NAME_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|list_add_tail
argument_list|(
operator|&
name|property
operator|->
name|head
argument_list|,
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|property_list
argument_list|)
expr_stmt|;
return|return
name|property
return|;
name|fail
label|:
name|free
argument_list|(
name|property
operator|->
name|values
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|property
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|struct
name|drm_property
modifier|*
name|drm_property_create_enum
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|struct
name|drm_prop_enum_list
modifier|*
name|props
parameter_list|,
name|int
name|num_values
parameter_list|)
block|{
name|struct
name|drm_property
modifier|*
name|property
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|flags
operator||=
name|DRM_MODE_PROP_ENUM
expr_stmt|;
name|property
operator|=
name|drm_property_create
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|,
name|name
argument_list|,
name|num_values
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|property
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_values
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|drm_property_add_enum
argument_list|(
name|property
argument_list|,
name|i
argument_list|,
name|props
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|props
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|drm_property_destroy
argument_list|(
name|dev
argument_list|,
name|property
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|property
return|;
block|}
name|struct
name|drm_property
modifier|*
name|drm_property_create_range
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|min
parameter_list|,
name|uint64_t
name|max
parameter_list|)
block|{
name|struct
name|drm_property
modifier|*
name|property
decl_stmt|;
name|flags
operator||=
name|DRM_MODE_PROP_RANGE
expr_stmt|;
name|property
operator|=
name|drm_property_create
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|,
name|name
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|property
condition|)
return|return
name|NULL
return|;
name|property
operator|->
name|values
index|[
literal|0
index|]
operator|=
name|min
expr_stmt|;
name|property
operator|->
name|values
index|[
literal|1
index|]
operator|=
name|max
expr_stmt|;
return|return
name|property
return|;
block|}
name|int
name|drm_property_add_enum
parameter_list|(
name|struct
name|drm_property
modifier|*
name|property
parameter_list|,
name|int
name|index
parameter_list|,
name|uint64_t
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|drm_property_enum
modifier|*
name|prop_enum
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|property
operator|->
name|flags
operator|&
name|DRM_MODE_PROP_ENUM
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|property
operator|->
name|enum_blob_list
argument_list|)
condition|)
block|{
name|list_for_each_entry
argument_list|(
argument|prop_enum
argument_list|,
argument|&property->enum_blob_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|prop_enum
operator|->
name|value
operator|==
name|value
condition|)
block|{
name|strncpy
argument_list|(
name|prop_enum
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|DRM_PROP_NAME_LEN
argument_list|)
expr_stmt|;
name|prop_enum
operator|->
name|name
index|[
name|DRM_PROP_NAME_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
name|prop_enum
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|drm_property_enum
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|prop_enum
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|DRM_PROP_NAME_LEN
argument_list|)
expr_stmt|;
name|prop_enum
operator|->
name|name
index|[
name|DRM_PROP_NAME_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|prop_enum
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|property
operator|->
name|values
index|[
name|index
index|]
operator|=
name|value
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|prop_enum
operator|->
name|head
argument_list|,
operator|&
name|property
operator|->
name|enum_blob_list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|void
name|drm_property_destroy
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_property
modifier|*
name|property
parameter_list|)
block|{
name|struct
name|drm_property_enum
modifier|*
name|prop_enum
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|prop_enum
argument_list|,
argument|pt
argument_list|,
argument|&property->enum_blob_list
argument_list|,
argument|head
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|prop_enum
operator|->
name|head
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prop_enum
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|property
operator|->
name|num_values
condition|)
name|free
argument_list|(
name|property
operator|->
name|values
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|drm_mode_object_put
argument_list|(
name|dev
argument_list|,
operator|&
name|property
operator|->
name|base
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|property
operator|->
name|head
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|property
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
name|int
name|drm_connector_attach_property
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_property
modifier|*
name|property
parameter_list|,
name|uint64_t
name|init_val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_PROPERTY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|property_ids
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|connector
operator|->
name|property_ids
index|[
name|i
index|]
operator|=
name|property
operator|->
name|base
operator|.
name|id
expr_stmt|;
name|connector
operator|->
name|property_values
index|[
name|i
index|]
operator|=
name|init_val
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|DRM_CONNECTOR_MAX_PROPERTY
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
name|int
name|drm_connector_property_set_value
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_property
modifier|*
name|property
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_PROPERTY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|property_ids
index|[
name|i
index|]
operator|==
name|property
operator|->
name|base
operator|.
name|id
condition|)
block|{
name|connector
operator|->
name|property_values
index|[
name|i
index|]
operator|=
name|value
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|DRM_CONNECTOR_MAX_PROPERTY
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
name|int
name|drm_connector_property_get_value
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_property
modifier|*
name|property
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_PROPERTY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|property_ids
index|[
name|i
index|]
operator|==
name|property
operator|->
name|base
operator|.
name|id
condition|)
block|{
operator|*
name|val
operator|=
name|connector
operator|->
name|property_values
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|DRM_CONNECTOR_MAX_PROPERTY
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
name|int
name|drm_mode_getproperty_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_mode_get_property
modifier|*
name|out_resp
init|=
name|data
decl_stmt|;
name|struct
name|drm_property
modifier|*
name|property
decl_stmt|;
name|int
name|enum_count
init|=
literal|0
decl_stmt|;
name|int
name|blob_count
init|=
literal|0
decl_stmt|;
name|int
name|value_count
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|int
name|copied
decl_stmt|;
name|struct
name|drm_property_enum
modifier|*
name|prop_enum
decl_stmt|;
name|struct
name|drm_mode_property_enum
name|__user
modifier|*
name|enum_ptr
decl_stmt|;
name|struct
name|drm_property_blob
modifier|*
name|prop_blob
decl_stmt|;
name|uint32_t
modifier|*
name|blob_id_ptr
decl_stmt|;
name|uint64_t
modifier|*
name|values_ptr
decl_stmt|;
name|uint32_t
modifier|*
name|blob_length_ptr
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|out_resp
operator|->
name|prop_id
argument_list|,
name|DRM_MODE_OBJECT_PROPERTY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|property
operator|=
name|obj_to_property
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|property
operator|->
name|flags
operator|&
name|DRM_MODE_PROP_ENUM
condition|)
block|{
name|list_for_each_entry
argument_list|(
argument|prop_enum
argument_list|,
argument|&property->enum_blob_list
argument_list|,
argument|head
argument_list|)
name|enum_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|property
operator|->
name|flags
operator|&
name|DRM_MODE_PROP_BLOB
condition|)
block|{
name|list_for_each_entry
argument_list|(
argument|prop_blob
argument_list|,
argument|&property->enum_blob_list
argument_list|,
argument|head
argument_list|)
name|blob_count
operator|++
expr_stmt|;
block|}
name|value_count
operator|=
name|property
operator|->
name|num_values
expr_stmt|;
name|strncpy
argument_list|(
name|out_resp
operator|->
name|name
argument_list|,
name|property
operator|->
name|name
argument_list|,
name|DRM_PROP_NAME_LEN
argument_list|)
expr_stmt|;
name|out_resp
operator|->
name|name
index|[
name|DRM_PROP_NAME_LEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|out_resp
operator|->
name|flags
operator|=
name|property
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|out_resp
operator|->
name|count_values
operator|>=
name|value_count
operator|)
operator|&&
name|value_count
condition|)
block|{
name|values_ptr
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|out_resp
operator|->
name|values_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|value_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|property
operator|->
name|values
index|[
name|i
index|]
argument_list|,
name|values_ptr
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|out_resp
operator|->
name|count_values
operator|=
name|value_count
expr_stmt|;
if|if
condition|(
name|property
operator|->
name|flags
operator|&
name|DRM_MODE_PROP_ENUM
condition|)
block|{
if|if
condition|(
operator|(
name|out_resp
operator|->
name|count_enum_blobs
operator|>=
name|enum_count
operator|)
operator|&&
name|enum_count
condition|)
block|{
name|copied
operator|=
literal|0
expr_stmt|;
name|enum_ptr
operator|=
operator|(
expr|struct
name|drm_mode_property_enum
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|out_resp
operator|->
name|enum_blob_ptr
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|prop_enum
argument_list|,
argument|&property->enum_blob_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|prop_enum
operator|->
name|value
argument_list|,
operator|&
name|enum_ptr
index|[
name|copied
index|]
operator|.
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|prop_enum
operator|->
name|name
argument_list|,
operator|&
name|enum_ptr
index|[
name|copied
index|]
operator|.
name|name
argument_list|,
name|DRM_PROP_NAME_LEN
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|copied
operator|++
expr_stmt|;
block|}
block|}
name|out_resp
operator|->
name|count_enum_blobs
operator|=
name|enum_count
expr_stmt|;
block|}
if|if
condition|(
name|property
operator|->
name|flags
operator|&
name|DRM_MODE_PROP_BLOB
condition|)
block|{
if|if
condition|(
operator|(
name|out_resp
operator|->
name|count_enum_blobs
operator|>=
name|blob_count
operator|)
operator|&&
name|blob_count
condition|)
block|{
name|copied
operator|=
literal|0
expr_stmt|;
name|blob_id_ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|out_resp
operator|->
name|enum_blob_ptr
expr_stmt|;
name|blob_length_ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|out_resp
operator|->
name|values_ptr
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|prop_blob
argument_list|,
argument|&property->enum_blob_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|prop_blob
operator|->
name|base
operator|.
name|id
argument_list|,
name|blob_id_ptr
operator|+
name|copied
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|prop_blob
operator|->
name|length
argument_list|,
name|blob_length_ptr
operator|+
name|copied
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|copied
operator|++
expr_stmt|;
block|}
block|}
name|out_resp
operator|->
name|count_enum_blobs
operator|=
name|blob_count
expr_stmt|;
block|}
name|done
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
specifier|static
name|struct
name|drm_property_blob
modifier|*
name|drm_property_create_blob
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|length
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|drm_property_blob
modifier|*
name|blob
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|length
operator|||
operator|!
name|data
condition|)
return|return
name|NULL
return|;
name|blob
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|drm_property_blob
argument_list|)
operator|+
name|length
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_mode_object_get
argument_list|(
name|dev
argument_list|,
operator|&
name|blob
operator|->
name|base
argument_list|,
name|DRM_MODE_OBJECT_BLOB
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|blob
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|blob
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|memcpy
argument_list|(
name|blob
operator|->
name|data
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|blob
operator|->
name|head
argument_list|,
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|property_blob_list
argument_list|)
expr_stmt|;
return|return
name|blob
return|;
block|}
specifier|static
name|void
name|drm_property_destroy_blob
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_property_blob
modifier|*
name|blob
parameter_list|)
block|{
name|drm_mode_object_put
argument_list|(
name|dev
argument_list|,
operator|&
name|blob
operator|->
name|base
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|blob
operator|->
name|head
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blob
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
name|int
name|drm_mode_getblob_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_mode_get_blob
modifier|*
name|out_resp
init|=
name|data
decl_stmt|;
name|struct
name|drm_property_blob
modifier|*
name|blob
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|blob_ptr
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|out_resp
operator|->
name|blob_id
argument_list|,
name|DRM_MODE_OBJECT_BLOB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|blob
operator|=
name|obj_to_blob
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_resp
operator|->
name|length
operator|==
name|blob
operator|->
name|length
condition|)
block|{
name|blob_ptr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|out_resp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|blob
operator|->
name|data
argument_list|,
name|blob_ptr
argument_list|,
name|blob
operator|->
name|length
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|out_resp
operator|->
name|length
operator|=
name|blob
operator|->
name|length
expr_stmt|;
name|done
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|int
name|drm_mode_connector_update_edid_property
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|edid
modifier|*
name|edid
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|connector
operator|->
name|edid_blob_ptr
condition|)
name|drm_property_destroy_blob
argument_list|(
name|dev
argument_list|,
name|connector
operator|->
name|edid_blob_ptr
argument_list|)
expr_stmt|;
comment|/* Delete edid, when there is none. */
if|if
condition|(
operator|!
name|edid
condition|)
block|{
name|connector
operator|->
name|edid_blob_ptr
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|drm_connector_property_set_value
argument_list|(
name|connector
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|edid_property
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|size
operator|=
name|EDID_LENGTH
operator|*
operator|(
literal|1
operator|+
name|edid
operator|->
name|extensions
operator|)
expr_stmt|;
name|connector
operator|->
name|edid_blob_ptr
operator|=
name|drm_property_create_blob
argument_list|(
name|connector
operator|->
name|dev
argument_list|,
name|size
argument_list|,
name|edid
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_connector_property_set_value
argument_list|(
name|connector
argument_list|,
name|dev
operator|->
name|mode_config
operator|.
name|edid_property
argument_list|,
name|connector
operator|->
name|edid_blob_ptr
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|int
name|drm_mode_connector_property_set_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_connector_set_property
modifier|*
name|out_resp
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_property
modifier|*
name|property
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|int
name|ret
init|=
operator|-
name|EINVAL
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|out_resp
operator|->
name|connector_id
argument_list|,
name|DRM_MODE_OBJECT_CONNECTOR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|connector
operator|=
name|obj_to_connector
argument_list|(
name|obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_PROPERTY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|property_ids
index|[
name|i
index|]
operator|==
name|out_resp
operator|->
name|prop_id
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|DRM_CONNECTOR_MAX_PROPERTY
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|out_resp
operator|->
name|prop_id
argument_list|,
name|DRM_MODE_OBJECT_PROPERTY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|property
operator|=
name|obj_to_property
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|property
operator|->
name|flags
operator|&
name|DRM_MODE_PROP_IMMUTABLE
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|property
operator|->
name|flags
operator|&
name|DRM_MODE_PROP_RANGE
condition|)
block|{
if|if
condition|(
name|out_resp
operator|->
name|value
operator|<
name|property
operator|->
name|values
index|[
literal|0
index|]
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|out_resp
operator|->
name|value
operator|>
name|property
operator|->
name|values
index|[
literal|1
index|]
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|property
operator|->
name|num_values
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|property
operator|->
name|values
index|[
name|i
index|]
operator|==
name|out_resp
operator|->
name|value
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
comment|/* Do DPMS ourselves */
if|if
condition|(
name|property
operator|==
name|connector
operator|->
name|dev
operator|->
name|mode_config
operator|.
name|dpms_property
condition|)
block|{
if|if
condition|(
name|connector
operator|->
name|funcs
operator|->
name|dpms
condition|)
call|(
modifier|*
name|connector
operator|->
name|funcs
operator|->
name|dpms
call|)
argument_list|(
name|connector
argument_list|,
operator|(
name|int
operator|)
name|out_resp
operator|->
name|value
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|connector
operator|->
name|funcs
operator|->
name|set_property
condition|)
name|ret
operator|=
name|connector
operator|->
name|funcs
operator|->
name|set_property
argument_list|(
name|connector
argument_list|,
name|property
argument_list|,
name|out_resp
operator|->
name|value
argument_list|)
expr_stmt|;
comment|/* store the property value if successful */
if|if
condition|(
operator|!
name|ret
condition|)
name|drm_connector_property_set_value
argument_list|(
name|connector
argument_list|,
name|property
argument_list|,
name|out_resp
operator|->
name|value
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|int
name|drm_mode_connector_attach_encoder
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_ENCODER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
operator|=
name|encoder
operator|->
name|base
operator|.
name|id
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
name|ENOMEM
return|;
block|}
name|void
name|drm_mode_connector_detach_encoder
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_CONNECTOR_MAX_ENCODER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
operator|==
name|encoder
operator|->
name|base
operator|.
name|id
condition|)
block|{
name|connector
operator|->
name|encoder_ids
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|connector
operator|->
name|encoder
operator|==
name|encoder
condition|)
name|connector
operator|->
name|encoder
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
name|int
name|drm_mode_crtc_set_gamma_size
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|gamma_size
parameter_list|)
block|{
name|crtc
operator|->
name|gamma_size
operator|=
name|gamma_size
expr_stmt|;
name|crtc
operator|->
name|gamma_store
operator|=
name|malloc
argument_list|(
name|gamma_size
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
literal|3
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|drm_mode_gamma_set_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_crtc_lut
modifier|*
name|crtc_lut
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|void
modifier|*
name|r_base
decl_stmt|,
modifier|*
name|g_base
decl_stmt|,
modifier|*
name|b_base
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|crtc_lut
operator|->
name|crtc_id
argument_list|,
name|DRM_MODE_OBJECT_CRTC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|crtc
operator|=
name|obj_to_crtc
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|/* memcpy into gamma store */
if|if
condition|(
name|crtc_lut
operator|->
name|gamma_size
operator|!=
name|crtc
operator|->
name|gamma_size
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|size
operator|=
name|crtc_lut
operator|->
name|gamma_size
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
expr_stmt|;
name|r_base
operator|=
name|crtc
operator|->
name|gamma_store
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|crtc_lut
operator|->
name|red
argument_list|,
name|r_base
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|g_base
operator|=
operator|(
name|char
operator|*
operator|)
name|r_base
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|crtc_lut
operator|->
name|green
argument_list|,
name|g_base
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|b_base
operator|=
operator|(
name|char
operator|*
operator|)
name|g_base
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|crtc_lut
operator|->
name|blue
argument_list|,
name|b_base
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|crtc
operator|->
name|funcs
operator|->
name|gamma_set
argument_list|(
name|crtc
argument_list|,
name|r_base
argument_list|,
name|g_base
argument_list|,
name|b_base
argument_list|,
literal|0
argument_list|,
name|crtc
operator|->
name|gamma_size
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|int
name|drm_mode_gamma_get_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_crtc_lut
modifier|*
name|crtc_lut
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|void
modifier|*
name|r_base
decl_stmt|,
modifier|*
name|g_base
decl_stmt|,
modifier|*
name|b_base
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_MODESET
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|crtc_lut
operator|->
name|crtc_id
argument_list|,
name|DRM_MODE_OBJECT_CRTC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|crtc
operator|=
name|obj_to_crtc
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|/* memcpy into gamma store */
if|if
condition|(
name|crtc_lut
operator|->
name|gamma_size
operator|!=
name|crtc
operator|->
name|gamma_size
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|size
operator|=
name|crtc_lut
operator|->
name|gamma_size
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
expr_stmt|;
name|r_base
operator|=
name|crtc
operator|->
name|gamma_store
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|r_base
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|crtc_lut
operator|->
name|red
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|g_base
operator|=
operator|(
name|char
operator|*
operator|)
name|r_base
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|g_base
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|crtc_lut
operator|->
name|green
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|b_base
operator|=
operator|(
name|char
operator|*
operator|)
name|g_base
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|b_base
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|crtc_lut
operator|->
name|blue
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
specifier|static
name|void
name|drm_kms_free
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|free
argument_list|(
name|arg
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
name|int
name|drm_mode_page_flip_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_crtc_page_flip
modifier|*
name|page_flip
init|=
name|data
decl_stmt|;
name|struct
name|drm_mode_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|fb
decl_stmt|;
name|struct
name|drm_pending_vblank_event
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
name|page_flip
operator|->
name|flags
operator|&
operator|~
name|DRM_MODE_PAGE_FLIP_FLAGS
operator|||
name|page_flip
operator|->
name|reserved
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|page_flip
operator|->
name|crtc_id
argument_list|,
name|DRM_MODE_OBJECT_CRTC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
goto|goto
name|out
goto|;
name|crtc
operator|=
name|obj_to_crtc
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|fb
operator|==
name|NULL
condition|)
block|{
comment|/* The framebuffer is currently unbound, presumably 		 * due to a hotplug event, that userspace has not 		 * yet discovered. 		 */
name|ret
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|crtc
operator|->
name|funcs
operator|->
name|page_flip
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|obj
operator|=
name|drm_mode_object_find
argument_list|(
name|dev
argument_list|,
name|page_flip
operator|->
name|fb_id
argument_list|,
name|DRM_MODE_OBJECT_FB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
goto|goto
name|out
goto|;
name|fb
operator|=
name|obj_to_fb
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
operator|>
name|fb
operator|->
name|width
operator|||
name|crtc
operator|->
name|mode
operator|.
name|vdisplay
operator|>
name|fb
operator|->
name|height
operator|||
name|crtc
operator|->
name|x
operator|>
name|fb
operator|->
name|width
operator|-
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
operator|||
name|crtc
operator|->
name|y
operator|>
name|fb
operator|->
name|height
operator|-
name|crtc
operator|->
name|mode
operator|.
name|vdisplay
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Invalid fb size %ux%u for CRTC viewport %ux%u+%d+%d.\n"
argument_list|,
name|fb
operator|->
name|width
argument_list|,
name|fb
operator|->
name|height
argument_list|,
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
argument_list|,
name|crtc
operator|->
name|mode
operator|.
name|vdisplay
argument_list|,
name|crtc
operator|->
name|x
argument_list|,
name|crtc
operator|->
name|y
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|page_flip
operator|->
name|flags
operator|&
name|DRM_MODE_PAGE_FLIP_EVENT
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_priv
operator|->
name|event_space
operator|<
sizeof|sizeof
name|e
operator|->
name|event
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|file_priv
operator|->
name|event_space
operator|-=
sizeof|sizeof
name|e
operator|->
name|event
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|e
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|e
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|base
operator|.
name|type
operator|=
name|DRM_EVENT_FLIP_COMPLETE
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|base
operator|.
name|length
operator|=
sizeof|sizeof
name|e
operator|->
name|event
expr_stmt|;
name|e
operator|->
name|event
operator|.
name|user_data
operator|=
name|page_flip
operator|->
name|user_data
expr_stmt|;
name|e
operator|->
name|base
operator|.
name|event
operator|=
operator|&
name|e
operator|->
name|event
operator|.
name|base
expr_stmt|;
name|e
operator|->
name|base
operator|.
name|file_priv
operator|=
name|file_priv
expr_stmt|;
name|e
operator|->
name|base
operator|.
name|destroy
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|drm_pending_event
operator|*
argument_list|)
operator|)
name|drm_kms_free
expr_stmt|;
block|}
name|ret
operator|=
operator|-
name|crtc
operator|->
name|funcs
operator|->
name|page_flip
argument_list|(
name|crtc
argument_list|,
name|fb
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|page_flip
operator|->
name|flags
operator|&
name|DRM_MODE_PAGE_FLIP_EVENT
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|file_priv
operator|->
name|event_space
operator|+=
sizeof|sizeof
name|e
operator|->
name|event
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|event_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_DRM
argument_list|,
literal|"page_flip_ioctl %d %d %d"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|,
name|page_flip
operator|->
name|crtc_id
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|void
name|drm_mode_config_reset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
if|if
condition|(
name|crtc
operator|->
name|funcs
operator|->
name|reset
condition|)
name|crtc
operator|->
name|funcs
operator|->
name|reset
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
if|if
condition|(
name|encoder
operator|->
name|funcs
operator|->
name|reset
condition|)
name|encoder
operator|->
name|funcs
operator|->
name|reset
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
if|if
condition|(
name|connector
operator|->
name|funcs
operator|->
name|reset
condition|)
name|connector
operator|->
name|funcs
operator|->
name|reset
argument_list|(
name|connector
argument_list|)
expr_stmt|;
block|}
name|int
name|drm_mode_create_dumb_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_create_dumb
modifier|*
name|args
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|driver
operator|->
name|dumb_create
condition|)
return|return
operator|-
name|ENOTSUP
return|;
return|return
name|dev
operator|->
name|driver
operator|->
name|dumb_create
argument_list|(
name|file_priv
argument_list|,
name|dev
argument_list|,
name|args
argument_list|)
return|;
block|}
name|int
name|drm_mode_mmap_dumb_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_map_dumb
modifier|*
name|args
init|=
name|data
decl_stmt|;
comment|/* call driver ioctl to get mmap offset */
if|if
condition|(
operator|!
name|dev
operator|->
name|driver
operator|->
name|dumb_map_offset
condition|)
return|return
operator|-
name|ENOTSUP
return|;
return|return
name|dev
operator|->
name|driver
operator|->
name|dumb_map_offset
argument_list|(
name|file_priv
argument_list|,
name|dev
argument_list|,
name|args
operator|->
name|handle
argument_list|,
operator|&
name|args
operator|->
name|offset
argument_list|)
return|;
block|}
name|int
name|drm_mode_destroy_dumb_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_mode_destroy_dumb
modifier|*
name|args
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|driver
operator|->
name|dumb_destroy
condition|)
return|return
operator|-
name|ENOTSUP
return|;
return|return
name|dev
operator|->
name|driver
operator|->
name|dumb_destroy
argument_list|(
name|file_priv
argument_list|,
name|dev
argument_list|,
name|args
operator|->
name|handle
argument_list|)
return|;
block|}
comment|/*  * Just need to support RGB formats here for compat with code that doesn't  * use pixel formats directly yet.  */
name|void
name|drm_fb_get_bpp_depth
parameter_list|(
name|uint32_t
name|format
parameter_list|,
name|unsigned
name|int
modifier|*
name|depth
parameter_list|,
name|int
modifier|*
name|bpp
parameter_list|)
block|{
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|DRM_FORMAT_RGB332
case|:
case|case
name|DRM_FORMAT_BGR233
case|:
operator|*
name|depth
operator|=
literal|8
expr_stmt|;
operator|*
name|bpp
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_XRGB1555
case|:
case|case
name|DRM_FORMAT_XBGR1555
case|:
case|case
name|DRM_FORMAT_RGBX5551
case|:
case|case
name|DRM_FORMAT_BGRX5551
case|:
case|case
name|DRM_FORMAT_ARGB1555
case|:
case|case
name|DRM_FORMAT_ABGR1555
case|:
case|case
name|DRM_FORMAT_RGBA5551
case|:
case|case
name|DRM_FORMAT_BGRA5551
case|:
operator|*
name|depth
operator|=
literal|15
expr_stmt|;
operator|*
name|bpp
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_RGB565
case|:
case|case
name|DRM_FORMAT_BGR565
case|:
operator|*
name|depth
operator|=
literal|16
expr_stmt|;
operator|*
name|bpp
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_RGB888
case|:
case|case
name|DRM_FORMAT_BGR888
case|:
operator|*
name|depth
operator|=
literal|24
expr_stmt|;
operator|*
name|bpp
operator|=
literal|24
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_XRGB8888
case|:
case|case
name|DRM_FORMAT_XBGR8888
case|:
case|case
name|DRM_FORMAT_RGBX8888
case|:
case|case
name|DRM_FORMAT_BGRX8888
case|:
operator|*
name|depth
operator|=
literal|24
expr_stmt|;
operator|*
name|bpp
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_XRGB2101010
case|:
case|case
name|DRM_FORMAT_XBGR2101010
case|:
case|case
name|DRM_FORMAT_RGBX1010102
case|:
case|case
name|DRM_FORMAT_BGRX1010102
case|:
case|case
name|DRM_FORMAT_ARGB2101010
case|:
case|case
name|DRM_FORMAT_ABGR2101010
case|:
case|case
name|DRM_FORMAT_RGBA1010102
case|:
case|case
name|DRM_FORMAT_BGRA1010102
case|:
operator|*
name|depth
operator|=
literal|30
expr_stmt|;
operator|*
name|bpp
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|DRM_FORMAT_ARGB8888
case|:
case|case
name|DRM_FORMAT_ABGR8888
case|:
case|case
name|DRM_FORMAT_RGBA8888
case|:
case|case
name|DRM_FORMAT_BGRA8888
case|:
operator|*
name|depth
operator|=
literal|32
expr_stmt|;
operator|*
name|bpp
operator|=
literal|32
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG_KMS
argument_list|(
literal|"unsupported pixel format\n"
argument_list|)
expr_stmt|;
operator|*
name|depth
operator|=
literal|0
expr_stmt|;
operator|*
name|bpp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

