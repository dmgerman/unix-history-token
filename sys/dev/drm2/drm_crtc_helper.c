begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006-2008 Intel Corporation  * Copyright (c) 2007 Dave Airlie<airlied@linux.ie>  *  * DRM core CRTC related functions  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting documentation, and  * that the name of the copyright holders not be used in advertising or  * publicity pertaining to distribution of the software without specific,  * written prior permission.  The copyright holders make no representations  * about the suitability of this software for any purpose.  It is provided "as  * is" without express or implied warranty.  *  * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO  * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR  * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  * OF THIS SOFTWARE.  *  * Authors:  *      Keith Packard  *	Eric Anholt<eric@anholt.net>  *      Dave Airlie<airlied@linux.ie>  *      Jesse Barnes<jesse.barnes@intel.com>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_fourcc.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc_helper.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_fb_helper.h>
end_include

begin_function
name|bool
name|drm_fetch_cmdline_mode_from_kenv
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_cmdline_mode
modifier|*
name|cmdline_mode
parameter_list|)
block|{
name|char
modifier|*
name|tun_var_name
decl_stmt|,
modifier|*
name|tun_mode
decl_stmt|;
specifier|static
specifier|const
name|char
name|tun_prefix
index|[]
init|=
literal|"drm_mode."
decl_stmt|;
name|bool
name|res
decl_stmt|;
name|res
operator|=
name|false
expr_stmt|;
name|tun_var_name
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tun_prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tun_var_name
argument_list|,
name|tun_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tun_var_name
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
name|tun_mode
operator|=
name|kern_getenv
argument_list|(
name|tun_var_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tun_mode
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
name|drm_mode_parse_command_line_for_connector
argument_list|(
name|tun_mode
argument_list|,
name|connector
argument_list|,
name|cmdline_mode
argument_list|)
expr_stmt|;
name|freeenv
argument_list|(
name|tun_mode
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tun_var_name
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|bool
name|drm_kms_helper_poll
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|drm_mode_validate_flag
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|flags
operator|==
operator|(
name|DRM_MODE_FLAG_DBLSCAN
operator||
name|DRM_MODE_FLAG_INTERLACE
operator|)
condition|)
return|return;
name|list_for_each_entry_safe
argument_list|(
argument|mode
argument_list|,
argument|t
argument_list|,
argument|&connector->modes
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
operator|)
condition|)
name|mode
operator|->
name|status
operator|=
name|MODE_NO_INTERLACE
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_DBLSCAN
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|DRM_MODE_FLAG_DBLSCAN
operator|)
condition|)
name|mode
operator|->
name|status
operator|=
name|MODE_NO_DBLESCAN
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * drm_helper_probe_single_connector_modes - get complete set of display modes  * @dev: DRM device  * @maxX: max width for modes  * @maxY: max height for modes  *  * LOCKING:  * Caller must hold mode config lock.  *  * Based on @dev's mode_config layout, scan all the connectors and try to detect  * modes on them.  Modes will first be added to the connector's probed_modes  * list, then culled (based on validity and the @maxX, @maxY parameters) and  * put into the normal modes list.  *  * Intended to be used either at bootup time or when major configuration  * changes have occurred.  *  * FIXME: take into account monitor limits  *  * RETURNS:  * Number of modes found on @connector.  */
end_comment

begin_function
name|int
name|drm_helper_probe_single_connector_modes
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|uint32_t
name|maxX
parameter_list|,
name|uint32_t
name|maxY
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|connector
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|struct
name|drm_connector_helper_funcs
modifier|*
name|connector_funcs
init|=
name|connector
operator|->
name|helper_private
decl_stmt|;
name|struct
name|drm_cmdline_mode
name|cmdline_mode
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|mode_flags
init|=
literal|0
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set all modes to the unverified state */
name|list_for_each_entry_safe
argument_list|(
argument|mode
argument_list|,
argument|t
argument_list|,
argument|&connector->modes
argument_list|,
argument|head
argument_list|)
name|mode
operator|->
name|status
operator|=
name|MODE_UNVERIFIED
expr_stmt|;
if|if
condition|(
name|connector
operator|->
name|force
condition|)
block|{
if|if
condition|(
name|connector
operator|->
name|force
operator|==
name|DRM_FORCE_ON
condition|)
name|connector
operator|->
name|status
operator|=
name|connector_status_connected
expr_stmt|;
else|else
name|connector
operator|->
name|status
operator|=
name|connector_status_disconnected
expr_stmt|;
if|if
condition|(
name|connector
operator|->
name|funcs
operator|->
name|force
condition|)
name|connector
operator|->
name|funcs
operator|->
name|force
argument_list|(
name|connector
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|connector
operator|->
name|status
operator|=
name|connector
operator|->
name|funcs
operator|->
name|detect
argument_list|(
name|connector
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|drm_kms_helper_poll_enable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|connector
operator|->
name|status
operator|==
name|connector_status_disconnected
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s] disconnected\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
name|drm_mode_connector_update_edid_property
argument_list|(
name|connector
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|prune
goto|;
block|}
name|count
operator|=
call|(
modifier|*
name|connector_funcs
operator|->
name|get_modes
call|)
argument_list|(
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|drm_fetch_cmdline_mode_from_kenv
argument_list|(
name|connector
argument_list|,
operator|&
name|cmdline_mode
argument_list|)
condition|)
block|{
name|mode
operator|=
name|drm_mode_create_from_cmdline_mode
argument_list|(
name|dev
argument_list|,
operator|&
name|cmdline_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|NULL
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s] found manual override "
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|drm_mode_probed_add
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|DRM_ERROR
argument_list|(
literal|"[CONNECTOR:%d:%s] manual override mode: parse error\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|connector
operator|->
name|status
operator|==
name|connector_status_connected
condition|)
name|count
operator|=
name|drm_add_modes_noedid
argument_list|(
name|connector
argument_list|,
literal|1024
argument_list|,
literal|768
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
goto|goto
name|prune
goto|;
name|drm_mode_connector_list_update
argument_list|(
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxX
operator|&&
name|maxY
condition|)
name|drm_mode_validate_size
argument_list|(
name|dev
argument_list|,
operator|&
name|connector
operator|->
name|modes
argument_list|,
name|maxX
argument_list|,
name|maxY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|connector
operator|->
name|interlace_allowed
condition|)
name|mode_flags
operator||=
name|DRM_MODE_FLAG_INTERLACE
expr_stmt|;
if|if
condition|(
name|connector
operator|->
name|doublescan_allowed
condition|)
name|mode_flags
operator||=
name|DRM_MODE_FLAG_DBLSCAN
expr_stmt|;
name|drm_mode_validate_flag
argument_list|(
name|connector
argument_list|,
name|mode_flags
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|mode
argument_list|,
argument|t
argument_list|,
argument|&connector->modes
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|mode
operator|->
name|status
operator|==
name|MODE_OK
condition|)
name|mode
operator|->
name|status
operator|=
name|connector_funcs
operator|->
name|mode_valid
argument_list|(
name|connector
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|prune
label|:
name|drm_mode_prune_invalid
argument_list|(
name|dev
argument_list|,
operator|&
name|connector
operator|->
name|modes
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|connector
operator|->
name|modes
argument_list|)
condition|)
return|return
literal|0
return|;
name|drm_mode_sort
argument_list|(
operator|&
name|connector
operator|->
name|modes
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s] probed modes :\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|mode
argument_list|,
argument|t
argument_list|,
argument|&connector->modes
argument_list|,
argument|head
argument_list|)
block|{
name|mode
operator|->
name|vrefresh
operator|=
name|drm_mode_vrefresh
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|drm_mode_set_crtcinfo
argument_list|(
name|mode
argument_list|,
name|CRTC_INTERLACE_HALVE_V
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/**  * drm_helper_encoder_in_use - check if a given encoder is in use  * @encoder: encoder to check  *  * LOCKING:  * Caller must hold mode config lock.  *  * Walk @encoders's DRM device's mode_config and see if it's in use.  *  * RETURNS:  * True if @encoder is part of the mode_config, false otherwise.  */
end_comment

begin_function
name|bool
name|drm_helper_encoder_in_use
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
if|if
condition|(
name|connector
operator|->
name|encoder
operator|==
name|encoder
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/**  * drm_helper_crtc_in_use - check if a given CRTC is in a mode_config  * @crtc: CRTC to check  *  * LOCKING:  * Caller must hold mode config lock.  *  * Walk @crtc's DRM device's mode_config and see if it's in use.  *  * RETURNS:  * True if @crtc is part of the mode_config, false otherwise.  */
end_comment

begin_function
name|bool
name|drm_helper_crtc_in_use
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
comment|/* FIXME: Locking around list access? */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
if|if
condition|(
name|encoder
operator|->
name|crtc
operator|==
name|crtc
operator|&&
name|drm_helper_encoder_in_use
argument_list|(
name|encoder
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drm_encoder_disable
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
init|=
name|encoder
operator|->
name|helper_private
decl_stmt|;
if|if
condition|(
name|encoder_funcs
operator|->
name|disable
condition|)
call|(
modifier|*
name|encoder_funcs
operator|->
name|disable
call|)
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|encoder_funcs
operator|->
name|dpms
call|)
argument_list|(
name|encoder
argument_list|,
name|DRM_MODE_DPMS_OFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_helper_disable_unused_functions - disable unused objects  * @dev: DRM device  *  * LOCKING:  * Caller must hold mode config lock.  *  * If an connector or CRTC isn't part of @dev's mode_config, it can be disabled  * by calling its dpms function, which should power it off.  */
end_comment

begin_function
name|void
name|drm_helper_disable_unused_functions
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|!
name|connector
operator|->
name|encoder
condition|)
continue|continue;
if|if
condition|(
name|connector
operator|->
name|status
operator|==
name|connector_status_disconnected
condition|)
name|connector
operator|->
name|encoder
operator|=
name|NULL
expr_stmt|;
block|}
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|!
name|drm_helper_encoder_in_use
argument_list|(
name|encoder
argument_list|)
condition|)
block|{
name|drm_encoder_disable
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
comment|/* disconnector encoder from any connector */
name|encoder
operator|->
name|crtc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
name|struct
name|drm_crtc_helper_funcs
modifier|*
name|crtc_funcs
init|=
name|crtc
operator|->
name|helper_private
decl_stmt|;
name|crtc
operator|->
name|enabled
operator|=
name|drm_helper_crtc_in_use
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|crtc
operator|->
name|enabled
condition|)
block|{
if|if
condition|(
name|crtc_funcs
operator|->
name|disable
condition|)
call|(
modifier|*
name|crtc_funcs
operator|->
name|disable
call|)
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|crtc_funcs
operator|->
name|dpms
call|)
argument_list|(
name|crtc
argument_list|,
name|DRM_MODE_DPMS_OFF
argument_list|)
expr_stmt|;
name|crtc
operator|->
name|fb
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * drm_encoder_crtc_ok - can a given crtc drive a given encoder?  * @encoder: encoder to test  * @crtc: crtc to test  *  * Return false if @encoder can't be driven by @crtc, true otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|drm_encoder_crtc_ok
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|,
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|tmp
decl_stmt|;
name|int
name|crtc_mask
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|crtc
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"checking null crtc?\n"
argument_list|)
expr_stmt|;
name|dev
operator|=
name|crtc
operator|->
name|dev
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|tmp
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|tmp
operator|==
name|crtc
condition|)
break|break;
name|crtc_mask
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|encoder
operator|->
name|possible_crtcs
operator|&
name|crtc_mask
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * Check the CRTC we're going to map each output to vs. its current  * CRTC.  If they don't match, we have to disable the output and the CRTC  * since the driver will have to re-route things.  */
end_comment

begin_function
specifier|static
name|void
name|drm_crtc_prepare_encoders
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
name|encoder_funcs
operator|=
name|encoder
operator|->
name|helper_private
expr_stmt|;
comment|/* Disable unused encoders */
if|if
condition|(
name|encoder
operator|->
name|crtc
operator|==
name|NULL
condition|)
name|drm_encoder_disable
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
comment|/* Disable encoders whose CRTC is about to change */
if|if
condition|(
name|encoder_funcs
operator|->
name|get_crtc
operator|&&
name|encoder
operator|->
name|crtc
operator|!=
call|(
modifier|*
name|encoder_funcs
operator|->
name|get_crtc
call|)
argument_list|(
name|encoder
argument_list|)
condition|)
name|drm_encoder_disable
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * drm_crtc_set_mode - set a mode  * @crtc: CRTC to program  * @mode: mode to use  * @x: width of mode  * @y: height of mode  *  * LOCKING:  * Caller must hold mode config lock.  *  * Try to set @mode on @crtc.  Give @crtc and its associated connectors a chance  * to fixup or reject the mode prior to trying to set it.  *  * RETURNS:  * True if the mode was set successfully, or false otherwise.  */
end_comment

begin_function
name|bool
name|drm_crtc_helper_set_mode
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
decl_stmt|,
name|saved_mode
decl_stmt|,
name|saved_hwmode
decl_stmt|;
name|struct
name|drm_crtc_helper_funcs
modifier|*
name|crtc_funcs
init|=
name|crtc
operator|->
name|helper_private
decl_stmt|;
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
decl_stmt|;
name|int
name|saved_x
decl_stmt|,
name|saved_y
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|bool
name|ret
init|=
name|true
decl_stmt|;
name|crtc
operator|->
name|enabled
operator|=
name|drm_helper_crtc_in_use
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|crtc
operator|->
name|enabled
condition|)
return|return
name|true
return|;
name|adjusted_mode
operator|=
name|drm_mode_duplicate
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adjusted_mode
condition|)
return|return
name|false
return|;
name|saved_hwmode
operator|=
name|crtc
operator|->
name|hwmode
expr_stmt|;
name|saved_mode
operator|=
name|crtc
operator|->
name|mode
expr_stmt|;
name|saved_x
operator|=
name|crtc
operator|->
name|x
expr_stmt|;
name|saved_y
operator|=
name|crtc
operator|->
name|y
expr_stmt|;
comment|/* Update crtc values up front so the driver can rely on them for mode 	 * setting. 	 */
name|crtc
operator|->
name|mode
operator|=
operator|*
name|mode
expr_stmt|;
name|crtc
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|crtc
operator|->
name|y
operator|=
name|y
expr_stmt|;
comment|/* Pass our mode to the connectors and the CRTC to give them a chance to 	 * adjust it according to limitations or connector properties, and also 	 * a chance to reject the mode entirely. 	 */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
name|encoder_funcs
operator|=
name|encoder
operator|->
name|helper_private
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ret
operator|=
name|encoder_funcs
operator|->
name|mode_fixup
argument_list|(
name|encoder
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|ret
operator|=
name|crtc_funcs
operator|->
name|mode_fixup
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CRTC:%d]\n"
argument_list|,
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
comment|/* Prepare the encoders and CRTCs before setting the mode. */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
name|encoder_funcs
operator|=
name|encoder
operator|->
name|helper_private
expr_stmt|;
comment|/* Disable the encoders as the first thing we do. */
name|encoder_funcs
operator|->
name|prepare
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
name|drm_crtc_prepare_encoders
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|crtc_funcs
operator|->
name|prepare
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* Set up the DPLL and any encoders state that needs to adjust or depend 	 * on the DPLL. 	 */
name|ret
operator|=
operator|!
name|crtc_funcs
operator|->
name|mode_set
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|old_fb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
goto|goto
name|done
goto|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[ENCODER:%d:%s] set [MODE:%d:%s]\n"
argument_list|,
name|encoder
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_encoder_name
argument_list|(
name|encoder
argument_list|)
argument_list|,
name|mode
operator|->
name|base
operator|.
name|id
argument_list|,
name|mode
operator|->
name|name
argument_list|)
expr_stmt|;
name|encoder_funcs
operator|=
name|encoder
operator|->
name|helper_private
expr_stmt|;
name|encoder_funcs
operator|->
name|mode_set
argument_list|(
name|encoder
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
block|}
comment|/* Now enable the clocks, plane, pipe, and connectors that we set up. */
name|crtc_funcs
operator|->
name|commit
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
name|encoder_funcs
operator|=
name|encoder
operator|->
name|helper_private
expr_stmt|;
name|encoder_funcs
operator|->
name|commit
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
comment|/* Store real post-adjustment hardware mode. */
name|crtc
operator|->
name|hwmode
operator|=
operator|*
name|adjusted_mode
expr_stmt|;
comment|/* Calculate and store various constants which 	 * are later needed by vblank and swap-completion 	 * timestamping. They are derived from true hwmode. 	 */
name|drm_calc_timestamping_constants
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* FIXME: add subpixel order */
name|done
label|:
name|drm_mode_destroy
argument_list|(
name|dev
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|crtc
operator|->
name|hwmode
operator|=
name|saved_hwmode
expr_stmt|;
name|crtc
operator|->
name|mode
operator|=
name|saved_mode
expr_stmt|;
name|crtc
operator|->
name|x
operator|=
name|saved_x
expr_stmt|;
name|crtc
operator|->
name|y
operator|=
name|saved_y
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_crtc_helper_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
comment|/* Decouple all encoders and their attached connectors from this crtc */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|connector
operator|->
name|encoder
operator|!=
name|encoder
condition|)
continue|continue;
name|connector
operator|->
name|encoder
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|drm_helper_disable_unused_functions
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * drm_crtc_helper_set_config - set a new config from userspace  * @crtc: CRTC to setup  * @crtc_info: user provided configuration  * @new_mode: new mode to set  * @connector_set: set of connectors for the new config  * @fb: new framebuffer  *  * LOCKING:  * Caller must hold mode config lock.  *  * Setup a new configuration, provided by the user in @crtc_info, and enable  * it.  *  * RETURNS:  * Zero. (FIXME)  */
end_comment

begin_function
name|int
name|drm_crtc_helper_set_config
parameter_list|(
name|struct
name|drm_mode_set
modifier|*
name|set
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|save_crtcs
decl_stmt|,
modifier|*
name|new_crtc
decl_stmt|,
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|save_encoders
decl_stmt|,
modifier|*
name|new_encoder
decl_stmt|,
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
init|=
name|NULL
decl_stmt|;
name|bool
name|mode_changed
init|=
name|false
decl_stmt|;
comment|/* if true do a full mode set */
name|bool
name|fb_changed
init|=
name|false
decl_stmt|;
comment|/* if true and !mode_changed just do a flip */
name|struct
name|drm_connector
modifier|*
name|save_connectors
decl_stmt|,
modifier|*
name|connector
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|ro
decl_stmt|,
name|fail
init|=
literal|0
decl_stmt|;
name|struct
name|drm_crtc_helper_funcs
modifier|*
name|crtc_funcs
decl_stmt|;
name|struct
name|drm_mode_set
name|save_set
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|set
operator|->
name|crtc
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|set
operator|->
name|crtc
operator|->
name|helper_private
condition|)
return|return
operator|-
name|EINVAL
return|;
name|crtc_funcs
operator|=
name|set
operator|->
name|crtc
operator|->
name|helper_private
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|->
name|mode
condition|)
name|set
operator|->
name|fb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|fb
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CRTC:%d] [FB:%d] #connectors=%d (x y) (%i %i)\n"
argument_list|,
name|set
operator|->
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|,
name|set
operator|->
name|fb
operator|->
name|base
operator|.
name|id
argument_list|,
operator|(
name|int
operator|)
name|set
operator|->
name|num_connectors
argument_list|,
name|set
operator|->
name|x
argument_list|,
name|set
operator|->
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CRTC:%d] [NOFB]\n"
argument_list|,
name|set
operator|->
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
return|return
name|drm_crtc_helper_disable
argument_list|(
name|set
operator|->
name|crtc
argument_list|)
return|;
block|}
name|dev
operator|=
name|set
operator|->
name|crtc
operator|->
name|dev
expr_stmt|;
comment|/* Allocate space for the backup of all (non-pointer) crtc, encoder and 	 * connector data. */
name|save_crtcs
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_crtc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_crtc
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|save_encoders
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_encoder
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_encoder
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|save_connectors
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|mode_config
operator|.
name|num_connector
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_connector
argument_list|)
argument_list|,
name|DRM_MEM_KMS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Copy data. Note that driver private data is not affected. 	 * Should anything bad happen only the expected state is 	 * restored, not the drivers personal bookkeeping. 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
name|save_crtcs
index|[
name|count
operator|++
index|]
operator|=
operator|*
name|crtc
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
name|save_encoders
index|[
name|count
operator|++
index|]
operator|=
operator|*
name|encoder
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
name|save_connectors
index|[
name|count
operator|++
index|]
operator|=
operator|*
name|connector
expr_stmt|;
block|}
name|save_set
operator|.
name|crtc
operator|=
name|set
operator|->
name|crtc
expr_stmt|;
name|save_set
operator|.
name|mode
operator|=
operator|&
name|set
operator|->
name|crtc
operator|->
name|mode
expr_stmt|;
name|save_set
operator|.
name|x
operator|=
name|set
operator|->
name|crtc
operator|->
name|x
expr_stmt|;
name|save_set
operator|.
name|y
operator|=
name|set
operator|->
name|crtc
operator|->
name|y
expr_stmt|;
name|save_set
operator|.
name|fb
operator|=
name|set
operator|->
name|crtc
operator|->
name|fb
expr_stmt|;
comment|/* We should be able to check here if the fb has the same properties 	 * and then just flip_or_move it */
if|if
condition|(
name|set
operator|->
name|crtc
operator|->
name|fb
operator|!=
name|set
operator|->
name|fb
condition|)
block|{
comment|/* If we have no fb then treat it as a full mode set */
if|if
condition|(
name|set
operator|->
name|crtc
operator|->
name|fb
operator|==
name|NULL
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"crtc has no fb, full mode set\n"
argument_list|)
expr_stmt|;
name|mode_changed
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|set
operator|->
name|fb
operator|==
name|NULL
condition|)
block|{
name|mode_changed
operator|=
name|true
expr_stmt|;
block|}
else|else
name|fb_changed
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|set
operator|->
name|x
operator|!=
name|set
operator|->
name|crtc
operator|->
name|x
operator|||
name|set
operator|->
name|y
operator|!=
name|set
operator|->
name|crtc
operator|->
name|y
condition|)
name|fb_changed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|mode
operator|&&
operator|!
name|drm_mode_equal
argument_list|(
name|set
operator|->
name|mode
argument_list|,
operator|&
name|set
operator|->
name|crtc
operator|->
name|mode
argument_list|)
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"modes are different, full mode set\n"
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
operator|&
name|set
operator|->
name|crtc
operator|->
name|mode
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|set
operator|->
name|mode
argument_list|)
expr_stmt|;
name|mode_changed
operator|=
name|true
expr_stmt|;
block|}
comment|/* a) traverse passed in connector list and get encoders for them */
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
name|struct
name|drm_connector_helper_funcs
modifier|*
name|connector_funcs
init|=
name|connector
operator|->
name|helper_private
decl_stmt|;
name|new_encoder
operator|=
name|connector
operator|->
name|encoder
expr_stmt|;
for|for
control|(
name|ro
operator|=
literal|0
init|;
name|ro
operator|<
name|set
operator|->
name|num_connectors
condition|;
name|ro
operator|++
control|)
block|{
if|if
condition|(
name|set
operator|->
name|connectors
index|[
name|ro
index|]
operator|==
name|connector
condition|)
block|{
name|new_encoder
operator|=
name|connector_funcs
operator|->
name|best_encoder
argument_list|(
name|connector
argument_list|)
expr_stmt|;
comment|/* if we can't get an encoder for a connector 				   we are setting now - then fail */
if|if
condition|(
name|new_encoder
operator|==
name|NULL
condition|)
comment|/* don't break so fail path works correct */
name|fail
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|new_encoder
operator|!=
name|connector
operator|->
name|encoder
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"encoder changed, full mode switch\n"
argument_list|)
expr_stmt|;
name|mode_changed
operator|=
name|true
expr_stmt|;
comment|/* If the encoder is reused for another connector, then 			 * the appropriate crtc will be set later. 			 */
if|if
condition|(
name|connector
operator|->
name|encoder
condition|)
name|connector
operator|->
name|encoder
operator|->
name|crtc
operator|=
name|NULL
expr_stmt|;
name|connector
operator|->
name|encoder
operator|=
name|new_encoder
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fail
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|!
name|connector
operator|->
name|encoder
condition|)
continue|continue;
if|if
condition|(
name|connector
operator|->
name|encoder
operator|->
name|crtc
operator|==
name|set
operator|->
name|crtc
condition|)
name|new_crtc
operator|=
name|NULL
expr_stmt|;
else|else
name|new_crtc
operator|=
name|connector
operator|->
name|encoder
operator|->
name|crtc
expr_stmt|;
for|for
control|(
name|ro
operator|=
literal|0
init|;
name|ro
operator|<
name|set
operator|->
name|num_connectors
condition|;
name|ro
operator|++
control|)
block|{
if|if
condition|(
name|set
operator|->
name|connectors
index|[
name|ro
index|]
operator|==
name|connector
condition|)
name|new_crtc
operator|=
name|set
operator|->
name|crtc
expr_stmt|;
block|}
comment|/* Make sure the new CRTC will work with the encoder */
if|if
condition|(
name|new_crtc
operator|&&
operator|!
name|drm_encoder_crtc_ok
argument_list|(
name|connector
operator|->
name|encoder
argument_list|,
name|new_crtc
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|new_crtc
operator|!=
name|connector
operator|->
name|encoder
operator|->
name|crtc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"crtc changed, full mode switch\n"
argument_list|)
expr_stmt|;
name|mode_changed
operator|=
name|true
expr_stmt|;
name|connector
operator|->
name|encoder
operator|->
name|crtc
operator|=
name|new_crtc
expr_stmt|;
block|}
if|if
condition|(
name|new_crtc
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s] to [CRTC:%d]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|new_crtc
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s] to [NOCRTC]\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* mode_set_base is not a required function */
if|if
condition|(
name|fb_changed
operator|&&
operator|!
name|crtc_funcs
operator|->
name|mode_set_base
condition|)
name|mode_changed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|mode_changed
condition|)
block|{
name|set
operator|->
name|crtc
operator|->
name|enabled
operator|=
name|drm_helper_crtc_in_use
argument_list|(
name|set
operator|->
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|crtc
operator|->
name|enabled
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"attempting to set mode from"
literal|" userspace\n"
argument_list|)
expr_stmt|;
name|drm_mode_debug_printmodeline
argument_list|(
name|set
operator|->
name|mode
argument_list|)
expr_stmt|;
name|old_fb
operator|=
name|set
operator|->
name|crtc
operator|->
name|fb
expr_stmt|;
name|set
operator|->
name|crtc
operator|->
name|fb
operator|=
name|set
operator|->
name|fb
expr_stmt|;
if|if
condition|(
operator|!
name|drm_crtc_helper_set_mode
argument_list|(
name|set
operator|->
name|crtc
argument_list|,
name|set
operator|->
name|mode
argument_list|,
name|set
operator|->
name|x
argument_list|,
name|set
operator|->
name|y
argument_list|,
name|old_fb
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to set mode on [CRTC:%d]\n"
argument_list|,
name|set
operator|->
name|crtc
operator|->
name|base
operator|.
name|id
argument_list|)
expr_stmt|;
name|set
operator|->
name|crtc
operator|->
name|fb
operator|=
name|old_fb
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|DRM_DEBUG_KMS
argument_list|(
literal|"Setting connector DPMS state to on\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|set
operator|->
name|num_connectors
condition|;
name|i
operator|++
control|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"\t[CONNECTOR:%d:%s] set DPMS on\n"
argument_list|,
name|set
operator|->
name|connectors
index|[
name|i
index|]
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|set
operator|->
name|connectors
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|set
operator|->
name|connectors
index|[
name|i
index|]
operator|->
name|dpms
operator|=
name|DRM_MODE_DPMS_ON
expr_stmt|;
block|}
block|}
name|drm_helper_disable_unused_functions
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fb_changed
condition|)
block|{
name|set
operator|->
name|crtc
operator|->
name|x
operator|=
name|set
operator|->
name|x
expr_stmt|;
name|set
operator|->
name|crtc
operator|->
name|y
operator|=
name|set
operator|->
name|y
expr_stmt|;
name|old_fb
operator|=
name|set
operator|->
name|crtc
operator|->
name|fb
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|crtc
operator|->
name|fb
operator|!=
name|set
operator|->
name|fb
condition|)
name|set
operator|->
name|crtc
operator|->
name|fb
operator|=
name|set
operator|->
name|fb
expr_stmt|;
name|ret
operator|=
name|crtc_funcs
operator|->
name|mode_set_base
argument_list|(
name|set
operator|->
name|crtc
argument_list|,
name|set
operator|->
name|x
argument_list|,
name|set
operator|->
name|y
argument_list|,
name|old_fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|set
operator|->
name|crtc
operator|->
name|fb
operator|=
name|old_fb
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|free
argument_list|(
name|save_connectors
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save_encoders
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save_crtcs
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
comment|/* Restore all previous data. */
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
operator|*
name|crtc
operator|=
name|save_crtcs
index|[
name|count
operator|++
index|]
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
operator|*
name|encoder
operator|=
name|save_encoders
index|[
name|count
operator|++
index|]
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
operator|*
name|connector
operator|=
name|save_connectors
index|[
name|count
operator|++
index|]
expr_stmt|;
block|}
comment|/* Try to restore the config */
if|if
condition|(
name|mode_changed
operator|&&
operator|!
name|drm_crtc_helper_set_mode
argument_list|(
name|save_set
operator|.
name|crtc
argument_list|,
name|save_set
operator|.
name|mode
argument_list|,
name|save_set
operator|.
name|x
argument_list|,
name|save_set
operator|.
name|y
argument_list|,
name|save_set
operator|.
name|fb
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to restore config after modeset failure\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save_connectors
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save_encoders
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save_crtcs
argument_list|,
name|DRM_MEM_KMS
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_helper_choose_encoder_dpms
parameter_list|(
name|struct
name|drm_encoder
modifier|*
name|encoder
parameter_list|)
block|{
name|int
name|dpms
init|=
name|DRM_MODE_DPMS_OFF
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|encoder
operator|->
name|dev
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
if|if
condition|(
name|connector
operator|->
name|encoder
operator|==
name|encoder
condition|)
if|if
condition|(
name|connector
operator|->
name|dpms
operator|<
name|dpms
condition|)
name|dpms
operator|=
name|connector
operator|->
name|dpms
expr_stmt|;
return|return
name|dpms
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_helper_choose_crtc_dpms
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|int
name|dpms
init|=
name|DRM_MODE_DPMS_OFF
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
if|if
condition|(
name|connector
operator|->
name|encoder
operator|&&
name|connector
operator|->
name|encoder
operator|->
name|crtc
operator|==
name|crtc
condition|)
if|if
condition|(
name|connector
operator|->
name|dpms
operator|<
name|dpms
condition|)
name|dpms
operator|=
name|connector
operator|->
name|dpms
expr_stmt|;
return|return
name|dpms
return|;
block|}
end_function

begin_comment
comment|/**  * drm_helper_connector_dpms  * @connector affected connector  * @mode DPMS mode  *  * Calls the low-level connector DPMS function, then  * calls appropriate encoder and crtc DPMS functions as well  */
end_comment

begin_function
name|void
name|drm_helper_connector_dpms
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
name|connector
operator|->
name|encoder
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|crtc
init|=
name|encoder
condition|?
name|encoder
operator|->
name|crtc
else|:
name|NULL
decl_stmt|;
name|int
name|old_dpms
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|connector
operator|->
name|dpms
condition|)
return|return;
name|old_dpms
operator|=
name|connector
operator|->
name|dpms
expr_stmt|;
name|connector
operator|->
name|dpms
operator|=
name|mode
expr_stmt|;
comment|/* from off to on, do crtc then encoder */
if|if
condition|(
name|mode
operator|<
name|old_dpms
condition|)
block|{
if|if
condition|(
name|crtc
condition|)
block|{
name|struct
name|drm_crtc_helper_funcs
modifier|*
name|crtc_funcs
init|=
name|crtc
operator|->
name|helper_private
decl_stmt|;
if|if
condition|(
name|crtc_funcs
operator|->
name|dpms
condition|)
call|(
modifier|*
name|crtc_funcs
operator|->
name|dpms
call|)
argument_list|(
name|crtc
argument_list|,
name|drm_helper_choose_crtc_dpms
argument_list|(
name|crtc
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|encoder
condition|)
block|{
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
init|=
name|encoder
operator|->
name|helper_private
decl_stmt|;
if|if
condition|(
name|encoder_funcs
operator|->
name|dpms
condition|)
call|(
modifier|*
name|encoder_funcs
operator|->
name|dpms
call|)
argument_list|(
name|encoder
argument_list|,
name|drm_helper_choose_encoder_dpms
argument_list|(
name|encoder
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* from on to off, do encoder then crtc */
if|if
condition|(
name|mode
operator|>
name|old_dpms
condition|)
block|{
if|if
condition|(
name|encoder
condition|)
block|{
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
init|=
name|encoder
operator|->
name|helper_private
decl_stmt|;
if|if
condition|(
name|encoder_funcs
operator|->
name|dpms
condition|)
call|(
modifier|*
name|encoder_funcs
operator|->
name|dpms
call|)
argument_list|(
name|encoder
argument_list|,
name|drm_helper_choose_encoder_dpms
argument_list|(
name|encoder
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|crtc
condition|)
block|{
name|struct
name|drm_crtc_helper_funcs
modifier|*
name|crtc_funcs
init|=
name|crtc
operator|->
name|helper_private
decl_stmt|;
if|if
condition|(
name|crtc_funcs
operator|->
name|dpms
condition|)
call|(
modifier|*
name|crtc_funcs
operator|->
name|dpms
call|)
argument_list|(
name|crtc
argument_list|,
name|drm_helper_choose_crtc_dpms
argument_list|(
name|crtc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
name|int
name|drm_helper_mode_fill_fb_struct
parameter_list|(
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|struct
name|drm_mode_fb_cmd2
modifier|*
name|mode_cmd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|fb
operator|->
name|width
operator|=
name|mode_cmd
operator|->
name|width
expr_stmt|;
name|fb
operator|->
name|height
operator|=
name|mode_cmd
operator|->
name|height
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|fb
operator|->
name|pitches
index|[
name|i
index|]
operator|=
name|mode_cmd
operator|->
name|pitches
index|[
name|i
index|]
expr_stmt|;
name|fb
operator|->
name|offsets
index|[
name|i
index|]
operator|=
name|mode_cmd
operator|->
name|offsets
index|[
name|i
index|]
expr_stmt|;
block|}
name|drm_fb_get_bpp_depth
argument_list|(
name|mode_cmd
operator|->
name|pixel_format
argument_list|,
operator|&
name|fb
operator|->
name|depth
argument_list|,
operator|&
name|fb
operator|->
name|bits_per_pixel
argument_list|)
expr_stmt|;
name|fb
operator|->
name|pixel_format
operator|=
name|mode_cmd
operator|->
name|pixel_format
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|drm_helper_resume_force_mode
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_crtc
modifier|*
name|crtc
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
name|struct
name|drm_encoder_helper_funcs
modifier|*
name|encoder_funcs
decl_stmt|;
name|struct
name|drm_crtc_helper_funcs
modifier|*
name|crtc_funcs
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
operator|!
name|crtc
operator|->
name|enabled
condition|)
continue|continue;
name|ret
operator|=
name|drm_crtc_helper_set_mode
argument_list|(
name|crtc
argument_list|,
operator|&
name|crtc
operator|->
name|mode
argument_list|,
name|crtc
operator|->
name|x
argument_list|,
name|crtc
operator|->
name|y
argument_list|,
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to set mode on crtc %p\n"
argument_list|,
name|crtc
argument_list|)
expr_stmt|;
comment|/* Turn off outputs that were already powered off */
if|if
condition|(
name|drm_helper_choose_crtc_dpms
argument_list|(
name|crtc
argument_list|)
condition|)
block|{
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|crtc
operator|!=
name|crtc
condition|)
continue|continue;
name|encoder_funcs
operator|=
name|encoder
operator|->
name|helper_private
expr_stmt|;
if|if
condition|(
name|encoder_funcs
operator|->
name|dpms
condition|)
call|(
modifier|*
name|encoder_funcs
operator|->
name|dpms
call|)
argument_list|(
name|encoder
argument_list|,
name|drm_helper_choose_encoder_dpms
argument_list|(
name|encoder
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|crtc_funcs
operator|=
name|crtc
operator|->
name|helper_private
expr_stmt|;
if|if
condition|(
name|crtc_funcs
operator|->
name|dpms
condition|)
call|(
modifier|*
name|crtc_funcs
operator|->
name|dpms
call|)
argument_list|(
name|crtc
argument_list|,
name|drm_helper_choose_crtc_dpms
argument_list|(
name|crtc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* disable the unused connectors while restoring the modesetting */
name|drm_helper_disable_unused_functions
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DRM_OUTPUT_POLL_PERIOD
value|(10 * hz)
end_define

begin_function
specifier|static
name|void
name|output_poll_execute
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
name|enum
name|drm_connector_status
name|old_status
decl_stmt|;
name|bool
name|repoll
init|=
name|false
decl_stmt|,
name|changed
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|drm_kms_helper_poll
condition|)
return|return;
name|dev
operator|=
name|ctx
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
comment|/* if this is HPD or polled don't check it - 		   TV out for instance */
if|if
condition|(
operator|!
name|connector
operator|->
name|polled
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|connector
operator|->
name|polled
operator|&
operator|(
name|DRM_CONNECTOR_POLL_CONNECT
operator||
name|DRM_CONNECTOR_POLL_DISCONNECT
operator|)
condition|)
name|repoll
operator|=
name|true
expr_stmt|;
name|old_status
operator|=
name|connector
operator|->
name|status
expr_stmt|;
comment|/* if we are connected and don't want to poll for disconnect 		   skip it */
if|if
condition|(
name|old_status
operator|==
name|connector_status_connected
operator|&&
operator|!
operator|(
name|connector
operator|->
name|polled
operator|&
name|DRM_CONNECTOR_POLL_DISCONNECT
operator|)
operator|&&
operator|!
operator|(
name|connector
operator|->
name|polled
operator|&
name|DRM_CONNECTOR_POLL_HPD
operator|)
condition|)
continue|continue;
name|connector
operator|->
name|status
operator|=
name|connector
operator|->
name|funcs
operator|->
name|detect
argument_list|(
name|connector
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"[CONNECTOR:%d:%s] status updated from %d to %d\n"
argument_list|,
name|connector
operator|->
name|base
operator|.
name|id
argument_list|,
name|drm_get_connector_name
argument_list|(
name|connector
argument_list|)
argument_list|,
name|old_status
argument_list|,
name|connector
operator|->
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_status
operator|!=
name|connector
operator|->
name|status
condition|)
name|changed
operator|=
name|true
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
if|#
directive|if
literal|0
comment|/* send a uevent + call fbdev */
block|drm_sysfs_hotplug_event(dev);
endif|#
directive|endif
if|if
condition|(
name|dev
operator|->
name|mode_config
operator|.
name|funcs
operator|->
name|output_poll_changed
condition|)
name|dev
operator|->
name|mode_config
operator|.
name|funcs
operator|->
name|output_poll_changed
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|repoll
condition|)
block|{
name|taskqueue_enqueue_timeout
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|output_poll_task
argument_list|,
name|DRM_OUTPUT_POLL_PERIOD
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|drm_kms_helper_poll_disable
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dev
operator|->
name|mode_config
operator|.
name|poll_enabled
condition|)
return|return;
name|taskqueue_cancel_timeout
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|output_poll_task
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|drm_kms_helper_poll_enable
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|bool
name|poll
init|=
name|false
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|mode_config
operator|.
name|poll_enabled
operator|||
operator|!
name|drm_kms_helper_poll
condition|)
return|return;
name|list_for_each_entry
argument_list|(
argument|connector
argument_list|,
argument|&dev->mode_config.connector_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|connector
operator|->
name|polled
condition|)
name|poll
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|poll
condition|)
block|{
name|taskqueue_enqueue_timeout
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|output_poll_task
argument_list|,
name|DRM_OUTPUT_POLL_PERIOD
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|drm_kms_helper_poll_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|TIMEOUT_TASK_INIT
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|output_poll_task
argument_list|,
literal|0
argument_list|,
name|output_poll_execute
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|mode_config
operator|.
name|poll_enabled
operator|=
name|true
expr_stmt|;
name|drm_kms_helper_poll_enable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|drm_kms_helper_poll_fini
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_kms_helper_poll_disable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|drm_helper_hpd_irq_event
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dev
operator|->
name|mode_config
operator|.
name|poll_enabled
condition|)
return|return;
comment|/* kill timer and schedule immediate execution, this doesn't block */
name|taskqueue_cancel_timeout
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|output_poll_task
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|drm_kms_helper_poll
condition|)
name|taskqueue_enqueue_timeout
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|dev
operator|->
name|mode_config
operator|.
name|output_poll_task
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

