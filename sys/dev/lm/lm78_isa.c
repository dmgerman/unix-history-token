begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$OpenBSD: lm78_isa.c,v 1.2 2007/07/01 21:48:57 cnst Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2005, 2006 Mark Kettenis  * Copyright (c) 2007 Constantine A. Murenin, Google Summer of Code  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sensors.h>
end_include

begin_include
include|#
directive|include
file|<dev/lm/lm78var.h>
end_include

begin_comment
comment|/* ISA registers */
end_comment

begin_define
define|#
directive|define
name|LMC_ADDR
value|0x05
end_define

begin_define
define|#
directive|define
name|LMC_DATA
value|0x06
end_define

begin_decl_stmt
specifier|extern
name|struct
name|cfdriver
name|lm_cd
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LMDEBUG
argument_list|)
end_if

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|do { printf x; } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|lm_isa_softc
block|{
name|struct
name|lm_softc
name|sc_lmsc
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_iores
decl_stmt|;
name|int
name|sc_iorid
decl_stmt|;
name|bus_space_tag_t
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|sc_ioh
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|lm_isa_probe
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lm_isa_attach
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lm_isa_detach
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int8_t
name|lm_isa_readreg
parameter_list|(
name|struct
name|lm_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lm_isa_writereg
parameter_list|(
name|struct
name|lm_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|lm_isa_methods
index|[]
init|=
block|{
comment|/* Methods from the device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|lm_isa_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|lm_isa_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|lm_isa_detach
argument_list|)
block|,
comment|/* Terminate method list */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|lm_isa_driver
init|=
block|{
literal|"lm"
block|,
name|lm_isa_methods
block|,
expr|sizeof
operator|(
expr|struct
name|lm_isa_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|lm_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|lm
argument_list|,
name|isa
argument_list|,
name|lm_isa_driver
argument_list|,
name|lm_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|lm_isa_probe
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|lm_isa_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|iores
decl_stmt|;
name|int
name|iorid
init|=
literal|0
decl_stmt|;
name|bus_space_tag_t
name|iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
decl_stmt|;
name|int
name|banksel
decl_stmt|,
name|vendid
decl_stmt|,
name|chipid
decl_stmt|,
name|addr
decl_stmt|;
name|iores
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|iorid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|8
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|iores
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: can't map i/o space\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|iot
operator|=
name|rman_get_bustag
argument_list|(
name|iores
argument_list|)
expr_stmt|;
name|ioh
operator|=
name|rman_get_bushandle
argument_list|(
name|iores
argument_list|)
expr_stmt|;
comment|/* Probe for Winbond chips. */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|LMC_ADDR
argument_list|,
name|WB_BANKSEL
argument_list|)
expr_stmt|;
name|banksel
operator|=
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|LMC_DATA
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|LMC_ADDR
argument_list|,
name|WB_VENDID
argument_list|)
expr_stmt|;
name|vendid
operator|=
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|LMC_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|banksel
operator|&
literal|0x80
operator|)
operator|&&
name|vendid
operator|==
operator|(
name|WB_VENDID_WINBOND
operator|>>
literal|8
operator|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|banksel
operator|&
literal|0x80
operator|)
operator|&&
name|vendid
operator|==
operator|(
name|WB_VENDID_WINBOND
operator|&
literal|0xff
operator|)
operator|)
condition|)
goto|goto
name|found
goto|;
comment|/* Probe for ITE chips (and don't attach if we find one). */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|LMC_ADDR
argument_list|,
literal|0x58
comment|/*ITD_CHIPID*/
argument_list|)
expr_stmt|;
name|vendid
operator|=
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|LMC_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendid
operator|==
literal|0x90
comment|/*IT_ID_IT87*/
condition|)
goto|goto
name|notfound
goto|;
comment|/* 	 * Probe for National Semiconductor LM78/79/81. 	 * 	 * XXX This assumes the address has not been changed from the 	 * power up default.  This is probably a reasonable 	 * assumption, and if it isn't true, we should be able to 	 * access the chip using the serial bus. 	 */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|LMC_ADDR
argument_list|,
name|LM_SBUSADDR
argument_list|)
expr_stmt|;
name|addr
operator|=
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|LMC_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|&
literal|0xfc
operator|)
operator|==
literal|0x2c
condition|)
block|{
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|LMC_ADDR
argument_list|,
name|LM_CHIPID
argument_list|)
expr_stmt|;
name|chipid
operator|=
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|LMC_DATA
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|chipid
operator|&
name|LM_CHIPID_MASK
condition|)
block|{
case|case
name|LM_CHIPID_LM78
case|:
case|case
name|LM_CHIPID_LM78J
case|:
case|case
name|LM_CHIPID_LM79
case|:
case|case
name|LM_CHIPID_LM81
case|:
goto|goto
name|found
goto|;
block|}
block|}
name|notfound
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|iorid
argument_list|,
name|iores
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|found
label|:
comment|/* Bus-independent probe */
name|sc
operator|->
name|sc_lmsc
operator|.
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_iot
operator|=
name|iot
expr_stmt|;
name|sc
operator|->
name|sc_ioh
operator|=
name|ioh
expr_stmt|;
name|sc
operator|->
name|sc_lmsc
operator|.
name|lm_writereg
operator|=
name|lm_isa_writereg
expr_stmt|;
name|sc
operator|->
name|sc_lmsc
operator|.
name|lm_readreg
operator|=
name|lm_isa_readreg
expr_stmt|;
name|lm_probe
argument_list|(
operator|&
name|sc
operator|->
name|sc_lmsc
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|iorid
argument_list|,
name|iores
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_iot
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ioh
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lm_isa_attach
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|lm_isa_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|struct
name|lm_softc
modifier|*
name|lmsc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int8_t
name|sbusaddr
decl_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_iores
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|sc_iorid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|8
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_iores
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't map i/o space\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|sc_iot
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_iores
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ioh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_iores
argument_list|)
expr_stmt|;
comment|/* Bus-independent attachment */
name|lm_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_lmsc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * Most devices supported by this driver can attach to iic(4) 	 * as well.  However, we prefer to attach them to isa(4) since 	 * that causes less overhead and is more reliable.  We look 	 * through all previously attached devices, and if we find an 	 * identical chip at the same serial bus address, we stop 	 * updating its sensors and mark them as invalid. 	 */
name|sbusaddr
operator|=
name|lm_isa_readreg
argument_list|(
operator|&
name|sc
operator|->
name|sc_lmsc
argument_list|,
name|LM_SBUSADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbusaddr
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lm_cd
operator|.
name|cd_ndevs
condition|;
name|i
operator|++
control|)
block|{
name|lmsc
operator|=
name|lm_cd
operator|.
name|cd_devs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|lmsc
operator|==
operator|&
name|sc
operator|->
name|sc_lmsc
condition|)
continue|continue;
if|if
condition|(
name|lmsc
operator|&&
name|lmsc
operator|->
name|sbusaddr
operator|==
name|sbusaddr
operator|&&
name|lmsc
operator|->
name|chipid
operator|==
name|sc
operator|->
name|sc_lmsc
operator|.
name|chipid
condition|)
name|config_detach
argument_list|(
operator|&
name|lmsc
operator|->
name|sc_dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lm_isa_detach
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|lm_isa_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Bus-independent detachment */
name|error
operator|=
name|lm_detach
argument_list|(
operator|&
name|sc
operator|->
name|sc_lmsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|sc_iorid
argument_list|,
name|sc
operator|->
name|sc_iores
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|u_int8_t
name|lm_isa_readreg
parameter_list|(
name|struct
name|lm_softc
modifier|*
name|lmsc
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|lm_isa_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lm_isa_softc
operator|*
operator|)
name|lmsc
decl_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|,
name|LMC_ADDR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|,
name|LMC_DATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lm_isa_writereg
parameter_list|(
name|struct
name|lm_softc
modifier|*
name|lmsc
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|lm_isa_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lm_isa_softc
operator|*
operator|)
name|lmsc
decl_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|,
name|LMC_ADDR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|,
name|LMC_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

