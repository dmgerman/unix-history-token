begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Robert N. M. Watson  * Copyright (c) 2012 SRI International  * All rights reserved.  *  * This software was developed by SRI International and the University of  * Cambridge Computer Laboratory under DARPA/AFRL contract (FA8750-10-C-0237)  * ("CTSRD"), as part of the DARPA CRASH research programme.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_disk.h>
end_include

begin_include
include|#
directive|include
file|<dev/isf/isf.h>
end_include

begin_comment
comment|/* Read Mode */
end_comment

begin_define
define|#
directive|define
name|ISF_CMD_RA
value|0xFF
end_define

begin_comment
comment|/* Read Array mode */
end_comment

begin_define
define|#
directive|define
name|ISF_CMD_RSR
value|0x70
end_define

begin_comment
comment|/* Read Status Register mode */
end_comment

begin_define
define|#
directive|define
name|ISF_CMD_RDI
value|0x90
end_define

begin_comment
comment|/* Read Device ID/Config Reg mode */
end_comment

begin_define
define|#
directive|define
name|ISF_CMD_RQ
value|0x98
end_define

begin_comment
comment|/* Read Query mode */
end_comment

begin_define
define|#
directive|define
name|ISF_CMD_CSR
value|0x50
end_define

begin_comment
comment|/* Clear Status Register */
end_comment

begin_comment
comment|/* Write Mode */
end_comment

begin_define
define|#
directive|define
name|ISF_CMD_WPS
value|0x40
end_define

begin_comment
comment|/* Word Program Setup */
end_comment

begin_define
define|#
directive|define
name|ISF_CMD_BPS
value|0xE8
end_define

begin_comment
comment|/* Buffered Program Setup */
end_comment

begin_define
define|#
directive|define
name|ISF_CMD_BPC
value|0xD0
end_define

begin_comment
comment|/* Buffered Program Confirm */
end_comment

begin_comment
comment|/* Erase Mode */
end_comment

begin_define
define|#
directive|define
name|ISF_CMD_BES
value|0x20
end_define

begin_comment
comment|/* Block Erase Setup */
end_comment

begin_define
define|#
directive|define
name|ISF_CMD_BEC
value|0xD0
end_define

begin_comment
comment|/* Block Erase Confirm */
end_comment

begin_comment
comment|/* Block Locking/Unlocking */
end_comment

begin_define
define|#
directive|define
name|ISF_CMD_LBS
value|0x60
end_define

begin_comment
comment|/* Lock Block Setup */
end_comment

begin_define
define|#
directive|define
name|ISF_CMD_LB
value|0x01
end_define

begin_comment
comment|/* Lock Block */
end_comment

begin_define
define|#
directive|define
name|ISF_CMD_UB
value|0xD0
end_define

begin_comment
comment|/* Unlock Block */
end_comment

begin_comment
comment|/*  * Read Device Identifier registers.  *  * NOTE: ISF_RDIR_BLC is relative to the block base address.  */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_MC
value|0x00
end_define

begin_comment
comment|/* Manufacture Code */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_ID
value|0x01
end_define

begin_comment
comment|/* Device ID Code */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_BLC
value|0x02
end_define

begin_comment
comment|/* Block Lock Configuration */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_RCR
value|0x05
end_define

begin_comment
comment|/* Read Configuration Register */
end_comment

begin_comment
comment|/*  * Protection Registers  */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_L0
value|0x80
end_define

begin_comment
comment|/* Lock Register 0 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_FPP
value|0x81
end_define

begin_comment
comment|/* 64-bit Factory Protection Register */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_UPP
value|0x85
end_define

begin_comment
comment|/* 64-bit User Protection Register */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_L1
value|0x89
end_define

begin_comment
comment|/* Lock Register 1 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP1
value|0x8A
end_define

begin_comment
comment|/* 128-bit Protection Register 1 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP2
value|0x92
end_define

begin_comment
comment|/* 128-bit Protection Register 2 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP3
value|0x9A
end_define

begin_comment
comment|/* 128-bit Protection Register 3 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP4
value|0xA2
end_define

begin_comment
comment|/* 128-bit Protection Register 4 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP5
value|0xAA
end_define

begin_comment
comment|/* 128-bit Protection Register 5 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP6
value|0xB2
end_define

begin_comment
comment|/* 128-bit Protection Register 6 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP7
value|0xBA
end_define

begin_comment
comment|/* 128-bit Protection Register 7 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP8
value|0xC2
end_define

begin_comment
comment|/* 128-bit Protection Register 8 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP9
value|0xCA
end_define

begin_comment
comment|/* 128-bit Protection Register 9 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP10
value|0xD2
end_define

begin_comment
comment|/* 128-bit Protection Register 10 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP11
value|0xDA
end_define

begin_comment
comment|/* 128-bit Protection Register 11 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP12
value|0xE2
end_define

begin_comment
comment|/* 128-bit Protection Register 12 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP13
value|0xEA
end_define

begin_comment
comment|/* 128-bit Protection Register 13 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP14
value|0xF2
end_define

begin_comment
comment|/* 128-bit Protection Register 14 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP15
value|0xFA
end_define

begin_comment
comment|/* 128-bit Protection Register 15 */
end_comment

begin_define
define|#
directive|define
name|ISF_REG_PP16
value|0x102
end_define

begin_comment
comment|/* 128-bit Protection Register 16 */
end_comment

begin_define
define|#
directive|define
name|ISF_SR_BWS
value|(1<< 0)
end_define

begin_comment
comment|/* BEFP Status */
end_comment

begin_define
define|#
directive|define
name|ISF_SR_BLS
value|(1<< 1)
end_define

begin_comment
comment|/* Block-Locked Status */
end_comment

begin_define
define|#
directive|define
name|ISF_SR_PSS
value|(1<< 2)
end_define

begin_comment
comment|/* Program Suspend Status */
end_comment

begin_define
define|#
directive|define
name|ISF_SR_VPPS
value|(1<< 3)
end_define

begin_comment
comment|/* Vpp Status */
end_comment

begin_define
define|#
directive|define
name|ISF_SR_PS
value|(1<< 4)
end_define

begin_comment
comment|/* Program Status */
end_comment

begin_define
define|#
directive|define
name|ISF_SR_ES
value|(1<< 5)
end_define

begin_comment
comment|/* Erase Status */
end_comment

begin_define
define|#
directive|define
name|ISF_SR_ESS
value|(1<< 6)
end_define

begin_comment
comment|/* Erase Suspend Status */
end_comment

begin_define
define|#
directive|define
name|ISF_SR_DWS
value|(1<< 7)
end_define

begin_comment
comment|/* Device Write Status */
end_comment

begin_define
define|#
directive|define
name|ISF_SR_FSC_MASK
value|(ISF_SR_VPPS | ISF_SR_PS | ISF_SR_BLS)
end_define

begin_define
define|#
directive|define
name|ISF_BUFFER_PROGRAM
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ISF
argument_list|,
literal|"isf_data"
argument_list|,
literal|"Intel StrateFlash driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|isf_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|isf_chips
block|{
name|uint16_t
name|chip_id
decl_stmt|;
name|size_t
name|chip_size
decl_stmt|;
specifier|const
name|char
modifier|*
name|chip_desc
decl_stmt|;
block|}
name|chip_ids
index|[]
init|=
block|{
block|{
literal|0x8817
block|,
literal|0x0800000
block|,
literal|"64-Mbit Top Parameter"
block|}
block|,
block|{
literal|0x881A
block|,
literal|0x0800000
block|,
literal|"64-Mbit Bottom Parameter"
block|}
block|,
block|{
literal|0x8818
block|,
literal|0x1000000
block|,
literal|"128-Mbit Top Parameter"
block|}
block|,
block|{
literal|0x881B
block|,
literal|0x1000000
block|,
literal|"128-Mbit Bottom Parameter"
block|}
block|,
block|{
literal|0x8919
block|,
literal|0x2000000
block|,
literal|"256-Mbit Top Parameter"
block|}
block|,
block|{
literal|0x891C
block|,
literal|0x2000000
block|,
literal|"256-Mbit Bottom Parameter"
block|}
block|,
block|{
literal|0x8961
block|,
literal|0x2000000
block|,
literal|"512-Mbit package (half)"
block|}
block|,
block|{
literal|0x0000
block|,
literal|0x0000000
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|isf_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*   * Device driver for the Intel StrataFlash NOR flash device.  This  * implementation is known to work with 256Mb instances of the device, but may  * also work with other 64/128/512Mb parts without much work.  Multiple  * device instances should be used when multiple parts are in the same  * physical package, due to variable block size support in the StrataFlash  * part.  */
end_comment

begin_function
specifier|static
name|uint16_t
name|isf_read_reg
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|reg
parameter_list|)
block|{
if|if
condition|(
name|isf_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"isf_read_reg(0x%02x)\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|le16toh
argument_list|(
name|bus_read_2
argument_list|(
name|sc
operator|->
name|isf_res
argument_list|,
name|reg
operator|*
literal|2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|isf_read_reg64
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|reg
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|uint16_t
modifier|*
name|val16
init|=
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|val
decl_stmt|;
if|if
condition|(
name|isf_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"isf_read_reg64(0x%02x)\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|val16
index|[
literal|0
index|]
operator|=
name|bus_read_2
argument_list|(
name|sc
operator|->
name|isf_res
argument_list|,
name|reg
operator|*
literal|2
argument_list|)
expr_stmt|;
name|val16
index|[
literal|1
index|]
operator|=
name|bus_read_2
argument_list|(
name|sc
operator|->
name|isf_res
argument_list|,
operator|(
name|reg
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|val16
index|[
literal|2
index|]
operator|=
name|bus_read_2
argument_list|(
name|sc
operator|->
name|isf_res
argument_list|,
operator|(
name|reg
operator|+
literal|2
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|val16
index|[
literal|3
index|]
operator|=
name|bus_read_2
argument_list|(
name|sc
operator|->
name|isf_res
argument_list|,
operator|(
name|reg
operator|+
literal|3
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|le64toh
argument_list|(
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|isf_read_off
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|off
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: negative offset\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|off
operator|<
name|sc
operator|->
name|isf_disk
operator|->
name|d_mediasize
argument_list|,
operator|(
literal|"%s: offset out side address space 0x%08jx \n"
operator|,
name|__func__
operator|,
operator|(
name|intmax_t
operator|)
name|off
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isf_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"isf_read_off(0x%08jx)\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
name|le16toh
argument_list|(
name|bus_read_2
argument_list|(
name|sc
operator|->
name|isf_res
argument_list|,
name|off
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isf_write_cmd
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|off
parameter_list|,
name|uint16_t
name|cmd
parameter_list|)
block|{
if|if
condition|(
name|isf_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"isf_write_cmd(0x%08jx, 0x%02x)\n"
argument_list|,
name|off
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|bus_write_2
argument_list|(
name|sc
operator|->
name|isf_res
argument_list|,
name|off
argument_list|,
name|htole16
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|isf_read_status
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|off
operator|/
literal|2
argument_list|,
name|ISF_CMD_RSR
argument_list|)
expr_stmt|;
return|return
name|isf_read_off
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isf_clear_status
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|)
block|{
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ISF_CMD_CSR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|isf_full_status_check
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|status
operator|=
name|isf_read_status
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ISF_SR_VPPS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"Vpp Range Error\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|ISF_SR_PS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"Program Error\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|ISF_SR_BLS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"Device Protect Error\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|isf_clear_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isf_full_erase_status_check
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|status
operator|=
name|isf_read_status
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ISF_SR_VPPS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"Vpp Range Error\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
operator|(
name|ISF_SR_PS
operator||
name|ISF_SR_ES
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"Command Sequence Error\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|ISF_SR_ES
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"Block Erase Error\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|ISF_SR_BLS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"Block Locked Error\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|isf_clear_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isf_unlock_block
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
name|ISF_CMD_LBS
argument_list|)
expr_stmt|;
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
name|ISF_CMD_UB
argument_list|)
expr_stmt|;
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
name|ISF_CMD_RA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isf_lock_block
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
name|ISF_CMD_LBS
argument_list|)
expr_stmt|;
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
name|ISF_CMD_LB
argument_list|)
expr_stmt|;
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
name|ISF_CMD_RA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isf_read
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|off
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|data
operator|%
literal|2
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: unaligned data %p"
operator|,
name|__func__
operator|,
name|data
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|len
operator|<=
name|ISF_SECTORSIZE
operator|)
operator|&&
operator|(
name|len
operator|%
literal|2
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"%s: invalid length %ju"
operator|,
name|__func__
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|off
operator|%
name|ISF_SECTORSIZE
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: invalid offset %ju\n"
operator|,
name|__func__
operator|,
name|off
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * It is not permitted to read blocks that are in the process of 	 * being erased, but we know they will be all 1's after the 	 * erase so just report that value if asked about a block that 	 * is being erased. 	 */
if|if
condition|(
name|sc
operator|->
name|isf_bstate
index|[
name|off
operator|/
name|ISF_ERASE_BLOCK
index|]
operator|==
name|BS_ERASING
condition|)
name|memset
argument_list|(
name|data
argument_list|,
literal|0xFF
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|bus_read_region_2
argument_list|(
name|sc
operator|->
name|isf_res
argument_list|,
name|off
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|data
argument_list|,
name|len
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|isf_write
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|off
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|cycles
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|uint16_t
modifier|*
name|dp
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|off_t
name|coff
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|data
operator|%
literal|2
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: unaligned data %p"
operator|,
name|__func__
operator|,
name|data
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|len
operator|<=
name|ISF_SECTORSIZE
operator|)
operator|&&
operator|(
name|len
operator|%
literal|2
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"%s: invalid length %ju"
operator|,
name|__func__
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|off
operator|%
name|ISF_SECTORSIZE
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: invalid offset %ju\n"
operator|,
name|__func__
operator|,
name|off
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|sc
operator|->
name|isf_erasing
argument_list|,
operator|(
literal|"%s: trying to write while erasing\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|isf_bstate
index|[
name|off
operator|/
name|ISF_ERASE_BLOCK
index|]
operator|!=
name|BS_ERASING
argument_list|,
operator|(
literal|"%s: block being erased at %ju\n"
operator|,
name|__func__
operator|,
name|off
operator|)
argument_list|)
expr_stmt|;
name|isf_unlock_block
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISF_BUFFER_PROGRAM
for|for
control|(
name|dp
operator|=
name|data
operator|,
name|coff
operator|=
name|off
init|;
name|dp
operator|-
operator|(
name|uint16_t
operator|*
operator|)
name|data
operator|<
name|len
operator|/
literal|2
condition|;
name|dp
operator|+=
literal|32
operator|,
name|coff
operator|+=
literal|64
control|)
block|{
name|isf_clear_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|coff
argument_list|,
name|ISF_CMD_BPS
argument_list|)
expr_stmt|;
name|cycles
operator|=
literal|0xFFFF
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|isf_read_off
argument_list|(
name|sc
argument_list|,
name|coff
argument_list|)
operator|&
name|ISF_SR_DWS
operator|)
condition|)
block|{
if|if
condition|(
name|cycles
operator|--
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"timeout waiting"
literal|" for write to start at 0x08%jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|coff
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|coff
argument_list|,
name|ISF_CMD_BPS
argument_list|)
expr_stmt|;
block|}
comment|/* When writing N blocks, send N-1 as the count */
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|coff
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|bus_write_region_2
argument_list|(
name|sc
operator|->
name|isf_res
argument_list|,
name|coff
argument_list|,
name|dp
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|coff
argument_list|,
name|ISF_CMD_BPC
argument_list|)
expr_stmt|;
name|status
operator|=
name|isf_read_off
argument_list|(
name|sc
argument_list|,
name|coff
argument_list|)
expr_stmt|;
name|cycles
operator|=
literal|0xFFFFF
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|status
operator|&
name|ISF_SR_DWS
operator|)
condition|)
block|{
if|if
condition|(
name|cycles
operator|--
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"timeout waiting"
literal|" for write to complete at 0x08%jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|coff
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|isf_read_off
argument_list|(
name|sc
argument_list|,
name|coff
argument_list|)
expr_stmt|;
block|}
name|isf_full_status_check
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|coff
argument_list|,
name|ISF_CMD_RA
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|dp
operator|=
name|data
operator|,
name|coff
operator|=
name|off
init|;
name|dp
operator|-
operator|(
name|uint16_t
operator|*
operator|)
name|data
operator|<
name|len
operator|/
literal|2
condition|;
name|dp
operator|++
operator|,
name|coff
operator|+=
literal|2
control|)
block|{
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|coff
argument_list|,
name|ISF_CMD_WPS
argument_list|)
expr_stmt|;
name|bus_write_2
argument_list|(
name|sc
operator|->
name|isf_res
argument_list|,
name|coff
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
name|status
operator|=
name|isf_read_off
argument_list|(
name|sc
argument_list|,
name|coff
argument_list|)
expr_stmt|;
name|cycles
operator|=
literal|0xFFFFF
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|status
operator|&
name|ISF_SR_DWS
operator|)
condition|)
block|{
if|if
condition|(
name|cycles
operator|--
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"timeout waiting"
literal|" for write to complete at 0x08%jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|coff
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|isf_read_off
argument_list|(
name|sc
argument_list|,
name|coff
argument_list|)
expr_stmt|;
block|}
block|}
name|isf_full_status_check
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|coff
argument_list|,
name|ISF_CMD_RA
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isf_lock_block
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isf_erase_at
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
name|int
name|cycles
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|isf_unlock_block
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|isf_clear_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
name|ISF_CMD_BES
argument_list|)
expr_stmt|;
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
name|ISF_CMD_BEC
argument_list|)
expr_stmt|;
name|cycles
operator|=
literal|0xFFFFFF
expr_stmt|;
name|status
operator|=
name|isf_read_off
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|status
operator|&
name|ISF_SR_DWS
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|NOTYET
name|ISF_SLEEP
argument_list|(
name|sc
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cycles
operator|--
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"Giving up on erase\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|isf_read_off
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
name|isf_full_erase_status_check
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|isf_lock_block
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
name|ISF_CMD_RA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isf_erase_range
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|blk_off
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|off_t
name|off
decl_stmt|;
name|off_t
name|ms
init|=
name|sc
operator|->
name|isf_disk
operator|->
name|d_mediasize
decl_stmt|;
name|KASSERT
argument_list|(
name|blk_off
operator|%
name|ISF_ERASE_BLOCK
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: invalid offset %ju\n"
operator|,
name|__func__
operator|,
name|blk_off
operator|)
argument_list|)
expr_stmt|;
name|ISF_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|off
operator|=
name|blk_off
init|;
name|off
operator|<
name|blk_off
operator|+
name|size
condition|;
name|off
operator|+=
name|ISF_ERASE_BLOCK
control|)
block|{
name|sc
operator|->
name|isf_bstate
index|[
name|off
operator|/
name|ISF_ERASE_BLOCK
index|]
operator|=
name|BS_ERASING
expr_stmt|;
comment|/* 		 * The first or last 128K is four blocks depending which 		 * part this is.  For now, just assume both are and 		 * erase four times. 		 */
if|if
condition|(
name|off
operator|==
literal|0
operator|||
name|ms
operator|-
name|off
operator|==
name|ISF_ERASE_BLOCK
condition|)
block|{
name|isf_erase_at
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|isf_erase_at
argument_list|(
name|sc
argument_list|,
name|off
operator|+
literal|0x08000
argument_list|)
expr_stmt|;
name|isf_erase_at
argument_list|(
name|sc
argument_list|,
name|off
operator|+
literal|0x10000
argument_list|)
expr_stmt|;
name|isf_erase_at
argument_list|(
name|sc
argument_list|,
name|off
operator|+
literal|0x18000
argument_list|)
expr_stmt|;
block|}
else|else
name|isf_erase_at
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|sc
operator|->
name|isf_bstate
index|[
name|off
operator|/
name|ISF_ERASE_BLOCK
index|]
operator|=
name|BS_STEADY
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * disk(9) methods.  */
end_comment

begin_function
specifier|static
name|int
name|isf_disk_ioctl
parameter_list|(
name|struct
name|disk
modifier|*
name|disk
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|isf_softc
modifier|*
name|sc
init|=
name|disk
operator|->
name|d_drv1
decl_stmt|;
name|struct
name|isf_range
modifier|*
name|ir
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ISF_ERASE
case|:
name|ir
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|ir
operator|->
name|ir_off
operator|%
name|ISF_ERASE_BLOCK
operator|!=
literal|0
operator|||
name|ir
operator|->
name|ir_off
operator|>=
name|disk
operator|->
name|d_mediasize
operator|||
name|ir
operator|->
name|ir_size
operator|==
literal|0
operator|||
name|ir
operator|->
name|ir_size
operator|%
name|ISF_ERASE_BLOCK
operator|!=
literal|0
operator|||
name|ir
operator|->
name|ir_off
operator|+
name|ir
operator|->
name|ir_size
operator|>
name|disk
operator|->
name|d_mediasize
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ISF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|isf_erasing
condition|)
block|{
name|ISF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|isf_erasing
operator|=
literal|1
expr_stmt|;
name|isf_erase_range
argument_list|(
name|sc
argument_list|,
name|ir
operator|->
name|ir_off
argument_list|,
name|ir
operator|->
name|ir_size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|isf_erasing
operator|=
literal|0
expr_stmt|;
name|ISF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isf_disk_strategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|isf_softc
modifier|*
name|sc
init|=
name|bp
operator|->
name|bio_disk
operator|->
name|d_drv1
decl_stmt|;
comment|/* 	 * We advertise a block size and maximum I/O size up the stack; catch 	 * any attempts to not follow the rules. 	 */
name|KASSERT
argument_list|(
name|bp
operator|->
name|bio_bcount
operator|==
name|ISF_SECTORSIZE
argument_list|,
operator|(
literal|"%s: I/O size not %d"
operator|,
name|__func__
operator|,
name|ISF_SECTORSIZE
operator|)
argument_list|)
expr_stmt|;
name|ISF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bioq_disksort
argument_list|(
operator|&
name|sc
operator|->
name|isf_bioq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ISF_WAKEUP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ISF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isf_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|isf_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|int
name|ss
init|=
name|sc
operator|->
name|isf_disk
operator|->
name|d_sectorsize
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ISF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
do|do
block|{
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|isf_bioq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|isf_doomed
condition|)
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|ISF_SLEEP
argument_list|(
name|sc
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|bp
operator|==
name|NULL
condition|)
do|;
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|isf_bioq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
name|isf_read
argument_list|(
name|sc
argument_list|,
name|bp
operator|->
name|bio_pblkno
operator|*
name|ss
argument_list|,
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_bcount
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
comment|/* 			 * In principle one could suspend the in-progress 			 * erase, process any pending writes to other 			 * blocks and then proceed, but that seems 			 * overly complex for the likely usage modes. 			 */
if|if
condition|(
name|sc
operator|->
name|isf_erasing
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* 			 * Read in the block we want to write and check that 			 * we're only setting bits to 0.  If an erase would 			 * be required return an I/O error. 			 */
name|isf_read
argument_list|(
name|sc
argument_list|,
name|bp
operator|->
name|bio_pblkno
operator|*
name|ss
argument_list|,
name|sc
operator|->
name|isf_rbuf
argument_list|,
name|bp
operator|->
name|bio_bcount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|bio_bcount
operator|/
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|sc
operator|->
name|isf_rbuf
index|[
name|i
index|]
operator|&
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|bp
operator|->
name|bio_data
operator|)
index|[
name|i
index|]
operator|)
operator|!=
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|bp
operator|->
name|bio_data
operator|)
index|[
name|i
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"write"
literal|" requires erase at 0x%08jx\n"
argument_list|,
name|bp
operator|->
name|bio_pblkno
operator|*
name|ss
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
name|isf_write
argument_list|(
name|sc
argument_list|,
name|bp
operator|->
name|bio_pblkno
operator|*
name|ss
argument_list|,
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_bcount
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unsupported I/O operation %d"
argument_list|,
name|__func__
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ISF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isf_dump_info
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int32_t
name|reg
decl_stmt|;
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ISF_CMD_RDI
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"manufacturer code: 0x%04x\n"
argument_list|,
name|isf_read_reg
argument_list|(
name|sc
argument_list|,
name|ISF_REG_MC
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"device id code: 0x%04x\n"
argument_list|,
name|isf_read_reg
argument_list|(
name|sc
argument_list|,
name|ISF_REG_ID
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"read config register: 0x%04x\n"
argument_list|,
name|isf_read_reg
argument_list|(
name|sc
argument_list|,
name|ISF_REG_RCR
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"lock register 0: 0x%04x\n"
argument_list|,
name|isf_read_reg
argument_list|(
name|sc
argument_list|,
name|ISF_REG_L0
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"lock register 1: 0x%04x\n"
argument_list|,
name|isf_read_reg
argument_list|(
name|sc
argument_list|,
name|ISF_REG_L1
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"factory PPR: 0x%016jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|isf_read_reg64
argument_list|(
name|sc
argument_list|,
name|ISF_REG_FPP
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"user PPR (64-bit): 0x%016jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|isf_read_reg64
argument_list|(
name|sc
argument_list|,
name|ISF_REG_UPP
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|ISF_REG_PP1
operator|,
name|i
operator|=
literal|1
init|;
name|reg
operator|<=
name|ISF_REG_PP16
condition|;
name|reg
operator|+=
literal|8
operator|,
name|i
operator|++
control|)
block|{
comment|/* XXX: big-endian ordering of uint64_t's */
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"user PPR [%02d]: 0x%016jx%016jx\n"
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|isf_read_reg64
argument_list|(
name|sc
argument_list|,
name|reg
operator|+
literal|4
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|isf_read_reg64
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ISF_CMD_RA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isf_disk_insert
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|mediasize
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|disk
decl_stmt|;
name|sc
operator|->
name|isf_doomed
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|isf_erasing
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|isf_bstate
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|isf_bstate
argument_list|)
operator|*
operator|(
name|mediasize
operator|/
name|ISF_ERASE_BLOCK
operator|)
argument_list|,
name|M_ISF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|kproc_create
argument_list|(
operator|&
name|isf_task
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|isf_proc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"isf"
argument_list|)
expr_stmt|;
name|disk
operator|=
name|disk_alloc
argument_list|()
expr_stmt|;
name|disk
operator|->
name|d_drv1
operator|=
name|sc
expr_stmt|;
name|disk
operator|->
name|d_name
operator|=
literal|"isf"
expr_stmt|;
name|disk
operator|->
name|d_unit
operator|=
name|sc
operator|->
name|isf_unit
expr_stmt|;
name|disk
operator|->
name|d_strategy
operator|=
name|isf_disk_strategy
expr_stmt|;
name|disk
operator|->
name|d_ioctl
operator|=
name|isf_disk_ioctl
expr_stmt|;
name|disk
operator|->
name|d_sectorsize
operator|=
name|ISF_SECTORSIZE
expr_stmt|;
name|disk
operator|->
name|d_mediasize
operator|=
name|mediasize
expr_stmt|;
name|disk
operator|->
name|d_maxsize
operator|=
name|ISF_SECTORSIZE
expr_stmt|;
name|sc
operator|->
name|isf_disk
operator|=
name|disk
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|isf_dump_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|disk_create
argument_list|(
name|disk
argument_list|,
name|DISK_VERSION
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"%juM flash device\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|disk
operator|->
name|d_mediasize
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isf_disk_remove
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|disk
decl_stmt|;
name|ISF_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|isf_disk
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: isf_disk NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|isf_doomed
operator|=
literal|1
expr_stmt|;
name|ISF_WAKEUP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ISF_SLEEP
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|isf_proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRW: Is it OK to call disk_destroy() under the mutex, or should 	 * we be deferring that to the calling context once it is released? 	 */
name|disk
operator|=
name|sc
operator|->
name|isf_disk
expr_stmt|;
name|disk_gone
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|disk_destroy
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|sc
operator|->
name|isf_disk
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|isf_bstate
argument_list|,
name|M_ISF
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"flash device removed\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|isf_attach
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|id
decl_stmt|;
name|u_long
name|start
decl_stmt|,
name|size
decl_stmt|;
name|struct
name|isf_chips
modifier|*
name|cp
init|=
name|chip_ids
decl_stmt|;
name|start
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|isf_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"Unsupported flash start alignment %lu\n"
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ISF_CMD_RDI
argument_list|)
expr_stmt|;
name|id
operator|=
name|isf_read_reg
argument_list|(
name|sc
argument_list|,
name|ISF_REG_ID
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|->
name|chip_id
operator|!=
name|id
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|chip_desc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"Unsupported device ID 0x%04x\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|isf_write_cmd
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ISF_CMD_RA
argument_list|)
expr_stmt|;
name|size
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|isf_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|cp
operator|->
name|chip_size
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|isf_dev
argument_list|,
literal|"Unsupported flash size %lu\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|isf_bioq
argument_list|)
expr_stmt|;
name|ISF_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|isf_disk
operator|=
name|NULL
expr_stmt|;
name|isf_disk_insert
argument_list|(
name|sc
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isf_detach
parameter_list|(
name|struct
name|isf_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Simulate a disk removal if one is present to deal with any pending 	 * or queued I/O.  This will occur as a result of a device driver 	 * detach -- the Intel StrataFlash has no notion of removal itself. 	 * 	 * XXXRW: Is the locking here right? 	 */
name|ISF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|isf_disk_remove
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bioq_flush
argument_list|(
operator|&
name|sc
operator|->
name|isf_bioq
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|isf_bioq
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: non-empty bioq"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ISF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ISF_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

