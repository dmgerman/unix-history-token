begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2014 The DragonFly Project.  All rights reserved.  *  * This code is derived from software contributed to The DragonFly Project  * by Matthew Dillon<dillon@backplane.com> and was subsequently ported,  * modified and enhanced for FreeBSD by Michael Gmelin<freebsd@grem.de>.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  * 3. Neither the name of The DragonFly Project nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific, prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE  * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * CYAPA - Cypress APA trackpad with I2C Interface driver  *  * Based on DragonFlyBSD's cyapa driver, which referenced the linux  * cyapa.c driver to figure out the bootstrapping and commands.  *  * Unable to locate any datasheet for the device.  *  *  * Trackpad layout:  *  *                2/3               1/3  *       +--------------------+------------+  *       |                    |   Middle   |  *       |                    |   Button   |  *       |       Left         |            |  *       |      Button        +------------+  *       |                    |   Right    |  *       |                    |   Button   |  *       +--------------------+............|  *       |     Thumb/Button Area           | 15%  *       +---------------------------------+  *  *  *                             FEATURES  *  * IMPS/2 emulation       - Emulates the IntelliMouse protocol.  *  * Jitter supression      - Implements 2-pixel hysteresis with memory.  *  * Jump detecion          - Detect jumps caused by touchpad.  *  * Two finger scrolling   - Use two fingers for Z axis scrolling.  *  * Button down/2nd finger - While one finger clicks and holds down the  *                          touchpad, the second one can be used to move  *                          the mouse cursor. Useful for drawing or  *                          selecting text.  *  * Thumb/Button Area      - The lower 15%* of the trackpad will not affect  *                          the mouse cursor position. This allows for high  *                          precision clicking, by controlling the cursor  *                          with the index finger and pushing/holding the  *                          pad down with the thumb.  *                          * can be changed using sysctl  *  * Track-pad button       - Push physical button. Left 2/3rds of the pad  *                          will issue a LEFT button event, upper right  *                          corner will issue a MIDDLE button event,  *                          lower right corner will issue a RIGHT button  *                          event. Optional tap support can be enabled  *                          and configured using sysctl.  *  *                              WARNINGS  *  * These trackpads get confused when three or more fingers are down on the  * same horizontal axis and will start to glitch the finger detection.  * Removing your hand for a few seconds will allow the trackpad to  * recalibrate.  Generally speaking, when using three or more fingers  * please try to place at least one finger off-axis (a little above or  * below) the other two.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/lockmgr.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mouse.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iiconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iicbus.h>
end_include

begin_include
include|#
directive|include
file|<dev/cyapa/cyapa.h>
end_include

begin_include
include|#
directive|include
file|"iicbus_if.h"
end_include

begin_include
include|#
directive|include
file|"bus_if.h"
end_include

begin_include
include|#
directive|include
file|"device_if.h"
end_include

begin_define
define|#
directive|define
name|CYAPA_BUFSIZE
value|128
end_define

begin_comment
comment|/* power of 2 */
end_comment

begin_define
define|#
directive|define
name|CYAPA_BUFMASK
value|(CYAPA_BUFSIZE - 1)
end_define

begin_define
define|#
directive|define
name|ZSCALE
value|15
end_define

begin_define
define|#
directive|define
name|TIME_TO_IDLE
value|(hz * 10)
end_define

begin_define
define|#
directive|define
name|TIME_TO_RESET
value|(hz * 3)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_CYAPA
argument_list|,
literal|"cyapa"
argument_list|,
literal|"CYAPA device data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|cyapa_fifo
block|{
name|int
name|rindex
decl_stmt|;
name|int
name|windex
decl_stmt|;
name|char
name|buf
index|[
name|CYAPA_BUFSIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cyapa_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/*>0 if device opened */
name|struct
name|cdev
modifier|*
name|devnode
decl_stmt|;
name|struct
name|selinfo
name|selinfo
decl_stmt|;
name|struct
name|mtx
name|mutex
decl_stmt|;
name|int
name|cap_resx
decl_stmt|;
name|int
name|cap_resy
decl_stmt|;
name|int
name|cap_phyx
decl_stmt|;
name|int
name|cap_phyy
decl_stmt|;
name|uint8_t
name|cap_buttons
decl_stmt|;
name|int
name|detaching
decl_stmt|;
comment|/* driver is detaching */
name|int
name|poll_thread_running
decl_stmt|;
comment|/* poll thread is running */
comment|/* PS/2 mouse emulation */
name|int
name|track_x
decl_stmt|;
comment|/* current tracking */
name|int
name|track_y
decl_stmt|;
name|int
name|track_z
decl_stmt|;
name|int
name|track_z_ticks
decl_stmt|;
name|uint16_t
name|track_but
decl_stmt|;
name|char
name|track_id
decl_stmt|;
comment|/* first finger id */
name|int
name|track_nfingers
decl_stmt|;
name|int
name|delta_x
decl_stmt|;
comment|/* accumulation -> report */
name|int
name|delta_y
decl_stmt|;
name|int
name|delta_z
decl_stmt|;
name|int
name|fuzz_x
decl_stmt|;
name|int
name|fuzz_y
decl_stmt|;
name|int
name|fuzz_z
decl_stmt|;
name|int
name|touch_x
decl_stmt|;
comment|/* touch down coordinates */
name|int
name|touch_y
decl_stmt|;
name|int
name|touch_z
decl_stmt|;
name|int
name|finger1_ticks
decl_stmt|;
name|int
name|finger2_ticks
decl_stmt|;
name|int
name|finger3_ticks
decl_stmt|;
name|uint16_t
name|reported_but
decl_stmt|;
name|struct
name|cyapa_fifo
name|rfifo
decl_stmt|;
comment|/* device->host */
name|struct
name|cyapa_fifo
name|wfifo
decl_stmt|;
comment|/* host->device */
name|uint8_t
name|ps2_cmd
decl_stmt|;
comment|/* active p2_cmd waiting for data */
name|uint8_t
name|ps2_acked
decl_stmt|;
name|int
name|active_tick
decl_stmt|;
name|int
name|data_signal
decl_stmt|;
name|int
name|blocked
decl_stmt|;
name|int
name|isselect
decl_stmt|;
name|int
name|reporting_mode
decl_stmt|;
comment|/* 0=disabled 1=enabled */
name|int
name|scaling_mode
decl_stmt|;
comment|/* 0=1:1 1=2:1 */
name|int
name|remote_mode
decl_stmt|;
comment|/* 0 for streaming mode */
name|int
name|zenabled
decl_stmt|;
comment|/* z-axis enabled (mode 1 or 2) */
name|mousehw_t
name|hw
decl_stmt|;
comment|/* hardware information */
name|mousemode_t
name|mode
decl_stmt|;
comment|/* mode */
name|int
name|poll_ticks
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cyapa_cdevpriv
block|{
name|struct
name|cyapa_softc
modifier|*
name|sc
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CYPOLL_SHUTDOWN
value|0x0001
end_define

begin_function_decl
specifier|static
name|void
name|cyapa_poll_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cyapa_raw_input
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_regs
modifier|*
name|regs
parameter_list|,
name|int
name|freq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cyapa_set_power_mode
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fifo_empty
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|fifo_ready
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|fifo_read
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|fifo_write
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|fifo_read_char
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fifo_write_char
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|,
name|uint8_t
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|fifo_space
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fifo_reset
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cyapa_fuzz
parameter_list|(
name|int
name|delta
parameter_list|,
name|int
modifier|*
name|fuzz
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|cyapa_idle_freq
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|cyapa_idle_freq
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cyapa_idle_freq
argument_list|,
literal|0
argument_list|,
literal|"Scan frequency in idle mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cyapa_slow_freq
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|cyapa_slow_freq
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cyapa_slow_freq
argument_list|,
literal|0
argument_list|,
literal|"Scan frequency in slow mode "
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cyapa_norm_freq
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|cyapa_norm_freq
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cyapa_norm_freq
argument_list|,
literal|0
argument_list|,
literal|"Normal scan frequency"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cyapa_minpressure
init|=
literal|12
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|cyapa_minpressure
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cyapa_minpressure
argument_list|,
literal|0
argument_list|,
literal|"Minimum pressure to detect finger"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cyapa_enable_tapclick
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|cyapa_enable_tapclick
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cyapa_enable_tapclick
argument_list|,
literal|0
argument_list|,
literal|"Enable tap to click"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cyapa_tapclick_min_ticks
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|cyapa_tapclick_min_ticks
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cyapa_tapclick_min_ticks
argument_list|,
literal|0
argument_list|,
literal|"Minimum tap duration for click"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cyapa_tapclick_max_ticks
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|cyapa_tapclick_max_ticks
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cyapa_tapclick_max_ticks
argument_list|,
literal|0
argument_list|,
literal|"Maximum tap duration for click"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cyapa_move_min_ticks
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|cyapa_move_min_ticks
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cyapa_move_min_ticks
argument_list|,
literal|0
argument_list|,
literal|"Minimum ticks before cursor position is changed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cyapa_scroll_wait_ticks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|cyapa_scroll_wait_ticks
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cyapa_scroll_wait_ticks
argument_list|,
literal|0
argument_list|,
literal|"Wait N ticks before starting to scroll"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cyapa_scroll_stick_ticks
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|cyapa_scroll_stick_ticks
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cyapa_scroll_stick_ticks
argument_list|,
literal|0
argument_list|,
literal|"Prevent cursor move on single finger for N ticks after scroll"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cyapa_thumbarea_percent
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|cyapa_thumbarea_percent
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cyapa_thumbarea_percent
argument_list|,
literal|0
argument_list|,
literal|"Size of bottom thumb area in percent"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cyapa_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|cyapa_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cyapa_debug
argument_list|,
literal|0
argument_list|,
literal|"Enable debugging"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cyapa_reset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|cyapa_reset
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cyapa_reset
argument_list|,
literal|0
argument_list|,
literal|"Reset track pad"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|cyapa_read_bytes
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
name|uint8_t
modifier|*
name|val
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|uint16_t
name|addr
init|=
name|iicbus_get_addr
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|iic_msg
name|msgs
index|[]
init|=
block|{
block|{
name|addr
block|,
name|IIC_M_WR
operator||
name|IIC_M_NOSTOP
block|,
literal|1
block|,
operator|&
name|reg
block|}
block|,
block|{
name|addr
block|,
name|IIC_M_RD
block|,
name|cnt
block|,
name|val
block|}
block|, 	}
decl_stmt|;
return|return
operator|(
name|iicbus_transfer
argument_list|(
name|dev
argument_list|,
name|msgs
argument_list|,
name|nitems
argument_list|(
name|msgs
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cyapa_write_bytes
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|val
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|uint16_t
name|addr
init|=
name|iicbus_get_addr
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|iic_msg
name|msgs
index|[]
init|=
block|{
block|{
name|addr
block|,
name|IIC_M_WR
operator||
name|IIC_M_NOSTOP
block|,
literal|1
block|,
operator|&
name|reg
block|}
block|,
block|{
name|addr
block|,
name|IIC_M_WR
operator||
name|IIC_M_NOSTART
block|,
name|cnt
block|,
name|__DECONST
argument_list|(
argument|uint8_t *
argument_list|,
argument|val
argument_list|)
block|}
block|, 	}
decl_stmt|;
return|return
operator|(
name|iicbus_transfer
argument_list|(
name|dev
argument_list|,
name|msgs
argument_list|,
name|nitems
argument_list|(
name|msgs
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyapa_lock
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyapa_unlock
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|CYAPA_LOCK_ASSERT
parameter_list|(
name|sc
parameter_list|)
value|mtx_assert(&(sc)->mutex, MA_OWNED);
end_define

begin_comment
comment|/*  * Notify if possible receive data ready.  Must be called  * with sc->mutex held (cyapa_lock(sc)).  */
end_comment

begin_function
specifier|static
name|void
name|cyapa_notify
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|CYAPA_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|data_signal
operator|||
operator|!
name|fifo_empty
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|)
condition|)
block|{
name|KNOTE_LOCKED
argument_list|(
operator|&
name|sc
operator|->
name|selinfo
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|blocked
operator|||
name|sc
operator|->
name|isselect
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|blocked
condition|)
block|{
name|sc
operator|->
name|blocked
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|blocked
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|isselect
condition|)
block|{
name|sc
operator|->
name|isselect
operator|=
literal|0
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|selinfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the device  */
end_comment

begin_function
specifier|static
name|int
name|init_device
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cyapa_cap
modifier|*
name|cap
parameter_list|,
name|int
name|probe
parameter_list|)
block|{
specifier|static
name|char
name|bl_exit
index|[]
init|=
block|{
literal|0x00
block|,
literal|0xff
block|,
literal|0xa5
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x07
block|}
decl_stmt|;
specifier|static
name|char
name|bl_deactivate
index|[]
init|=
block|{
literal|0x00
block|,
literal|0xff
block|,
literal|0x3b
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x07
block|}
decl_stmt|;
name|struct
name|cyapa_boot_regs
name|boot
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|retries
decl_stmt|;
comment|/* Get status */
name|error
operator|=
name|cyapa_read_bytes
argument_list|(
name|dev
argument_list|,
name|CMD_BOOT_STATUS
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|boot
argument_list|,
sizeof|sizeof
argument_list|(
name|boot
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Bootstrap the device if necessary.  It can take up to 2 seconds 	 * for the device to fully initialize. 	 */
name|retries
operator|=
literal|20
expr_stmt|;
while|while
condition|(
operator|(
name|boot
operator|.
name|stat
operator|&
name|CYAPA_STAT_RUNNING
operator|)
operator|==
literal|0
operator|&&
name|retries
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|boot
operator|.
name|boot
operator|&
name|CYAPA_BOOT_BUSY
condition|)
block|{
comment|/* Busy, wait loop. */
block|}
elseif|else
if|if
condition|(
name|boot
operator|.
name|error
operator|&
name|CYAPA_ERROR_BOOTLOADER
condition|)
block|{
comment|/* Magic */
name|error
operator|=
name|cyapa_write_bytes
argument_list|(
name|dev
argument_list|,
name|CMD_BOOT_STATUS
argument_list|,
name|bl_deactivate
argument_list|,
sizeof|sizeof
argument_list|(
name|bl_deactivate
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
else|else
block|{
comment|/* Magic */
name|error
operator|=
name|cyapa_write_bytes
argument_list|(
name|dev
argument_list|,
name|CMD_BOOT_STATUS
argument_list|,
name|bl_exit
argument_list|,
sizeof|sizeof
argument_list|(
name|bl_exit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
name|pause
argument_list|(
literal|"cyapab1"
argument_list|,
operator|(
name|hz
operator|*
literal|2
operator|)
operator|/
literal|10
argument_list|)
expr_stmt|;
operator|--
name|retries
expr_stmt|;
name|error
operator|=
name|cyapa_read_bytes
argument_list|(
name|dev
argument_list|,
name|CMD_BOOT_STATUS
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|boot
argument_list|,
sizeof|sizeof
argument_list|(
name|boot
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|retries
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to bring device out of bootstrap\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Check identity */
if|if
condition|(
name|cap
condition|)
block|{
name|error
operator|=
name|cyapa_read_bytes
argument_list|(
name|dev
argument_list|,
name|CMD_QUERY_CAPABILITIES
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cap
operator|->
name|prod_ida
argument_list|,
literal|"CYTRA"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Product ID \"%5.5s\" mismatch\n"
argument_list|,
name|cap
operator|->
name|prod_ida
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
block|}
name|error
operator|=
name|cyapa_read_bytes
argument_list|(
name|dev
argument_list|,
name|CMD_BOOT_STATUS
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|boot
argument_list|,
sizeof|sizeof
argument_list|(
name|boot
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe
operator|==
literal|0
condition|)
comment|/* official init */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cyapa init status %02x\n"
argument_list|,
name|boot
operator|.
name|stat
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|probe
operator|==
literal|2
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cyapa reset status %02x\n"
argument_list|,
name|boot
operator|.
name|stat
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|cyapa_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cyapa_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cyapa_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cyapa_cdevpriv_dtor
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|devclass_t
name|cyapa_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|cyapa_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cyapa_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cyapa_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cyapa_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cyapa_driver
init|=
block|{
literal|"cyapa"
block|,
name|cyapa_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|cyapa_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|cyapaopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|cyapaioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|cyaparead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|cyapawrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_kqfilter_t
name|cyapakqfilter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|cyapapoll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|cyapa_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|cyapaopen
block|,
operator|.
name|d_ioctl
operator|=
name|cyapaioctl
block|,
operator|.
name|d_read
operator|=
name|cyaparead
block|,
operator|.
name|d_write
operator|=
name|cyapawrite
block|,
operator|.
name|d_kqfilter
operator|=
name|cyapakqfilter
block|,
operator|.
name|d_poll
operator|=
name|cyapapoll
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|cyapa_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cyapa_cap
name|cap
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|addr
operator|=
name|iicbus_get_addr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * 0x67 - cypress trackpad on the acer c720 	 * (other devices might use other ids). 	 */
if|if
condition|(
name|addr
operator|!=
literal|0xce
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
name|init_device
argument_list|(
name|dev
argument_list|,
operator|&
name|cap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Cypress APA I2C Trackpad"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_VENDOR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cyapa_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cyapa_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cyapa_cap
name|cap
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reporting_mode
operator|=
literal|1
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|addr
operator|=
name|iicbus_get_addr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_device
argument_list|(
name|dev
argument_list|,
operator|&
name|cap
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|,
literal|"cyapa"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|knlist_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|selinfo
operator|.
name|si_note
argument_list|,
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cap_resx
operator|=
operator|(
operator|(
name|cap
operator|.
name|max_abs_xy_high
operator|<<
literal|4
operator|)
operator|&
literal|0x0F00
operator|)
operator||
name|cap
operator|.
name|max_abs_x_low
expr_stmt|;
name|sc
operator|->
name|cap_resy
operator|=
operator|(
operator|(
name|cap
operator|.
name|max_abs_xy_high
operator|<<
literal|8
operator|)
operator|&
literal|0x0F00
operator|)
operator||
name|cap
operator|.
name|max_abs_y_low
expr_stmt|;
name|sc
operator|->
name|cap_phyx
operator|=
operator|(
operator|(
name|cap
operator|.
name|phy_siz_xy_high
operator|<<
literal|4
operator|)
operator|&
literal|0x0F00
operator|)
operator||
name|cap
operator|.
name|phy_siz_x_low
expr_stmt|;
name|sc
operator|->
name|cap_phyy
operator|=
operator|(
operator|(
name|cap
operator|.
name|phy_siz_xy_high
operator|<<
literal|8
operator|)
operator|&
literal|0x0F00
operator|)
operator||
name|cap
operator|.
name|phy_siz_y_low
expr_stmt|;
name|sc
operator|->
name|cap_buttons
operator|=
name|cap
operator|.
name|buttons
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%5.5s-%6.6s-%2.2s buttons=%c%c%c res=%dx%d\n"
argument_list|,
name|cap
operator|.
name|prod_ida
argument_list|,
name|cap
operator|.
name|prod_idb
argument_list|,
name|cap
operator|.
name|prod_idc
argument_list|,
operator|(
operator|(
name|cap
operator|.
name|buttons
operator|&
name|CYAPA_FNGR_LEFT
operator|)
condition|?
literal|'L'
else|:
literal|'-'
operator|)
argument_list|,
operator|(
operator|(
name|cap
operator|.
name|buttons
operator|&
name|CYAPA_FNGR_MIDDLE
operator|)
condition|?
literal|'M'
else|:
literal|'-'
operator|)
argument_list|,
operator|(
operator|(
name|cap
operator|.
name|buttons
operator|&
name|CYAPA_FNGR_RIGHT
operator|)
condition|?
literal|'R'
else|:
literal|'-'
operator|)
argument_list|,
name|sc
operator|->
name|cap_resx
argument_list|,
name|sc
operator|->
name|cap_resy
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|5
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|iftype
operator|=
name|MOUSE_IF_PS2
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_MOUSE
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|model
operator|=
name|MOUSE_MODEL_INTELLI
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|addr
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
literal|100
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
literal|4
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|accelfactor
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|MOUSE_PS2_PACKETSIZE
expr_stmt|;
comment|/* Setup input event tracking */
name|cyapa_set_power_mode
argument_list|(
name|sc
argument_list|,
name|CMD_POWER_MODE_IDLE
argument_list|)
expr_stmt|;
comment|/* Start the polling thread */
name|kthread_add
argument_list|(
name|cyapa_poll_thread
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cyapa-poll"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devnode
operator|=
name|make_dev
argument_list|(
operator|&
name|cyapa_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"cyapa%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devnode
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cyapa_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cyapa_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Cleanup poller thread */
name|cyapa_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|poll_thread_running
condition|)
block|{
name|sc
operator|->
name|detaching
operator|=
literal|1
expr_stmt|;
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|detaching
argument_list|,
operator|&
name|sc
operator|->
name|mutex
argument_list|,
name|PCATCH
argument_list|,
literal|"cyapadet"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|cyapa_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|sc
operator|->
name|devnode
argument_list|)
expr_stmt|;
name|knlist_clear
argument_list|(
operator|&
name|sc
operator|->
name|selinfo
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seldrain
argument_list|(
operator|&
name|sc
operator|->
name|selinfo
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|sc
operator|->
name|selinfo
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * USER DEVICE I/O FUNCTIONS  */
end_comment

begin_function
specifier|static
name|int
name|cyapaopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cyapa_cdevpriv
modifier|*
name|priv
decl_stmt|;
name|int
name|error
decl_stmt|;
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|,
name|M_CYAPA
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|priv
operator|->
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|error
operator|=
name|devfs_set_cdevpriv
argument_list|(
name|priv
argument_list|,
name|cyapa_cdevpriv_dtor
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|cyapa_lock
argument_list|(
name|priv
operator|->
name|sc
argument_list|)
expr_stmt|;
name|priv
operator|->
name|sc
operator|->
name|count
operator|++
expr_stmt|;
name|cyapa_unlock
argument_list|(
name|priv
operator|->
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|priv
argument_list|,
name|M_CYAPA
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyapa_cdevpriv_dtor
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|cyapa_cdevpriv
modifier|*
name|priv
decl_stmt|;
name|priv
operator|=
name|data
expr_stmt|;
name|KASSERT
argument_list|(
name|priv
operator|!=
name|NULL
argument_list|,
operator|(
literal|"cyapa cdevpriv should not be NULL!"
operator|)
argument_list|)
expr_stmt|;
name|cyapa_lock
argument_list|(
name|priv
operator|->
name|sc
argument_list|)
expr_stmt|;
name|priv
operator|->
name|sc
operator|->
name|count
operator|--
expr_stmt|;
name|cyapa_unlock
argument_list|(
name|priv
operator|->
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|priv
argument_list|,
name|M_CYAPA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cyaparead
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|cyapa_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|didread
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
comment|/* If buffer is empty, load a new event if it is ready */
name|cyapa_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|fifo_empty
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|)
operator|&&
operator|(
name|sc
operator|->
name|data_signal
operator|||
name|sc
operator|->
name|delta_x
operator|||
name|sc
operator|->
name|delta_y
operator|||
name|sc
operator|->
name|track_but
operator|!=
name|sc
operator|->
name|reported_but
operator|)
condition|)
block|{
name|uint8_t
name|c0
decl_stmt|;
name|uint16_t
name|but
decl_stmt|;
name|int
name|delta_x
decl_stmt|;
name|int
name|delta_y
decl_stmt|;
name|int
name|delta_z
decl_stmt|;
comment|/* Accumulate delta_x, delta_y */
name|sc
operator|->
name|data_signal
operator|=
literal|0
expr_stmt|;
name|delta_x
operator|=
name|sc
operator|->
name|delta_x
expr_stmt|;
name|delta_y
operator|=
name|sc
operator|->
name|delta_y
expr_stmt|;
name|delta_z
operator|=
name|sc
operator|->
name|delta_z
expr_stmt|;
if|if
condition|(
name|delta_x
operator|>
literal|255
condition|)
block|{
name|delta_x
operator|=
literal|255
expr_stmt|;
name|sc
operator|->
name|data_signal
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delta_x
operator|<
operator|-
literal|256
condition|)
block|{
name|delta_x
operator|=
operator|-
literal|256
expr_stmt|;
name|sc
operator|->
name|data_signal
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delta_y
operator|>
literal|255
condition|)
block|{
name|delta_y
operator|=
literal|255
expr_stmt|;
name|sc
operator|->
name|data_signal
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delta_y
operator|<
operator|-
literal|256
condition|)
block|{
name|delta_y
operator|=
operator|-
literal|256
expr_stmt|;
name|sc
operator|->
name|data_signal
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delta_z
operator|>
literal|255
condition|)
block|{
name|delta_z
operator|=
literal|255
expr_stmt|;
name|sc
operator|->
name|data_signal
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delta_z
operator|<
operator|-
literal|256
condition|)
block|{
name|delta_z
operator|=
operator|-
literal|256
expr_stmt|;
name|sc
operator|->
name|data_signal
operator|=
literal|1
expr_stmt|;
block|}
name|but
operator|=
name|sc
operator|->
name|track_but
expr_stmt|;
comment|/* Adjust baseline for next calculation */
name|sc
operator|->
name|delta_x
operator|-=
name|delta_x
expr_stmt|;
name|sc
operator|->
name|delta_y
operator|-=
name|delta_y
expr_stmt|;
name|sc
operator|->
name|delta_z
operator|-=
name|delta_z
expr_stmt|;
name|sc
operator|->
name|reported_but
operator|=
name|but
expr_stmt|;
comment|/* 		 * Fuzz reduces movement jitter by introducing some 		 * hysteresis.  It operates without cumulative error so 		 * if you swish around quickly and return your finger to 		 * where it started, so to will the mouse. 		 */
name|delta_x
operator|=
name|cyapa_fuzz
argument_list|(
name|delta_x
argument_list|,
operator|&
name|sc
operator|->
name|fuzz_x
argument_list|)
expr_stmt|;
name|delta_y
operator|=
name|cyapa_fuzz
argument_list|(
name|delta_y
argument_list|,
operator|&
name|sc
operator|->
name|fuzz_y
argument_list|)
expr_stmt|;
name|delta_z
operator|=
name|cyapa_fuzz
argument_list|(
name|delta_z
argument_list|,
operator|&
name|sc
operator|->
name|fuzz_z
argument_list|)
expr_stmt|;
comment|/* 		 * Generate report 		 */
name|c0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|delta_x
operator|<
literal|0
condition|)
name|c0
operator||=
literal|0x10
expr_stmt|;
if|if
condition|(
name|delta_y
operator|<
literal|0
condition|)
name|c0
operator||=
literal|0x20
expr_stmt|;
name|c0
operator||=
literal|0x08
expr_stmt|;
if|if
condition|(
name|but
operator|&
name|CYAPA_FNGR_LEFT
condition|)
name|c0
operator||=
literal|0x01
expr_stmt|;
if|if
condition|(
name|but
operator|&
name|CYAPA_FNGR_MIDDLE
condition|)
name|c0
operator||=
literal|0x04
expr_stmt|;
if|if
condition|(
name|but
operator|&
name|CYAPA_FNGR_RIGHT
condition|)
name|c0
operator||=
literal|0x02
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
name|c0
argument_list|)
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
operator|(
name|uint8_t
operator|)
name|delta_x
argument_list|)
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
operator|(
name|uint8_t
operator|)
name|delta_y
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|zenabled
condition|)
block|{
case|case
literal|1
case|:
comment|/* Z axis all 8 bits */
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
operator|(
name|uint8_t
operator|)
name|delta_z
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 			 * Z axis low 4 bits + 4th button and 5th button 			 * (high 2 bits must be left 0).  Auto-scale 			 * delta_z to fit to avoid a wrong-direction 			 * overflow (don't try to retain the remainder). 			 */
while|while
condition|(
name|delta_z
operator|>
literal|7
operator|||
name|delta_z
operator|<
operator|-
literal|8
condition|)
name|delta_z
operator|>>=
literal|1
expr_stmt|;
name|c0
operator|=
operator|(
name|uint8_t
operator|)
name|delta_z
operator|&
literal|0x0F
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
name|c0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* basic PS/2 */
break|break;
block|}
name|cyapa_notify
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Blocking / Non-blocking */
name|error
operator|=
literal|0
expr_stmt|;
name|didread
operator|=
operator|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|ioflag
operator|&
name|IO_NDELAY
operator|)
operator|==
literal|0
operator|&&
name|fifo_empty
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|data_signal
condition|)
goto|goto
name|again
goto|;
name|sc
operator|->
name|blocked
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|blocked
argument_list|,
operator|&
name|sc
operator|->
name|mutex
argument_list|,
name|PCATCH
argument_list|,
literal|"cyablk"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
comment|/* Return any buffered data */
while|while
condition|(
name|error
operator|==
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|&&
operator|(
name|n
operator|=
name|fifo_ready
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|>
name|uio
operator|->
name|uio_resid
condition|)
name|n
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|ptr
operator|=
name|fifo_read
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cyapa_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|ptr
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|cyapa_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|fifo_read
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|didread
operator|=
literal|1
expr_stmt|;
block|}
name|cyapa_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|didread
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
block|}
return|return
operator|(
name|didread
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cyapawrite
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|cyapa_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|cmd_completed
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|uint8_t
name|c0
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|again
label|:
comment|/* 	 * Copy data from userland.  This will also cross-over the end 	 * of the fifo and keep filling. 	 */
name|cyapa_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|fifo_space
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|wfifo
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
condition|)
block|{
if|if
condition|(
name|n
operator|>
name|uio
operator|->
name|uio_resid
condition|)
name|n
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|ptr
operator|=
name|fifo_write
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|wfifo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cyapa_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|ptr
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|cyapa_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|fifo_write
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|wfifo
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* Handle commands */
name|cmd_completed
operator|=
operator|(
name|fifo_ready
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|wfifo
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
while|while
condition|(
name|fifo_ready
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|wfifo
argument_list|)
operator|&&
name|cmd_completed
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ps2_cmd
operator|==
literal|0
condition|)
name|sc
operator|->
name|ps2_cmd
operator|=
name|fifo_read_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|wfifo
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|ps2_cmd
condition|)
block|{
case|case
literal|0xE6
case|:
comment|/* SET SCALING 1:1 */
name|sc
operator|->
name|scaling_mode
operator|=
literal|0
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xE7
case|:
comment|/* SET SCALING 2:1 */
name|sc
operator|->
name|scaling_mode
operator|=
literal|1
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xE8
case|:
comment|/* SET RESOLUTION +1 byte */
if|if
condition|(
name|sc
operator|->
name|ps2_acked
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|ps2_acked
operator|=
literal|1
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fifo_ready
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|wfifo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmd_completed
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|fifo_read_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|wfifo
argument_list|)
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xE9
case|:
comment|/* 			 * STATUS REQUEST 			 * 			 * byte1: 			 *	bit 7	0 			 *	bit 6	Mode	(1=remote mode, 0=stream mode) 			 *	bit 5	Enable	(data reporting enabled) 			 *	bit 4	Scaling	(0=1:1 1=2:1) 			 *	bit 3	0 			 *	bit 2	LEFT BUTTON    (1 if pressed) 			 *	bit 1	MIDDLE BUTTON  (1 if pressed) 			 *	bit 0	RIGHT BUTTON   (1 if pressed) 			 * 			 * byte2: resolution counts/mm 			 * byte3: sample rate 			 */
name|c0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|remote_mode
condition|)
name|c0
operator||=
literal|0x40
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reporting_mode
condition|)
name|c0
operator||=
literal|0x20
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|scaling_mode
condition|)
name|c0
operator||=
literal|0x10
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|track_but
operator|&
name|CYAPA_FNGR_LEFT
condition|)
name|c0
operator||=
literal|0x04
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|track_but
operator|&
name|CYAPA_FNGR_MIDDLE
condition|)
name|c0
operator||=
literal|0x02
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|track_but
operator|&
name|CYAPA_FNGR_RIGHT
condition|)
name|c0
operator||=
literal|0x01
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
name|c0
argument_list|)
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|100
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xEA
case|:
comment|/* Set stream mode and reset movement counters */
name|sc
operator|->
name|remote_mode
operator|=
literal|0
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|delta_x
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|delta_y
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|delta_z
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0xEB
case|:
comment|/* 			 * Read Data (if in remote mode).  If not in remote 			 * mode force an event. 			 */
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|data_signal
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0xEC
case|:
comment|/* Reset Wrap Mode (ignored) */
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xEE
case|:
comment|/* Set Wrap Mode (ignored) */
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xF0
case|:
comment|/* Set Remote Mode */
name|sc
operator|->
name|remote_mode
operator|=
literal|1
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|delta_x
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|delta_y
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|delta_z
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0xF2
case|:
comment|/* 			 * Get Device ID 			 * 			 * If we send 0x00 - normal PS/2 mouse, no Z-axis 			 * 			 * If we send 0x03 - Intellimouse, data packet has 			 * an additional Z movement byte (8 bits signed). 			 * (also reset movement counters) 			 * 			 * If we send 0x04 - Now includes z-axis and the 			 * 4th and 5th mouse buttons. 			 */
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|zenabled
condition|)
block|{
case|case
literal|1
case|:
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|delta_x
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|delta_y
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|delta_z
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0xF3
case|:
comment|/* 			 * Set Sample Rate 			 * 			 * byte1: the sample rate 			 */
if|if
condition|(
name|sc
operator|->
name|ps2_acked
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|ps2_acked
operator|=
literal|1
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fifo_ready
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|wfifo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmd_completed
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|fifo_read_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|wfifo
argument_list|)
expr_stmt|;
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
comment|/* 			 * zenabling sequence: 200,100,80 (device id 0x03) 			 *		       200,200,80 (device id 0x04) 			 * 			 * We support id 0x03 (no 4th or 5th button). 			 * We support id 0x04 (w/ 4th and 5th button). 			 */
if|if
condition|(
name|sc
operator|->
name|zenabled
operator|==
literal|0
operator|&&
name|sc
operator|->
name|mode
operator|.
name|rate
operator|==
literal|200
condition|)
name|sc
operator|->
name|zenabled
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|zenabled
operator|==
operator|-
literal|1
operator|&&
name|sc
operator|->
name|mode
operator|.
name|rate
operator|==
literal|100
condition|)
name|sc
operator|->
name|zenabled
operator|=
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|zenabled
operator|==
operator|-
literal|1
operator|&&
name|sc
operator|->
name|mode
operator|.
name|rate
operator|==
literal|200
condition|)
name|sc
operator|->
name|zenabled
operator|=
operator|-
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|zenabled
operator|==
operator|-
literal|2
operator|&&
name|sc
operator|->
name|mode
operator|.
name|rate
operator|==
literal|80
condition|)
name|sc
operator|->
name|zenabled
operator|=
literal|1
expr_stmt|;
comment|/* z-axis mode */
elseif|else
if|if
condition|(
name|sc
operator|->
name|zenabled
operator|==
operator|-
literal|3
operator|&&
name|sc
operator|->
name|mode
operator|.
name|rate
operator|==
literal|80
condition|)
name|sc
operator|->
name|zenabled
operator|=
literal|2
expr_stmt|;
comment|/* z-axis+but4/5 */
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
condition|)
name|sc
operator|->
name|zenabled
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0xF4
case|:
comment|/* Enable data reporting.  Only effects stream mode. */
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reporting_mode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0xF5
case|:
comment|/* 			 * Disable data reporting.  Only effects stream mode 			 * and is ignored right now. 			 */
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reporting_mode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0xF6
case|:
comment|/* 			 * SET DEFAULTS 			 * 			 * (reset sampling rate, resolution, scaling and 			 *  enter stream mode) 			 */
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
literal|100
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
literal|4
expr_stmt|;
name|sc
operator|->
name|scaling_mode
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|reporting_mode
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|remote_mode
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|delta_x
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|delta_y
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|delta_z
operator|=
literal|0
expr_stmt|;
comment|/* signal */
break|break;
case|case
literal|0xFE
case|:
comment|/* 			 * RESEND 			 * 			 * Force a resend by guaranteeing that reported_but 			 * differs from track_but. 			 */
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|data_signal
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0xFF
case|:
comment|/* 			 * RESET 			 */
name|fifo_reset
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|)
expr_stmt|;
comment|/* should we do this? */
name|fifo_reset
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|wfifo
argument_list|)
expr_stmt|;
comment|/* should we do this? */
name|fifo_write_char
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|,
literal|0xFA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|delta_x
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|delta_y
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|delta_z
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|zenabled
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown command %02x\n"
argument_list|,
name|sc
operator|->
name|ps2_cmd
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmd_completed
condition|)
block|{
name|sc
operator|->
name|ps2_cmd
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ps2_acked
operator|=
literal|0
expr_stmt|;
block|}
name|cyapa_notify
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|cyapa_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|cmd_completed
operator|||
name|uio
operator|->
name|uio_resid
operator|)
condition|)
goto|goto
name|again
goto|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|cyapafiltdetach
parameter_list|(
name|struct
name|knote
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cyapafilt
parameter_list|(
name|struct
name|knote
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|cyapa_filtops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_detach
operator|=
name|cyapafiltdetach
block|,
operator|.
name|f_event
operator|=
name|cyapafilt
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|cyapakqfilter
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|cyapa_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|knlist
modifier|*
name|knlist
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
switch|switch
condition|(
name|kn
operator|->
name|kn_filter
condition|)
block|{
case|case
name|EVFILT_READ
case|:
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|cyapa_filtops
expr_stmt|;
name|kn
operator|->
name|kn_hook
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|knlist
operator|=
operator|&
name|sc
operator|->
name|selinfo
operator|.
name|si_note
expr_stmt|;
name|knlist_add
argument_list|(
name|knlist
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cyapapoll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cyapa_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|revents
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|revents
operator|=
literal|0
expr_stmt|;
name|cyapa_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|data_signal
operator|||
operator|!
name|fifo_empty
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|)
condition|)
name|revents
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|isselect
operator|=
literal|1
expr_stmt|;
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|sc
operator|->
name|selinfo
argument_list|)
expr_stmt|;
block|}
block|}
name|cyapa_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyapafiltdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|cyapa_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|knlist
modifier|*
name|knlist
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|cyapa_softc
operator|*
operator|)
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|knlist
operator|=
operator|&
name|sc
operator|->
name|selinfo
operator|.
name|si_note
expr_stmt|;
name|knlist_remove
argument_list|(
name|knlist
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cyapafilt
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|cyapa_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|ready
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|cyapa_softc
operator|*
operator|)
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|cyapa_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ready
operator|=
name|fifo_ready
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rfifo
argument_list|)
operator|||
name|sc
operator|->
name|data_signal
expr_stmt|;
name|cyapa_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ready
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cyapaioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cyapa_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|cyapa_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOUSE_GETHWINFO
case|:
operator|*
operator|(
name|mousehw_t
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|hw
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
literal|0
condition|)
operator|(
operator|(
name|mousehw_t
operator|*
operator|)
name|data
operator|)
operator|->
name|model
operator|=
name|MOUSE_MODEL_GENERIC
expr_stmt|;
break|break;
case|case
name|MOUSE_GETMODE
case|:
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|mode
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|data
operator|)
operator|->
name|resolution
operator|=
name|MOUSE_RES_LOW
operator|-
name|sc
operator|->
name|mode
operator|.
name|resolution
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
condition|)
block|{
case|case
literal|0
case|:
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|data
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|data
operator|)
operator|->
name|packetsize
operator|=
name|MOUSE_PS2_PACKETSIZE
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|data
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|data
operator|)
operator|->
name|packetsize
operator|=
name|MOUSE_PS2_PACKETSIZE
operator|+
literal|1
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MOUSE_GETLEVEL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|mode
operator|.
name|level
expr_stmt|;
break|break;
case|case
name|MOUSE_SETLEVEL
case|:
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|>
literal|2
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|?
literal|2
else|:
literal|0
expr_stmt|;
name|sc
operator|->
name|zenabled
operator|=
name|sc
operator|->
name|mode
operator|.
name|level
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
name|cyapa_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MAJOR SUPPORT FUNCTIONS  */
end_comment

begin_function
specifier|static
name|void
name|cyapa_poll_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cyapa_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cyapa_regs
name|regs
decl_stmt|;
name|device_t
name|bus
decl_stmt|;
comment|/* iicbus */
name|int
name|error
decl_stmt|;
name|int
name|freq
decl_stmt|;
name|int
name|isidle
decl_stmt|;
name|int
name|pstate
decl_stmt|;
name|int
name|npstate
decl_stmt|;
name|int
name|last_reset
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|freq
operator|=
name|cyapa_norm_freq
expr_stmt|;
name|isidle
operator|=
literal|0
expr_stmt|;
name|pstate
operator|=
name|CMD_POWER_MODE_IDLE
expr_stmt|;
name|last_reset
operator|=
name|ticks
expr_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|cyapa_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|poll_thread_running
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|sc
operator|->
name|detaching
condition|)
block|{
name|cyapa_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iicbus_request_bus
argument_list|(
name|bus
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|IIC_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|cyapa_read_bytes
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|CMD_DEV_STATUS
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
name|regs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|isidle
operator|=
name|cyapa_raw_input
argument_list|(
name|sc
argument_list|,
operator|&
name|regs
argument_list|,
name|freq
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * For some reason the device can crap-out.  If it 			 * drops back into bootstrap mode try to reinitialize 			 * it. 			 */
if|if
condition|(
name|cyapa_reset
operator|||
operator|(
operator|(
name|regs
operator|.
name|stat
operator|&
name|CYAPA_STAT_RUNNING
operator|)
operator|==
literal|0
operator|&&
call|(
name|unsigned
call|)
argument_list|(
name|ticks
operator|-
name|last_reset
argument_list|)
operator|>
name|TIME_TO_RESET
operator|)
condition|)
block|{
name|cyapa_reset
operator|=
literal|0
expr_stmt|;
name|last_reset
operator|=
name|ticks
expr_stmt|;
name|init_device
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|NULL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|iicbus_release_bus
argument_list|(
name|bus
argument_list|,
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
name|pause
argument_list|(
literal|"cyapw"
argument_list|,
name|hz
operator|/
name|freq
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|poll_ticks
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|freq
operator|=
name|cyapa_idle_freq
expr_stmt|;
name|npstate
operator|=
name|CMD_POWER_MODE_IDLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isidle
condition|)
block|{
name|freq
operator|=
name|cyapa_slow_freq
expr_stmt|;
name|npstate
operator|=
name|CMD_POWER_MODE_IDLE
expr_stmt|;
block|}
else|else
block|{
name|freq
operator|=
name|cyapa_norm_freq
expr_stmt|;
name|npstate
operator|=
name|CMD_POWER_MODE_FULL
expr_stmt|;
block|}
if|if
condition|(
name|pstate
operator|!=
name|npstate
condition|)
block|{
name|pstate
operator|=
name|npstate
expr_stmt|;
name|cyapa_set_power_mode
argument_list|(
name|sc
argument_list|,
name|pstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|cyapa_debug
condition|)
block|{
switch|switch
condition|(
name|pstate
condition|)
block|{
case|case
name|CMD_POWER_MODE_OFF
case|:
name|printf
argument_list|(
literal|"cyapa: power off\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_POWER_MODE_IDLE
case|:
name|printf
argument_list|(
literal|"cyapa: power idle\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_POWER_MODE_FULL
case|:
name|printf
argument_list|(
literal|"cyapa: power full\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|cyapa_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|poll_thread_running
operator|=
literal|0
expr_stmt|;
name|cyapa_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cyapa_raw_input
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_regs
modifier|*
name|regs
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
name|int
name|nfingers
decl_stmt|;
name|int
name|afingers
decl_stmt|;
comment|/* actual fingers after culling */
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|isidle
decl_stmt|;
name|int
name|thumbarea_begin
decl_stmt|;
name|int
name|seen_thumb
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|z
decl_stmt|;
name|int
name|newfinger
decl_stmt|;
name|int
name|lessfingers
decl_stmt|;
name|int
name|click_x
decl_stmt|;
name|int
name|click_y
decl_stmt|;
name|uint16_t
name|but
decl_stmt|;
comment|/* high bits used for simulated but4/but5 */
name|thumbarea_begin
operator|=
name|sc
operator|->
name|cap_resy
operator|-
operator|(
operator|(
name|sc
operator|->
name|cap_resy
operator|*
name|cyapa_thumbarea_percent
operator|)
operator|/
literal|100
operator|)
expr_stmt|;
name|click_x
operator|=
name|click_y
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the device is not running the rest of the status 	 * means something else, set fingers to 0. 	 */
if|if
condition|(
operator|(
name|regs
operator|->
name|stat
operator|&
name|CYAPA_STAT_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|regs
operator|->
name|fngr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Process fingers/movement */
name|nfingers
operator|=
name|CYAPA_FNGR_NUMFINGERS
argument_list|(
name|regs
operator|->
name|fngr
argument_list|)
expr_stmt|;
name|afingers
operator|=
name|nfingers
expr_stmt|;
if|if
condition|(
name|cyapa_debug
condition|)
block|{
name|printf
argument_list|(
literal|"stat %02x buttons %c%c%c nfngrs=%d "
argument_list|,
name|regs
operator|->
name|stat
argument_list|,
operator|(
operator|(
name|regs
operator|->
name|fngr
operator|&
name|CYAPA_FNGR_LEFT
operator|)
condition|?
literal|'L'
else|:
literal|'-'
operator|)
argument_list|,
operator|(
operator|(
name|regs
operator|->
name|fngr
operator|&
name|CYAPA_FNGR_MIDDLE
operator|)
condition|?
literal|'M'
else|:
literal|'-'
operator|)
argument_list|,
operator|(
operator|(
name|regs
operator|->
name|fngr
operator|&
name|CYAPA_FNGR_RIGHT
operator|)
condition|?
literal|'R'
else|:
literal|'-'
operator|)
argument_list|,
name|nfingers
argument_list|)
expr_stmt|;
block|}
name|seen_thumb
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|afingers
condition|;
control|)
block|{
if|if
condition|(
name|cyapa_debug
condition|)
block|{
name|printf
argument_list|(
literal|" [x=%04d y=%04d p=%d i=%d]"
argument_list|,
name|CYAPA_TOUCH_X
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
argument_list|,
name|CYAPA_TOUCH_Y
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
argument_list|,
name|CYAPA_TOUCH_P
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
argument_list|,
name|regs
operator|->
name|touch
index|[
name|i
index|]
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|CYAPA_TOUCH_Y
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
operator|>
name|thumbarea_begin
operator|&&
name|seen_thumb
operator|)
operator|||
name|CYAPA_TOUCH_P
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
operator|<
name|cyapa_minpressure
condition|)
block|{
operator|--
name|afingers
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|afingers
condition|)
block|{
name|regs
operator|->
name|touch
index|[
name|i
index|]
operator|=
name|regs
operator|->
name|touch
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
name|CYAPA_TOUCH_Y
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
operator|>
name|thumbarea_begin
condition|)
name|seen_thumb
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
name|nfingers
operator|=
name|afingers
expr_stmt|;
comment|/* Tracking for local solutions */
name|cyapa_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Track timing for finger-downs.  Used to detect false-3-finger 	 * button-down. 	 */
switch|switch
condition|(
name|afingers
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|sc
operator|->
name|track_nfingers
operator|==
literal|0
condition|)
name|sc
operator|->
name|finger1_ticks
operator|=
name|sc
operator|->
name|poll_ticks
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|sc
operator|->
name|track_nfingers
operator|<=
literal|0
condition|)
name|sc
operator|->
name|finger1_ticks
operator|=
name|sc
operator|->
name|poll_ticks
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|track_nfingers
operator|<=
literal|1
condition|)
name|sc
operator|->
name|finger2_ticks
operator|=
name|sc
operator|->
name|poll_ticks
expr_stmt|;
break|break;
case|case
literal|3
case|:
default|default:
if|if
condition|(
name|sc
operator|->
name|track_nfingers
operator|<=
literal|0
condition|)
name|sc
operator|->
name|finger1_ticks
operator|=
name|sc
operator|->
name|poll_ticks
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|track_nfingers
operator|<=
literal|1
condition|)
name|sc
operator|->
name|finger2_ticks
operator|=
name|sc
operator|->
name|poll_ticks
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|track_nfingers
operator|<=
literal|2
condition|)
name|sc
operator|->
name|finger3_ticks
operator|=
name|sc
operator|->
name|poll_ticks
expr_stmt|;
break|break;
block|}
name|newfinger
operator|=
name|sc
operator|->
name|track_nfingers
operator|<
name|afingers
expr_stmt|;
name|lessfingers
operator|=
name|sc
operator|->
name|track_nfingers
operator|>
name|afingers
expr_stmt|;
name|sc
operator|->
name|track_nfingers
operator|=
name|afingers
expr_stmt|;
comment|/* 	 * Lookup and track finger indexes in the touch[] array. 	 */
if|if
condition|(
name|afingers
operator|==
literal|0
condition|)
block|{
name|click_x
operator|=
name|sc
operator|->
name|track_x
expr_stmt|;
name|click_y
operator|=
name|sc
operator|->
name|track_y
expr_stmt|;
name|sc
operator|->
name|track_x
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|track_y
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|track_z
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|fuzz_x
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|fuzz_y
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|fuzz_z
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|touch_x
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|touch_y
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|touch_z
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|track_id
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|track_but
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The id assigned on touch can move around in the array, 		 * find it.  If that finger is lifted up, assign some other 		 * finger for mouse tracking and reset track_x and track_y 		 * to avoid a mouse jump. 		 * 		 * If>= 2 fingers are down be sure not to assign i and 		 * j to the same index. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfingers
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|track_id
operator|==
name|regs
operator|->
name|touch
index|[
name|i
index|]
operator|.
name|id
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|nfingers
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|track_x
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|track_y
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|track_z
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|CYAPA_TOUCH_Y
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
operator|>=
name|thumbarea_begin
operator|&&
name|i
operator|<
name|nfingers
condition|)
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|nfingers
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|track_id
operator|=
name|regs
operator|->
name|touch
index|[
name|i
index|]
operator|.
name|id
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|track_but
operator|||
name|CYAPA_TOUCH_Y
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
operator|>=
name|thumbarea_begin
operator|)
operator|&&
name|newfinger
operator|&&
name|afingers
operator|==
literal|2
condition|)
block|{
name|j
operator|=
name|regs
operator|->
name|touch
index|[
literal|0
index|]
operator|.
name|id
operator|==
name|sc
operator|->
name|track_id
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|CYAPA_TOUCH_Y
argument_list|(
name|regs
argument_list|,
name|j
argument_list|)
operator|<
name|thumbarea_begin
condition|)
block|{
name|i
operator|=
name|j
expr_stmt|;
name|sc
operator|->
name|track_x
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|track_y
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|track_z
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|track_id
operator|=
name|regs
operator|->
name|touch
index|[
name|i
index|]
operator|.
name|id
expr_stmt|;
block|}
block|}
block|}
comment|/* Two finger scrolling - reset after timeout */
if|if
condition|(
name|sc
operator|->
name|track_z
operator|!=
operator|-
literal|1
operator|&&
name|afingers
operator|!=
literal|2
operator|&&
operator|(
name|sc
operator|->
name|poll_ticks
operator|-
name|sc
operator|->
name|track_z_ticks
operator|)
operator|>
name|cyapa_scroll_stick_ticks
condition|)
block|{
name|sc
operator|->
name|track_z
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|track_z_ticks
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Initiate two finger scrolling */
if|if
condition|(
operator|!
operator|(
name|regs
operator|->
name|fngr
operator|&
name|CYAPA_FNGR_LEFT
operator|)
operator|&&
operator|(
operator|(
name|afingers
operator|&&
name|sc
operator|->
name|track_z
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|afingers
operator|==
literal|2
operator|&&
name|CYAPA_TOUCH_Y
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|)
operator|<
name|thumbarea_begin
operator|&&
name|CYAPA_TOUCH_Y
argument_list|(
name|regs
argument_list|,
literal|1
argument_list|)
operator|<
name|thumbarea_begin
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|afingers
operator|==
literal|2
operator|&&
operator|(
name|sc
operator|->
name|poll_ticks
operator|-
name|sc
operator|->
name|finger2_ticks
operator|)
operator|>
name|cyapa_scroll_wait_ticks
condition|)
block|{
name|z
operator|=
operator|(
name|CYAPA_TOUCH_Y
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|)
operator|+
name|CYAPA_TOUCH_Y
argument_list|(
name|regs
argument_list|,
literal|1
argument_list|)
operator|)
operator|>>
literal|1
expr_stmt|;
name|sc
operator|->
name|delta_z
operator|+=
name|z
operator|/
name|ZSCALE
operator|-
name|sc
operator|->
name|track_z
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|track_z
operator|==
operator|-
literal|1
condition|)
block|{
name|sc
operator|->
name|delta_z
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|touch_z
operator|==
operator|-
literal|1
condition|)
name|sc
operator|->
name|touch_z
operator|=
name|z
expr_stmt|;
comment|/* not used atm */
name|sc
operator|->
name|track_z
operator|=
name|z
operator|/
name|ZSCALE
expr_stmt|;
name|sc
operator|->
name|track_z_ticks
operator|=
name|sc
operator|->
name|poll_ticks
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|afingers
condition|)
block|{
comment|/* Normal pad position reporting */
name|x
operator|=
name|CYAPA_TOUCH_X
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|y
operator|=
name|CYAPA_TOUCH_Y
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|click_x
operator|=
name|x
expr_stmt|;
name|click_y
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|track_x
operator|!=
operator|-
literal|1
operator|&&
name|sc
operator|->
name|track_y
operator|<
name|thumbarea_begin
operator|&&
operator|(
name|afingers
operator|>
literal|1
operator|||
operator|(
name|sc
operator|->
name|poll_ticks
operator|-
name|sc
operator|->
name|finger1_ticks
operator|)
operator|>=
name|cyapa_move_min_ticks
operator|||
name|freq
operator|<
name|cyapa_norm_freq
operator|)
condition|)
block|{
name|sc
operator|->
name|delta_x
operator|+=
name|x
operator|-
name|sc
operator|->
name|track_x
expr_stmt|;
name|sc
operator|->
name|delta_y
operator|-=
name|y
operator|-
name|sc
operator|->
name|track_y
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|delta_x
operator|>
name|sc
operator|->
name|cap_resx
condition|)
name|sc
operator|->
name|delta_x
operator|=
name|sc
operator|->
name|cap_resx
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|delta_x
operator|<
operator|-
name|sc
operator|->
name|cap_resx
condition|)
name|sc
operator|->
name|delta_x
operator|=
operator|-
name|sc
operator|->
name|cap_resx
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|delta_y
operator|>
name|sc
operator|->
name|cap_resy
condition|)
name|sc
operator|->
name|delta_y
operator|=
name|sc
operator|->
name|cap_resy
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|delta_y
operator|<
operator|-
name|sc
operator|->
name|cap_resy
condition|)
name|sc
operator|->
name|delta_y
operator|=
operator|-
name|sc
operator|->
name|cap_resy
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|sc
operator|->
name|delta_y
argument_list|)
operator|>
name|sc
operator|->
name|cap_resy
operator|/
literal|2
operator|||
name|abs
argument_list|(
name|sc
operator|->
name|delta_x
argument_list|)
operator|>
name|sc
operator|->
name|cap_resx
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|cyapa_debug
condition|)
name|printf
argument_list|(
literal|"Detected jump by %i %i\n"
argument_list|,
name|sc
operator|->
name|delta_x
argument_list|,
name|sc
operator|->
name|delta_y
argument_list|)
expr_stmt|;
name|sc
operator|->
name|delta_x
operator|=
name|sc
operator|->
name|delta_y
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|touch_x
operator|==
operator|-
literal|1
condition|)
block|{
name|sc
operator|->
name|touch_x
operator|=
name|x
expr_stmt|;
name|sc
operator|->
name|touch_y
operator|=
name|y
expr_stmt|;
block|}
name|sc
operator|->
name|track_x
operator|=
name|x
expr_stmt|;
name|sc
operator|->
name|track_y
operator|=
name|y
expr_stmt|;
block|}
comment|/* Select finger (L = 2/3x, M = 1/3u, R = 1/3d) */
name|int
name|is_tapclick
init|=
operator|(
name|cyapa_enable_tapclick
operator|&&
name|lessfingers
operator|&&
name|afingers
operator|==
literal|0
operator|&&
name|sc
operator|->
name|poll_ticks
operator|-
name|sc
operator|->
name|finger1_ticks
operator|>=
name|cyapa_tapclick_min_ticks
operator|&&
name|sc
operator|->
name|poll_ticks
operator|-
name|sc
operator|->
name|finger1_ticks
operator|<
name|cyapa_tapclick_max_ticks
operator|)
decl_stmt|;
if|if
condition|(
name|regs
operator|->
name|fngr
operator|&
name|CYAPA_FNGR_LEFT
operator|||
name|is_tapclick
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|track_but
condition|)
block|{
name|but
operator|=
name|sc
operator|->
name|track_but
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|afingers
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|click_x
operator|<
name|sc
operator|->
name|cap_resx
operator|*
literal|2
operator|/
literal|3
condition|)
name|but
operator|=
name|CYAPA_FNGR_LEFT
expr_stmt|;
elseif|else
if|if
condition|(
name|click_y
operator|<
name|sc
operator|->
name|cap_resy
operator|/
literal|2
condition|)
name|but
operator|=
name|CYAPA_FNGR_MIDDLE
expr_stmt|;
else|else
name|but
operator|=
name|CYAPA_FNGR_RIGHT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_tapclick
condition|)
block|{
if|if
condition|(
name|click_x
operator|<
name|sc
operator|->
name|cap_resx
operator|*
literal|2
operator|/
literal|3
operator|||
name|cyapa_enable_tapclick
operator|<
literal|2
condition|)
name|but
operator|=
name|CYAPA_FNGR_LEFT
expr_stmt|;
elseif|else
if|if
condition|(
name|click_y
operator|<
name|sc
operator|->
name|cap_resy
operator|/
literal|2
operator|&&
name|cyapa_enable_tapclick
operator|>
literal|2
condition|)
name|but
operator|=
name|CYAPA_FNGR_MIDDLE
expr_stmt|;
else|else
name|but
operator|=
name|CYAPA_FNGR_RIGHT
expr_stmt|;
block|}
else|else
block|{
name|but
operator|=
name|CYAPA_FNGR_LEFT
expr_stmt|;
block|}
block|}
else|else
block|{
name|but
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Detect state change from last reported state and 	 * determine if we have gone idle. 	 */
name|sc
operator|->
name|track_but
operator|=
name|but
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|delta_x
operator|||
name|sc
operator|->
name|delta_y
operator|||
name|sc
operator|->
name|delta_z
operator|||
name|sc
operator|->
name|track_but
operator|!=
name|sc
operator|->
name|reported_but
condition|)
block|{
name|sc
operator|->
name|active_tick
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|remote_mode
operator|==
literal|0
operator|&&
name|sc
operator|->
name|reporting_mode
condition|)
name|sc
operator|->
name|data_signal
operator|=
literal|1
expr_stmt|;
name|isidle
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|ticks
operator|-
name|sc
operator|->
name|active_tick
argument_list|)
operator|>=
name|TIME_TO_IDLE
condition|)
block|{
name|sc
operator|->
name|active_tick
operator|=
name|ticks
operator|-
name|TIME_TO_IDLE
expr_stmt|;
comment|/* prevent overflow */
name|isidle
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|isidle
operator|=
literal|0
expr_stmt|;
block|}
name|cyapa_notify
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cyapa_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cyapa_debug
condition|)
name|printf
argument_list|(
literal|"%i>> %i<< %i\n"
argument_list|,
name|isidle
argument_list|,
name|sc
operator|->
name|track_id
argument_list|,
name|sc
operator|->
name|delta_y
argument_list|)
expr_stmt|;
return|return
operator|(
name|isidle
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyapa_set_power_mode
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|uint8_t
name|data
decl_stmt|;
name|device_t
name|bus
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|iicbus_request_bus
argument_list|(
name|bus
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|IIC_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|cyapa_read_bytes
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|CMD_POWER_MODE
argument_list|,
operator|&
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|data
operator|&
operator|~
literal|0xFC
operator|)
operator||
name|mode
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|cyapa_write_bytes
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|CMD_POWER_MODE
argument_list|,
operator|&
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|iicbus_release_bus
argument_list|(
name|bus
argument_list|,
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * FIFO FUNCTIONS  */
end_comment

begin_comment
comment|/*  * Returns non-zero if the fifo is empty  */
end_comment

begin_function
specifier|static
name|int
name|fifo_empty
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|CYAPA_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|fifo
operator|->
name|rindex
operator|==
name|fifo
operator|->
name|windex
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the number of characters available for reading from  * the fifo without wrapping the fifo buffer.  */
end_comment

begin_function
specifier|static
name|size_t
name|fifo_ready
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
name|CYAPA_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|n
operator|=
name|CYAPA_BUFSIZE
operator|-
operator|(
name|fifo
operator|->
name|rindex
operator|&
name|CYAPA_BUFMASK
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
call|(
name|size_t
call|)
argument_list|(
name|fifo
operator|->
name|windex
operator|-
name|fifo
operator|->
name|rindex
argument_list|)
condition|)
name|n
operator|=
call|(
name|size_t
call|)
argument_list|(
name|fifo
operator|->
name|windex
operator|-
name|fifo
operator|->
name|rindex
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a read pointer into the fifo and then bumps  * rindex.  The FIFO must have at least 'n' characters in  * it.  The value (n) can cause the index to wrap but users  * of the buffer should never supply a value for (n) that wraps  * the buffer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fifo_read
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|CYAPA_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
operator|(
name|CYAPA_BUFSIZE
operator|-
operator|(
name|fifo
operator|->
name|rindex
operator|&
name|CYAPA_BUFMASK
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"fifo_read: overflow\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|fifo
operator|->
name|buf
operator|)
return|;
block|}
name|ptr
operator|=
name|fifo
operator|->
name|buf
operator|+
operator|(
name|fifo
operator|->
name|rindex
operator|&
name|CYAPA_BUFMASK
operator|)
expr_stmt|;
name|fifo
operator|->
name|rindex
operator|+=
name|n
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|fifo_read_char
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|uint8_t
name|c
decl_stmt|;
name|CYAPA_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fifo
operator|->
name|rindex
operator|==
name|fifo
operator|->
name|windex
condition|)
block|{
name|printf
argument_list|(
literal|"fifo_read_char: overflow\n"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|fifo
operator|->
name|buf
index|[
name|fifo
operator|->
name|rindex
operator|&
name|CYAPA_BUFMASK
index|]
expr_stmt|;
operator|++
name|fifo
operator|->
name|rindex
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write a character to the FIFO.  The character will be discarded  * if the FIFO is full.  */
end_comment

begin_function
specifier|static
name|void
name|fifo_write_char
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|,
name|uint8_t
name|c
parameter_list|)
block|{
name|CYAPA_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fifo
operator|->
name|windex
operator|-
name|fifo
operator|->
name|rindex
operator|<
name|CYAPA_BUFSIZE
condition|)
block|{
name|fifo
operator|->
name|buf
index|[
name|fifo
operator|->
name|windex
operator|&
name|CYAPA_BUFMASK
index|]
operator|=
name|c
expr_stmt|;
operator|++
name|fifo
operator|->
name|windex
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the amount of space available for writing without wrapping  * the fifo.  */
end_comment

begin_function
specifier|static
name|size_t
name|fifo_space
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
name|CYAPA_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|n
operator|=
name|CYAPA_BUFSIZE
operator|-
operator|(
name|fifo
operator|->
name|windex
operator|&
name|CYAPA_BUFMASK
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
call|(
name|size_t
call|)
argument_list|(
name|CYAPA_BUFSIZE
operator|-
operator|(
name|fifo
operator|->
name|windex
operator|-
name|fifo
operator|->
name|rindex
operator|)
argument_list|)
condition|)
name|n
operator|=
call|(
name|size_t
call|)
argument_list|(
name|CYAPA_BUFSIZE
operator|-
operator|(
name|fifo
operator|->
name|windex
operator|-
name|fifo
operator|->
name|rindex
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|fifo_write
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|CYAPA_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|fifo
operator|->
name|buf
operator|+
operator|(
name|fifo
operator|->
name|windex
operator|&
name|CYAPA_BUFMASK
operator|)
expr_stmt|;
name|fifo
operator|->
name|windex
operator|+=
name|n
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fifo_reset
parameter_list|(
name|struct
name|cyapa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cyapa_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|CYAPA_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fifo
operator|->
name|rindex
operator|=
literal|0
expr_stmt|;
name|fifo
operator|->
name|windex
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fuzz handling  */
end_comment

begin_function
specifier|static
name|int
name|cyapa_fuzz
parameter_list|(
name|int
name|delta
parameter_list|,
name|int
modifier|*
name|fuzzp
parameter_list|)
block|{
name|int
name|fuzz
decl_stmt|;
name|fuzz
operator|=
operator|*
name|fuzzp
expr_stmt|;
if|if
condition|(
name|fuzz
operator|>=
literal|0
operator|&&
name|delta
operator|<
literal|0
condition|)
block|{
operator|++
name|delta
expr_stmt|;
operator|--
name|fuzz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fuzz
operator|<=
literal|0
operator|&&
name|delta
operator|>
literal|0
condition|)
block|{
operator|--
name|delta
expr_stmt|;
operator|++
name|fuzz
expr_stmt|;
block|}
operator|*
name|fuzzp
operator|=
name|fuzz
expr_stmt|;
return|return
operator|(
name|delta
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cyapa
argument_list|,
name|iicbus
argument_list|,
name|cyapa_driver
argument_list|,
name|cyapa_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|cyapa
argument_list|,
name|iicbus
argument_list|,
name|IICBUS_MINVER
argument_list|,
name|IICBUS_PREFVER
argument_list|,
name|IICBUS_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cyapa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

