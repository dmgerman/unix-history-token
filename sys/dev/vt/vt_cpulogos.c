begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Conrad Meyer<cse.cem@gmail.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/terminal.h>
end_include

begin_include
include|#
directive|include
file|<dev/vt/vt.h>
end_include

begin_decl_stmt
specifier|extern
specifier|const
name|unsigned
name|char
name|vt_beastie_vga16
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|unsigned
name|char
name|vt_beastie2_vga16
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|unsigned
name|char
name|vt_orb_vga16
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout
name|vt_splash_cpu_callout
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|unsigned
name|char
name|vt_vga2bsd
parameter_list|(
name|unsigned
name|char
name|vga
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|lut
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
comment|/* 1 and 4 swap */
literal|2
block|,
literal|6
block|,
comment|/* 3 and 6 swap */
literal|1
block|,
comment|/* 4 and 1 swap */
literal|5
block|,
literal|3
block|,
comment|/* 6 and 3 swap */
literal|7
block|, 	}
decl_stmt|;
name|unsigned
name|int
name|bright
decl_stmt|;
name|bright
operator|=
operator|(
name|vga
operator|&
literal|0x8
operator|)
expr_stmt|;
return|return
operator|(
name|lut
index|[
name|vga
operator|&
literal|0x7
index|]
operator||
name|bright
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vt_draw_2_vga16_px
parameter_list|(
name|struct
name|vt_device
modifier|*
name|vd
parameter_list|,
name|vt_axis_t
name|x
parameter_list|,
name|vt_axis_t
name|y
parameter_list|,
name|unsigned
name|char
name|color
parameter_list|)
block|{
name|vd
operator|->
name|vd_driver
operator|->
name|vd_setpixel
argument_list|(
name|vd
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|vt_vga2bsd
argument_list|(
name|color
operator|>>
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_driver
operator|->
name|vd_setpixel
argument_list|(
name|vd
argument_list|,
name|x
operator|+
literal|1
argument_list|,
name|y
argument_list|,
name|vt_vga2bsd
argument_list|(
name|color
operator|&
literal|0xf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vt_draw_1_logo
parameter_list|(
name|struct
name|vt_device
modifier|*
name|vd
parameter_list|,
name|vt_axis_t
name|top
parameter_list|,
name|vt_axis_t
name|left
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
name|rle_sent
init|=
literal|0x16
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|xy
decl_stmt|,
name|run
decl_stmt|,
name|runcolor
decl_stmt|,
name|i
decl_stmt|;
switch|switch
condition|(
name|vt_splash_cpu_style
condition|)
block|{
case|case
name|VT_LOGOS_DRAW_ALT_BEASTIE
case|:
name|data
operator|=
name|vt_beastie2_vga16
expr_stmt|;
break|break;
case|case
name|VT_LOGOS_DRAW_ORB
case|:
name|data
operator|=
name|vt_orb_vga16
expr_stmt|;
break|break;
case|case
name|VT_LOGOS_DRAW_BEASTIE
case|:
comment|/* FALLTHROUGH */
default|default:
name|data
operator|=
name|vt_beastie_vga16
expr_stmt|;
break|break;
block|}
comment|/* Decode basic RLE (gets us to 30-40% of uncompressed data size): */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|xy
operator|=
literal|0
init|;
name|xy
operator|<
name|vt_logo_sprite_height
operator|*
name|vt_logo_sprite_width
condition|;
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|==
name|rle_sent
condition|)
block|{
name|runcolor
operator|=
name|data
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|run
operator|=
name|data
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
for|for
control|(
init|;
name|run
condition|;
name|run
operator|--
operator|,
name|xy
operator|+=
literal|2
control|)
name|vt_draw_2_vga16_px
argument_list|(
name|vd
argument_list|,
name|left
operator|+
operator|(
name|xy
operator|%
name|vt_logo_sprite_width
operator|)
argument_list|,
name|top
operator|+
operator|(
name|xy
operator|/
name|vt_logo_sprite_width
operator|)
argument_list|,
name|runcolor
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|vt_draw_2_vga16_px
argument_list|(
name|vd
argument_list|,
name|left
operator|+
operator|(
name|xy
operator|%
name|vt_logo_sprite_width
operator|)
argument_list|,
name|top
operator|+
operator|(
name|xy
operator|/
name|vt_logo_sprite_width
operator|)
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|xy
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|vtterm_draw_cpu_logos
parameter_list|(
name|struct
name|vt_device
modifier|*
name|vd
parameter_list|)
block|{
name|unsigned
name|int
name|ncpu
decl_stmt|,
name|i
decl_stmt|;
name|vt_axis_t
name|left
decl_stmt|;
if|if
condition|(
name|vt_splash_ncpu
condition|)
name|ncpu
operator|=
name|vt_splash_ncpu
expr_stmt|;
else|else
block|{
name|ncpu
operator|=
name|mp_ncpus
expr_stmt|;
if|if
condition|(
name|ncpu
operator|<
literal|1
condition|)
name|ncpu
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vd_driver
operator|->
name|vd_drawrect
condition|)
name|vd
operator|->
name|vd_driver
operator|->
name|vd_drawrect
argument_list|(
name|vd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|vd
operator|->
name|vd_width
argument_list|,
name|vt_logo_sprite_height
argument_list|,
literal|1
argument_list|,
name|TC_BLACK
argument_list|)
expr_stmt|;
comment|/* 	 * Blank is okay because we only ever draw beasties on full screen 	 * refreshes. 	 */
elseif|else
if|if
condition|(
name|vd
operator|->
name|vd_driver
operator|->
name|vd_blank
condition|)
name|vd
operator|->
name|vd_driver
operator|->
name|vd_blank
argument_list|(
name|vd
argument_list|,
name|TC_BLACK
argument_list|)
expr_stmt|;
name|ncpu
operator|=
name|MIN
argument_list|(
name|ncpu
argument_list|,
name|vd
operator|->
name|vd_width
operator|/
name|vt_logo_sprite_width
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|left
operator|=
literal|0
init|;
name|i
operator|<
name|ncpu
condition|;
name|left
operator|+=
name|vt_logo_sprite_width
operator|,
name|i
operator|++
control|)
name|vt_draw_1_logo
argument_list|(
name|vd
argument_list|,
literal|0
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vt_fini_logos
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|struct
name|vt_device
modifier|*
name|vd
decl_stmt|;
name|struct
name|vt_window
modifier|*
name|vw
decl_stmt|;
name|struct
name|terminal
modifier|*
name|tm
decl_stmt|;
name|struct
name|vt_font
modifier|*
name|vf
decl_stmt|;
name|struct
name|winsize
name|wsz
decl_stmt|;
name|term_pos_t
name|size
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|vt_draw_logo_cpus
condition|)
return|return;
if|if
condition|(
operator|!
name|vty_enabled
argument_list|(
name|VTY_VT
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|vt_splash_cpu
condition|)
return|return;
name|vd
operator|=
operator|&
name|vt_consdev
expr_stmt|;
name|VT_LOCK
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|->
name|vd_flags
operator|&
operator|(
name|VDF_DEAD
operator||
name|VDF_TEXTMODE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|VT_UNLOCK
argument_list|(
name|vd
argument_list|)
expr_stmt|;
return|return;
block|}
name|vt_draw_logo_cpus
operator|=
literal|0
expr_stmt|;
name|VT_UNLOCK
argument_list|(
name|vd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VT_MAXWINDOWS
condition|;
name|i
operator|++
control|)
block|{
name|vw
operator|=
name|vd
operator|->
name|vd_windows
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vw
operator|==
name|NULL
condition|)
continue|continue;
name|tm
operator|=
name|vw
operator|->
name|vw_terminal
expr_stmt|;
name|vf
operator|=
name|vw
operator|->
name|vw_font
expr_stmt|;
if|if
condition|(
name|vf
operator|==
name|NULL
condition|)
continue|continue;
name|vt_termsize
argument_list|(
name|vd
argument_list|,
name|vf
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|vt_winsize
argument_list|(
name|vd
argument_list|,
name|vf
argument_list|,
operator|&
name|wsz
argument_list|)
expr_stmt|;
comment|/* Resize screen buffer and terminal. */
name|terminal_mute
argument_list|(
name|tm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vtbuf_grow
argument_list|(
operator|&
name|vw
operator|->
name|vw_buf
argument_list|,
operator|&
name|size
argument_list|,
name|vw
operator|->
name|vw_buf
operator|.
name|vb_history_size
argument_list|)
expr_stmt|;
name|terminal_set_winsize_blank
argument_list|(
name|tm
argument_list|,
operator|&
name|wsz
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|terminal_set_cursor
argument_list|(
name|tm
argument_list|,
operator|&
name|vw
operator|->
name|vw_buf
operator|.
name|vb_cursor
argument_list|)
expr_stmt|;
name|terminal_mute
argument_list|(
name|tm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VT_LOCK
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vt_compute_drawable_area
argument_list|(
name|vw
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_curwindow
operator|==
name|vw
condition|)
block|{
name|vd
operator|->
name|vd_flags
operator||=
name|VDF_INVALID
expr_stmt|;
name|vt_resume_flush_timer
argument_list|(
name|vd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|VT_UNLOCK
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vt_init_logos
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|vt_device
modifier|*
name|vd
decl_stmt|;
name|struct
name|vt_window
modifier|*
name|vw
decl_stmt|;
name|struct
name|terminal
modifier|*
name|tm
decl_stmt|;
name|struct
name|vt_font
modifier|*
name|vf
decl_stmt|;
name|struct
name|winsize
name|wsz
decl_stmt|;
name|term_pos_t
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|vty_enabled
argument_list|(
name|VTY_VT
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|vt_splash_cpu
condition|)
return|return;
name|tm
operator|=
operator|&
name|vt_consterm
expr_stmt|;
name|vw
operator|=
name|tm
operator|->
name|tm_softc
expr_stmt|;
if|if
condition|(
name|vw
operator|==
name|NULL
condition|)
return|return;
name|vd
operator|=
name|vw
operator|->
name|vw_device
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
return|return;
name|vf
operator|=
name|vw
operator|->
name|vw_font
expr_stmt|;
if|if
condition|(
name|vf
operator|==
name|NULL
condition|)
return|return;
name|VT_LOCK
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|vd
operator|->
name|vd_flags
operator|&
name|VDF_INITIALIZED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"vd %p not initialized"
operator|,
name|vd
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|->
name|vd_flags
operator|&
operator|(
name|VDF_DEAD
operator||
name|VDF_TEXTMODE
operator|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|vd
operator|->
name|vd_height
operator|<=
name|vt_logo_sprite_height
condition|)
goto|goto
name|out
goto|;
name|vt_draw_logo_cpus
operator|=
literal|1
expr_stmt|;
name|VT_UNLOCK
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vt_termsize
argument_list|(
name|vd
argument_list|,
name|vf
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|vt_winsize
argument_list|(
name|vd
argument_list|,
name|vf
argument_list|,
operator|&
name|wsz
argument_list|)
expr_stmt|;
comment|/* Resize screen buffer and terminal. */
name|terminal_mute
argument_list|(
name|tm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vtbuf_grow
argument_list|(
operator|&
name|vw
operator|->
name|vw_buf
argument_list|,
operator|&
name|size
argument_list|,
name|vw
operator|->
name|vw_buf
operator|.
name|vb_history_size
argument_list|)
expr_stmt|;
name|terminal_set_winsize_blank
argument_list|(
name|tm
argument_list|,
operator|&
name|wsz
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|terminal_set_cursor
argument_list|(
name|tm
argument_list|,
operator|&
name|vw
operator|->
name|vw_buf
operator|.
name|vb_cursor
argument_list|)
expr_stmt|;
name|terminal_mute
argument_list|(
name|tm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VT_LOCK
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vt_compute_drawable_area
argument_list|(
name|vw
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_curwindow
operator|==
name|vw
condition|)
block|{
name|vd
operator|->
name|vd_flags
operator||=
name|VDF_INVALID
expr_stmt|;
name|vt_resume_flush_timer
argument_list|(
name|vd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|callout_init
argument_list|(
operator|&
name|vt_splash_cpu_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|vt_splash_cpu_callout
argument_list|,
name|vt_splash_cpu_duration
operator|*
name|hz
argument_list|,
name|vt_fini_logos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|out
label|:
name|VT_UNLOCK
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|vt_logos
argument_list|,
name|SI_SUB_CPU
operator|+
literal|1
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|vt_init_logos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

