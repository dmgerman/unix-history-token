begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2014, LSI Corp.  * All rights reserved.  * Author: Marian Choy  * Support: freebsdraid@lsi.com  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  * 3. Neither the name of the<ORGANIZATION> nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  * */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"dev/mrsas/mrsas.h"
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* XXX for pcpu.h */
end_comment

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_comment
comment|/* XXX for PCPU_GET */
end_comment

begin_define
define|#
directive|define
name|smp_processor_id
parameter_list|()
value|PCPU_GET(cpuid)
end_define

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
name|int
name|mrsas_cam_attach
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//int mrsas_ldio_inq(union ccb *ccb);
end_comment

begin_function_decl
name|int
name|mrsas_ldio_inq
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_bus_scan
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_bus_scan_sim
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_map_request
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_build_ldio
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_build_dcdb
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_setup_io
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|device_id
parameter_list|,
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_xpt_freeze
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_xpt_release
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_cam_detach
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_release_mpt_cmd
parameter_list|(
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_unmap_request
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_cmd_done
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_fire_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|req_desc_lo
parameter_list|,
name|u_int32_t
name|req_desc_hi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_set_pd_lba
parameter_list|(
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
parameter_list|,
name|u_int8_t
name|cdb_len
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|local_map_ptr
parameter_list|,
name|u_int32_t
name|ref_tag
parameter_list|,
name|u_int32_t
name|ld_block_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_freeze_simq
parameter_list|(
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_scsiio_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_data_load_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|mrsas_startio
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|mrsas_mpt_cmd
modifier|*
name|mrsas_get_mpt_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|mrsas_get_request_desc
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int16_t
name|MR_TargetIdToLdGet
parameter_list|(
name|u_int32_t
name|ldTgtId
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int32_t
name|MR_LdBlockSizeGet
parameter_list|(
name|u_int32_t
name|ldTgtId
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mrsas_isr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mrsas_aen_handler
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int8_t
name|MR_BuildRaidContext
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|RAID_CONTEXT
modifier|*
name|pRAID_Context
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int16_t
name|MR_LdSpanArrayGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int32_t
name|span
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int16_t
name|mrsas_get_updated_dev_handle
parameter_list|(
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int8_t
name|megasas_get_best_arm
parameter_list|(
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|,
name|u_int8_t
name|arm
parameter_list|,
name|u_int64_t
name|block
parameter_list|,
name|u_int32_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * mrsas_cam_attach:        Main entry to CAM subsystem   * input:                   Adapter instance soft state   *  * This function is called from mrsas_attach() during initialization  * to perform SIM allocations and XPT bus registration.  If the kernel   * version is 7.4 or earlier, it would also initiate a bus scan.  */
end_comment

begin_function
name|int
name|mrsas_cam_attach
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|mrsas_cam_depth
decl_stmt|;
name|mrsas_cam_depth
operator|=
name|sc
operator|->
name|max_fw_cmds
operator|-
name|MRSAS_INTERNAL_CMDS
expr_stmt|;
if|if
condition|(
operator|(
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|mrsas_cam_depth
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate SIM queue\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*       * Create SIM for bus 0 and register, also create path       */
name|sc
operator|->
name|sim_0
operator|=
name|cam_sim_alloc
argument_list|(
name|mrsas_action
argument_list|,
name|mrsas_poll
argument_list|,
literal|"mrsas"
argument_list|,
name|sc
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sim_lock
argument_list|,
name|mrsas_cam_depth
argument_list|,
name|mrsas_cam_depth
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sim_0
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot register SIM\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Initialize taskqueue for Event Handling */
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|ev_task
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mrsas_aen_handler
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ev_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"mrsas_taskq"
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|ev_tq
argument_list|)
expr_stmt|;
comment|/* Run the task queue with lowest priority */
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|ev_tq
argument_list|,
literal|1
argument_list|,
literal|255
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|,
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|// passing true frees the devq
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|sc
operator|->
name|path_0
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|// passing true will free the devq
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
comment|/*       * Create SIM for bus 1 and register, also create path       */
name|sc
operator|->
name|sim_1
operator|=
name|cam_sim_alloc
argument_list|(
name|mrsas_action
argument_list|,
name|mrsas_poll
argument_list|,
literal|"mrsas"
argument_list|,
name|sc
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sim_lock
argument_list|,
name|mrsas_cam_depth
argument_list|,
name|mrsas_cam_depth
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sim_1
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot register SIM\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|,
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|1
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|// passing true frees the devq
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|sc
operator|->
name|path_1
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<=
literal|704000
operator|)
if|if
condition|(
name|mrsas_bus_scan
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Error in bus scan.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_cam_detach:        De-allocates and teardown CAM    * input:                   Adapter instance soft state   *  * De-registers and frees the paths and SIMs.   */
end_comment

begin_function
name|void
name|mrsas_cam_detach
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|ev_tq
operator|!=
name|NULL
condition|)
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|ev_tq
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|path_0
condition|)
name|xpt_free_path
argument_list|(
name|sc
operator|->
name|path_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sim_0
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|path_1
condition|)
name|xpt_free_path
argument_list|(
name|sc
operator|->
name|path_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sim_1
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_action:            SIM callback entry point     * input:                   pointer to SIM   *                          pointer to CAM Control Block  *  * This function processes CAM subsystem requests. The type of request is  * stored in ccb->ccb_h.func_code.  The preprocessor #ifdef is necessary  * because ccb->cpi.maxio is not supported for FreeBSD version 7.4 or   * earlier.     */
end_comment

begin_function
specifier|static
name|void
name|mrsas_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|mrsas_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
decl_stmt|;
name|u_int32_t
name|device_id
decl_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
block|{
name|device_id
operator|=
name|ccb_h
operator|->
name|target_id
expr_stmt|;
comment|/*               * bus 0 is LD, bus 1 is for system-PD               */
if|if
condition|(
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
operator|==
literal|1
operator|&&
name|sc
operator|->
name|pd_list
index|[
name|device_id
index|]
operator|.
name|driveState
operator|!=
name|MR_PD_STATE_SYSTEM
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mrsas_startio
argument_list|(
name|sc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|XPT_ABORT
case|:
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
block|{
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|ccb
operator|->
name|cts
operator|.
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|valid
operator|=
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|proto_specific
operator|.
name|scsi
operator|.
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|proto_specific
operator|.
name|scsi
operator|.
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
block|{
name|ccb
operator|->
name|cpi
operator|.
name|version_num
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|hba_inquiry
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|max_lun
operator|=
name|MRSAS_SCSI_MAX_LUNS
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|initiator_id
operator|=
name|MRSAS_SCSI_INITIATOR_ID
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|base_transfer_speed
operator|=
literal|150000
expr_stmt|;
name|strncpy
argument_list|(
name|ccb
operator|->
name|cpi
operator|.
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ccb
operator|->
name|cpi
operator|.
name|hba_vid
argument_list|,
literal|"LSI"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ccb
operator|->
name|cpi
operator|.
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|cpi
operator|.
name|bus_id
operator|==
literal|0
condition|)
name|ccb
operator|->
name|cpi
operator|.
name|max_target
operator|=
name|MRSAS_MAX_PD
operator|-
literal|1
expr_stmt|;
else|else
name|ccb
operator|->
name|cpi
operator|.
name|max_target
operator|=
name|MRSAS_MAX_LD_IDS
operator|-
literal|1
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|704000
operator|)
name|ccb
operator|->
name|cpi
operator|.
name|maxio
operator|=
name|MRSAS_MAX_IO_SIZE
expr_stmt|;
endif|#
directive|endif
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * mrsas_scsiio_timeout         Callback function for IO timed out  * input:                       mpt command context  *  * This function will execute after timeout value  * provided by ccb header from CAM layer, if timer expires.  * Driver will run timer for all DCDM and LDIO comming from CAM layer.  * This function is callback function for IO timeout and it runs in  * no-sleep context. Set do_timedout_reset in Adapter context so that  * it will execute OCR/Kill adpter from ocr_thread context.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_scsiio_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mrsas_softc
modifier|*
name|sc
decl_stmt|;
name|cmd
operator|=
operator|(
expr|struct
name|mrsas_mpt_cmd
operator|*
operator|)
name|data
expr_stmt|;
name|sc
operator|=
name|cmd
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|ccb_ptr
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"command timeout with NULL ccb\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Below callout is dummy entry so that it will be      * cancelled from mrsas_cmd_done(). Now Controller will      * go to OCR/Kill Adapter based on OCR enable/disable      * property of Controller from ocr_thread context.      */
name|callout_reset
argument_list|(
operator|&
name|cmd
operator|->
name|cm_callout
argument_list|,
operator|(
literal|600000
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|,
name|mrsas_scsiio_timeout
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|do_timedout_reset
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ocr_thread_active
condition|)
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|ocr_chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_startio:           SCSI IO entry point     * input:                   Adapter instance soft state   *                          pointer to CAM Control Block  *  * This function is the SCSI IO entry point and it initiates IO processing.   * It copies the IO and depending if the IO is read/write or inquiry, it would   * call mrsas_build_ldio() or mrsas_build_dcdb(), respectively.  It returns  * 0 if the command is sent to firmware successfully, otherwise it returns 1.  */
end_comment

begin_function
specifier|static
name|int32_t
name|mrsas_startio
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|)
decl_stmt|;
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|req_desc
decl_stmt|;
if|if
condition|(
operator|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|)
operator|==
name|SYNCHRONIZE_CACHE
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ccb_h
operator|->
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|cmd
operator|=
name|mrsas_get_mpt_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|ccb_h
operator|->
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_IN
condition|)
name|cmd
operator|->
name|flags
operator||=
name|MRSAS_DIR_IN
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_OUT
condition|)
name|cmd
operator|->
name|flags
operator||=
name|MRSAS_DIR_OUT
expr_stmt|;
block|}
else|else
name|cmd
operator|->
name|flags
operator|=
name|MRSAS_DIR_NONE
expr_stmt|;
comment|/* no data */
comment|/* For FreeBSD 10.0 and higher */
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|1000000
operator|)
comment|/*  *      * XXX We don't yet support physical addresses here.  */
switch|switch
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_MASK
operator|)
condition|)
block|{
case|case
name|CAM_DATA_PADDR
case|:
case|case
name|CAM_DATA_SG_PADDR
case|:
name|printf
argument_list|(
literal|"%s: physical addresses not supported\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|CAM_DATA_SG
case|:
name|printf
argument_list|(
literal|"%s: scatter gather is not supported\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|CAM_DATA_VADDR
case|:
if|if
condition|(
name|csio
operator|->
name|dxfer_len
operator|>
name|MRSAS_MAX_IO_SIZE
condition|)
block|{
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_TOO_BIG
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|cmd
operator|->
name|length
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|length
condition|)
name|cmd
operator|->
name|data
operator|=
name|csio
operator|->
name|data_ptr
expr_stmt|;
break|break;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
condition|)
block|{
comment|//Virtual data address
if|if
condition|(
operator|!
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
condition|)
block|{
if|if
condition|(
name|csio
operator|->
name|dxfer_len
operator|>
name|MRSAS_MAX_IO_SIZE
condition|)
block|{
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_TOO_BIG
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|cmd
operator|->
name|length
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|length
condition|)
name|cmd
operator|->
name|data
operator|=
name|csio
operator|->
name|data_ptr
expr_stmt|;
block|}
else|else
block|{
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|//Data addresses are physical.
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
comment|/* save ccb ptr */
name|cmd
operator|->
name|ccb_ptr
operator|=
name|ccb
expr_stmt|;
name|req_desc
operator|=
name|mrsas_get_request_desc
argument_list|(
name|sc
argument_list|,
operator|(
name|cmd
operator|->
name|index
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req_desc
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot get request_descriptor.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|memset
argument_list|(
name|req_desc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MRSAS_REQUEST_DESCRIPTOR_UNION
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|=
name|req_desc
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|cmd
operator|->
name|io_request
operator|->
name|CDB
operator|.
name|CDB32
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|cmd
operator|->
name|io_request
operator|->
name|CDB
operator|.
name|CDB32
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrsas_ldio_inq
argument_list|(
name|sim
argument_list|,
name|ccb
argument_list|)
condition|)
block|{
if|if
condition|(
name|mrsas_build_ldio
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|ccb
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Build LDIO failed.\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mrsas_build_dcdb
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|ccb
argument_list|,
name|sim
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Build DCDB failed.\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|==
name|MRSAS_DIR_IN
condition|)
comment|//from device
name|cmd
operator|->
name|io_request
operator|->
name|Control
operator||=
name|MPI2_SCSIIO_CONTROL_READ
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|flags
operator|==
name|MRSAS_DIR_OUT
condition|)
comment|//to device
name|cmd
operator|->
name|io_request
operator|->
name|Control
operator||=
name|MPI2_SCSIIO_CONTROL_WRITE
expr_stmt|;
name|cmd
operator|->
name|io_request
operator|->
name|SGLFlags
operator|=
name|MPI2_SGE_FLAGS_64_BIT_ADDRESSING
expr_stmt|;
name|cmd
operator|->
name|io_request
operator|->
name|SGLOffset0
operator|=
name|offsetof
argument_list|(
name|MRSAS_RAID_SCSI_IO_REQUEST
argument_list|,
name|SGL
argument_list|)
operator|/
literal|4
expr_stmt|;
name|cmd
operator|->
name|io_request
operator|->
name|SenseBufferLowAddress
operator|=
name|cmd
operator|->
name|sense_phys_addr
expr_stmt|;
name|cmd
operator|->
name|io_request
operator|->
name|SenseBufferLength
operator|=
name|MRSAS_SCSI_SENSE_BUFFERSIZE
expr_stmt|;
name|req_desc
operator|=
name|cmd
operator|->
name|request_desc
expr_stmt|;
name|req_desc
operator|->
name|SCSIIO
operator|.
name|SMID
operator|=
name|cmd
operator|->
name|index
expr_stmt|;
comment|/*      * Start timer for IO timeout. Default timeout value is 90 second.      */
name|callout_reset
argument_list|(
operator|&
name|cmd
operator|->
name|cm_callout
argument_list|,
operator|(
name|sc
operator|->
name|mrsas_io_timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|,
name|mrsas_scsiio_timeout
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|sc
operator|->
name|fw_outstanding
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|sc
operator|->
name|fw_outstanding
argument_list|)
operator|>
name|sc
operator|->
name|io_cmds_highwater
condition|)
name|sc
operator|->
name|io_cmds_highwater
operator|++
expr_stmt|;
name|mrsas_fire_cmd
argument_list|(
name|sc
argument_list|,
name|req_desc
operator|->
name|addr
operator|.
name|u
operator|.
name|low
argument_list|,
name|req_desc
operator|->
name|addr
operator|.
name|u
operator|.
name|high
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|done
label|:
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_ldio_inq:           Determines if IO is read/write or inquiry     * input:                        pointer to CAM Control Block  *  * This function determines if the IO is read/write or inquiry.  It returns a  * 1 if the IO is read/write and 0 if it is inquiry.  */
end_comment

begin_function
name|int
name|mrsas_ldio_inq
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|)
decl_stmt|;
if|if
condition|(
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
condition|)
block|{
case|case
name|READ_10
case|:
case|case
name|WRITE_10
case|:
case|case
name|READ_12
case|:
case|case
name|WRITE_12
case|:
case|case
name|READ_6
case|:
case|case
name|WRITE_6
case|:
case|case
name|READ_16
case|:
case|case
name|WRITE_16
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * mrsas_get_mpt_cmd:            Get a cmd from free command pool    * input:                        Adapter instance soft state   *  * This function removes an MPT command from the command free list and   * initializes it.  */
end_comment

begin_function
name|struct
name|mrsas_mpt_cmd
modifier|*
name|mrsas_get_mpt_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
init|=
name|NULL
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mpt_cmd_pool_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|mrsas_mpt_cmd_list_head
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|mrsas_mpt_cmd_list_head
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|mrsas_mpt_cmd_list_head
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|cmd
operator|->
name|io_request
argument_list|,
literal|0
argument_list|,
name|MRSAS_MPI2_RAID_DEFAULT_IO_FRAME_SIZE
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|cmd
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|error_code
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|load_balance
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|ccb_ptr
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mpt_cmd_pool_lock
argument_list|)
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_release_mpt_cmd:      Return a cmd to free command pool    * input:                      Command packet for return to free command pool   *  * This function returns an MPT command to the free command list.  */
end_comment

begin_function
name|void
name|mrsas_release_mpt_cmd
parameter_list|(
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
init|=
name|cmd
operator|->
name|sc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mpt_cmd_pool_lock
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|sync_cmd_idx
operator|=
operator|(
name|u_int32_t
operator|)
name|MRSAS_ULONG_MAX
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|mrsas_mpt_cmd_list_head
operator|)
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mpt_cmd_pool_lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * mrsas_get_request_desc:     Get request descriptor from array    * input:                      Adapter instance soft state  *                             SMID index   *  * This function returns a pointer to the request descriptor.  */
end_comment

begin_function
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|mrsas_get_request_desc
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|index
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|sc
operator|->
name|max_fw_cmds
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Invalid SMID (0x%x)request for desc\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|=
name|sc
operator|->
name|req_desc
operator|+
sizeof|sizeof
argument_list|(
name|MRSAS_REQUEST_DESCRIPTOR_UNION
argument_list|)
operator|*
name|index
expr_stmt|;
return|return
operator|(
name|MRSAS_REQUEST_DESCRIPTOR_UNION
operator|*
operator|)
name|p
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_build_ldio:       Builds an LDIO command    * input:                  Adapter instance soft state  *                         Pointer to command packet  *                         Pointer to CCB   *  * This function builds the LDIO command packet.  It returns 0 if the   * command is built successfully, otherwise it returns a 1.   */
end_comment

begin_function
name|int
name|mrsas_build_ldio
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|)
decl_stmt|;
name|u_int32_t
name|device_id
decl_stmt|;
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
decl_stmt|;
name|device_id
operator|=
name|ccb_h
operator|->
name|target_id
expr_stmt|;
name|io_request
operator|=
name|cmd
operator|->
name|io_request
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|VirtualDiskTgtId
operator|=
name|device_id
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|exStatus
operator|=
literal|0
expr_stmt|;
comment|/* just the cdb len, other flags zero, and ORed-in later for FP */
name|io_request
operator|->
name|IoFlags
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
name|mrsas_setup_io
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|ccb
argument_list|,
name|device_id
argument_list|,
name|io_request
argument_list|)
operator|!=
name|SUCCESS
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Build ldio or fpio error\n"
argument_list|)
expr_stmt|;
name|io_request
operator|->
name|DataLength
operator|=
name|cmd
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|mrsas_map_request
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|sge_count
operator|>
name|MRSAS_MAX_SGL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Error: sge_count (0x%x) exceeds"
literal|"max (0x%x) allowed\n"
argument_list|,
name|cmd
operator|->
name|sge_count
argument_list|,
name|sc
operator|->
name|max_num_sge
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|io_request
operator|->
name|RaidContext
operator|.
name|numSGE
operator|=
name|cmd
operator|->
name|sge_count
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Data map/load failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_setup_io:             Set up data including Fast Path I/O    * input:                      Adapter instance soft state  *                             Pointer to command packet  *                             Pointer to CCB   *  * This function builds the DCDB inquiry command.  It returns 0 if the   * command is built successfully, otherwise it returns a 1.   */
end_comment

begin_function
name|int
name|mrsas_setup_io
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|device_id
parameter_list|,
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|)
decl_stmt|;
name|struct
name|IO_REQUEST_INFO
name|io_info
decl_stmt|;
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map_ptr
decl_stmt|;
name|u_int8_t
name|fp_possible
decl_stmt|;
name|u_int32_t
name|start_lba_hi
decl_stmt|,
name|start_lba_lo
decl_stmt|,
name|ld_block_size
decl_stmt|;
name|u_int32_t
name|datalength
init|=
literal|0
decl_stmt|;
name|start_lba_lo
operator|=
literal|0
expr_stmt|;
name|start_lba_hi
operator|=
literal|0
expr_stmt|;
name|fp_possible
operator|=
literal|0
expr_stmt|;
comment|/*      * READ_6 (0x08) or WRITE_6 (0x0A) cdb      */
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|==
literal|6
condition|)
block|{
name|datalength
operator|=
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
expr_stmt|;
name|start_lba_lo
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|3
index|]
expr_stmt|;
name|start_lba_lo
operator|&=
literal|0x1FFFFF
expr_stmt|;
block|}
comment|/*      * READ_10 (0x28) or WRITE_6 (0x2A) cdb      */
elseif|else
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|==
literal|10
condition|)
block|{
name|datalength
operator|=
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|start_lba_lo
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
operator|<<
literal|8
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|5
index|]
operator|)
expr_stmt|;
block|}
comment|/*      * READ_12 (0xA8) or WRITE_12 (0xAA) cdb      */
elseif|else
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|==
literal|12
condition|)
block|{
name|datalength
operator|=
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|6
index|]
operator|<<
literal|24
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|7
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|9
index|]
operator|)
expr_stmt|;
name|start_lba_lo
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
operator|<<
literal|8
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|5
index|]
operator|)
expr_stmt|;
block|}
comment|/*      * READ_16 (0x88) or WRITE_16 (0xx8A) cdb      */
elseif|else
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|==
literal|16
condition|)
block|{
name|datalength
operator|=
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|10
index|]
operator|<<
literal|24
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|11
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|12
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|13
index|]
operator|)
expr_stmt|;
name|start_lba_lo
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|6
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|7
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
operator|<<
literal|8
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|9
index|]
operator|)
expr_stmt|;
name|start_lba_hi
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
operator|<<
literal|8
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|5
index|]
operator|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|io_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|IO_REQUEST_INFO
argument_list|)
argument_list|)
expr_stmt|;
name|io_info
operator|.
name|ldStartBlock
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|start_lba_hi
operator|<<
literal|32
operator|)
operator||
name|start_lba_lo
expr_stmt|;
name|io_info
operator|.
name|numBlocks
operator|=
name|datalength
expr_stmt|;
name|io_info
operator|.
name|ldTgtId
operator|=
name|device_id
expr_stmt|;
switch|switch
condition|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
condition|)
block|{
case|case
name|CAM_DIR_IN
case|:
name|io_info
operator|.
name|isRead
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CAM_DIR_OUT
case|:
name|io_info
operator|.
name|isRead
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAM_DIR_NONE
case|:
default|default:
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_TRACE
argument_list|,
literal|"From %s : DMA Flag is %d \n"
argument_list|,
name|__func__
argument_list|,
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
argument_list|)
expr_stmt|;
break|break;
block|}
name|map_ptr
operator|=
name|sc
operator|->
name|ld_drv_map
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
expr_stmt|;
name|ld_block_size
operator|=
name|MR_LdBlockSizeGet
argument_list|(
name|device_id
argument_list|,
name|map_ptr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|MR_TargetIdToLdGet
argument_list|(
name|device_id
argument_list|,
name|map_ptr
argument_list|)
operator|>=
name|MAX_LOGICAL_DRIVES_EXT
operator|)
operator|||
operator|(
operator|!
name|sc
operator|->
name|fast_path_io
operator|)
condition|)
block|{
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockFlags
operator|=
literal|0
expr_stmt|;
name|fp_possible
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|MR_BuildRaidContext
argument_list|(
name|sc
argument_list|,
operator|&
name|io_info
argument_list|,
operator|&
name|io_request
operator|->
name|RaidContext
argument_list|,
name|map_ptr
argument_list|)
condition|)
name|fp_possible
operator|=
name|io_info
operator|.
name|fpOkForIo
expr_stmt|;
block|}
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|MSIxIndex
operator|=
name|sc
operator|->
name|msix_vectors
condition|?
name|smp_processor_id
argument_list|()
operator|%
name|sc
operator|->
name|msix_vectors
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|fp_possible
condition|)
block|{
name|mrsas_set_pd_lba
argument_list|(
name|io_request
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|,
operator|&
name|io_info
argument_list|,
name|ccb
argument_list|,
name|map_ptr
argument_list|,
name|start_lba_lo
argument_list|,
name|ld_block_size
argument_list|)
expr_stmt|;
name|io_request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_SCSI_IO_REQUEST
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|RequestFlags
operator|=
operator|(
name|MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_INVADER
operator|)
operator|||
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_FURY
operator|)
condition|)
block|{
if|if
condition|(
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockFlags
operator|==
name|REGION_TYPE_UNUSED
condition|)
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|RequestFlags
operator|=
operator|(
name|MRSAS_REQ_DESCRIPT_FLAGS_NO_LOCK
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|Type
operator|=
name|MPI2_TYPE_CUDA
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|nseg
operator|=
literal|0x1
expr_stmt|;
name|io_request
operator|->
name|IoFlags
operator||=
name|MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockFlags
operator||=
operator|(
name|MR_RL_FLAGS_GRANT_DESTINATION_CUDA
operator||
name|MR_RL_FLAGS_SEQ_NUM_ENABLE
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|load_balance_info
index|[
name|device_id
index|]
operator|.
name|loadBalanceFlag
operator|)
operator|&&
operator|(
name|io_info
operator|.
name|isRead
operator|)
condition|)
block|{
name|io_info
operator|.
name|devHandle
operator|=
name|mrsas_get_updated_dev_handle
argument_list|(
operator|&
name|sc
operator|->
name|load_balance_info
index|[
name|device_id
index|]
argument_list|,
operator|&
name|io_info
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|load_balance
operator|=
name|MRSAS_LOAD_BALANCE_FLAG
expr_stmt|;
block|}
else|else
name|cmd
operator|->
name|load_balance
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|DevHandle
operator|=
name|io_info
operator|.
name|devHandle
expr_stmt|;
name|io_request
operator|->
name|DevHandle
operator|=
name|io_info
operator|.
name|devHandle
expr_stmt|;
block|}
else|else
block|{
comment|/* Not FP IO */
name|io_request
operator|->
name|RaidContext
operator|.
name|timeoutValue
operator|=
name|map_ptr
operator|->
name|raidMap
operator|.
name|fpPdIoTimeoutSec
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|RequestFlags
operator|=
operator|(
name|MRSAS_REQ_DESCRIPT_FLAGS_LD_IO
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_INVADER
operator|)
operator|||
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_FURY
operator|)
condition|)
block|{
if|if
condition|(
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockFlags
operator|==
name|REGION_TYPE_UNUSED
condition|)
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|RequestFlags
operator|=
operator|(
name|MRSAS_REQ_DESCRIPT_FLAGS_NO_LOCK
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|Type
operator|=
name|MPI2_TYPE_CUDA
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockFlags
operator||=
operator|(
name|MR_RL_FLAGS_GRANT_DESTINATION_CPU0
operator||
name|MR_RL_FLAGS_SEQ_NUM_ENABLE
operator|)
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|nseg
operator|=
literal|0x1
expr_stmt|;
block|}
name|io_request
operator|->
name|Function
operator|=
name|MRSAS_MPI2_FUNCTION_LD_IO_REQUEST
expr_stmt|;
name|io_request
operator|->
name|DevHandle
operator|=
name|device_id
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_build_dcdb:       Builds an DCDB command    * input:                  Adapter instance soft state  *                         Pointer to command packet  *                         Pointer to CCB   *  * This function builds the DCDB inquiry command.  It returns 0 if the   * command is built successfully, otherwise it returns a 1.   */
end_comment

begin_function
name|int
name|mrsas_build_dcdb
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
decl_stmt|;
name|u_int32_t
name|device_id
decl_stmt|;
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map_ptr
decl_stmt|;
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
decl_stmt|;
name|io_request
operator|=
name|cmd
operator|->
name|io_request
expr_stmt|;
name|device_id
operator|=
name|ccb_h
operator|->
name|target_id
expr_stmt|;
name|map_ptr
operator|=
name|sc
operator|->
name|ld_drv_map
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
expr_stmt|;
comment|/* Check if this is for system PD */
if|if
condition|(
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
operator|==
literal|1
operator|&&
name|sc
operator|->
name|pd_list
index|[
name|device_id
index|]
operator|.
name|driveState
operator|==
name|MR_PD_STATE_SYSTEM
condition|)
block|{
name|io_request
operator|->
name|Function
operator|=
literal|0
expr_stmt|;
name|io_request
operator|->
name|DevHandle
operator|=
name|map_ptr
operator|->
name|raidMap
operator|.
name|devHndlInfo
index|[
name|device_id
index|]
operator|.
name|curDevHdl
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|timeoutValue
operator|=
name|map_ptr
operator|->
name|raidMap
operator|.
name|fpPdIoTimeoutSec
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockFlags
operator|=
literal|0
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockRowLBA
operator|=
literal|0
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockLength
operator|=
literal|0
expr_stmt|;
comment|// LSI TEST
comment|//printf("LSI Debug bus %d device_id %d map_ptr->raidMap.devHndlInfo[device_id].curDevHdl %d \n",
comment|//		cam_sim_bus(sim), device_id, map_ptr->raidMap.devHndlInfo[device_id].curDevHdl);
name|io_request
operator|->
name|RaidContext
operator|.
name|RAIDFlags
operator|=
name|MR_RAID_FLAGS_IO_SUB_TYPE_SYSTEM_PD
operator|<<
name|MR_RAID_CTX_RAID_FLAGS_IO_SUB_TYPE_SHIFT
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_INVADER
operator|)
operator|||
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_FURY
operator|)
condition|)
name|io_request
operator|->
name|IoFlags
operator||=
name|MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|RequestFlags
operator|=
operator|(
name|MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|DevHandle
operator|=
name|map_ptr
operator|->
name|raidMap
operator|.
name|devHndlInfo
index|[
name|device_id
index|]
operator|.
name|curDevHdl
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|MSIxIndex
operator|=
name|sc
operator|->
name|msix_vectors
condition|?
name|smp_processor_id
argument_list|()
operator|%
name|sc
operator|->
name|msix_vectors
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|io_request
operator|->
name|Function
operator|=
name|MRSAS_MPI2_FUNCTION_LD_IO_REQUEST
expr_stmt|;
name|io_request
operator|->
name|DevHandle
operator|=
name|device_id
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|RequestFlags
operator|=
operator|(
name|MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
block|}
name|io_request
operator|->
name|RaidContext
operator|.
name|VirtualDiskTgtId
operator|=
name|device_id
expr_stmt|;
name|io_request
operator|->
name|LUN
index|[
literal|1
index|]
operator|=
name|ccb_h
operator|->
name|target_lun
operator|&
literal|0xF
expr_stmt|;
name|io_request
operator|->
name|DataLength
operator|=
name|cmd
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|mrsas_map_request
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|sge_count
operator|>
name|sc
operator|->
name|max_num_sge
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Error: sge_count (0x%x) exceeds"
literal|"max (0x%x) allowed\n"
argument_list|,
name|cmd
operator|->
name|sge_count
argument_list|,
name|sc
operator|->
name|max_num_sge
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|io_request
operator|->
name|RaidContext
operator|.
name|numSGE
operator|=
name|cmd
operator|->
name|sge_count
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Data map/load failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_map_request:           Map and load data     * input:                       Adapter instance soft state  *                              Pointer to command packet  *  * For data from OS, map and load the data buffer into bus space.  The  * SG list is built in the callback.  If the  bus dmamap load is not  * successful, cmd->error_code will contain the  error code and a 1 is   * returned.  */
end_comment

begin_function
name|int
name|mrsas_map_request
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|u_int32_t
name|retcode
init|=
literal|0
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|int
name|flag
init|=
name|BUS_DMA_NOWAIT
decl_stmt|;
name|sim
operator|=
name|xpt_path_sim
argument_list|(
name|cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/* Map data buffer into bus space */
name|retcode
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|data_tag
argument_list|,
name|cmd
operator|->
name|data_dmamap
argument_list|,
name|cmd
operator|->
name|data
argument_list|,
name|cmd
operator|->
name|length
argument_list|,
name|mrsas_data_load_cb
argument_list|,
name|cmd
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"bus_dmamap_load(): retcode = %d\n"
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
name|EINPROGRESS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"request load in progress\n"
argument_list|)
expr_stmt|;
name|mrsas_freeze_simq
argument_list|(
name|cmd
argument_list|,
name|sim
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cmd
operator|->
name|error_code
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_unmap_request:       Unmap and unload data     * input:                     Adapter instance soft state  *                            Pointer to command packet  *  * This function unmaps and unloads data from OS.  */
end_comment

begin_function
name|void
name|mrsas_unmap_request
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MRSAS_DIR_IN
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|data_tag
argument_list|,
name|cmd
operator|->
name|data_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MRSAS_DIR_OUT
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|data_tag
argument_list|,
name|cmd
operator|->
name|data_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|data_tag
argument_list|,
name|cmd
operator|->
name|data_dmamap
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * mrsas_data_load_cb:        Callback entry point     * input:                     Pointer to command packet as argument   *                            Pointer to segment  *                            Number of segments  *                            Error   *  * This is the callback function of the bus dma map load.  It builds   * the SG list.    */
end_comment

begin_function
specifier|static
name|void
name|mrsas_data_load_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
init|=
operator|(
expr|struct
name|mrsas_mpt_cmd
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|mrsas_softc
modifier|*
name|sc
init|=
name|cmd
operator|->
name|sc
decl_stmt|;
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
decl_stmt|;
name|pMpi25IeeeSgeChain64_t
name|sgl_ptr
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|sg_processed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmd
operator|->
name|error_code
operator|=
name|error
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"mrsas_data_load_cb: error=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_TOO_BIG
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MRSAS_DIR_IN
condition|)
name|bus_dmamap_sync
argument_list|(
name|cmd
operator|->
name|sc
operator|->
name|data_tag
argument_list|,
name|cmd
operator|->
name|data_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MRSAS_DIR_OUT
condition|)
name|bus_dmamap_sync
argument_list|(
name|cmd
operator|->
name|sc
operator|->
name|data_tag
argument_list|,
name|cmd
operator|->
name|data_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|>
name|sc
operator|->
name|max_num_sge
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"SGE count is too large or 0.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|io_request
operator|=
name|cmd
operator|->
name|io_request
expr_stmt|;
name|sgl_ptr
operator|=
operator|(
name|pMpi25IeeeSgeChain64_t
operator|)
operator|&
name|io_request
operator|->
name|SGL
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_INVADER
operator|)
operator|||
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_FURY
operator|)
condition|)
block|{
name|pMpi25IeeeSgeChain64_t
name|sgl_ptr_end
init|=
name|sgl_ptr
decl_stmt|;
name|sgl_ptr_end
operator|+=
name|sc
operator|->
name|max_sge_in_main_msg
operator|-
literal|1
expr_stmt|;
name|sgl_ptr_end
operator|->
name|Flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|sgl_ptr
operator|->
name|Address
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sgl_ptr
operator|->
name|Length
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
name|sgl_ptr
operator|->
name|Flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_INVADER
operator|)
operator|||
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_FURY
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|nseg
operator|-
literal|1
condition|)
name|sgl_ptr
operator|->
name|Flags
operator|=
name|IEEE_SGE_FLAGS_END_OF_LIST
expr_stmt|;
block|}
name|sgl_ptr
operator|++
expr_stmt|;
name|sg_processed
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/*               * Prepare chain element               */
if|if
condition|(
operator|(
name|sg_processed
operator|==
operator|(
name|sc
operator|->
name|max_sge_in_main_msg
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|nseg
operator|>
name|sc
operator|->
name|max_sge_in_main_msg
operator|)
condition|)
block|{
name|pMpi25IeeeSgeChain64_t
name|sg_chain
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_INVADER
operator|)
operator|||
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_FURY
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cmd
operator|->
name|io_request
operator|->
name|IoFlags
operator|&
name|MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH
operator|)
operator|!=
name|MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH
condition|)
name|cmd
operator|->
name|io_request
operator|->
name|ChainOffset
operator|=
name|sc
operator|->
name|chain_offset_io_request
expr_stmt|;
else|else
name|cmd
operator|->
name|io_request
operator|->
name|ChainOffset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cmd
operator|->
name|io_request
operator|->
name|ChainOffset
operator|=
name|sc
operator|->
name|chain_offset_io_request
expr_stmt|;
name|sg_chain
operator|=
name|sgl_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_INVADER
operator|)
operator|||
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_FURY
operator|)
condition|)
name|sg_chain
operator|->
name|Flags
operator|=
name|IEEE_SGE_FLAGS_CHAIN_ELEMENT
expr_stmt|;
else|else
name|sg_chain
operator|->
name|Flags
operator|=
operator|(
name|IEEE_SGE_FLAGS_CHAIN_ELEMENT
operator||
name|MPI2_IEEE_SGE_FLAGS_IOCPLBNTA_ADDR
operator|)
expr_stmt|;
name|sg_chain
operator|->
name|Length
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
operator|*
operator|(
name|nseg
operator|-
name|sg_processed
operator|)
operator|)
expr_stmt|;
name|sg_chain
operator|->
name|Address
operator|=
name|cmd
operator|->
name|chain_frame_phys_addr
expr_stmt|;
name|sgl_ptr
operator|=
operator|(
name|pMpi25IeeeSgeChain64_t
operator|)
name|cmd
operator|->
name|chain_frame
expr_stmt|;
block|}
block|}
block|}
name|cmd
operator|->
name|sge_count
operator|=
name|nseg
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_freeze_simq:        Freeze SIM queue     * input:                    Pointer to command packet    *                           Pointer to SIM  *  * This function freezes the sim queue.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_freeze_simq
parameter_list|(
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|(
name|cmd
operator|->
name|ccb_ptr
operator|)
decl_stmt|;
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mrsas_xpt_freeze
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|xpt_freeze_simq
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mrsas_xpt_release
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|xpt_release_simq
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_cmd_done:           Perform remaining command completion   * input:                    Adapter instance soft state    *                           Pointer to command packet   *  * This function calls ummap request and releases the MPT command.   */
end_comment

begin_function
name|void
name|mrsas_cmd_done
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|callout_stop
argument_list|(
operator|&
name|cmd
operator|->
name|cm_callout
argument_list|)
expr_stmt|;
name|mrsas_unmap_request
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|cmd
operator|->
name|ccb_ptr
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ccb_ptr
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_poll:               Polling entry point   * input:                    Pointer to SIM    *  * This is currently a stub function.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|mrsas_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|mrsas_isr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mrsas_bus_scan:           Perform bus scan   * input:                    Adapter instance soft state    *  * This mrsas_bus_scan function is needed for FreeBSD 7.x.  Also, it should  * not be called in FreeBSD 8.x and later versions, where the bus scan is   * automatic.   */
end_comment

begin_function
name|int
name|mrsas_bus_scan
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb_0
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb_1
decl_stmt|;
if|if
condition|(
operator|(
name|ccb_0
operator|=
name|xpt_alloc_ccb
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb_1
operator|=
name|xpt_alloc_ccb
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|ccb_0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb_0
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|ccb_0
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb_1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb_1
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|ccb_0
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb_1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
name|xpt_rescan
argument_list|(
name|ccb_0
argument_list|)
expr_stmt|;
name|xpt_rescan
argument_list|(
name|ccb_1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_bus_scan_sim:		Perform bus scan per SIM  * input:					Adapter instance soft state    * 							This function will be called from Event handler   * 							on LD creation/deletion, JBOD on/off.  */
end_comment

begin_function
name|int
name|mrsas_bus_scan_sim
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
name|xpt_alloc_ccb
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|cam_sim_path
argument_list|(
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
name|xpt_rescan
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

