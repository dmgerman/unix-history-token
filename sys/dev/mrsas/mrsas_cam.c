begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2015, AVAGO Tech. All rights reserved. Author: Marian Choy  * Copyright (c) 2014, LSI Corp. All rights reserved. Author: Marian Choy  * Support: freebsdraid@avagotech.com  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  * 1. Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer. 2. Redistributions  * in binary form must reproduce the above copyright notice, this list of  * conditions and the following disclaimer in the documentation and/or other  * materials provided with the distribution. 3. Neither the name of the  *<ORGANIZATION> nor the names of its contributors may be used to endorse or  * promote products derived from this software without specific prior written  * permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"dev/mrsas/mrsas.h"
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* XXX for pcpu.h */
end_comment

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_comment
comment|/* XXX for PCPU_GET */
end_comment

begin_define
define|#
directive|define
name|smp_processor_id
parameter_list|()
value|PCPU_GET(cpuid)
end_define

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
name|int
name|mrsas_cam_attach
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_find_io_type
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_bus_scan
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_bus_scan_sim
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_map_request
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_build_ldio_rw
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_build_ldio_nonrw
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_build_syspdio
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|u_int8_t
name|fp_possible
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_setup_io
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|device_id
parameter_list|,
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_xpt_freeze
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_xpt_release
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_cam_detach
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_release_mpt_cmd
parameter_list|(
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_unmap_request
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_cmd_done
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_fire_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|req_desc_lo
parameter_list|,
name|u_int32_t
name|req_desc_hi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_set_pd_lba
parameter_list|(
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
parameter_list|,
name|u_int8_t
name|cdb_len
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|local_map_ptr
parameter_list|,
name|u_int32_t
name|ref_tag
parameter_list|,
name|u_int32_t
name|ld_block_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_freeze_simq
parameter_list|(
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_cam_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_scsiio_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_track_scsiio
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|target_id_t
name|id
parameter_list|,
name|u_int32_t
name|bus_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_tm_response_code
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|MPI2_SCSI_TASK_MANAGE_REPLY
modifier|*
name|mpi_reply
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_issue_tm
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|req_desc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_data_load_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|mrsas_startio
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|mrsas_mpt_cmd
modifier|*
name|mrsas_get_mpt_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|mrsas_get_request_desc
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mrsas_map_mpt_cmd_status
parameter_list|(
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|u_int8_t
name|extStatus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|mrsas_reset_targets
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int16_t
name|MR_TargetIdToLdGet
parameter_list|(
name|u_int32_t
name|ldTgtId
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int32_t
name|MR_LdBlockSizeGet
parameter_list|(
name|u_int32_t
name|ldTgtId
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mrsas_isr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mrsas_aen_handler
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int8_t
name|MR_BuildRaidContext
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|RAID_CONTEXT
modifier|*
name|pRAID_Context
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int16_t
name|MR_LdSpanArrayGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int32_t
name|span
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int16_t
name|mrsas_get_updated_dev_handle
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int8_t
name|megasas_get_best_arm
parameter_list|(
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|,
name|u_int8_t
name|arm
parameter_list|,
name|u_int64_t
name|block
parameter_list|,
name|u_int32_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|mrsas_complete_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|MSIxIndex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|MR_LD_RAID
modifier|*
name|MR_LdRaidGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mrsas_disable_intr
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mrsas_enable_intr
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * mrsas_cam_attach:	Main entry to CAM subsystem  * input:				Adapter instance soft state  *  * This function is called from mrsas_attach() during initialization to perform  * SIM allocations and XPT bus registration.  If the kernel version is 7.4 or  * earlier, it would also initiate a bus scan.  */
end_comment

begin_function
name|int
name|mrsas_cam_attach
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|mrsas_cam_depth
decl_stmt|;
name|mrsas_cam_depth
operator|=
name|sc
operator|->
name|max_fw_cmds
operator|-
name|MRSAS_INTERNAL_CMDS
expr_stmt|;
if|if
condition|(
operator|(
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|mrsas_cam_depth
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate SIM queue\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Create SIM for bus 0 and register, also create path 	 */
name|sc
operator|->
name|sim_0
operator|=
name|cam_sim_alloc
argument_list|(
name|mrsas_action
argument_list|,
name|mrsas_cam_poll
argument_list|,
literal|"mrsas"
argument_list|,
name|sc
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sim_lock
argument_list|,
name|mrsas_cam_depth
argument_list|,
name|mrsas_cam_depth
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sim_0
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot register SIM\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Initialize taskqueue for Event Handling */
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|ev_task
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mrsas_aen_handler
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ev_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"mrsas_taskq"
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|ev_tq
argument_list|)
expr_stmt|;
comment|/* Run the task queue with lowest priority */
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|ev_tq
argument_list|,
literal|1
argument_list|,
literal|255
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|,
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* passing true frees the devq */
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|sc
operator|->
name|path_0
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* passing true will free the 						 * devq */
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Create SIM for bus 1 and register, also create path 	 */
name|sc
operator|->
name|sim_1
operator|=
name|cam_sim_alloc
argument_list|(
name|mrsas_action
argument_list|,
name|mrsas_cam_poll
argument_list|,
literal|"mrsas"
argument_list|,
name|sc
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sim_lock
argument_list|,
name|mrsas_cam_depth
argument_list|,
name|mrsas_cam_depth
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sim_1
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot register SIM\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|,
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|1
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* passing true frees the devq */
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|sc
operator|->
name|path_1
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<=
literal|704000
operator|)
if|if
condition|(
name|mrsas_bus_scan
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Error in bus scan.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_cam_detach:	De-allocates and teardown CAM  * input:				Adapter instance soft state  *  * De-registers and frees the paths and SIMs.  */
end_comment

begin_function
name|void
name|mrsas_cam_detach
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|ev_tq
operator|!=
name|NULL
condition|)
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|ev_tq
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|path_0
condition|)
name|xpt_free_path
argument_list|(
name|sc
operator|->
name|path_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sim_0
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|path_1
condition|)
name|xpt_free_path
argument_list|(
name|sc
operator|->
name|path_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sim_1
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mrsas_action:	SIM callback entry point  * input:			pointer to SIM pointer to CAM Control Block  *  * This function processes CAM subsystem requests. The type of request is stored  * in ccb->ccb_h.func_code.  The preprocessor #ifdef is necessary because  * ccb->cpi.maxio is not supported for FreeBSD version 7.4 or earlier.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|mrsas_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
decl_stmt|;
name|u_int32_t
name|device_id
decl_stmt|;
comment|/*      * Check if the system going down      * or the adapter is in unrecoverable critical error      */
if|if
condition|(
name|sc
operator|->
name|remove_in_progress
operator|||
operator|(
name|sc
operator|->
name|adprecovery
operator|==
name|MRSAS_HW_CRITICAL_ERROR
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
block|{
name|device_id
operator|=
name|ccb_h
operator|->
name|target_id
expr_stmt|;
comment|/* 			 * bus 0 is LD, bus 1 is for system-PD 			 */
if|if
condition|(
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
operator|==
literal|1
operator|&&
name|sc
operator|->
name|pd_list
index|[
name|device_id
index|]
operator|.
name|driveState
operator|!=
name|MR_PD_STATE_SYSTEM
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mrsas_startio
argument_list|(
name|sc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|XPT_ABORT
case|:
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
block|{
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|ccb
operator|->
name|cts
operator|.
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|valid
operator|=
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|proto_specific
operator|.
name|scsi
operator|.
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|proto_specific
operator|.
name|scsi
operator|.
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
block|{
name|ccb
operator|->
name|cpi
operator|.
name|version_num
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|hba_inquiry
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|target_sprt
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|902001
operator|)
name|ccb
operator|->
name|cpi
operator|.
name|hba_misc
operator|=
name|PIM_UNMAPPED
expr_stmt|;
else|#
directive|else
name|ccb
operator|->
name|cpi
operator|.
name|hba_misc
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ccb
operator|->
name|cpi
operator|.
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|max_lun
operator|=
name|MRSAS_SCSI_MAX_LUNS
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|initiator_id
operator|=
name|MRSAS_SCSI_INITIATOR_ID
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|base_transfer_speed
operator|=
literal|150000
expr_stmt|;
name|strlcpy
argument_list|(
name|ccb
operator|->
name|cpi
operator|.
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ccb
operator|->
name|cpi
operator|.
name|hba_vid
argument_list|,
literal|"AVAGO"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ccb
operator|->
name|cpi
operator|.
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|ccb
operator|->
name|cpi
operator|.
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|cpi
operator|.
name|bus_id
operator|==
literal|0
condition|)
name|ccb
operator|->
name|cpi
operator|.
name|max_target
operator|=
name|MRSAS_MAX_PD
operator|-
literal|1
expr_stmt|;
else|else
name|ccb
operator|->
name|cpi
operator|.
name|max_target
operator|=
name|MRSAS_MAX_LD_IDS
operator|-
literal|1
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|704000
operator|)
name|ccb
operator|->
name|cpi
operator|.
name|maxio
operator|=
name|sc
operator|->
name|max_num_sge
operator|*
name|MRSAS_PAGE_SIZE
expr_stmt|;
endif|#
directive|endif
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * mrsas_scsiio_timeout:	Callback function for IO timed out  * input:					mpt command context  *  * This function will execute after timeout value provided by ccb header from  * CAM layer, if timer expires. Driver will run timer for all DCDM and LDIO  * coming from CAM layer. This function is callback function for IO timeout  * and it runs in no-sleep context. Set do_timedout_reset in Adapter context  * so that it will execute OCR/Kill adpter from ocr_thread context.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_scsiio_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mrsas_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|target_id
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return;
name|cmd
operator|=
operator|(
expr|struct
name|mrsas_mpt_cmd
operator|*
operator|)
name|data
expr_stmt|;
name|sc
operator|=
name|cmd
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|ccb_ptr
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"command timeout with NULL ccb\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Below callout is dummy entry so that it will be cancelled from 	 * mrsas_cmd_done(). Now Controller will go to OCR/Kill Adapter based 	 * on OCR enable/disable property of Controller from ocr_thread 	 * context. 	 */
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|1000510
operator|)
name|callout_reset_sbt
argument_list|(
operator|&
name|cmd
operator|->
name|cm_callout
argument_list|,
name|SBT_1S
operator|*
literal|180
argument_list|,
literal|0
argument_list|,
name|mrsas_scsiio_timeout
argument_list|,
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|callout_reset
argument_list|(
operator|&
name|cmd
operator|->
name|cm_callout
argument_list|,
operator|(
literal|180000
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|,
name|mrsas_scsiio_timeout
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|->
name|ccb_ptr
operator|->
name|cpi
operator|.
name|bus_id
operator|==
literal|0
condition|)
name|target_id
operator|=
name|cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
else|else
name|target_id
operator|=
operator|(
name|cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|target_id
operator|+
operator|(
name|MRSAS_MAX_PD
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Save the cmd to be processed for TM, if it is not there in the array */
if|if
condition|(
name|sc
operator|->
name|target_reset_pool
index|[
name|target_id
index|]
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|target_reset_pool
index|[
name|target_id
index|]
operator|=
name|cmd
expr_stmt|;
name|mrsas_atomic_inc
argument_list|(
operator|&
name|sc
operator|->
name|target_reset_outstanding
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * mrsas_startio:	SCSI IO entry point  * input:			Adapter instance soft state  * 					pointer to CAM Control Block  *  * This function is the SCSI IO entry point and it initiates IO processing. It  * copies the IO and depending if the IO is read/write or inquiry, it would  * call mrsas_build_ldio() or mrsas_build_dcdb(), respectively.  It returns 0  * if the command is sent to firmware successfully, otherwise it returns 1.  */
end_comment

begin_function
specifier|static
name|int32_t
name|mrsas_startio
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|)
decl_stmt|;
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|req_desc
decl_stmt|;
name|u_int8_t
name|cmd_type
decl_stmt|;
if|if
condition|(
operator|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|)
operator|==
name|SYNCHRONIZE_CACHE
operator|&&
operator|(
operator|!
name|sc
operator|->
name|fw_sync_cache_support
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ccb_h
operator|->
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|cmd
operator|=
name|mrsas_get_mpt_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|ccb_h
operator|->
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_IN
condition|)
name|cmd
operator|->
name|flags
operator||=
name|MRSAS_DIR_IN
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_OUT
condition|)
name|cmd
operator|->
name|flags
operator||=
name|MRSAS_DIR_OUT
expr_stmt|;
block|}
else|else
name|cmd
operator|->
name|flags
operator|=
name|MRSAS_DIR_NONE
expr_stmt|;
comment|/* no data */
comment|/* For FreeBSD 9.2 and higher */
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|902001
operator|)
comment|/* 	 * XXX We don't yet support physical addresses here. 	 */
switch|switch
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_MASK
operator|)
condition|)
block|{
case|case
name|CAM_DATA_PADDR
case|:
case|case
name|CAM_DATA_SG_PADDR
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"%s: physical addresses not supported\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|CAM_DATA_SG
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"%s: scatter gather is not supported\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|CAM_DATA_VADDR
case|:
if|if
condition|(
name|csio
operator|->
name|dxfer_len
operator|>
operator|(
name|sc
operator|->
name|max_num_sge
operator|*
name|MRSAS_PAGE_SIZE
operator|)
condition|)
block|{
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_TOO_BIG
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|cmd
operator|->
name|length
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|length
condition|)
name|cmd
operator|->
name|data
operator|=
name|csio
operator|->
name|data_ptr
expr_stmt|;
break|break;
case|case
name|CAM_DATA_BIO
case|:
if|if
condition|(
name|csio
operator|->
name|dxfer_len
operator|>
operator|(
name|sc
operator|->
name|max_num_sge
operator|*
name|MRSAS_PAGE_SIZE
operator|)
condition|)
block|{
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_TOO_BIG
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|cmd
operator|->
name|length
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|length
condition|)
name|cmd
operator|->
name|data
operator|=
name|csio
operator|->
name|data_ptr
expr_stmt|;
break|break;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
condition|)
block|{
comment|/* Virtual data address */
if|if
condition|(
operator|!
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
condition|)
block|{
if|if
condition|(
name|csio
operator|->
name|dxfer_len
operator|>
operator|(
name|sc
operator|->
name|max_num_sge
operator|*
name|MRSAS_PAGE_SIZE
operator|)
condition|)
block|{
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_TOO_BIG
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|cmd
operator|->
name|length
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|length
condition|)
name|cmd
operator|->
name|data
operator|=
name|csio
operator|->
name|data_ptr
expr_stmt|;
block|}
else|else
block|{
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|/* Data addresses are physical. */
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
comment|/* save ccb ptr */
name|cmd
operator|->
name|ccb_ptr
operator|=
name|ccb
expr_stmt|;
name|req_desc
operator|=
name|mrsas_get_request_desc
argument_list|(
name|sc
argument_list|,
operator|(
name|cmd
operator|->
name|index
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req_desc
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot get request_descriptor.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|memset
argument_list|(
name|req_desc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MRSAS_REQUEST_DESCRIPTOR_UNION
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|=
name|req_desc
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|cmd
operator|->
name|io_request
operator|->
name|CDB
operator|.
name|CDB32
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|cmd
operator|->
name|io_request
operator|->
name|CDB
operator|.
name|CDB32
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
comment|/* Check for IO type READ-WRITE targeted for Logical Volume */
name|cmd_type
operator|=
name|mrsas_find_io_type
argument_list|(
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd_type
condition|)
block|{
case|case
name|READ_WRITE_LDIO
case|:
comment|/* Build READ-WRITE IO for Logical Volume  */
if|if
condition|(
name|mrsas_build_ldio_rw
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|ccb
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Build RW LDIO failed.\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|NON_READ_WRITE_LDIO
case|:
comment|/* Build NON READ-WRITE IO for Logical Volume  */
if|if
condition|(
name|mrsas_build_ldio_nonrw
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|ccb
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Build NON-RW LDIO failed.\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|READ_WRITE_SYSPDIO
case|:
case|case
name|NON_READ_WRITE_SYSPDIO
case|:
if|if
condition|(
name|sc
operator|->
name|secure_jbod_support
operator|&&
operator|(
name|cmd_type
operator|==
name|NON_READ_WRITE_SYSPDIO
operator|)
condition|)
block|{
comment|/* Build NON-RW IO for JBOD */
if|if
condition|(
name|mrsas_build_syspdio
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|ccb
argument_list|,
name|sim
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Build SYSPDIO failed.\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Build RW IO for JBOD */
if|if
condition|(
name|mrsas_build_syspdio
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|ccb
argument_list|,
name|sim
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Build SYSPDIO failed.\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|==
name|MRSAS_DIR_IN
condition|)
comment|/* from device */
name|cmd
operator|->
name|io_request
operator|->
name|Control
operator||=
name|MPI2_SCSIIO_CONTROL_READ
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|flags
operator|==
name|MRSAS_DIR_OUT
condition|)
comment|/* to device */
name|cmd
operator|->
name|io_request
operator|->
name|Control
operator||=
name|MPI2_SCSIIO_CONTROL_WRITE
expr_stmt|;
name|cmd
operator|->
name|io_request
operator|->
name|SGLFlags
operator|=
name|MPI2_SGE_FLAGS_64_BIT_ADDRESSING
expr_stmt|;
name|cmd
operator|->
name|io_request
operator|->
name|SGLOffset0
operator|=
name|offsetof
argument_list|(
name|MRSAS_RAID_SCSI_IO_REQUEST
argument_list|,
name|SGL
argument_list|)
operator|/
literal|4
expr_stmt|;
name|cmd
operator|->
name|io_request
operator|->
name|SenseBufferLowAddress
operator|=
name|cmd
operator|->
name|sense_phys_addr
expr_stmt|;
name|cmd
operator|->
name|io_request
operator|->
name|SenseBufferLength
operator|=
name|MRSAS_SCSI_SENSE_BUFFERSIZE
expr_stmt|;
name|req_desc
operator|=
name|cmd
operator|->
name|request_desc
expr_stmt|;
name|req_desc
operator|->
name|SCSIIO
operator|.
name|SMID
operator|=
name|cmd
operator|->
name|index
expr_stmt|;
comment|/* 	 * Start timer for IO timeout. Default timeout value is 90 second. 	 */
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|1000510
operator|)
name|callout_reset_sbt
argument_list|(
operator|&
name|cmd
operator|->
name|cm_callout
argument_list|,
name|SBT_1S
operator|*
literal|180
argument_list|,
literal|0
argument_list|,
name|mrsas_scsiio_timeout
argument_list|,
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|callout_reset
argument_list|(
operator|&
name|cmd
operator|->
name|cm_callout
argument_list|,
operator|(
literal|180000
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|,
name|mrsas_scsiio_timeout
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mrsas_atomic_inc
argument_list|(
operator|&
name|sc
operator|->
name|fw_outstanding
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrsas_atomic_read
argument_list|(
operator|&
name|sc
operator|->
name|fw_outstanding
argument_list|)
operator|>
name|sc
operator|->
name|io_cmds_highwater
condition|)
name|sc
operator|->
name|io_cmds_highwater
operator|++
expr_stmt|;
name|mrsas_fire_cmd
argument_list|(
name|sc
argument_list|,
name|req_desc
operator|->
name|addr
operator|.
name|u
operator|.
name|low
argument_list|,
name|req_desc
operator|->
name|addr
operator|.
name|u
operator|.
name|high
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|done
label|:
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_find_io_type:	Determines if IO is read/write or inquiry  * input:			pointer to CAM Control Block  *  * This function determines if the IO is read/write or inquiry.  It returns a 1  * if the IO is read/write and 0 if it is inquiry.  */
end_comment

begin_function
name|int
name|mrsas_find_io_type
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|)
decl_stmt|;
switch|switch
condition|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
condition|)
block|{
case|case
name|READ_10
case|:
case|case
name|WRITE_10
case|:
case|case
name|READ_12
case|:
case|case
name|WRITE_12
case|:
case|case
name|READ_6
case|:
case|case
name|WRITE_6
case|:
case|case
name|READ_16
case|:
case|case
name|WRITE_16
case|:
return|return
operator|(
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
condition|?
name|READ_WRITE_SYSPDIO
else|:
name|READ_WRITE_LDIO
operator|)
return|;
default|default:
return|return
operator|(
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
condition|?
name|NON_READ_WRITE_SYSPDIO
else|:
name|NON_READ_WRITE_LDIO
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * mrsas_get_mpt_cmd:	Get a cmd from free command pool  * input:				Adapter instance soft state  *  * This function removes an MPT command from the command free list and  * initializes it.  */
end_comment

begin_function
name|struct
name|mrsas_mpt_cmd
modifier|*
name|mrsas_get_mpt_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
init|=
name|NULL
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mpt_cmd_pool_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|mrsas_mpt_cmd_list_head
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|mrsas_mpt_cmd_list_head
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|mrsas_mpt_cmd_list_head
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|out
goto|;
block|}
name|memset
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|cmd
operator|->
name|io_request
argument_list|,
literal|0
argument_list|,
name|MRSAS_MPI2_RAID_DEFAULT_IO_FRAME_SIZE
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|cmd
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|error_code
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|load_balance
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|ccb_ptr
operator|=
name|NULL
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mpt_cmd_pool_lock
argument_list|)
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_release_mpt_cmd:	Return a cmd to free command pool  * input:					Command packet for return to free command pool  *  * This function returns an MPT command to the free command list.  */
end_comment

begin_function
name|void
name|mrsas_release_mpt_cmd
parameter_list|(
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
init|=
name|cmd
operator|->
name|sc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mpt_cmd_pool_lock
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|sync_cmd_idx
operator|=
operator|(
name|u_int32_t
operator|)
name|MRSAS_ULONG_MAX
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|mrsas_mpt_cmd_list_head
operator|)
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mpt_cmd_pool_lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * mrsas_get_request_desc:	Get request descriptor from array  * input:					Adapter instance soft state  * 							SMID index  *  * This function returns a pointer to the request descriptor.  */
end_comment

begin_function
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|mrsas_get_request_desc
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|index
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|sc
operator|->
name|max_fw_cmds
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Invalid SMID (0x%x)request for desc\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|=
name|sc
operator|->
name|req_desc
operator|+
sizeof|sizeof
argument_list|(
name|MRSAS_REQUEST_DESCRIPTOR_UNION
argument_list|)
operator|*
name|index
expr_stmt|;
return|return
operator|(
name|MRSAS_REQUEST_DESCRIPTOR_UNION
operator|*
operator|)
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_build_ldio_rw:	Builds an LDIO command  * input:				Adapter instance soft state  * 						Pointer to command packet  * 						Pointer to CCB  *  * This function builds the LDIO command packet.  It returns 0 if the command is  * built successfully, otherwise it returns a 1.  */
end_comment

begin_function
name|int
name|mrsas_build_ldio_rw
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|)
decl_stmt|;
name|u_int32_t
name|device_id
decl_stmt|;
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
decl_stmt|;
name|device_id
operator|=
name|ccb_h
operator|->
name|target_id
expr_stmt|;
name|io_request
operator|=
name|cmd
operator|->
name|io_request
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|VirtualDiskTgtId
operator|=
name|device_id
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|exStatus
operator|=
literal|0
expr_stmt|;
comment|/* just the cdb len, other flags zero, and ORed-in later for FP */
name|io_request
operator|->
name|IoFlags
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
name|mrsas_setup_io
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|ccb
argument_list|,
name|device_id
argument_list|,
name|io_request
argument_list|)
operator|!=
name|SUCCESS
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Build ldio or fpio error\n"
argument_list|)
expr_stmt|;
name|io_request
operator|->
name|DataLength
operator|=
name|cmd
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|mrsas_map_request
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|ccb
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|sge_count
operator|>
name|sc
operator|->
name|max_num_sge
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Error: sge_count (0x%x) exceeds"
literal|"max (0x%x) allowed\n"
argument_list|,
name|cmd
operator|->
name|sge_count
argument_list|,
name|sc
operator|->
name|max_num_sge
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
comment|/* 		 * numSGE store lower 8 bit of sge_count. numSGEExt store 		 * higher 8 bit of sge_count 		 */
name|io_request
operator|->
name|RaidContext
operator|.
name|numSGE
operator|=
name|cmd
operator|->
name|sge_count
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|numSGEExt
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|cmd
operator|->
name|sge_count
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Data map/load failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_setup_io:	Set up data including Fast Path I/O  * input:			Adapter instance soft state  * 					Pointer to command packet  * 					Pointer to CCB  *  * This function builds the DCDB inquiry command.  It returns 0 if the command  * is built successfully, otherwise it returns a 1.  */
end_comment

begin_function
name|int
name|mrsas_setup_io
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|device_id
parameter_list|,
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|)
decl_stmt|;
name|struct
name|IO_REQUEST_INFO
name|io_info
decl_stmt|;
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map_ptr
decl_stmt|;
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
name|u_int8_t
name|fp_possible
decl_stmt|;
name|u_int32_t
name|start_lba_hi
decl_stmt|,
name|start_lba_lo
decl_stmt|,
name|ld_block_size
decl_stmt|,
name|ld
decl_stmt|;
name|u_int32_t
name|datalength
init|=
literal|0
decl_stmt|;
name|start_lba_lo
operator|=
literal|0
expr_stmt|;
name|start_lba_hi
operator|=
literal|0
expr_stmt|;
name|fp_possible
operator|=
literal|0
expr_stmt|;
comment|/* 	 * READ_6 (0x08) or WRITE_6 (0x0A) cdb 	 */
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|==
literal|6
condition|)
block|{
name|datalength
operator|=
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
expr_stmt|;
name|start_lba_lo
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|3
index|]
expr_stmt|;
name|start_lba_lo
operator|&=
literal|0x1FFFFF
expr_stmt|;
block|}
comment|/* 	 * READ_10 (0x28) or WRITE_6 (0x2A) cdb 	 */
elseif|else
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|==
literal|10
condition|)
block|{
name|datalength
operator|=
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|start_lba_lo
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
operator|<<
literal|8
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|5
index|]
operator|)
expr_stmt|;
block|}
comment|/* 	 * READ_12 (0xA8) or WRITE_12 (0xAA) cdb 	 */
elseif|else
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|==
literal|12
condition|)
block|{
name|datalength
operator|=
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|6
index|]
operator|<<
literal|24
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|7
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|9
index|]
operator|)
expr_stmt|;
name|start_lba_lo
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
operator|<<
literal|8
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|5
index|]
operator|)
expr_stmt|;
block|}
comment|/* 	 * READ_16 (0x88) or WRITE_16 (0xx8A) cdb 	 */
elseif|else
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|==
literal|16
condition|)
block|{
name|datalength
operator|=
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|10
index|]
operator|<<
literal|24
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|11
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|12
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|13
index|]
operator|)
expr_stmt|;
name|start_lba_lo
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|6
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|7
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
operator|<<
literal|8
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|9
index|]
operator|)
expr_stmt|;
name|start_lba_hi
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
operator|<<
literal|8
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|5
index|]
operator|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|io_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|IO_REQUEST_INFO
argument_list|)
argument_list|)
expr_stmt|;
name|io_info
operator|.
name|ldStartBlock
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|start_lba_hi
operator|<<
literal|32
operator|)
operator||
name|start_lba_lo
expr_stmt|;
name|io_info
operator|.
name|numBlocks
operator|=
name|datalength
expr_stmt|;
name|io_info
operator|.
name|ldTgtId
operator|=
name|device_id
expr_stmt|;
switch|switch
condition|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
condition|)
block|{
case|case
name|CAM_DIR_IN
case|:
name|io_info
operator|.
name|isRead
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CAM_DIR_OUT
case|:
name|io_info
operator|.
name|isRead
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAM_DIR_NONE
case|:
default|default:
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_TRACE
argument_list|,
literal|"From %s : DMA Flag is %d \n"
argument_list|,
name|__func__
argument_list|,
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
argument_list|)
expr_stmt|;
break|break;
block|}
name|map_ptr
operator|=
name|sc
operator|->
name|ld_drv_map
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
expr_stmt|;
name|ld_block_size
operator|=
name|MR_LdBlockSizeGet
argument_list|(
name|device_id
argument_list|,
name|map_ptr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|device_id
argument_list|,
name|map_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ld
operator|>=
name|MAX_LOGICAL_DRIVES_EXT
operator|)
operator|||
operator|(
operator|!
name|sc
operator|->
name|fast_path_io
operator|)
condition|)
block|{
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockFlags
operator|=
literal|0
expr_stmt|;
name|fp_possible
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|MR_BuildRaidContext
argument_list|(
name|sc
argument_list|,
operator|&
name|io_info
argument_list|,
operator|&
name|io_request
operator|->
name|RaidContext
argument_list|,
name|map_ptr
argument_list|)
condition|)
name|fp_possible
operator|=
name|io_info
operator|.
name|fpOkForIo
expr_stmt|;
block|}
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map_ptr
argument_list|)
expr_stmt|;
comment|/* Store the TM capability value in cmd */
name|cmd
operator|->
name|tmCapable
operator|=
name|raid
operator|->
name|capability
operator|.
name|tmCapable
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|MSIxIndex
operator|=
name|sc
operator|->
name|msix_vectors
condition|?
name|smp_processor_id
argument_list|()
operator|%
name|sc
operator|->
name|msix_vectors
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|fp_possible
condition|)
block|{
name|mrsas_set_pd_lba
argument_list|(
name|io_request
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|,
operator|&
name|io_info
argument_list|,
name|ccb
argument_list|,
name|map_ptr
argument_list|,
name|start_lba_lo
argument_list|,
name|ld_block_size
argument_list|)
expr_stmt|;
name|io_request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_SCSI_IO_REQUEST
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|RequestFlags
operator|=
operator|(
name|MPI2_REQ_DESCRIPT_FLAGS_FP_IO
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mrsas_gen3_ctrl
condition|)
block|{
if|if
condition|(
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockFlags
operator|==
name|REGION_TYPE_UNUSED
condition|)
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|RequestFlags
operator|=
operator|(
name|MRSAS_REQ_DESCRIPT_FLAGS_NO_LOCK
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|Type
operator|=
name|MPI2_TYPE_CUDA
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|nseg
operator|=
literal|0x1
expr_stmt|;
name|io_request
operator|->
name|IoFlags
operator||=
name|MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockFlags
operator||=
operator|(
name|MR_RL_FLAGS_GRANT_DESTINATION_CUDA
operator||
name|MR_RL_FLAGS_SEQ_NUM_ENABLE
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|load_balance_info
index|[
name|device_id
index|]
operator|.
name|loadBalanceFlag
operator|)
operator|&&
operator|(
name|io_info
operator|.
name|isRead
operator|)
condition|)
block|{
name|io_info
operator|.
name|devHandle
operator|=
name|mrsas_get_updated_dev_handle
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|load_balance_info
index|[
name|device_id
index|]
argument_list|,
operator|&
name|io_info
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|load_balance
operator|=
name|MRSAS_LOAD_BALANCE_FLAG
expr_stmt|;
name|cmd
operator|->
name|pd_r1_lb
operator|=
name|io_info
operator|.
name|pd_after_lb
expr_stmt|;
block|}
else|else
name|cmd
operator|->
name|load_balance
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|DevHandle
operator|=
name|io_info
operator|.
name|devHandle
expr_stmt|;
name|io_request
operator|->
name|DevHandle
operator|=
name|io_info
operator|.
name|devHandle
expr_stmt|;
block|}
else|else
block|{
comment|/* Not FP IO */
name|io_request
operator|->
name|RaidContext
operator|.
name|timeoutValue
operator|=
name|map_ptr
operator|->
name|raidMap
operator|.
name|fpPdIoTimeoutSec
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|RequestFlags
operator|=
operator|(
name|MRSAS_REQ_DESCRIPT_FLAGS_LD_IO
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mrsas_gen3_ctrl
condition|)
block|{
if|if
condition|(
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockFlags
operator|==
name|REGION_TYPE_UNUSED
condition|)
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|RequestFlags
operator|=
operator|(
name|MRSAS_REQ_DESCRIPT_FLAGS_NO_LOCK
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|Type
operator|=
name|MPI2_TYPE_CUDA
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockFlags
operator||=
operator|(
name|MR_RL_FLAGS_GRANT_DESTINATION_CPU0
operator||
name|MR_RL_FLAGS_SEQ_NUM_ENABLE
operator|)
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|nseg
operator|=
literal|0x1
expr_stmt|;
block|}
name|io_request
operator|->
name|Function
operator|=
name|MRSAS_MPI2_FUNCTION_LD_IO_REQUEST
expr_stmt|;
name|io_request
operator|->
name|DevHandle
operator|=
name|device_id
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_build_ldio_nonrw:	Builds an LDIO command  * input:				Adapter instance soft state  * 						Pointer to command packet  * 						Pointer to CCB  *  * This function builds the LDIO command packet.  It returns 0 if the command is  * built successfully, otherwise it returns a 1.  */
end_comment

begin_function
name|int
name|mrsas_build_ldio_nonrw
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
decl_stmt|;
name|u_int32_t
name|device_id
decl_stmt|,
name|ld
decl_stmt|;
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map_ptr
decl_stmt|;
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
decl_stmt|;
name|io_request
operator|=
name|cmd
operator|->
name|io_request
expr_stmt|;
name|device_id
operator|=
name|ccb_h
operator|->
name|target_id
expr_stmt|;
name|map_ptr
operator|=
name|sc
operator|->
name|ld_drv_map
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
expr_stmt|;
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|device_id
argument_list|,
name|map_ptr
argument_list|)
expr_stmt|;
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map_ptr
argument_list|)
expr_stmt|;
comment|/* Store the TM capability value in cmd */
name|cmd
operator|->
name|tmCapable
operator|=
name|raid
operator|->
name|capability
operator|.
name|tmCapable
expr_stmt|;
comment|/* FW path for LD Non-RW (SCSI management commands) */
name|io_request
operator|->
name|Function
operator|=
name|MRSAS_MPI2_FUNCTION_LD_IO_REQUEST
expr_stmt|;
name|io_request
operator|->
name|DevHandle
operator|=
name|device_id
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|RequestFlags
operator|=
operator|(
name|MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|VirtualDiskTgtId
operator|=
name|device_id
expr_stmt|;
name|io_request
operator|->
name|LUN
index|[
literal|1
index|]
operator|=
name|ccb_h
operator|->
name|target_lun
operator|&
literal|0xF
expr_stmt|;
name|io_request
operator|->
name|DataLength
operator|=
name|cmd
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|mrsas_map_request
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|ccb
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|sge_count
operator|>
name|sc
operator|->
name|max_num_sge
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Error: sge_count (0x%x) exceeds"
literal|"max (0x%x) allowed\n"
argument_list|,
name|cmd
operator|->
name|sge_count
argument_list|,
name|sc
operator|->
name|max_num_sge
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * numSGE store lower 8 bit of sge_count. numSGEExt store 		 * higher 8 bit of sge_count 		 */
name|io_request
operator|->
name|RaidContext
operator|.
name|numSGE
operator|=
name|cmd
operator|->
name|sge_count
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|numSGEExt
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|cmd
operator|->
name|sge_count
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Data map/load failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_build_syspdio:	Builds an DCDB command  * input:				Adapter instance soft state  * 						Pointer to command packet  * 						Pointer to CCB  *  * This function builds the DCDB inquiry command.  It returns 0 if the command  * is built successfully, otherwise it returns a 1.  */
end_comment

begin_function
name|int
name|mrsas_build_syspdio
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|u_int8_t
name|fp_possible
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
decl_stmt|;
name|u_int32_t
name|device_id
decl_stmt|;
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|local_map_ptr
decl_stmt|;
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
decl_stmt|;
name|struct
name|MR_PD_CFG_SEQ_NUM_SYNC
modifier|*
name|pd_sync
decl_stmt|;
name|io_request
operator|=
name|cmd
operator|->
name|io_request
expr_stmt|;
name|device_id
operator|=
name|ccb_h
operator|->
name|target_id
expr_stmt|;
name|local_map_ptr
operator|=
name|sc
operator|->
name|ld_drv_map
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|RAIDFlags
operator|=
name|MR_RAID_FLAGS_IO_SUB_TYPE_SYSTEM_PD
operator|<<
name|MR_RAID_CTX_RAID_FLAGS_IO_SUB_TYPE_SHIFT
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockFlags
operator|=
literal|0
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockRowLBA
operator|=
literal|0
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockLength
operator|=
literal|0
expr_stmt|;
comment|/* If FW supports PD sequence number */
if|if
condition|(
name|sc
operator|->
name|use_seqnum_jbod_fp
operator|&&
name|sc
operator|->
name|pd_list
index|[
name|device_id
index|]
operator|.
name|driveType
operator|==
literal|0x00
condition|)
block|{
comment|//printf("Using Drv seq num\n");
name|pd_sync
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|jbodmap_mem
index|[
operator|(
name|sc
operator|->
name|pd_seq_map_id
operator|-
literal|1
operator|)
operator|&
literal|1
index|]
expr_stmt|;
name|cmd
operator|->
name|tmCapable
operator|=
name|pd_sync
operator|->
name|seq
index|[
name|device_id
index|]
operator|.
name|capability
operator|.
name|tmCapable
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|VirtualDiskTgtId
operator|=
name|device_id
operator|+
literal|255
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|configSeqNum
operator|=
name|pd_sync
operator|->
name|seq
index|[
name|device_id
index|]
operator|.
name|seqNum
expr_stmt|;
name|io_request
operator|->
name|DevHandle
operator|=
name|pd_sync
operator|->
name|seq
index|[
name|device_id
index|]
operator|.
name|devHandle
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|regLockFlags
operator||=
operator|(
name|MR_RL_FLAGS_SEQ_NUM_ENABLE
operator||
name|MR_RL_FLAGS_GRANT_DESTINATION_CUDA
operator|)
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|Type
operator|=
name|MPI2_TYPE_CUDA
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|nseg
operator|=
literal|0x1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|fast_path_io
condition|)
block|{
comment|//printf("Using LD RAID map\n");
name|io_request
operator|->
name|RaidContext
operator|.
name|VirtualDiskTgtId
operator|=
name|device_id
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|configSeqNum
operator|=
literal|0
expr_stmt|;
name|local_map_ptr
operator|=
name|sc
operator|->
name|ld_drv_map
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
expr_stmt|;
name|io_request
operator|->
name|DevHandle
operator|=
name|local_map_ptr
operator|->
name|raidMap
operator|.
name|devHndlInfo
index|[
name|device_id
index|]
operator|.
name|curDevHdl
expr_stmt|;
block|}
else|else
block|{
comment|//printf("Using FW PATH\n");
comment|/* Want to send all IO via FW path */
name|io_request
operator|->
name|RaidContext
operator|.
name|VirtualDiskTgtId
operator|=
name|device_id
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|configSeqNum
operator|=
literal|0
expr_stmt|;
name|io_request
operator|->
name|DevHandle
operator|=
literal|0xFFFF
expr_stmt|;
block|}
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|DevHandle
operator|=
name|io_request
operator|->
name|DevHandle
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|MSIxIndex
operator|=
name|sc
operator|->
name|msix_vectors
condition|?
name|smp_processor_id
argument_list|()
operator|%
name|sc
operator|->
name|msix_vectors
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fp_possible
condition|)
block|{
comment|/* system pd firmware path */
name|io_request
operator|->
name|Function
operator|=
name|MRSAS_MPI2_FUNCTION_LD_IO_REQUEST
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|RequestFlags
operator|=
operator|(
name|MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|timeoutValue
operator|=
name|local_map_ptr
operator|->
name|raidMap
operator|.
name|fpPdIoTimeoutSec
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|VirtualDiskTgtId
operator|=
name|device_id
expr_stmt|;
block|}
else|else
block|{
comment|/* system pd fast path */
name|io_request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_SCSI_IO_REQUEST
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|timeoutValue
operator|=
name|local_map_ptr
operator|->
name|raidMap
operator|.
name|fpPdIoTimeoutSec
expr_stmt|;
comment|/* 		 * NOTE - For system pd RW cmds only IoFlags will be FAST_PATH 		 * Because the NON RW cmds will now go via FW Queue 		 * and not the Exception queue 		 */
name|io_request
operator|->
name|IoFlags
operator||=
name|MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH
expr_stmt|;
name|cmd
operator|->
name|request_desc
operator|->
name|SCSIIO
operator|.
name|RequestFlags
operator|=
operator|(
name|MPI2_REQ_DESCRIPT_FLAGS_FP_IO
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
block|}
name|io_request
operator|->
name|LUN
index|[
literal|1
index|]
operator|=
name|ccb_h
operator|->
name|target_lun
operator|&
literal|0xF
expr_stmt|;
name|io_request
operator|->
name|DataLength
operator|=
name|cmd
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|mrsas_map_request
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|ccb
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|sge_count
operator|>
name|sc
operator|->
name|max_num_sge
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Error: sge_count (0x%x) exceeds"
literal|"max (0x%x) allowed\n"
argument_list|,
name|cmd
operator|->
name|sge_count
argument_list|,
name|sc
operator|->
name|max_num_sge
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * numSGE store lower 8 bit of sge_count. numSGEExt store 		 * higher 8 bit of sge_count 		 */
name|io_request
operator|->
name|RaidContext
operator|.
name|numSGE
operator|=
name|cmd
operator|->
name|sge_count
expr_stmt|;
name|io_request
operator|->
name|RaidContext
operator|.
name|numSGEExt
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|cmd
operator|->
name|sge_count
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Data map/load failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_map_request:	Map and load data  * input:				Adapter instance soft state  * 						Pointer to command packet  *  * For data from OS, map and load the data buffer into bus space.  The SG list  * is built in the callback.  If the  bus dmamap load is not successful,  * cmd->error_code will contain the  error code and a 1 is returned.  */
end_comment

begin_function
name|int
name|mrsas_map_request
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|u_int32_t
name|retcode
init|=
literal|0
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|sim
operator|=
name|xpt_path_sim
argument_list|(
name|cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
comment|/* Map data buffer into bus space */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|902001
operator|)
name|retcode
operator|=
name|bus_dmamap_load_ccb
argument_list|(
name|sc
operator|->
name|data_tag
argument_list|,
name|cmd
operator|->
name|data_dmamap
argument_list|,
name|ccb
argument_list|,
name|mrsas_data_load_cb
argument_list|,
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|retcode
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|data_tag
argument_list|,
name|cmd
operator|->
name|data_dmamap
argument_list|,
name|cmd
operator|->
name|data
argument_list|,
name|cmd
operator|->
name|length
argument_list|,
name|mrsas_data_load_cb
argument_list|,
name|cmd
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"bus_dmamap_load(): retcode = %d\n"
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
name|EINPROGRESS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"request load in progress\n"
argument_list|)
expr_stmt|;
name|mrsas_freeze_simq
argument_list|(
name|cmd
argument_list|,
name|sim
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cmd
operator|->
name|error_code
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_unmap_request:	Unmap and unload data  * input:				Adapter instance soft state  * 						Pointer to command packet  *  * This function unmaps and unloads data from OS.  */
end_comment

begin_function
name|void
name|mrsas_unmap_request
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MRSAS_DIR_IN
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|data_tag
argument_list|,
name|cmd
operator|->
name|data_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MRSAS_DIR_OUT
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|data_tag
argument_list|,
name|cmd
operator|->
name|data_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|data_tag
argument_list|,
name|cmd
operator|->
name|data_dmamap
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * mrsas_data_load_cb:	Callback entry point  * input:				Pointer to command packet as argument  * 						Pointer to segment  * 						Number of segments Error  *  * This is the callback function of the bus dma map load.  It builds the SG  * list.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_data_load_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
init|=
operator|(
expr|struct
name|mrsas_mpt_cmd
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|mrsas_softc
modifier|*
name|sc
init|=
name|cmd
operator|->
name|sc
decl_stmt|;
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
decl_stmt|;
name|pMpi25IeeeSgeChain64_t
name|sgl_ptr
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|sg_processed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmd
operator|->
name|error_code
operator|=
name|error
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"mrsas_data_load_cb: error=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_TOO_BIG
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MRSAS_DIR_IN
condition|)
name|bus_dmamap_sync
argument_list|(
name|cmd
operator|->
name|sc
operator|->
name|data_tag
argument_list|,
name|cmd
operator|->
name|data_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MRSAS_DIR_OUT
condition|)
name|bus_dmamap_sync
argument_list|(
name|cmd
operator|->
name|sc
operator|->
name|data_tag
argument_list|,
name|cmd
operator|->
name|data_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|>
name|sc
operator|->
name|max_num_sge
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"SGE count is too large or 0.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|io_request
operator|=
name|cmd
operator|->
name|io_request
expr_stmt|;
name|sgl_ptr
operator|=
operator|(
name|pMpi25IeeeSgeChain64_t
operator|)
operator|&
name|io_request
operator|->
name|SGL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mrsas_gen3_ctrl
condition|)
block|{
name|pMpi25IeeeSgeChain64_t
name|sgl_ptr_end
init|=
name|sgl_ptr
decl_stmt|;
name|sgl_ptr_end
operator|+=
name|sc
operator|->
name|max_sge_in_main_msg
operator|-
literal|1
expr_stmt|;
name|sgl_ptr_end
operator|->
name|Flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|sgl_ptr
operator|->
name|Address
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sgl_ptr
operator|->
name|Length
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
name|sgl_ptr
operator|->
name|Flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mrsas_gen3_ctrl
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|nseg
operator|-
literal|1
condition|)
name|sgl_ptr
operator|->
name|Flags
operator|=
name|IEEE_SGE_FLAGS_END_OF_LIST
expr_stmt|;
block|}
name|sgl_ptr
operator|++
expr_stmt|;
name|sg_processed
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|sg_processed
operator|==
operator|(
name|sc
operator|->
name|max_sge_in_main_msg
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|nseg
operator|>
name|sc
operator|->
name|max_sge_in_main_msg
operator|)
condition|)
block|{
name|pMpi25IeeeSgeChain64_t
name|sg_chain
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mrsas_gen3_ctrl
condition|)
block|{
if|if
condition|(
operator|(
name|cmd
operator|->
name|io_request
operator|->
name|IoFlags
operator|&
name|MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH
operator|)
operator|!=
name|MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH
condition|)
name|cmd
operator|->
name|io_request
operator|->
name|ChainOffset
operator|=
name|sc
operator|->
name|chain_offset_io_request
expr_stmt|;
else|else
name|cmd
operator|->
name|io_request
operator|->
name|ChainOffset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cmd
operator|->
name|io_request
operator|->
name|ChainOffset
operator|=
name|sc
operator|->
name|chain_offset_io_request
expr_stmt|;
name|sg_chain
operator|=
name|sgl_ptr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mrsas_gen3_ctrl
condition|)
name|sg_chain
operator|->
name|Flags
operator|=
name|IEEE_SGE_FLAGS_CHAIN_ELEMENT
expr_stmt|;
else|else
name|sg_chain
operator|->
name|Flags
operator|=
operator|(
name|IEEE_SGE_FLAGS_CHAIN_ELEMENT
operator||
name|MPI2_IEEE_SGE_FLAGS_IOCPLBNTA_ADDR
operator|)
expr_stmt|;
name|sg_chain
operator|->
name|Length
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
operator|*
operator|(
name|nseg
operator|-
name|sg_processed
operator|)
operator|)
expr_stmt|;
name|sg_chain
operator|->
name|Address
operator|=
name|cmd
operator|->
name|chain_frame_phys_addr
expr_stmt|;
name|sgl_ptr
operator|=
operator|(
name|pMpi25IeeeSgeChain64_t
operator|)
name|cmd
operator|->
name|chain_frame
expr_stmt|;
block|}
block|}
block|}
name|cmd
operator|->
name|sge_count
operator|=
name|nseg
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mrsas_freeze_simq:	Freeze SIM queue  * input:				Pointer to command packet  * 						Pointer to SIM  *  * This function freezes the sim queue.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_freeze_simq
parameter_list|(
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|(
name|cmd
operator|->
name|ccb_ptr
operator|)
decl_stmt|;
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mrsas_xpt_freeze
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|xpt_freeze_simq
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mrsas_xpt_release
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|xpt_release_simq
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mrsas_cmd_done:	Perform remaining command completion  * input:			Adapter instance soft state  Pointer to command packet  *  * This function calls ummap request and releases the MPT command.  */
end_comment

begin_function
name|void
name|mrsas_cmd_done
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|mrsas_unmap_request
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|cmd
operator|->
name|cm_callout
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|cmd
operator|->
name|ccb_ptr
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ccb_ptr
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mrsas_cam_poll:	Polling entry point  * input:			Pointer to SIM  *  * This is currently a stub function.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_cam_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|mrsas_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|mrsas_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_vectors
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msix_vectors
condition|;
name|i
operator|++
control|)
block|{
name|mrsas_complete_cmd
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mrsas_complete_cmd
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * mrsas_bus_scan:	Perform bus scan  * input:			Adapter instance soft state  *  * This mrsas_bus_scan function is needed for FreeBSD 7.x.  Also, it should not  * be called in FreeBSD 8.x and later versions, where the bus scan is  * automatic.  */
end_comment

begin_function
name|int
name|mrsas_bus_scan
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb_0
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb_1
decl_stmt|;
if|if
condition|(
operator|(
name|ccb_0
operator|=
name|xpt_alloc_ccb
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb_1
operator|=
name|xpt_alloc_ccb
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|ccb_0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb_0
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_0
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|ccb_0
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb_1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb_1
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sim_1
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|ccb_0
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb_1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
name|xpt_rescan
argument_list|(
name|ccb_0
argument_list|)
expr_stmt|;
name|xpt_rescan
argument_list|(
name|ccb_1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_bus_scan_sim:	Perform bus scan per SIM  * input:				adapter instance soft state  *  * This function will be called from Event handler on LD creation/deletion,  * JBOD on/off.  */
end_comment

begin_function
name|int
name|mrsas_bus_scan_sim
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
name|xpt_alloc_ccb
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|cam_sim_path
argument_list|(
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
name|xpt_rescan
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_track_scsiio:  Track IOs for a given target in the mpt_cmd_list  * input:           Adapter instance soft state  *                  Target ID of target  *                  Bus ID of the target  *  * This function checks for any pending IO in the whole mpt_cmd_list pool  * with the bus_id and target_id passed in arguments. If some IO is found  * that means target reset is not successfully completed.  *  * Returns FAIL if IOs pending to the target device, else return SUCCESS  */
end_comment

begin_function
specifier|static
name|int
name|mrsas_track_scsiio
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|target_id_t
name|tgt_id
parameter_list|,
name|u_int32_t
name|bus_id
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|mrsas_mpt_cmd
modifier|*
name|mpt_cmd
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_fw_cmds
condition|;
name|i
operator|++
control|)
block|{
name|mpt_cmd
operator|=
name|sc
operator|->
name|mpt_cmd_list
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Check if the target_id and bus_id is same as the timeout IO 	 */
if|if
condition|(
name|mpt_cmd
operator|->
name|ccb_ptr
condition|)
block|{
comment|/* bus_id = 1 denotes a VD */
if|if
condition|(
name|bus_id
operator|==
literal|1
condition|)
name|tgt_id
operator|=
operator|(
name|mpt_cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|target_id
operator|-
operator|(
name|MRSAS_MAX_PD
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|mpt_cmd
operator|->
name|ccb_ptr
operator|->
name|cpi
operator|.
name|bus_id
operator|==
name|bus_id
operator|&&
name|mpt_cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
name|tgt_id
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"IO commands pending to target id %d\n"
argument_list|,
name|tgt_id
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TM_DEBUG
end_if

begin_comment
comment|/*  * mrsas_tm_response_code: Prints TM response code received from FW  * input:           Adapter instance soft state  *                  MPI reply returned from firmware  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_tm_response_code
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|MPI2_SCSI_TASK_MANAGE_REPLY
modifier|*
name|mpi_reply
parameter_list|)
block|{
name|char
modifier|*
name|desc
decl_stmt|;
switch|switch
condition|(
name|mpi_reply
operator|->
name|ResponseCode
condition|)
block|{
case|case
name|MPI2_SCSITASKMGMT_RSP_TM_COMPLETE
case|:
name|desc
operator|=
literal|"task management request completed"
expr_stmt|;
break|break;
case|case
name|MPI2_SCSITASKMGMT_RSP_INVALID_FRAME
case|:
name|desc
operator|=
literal|"invalid frame"
expr_stmt|;
break|break;
case|case
name|MPI2_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED
case|:
name|desc
operator|=
literal|"task management request not supported"
expr_stmt|;
break|break;
case|case
name|MPI2_SCSITASKMGMT_RSP_TM_FAILED
case|:
name|desc
operator|=
literal|"task management request failed"
expr_stmt|;
break|break;
case|case
name|MPI2_SCSITASKMGMT_RSP_TM_SUCCEEDED
case|:
name|desc
operator|=
literal|"task management request succeeded"
expr_stmt|;
break|break;
case|case
name|MPI2_SCSITASKMGMT_RSP_TM_INVALID_LUN
case|:
name|desc
operator|=
literal|"invalid lun"
expr_stmt|;
break|break;
case|case
literal|0xA
case|:
name|desc
operator|=
literal|"overlapped tag attempted"
expr_stmt|;
break|break;
case|case
name|MPI2_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC
case|:
name|desc
operator|=
literal|"task queued, however not sent to target"
expr_stmt|;
break|break;
default|default:
name|desc
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"response_code(%01x): %s\n"
argument_list|,
name|mpi_reply
operator|->
name|ResponseCode
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"TerminationCount/DevHandle/Function/TaskType/IOCStat/IOCLoginfo\n"
literal|"0x%x/0x%x/0x%x/0x%x/0x%x/0x%x\n"
argument_list|,
name|mpi_reply
operator|->
name|TerminationCount
argument_list|,
name|mpi_reply
operator|->
name|DevHandle
argument_list|,
name|mpi_reply
operator|->
name|Function
argument_list|,
name|mpi_reply
operator|->
name|TaskType
argument_list|,
name|mpi_reply
operator|->
name|IOCStatus
argument_list|,
name|mpi_reply
operator|->
name|IOCLogInfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * mrsas_issue_tm:  Fires the TM command to FW and waits for completion  * input:           Adapter instance soft state  *                  reqest descriptor compiled by mrsas_reset_targets  *  * Returns FAIL if TM command TIMEDOUT from FW else SUCCESS.  */
end_comment

begin_function
specifier|static
name|int
name|mrsas_issue_tm
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|req_desc
parameter_list|)
block|{
name|int
name|sleep_stat
decl_stmt|;
name|mrsas_fire_cmd
argument_list|(
name|sc
argument_list|,
name|req_desc
operator|->
name|addr
operator|.
name|u
operator|.
name|low
argument_list|,
name|req_desc
operator|->
name|addr
operator|.
name|u
operator|.
name|high
argument_list|)
expr_stmt|;
name|sleep_stat
operator|=
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|ocr_chan
argument_list|,
operator|&
name|sc
operator|->
name|sim_lock
argument_list|,
name|PRIBIO
argument_list|,
literal|"tm_sleep"
argument_list|,
literal|50
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleep_stat
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"tm cmd TIMEDOUT\n"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_reset_targets : Gathers info to fire a target reset command  * input:           Adapter instance soft state  *  * This function compiles data for a target reset command to be fired to the FW  * and then traverse the target_reset_pool to see targets with TIMEDOUT IOs.  *  * Returns SUCCESS or FAIL  */
end_comment

begin_function
name|int
name|mrsas_reset_targets
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mrsas_mpt_cmd
modifier|*
name|tm_mpt_cmd
init|=
name|NULL
decl_stmt|;
name|struct
name|mrsas_mpt_cmd
modifier|*
name|tgt_mpt_cmd
init|=
name|NULL
decl_stmt|;
name|MR_TASK_MANAGE_REQUEST
modifier|*
name|mr_request
decl_stmt|;
name|MPI2_SCSI_TASK_MANAGE_REQUEST
modifier|*
name|tm_mpi_request
decl_stmt|;
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|req_desc
decl_stmt|;
name|int
name|retCode
init|=
name|FAIL
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|,
name|outstanding
decl_stmt|;
name|u_int32_t
name|MSIxIndex
decl_stmt|,
name|bus_id
decl_stmt|;
name|target_id_t
name|tgt_id
decl_stmt|;
if|#
directive|if
name|TM_DEBUG
name|MPI2_SCSI_TASK_MANAGE_REPLY
modifier|*
name|mpi_reply
decl_stmt|;
endif|#
directive|endif
name|outstanding
operator|=
name|mrsas_atomic_read
argument_list|(
operator|&
name|sc
operator|->
name|fw_outstanding
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outstanding
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"NO IOs pending...\n"
argument_list|)
expr_stmt|;
name|mrsas_atomic_set
argument_list|(
operator|&
name|sc
operator|->
name|target_reset_outstanding
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retCode
operator|=
name|SUCCESS
expr_stmt|;
goto|goto
name|return_status
goto|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|adprecovery
operator|!=
name|MRSAS_HBA_OPERATIONAL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Controller is not operational\n"
argument_list|)
expr_stmt|;
goto|goto
name|return_status
goto|;
block|}
else|else
block|{
comment|/* Some more error checks will be added in future */
block|}
comment|/* Get an mpt frame and an index to fire the TM cmd */
name|tm_mpt_cmd
operator|=
name|mrsas_get_mpt_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tm_mpt_cmd
condition|)
block|{
name|retCode
operator|=
name|FAIL
expr_stmt|;
goto|goto
name|return_status
goto|;
block|}
name|req_desc
operator|=
name|mrsas_get_request_desc
argument_list|(
name|sc
argument_list|,
operator|(
name|tm_mpt_cmd
operator|->
name|index
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req_desc
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot get request_descriptor for tm.\n"
argument_list|)
expr_stmt|;
name|retCode
operator|=
name|FAIL
expr_stmt|;
goto|goto
name|release_mpt
goto|;
block|}
name|memset
argument_list|(
name|req_desc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MRSAS_REQUEST_DESCRIPTOR_UNION
argument_list|)
argument_list|)
expr_stmt|;
name|req_desc
operator|->
name|HighPriority
operator|.
name|SMID
operator|=
name|tm_mpt_cmd
operator|->
name|index
expr_stmt|;
name|req_desc
operator|->
name|HighPriority
operator|.
name|RequestFlags
operator|=
operator|(
name|MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
name|req_desc
operator|->
name|HighPriority
operator|.
name|MSIxIndex
operator|=
literal|0
expr_stmt|;
name|req_desc
operator|->
name|HighPriority
operator|.
name|LMID
operator|=
literal|0
expr_stmt|;
name|req_desc
operator|->
name|HighPriority
operator|.
name|Reserved1
operator|=
literal|0
expr_stmt|;
name|tm_mpt_cmd
operator|->
name|request_desc
operator|=
name|req_desc
expr_stmt|;
name|mr_request
operator|=
operator|(
name|MR_TASK_MANAGE_REQUEST
operator|*
operator|)
name|tm_mpt_cmd
operator|->
name|io_request
expr_stmt|;
name|memset
argument_list|(
name|mr_request
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MR_TASK_MANAGE_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|tm_mpi_request
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REQUEST
operator|*
operator|)
operator|&
name|mr_request
operator|->
name|TmRequest
expr_stmt|;
name|tm_mpi_request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_SCSI_TASK_MGMT
expr_stmt|;
name|tm_mpi_request
operator|->
name|TaskType
operator|=
name|MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET
expr_stmt|;
name|tm_mpi_request
operator|->
name|TaskMID
operator|=
literal|0
expr_stmt|;
comment|/* smid task */
name|tm_mpi_request
operator|->
name|LUN
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Traverse the tm_mpt pool to get valid entries */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MRSAS_MAX_TM_TARGETS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|target_reset_pool
index|[
name|i
index|]
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|tgt_mpt_cmd
operator|=
name|sc
operator|->
name|target_reset_pool
index|[
name|i
index|]
expr_stmt|;
block|}
name|tgt_id
operator|=
name|i
expr_stmt|;
comment|/* See if the target is tm capable or NOT */
if|if
condition|(
operator|!
name|tgt_mpt_cmd
operator|->
name|tmCapable
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Task management NOT SUPPORTED for "
literal|"CAM target:%d\n"
argument_list|,
name|tgt_id
argument_list|)
expr_stmt|;
name|retCode
operator|=
name|FAIL
expr_stmt|;
goto|goto
name|release_mpt
goto|;
block|}
name|tm_mpi_request
operator|->
name|DevHandle
operator|=
name|tgt_mpt_cmd
operator|->
name|io_request
operator|->
name|DevHandle
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|MRSAS_MAX_PD
operator|-
literal|1
operator|)
condition|)
block|{
name|mr_request
operator|->
name|uTmReqReply
operator|.
name|tmReqFlags
operator|.
name|isTMForPD
operator|=
literal|1
expr_stmt|;
name|bus_id
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mr_request
operator|->
name|uTmReqReply
operator|.
name|tmReqFlags
operator|.
name|isTMForLD
operator|=
literal|1
expr_stmt|;
name|bus_id
operator|=
literal|1
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"TM will be fired for "
literal|"CAM target:%d and bus_id %d\n"
argument_list|,
name|tgt_id
argument_list|,
name|bus_id
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ocr_chan
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|tm_mpt_cmd
expr_stmt|;
name|retCode
operator|=
name|mrsas_issue_tm
argument_list|(
name|sc
argument_list|,
name|req_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|retCode
operator|==
name|FAIL
condition|)
goto|goto
name|release_mpt
goto|;
if|#
directive|if
name|TM_DEBUG
name|mpi_reply
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REPLY
operator|*
operator|)
operator|&
name|mr_request
operator|->
name|uTmReqReply
operator|.
name|TMReply
expr_stmt|;
name|mrsas_tm_response_code
argument_list|(
name|sc
argument_list|,
name|mpi_reply
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mrsas_atomic_dec
argument_list|(
operator|&
name|sc
operator|->
name|target_reset_outstanding
argument_list|)
expr_stmt|;
name|sc
operator|->
name|target_reset_pool
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Check for pending cmds in the mpt_cmd_pool with the tgt_id */
name|mrsas_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Wait for 1 second to complete parallel ISR calling same 		 * mrsas_complete_cmd() 		 */
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|ocr_chan
argument_list|,
operator|&
name|sc
operator|->
name|sim_lock
argument_list|,
name|PRIBIO
argument_list|,
literal|"mrsas_reset_wakeup"
argument_list|,
literal|1
operator|*
name|hz
argument_list|)
expr_stmt|;
name|count
operator|=
name|sc
operator|->
name|msix_vectors
operator|>
literal|0
condition|?
name|sc
operator|->
name|msix_vectors
else|:
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|MSIxIndex
operator|=
literal|0
init|;
name|MSIxIndex
operator|<
name|count
condition|;
name|MSIxIndex
operator|++
control|)
name|mrsas_complete_cmd
argument_list|(
name|sc
argument_list|,
name|MSIxIndex
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
name|retCode
operator|=
name|mrsas_track_scsiio
argument_list|(
name|sc
argument_list|,
name|tgt_id
argument_list|,
name|bus_id
argument_list|)
expr_stmt|;
name|mrsas_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|retCode
operator|==
name|FAIL
condition|)
goto|goto
name|release_mpt
goto|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Number of targets outstanding "
literal|"after reset: %d\n"
argument_list|,
name|mrsas_atomic_read
argument_list|(
operator|&
name|sc
operator|->
name|target_reset_outstanding
argument_list|)
argument_list|)
expr_stmt|;
name|release_mpt
label|:
name|mrsas_release_mpt_cmd
argument_list|(
name|tm_mpt_cmd
argument_list|)
expr_stmt|;
name|return_status
label|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"target reset %s!!\n"
argument_list|,
operator|(
name|retCode
operator|==
name|SUCCESS
operator|)
condition|?
literal|"SUCCESS"
else|:
literal|"FAIL"
argument_list|)
expr_stmt|;
return|return
name|retCode
return|;
block|}
end_function

end_unit

