begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2014, LSI Corp.  * All rights reserved.  * Author: Marian Choy  * Support: freebsdraid@lsi.com  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  * 3. Neither the name of the<ORGANIZATION> nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation  * are those of the authors and should not be interpreted as representing  * official policies,either expressed or implied, of the FreeBSD Project.  *  * Send feedback to:<megaraidfbsd@lsi.com>  * Mail to: LSI Corporation, 1621 Barber Lane, Milpitas, CA 95035  *    ATTN: MegaRaid FreeBSD  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/mrsas/mrsas.h>
end_include

begin_include
include|#
directive|include
file|<dev/mrsas/mrsas_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_comment
comment|/*   * Function prototypes   */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|mrsas_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|mrsas_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|mrsas_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|mrsas_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|mrsas_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mrsas_mgmt_info
name|mrsas_mgmt_info
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|mrsas_ident
modifier|*
name|mrsas_find_ident
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_shutdown_ctlr
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|opcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_flush_cache
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_reset_reply_desc
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_ocr_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_get_map_info
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_get_ld_map_info
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_sync_map_info
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_get_pd_list
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_get_ld_list
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_setup_irq
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_alloc_mem
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_init_fw
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_setup_raidmap
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_complete_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_clear_intr
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_get_ctrl_info
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_ctrl_info
modifier|*
name|ctrl_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_issue_blocked_abort_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd_to_abort
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int32_t
name|mrsas_read_reg
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int8_t
name|mrsas_build_mptmfi_passthru
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|mfi_cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_transition_to_ready
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ocr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_init_adapter
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_alloc_mpt_cmds
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_alloc_ioc_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_alloc_ctlr_info_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_ioc_init
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_bus_scan
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_issue_dcmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_issue_polled
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_reset_ctrl
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_wait_for_outstanding
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_issue_blocked_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_alloc_tmp_dcmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_tmp_dcmd
modifier|*
name|tcmd
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_release_mfi_cmd
parameter_list|(
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_wakeup
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_complete_aen
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_complete_abort
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_disable_intr
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_enable_intr
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_free_ioc_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_free_mem
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_free_tmp_dcmd
parameter_list|(
name|struct
name|mrsas_tmp_dcmd
modifier|*
name|tmp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_isr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_teardown_intr
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_addr_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_kill_hba
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_aen_handler
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_write_reg
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|u_int32_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_fire_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|req_desc_lo
parameter_list|,
name|u_int32_t
name|req_desc_hi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_free_ctlr_info_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_complete_mptmfi_passthru
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|,
name|u_int8_t
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_map_mpt_cmd_status
parameter_list|(
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|u_int8_t
name|extStatus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|mrsas_mfi_cmd
modifier|*
name|mrsas_get_mfi_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|mrsas_build_mpt_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|mrsas_cam_attach
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mrsas_cam_detach
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mrsas_cmd_done
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mrsas_free_frame
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|mrsas_alloc_mfi_cmds
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mrsas_release_mpt_cmd
parameter_list|(
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|mrsas_mpt_cmd
modifier|*
name|mrsas_get_mpt_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|mrsas_passthru
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|u_long
name|ioctlCmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|uint8_t
name|MR_ValidateMapInfo
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int16_t
name|MR_GetLDTgtId
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|MR_LD_RAID
modifier|*
name|MR_LdRaidGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mrsas_xpt_freeze
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mrsas_xpt_release
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|mrsas_get_request_desc
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|mrsas_bus_scan_sim
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_alloc_evt_log_info_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_free_evt_log_info_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|mrsas
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"MRSAS Driver Parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * PCI device struct and table  *  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|mrsas_ident
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
name|uint16_t
name|subvendor
decl_stmt|;
name|uint16_t
name|subdevice
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|MRSAS_CTLR_ID
typedef|;
end_typedef

begin_decl_stmt
name|MRSAS_CTLR_ID
name|device_table
index|[]
init|=
block|{
block|{
literal|0x1000
block|,
name|MRSAS_TBOLT
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|"LSI Thunderbolt SAS Controller"
block|}
block|,
block|{
literal|0x1000
block|,
name|MRSAS_INVADER
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|"LSI Invader SAS Controller"
block|}
block|,
block|{
literal|0x1000
block|,
name|MRSAS_FURY
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|"LSI Fury SAS Controller"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Character device entry points   *  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|mrsas_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|mrsas_open
block|,
operator|.
name|d_close
operator|=
name|mrsas_close
block|,
operator|.
name|d_read
operator|=
name|mrsas_read
block|,
operator|.
name|d_write
operator|=
name|mrsas_write
block|,
operator|.
name|d_ioctl
operator|=
name|mrsas_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"mrsas"
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MRSAS
argument_list|,
literal|"mrsasbuf"
argument_list|,
literal|"Buffers for the MRSAS driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * In the cdevsw routines, we find our softc by using the si_drv1 member  * of struct cdev.  We set this variable to point to our softc in our  * attach routine when we create the /dev entry.  */
end_comment

begin_function
name|int
name|mrsas_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mrsas_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mrsas_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mrsas_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   * Register Read/Write Functions   *  */
end_comment

begin_function
name|void
name|mrsas_write_reg
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|u_int32_t
name|value
parameter_list|)
block|{
name|bus_space_tag_t
name|bus_tag
init|=
name|sc
operator|->
name|bus_tag
decl_stmt|;
name|bus_space_handle_t
name|bus_handle
init|=
name|sc
operator|->
name|bus_handle
decl_stmt|;
name|bus_space_write_4
argument_list|(
name|bus_tag
argument_list|,
name|bus_handle
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|mrsas_read_reg
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|bus_space_tag_t
name|bus_tag
init|=
name|sc
operator|->
name|bus_tag
decl_stmt|;
name|bus_space_handle_t
name|bus_handle
init|=
name|sc
operator|->
name|bus_handle
decl_stmt|;
return|return
operator|(
operator|(
name|u_int32_t
operator|)
name|bus_space_read_4
argument_list|(
name|bus_tag
argument_list|,
name|bus_handle
argument_list|,
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   * Interrupt Disable/Enable/Clear Functions   *  */
end_comment

begin_function
name|void
name|mrsas_disable_intr
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|mask
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_intr_mask
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* Dummy read to force pci flush */
name|status
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_intr_mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mrsas_enable_intr
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|mask
init|=
name|MFI_FUSION_ENABLE_INTERRUPT_MASK
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_intr_status
argument_list|)
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_intr_status
argument_list|)
argument_list|)
expr_stmt|;
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_intr_mask
argument_list|)
argument_list|,
operator|~
name|mask
argument_list|)
expr_stmt|;
name|status
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_intr_mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mrsas_clear_intr
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|status
decl_stmt|,
name|fw_status
decl_stmt|,
name|fw_state
decl_stmt|;
comment|/* Read received interrupt */
name|status
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_intr_status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If FW state change interrupt is received, write to it again to clear */
if|if
condition|(
name|status
operator|&
name|MRSAS_FW_STATE_CHNG_INTERRUPT
condition|)
block|{
name|fw_status
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_scratch_pad
argument_list|)
argument_list|)
expr_stmt|;
name|fw_state
operator|=
name|fw_status
operator|&
name|MFI_STATE_MASK
expr_stmt|;
if|if
condition|(
name|fw_state
operator|==
name|MFI_STATE_FAULT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"FW is in FAULT state!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ocr_thread_active
condition|)
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|ocr_chan
argument_list|)
expr_stmt|;
block|}
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_intr_status
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_intr_status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Not our interrupt, so just return */
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|MFI_FUSION_ENABLE_INTERRUPT_MASK
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* We got a reply interrupt */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   * PCI Support Functions   *  */
end_comment

begin_function
specifier|static
name|struct
name|mrsas_ident
modifier|*
name|mrsas_find_ident
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mrsas_ident
modifier|*
name|pci_device
decl_stmt|;
for|for
control|(
name|pci_device
operator|=
name|device_table
init|;
name|pci_device
operator|->
name|vendor
operator|!=
literal|0
condition|;
name|pci_device
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pci_device
operator|->
name|vendor
operator|==
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
operator|(
name|pci_device
operator|->
name|device
operator|==
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|pci_device
operator|->
name|subvendor
operator|==
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
operator|)
operator|||
operator|(
name|pci_device
operator|->
name|subvendor
operator|==
literal|0xffff
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_device
operator|->
name|subdevice
operator|==
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
operator|)
operator|||
operator|(
name|pci_device
operator|->
name|subdevice
operator|==
literal|0xffff
operator|)
operator|)
condition|)
return|return
operator|(
name|pci_device
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mrsas_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|static
name|u_int8_t
name|first_ctrl
init|=
literal|1
decl_stmt|;
name|struct
name|mrsas_ident
modifier|*
name|id
decl_stmt|;
if|if
condition|(
operator|(
name|id
operator|=
name|mrsas_find_ident
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|first_ctrl
condition|)
block|{
name|printf
argument_list|(
literal|"LSI MegaRAID SAS FreeBSD mrsas driver version: %s\n"
argument_list|,
name|MRSAS_VERSION
argument_list|)
expr_stmt|;
name|first_ctrl
operator|=
literal|0
expr_stmt|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|id
operator|->
name|desc
argument_list|)
expr_stmt|;
comment|/* between BUS_PROBE_DEFAULT and BUS_PROBE_LOW_PRIORITY */
return|return
operator|(
operator|-
literal|30
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_setup_sysctl:  setup sysctl values for mrsas  * input:               Adapter instance soft state  *  * Setup sysctl entries for mrsas driver.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_setup_sysctl
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|sysctl_ctx
init|=
name|NULL
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sysctl_tree
init|=
name|NULL
decl_stmt|;
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|,
name|tmpstr2
index|[
literal|80
index|]
decl_stmt|;
comment|/*      * Setup the sysctl variable so the user can change the debug level      * on the fly.      */
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"MRSAS controller %d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr2
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr2
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|)
argument_list|)
expr_stmt|;
name|sysctl_ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl_ctx
operator|!=
name|NULL
condition|)
name|sysctl_tree
operator|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl_tree
operator|==
name|NULL
condition|)
block|{
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw_mrsas
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|tmpstr2
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sysctl_tree
operator|==
name|NULL
condition|)
return|return;
name|sysctl_ctx
operator|=
operator|&
name|sc
operator|->
name|sysctl_ctx
expr_stmt|;
name|sysctl_tree
operator|=
name|sc
operator|->
name|sysctl_tree
expr_stmt|;
block|}
name|SYSCTL_ADD_UINT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"disable_ocr"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|disableOnlineCtrlReset
argument_list|,
literal|0
argument_list|,
literal|"Disable the use of OCR"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"driver_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|MRSAS_VERSION
argument_list|,
name|strlen
argument_list|(
name|MRSAS_VERSION
argument_list|)
argument_list|,
literal|"driver version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"reset_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|reset_count
argument_list|,
literal|0
argument_list|,
literal|"number of ocr from start of the day"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fw_outstanding"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|fw_outstanding
argument_list|,
literal|0
argument_list|,
literal|"FW outstanding commands"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"io_cmds_highwater"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|io_cmds_highwater
argument_list|,
literal|0
argument_list|,
literal|"Max FW outstanding commands"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mrsas_debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|mrsas_debug
argument_list|,
literal|0
argument_list|,
literal|"Driver debug level"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mrsas_io_timeout"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|mrsas_io_timeout
argument_list|,
literal|0
argument_list|,
literal|"Driver IO timeout value in mili-second."
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mrsas_fw_fault_check_delay"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|mrsas_fw_fault_check_delay
argument_list|,
literal|0
argument_list|,
literal|"FW fault check thread delay in seconds.<default is 1 sec>"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"reset_in_progress"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|reset_in_progress
argument_list|,
literal|0
argument_list|,
literal|"ocr in progress status"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_get_tunables:  get tunable parameters.  * input:               Adapter instance soft state  *  * Get tunable parameters. This will help to debug driver at boot time.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_get_tunables
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|;
comment|/* XXX default to some debugging for now */
name|sc
operator|->
name|mrsas_debug
operator|=
name|MRSAS_FAULT
expr_stmt|;
name|sc
operator|->
name|mrsas_io_timeout
operator|=
name|MRSAS_IO_TIMEOUT
expr_stmt|;
name|sc
operator|->
name|mrsas_fw_fault_check_delay
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|reset_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|reset_in_progress
operator|=
literal|0
expr_stmt|;
comment|/*      * Grab the global variables.      */
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mrsas.debug_level"
argument_list|,
operator|&
name|sc
operator|->
name|mrsas_debug
argument_list|)
expr_stmt|;
comment|/* Grab the unit-instance variables */
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mrsas.%d.debug_level"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|mrsas_debug
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_alloc_evt_log_info cmd:	Allocates memory to get event log information.  * 								  	Used to get sequence number at driver load time.  * input:                      	  	Adapter soft state  *  * Allocates DMAable memory for the event log info internal command.  */
end_comment

begin_function
name|int
name|mrsas_alloc_evt_log_info_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|el_info_size
decl_stmt|;
comment|/* Allocate get event log info command */
name|el_info_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_evt_log_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
comment|// parent
literal|1
argument_list|,
literal|0
argument_list|,
comment|// algnmnt, boundary
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// filter, filterarg
name|el_info_size
argument_list|,
comment|// maxsize
literal|1
argument_list|,
comment|// msegments
name|el_info_size
argument_list|,
comment|// maxsegsize
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|// flags
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// lockfunc, lockarg
operator|&
name|sc
operator|->
name|el_info_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate event log info tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|el_info_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|el_info_mem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|el_info_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate event log info cmd mem\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|el_info_tag
argument_list|,
name|sc
operator|->
name|el_info_dmamap
argument_list|,
name|sc
operator|->
name|el_info_mem
argument_list|,
name|el_info_size
argument_list|,
name|mrsas_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|el_info_phys_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot load event log info cmd mem\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|sc
operator|->
name|el_info_mem
argument_list|,
literal|0
argument_list|,
name|el_info_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_free_evt_info_cmd: 	Free memory for Event log info command   * input:                    	Adapter soft state  *  * Deallocates memory for the event log info internal command.  */
end_comment

begin_function
name|void
name|mrsas_free_evt_log_info_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|el_info_phys_addr
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|el_info_tag
argument_list|,
name|sc
operator|->
name|el_info_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|el_info_mem
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|el_info_tag
argument_list|,
name|sc
operator|->
name|el_info_mem
argument_list|,
name|sc
operator|->
name|el_info_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|el_info_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|el_info_tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  mrsas_get_seq_num:	Get latest event sequence number  *  @sc:				Adapter soft state  *  @eli:				Firmware event log sequence number information.  *						Firmware maintains a log of all events in a non-volatile area.  *						Driver get the sequence number using DCMD  *						"MR_DCMD_CTRL_EVENT_GET_INFO" at driver load time.  */
end_comment

begin_function
specifier|static
name|int
name|mrsas_get_seq_num
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_evt_log_info
modifier|*
name|eli
parameter_list|)
block|{
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mrsas_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|cmd
operator|=
name|mrsas_get_mfi_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Failed to get a free cmd\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dcmd
operator|=
operator|&
name|cmd
operator|->
name|frame
operator|->
name|dcmd
expr_stmt|;
if|if
condition|(
name|mrsas_alloc_evt_log_info_cmd
argument_list|(
name|sc
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate evt log info cmd\n"
argument_list|)
expr_stmt|;
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|memset
argument_list|(
name|dcmd
operator|->
name|mbox
operator|.
name|b
argument_list|,
literal|0
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|cmd_status
operator|=
literal|0x0
expr_stmt|;
name|dcmd
operator|->
name|sge_count
operator|=
literal|1
expr_stmt|;
name|dcmd
operator|->
name|flags
operator|=
name|MFI_FRAME_DIR_READ
expr_stmt|;
name|dcmd
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|pad_0
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|data_xfer_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_evt_log_info
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MR_DCMD_CTRL_EVENT_GET_INFO
expr_stmt|;
name|dcmd
operator|->
name|sgl
operator|.
name|sge32
index|[
literal|0
index|]
operator|.
name|phys_addr
operator|=
name|sc
operator|->
name|el_info_phys_addr
expr_stmt|;
name|dcmd
operator|->
name|sgl
operator|.
name|sge32
index|[
literal|0
index|]
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_evt_log_info
argument_list|)
expr_stmt|;
name|mrsas_issue_blocked_cmd
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/*  	 * Copy the data back into callers buffer  	 */
name|memcpy
argument_list|(
name|eli
argument_list|,
name|sc
operator|->
name|el_info_mem
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_evt_log_info
argument_list|)
argument_list|)
expr_stmt|;
name|mrsas_free_evt_log_info_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *  mrsas_register_aen:		Register for asynchronous event notification  *  @sc:					Adapter soft state  *  @seq_num:				Starting sequence number  *  @class_locale:			Class of the event  *  						This function subscribes for events beyond the @seq_num   *  						and type @class_locale.  *   * */
end_comment

begin_function
specifier|static
name|int
name|mrsas_register_aen
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|seq_num
parameter_list|,
name|u_int32_t
name|class_locale_word
parameter_list|)
block|{
name|int
name|ret_val
decl_stmt|;
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mrsas_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|union
name|mrsas_evt_class_locale
name|curr_aen
decl_stmt|;
name|union
name|mrsas_evt_class_locale
name|prev_aen
decl_stmt|;
comment|/*  *  If there an AEN pending already (aen_cmd), check if the  *  class_locale of that pending AEN is inclusive of the new  *  AEN request we currently have. If it is, then we don't have  *  to do anything. In other words, whichever events the current  *  AEN request is subscribing to, have already been subscribed  *  to.  *  If the old_cmd is _not_ inclusive, then we have to abort  *  that command, form a class_locale that is superset of both  *  old and current and re-issue to the FW  * */
name|curr_aen
operator|.
name|word
operator|=
name|class_locale_word
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aen_cmd
condition|)
block|{
name|prev_aen
operator|.
name|word
operator|=
name|sc
operator|->
name|aen_cmd
operator|->
name|frame
operator|->
name|dcmd
operator|.
name|mbox
operator|.
name|w
index|[
literal|1
index|]
expr_stmt|;
comment|/*  * A class whose enum value is smaller is inclusive of all  * higher values. If a PROGRESS (= -1) was previously  * registered, then a new registration requests for higher  * classes need not be sent to FW. They are automatically  * included.  * Locale numbers don't have such hierarchy. They are bitmap values  */
if|if
condition|(
operator|(
name|prev_aen
operator|.
name|members
operator|.
name|class
operator|<=
name|curr_aen
operator|.
name|members
operator|.
name|class
operator|)
operator|&&
operator|!
operator|(
operator|(
name|prev_aen
operator|.
name|members
operator|.
name|locale
operator|&
name|curr_aen
operator|.
name|members
operator|.
name|locale
operator|)
operator|^
name|curr_aen
operator|.
name|members
operator|.
name|locale
operator|)
condition|)
block|{
comment|/*   			 * Previously issued event registration includes   			 * current request. Nothing to do.   			 */
return|return
literal|0
return|;
block|}
else|else
block|{
name|curr_aen
operator|.
name|members
operator|.
name|locale
operator||=
name|prev_aen
operator|.
name|members
operator|.
name|locale
expr_stmt|;
if|if
condition|(
name|prev_aen
operator|.
name|members
operator|.
name|class
operator|<
name|curr_aen
operator|.
name|members
operator|.
name|class
condition|)
name|curr_aen
operator|.
name|members
operator|.
name|class
operator|=
name|prev_aen
operator|.
name|members
operator|.
name|class
expr_stmt|;
name|sc
operator|->
name|aen_cmd
operator|->
name|abort_aen
operator|=
literal|1
expr_stmt|;
name|ret_val
operator|=
name|mrsas_issue_blocked_abort_cmd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|aen_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|printf
argument_list|(
literal|"mrsas: Failed to abort "
literal|"previous AEN command\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
block|}
name|cmd
operator|=
name|mrsas_get_mfi_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|dcmd
operator|=
operator|&
name|cmd
operator|->
name|frame
operator|->
name|dcmd
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|evt_detail_mem
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_evt_detail
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  * Prepare DCMD for aen registration  */
name|memset
argument_list|(
name|dcmd
operator|->
name|mbox
operator|.
name|b
argument_list|,
literal|0
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|cmd_status
operator|=
literal|0x0
expr_stmt|;
name|dcmd
operator|->
name|sge_count
operator|=
literal|1
expr_stmt|;
name|dcmd
operator|->
name|flags
operator|=
name|MFI_FRAME_DIR_READ
expr_stmt|;
name|dcmd
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|pad_0
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|data_xfer_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_evt_detail
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MR_DCMD_CTRL_EVENT_WAIT
expr_stmt|;
name|dcmd
operator|->
name|mbox
operator|.
name|w
index|[
literal|0
index|]
operator|=
name|seq_num
expr_stmt|;
name|sc
operator|->
name|last_seq_num
operator|=
name|seq_num
expr_stmt|;
name|dcmd
operator|->
name|mbox
operator|.
name|w
index|[
literal|1
index|]
operator|=
name|curr_aen
operator|.
name|word
expr_stmt|;
name|dcmd
operator|->
name|sgl
operator|.
name|sge32
index|[
literal|0
index|]
operator|.
name|phys_addr
operator|=
operator|(
name|u_int32_t
operator|)
name|sc
operator|->
name|evt_detail_phys_addr
expr_stmt|;
name|dcmd
operator|->
name|sgl
operator|.
name|sge32
index|[
literal|0
index|]
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_evt_detail
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aen_cmd
operator|!=
name|NULL
condition|)
block|{
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*   	 * Store reference to the cmd used to register for AEN. When an   	 * application wants us to register for AEN, we have to abort this    	 * cmd and re-register with a new EVENT LOCALE supplied by that app   	 */
name|sc
operator|->
name|aen_cmd
operator|=
name|cmd
expr_stmt|;
comment|/*   	  Issue the aen registration frame   	*/
if|if
condition|(
name|mrsas_issue_dcmd
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot issue AEN DCMD command.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_start_aen -  Subscribes to AEN during driver load time  * @instance:           Adapter soft state  */
end_comment

begin_function
specifier|static
name|int
name|mrsas_start_aen
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mrsas_evt_log_info
name|eli
decl_stmt|;
name|union
name|mrsas_evt_class_locale
name|class_locale
decl_stmt|;
comment|/* Get the latest sequence number from FW*/
name|memset
argument_list|(
operator|&
name|eli
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|eli
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrsas_get_seq_num
argument_list|(
name|sc
argument_list|,
operator|&
name|eli
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Register AEN with FW for latest sequence number plus 1*/
name|class_locale
operator|.
name|members
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|locale
operator|=
name|MR_EVT_LOCALE_ALL
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|class
operator|=
name|MR_EVT_CLASS_DEBUG
expr_stmt|;
return|return
name|mrsas_register_aen
argument_list|(
name|sc
argument_list|,
name|eli
operator|.
name|newest_seq_num
operator|+
literal|1
argument_list|,
name|class_locale
operator|.
name|word
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_attach:            PCI entry point  * input:                   device struct pointer   *   * Performs setup of PCI and registers, initializes mutexes and  * linked lists, registers interrupts and CAM, and initializes     * the adapter/controller to its proper state.  */
end_comment

begin_function
specifier|static
name|int
name|mrsas_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|cmd
decl_stmt|,
name|bar
decl_stmt|,
name|error
decl_stmt|;
comment|/* Look up our softc and initialize its fields. */
name|sc
operator|->
name|mrsas_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mrsas_get_tunables
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*       * Set up PCI and registers       */
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
name|PCIM_CMD_PORTEN
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Force the busmaster enable bit on. */
name|cmd
operator||=
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|//bar = pci_read_config(dev, MRSAS_PCI_BAR0, 4);
name|bar
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|MRSAS_PCI_BAR1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg_res_id
operator|=
name|MRSAS_PCI_BAR1
expr_stmt|;
comment|/* BAR1 offset */
if|if
condition|(
operator|(
name|sc
operator|->
name|reg_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|reg_res_id
operator|)
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate PCI registers\n"
argument_list|)
expr_stmt|;
goto|goto
name|attach_fail
goto|;
block|}
name|sc
operator|->
name|bus_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|reg_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bus_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|reg_res
argument_list|)
expr_stmt|;
comment|/* Intialize mutexes */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|,
literal|"mrsas_sim_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|pci_lock
argument_list|,
literal|"mrsas_pci_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|,
literal|"mrsas_io_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|aen_lock
argument_list|,
literal|"mrsas_aen_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|ioctl_lock
argument_list|,
literal|"mrsas_ioctl_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mpt_cmd_pool_lock
argument_list|,
literal|"mrsas_mpt_cmd_pool_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mfi_cmd_pool_lock
argument_list|,
literal|"mrsas_mfi_cmd_pool_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|,
literal|"mrsas_raidmap_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Intialize linked list */
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mrsas_mpt_cmd_list_head
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mrsas_mfi_cmd_list_head
argument_list|)
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|sc
operator|->
name|fw_outstanding
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|io_cmds_highwater
operator|=
literal|0
expr_stmt|;
comment|/* Create a /dev entry for this device. */
name|sc
operator|->
name|mrsas_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|mrsas_cdevsw
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
operator|(
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IWGRP
operator|)
argument_list|,
literal|"mrsas%u"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
condition|)
name|make_dev_alias
argument_list|(
name|sc
operator|->
name|mrsas_cdev
argument_list|,
literal|"megaraid_sas_ioctl_node"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mrsas_cdev
condition|)
name|sc
operator|->
name|mrsas_cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|adprecovery
operator|=
name|MRSAS_HBA_OPERATIONAL
expr_stmt|;
name|sc
operator|->
name|UnevenSpanSupport
operator|=
literal|0
expr_stmt|;
comment|/* Initialize Firmware */
if|if
condition|(
name|mrsas_init_fw
argument_list|(
name|sc
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
goto|goto
name|attach_fail_fw
goto|;
block|}
comment|/* Register SCSI mid-layer */
if|if
condition|(
operator|(
name|mrsas_cam_attach
argument_list|(
name|sc
argument_list|)
operator|!=
name|SUCCESS
operator|)
condition|)
block|{
goto|goto
name|attach_fail_cam
goto|;
block|}
comment|/* Register IRQs */
if|if
condition|(
name|mrsas_setup_irq
argument_list|(
name|sc
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
goto|goto
name|attach_fail_irq
goto|;
block|}
comment|/* Enable Interrupts */
name|mrsas_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mrsas_kproc_create
argument_list|(
name|mrsas_ocr_thread
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ocr_thread
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"mrsas_ocr%d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"Error %d starting rescan thread\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|attach_fail_irq
goto|;
block|}
name|mrsas_setup_sysctl
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initiate AEN (Asynchronous Event Notification)*/
if|if
condition|(
name|mrsas_start_aen
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Error: start aen failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_start_aen
goto|;
block|}
comment|/*      * Add this controller to mrsas_mgmt_info structure so that it      * can be exported to management applications      */
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
condition|)
name|memset
argument_list|(
operator|&
name|mrsas_mgmt_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mrsas_mgmt_info
argument_list|)
argument_list|)
expr_stmt|;
name|mrsas_mgmt_info
operator|.
name|count
operator|++
expr_stmt|;
name|mrsas_mgmt_info
operator|.
name|sc_ptr
index|[
name|mrsas_mgmt_info
operator|.
name|max_index
index|]
operator|=
name|sc
expr_stmt|;
name|mrsas_mgmt_info
operator|.
name|max_index
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail_start_aen
label|:
name|attach_fail_irq
label|:
name|mrsas_teardown_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|attach_fail_cam
label|:
name|mrsas_cam_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|attach_fail_fw
label|:
comment|//attach_fail_raidmap:
name|mrsas_free_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|aen_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|pci_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|ioctl_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mpt_cmd_pool_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mfi_cmd_pool_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
name|attach_fail
label|:
name|destroy_dev
argument_list|(
name|sc
operator|->
name|mrsas_cdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reg_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|reg_res_id
argument_list|,
name|sc
operator|->
name|reg_res
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_detach:            De-allocates and teardown resources  * input:                   device struct pointer   *   * This function is the entry point for device disconnect and detach.  It  * performs memory de-allocations, shutdown of the controller and various   * teardown and destroy resource functions.  */
end_comment

begin_function
specifier|static
name|int
name|mrsas_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|remove_in_progress
operator|=
literal|1
expr_stmt|;
comment|/*      * Take the instance off the instance array. Note that we will not      * decrement the max_index. We let this array be sparse array     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mrsas_mgmt_info
operator|.
name|max_index
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mrsas_mgmt_info
operator|.
name|sc_ptr
index|[
name|i
index|]
operator|==
name|sc
condition|)
block|{
name|mrsas_mgmt_info
operator|.
name|count
operator|--
expr_stmt|;
name|mrsas_mgmt_info
operator|.
name|sc_ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|ocr_thread_active
condition|)
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|ocr_chan
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|reset_in_progress
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
name|MRSAS_RESET_NOTICE_INTERVAL
operator|)
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_INFO
argument_list|,
literal|"[%2d]waiting for ocr to be finished\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|pause
argument_list|(
literal|"mr_shutdown"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|ocr_thread_active
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
name|MRSAS_RESET_NOTICE_INTERVAL
operator|)
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_INFO
argument_list|,
literal|"[%2d]waiting for "
literal|"mrsas_ocr thread to quit ocr %d\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|ocr_thread_active
argument_list|)
expr_stmt|;
block|}
name|pause
argument_list|(
literal|"mr_shutdown"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|mrsas_flush_cache
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_shutdown_ctlr
argument_list|(
name|sc
argument_list|,
name|MR_DCMD_CTRL_SHUTDOWN
argument_list|)
expr_stmt|;
name|mrsas_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_cam_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_teardown_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_free_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|aen_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|pci_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|ioctl_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mpt_cmd_pool_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mfi_cmd_pool_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reg_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|reg_res_id
argument_list|,
name|sc
operator|->
name|reg_res
argument_list|)
expr_stmt|;
block|}
name|destroy_dev
argument_list|(
name|sc
operator|->
name|mrsas_cdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sysctl_tree
operator|!=
name|NULL
condition|)
name|sysctl_ctx_free
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_free_mem:          Frees allocated memory   * input:                   Adapter instance soft state  *   * This function is called from mrsas_detach() to free previously allocated  * memory.    */
end_comment

begin_function
name|void
name|mrsas_free_mem
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|max_cmd
decl_stmt|;
name|struct
name|mrsas_mfi_cmd
modifier|*
name|mfi_cmd
decl_stmt|;
name|struct
name|mrsas_mpt_cmd
modifier|*
name|mpt_cmd
decl_stmt|;
comment|/*      * Free RAID map memory      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|raidmap_phys_addr
index|[
name|i
index|]
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|raidmap_tag
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|raidmap_dmamap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|raidmap_mem
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|raidmap_tag
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|raidmap_mem
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|raidmap_dmamap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|raidmap_tag
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|raidmap_tag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ld_drv_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|ld_drv_map
index|[
name|i
index|]
argument_list|,
name|M_MRSAS
argument_list|)
expr_stmt|;
block|}
comment|/*       * Free version buffer memroy       */
if|if
condition|(
name|sc
operator|->
name|verbuf_phys_addr
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|verbuf_tag
argument_list|,
name|sc
operator|->
name|verbuf_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|verbuf_mem
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|verbuf_tag
argument_list|,
name|sc
operator|->
name|verbuf_mem
argument_list|,
name|sc
operator|->
name|verbuf_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|verbuf_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|verbuf_tag
argument_list|)
expr_stmt|;
comment|/*       * Free sense buffer memory       */
if|if
condition|(
name|sc
operator|->
name|sense_phys_addr
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sense_tag
argument_list|,
name|sc
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sense_mem
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sense_tag
argument_list|,
name|sc
operator|->
name|sense_mem
argument_list|,
name|sc
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sense_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sense_tag
argument_list|)
expr_stmt|;
comment|/*       * Free chain frame memory       */
if|if
condition|(
name|sc
operator|->
name|chain_frame_phys_addr
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|chain_frame_tag
argument_list|,
name|sc
operator|->
name|chain_frame_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chain_frame_mem
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|chain_frame_tag
argument_list|,
name|sc
operator|->
name|chain_frame_mem
argument_list|,
name|sc
operator|->
name|chain_frame_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chain_frame_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|chain_frame_tag
argument_list|)
expr_stmt|;
comment|/*       * Free IO Request memory       */
if|if
condition|(
name|sc
operator|->
name|io_request_phys_addr
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|io_request_tag
argument_list|,
name|sc
operator|->
name|io_request_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|io_request_mem
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|io_request_tag
argument_list|,
name|sc
operator|->
name|io_request_mem
argument_list|,
name|sc
operator|->
name|io_request_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|io_request_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|io_request_tag
argument_list|)
expr_stmt|;
comment|/*       * Free Reply Descriptor memory       */
if|if
condition|(
name|sc
operator|->
name|reply_desc_phys_addr
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|reply_desc_tag
argument_list|,
name|sc
operator|->
name|reply_desc_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reply_desc_mem
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|reply_desc_tag
argument_list|,
name|sc
operator|->
name|reply_desc_mem
argument_list|,
name|sc
operator|->
name|reply_desc_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reply_desc_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|reply_desc_tag
argument_list|)
expr_stmt|;
comment|/*       * Free event detail memory       */
if|if
condition|(
name|sc
operator|->
name|evt_detail_phys_addr
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|evt_detail_tag
argument_list|,
name|sc
operator|->
name|evt_detail_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|evt_detail_mem
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|evt_detail_tag
argument_list|,
name|sc
operator|->
name|evt_detail_mem
argument_list|,
name|sc
operator|->
name|evt_detail_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|evt_detail_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|evt_detail_tag
argument_list|)
expr_stmt|;
comment|/*       * Free MFI frames       */
if|if
condition|(
name|sc
operator|->
name|mfi_cmd_list
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MRSAS_MAX_MFI_CMDS
condition|;
name|i
operator|++
control|)
block|{
name|mfi_cmd
operator|=
name|sc
operator|->
name|mfi_cmd_list
index|[
name|i
index|]
expr_stmt|;
name|mrsas_free_frame
argument_list|(
name|sc
argument_list|,
name|mfi_cmd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|mficmd_frame_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mficmd_frame_tag
argument_list|)
expr_stmt|;
comment|/*       * Free MPT internal command list       */
name|max_cmd
operator|=
name|sc
operator|->
name|max_fw_cmds
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mpt_cmd_list
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_cmd
condition|;
name|i
operator|++
control|)
block|{
name|mpt_cmd
operator|=
name|sc
operator|->
name|mpt_cmd_list
index|[
name|i
index|]
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|data_tag
argument_list|,
name|mpt_cmd
operator|->
name|data_dmamap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|mpt_cmd_list
index|[
name|i
index|]
argument_list|,
name|M_MRSAS
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|mpt_cmd_list
argument_list|,
name|M_MRSAS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mpt_cmd_list
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * Free MFI internal command list       */
if|if
condition|(
name|sc
operator|->
name|mfi_cmd_list
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MRSAS_MAX_MFI_CMDS
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|mfi_cmd_list
index|[
name|i
index|]
argument_list|,
name|M_MRSAS
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|mfi_cmd_list
argument_list|,
name|M_MRSAS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_cmd_list
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*       * Free request descriptor memory       */
name|free
argument_list|(
name|sc
operator|->
name|req_desc
argument_list|,
name|M_MRSAS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|req_desc
operator|=
name|NULL
expr_stmt|;
comment|/*       * Destroy parent tag       */
if|if
condition|(
name|sc
operator|->
name|mrsas_parent_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_teardown_intr:        Teardown interrupt   * input:                      Adapter instance soft state  *  * This function is called from mrsas_detach() to teardown and release  * bus interrupt resourse.  */
end_comment

begin_function
name|void
name|mrsas_teardown_intr
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|intr_handle
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
name|sc
operator|->
name|mrsas_irq
argument_list|,
name|sc
operator|->
name|intr_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mrsas_irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_id
argument_list|,
name|sc
operator|->
name|mrsas_irq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr_handle
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_suspend:          Suspend entry point  * input:                  Device struct pointer   *   * This function is the entry point for system suspend from the OS.     */
end_comment

begin_function
specifier|static
name|int
name|mrsas_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_resume:           Resume entry point   * input:                  Device struct pointer   *   * This function is the entry point for system resume from the OS.     */
end_comment

begin_function
specifier|static
name|int
name|mrsas_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_ioctl:       IOCtl commands entry point.   *   * This function is the entry point for IOCtls from the OS.  It calls the   * appropriate function for processing depending on the command received.  */
end_comment

begin_function
specifier|static
name|int
name|mrsas_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|mrsas_iocpacket
modifier|*
name|user_ioc
init|=
operator|(
expr|struct
name|mrsas_iocpacket
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* get the Host number& the softc from data sent by the Application */
name|sc
operator|=
name|mrsas_mgmt_info
operator|.
name|sc_ptr
index|[
name|user_ioc
operator|->
name|host_no
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|mrsas_mgmt_info
operator|.
name|max_index
operator|==
name|user_ioc
operator|->
name|host_no
operator|)
operator|||
operator|(
name|sc
operator|==
name|NULL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Please check the controller number\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"There is NO such Host no. %d\n"
argument_list|,
name|user_ioc
operator|->
name|host_no
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|remove_in_progress
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_INFO
argument_list|,
literal|"Driver remove or shutdown called.\n"
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|ioctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|reset_in_progress
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|ioctl_lock
argument_list|)
expr_stmt|;
goto|goto
name|do_ioctl
goto|;
block|}
comment|/* Release ioclt_lock, and wait for OCR      * to be finished */
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|ioctl_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|reset_in_progress
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
name|MRSAS_RESET_NOTICE_INTERVAL
operator|)
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_INFO
argument_list|,
literal|"[%2d]waiting for "
literal|"OCR to be finished %d\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|ocr_thread_active
argument_list|)
expr_stmt|;
block|}
name|pause
argument_list|(
literal|"mr_ioctl"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|do_ioctl
label|:
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MRSAS_IOC_FIRMWARE_PASS_THROUGH64
case|:
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
case|case
name|MRSAS_IOC_FIRMWARE_PASS_THROUGH32
case|:
endif|#
directive|endif
name|ret
operator|=
name|mrsas_passthru
argument_list|(
name|sc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRSAS_IOC_SCAN_BUS
case|:
name|ret
operator|=
name|mrsas_bus_scan
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_TRACE
argument_list|,
literal|"IOCTL command 0x%lx is not handled\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_setup_irq:   Set up interrupt.   * input:             Adapter instance soft state  *   * This function sets up interrupts as a bus resource, with flags indicating  * resource permitting contemporaneous sharing and for resource to activate   * atomically.  */
end_comment

begin_function
specifier|static
name|int
name|mrsas_setup_irq
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|irq_id
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mrsas_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_id
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mrsas_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
name|sc
operator|->
name|mrsas_irq
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_CAM
argument_list|,
name|NULL
argument_list|,
name|mrsas_isr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_handle
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot set up interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_isr:        ISR entry point   * input:            argument pointer   *  * This function is the interrupt service routine entry point.  There  * are two types of interrupts, state change interrupt and response  * interrupt.  If an interrupt is not ours, we just return.  */
end_comment

begin_function
name|void
name|mrsas_isr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|mrsas_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* Clear FW state change interrupt */
name|status
operator|=
name|mrsas_clear_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Not our interrupt */
if|if
condition|(
operator|!
name|status
condition|)
return|return;
comment|/* If we are resetting, bail */
if|if
condition|(
name|test_bit
argument_list|(
name|MRSAS_FUSION_IN_RESET
argument_list|,
operator|&
name|sc
operator|->
name|reset_flags
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" Entered into ISR when OCR is going active. \n"
argument_list|)
expr_stmt|;
name|mrsas_clear_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Process for reply request and clear response interrupt */
if|if
condition|(
name|mrsas_complete_cmd
argument_list|(
name|sc
argument_list|)
operator|!=
name|SUCCESS
condition|)
name|mrsas_clear_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * mrsas_complete_cmd:        Process reply request    * input:                     Adapter instance soft state  *  * This function is called from mrsas_isr() to process reply request and   * clear response interrupt. Processing of the reply request entails  * walking through the reply descriptor array for the command request    * pended from Firmware.  We look at the Function field to determine  * the command type and perform the appropriate action.  Before we  * return, we clear the response interrupt.  */
end_comment

begin_function
specifier|static
name|int
name|mrsas_complete_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|Mpi2ReplyDescriptorsUnion_t
modifier|*
name|desc
decl_stmt|;
name|MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR
modifier|*
name|reply_desc
decl_stmt|;
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|scsi_io_req
decl_stmt|;
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd_mpt
decl_stmt|;
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd_mfi
decl_stmt|;
name|u_int8_t
name|arm
decl_stmt|,
name|reply_descript_type
decl_stmt|;
name|u_int16_t
name|smid
decl_stmt|,
name|num_completed
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|,
name|extStatus
decl_stmt|;
name|union
name|desc_value
name|desc_val
decl_stmt|;
name|PLD_LOAD_BALANCE_INFO
name|lbinfo
decl_stmt|;
name|u_int32_t
name|device_id
decl_stmt|;
name|int
name|threshold_reply_count
init|=
literal|0
decl_stmt|;
comment|/* If we have a hardware error, not need to continue */
if|if
condition|(
name|sc
operator|->
name|adprecovery
operator|==
name|MRSAS_HW_CRITICAL_ERROR
condition|)
return|return
operator|(
name|DONE
operator|)
return|;
name|desc
operator|=
name|sc
operator|->
name|reply_desc_mem
expr_stmt|;
name|desc
operator|+=
name|sc
operator|->
name|last_reply_idx
expr_stmt|;
name|reply_desc
operator|=
operator|(
name|MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR
operator|*
operator|)
name|desc
expr_stmt|;
name|desc_val
operator|.
name|word
operator|=
name|desc
operator|->
name|Words
expr_stmt|;
name|num_completed
operator|=
literal|0
expr_stmt|;
name|reply_descript_type
operator|=
name|reply_desc
operator|->
name|ReplyFlags
operator|&
name|MPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK
expr_stmt|;
comment|/* Find our reply descriptor for the command and process */
while|while
condition|(
operator|(
name|desc_val
operator|.
name|u
operator|.
name|low
operator|!=
literal|0xFFFFFFFF
operator|)
operator|&&
operator|(
name|desc_val
operator|.
name|u
operator|.
name|high
operator|!=
literal|0xFFFFFFFF
operator|)
condition|)
block|{
name|smid
operator|=
name|reply_desc
operator|->
name|SMID
expr_stmt|;
name|cmd_mpt
operator|=
name|sc
operator|->
name|mpt_cmd_list
index|[
name|smid
operator|-
literal|1
index|]
expr_stmt|;
name|scsi_io_req
operator|=
operator|(
name|MRSAS_RAID_SCSI_IO_REQUEST
operator|*
operator|)
name|cmd_mpt
operator|->
name|io_request
expr_stmt|;
name|status
operator|=
name|scsi_io_req
operator|->
name|RaidContext
operator|.
name|status
expr_stmt|;
name|extStatus
operator|=
name|scsi_io_req
operator|->
name|RaidContext
operator|.
name|exStatus
expr_stmt|;
switch|switch
condition|(
name|scsi_io_req
operator|->
name|Function
condition|)
block|{
case|case
name|MPI2_FUNCTION_SCSI_IO_REQUEST
case|:
comment|/*Fast Path IO.*/
name|device_id
operator|=
name|cmd_mpt
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lbinfo
operator|=
operator|&
name|sc
operator|->
name|load_balance_info
index|[
name|device_id
index|]
expr_stmt|;
if|if
condition|(
name|cmd_mpt
operator|->
name|load_balance
operator|==
name|MRSAS_LOAD_BALANCE_FLAG
condition|)
block|{
name|arm
operator|=
name|lbinfo
operator|->
name|raid1DevHandle
index|[
literal|0
index|]
operator|==
name|scsi_io_req
operator|->
name|DevHandle
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|lbinfo
operator|->
name|scsi_pending_cmds
index|[
name|arm
index|]
argument_list|)
expr_stmt|;
name|cmd_mpt
operator|->
name|load_balance
operator|&=
operator|~
name|MRSAS_LOAD_BALANCE_FLAG
expr_stmt|;
block|}
comment|//Fall thru and complete IO
case|case
name|MRSAS_MPI2_FUNCTION_LD_IO_REQUEST
case|:
name|mrsas_map_mpt_cmd_status
argument_list|(
name|cmd_mpt
argument_list|,
name|status
argument_list|,
name|extStatus
argument_list|)
expr_stmt|;
name|mrsas_cmd_done
argument_list|(
name|sc
argument_list|,
name|cmd_mpt
argument_list|)
expr_stmt|;
name|scsi_io_req
operator|->
name|RaidContext
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|scsi_io_req
operator|->
name|RaidContext
operator|.
name|exStatus
operator|=
literal|0
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|sc
operator|->
name|fw_outstanding
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRSAS_MPI2_FUNCTION_PASSTHRU_IO_REQUEST
case|:
comment|/*MFI command */
name|cmd_mfi
operator|=
name|sc
operator|->
name|mfi_cmd_list
index|[
name|cmd_mpt
operator|->
name|sync_cmd_idx
index|]
expr_stmt|;
name|mrsas_complete_mptmfi_passthru
argument_list|(
name|sc
argument_list|,
name|cmd_mfi
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|cmd_mpt
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|mrsas_release_mpt_cmd
argument_list|(
name|cmd_mpt
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|last_reply_idx
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|last_reply_idx
operator|>=
name|sc
operator|->
name|reply_q_depth
condition|)
name|sc
operator|->
name|last_reply_idx
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|Words
operator|=
operator|~
operator|(
operator|(
name|uint64_t
operator|)
literal|0x00
operator|)
expr_stmt|;
comment|/* set it back to all 0xFFFFFFFFs */
name|num_completed
operator|++
expr_stmt|;
name|threshold_reply_count
operator|++
expr_stmt|;
comment|/* Get the next reply descriptor */
if|if
condition|(
operator|!
name|sc
operator|->
name|last_reply_idx
condition|)
name|desc
operator|=
name|sc
operator|->
name|reply_desc_mem
expr_stmt|;
else|else
name|desc
operator|++
expr_stmt|;
name|reply_desc
operator|=
operator|(
name|MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR
operator|*
operator|)
name|desc
expr_stmt|;
name|desc_val
operator|.
name|word
operator|=
name|desc
operator|->
name|Words
expr_stmt|;
name|reply_descript_type
operator|=
name|reply_desc
operator|->
name|ReplyFlags
operator|&
name|MPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK
expr_stmt|;
if|if
condition|(
name|reply_descript_type
operator|==
name|MPI2_RPY_DESCRIPT_FLAGS_UNUSED
condition|)
break|break;
comment|/*           * Write to reply post index after completing threshold reply count           * and still there are more replies in reply queue pending to be           * completed.          */
if|if
condition|(
name|threshold_reply_count
operator|>=
name|THRESHOLD_REPLY_COUNT
condition|)
block|{
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|reply_post_host_index
argument_list|)
argument_list|,
name|sc
operator|->
name|last_reply_idx
argument_list|)
expr_stmt|;
name|threshold_reply_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* No match, just return */
if|if
condition|(
name|num_completed
operator|==
literal|0
condition|)
return|return
operator|(
name|DONE
operator|)
return|;
comment|/* Clear response interrupt */
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|reply_post_host_index
argument_list|)
argument_list|,
name|sc
operator|->
name|last_reply_idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_map_mpt_cmd_status:  Allocate DMAable memory.  * input:                     Adapter instance soft state  *  * This function is called from mrsas_complete_cmd(), for LD IO and FastPath IO.  * It checks the command status and maps the appropriate CAM status for the CCB.     */
end_comment

begin_function
name|void
name|mrsas_map_mpt_cmd_status
parameter_list|(
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|u_int8_t
name|extStatus
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
init|=
name|cmd
operator|->
name|sc
decl_stmt|;
name|u_int8_t
modifier|*
name|sense_data
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|MFI_STAT_OK
case|:
name|cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|MFI_STAT_SCSI_IO_FAILED
case|:
case|case
name|MFI_STAT_SCSI_DONE_WITH_ERROR
case|:
name|cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|sense_data
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|cmd
operator|->
name|ccb_ptr
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
if|if
condition|(
name|sense_data
condition|)
block|{
comment|/* For now just copy 18 bytes back */
name|memcpy
argument_list|(
name|sense_data
argument_list|,
name|cmd
operator|->
name|sense
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ccb_ptr
operator|->
name|csio
operator|.
name|sense_len
operator|=
literal|18
expr_stmt|;
name|cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
break|break;
case|case
name|MFI_STAT_LD_OFFLINE
case|:
case|case
name|MFI_STAT_DEVICE_NOT_FOUND
case|:
if|if
condition|(
name|cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|target_lun
condition|)
name|cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_LUN_INVALID
expr_stmt|;
else|else
name|cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
break|break;
case|case
name|MFI_STAT_CONFIG_SEQ_MISMATCH
case|:
comment|/*send status to CAM layer to retry sending  command without               * decrementing retry counter*/
name|cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"FW cmd complete status %x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ccb_ptr
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
name|cmd
operator|->
name|ccb_ptr
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|status
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * mrsas_alloc_mem:  Allocate DMAable memory.  * input:            Adapter instance soft state  *  * This function creates the parent DMA tag and allocates DMAable memory.  * DMA tag describes constraints of DMA mapping. Memory allocated is mapped  * into Kernel virtual address. Callback argument is physical memory address.   */
end_comment

begin_function
specifier|static
name|int
name|mrsas_alloc_mem
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|verbuf_size
decl_stmt|,
name|io_req_size
decl_stmt|,
name|reply_desc_size
decl_stmt|,
name|sense_size
decl_stmt|,
name|chain_frame_size
decl_stmt|,
name|evt_detail_size
decl_stmt|;
comment|/*      * Allocate parent DMA tag      */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MRSAS_MAX_IO_SIZE
argument_list|,
comment|/* maxsize */
name|MRSAS_MAX_SGL
argument_list|,
comment|/* nsegments */
name|MRSAS_MAX_IO_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|mrsas_parent_tag
comment|/* tag */
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate parent DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*      * Allocate for version buffer      */
name|verbuf_size
operator|=
name|MRSAS_MAX_NAME_LENGTH
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
comment|// parent
literal|1
argument_list|,
literal|0
argument_list|,
comment|// algnmnt, boundary
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// filter, filterarg
name|verbuf_size
argument_list|,
comment|// maxsize
literal|1
argument_list|,
comment|// msegments
name|verbuf_size
argument_list|,
comment|// maxsegsize
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|// flags
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// lockfunc, lockarg
operator|&
name|sc
operator|->
name|verbuf_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate verbuf DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|verbuf_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|verbuf_mem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|verbuf_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate verbuf memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|verbuf_mem
argument_list|,
name|verbuf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|verbuf_tag
argument_list|,
name|sc
operator|->
name|verbuf_dmamap
argument_list|,
name|sc
operator|->
name|verbuf_mem
argument_list|,
name|verbuf_size
argument_list|,
name|mrsas_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|verbuf_phys_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot load verbuf DMA map\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*      * Allocate IO Request Frames      */
name|io_req_size
operator|=
name|sc
operator|->
name|io_frames_alloc_sz
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
comment|// parent
literal|16
argument_list|,
literal|0
argument_list|,
comment|// algnmnt, boundary
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// filter, filterarg
name|io_req_size
argument_list|,
comment|// maxsize
literal|1
argument_list|,
comment|// msegments
name|io_req_size
argument_list|,
comment|// maxsegsize
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|// flags
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// lockfunc, lockarg
operator|&
name|sc
operator|->
name|io_request_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot create IO request tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|io_request_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|io_request_mem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|io_request_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc IO request memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|io_request_mem
argument_list|,
name|io_req_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|io_request_tag
argument_list|,
name|sc
operator|->
name|io_request_dmamap
argument_list|,
name|sc
operator|->
name|io_request_mem
argument_list|,
name|io_req_size
argument_list|,
name|mrsas_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|io_request_phys_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot load IO request memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*      * Allocate Chain Frames      */
name|chain_frame_size
operator|=
name|sc
operator|->
name|chain_frames_alloc_sz
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
comment|// parent
literal|4
argument_list|,
literal|0
argument_list|,
comment|// algnmnt, boundary
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// filter, filterarg
name|chain_frame_size
argument_list|,
comment|// maxsize
literal|1
argument_list|,
comment|// msegments
name|chain_frame_size
argument_list|,
comment|// maxsegsize
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|// flags
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// lockfunc, lockarg
operator|&
name|sc
operator|->
name|chain_frame_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot create chain frame tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|chain_frame_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|chain_frame_mem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|chain_frame_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc chain frame memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|chain_frame_mem
argument_list|,
name|chain_frame_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|chain_frame_tag
argument_list|,
name|sc
operator|->
name|chain_frame_dmamap
argument_list|,
name|sc
operator|->
name|chain_frame_mem
argument_list|,
name|chain_frame_size
argument_list|,
name|mrsas_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|chain_frame_phys_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot load chain frame memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*      * Allocate Reply Descriptor Array      */
name|reply_desc_size
operator|=
name|sc
operator|->
name|reply_alloc_sz
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
comment|// parent
literal|16
argument_list|,
literal|0
argument_list|,
comment|// algnmnt, boundary
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// filter, filterarg
name|reply_desc_size
argument_list|,
comment|// maxsize
literal|1
argument_list|,
comment|// msegments
name|reply_desc_size
argument_list|,
comment|// maxsegsize
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|// flags
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// lockfunc, lockarg
operator|&
name|sc
operator|->
name|reply_desc_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot create reply descriptor tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|reply_desc_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|reply_desc_mem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|reply_desc_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc reply descriptor memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|reply_desc_tag
argument_list|,
name|sc
operator|->
name|reply_desc_dmamap
argument_list|,
name|sc
operator|->
name|reply_desc_mem
argument_list|,
name|reply_desc_size
argument_list|,
name|mrsas_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|reply_desc_phys_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot load reply descriptor memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*      * Allocate Sense Buffer Array.  Keep in lower 4GB       */
name|sense_size
operator|=
name|sc
operator|->
name|max_fw_cmds
operator|*
name|MRSAS_SENSE_LEN
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
comment|// parent
literal|64
argument_list|,
literal|0
argument_list|,
comment|// algnmnt, boundary
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// filter, filterarg
name|sense_size
argument_list|,
comment|// maxsize
literal|1
argument_list|,
comment|// nsegments
name|sense_size
argument_list|,
comment|// maxsegsize
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|// flags
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// lockfunc, lockarg
operator|&
name|sc
operator|->
name|sense_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate sense buf tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sense_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sense_mem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|sense_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate sense buf memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sense_tag
argument_list|,
name|sc
operator|->
name|sense_dmamap
argument_list|,
name|sc
operator|->
name|sense_mem
argument_list|,
name|sense_size
argument_list|,
name|mrsas_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|sense_phys_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot load sense buf memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*      * Allocate for Event detail structure      */
name|evt_detail_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_evt_detail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
comment|// parent
literal|1
argument_list|,
literal|0
argument_list|,
comment|// algnmnt, boundary
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// filter, filterarg
name|evt_detail_size
argument_list|,
comment|// maxsize
literal|1
argument_list|,
comment|// msegments
name|evt_detail_size
argument_list|,
comment|// maxsegsize
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|// flags
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// lockfunc, lockarg
operator|&
name|sc
operator|->
name|evt_detail_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot create Event detail tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|evt_detail_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|evt_detail_mem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|evt_detail_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc Event detail buffer memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|evt_detail_mem
argument_list|,
name|evt_detail_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|evt_detail_tag
argument_list|,
name|sc
operator|->
name|evt_detail_dmamap
argument_list|,
name|sc
operator|->
name|evt_detail_mem
argument_list|,
name|evt_detail_size
argument_list|,
name|mrsas_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|evt_detail_phys_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot load Event detail buffer memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*     * Create a dma tag for data buffers; size will be the maximum     * possible I/O size (280kB).     */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
comment|// parent
literal|1
argument_list|,
comment|// alignment
literal|0
argument_list|,
comment|// boundary
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// filter, filterarg
name|MRSAS_MAX_IO_SIZE
argument_list|,
comment|// maxsize
name|MRSAS_MAX_SGL
argument_list|,
comment|// nsegments
name|MRSAS_MAX_IO_SIZE
argument_list|,
comment|// maxsegsize
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|// flags
name|busdma_lock_mutex
argument_list|,
comment|// lockfunc
operator|&
name|sc
operator|->
name|io_lock
argument_list|,
comment|// lockfuncarg
operator|&
name|sc
operator|->
name|data_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot create data dma tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_addr_cb:   Callback function of bus_dmamap_load()  * input:           callback argument,   *                  machine dependent type that describes DMA segments,  *                  number of segments,  *                  error code.    *  * This function is for the driver to receive mapping information resultant  * of the bus_dmamap_load(). The information is actually not being used,  * but the address is saved anyway.  */
end_comment

begin_function
name|void
name|mrsas_addr_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mrsas_setup_raidmap:  Set up RAID map.  * input:                Adapter instance soft state  *  * Allocate DMA memory for the RAID maps and perform setup.  */
end_comment

begin_function
specifier|static
name|int
name|mrsas_setup_raidmap
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|drv_supported_vd_count
operator|=
name|MRSAS_MAX_LD_CHANNELS
operator|*
name|MRSAS_MAX_DEV_PER_CHANNEL
expr_stmt|;
name|sc
operator|->
name|drv_supported_pd_count
operator|=
name|MRSAS_MAX_PD_CHANNELS
operator|*
name|MRSAS_MAX_DEV_PER_CHANNEL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|max256vdSupport
condition|)
block|{
name|sc
operator|->
name|fw_supported_vd_count
operator|=
name|MAX_LOGICAL_DRIVES_EXT
expr_stmt|;
name|sc
operator|->
name|fw_supported_pd_count
operator|=
name|MAX_PHYSICAL_DEVICES
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|fw_supported_vd_count
operator|=
name|MAX_LOGICAL_DRIVES
expr_stmt|;
name|sc
operator|->
name|fw_supported_pd_count
operator|=
name|MAX_PHYSICAL_DEVICES
expr_stmt|;
block|}
if|#
directive|if
name|VD_EXT_DEBUG
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"FW supports: max256vdSupport = %s\n"
argument_list|,
name|sc
operator|->
name|max256vdSupport
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"FW supports %dVDs %dPDs\n"
literal|"DRIVER supports %dVDs  %dPDs \n"
argument_list|,
name|sc
operator|->
name|fw_supported_vd_count
argument_list|,
name|sc
operator|->
name|fw_supported_pd_count
argument_list|,
name|sc
operator|->
name|drv_supported_vd_count
argument_list|,
name|sc
operator|->
name|drv_supported_pd_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|old_map_sz
operator|=
sizeof|sizeof
argument_list|(
name|MR_FW_RAID_MAP
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|MR_LD_SPAN_MAP
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|fw_supported_vd_count
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|sc
operator|->
name|new_map_sz
operator|=
sizeof|sizeof
argument_list|(
name|MR_FW_RAID_MAP_EXT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|drv_map_sz
operator|=
sizeof|sizeof
argument_list|(
name|MR_DRV_RAID_MAP
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|MR_LD_SPAN_MAP
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|drv_supported_vd_count
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ld_drv_map
index|[
name|i
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|sc
operator|->
name|drv_map_sz
argument_list|,
name|M_MRSAS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
comment|/* Do Error handling */
if|if
condition|(
operator|!
name|sc
operator|->
name|ld_drv_map
index|[
name|i
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Could not allocate memory for local map"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|free
argument_list|(
name|sc
operator|->
name|ld_drv_map
index|[
literal|0
index|]
argument_list|,
name|M_MRSAS
argument_list|)
expr_stmt|;
comment|//ABORT driver initialization
goto|goto
name|ABORT
goto|;
block|}
block|}
name|sc
operator|->
name|max_map_sz
operator|=
name|max
argument_list|(
name|sc
operator|->
name|old_map_sz
argument_list|,
name|sc
operator|->
name|new_map_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|max256vdSupport
condition|)
name|sc
operator|->
name|current_map_sz
operator|=
name|sc
operator|->
name|new_map_sz
expr_stmt|;
else|else
name|sc
operator|->
name|current_map_sz
operator|=
name|sc
operator|->
name|old_map_sz
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
comment|// parent
literal|4
argument_list|,
literal|0
argument_list|,
comment|// algnmnt, boundary
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// filter, filterarg
name|sc
operator|->
name|max_map_sz
argument_list|,
comment|// maxsize
literal|1
argument_list|,
comment|// nsegments
name|sc
operator|->
name|max_map_sz
argument_list|,
comment|// maxsegsize
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|// flags
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// lockfunc, lockarg
operator|&
name|sc
operator|->
name|raidmap_tag
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate raid map tag.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|raidmap_tag
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|raidmap_mem
index|[
name|i
index|]
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|raidmap_dmamap
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate raidmap memory.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|raidmap_mem
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|max_map_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|raidmap_tag
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|raidmap_dmamap
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|raidmap_mem
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|max_map_sz
argument_list|,
name|mrsas_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|raidmap_phys_addr
index|[
name|i
index|]
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot load raidmap memory.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|raidmap_mem
index|[
name|i
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate memory for raid map.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|mrsas_get_map_info
argument_list|(
name|sc
argument_list|)
condition|)
name|mrsas_sync_map_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|ABORT
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_init_fw:      Initialize Firmware     * input:              Adapter soft state  *  * Calls transition_to_ready() to make sure Firmware is in operational   * state and calls mrsas_init_adapter() to send IOC_INIT command to  * Firmware.  It issues internal commands to get the controller info  * after the IOC_INIT command response is received by Firmware.    * Note:  code relating to get_pdlist, get_ld_list and max_sectors   * are currently not being used, it is left here as placeholder.   */
end_comment

begin_function
specifier|static
name|int
name|mrsas_init_fw
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|max_sectors_1
decl_stmt|;
name|u_int32_t
name|max_sectors_2
decl_stmt|;
name|u_int32_t
name|tmp_sectors
decl_stmt|;
name|struct
name|mrsas_ctrl_info
modifier|*
name|ctrl_info
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|ocr
init|=
literal|0
decl_stmt|;
comment|/* Make sure Firmware is ready */
name|ret
operator|=
name|mrsas_transition_to_ready
argument_list|(
name|sc
argument_list|,
name|ocr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|SUCCESS
condition|)
block|{
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Get operational params, sge flags, send init cmd to ctlr */
if|if
condition|(
name|mrsas_init_adapter
argument_list|(
name|sc
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Adapter initialize Fail.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Allocate internal commands for pass-thru */
if|if
condition|(
name|mrsas_alloc_mfi_cmds
argument_list|(
name|sc
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Allocate MFI cmd failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*      * Get the controller info from FW, so that      * the MAX VD support availability can be decided.      */
name|ctrl_info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_ctrl_info
argument_list|)
argument_list|,
name|M_MRSAS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctrl_info
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Malloc for ctrl_info failed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrsas_get_ctrl_info
argument_list|(
name|sc
argument_list|,
name|ctrl_info
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Unable to get FW ctrl_info.\n"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|max256vdSupport
operator|=
operator|(
name|u_int8_t
operator|)
name|ctrl_info
operator|->
name|adapterOperations3
operator|.
name|supportMaxExtLDs
expr_stmt|;
if|if
condition|(
name|ctrl_info
operator|->
name|max_lds
operator|>
literal|64
condition|)
block|{
name|sc
operator|->
name|max256vdSupport
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mrsas_setup_raidmap
argument_list|(
name|sc
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Set up RAID map failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* For pass-thru, get PD/LD list and controller info */
name|memset
argument_list|(
name|sc
operator|->
name|pd_list
argument_list|,
literal|0
argument_list|,
name|MRSAS_MAX_PD
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_pd_list
argument_list|)
argument_list|)
expr_stmt|;
name|mrsas_get_pd_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|ld_ids
argument_list|,
literal|0xff
argument_list|,
name|MRSAS_MAX_LD_IDS
argument_list|)
expr_stmt|;
name|mrsas_get_ld_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Compute the max allowed sectors per IO: The controller info has two      * limits on max sectors. Driver should use the minimum of these two.      *      * 1<< stripe_sz_ops.min = max sectors per strip      *      * Note that older firmwares (< FW ver 30) didn't report information      * to calculate max_sectors_1. So the number ended up as zero always.      */
name|tmp_sectors
operator|=
literal|0
expr_stmt|;
name|max_sectors_1
operator|=
operator|(
literal|1
operator|<<
name|ctrl_info
operator|->
name|stripe_sz_ops
operator|.
name|min
operator|)
operator|*
name|ctrl_info
operator|->
name|max_strips_per_io
expr_stmt|;
name|max_sectors_2
operator|=
name|ctrl_info
operator|->
name|max_request_size
expr_stmt|;
name|tmp_sectors
operator|=
name|min
argument_list|(
name|max_sectors_1
argument_list|,
name|max_sectors_2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|max_sectors_per_req
operator|=
name|sc
operator|->
name|max_num_sge
operator|*
name|MRSAS_PAGE_SIZE
operator|/
literal|512
expr_stmt|;
if|if
condition|(
name|tmp_sectors
operator|&&
operator|(
name|sc
operator|->
name|max_sectors_per_req
operator|>
name|tmp_sectors
operator|)
condition|)
name|sc
operator|->
name|max_sectors_per_req
operator|=
name|tmp_sectors
expr_stmt|;
name|sc
operator|->
name|disableOnlineCtrlReset
operator|=
name|ctrl_info
operator|->
name|properties
operator|.
name|OnOffProperties
operator|.
name|disableOnlineCtrlReset
expr_stmt|;
name|sc
operator|->
name|UnevenSpanSupport
operator|=
name|ctrl_info
operator|->
name|adapterOperations2
operator|.
name|supportUnevenSpans
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|UnevenSpanSupport
condition|)
block|{
name|printf
argument_list|(
literal|"FW supports: UnevenSpanSupport=%x\n\n"
argument_list|,
name|sc
operator|->
name|UnevenSpanSupport
argument_list|)
expr_stmt|;
if|if
condition|(
name|MR_ValidateMapInfo
argument_list|(
name|sc
argument_list|)
condition|)
name|sc
operator|->
name|fast_path_io
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|fast_path_io
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ctrl_info
condition|)
name|free
argument_list|(
name|ctrl_info
argument_list|,
name|M_MRSAS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_init_adapter:     Initializes the adapter/controller   * input:                  Adapter soft state  *  * Prepares for the issuing of the IOC Init cmd to FW for initializing the   * ROC/controller.  The FW register is read to determined the number of   * commands that is supported.  All memory allocations for IO is based on  * max_cmd.  Appropriate calculations are performed in this function.   */
end_comment

begin_function
name|int
name|mrsas_init_adapter
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|u_int32_t
name|max_cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Read FW status register */
name|status
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_scratch_pad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get operational params from status register */
name|sc
operator|->
name|max_fw_cmds
operator|=
name|status
operator|&
name|MRSAS_FWSTATE_MAXCMD_MASK
expr_stmt|;
comment|/* Decrement the max supported by 1, to correlate with FW */
name|sc
operator|->
name|max_fw_cmds
operator|=
name|sc
operator|->
name|max_fw_cmds
operator|-
literal|1
expr_stmt|;
name|max_cmd
operator|=
name|sc
operator|->
name|max_fw_cmds
expr_stmt|;
comment|/* Determine allocation size of command frames */
name|sc
operator|->
name|reply_q_depth
operator|=
operator|(
operator|(
name|max_cmd
operator|*
literal|2
operator|+
literal|1
operator|+
literal|15
operator|)
operator|/
literal|16
operator|*
literal|16
operator|)
expr_stmt|;
name|sc
operator|->
name|request_alloc_sz
operator|=
sizeof|sizeof
argument_list|(
name|MRSAS_REQUEST_DESCRIPTOR_UNION
argument_list|)
operator|*
name|max_cmd
expr_stmt|;
name|sc
operator|->
name|reply_alloc_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_REPLY_DESCRIPTORS_UNION
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|reply_q_depth
operator|)
expr_stmt|;
name|sc
operator|->
name|io_frames_alloc_sz
operator|=
name|MRSAS_MPI2_RAID_DEFAULT_IO_FRAME_SIZE
operator|+
operator|(
name|MRSAS_MPI2_RAID_DEFAULT_IO_FRAME_SIZE
operator|*
operator|(
name|max_cmd
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|sc
operator|->
name|chain_frames_alloc_sz
operator|=
literal|1024
operator|*
name|max_cmd
expr_stmt|;
name|sc
operator|->
name|max_sge_in_main_msg
operator|=
operator|(
name|MRSAS_MPI2_RAID_DEFAULT_IO_FRAME_SIZE
operator|-
name|offsetof
argument_list|(
name|MRSAS_RAID_SCSI_IO_REQUEST
argument_list|,
name|SGL
argument_list|)
operator|)
operator|/
literal|16
expr_stmt|;
name|sc
operator|->
name|max_sge_in_chain
operator|=
name|MRSAS_MAX_SZ_CHAIN_FRAME
operator|/
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
expr_stmt|;
name|sc
operator|->
name|max_num_sge
operator|=
name|sc
operator|->
name|max_sge_in_main_msg
operator|+
name|sc
operator|->
name|max_sge_in_chain
operator|-
literal|2
expr_stmt|;
comment|/* Used for pass thru MFI frame (DCMD) */
name|sc
operator|->
name|chain_offset_mfi_pthru
operator|=
name|offsetof
argument_list|(
name|MRSAS_RAID_SCSI_IO_REQUEST
argument_list|,
name|SGL
argument_list|)
operator|/
literal|16
expr_stmt|;
name|sc
operator|->
name|chain_offset_io_request
operator|=
operator|(
name|MRSAS_MPI2_RAID_DEFAULT_IO_FRAME_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
operator|)
operator|/
literal|16
expr_stmt|;
name|sc
operator|->
name|last_reply_idx
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|mrsas_alloc_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|SUCCESS
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|ret
operator|=
name|mrsas_alloc_mpt_cmds
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|SUCCESS
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|ret
operator|=
name|mrsas_ioc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|SUCCESS
condition|)
return|return
operator|(
name|ret
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_alloc_ioc_cmd:   Allocates memory for IOC Init command   * input:                 Adapter soft state  *  * Allocates for the IOC Init cmd to FW to initialize the ROC/controller.  */
end_comment

begin_function
name|int
name|mrsas_alloc_ioc_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ioc_init_size
decl_stmt|;
comment|/* Allocate IOC INIT command */
name|ioc_init_size
operator|=
literal|1024
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_IOC_INIT_REQUEST
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
comment|// parent
literal|1
argument_list|,
literal|0
argument_list|,
comment|// algnmnt, boundary
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// filter, filterarg
name|ioc_init_size
argument_list|,
comment|// maxsize
literal|1
argument_list|,
comment|// msegments
name|ioc_init_size
argument_list|,
comment|// maxsegsize
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|// flags
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// lockfunc, lockarg
operator|&
name|sc
operator|->
name|ioc_init_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate ioc init tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|ioc_init_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|ioc_init_mem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|ioc_init_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate ioc init cmd mem\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|ioc_init_mem
argument_list|,
name|ioc_init_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|ioc_init_tag
argument_list|,
name|sc
operator|->
name|ioc_init_dmamap
argument_list|,
name|sc
operator|->
name|ioc_init_mem
argument_list|,
name|ioc_init_size
argument_list|,
name|mrsas_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|ioc_init_phys_mem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot load ioc init cmd mem\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_free_ioc_cmd:   Allocates memory for IOC Init command   * input:                Adapter soft state  *  * Deallocates memory of the IOC Init cmd.  */
end_comment

begin_function
name|void
name|mrsas_free_ioc_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|ioc_init_phys_mem
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|ioc_init_tag
argument_list|,
name|sc
operator|->
name|ioc_init_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ioc_init_mem
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|ioc_init_tag
argument_list|,
name|sc
operator|->
name|ioc_init_mem
argument_list|,
name|sc
operator|->
name|ioc_init_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ioc_init_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|ioc_init_tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_ioc_init:     Sends IOC Init command to FW  * input:              Adapter soft state  *  * Issues the IOC Init cmd to FW to initialize the ROC/controller.  */
end_comment

begin_function
name|int
name|mrsas_ioc_init
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mrsas_init_frame
modifier|*
name|init_frame
decl_stmt|;
name|pMpi2IOCInitRequest_t
name|IOCInitMsg
decl_stmt|;
name|MRSAS_REQUEST_DESCRIPTOR_UNION
name|req_desc
decl_stmt|;
name|u_int8_t
name|max_wait
init|=
name|MRSAS_IOC_INIT_WAIT_TIME
decl_stmt|;
name|bus_addr_t
name|phys_addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|retcode
init|=
literal|0
decl_stmt|;
comment|/* Allocate memory for the IOC INIT command */
if|if
condition|(
name|mrsas_alloc_ioc_cmd
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate IOC command.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|IOCInitMsg
operator|=
call|(
name|pMpi2IOCInitRequest_t
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|ioc_init_mem
operator|)
operator|+
literal|1024
argument_list|)
expr_stmt|;
name|IOCInitMsg
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_IOC_INIT
expr_stmt|;
name|IOCInitMsg
operator|->
name|WhoInit
operator|=
name|MPI2_WHOINIT_HOST_DRIVER
expr_stmt|;
name|IOCInitMsg
operator|->
name|MsgVersion
operator|=
name|MPI2_VERSION
expr_stmt|;
name|IOCInitMsg
operator|->
name|HeaderVersion
operator|=
name|MPI2_HEADER_VERSION
expr_stmt|;
name|IOCInitMsg
operator|->
name|SystemRequestFrameSize
operator|=
name|MRSAS_MPI2_RAID_DEFAULT_IO_FRAME_SIZE
operator|/
literal|4
expr_stmt|;
name|IOCInitMsg
operator|->
name|ReplyDescriptorPostQueueDepth
operator|=
name|sc
operator|->
name|reply_q_depth
expr_stmt|;
name|IOCInitMsg
operator|->
name|ReplyDescriptorPostQueueAddress
operator|=
name|sc
operator|->
name|reply_desc_phys_addr
expr_stmt|;
name|IOCInitMsg
operator|->
name|SystemRequestFrameBaseAddress
operator|=
name|sc
operator|->
name|io_request_phys_addr
expr_stmt|;
name|init_frame
operator|=
operator|(
expr|struct
name|mrsas_init_frame
operator|*
operator|)
name|sc
operator|->
name|ioc_init_mem
expr_stmt|;
name|init_frame
operator|->
name|cmd
operator|=
name|MFI_CMD_INIT
expr_stmt|;
name|init_frame
operator|->
name|cmd_status
operator|=
literal|0xFF
expr_stmt|;
name|init_frame
operator|->
name|flags
operator||=
name|MFI_FRAME_DONT_POST_IN_REPLY_QUEUE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|verbuf_mem
condition|)
block|{
name|snprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|verbuf_mem
argument_list|,
name|strlen
argument_list|(
name|MRSAS_VERSION
argument_list|)
operator|+
literal|2
argument_list|,
literal|"%s\n"
argument_list|,
name|MRSAS_VERSION
argument_list|)
expr_stmt|;
name|init_frame
operator|->
name|driver_ver_lo
operator|=
operator|(
name|bus_addr_t
operator|)
name|sc
operator|->
name|verbuf_phys_addr
expr_stmt|;
name|init_frame
operator|->
name|driver_ver_hi
operator|=
literal|0
expr_stmt|;
block|}
name|init_frame
operator|->
name|driver_operations
operator|.
name|mfi_capabilities
operator|.
name|support_max_255lds
operator|=
literal|1
expr_stmt|;
name|phys_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|sc
operator|->
name|ioc_init_phys_mem
operator|+
literal|1024
expr_stmt|;
name|init_frame
operator|->
name|queue_info_new_phys_addr_lo
operator|=
name|phys_addr
expr_stmt|;
name|init_frame
operator|->
name|data_xfer_len
operator|=
sizeof|sizeof
argument_list|(
name|Mpi2IOCInitRequest_t
argument_list|)
expr_stmt|;
name|req_desc
operator|.
name|addr
operator|.
name|Words
operator|=
operator|(
name|bus_addr_t
operator|)
name|sc
operator|->
name|ioc_init_phys_mem
expr_stmt|;
name|req_desc
operator|.
name|MFAIo
operator|.
name|RequestFlags
operator|=
operator|(
name|MRSAS_REQ_DESCRIPT_FLAGS_MFA
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
name|mrsas_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"Issuing IOC INIT command to FW.\n"
argument_list|)
expr_stmt|;
comment|//device_printf(sc->mrsas_dev, "Issuing IOC INIT command to FW.\n");del?
name|mrsas_fire_cmd
argument_list|(
name|sc
argument_list|,
name|req_desc
operator|.
name|addr
operator|.
name|u
operator|.
name|low
argument_list|,
name|req_desc
operator|.
name|addr
operator|.
name|u
operator|.
name|high
argument_list|)
expr_stmt|;
comment|/*      * Poll response timer to wait for Firmware response.  While this      * timer with the DELAY call could block CPU, the time interval for      * this is only 1 millisecond.      */
if|if
condition|(
name|init_frame
operator|->
name|cmd_status
operator|==
literal|0xFF
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|max_wait
operator|*
literal|1000
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|init_frame
operator|->
name|cmd_status
operator|==
literal|0xFF
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
if|if
condition|(
name|init_frame
operator|->
name|cmd_status
operator|==
literal|0
condition|)
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"IOC INIT response received from FW.\n"
argument_list|)
expr_stmt|;
comment|//device_printf(sc->mrsas_dev, "IOC INIT response received from FW.\n");del?
else|else
block|{
if|if
condition|(
name|init_frame
operator|->
name|cmd_status
operator|==
literal|0xFF
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"IOC Init timed out after %d seconds.\n"
argument_list|,
name|max_wait
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"IOC Init failed, status = 0x%x\n"
argument_list|,
name|init_frame
operator|->
name|cmd_status
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
block|}
name|mrsas_free_ioc_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_alloc_mpt_cmds:  Allocates the command packets  * input:                 Adapter instance soft state  *  * This function allocates the internal commands for IOs. Each command that is  * issued to FW is wrapped in a local data structure called mrsas_mpt_cmd.  * An array is allocated with mrsas_mpt_cmd context.  The free commands are   * maintained in a linked list (cmd pool). SMID value range is from 1 to  * max_fw_cmds.  */
end_comment

begin_function
name|int
name|mrsas_alloc_mpt_cmds
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int32_t
name|max_cmd
decl_stmt|;
name|struct
name|mrsas_mpt_cmd
modifier|*
name|cmd
decl_stmt|;
name|pMpi2ReplyDescriptorsUnion_t
name|reply_desc
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|,
name|chain_offset
decl_stmt|,
name|sense_offset
decl_stmt|;
name|bus_addr_t
name|io_req_base_phys
decl_stmt|,
name|chain_frame_base_phys
decl_stmt|,
name|sense_base_phys
decl_stmt|;
name|u_int8_t
modifier|*
name|io_req_base
decl_stmt|,
modifier|*
name|chain_frame_base
decl_stmt|,
modifier|*
name|sense_base
decl_stmt|;
name|max_cmd
operator|=
name|sc
operator|->
name|max_fw_cmds
expr_stmt|;
name|sc
operator|->
name|req_desc
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|request_alloc_sz
argument_list|,
name|M_MRSAS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|req_desc
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Out of memory, cannot alloc req desc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|sc
operator|->
name|req_desc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|request_alloc_sz
argument_list|)
expr_stmt|;
comment|/*      * sc->mpt_cmd_list is an array of struct mrsas_mpt_cmd pointers. Allocate the      * dynamic array first and then allocate individual commands.      */
name|sc
operator|->
name|mpt_cmd_list
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_mpt_cmd
operator|*
argument_list|)
operator|*
name|max_cmd
argument_list|,
name|M_MRSAS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mpt_cmd_list
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc memory for mpt_cmd_list.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|sc
operator|->
name|mpt_cmd_list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_mpt_cmd
operator|*
argument_list|)
operator|*
name|max_cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_cmd
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|mpt_cmd_list
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_mpt_cmd
argument_list|)
argument_list|,
name|M_MRSAS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mpt_cmd_list
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|free
argument_list|(
name|sc
operator|->
name|mpt_cmd_list
index|[
name|j
index|]
argument_list|,
name|M_MRSAS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|mpt_cmd_list
argument_list|,
name|M_MRSAS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mpt_cmd_list
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
name|io_req_base
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|sc
operator|->
name|io_request_mem
operator|+
name|MRSAS_MPI2_RAID_DEFAULT_IO_FRAME_SIZE
expr_stmt|;
name|io_req_base_phys
operator|=
operator|(
name|bus_addr_t
operator|)
name|sc
operator|->
name|io_request_phys_addr
operator|+
name|MRSAS_MPI2_RAID_DEFAULT_IO_FRAME_SIZE
expr_stmt|;
name|chain_frame_base
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|sc
operator|->
name|chain_frame_mem
expr_stmt|;
name|chain_frame_base_phys
operator|=
operator|(
name|bus_addr_t
operator|)
name|sc
operator|->
name|chain_frame_phys_addr
expr_stmt|;
name|sense_base
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|sc
operator|->
name|sense_mem
expr_stmt|;
name|sense_base_phys
operator|=
operator|(
name|bus_addr_t
operator|)
name|sc
operator|->
name|sense_phys_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_cmd
condition|;
name|i
operator|++
control|)
block|{
name|cmd
operator|=
name|sc
operator|->
name|mpt_cmd_list
index|[
name|i
index|]
expr_stmt|;
name|offset
operator|=
name|MRSAS_MPI2_RAID_DEFAULT_IO_FRAME_SIZE
operator|*
name|i
expr_stmt|;
name|chain_offset
operator|=
literal|1024
operator|*
name|i
expr_stmt|;
name|sense_offset
operator|=
name|MRSAS_SENSE_LEN
operator|*
name|i
expr_stmt|;
name|memset
argument_list|(
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_mpt_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|cmd
operator|->
name|ccb_ptr
operator|=
name|NULL
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|cmd
operator|->
name|cm_callout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|sync_cmd_idx
operator|=
operator|(
name|u_int32_t
operator|)
name|MRSAS_ULONG_MAX
expr_stmt|;
name|cmd
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|cmd
operator|->
name|io_request
operator|=
operator|(
name|MRSAS_RAID_SCSI_IO_REQUEST
operator|*
operator|)
operator|(
name|io_req_base
operator|+
name|offset
operator|)
expr_stmt|;
name|memset
argument_list|(
name|cmd
operator|->
name|io_request
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MRSAS_RAID_SCSI_IO_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|io_request_phys_addr
operator|=
name|io_req_base_phys
operator|+
name|offset
expr_stmt|;
name|cmd
operator|->
name|chain_frame
operator|=
operator|(
name|MPI2_SGE_IO_UNION
operator|*
operator|)
operator|(
name|chain_frame_base
operator|+
name|chain_offset
operator|)
expr_stmt|;
name|cmd
operator|->
name|chain_frame_phys_addr
operator|=
name|chain_frame_base_phys
operator|+
name|chain_offset
expr_stmt|;
name|cmd
operator|->
name|sense
operator|=
name|sense_base
operator|+
name|sense_offset
expr_stmt|;
name|cmd
operator|->
name|sense_phys_addr
operator|=
name|sense_base_phys
operator|+
name|sense_offset
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|data_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|cmd
operator|->
name|data_dmamap
argument_list|)
condition|)
block|{
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|mrsas_mpt_cmd_list_head
operator|)
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize reply descriptor array to 0xFFFFFFFF */
name|reply_desc
operator|=
name|sc
operator|->
name|reply_desc_mem
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|reply_q_depth
condition|;
name|i
operator|++
operator|,
name|reply_desc
operator|++
control|)
block|{
name|reply_desc
operator|->
name|Words
operator|=
name|MRSAS_ULONG_MAX
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_fire_cmd:     Sends command to FW  * input:              Adapter soft state  *                     request descriptor address low  *                     request descriptor address high  *  * This functions fires the command to Firmware by writing to the   * inbound_low_queue_port and inbound_high_queue_port.  */
end_comment

begin_function
name|void
name|mrsas_fire_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|req_desc_lo
parameter_list|,
name|u_int32_t
name|req_desc_hi
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|pci_lock
argument_list|)
expr_stmt|;
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|inbound_low_queue_port
argument_list|)
argument_list|,
name|req_desc_lo
argument_list|)
expr_stmt|;
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|inbound_high_queue_port
argument_list|)
argument_list|,
name|req_desc_hi
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|pci_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_transition_to_ready:  Move FW to Ready state   * input:                      Adapter instance soft state  *  * During the initialization, FW passes can potentially be in any one of  * several possible states. If the FW in operational, waiting-for-handshake  * states, driver must take steps to bring it to ready state. Otherwise, it  * has to wait for the ready state.  */
end_comment

begin_function
name|int
name|mrsas_transition_to_ready
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ocr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int8_t
name|max_wait
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|,
name|fw_state
decl_stmt|;
name|u_int32_t
name|cur_state
decl_stmt|;
name|u_int32_t
name|abs_state
decl_stmt|,
name|curr_abs_state
decl_stmt|;
name|val
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_scratch_pad
argument_list|)
argument_list|)
expr_stmt|;
name|fw_state
operator|=
name|val
operator|&
name|MFI_STATE_MASK
expr_stmt|;
name|max_wait
operator|=
name|MRSAS_RESET_WAIT_TIME
expr_stmt|;
if|if
condition|(
name|fw_state
operator|!=
name|MFI_STATE_READY
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Waiting for FW to come to ready state\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fw_state
operator|!=
name|MFI_STATE_READY
condition|)
block|{
name|abs_state
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_scratch_pad
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fw_state
condition|)
block|{
case|case
name|MFI_STATE_FAULT
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"FW is in FAULT state!!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocr
condition|)
block|{
name|cur_state
operator|=
name|MFI_STATE_FAULT
expr_stmt|;
break|break;
block|}
else|else
return|return
operator|-
name|ENODEV
return|;
case|case
name|MFI_STATE_WAIT_HANDSHAKE
case|:
comment|/* Set the CLR bit in inbound doorbell */
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|doorbell
argument_list|)
argument_list|,
name|MFI_INIT_CLEAR_HANDSHAKE
operator||
name|MFI_INIT_HOTPLUG
argument_list|)
expr_stmt|;
name|cur_state
operator|=
name|MFI_STATE_WAIT_HANDSHAKE
expr_stmt|;
break|break;
case|case
name|MFI_STATE_BOOT_MESSAGE_PENDING
case|:
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|doorbell
argument_list|)
argument_list|,
name|MFI_INIT_HOTPLUG
argument_list|)
expr_stmt|;
name|cur_state
operator|=
name|MFI_STATE_BOOT_MESSAGE_PENDING
expr_stmt|;
break|break;
case|case
name|MFI_STATE_OPERATIONAL
case|:
comment|/* Bring it to READY state; assuming max wait 10 secs */
name|mrsas_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|doorbell
argument_list|)
argument_list|,
name|MFI_RESET_FLAGS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_wait
operator|*
literal|1000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|doorbell
argument_list|)
argument_list|)
operator|&
literal|1
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|cur_state
operator|=
name|MFI_STATE_OPERATIONAL
expr_stmt|;
break|break;
case|case
name|MFI_STATE_UNDEFINED
case|:
comment|/* This state should not last for more than 2 seconds */
name|cur_state
operator|=
name|MFI_STATE_UNDEFINED
expr_stmt|;
break|break;
case|case
name|MFI_STATE_BB_INIT
case|:
name|cur_state
operator|=
name|MFI_STATE_BB_INIT
expr_stmt|;
break|break;
case|case
name|MFI_STATE_FW_INIT
case|:
name|cur_state
operator|=
name|MFI_STATE_FW_INIT
expr_stmt|;
break|break;
case|case
name|MFI_STATE_FW_INIT_2
case|:
name|cur_state
operator|=
name|MFI_STATE_FW_INIT_2
expr_stmt|;
break|break;
case|case
name|MFI_STATE_DEVICE_SCAN
case|:
name|cur_state
operator|=
name|MFI_STATE_DEVICE_SCAN
expr_stmt|;
break|break;
case|case
name|MFI_STATE_FLUSH_CACHE
case|:
name|cur_state
operator|=
name|MFI_STATE_FLUSH_CACHE
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Unknown state 0x%x\n"
argument_list|,
name|fw_state
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
comment|/* 	 * The cur_state should not last for more than max_wait secs 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|max_wait
operator|*
literal|1000
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|fw_state
operator|=
operator|(
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_scratch_pad
argument_list|)
argument_list|)
operator|&
name|MFI_STATE_MASK
operator|)
expr_stmt|;
name|curr_abs_state
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_scratch_pad
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs_state
operator|==
name|curr_abs_state
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* 	 * Return error if fw_state hasn't changed after max_wait 	 */
if|if
condition|(
name|curr_abs_state
operator|==
name|abs_state
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"FW state [%d] hasn't changed "
literal|"in %d secs\n"
argument_list|,
name|fw_state
argument_list|,
name|max_wait
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
block|}
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"FW now in Ready state\n"
argument_list|)
expr_stmt|;
comment|//device_printf(sc->mrsas_dev, "FW now in Ready state\n");del?
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_get_mfi_cmd:      Get a cmd from free command pool  * input:                  Adapter soft state  *  * This function removes an MFI command from the command list.  */
end_comment

begin_function
name|struct
name|mrsas_mfi_cmd
modifier|*
name|mrsas_get_mfi_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
init|=
name|NULL
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_cmd_pool_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|mrsas_mfi_cmd_list_head
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|mrsas_mfi_cmd_list_head
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|mrsas_mfi_cmd_list_head
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_cmd_pool_lock
argument_list|)
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_ocr_thread             Thread to handle OCR/Kill Adapter.  * input:               Adapter Context.  *  * This function will check FW status register and flag  * do_timeout_reset flag. It will do OCR/Kill adapter if  * FW is in fault state or IO timed out has trigger reset.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_ocr_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|fw_status
decl_stmt|,
name|fw_state
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mrsas_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ocr_thread_active
operator|=
literal|1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Sleep for 1 second and check the queue status*/
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|ocr_chan
argument_list|,
operator|&
name|sc
operator|->
name|sim_lock
argument_list|,
name|PRIBIO
argument_list|,
literal|"mrsas_ocr"
argument_list|,
name|sc
operator|->
name|mrsas_fw_fault_check_delay
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|remove_in_progress
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"Exit due to shutdown from %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|fw_status
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_scratch_pad
argument_list|)
argument_list|)
expr_stmt|;
name|fw_state
operator|=
name|fw_status
operator|&
name|MFI_STATE_MASK
expr_stmt|;
if|if
condition|(
name|fw_state
operator|==
name|MFI_STATE_FAULT
operator|||
name|sc
operator|->
name|do_timedout_reset
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"OCR started due to %s!\n"
argument_list|,
name|sc
operator|->
name|do_timedout_reset
condition|?
literal|"IO Timeout"
else|:
literal|"FW fault detected"
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|ioctl_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reset_in_progress
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|reset_count
operator|++
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|ioctl_lock
argument_list|)
expr_stmt|;
name|mrsas_xpt_freeze
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_reset_ctrl
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_xpt_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reset_in_progress
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|do_timedout_reset
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ocr_thread_active
operator|=
literal|0
expr_stmt|;
name|mrsas_kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_reset_reply_desc       Reset Reply descriptor as part of OCR.  * input:                       Adapter Context.  *  * This function will clear reply descriptor so that post OCR  * driver and FW will lost old history.  */
end_comment

begin_function
name|void
name|mrsas_reset_reply_desc
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|pMpi2ReplyDescriptorsUnion_t
name|reply_desc
decl_stmt|;
name|sc
operator|->
name|last_reply_idx
operator|=
literal|0
expr_stmt|;
name|reply_desc
operator|=
name|sc
operator|->
name|reply_desc_mem
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|reply_q_depth
condition|;
name|i
operator|++
operator|,
name|reply_desc
operator|++
control|)
block|{
name|reply_desc
operator|->
name|Words
operator|=
name|MRSAS_ULONG_MAX
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * mrsas_reset_ctrl     Core function to OCR/Kill adapter.  * input:               Adapter Context.  *  * This function will run from thread context so that it can sleep.  * 1. Do not handle OCR if FW is in HW critical error.  * 2. Wait for outstanding command to complete for 180 seconds.  * 3. If #2 does not find any outstanding command Controller is in working  * state, so skip OCR.  * Otherwise, do OCR/kill Adapter based on flag disableOnlineCtrlReset.  * 4. Start of the OCR, return all SCSI command back to CAM layer which has  * ccb_ptr.  * 5. Post OCR, Re-fire Managment command and move Controller to Operation  * state.  */
end_comment

begin_function
name|int
name|mrsas_reset_ctrl
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|retval
init|=
name|SUCCESS
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|retry
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|host_diag
decl_stmt|,
name|abs_state
decl_stmt|,
name|status_reg
decl_stmt|,
name|reset_adapter
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|mrsas_mfi_cmd
modifier|*
name|mfi_cmd
decl_stmt|;
name|struct
name|mrsas_mpt_cmd
modifier|*
name|mpt_cmd
decl_stmt|;
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|req_desc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|adprecovery
operator|==
name|MRSAS_HW_CRITICAL_ERROR
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"mrsas: Hardware critical error, returning FAIL.\n"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|set_bit
argument_list|(
name|MRSAS_FUSION_IN_RESET
argument_list|,
operator|&
name|sc
operator|->
name|reset_flags
argument_list|)
expr_stmt|;
name|sc
operator|->
name|adprecovery
operator|=
name|MRSAS_ADPRESET_SM_INFAULT
expr_stmt|;
name|mrsas_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* First try waiting for commands to complete */
if|if
condition|(
name|mrsas_wait_for_outstanding
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"resetting adapter from %s.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Now return commands back to the CAM layer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_fw_cmds
condition|;
name|i
operator|++
control|)
block|{
name|mpt_cmd
operator|=
name|sc
operator|->
name|mpt_cmd_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mpt_cmd
operator|->
name|ccb_ptr
condition|)
block|{
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|(
name|mpt_cmd
operator|->
name|ccb_ptr
operator|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
name|mrsas_cmd_done
argument_list|(
name|sc
argument_list|,
name|mpt_cmd
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|sc
operator|->
name|fw_outstanding
argument_list|)
expr_stmt|;
block|}
block|}
name|status_reg
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_scratch_pad
argument_list|)
argument_list|)
expr_stmt|;
name|abs_state
operator|=
name|status_reg
operator|&
name|MFI_STATE_MASK
expr_stmt|;
name|reset_adapter
operator|=
name|status_reg
operator|&
name|MFI_RESET_ADAPTER
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|disableOnlineCtrlReset
operator|||
operator|(
name|abs_state
operator|==
name|MFI_STATE_FAULT
operator|&&
operator|!
name|reset_adapter
operator|)
condition|)
block|{
comment|/* Reset not supported, kill adapter */
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"Reset not supported, killing adapter.\n"
argument_list|)
expr_stmt|;
name|mrsas_kill_hba
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|adprecovery
operator|=
name|MRSAS_HW_CRITICAL_ERROR
expr_stmt|;
name|retval
operator|=
name|FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Now try to reset the chip */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MRSAS_FUSION_MAX_RESET_TRIES
condition|;
name|i
operator|++
control|)
block|{
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|fusion_seq_offset
argument_list|)
argument_list|,
name|MPI2_WRSEQ_FLUSH_KEY_VALUE
argument_list|)
expr_stmt|;
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|fusion_seq_offset
argument_list|)
argument_list|,
name|MPI2_WRSEQ_1ST_KEY_VALUE
argument_list|)
expr_stmt|;
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|fusion_seq_offset
argument_list|)
argument_list|,
name|MPI2_WRSEQ_2ND_KEY_VALUE
argument_list|)
expr_stmt|;
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|fusion_seq_offset
argument_list|)
argument_list|,
name|MPI2_WRSEQ_3RD_KEY_VALUE
argument_list|)
expr_stmt|;
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|fusion_seq_offset
argument_list|)
argument_list|,
name|MPI2_WRSEQ_4TH_KEY_VALUE
argument_list|)
expr_stmt|;
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|fusion_seq_offset
argument_list|)
argument_list|,
name|MPI2_WRSEQ_5TH_KEY_VALUE
argument_list|)
expr_stmt|;
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|fusion_seq_offset
argument_list|)
argument_list|,
name|MPI2_WRSEQ_6TH_KEY_VALUE
argument_list|)
expr_stmt|;
comment|/* Check that the diag write enable (DRWE) bit is on */
name|host_diag
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|fusion_host_diag
argument_list|)
argument_list|)
expr_stmt|;
name|retry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|host_diag
operator|&
name|HOST_DIAG_WRITE_ENABLE
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|host_diag
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|fusion_host_diag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
operator|++
operator|==
literal|100
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"Host diag unlock failed!\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|host_diag
operator|&
name|HOST_DIAG_WRITE_ENABLE
operator|)
condition|)
continue|continue;
comment|/* Send chip reset command */
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|fusion_host_diag
argument_list|)
argument_list|,
name|host_diag
operator||
name|HOST_DIAG_RESET_ADAPTER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|3000
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* Make sure reset adapter bit is cleared */
name|host_diag
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|fusion_host_diag
argument_list|)
argument_list|)
expr_stmt|;
name|retry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|host_diag
operator|&
name|HOST_DIAG_RESET_ADAPTER
condition|)
block|{
name|DELAY
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|host_diag
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|fusion_host_diag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
operator|++
operator|==
literal|1000
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"Diag reset adapter never cleared!\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|host_diag
operator|&
name|HOST_DIAG_RESET_ADAPTER
condition|)
continue|continue;
name|abs_state
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_scratch_pad
argument_list|)
argument_list|)
operator|&
name|MFI_STATE_MASK
expr_stmt|;
name|retry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|abs_state
operator|<=
name|MFI_STATE_FW_INIT
operator|)
operator|&&
operator|(
name|retry
operator|++
operator|<
literal|1000
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|abs_state
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_scratch_pad
argument_list|)
argument_list|)
operator|&
name|MFI_STATE_MASK
expr_stmt|;
block|}
if|if
condition|(
name|abs_state
operator|<=
name|MFI_STATE_FW_INIT
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"firmware state< MFI_STATE_FW_INIT,"
literal|" state = 0x%x\n"
argument_list|,
name|abs_state
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Wait for FW to become ready */
if|if
condition|(
name|mrsas_transition_to_ready
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"mrsas: Failed to transition controller to ready.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mrsas_reset_reply_desc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrsas_ioc_init
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"mrsas_ioc_init() failed!\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|clear_bit
argument_list|(
name|MRSAS_FUSION_IN_RESET
argument_list|,
operator|&
name|sc
operator|->
name|reset_flags
argument_list|)
expr_stmt|;
name|mrsas_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|adprecovery
operator|=
name|MRSAS_HBA_OPERATIONAL
expr_stmt|;
comment|/* Re-fire management commands */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|max_fw_cmds
condition|;
name|j
operator|++
control|)
block|{
name|mpt_cmd
operator|=
name|sc
operator|->
name|mpt_cmd_list
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|mpt_cmd
operator|->
name|sync_cmd_idx
operator|!=
operator|(
name|u_int32_t
operator|)
name|MRSAS_ULONG_MAX
condition|)
block|{
name|mfi_cmd
operator|=
name|sc
operator|->
name|mfi_cmd_list
index|[
name|mpt_cmd
operator|->
name|sync_cmd_idx
index|]
expr_stmt|;
if|if
condition|(
name|mfi_cmd
operator|->
name|frame
operator|->
name|dcmd
operator|.
name|opcode
operator|==
name|MR_DCMD_LD_MAP_GET_INFO
condition|)
block|{
name|mrsas_release_mfi_cmd
argument_list|(
name|mfi_cmd
argument_list|)
expr_stmt|;
name|mrsas_release_mpt_cmd
argument_list|(
name|mpt_cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|req_desc
operator|=
name|mrsas_get_request_desc
argument_list|(
name|sc
argument_list|,
name|mfi_cmd
operator|->
name|cmd_id
operator|.
name|context
operator|.
name|smid
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"Re-fire command DCMD opcode 0x%x index %d\n "
argument_list|,
name|mfi_cmd
operator|->
name|frame
operator|->
name|dcmd
operator|.
name|opcode
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req_desc
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot build MPT cmd.\n"
argument_list|)
expr_stmt|;
else|else
name|mrsas_fire_cmd
argument_list|(
name|sc
argument_list|,
name|req_desc
operator|->
name|addr
operator|.
name|u
operator|.
name|low
argument_list|,
name|req_desc
operator|->
name|addr
operator|.
name|u
operator|.
name|high
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Reset load balance info */
name|memset
argument_list|(
name|sc
operator|->
name|load_balance_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|LD_LOAD_BALANCE_INFO
argument_list|)
operator|*
name|MAX_LOGICAL_DRIVES_EXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mrsas_get_map_info
argument_list|(
name|sc
argument_list|)
condition|)
name|mrsas_sync_map_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Adapter reset completed successfully */
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Reset successful\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Reset failed, kill the adapter */
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Reset failed, killing adapter.\n"
argument_list|)
expr_stmt|;
name|mrsas_kill_hba
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|retval
operator|=
name|FAIL
expr_stmt|;
block|}
else|else
block|{
name|clear_bit
argument_list|(
name|MRSAS_FUSION_IN_RESET
argument_list|,
operator|&
name|sc
operator|->
name|reset_flags
argument_list|)
expr_stmt|;
name|mrsas_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|adprecovery
operator|=
name|MRSAS_HBA_OPERATIONAL
expr_stmt|;
block|}
name|out
label|:
name|clear_bit
argument_list|(
name|MRSAS_FUSION_IN_RESET
argument_list|,
operator|&
name|sc
operator|->
name|reset_flags
argument_list|)
expr_stmt|;
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"Reset Exit with %d.\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_kill_hba       Kill HBA when OCR is not supported.  * input:               Adapter Context.  *  * This function will kill HBA when OCR is not supported.  */
end_comment

begin_function
name|void
name|mrsas_kill_hba
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mrsas_write_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|doorbell
argument_list|)
argument_list|,
name|MFI_STOP_ADP
argument_list|)
expr_stmt|;
comment|/* Flush */
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|doorbell
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_wait_for_outstanding           Wait for outstanding commands  * input:                               Adapter Context.  *  * This function will wait for 180 seconds for outstanding  * commands to be completed.  */
end_comment

begin_function
name|int
name|mrsas_wait_for_outstanding
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|outstanding
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|fw_state
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MRSAS_RESET_WAIT_TIME
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|remove_in_progress
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"Driver remove or shutdown called.\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Check if firmware is in fault state */
name|fw_state
operator|=
name|mrsas_read_reg
argument_list|(
name|sc
argument_list|,
name|offsetof
argument_list|(
name|mrsas_reg_set
argument_list|,
name|outbound_scratch_pad
argument_list|)
argument_list|)
operator|&
name|MFI_STATE_MASK
expr_stmt|;
if|if
condition|(
name|fw_state
operator|==
name|MFI_STATE_FAULT
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"Found FW in FAULT state, will reset adapter.\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|outstanding
operator|=
name|atomic_read
argument_list|(
operator|&
name|sc
operator|->
name|fw_outstanding
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outstanding
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
name|MRSAS_RESET_NOTICE_INTERVAL
operator|)
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|"[%2d]waiting for %d "
literal|"commands to complete\n"
argument_list|,
name|i
argument_list|,
name|outstanding
argument_list|)
expr_stmt|;
name|mrsas_complete_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|sc
operator|->
name|fw_outstanding
argument_list|)
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_OCR
argument_list|,
literal|" pending commands remain after waiting,"
literal|" will reset adapter.\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
name|out
label|:
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_release_mfi_cmd: Return a cmd to free command pool  * input:                 Command packet for return to free cmd pool   *  * This function returns the MFI command to the command list.  */
end_comment

begin_function
name|void
name|mrsas_release_mfi_cmd
parameter_list|(
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mrsas_softc
modifier|*
name|sc
init|=
name|cmd
operator|->
name|sc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_cmd_pool_lock
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ccb_ptr
operator|=
name|NULL
expr_stmt|;
name|cmd
operator|->
name|cmd_id
operator|.
name|frame_count
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|mrsas_mfi_cmd_list_head
operator|)
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_cmd_pool_lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * mrsas_get_controller_info -        Returns FW's controller structure  * input:                             Adapter soft state  *                                    Controller information structure  *  * Issues an internal command (DCMD) to get the FW's controller structure.  * This information is mainly used to find out the maximum IO transfer per  * command supported by the FW.  */
end_comment

begin_function
specifier|static
name|int
name|mrsas_get_ctrl_info
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_ctrl_info
modifier|*
name|ctrl_info
parameter_list|)
block|{
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mrsas_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|cmd
operator|=
name|mrsas_get_mfi_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Failed to get a free cmd\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dcmd
operator|=
operator|&
name|cmd
operator|->
name|frame
operator|->
name|dcmd
expr_stmt|;
if|if
condition|(
name|mrsas_alloc_ctlr_info_cmd
argument_list|(
name|sc
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate get ctlr info cmd\n"
argument_list|)
expr_stmt|;
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|memset
argument_list|(
name|dcmd
operator|->
name|mbox
operator|.
name|b
argument_list|,
literal|0
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|cmd_status
operator|=
literal|0xFF
expr_stmt|;
name|dcmd
operator|->
name|sge_count
operator|=
literal|1
expr_stmt|;
name|dcmd
operator|->
name|flags
operator|=
name|MFI_FRAME_DIR_READ
expr_stmt|;
name|dcmd
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|pad_0
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|data_xfer_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_ctrl_info
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MR_DCMD_CTRL_GET_INFO
expr_stmt|;
name|dcmd
operator|->
name|sgl
operator|.
name|sge32
index|[
literal|0
index|]
operator|.
name|phys_addr
operator|=
name|sc
operator|->
name|ctlr_info_phys_addr
expr_stmt|;
name|dcmd
operator|->
name|sgl
operator|.
name|sge32
index|[
literal|0
index|]
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_ctrl_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mrsas_issue_polled
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
condition|)
name|memcpy
argument_list|(
name|ctrl_info
argument_list|,
name|sc
operator|->
name|ctlr_info_mem
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_ctrl_info
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|retcode
operator|=
literal|1
expr_stmt|;
name|mrsas_free_ctlr_info_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_alloc_ctlr_info_cmd:  Allocates memory for controller info command  * input:                      Adapter soft state  *  * Allocates DMAable memory for the controller info internal command.  */
end_comment

begin_function
name|int
name|mrsas_alloc_ctlr_info_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ctlr_info_size
decl_stmt|;
comment|/* Allocate get controller info command */
name|ctlr_info_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_ctrl_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
comment|// parent
literal|1
argument_list|,
literal|0
argument_list|,
comment|// algnmnt, boundary
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// filter, filterarg
name|ctlr_info_size
argument_list|,
comment|// maxsize
literal|1
argument_list|,
comment|// msegments
name|ctlr_info_size
argument_list|,
comment|// maxsegsize
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|// flags
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// lockfunc, lockarg
operator|&
name|sc
operator|->
name|ctlr_info_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate ctlr info tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|ctlr_info_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|ctlr_info_mem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|ctlr_info_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate ctlr info cmd mem\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|ctlr_info_tag
argument_list|,
name|sc
operator|->
name|ctlr_info_dmamap
argument_list|,
name|sc
operator|->
name|ctlr_info_mem
argument_list|,
name|ctlr_info_size
argument_list|,
name|mrsas_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|ctlr_info_phys_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot load ctlr info cmd mem\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|sc
operator|->
name|ctlr_info_mem
argument_list|,
literal|0
argument_list|,
name|ctlr_info_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_free_ctlr_info_cmd: Free memory for controller info command   * input:                    Adapter soft state  *  * Deallocates memory of the get controller info cmd.  */
end_comment

begin_function
name|void
name|mrsas_free_ctlr_info_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|ctlr_info_phys_addr
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|ctlr_info_tag
argument_list|,
name|sc
operator|->
name|ctlr_info_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ctlr_info_mem
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|ctlr_info_tag
argument_list|,
name|sc
operator|->
name|ctlr_info_mem
argument_list|,
name|sc
operator|->
name|ctlr_info_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ctlr_info_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|ctlr_info_tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_issue_polled:        Issues a polling command  * inputs:                    Adapter soft state  *                            Command packet to be issued  *  * This function is for posting of internal commands to Firmware.  MFI   * requires the cmd_status to be set to 0xFF before posting.  The maximun  * wait time of the poll response timer is 180 seconds.  */
end_comment

begin_function
name|int
name|mrsas_issue_polled
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mrsas_header
modifier|*
name|frame_hdr
init|=
operator|&
name|cmd
operator|->
name|frame
operator|->
name|hdr
decl_stmt|;
name|u_int8_t
name|max_wait
init|=
name|MRSAS_INTERNAL_CMD_WAIT_TIME
decl_stmt|;
name|int
name|i
decl_stmt|,
name|retcode
init|=
literal|0
decl_stmt|;
name|frame_hdr
operator|->
name|cmd_status
operator|=
literal|0xFF
expr_stmt|;
name|frame_hdr
operator|->
name|flags
operator||=
name|MFI_FRAME_DONT_POST_IN_REPLY_QUEUE
expr_stmt|;
comment|/* Issue the frame using inbound queue port */
if|if
condition|(
name|mrsas_issue_dcmd
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot issue DCMD internal command.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*       * Poll response timer to wait for Firmware response.  While this         * timer with the DELAY call could block CPU, the time interval for       * this is only 1 millisecond.       */
if|if
condition|(
name|frame_hdr
operator|->
name|cmd_status
operator|==
literal|0xFF
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|max_wait
operator|*
literal|1000
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|frame_hdr
operator|->
name|cmd_status
operator|==
literal|0xFF
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
if|if
condition|(
name|frame_hdr
operator|->
name|cmd_status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|frame_hdr
operator|->
name|cmd_status
operator|==
literal|0xFF
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"DCMD timed out after %d seconds.\n"
argument_list|,
name|max_wait
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"DCMD failed, status = 0x%x\n"
argument_list|,
name|frame_hdr
operator|->
name|cmd_status
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_issue_dcmd -     Issues a MFI Pass thru cmd  * input:                 Adapter soft state  *                        mfi cmd pointer  *  * This function is called by mrsas_issued_blocked_cmd() and  * mrsas_issued_polled(), to build the MPT command and then fire the   * command to Firmware.   */
end_comment

begin_function
name|int
name|mrsas_issue_dcmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|req_desc
decl_stmt|;
name|req_desc
operator|=
name|mrsas_build_mpt_cmd
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req_desc
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot build MPT cmd.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|mrsas_fire_cmd
argument_list|(
name|sc
argument_list|,
name|req_desc
operator|->
name|addr
operator|.
name|u
operator|.
name|low
argument_list|,
name|req_desc
operator|->
name|addr
operator|.
name|u
operator|.
name|high
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_build_mpt_cmd - Calls helper function to build Passthru cmd  * input:                Adapter soft state  *                       mfi cmd to build  *  * This function is called by mrsas_issue_cmd() to build the MPT-MFI  * passthru command and prepares the MPT command to send to Firmware.  */
end_comment

begin_function
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|mrsas_build_mpt_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|MRSAS_REQUEST_DESCRIPTOR_UNION
modifier|*
name|req_desc
decl_stmt|;
name|u_int16_t
name|index
decl_stmt|;
if|if
condition|(
name|mrsas_build_mptmfi_passthru
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot build MPT-MFI passthru cmd.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|index
operator|=
name|cmd
operator|->
name|cmd_id
operator|.
name|context
operator|.
name|smid
expr_stmt|;
name|req_desc
operator|=
name|mrsas_get_request_desc
argument_list|(
name|sc
argument_list|,
name|index
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req_desc
condition|)
return|return
name|NULL
return|;
name|req_desc
operator|->
name|addr
operator|.
name|Words
operator|=
literal|0
expr_stmt|;
name|req_desc
operator|->
name|SCSIIO
operator|.
name|RequestFlags
operator|=
operator|(
name|MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO
operator|<<
name|MRSAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT
operator|)
expr_stmt|;
name|req_desc
operator|->
name|SCSIIO
operator|.
name|SMID
operator|=
name|index
expr_stmt|;
return|return
operator|(
name|req_desc
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_build_mptmfi_passthru - Builds a MPT MFI Passthru command   * input:                        Adapter soft state  *                               mfi cmd pointer   *  * The MPT command and the io_request are setup as a passthru command.   * The SGE chain address is set to frame_phys_addr of the MFI command.   */
end_comment

begin_function
name|u_int8_t
name|mrsas_build_mptmfi_passthru
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|mfi_cmd
parameter_list|)
block|{
name|MPI25_IEEE_SGE_CHAIN64
modifier|*
name|mpi25_ieee_chain
decl_stmt|;
name|PTR_MRSAS_RAID_SCSI_IO_REQUEST
name|io_req
decl_stmt|;
name|struct
name|mrsas_mpt_cmd
modifier|*
name|mpt_cmd
decl_stmt|;
name|struct
name|mrsas_header
modifier|*
name|frame_hdr
init|=
operator|&
name|mfi_cmd
operator|->
name|frame
operator|->
name|hdr
decl_stmt|;
name|mpt_cmd
operator|=
name|mrsas_get_mpt_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mpt_cmd
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Save the smid. To be used for returning the cmd */
name|mfi_cmd
operator|->
name|cmd_id
operator|.
name|context
operator|.
name|smid
operator|=
name|mpt_cmd
operator|->
name|index
expr_stmt|;
name|mpt_cmd
operator|->
name|sync_cmd_idx
operator|=
name|mfi_cmd
operator|->
name|index
expr_stmt|;
comment|/*      * For cmds where the flag is set, store the flag and check      * on completion. For cmds with this flag, don't call      * mrsas_complete_cmd.      */
if|if
condition|(
name|frame_hdr
operator|->
name|flags
operator|&
name|MFI_FRAME_DONT_POST_IN_REPLY_QUEUE
condition|)
name|mpt_cmd
operator|->
name|flags
operator|=
name|MFI_FRAME_DONT_POST_IN_REPLY_QUEUE
expr_stmt|;
name|io_req
operator|=
name|mpt_cmd
operator|->
name|io_request
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_INVADER
operator|)
operator|||
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_FURY
operator|)
condition|)
block|{
name|pMpi25IeeeSgeChain64_t
name|sgl_ptr_end
init|=
operator|(
name|pMpi25IeeeSgeChain64_t
operator|)
operator|&
name|io_req
operator|->
name|SGL
decl_stmt|;
name|sgl_ptr_end
operator|+=
name|sc
operator|->
name|max_sge_in_main_msg
operator|-
literal|1
expr_stmt|;
name|sgl_ptr_end
operator|->
name|Flags
operator|=
literal|0
expr_stmt|;
block|}
name|mpi25_ieee_chain
operator|=
operator|(
name|MPI25_IEEE_SGE_CHAIN64
operator|*
operator|)
operator|&
name|io_req
operator|->
name|SGL
operator|.
name|IeeeChain
expr_stmt|;
name|io_req
operator|->
name|Function
operator|=
name|MRSAS_MPI2_FUNCTION_PASSTHRU_IO_REQUEST
expr_stmt|;
name|io_req
operator|->
name|SGLOffset0
operator|=
name|offsetof
argument_list|(
name|MRSAS_RAID_SCSI_IO_REQUEST
argument_list|,
name|SGL
argument_list|)
operator|/
literal|4
expr_stmt|;
name|io_req
operator|->
name|ChainOffset
operator|=
name|sc
operator|->
name|chain_offset_mfi_pthru
expr_stmt|;
name|mpi25_ieee_chain
operator|->
name|Address
operator|=
name|mfi_cmd
operator|->
name|frame_phys_addr
expr_stmt|;
name|mpi25_ieee_chain
operator|->
name|Flags
operator|=
name|IEEE_SGE_FLAGS_CHAIN_ELEMENT
operator||
name|MPI2_IEEE_SGE_FLAGS_IOCPLBNTA_ADDR
expr_stmt|;
name|mpi25_ieee_chain
operator|->
name|Length
operator|=
name|MRSAS_MAX_SZ_CHAIN_FRAME
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_issue_blocked_cmd - Synchronous wrapper around regular FW cmds  * input:                    Adapter soft state  *                           Command to be issued  *  * This function waits on an event for the command to be returned   * from the ISR. Max wait time is MRSAS_INTERNAL_CMD_WAIT_TIME secs.  * Used for issuing internal and ioctl commands.  */
end_comment

begin_function
name|int
name|mrsas_issue_blocked_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|u_int8_t
name|max_wait
init|=
name|MRSAS_INTERNAL_CMD_WAIT_TIME
decl_stmt|;
name|unsigned
name|long
name|total_time
init|=
literal|0
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
comment|/* Initialize cmd_status */
name|cmd
operator|->
name|cmd_status
operator|=
name|ECONNREFUSED
expr_stmt|;
comment|/* Build MPT-MFI command for issue to FW */
if|if
condition|(
name|mrsas_issue_dcmd
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot issue DCMD internal command.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|chan
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|cmd
expr_stmt|;
comment|/* The following is for debug only... */
comment|//device_printf(sc->mrsas_dev,"DCMD issued to FW, about to sleep-wait...\n");
comment|//device_printf(sc->mrsas_dev,"sc->chan = %p\n", sc->chan);
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|cmd_status
operator|==
name|ECONNREFUSED
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|chan
argument_list|,
literal|0
argument_list|,
literal|"mrsas_sleep"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
name|total_time
operator|++
expr_stmt|;
if|if
condition|(
name|total_time
operator|>=
name|max_wait
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Internal command timed out after %d seconds.\n"
argument_list|,
name|max_wait
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_complete_mptmfi_passthru - Completes a command  * input:                           sc: Adapter soft state  *                                  cmd: Command to be completed  *                                  status: cmd completion status   *  * This function is called from mrsas_complete_cmd() after an interrupt   * is received from Firmware, and io_request->Function is   * MRSAS_MPI2_FUNCTION_PASSTHRU_IO_REQUEST.  */
end_comment

begin_function
name|void
name|mrsas_complete_mptmfi_passthru
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|,
name|u_int8_t
name|status
parameter_list|)
block|{
name|struct
name|mrsas_header
modifier|*
name|hdr
init|=
operator|&
name|cmd
operator|->
name|frame
operator|->
name|hdr
decl_stmt|;
name|u_int8_t
name|cmd_status
init|=
name|cmd
operator|->
name|frame
operator|->
name|hdr
operator|.
name|cmd_status
decl_stmt|;
comment|/* Reset the retry counter for future re-tries */
name|cmd
operator|->
name|retry_for_fw_reset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|ccb_ptr
condition|)
name|cmd
operator|->
name|ccb_ptr
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|cmd
condition|)
block|{
case|case
name|MFI_CMD_INVALID
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"MFI_CMD_INVALID command.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFI_CMD_PD_SCSI_IO
case|:
case|case
name|MFI_CMD_LD_SCSI_IO
case|:
comment|/*              * MFI_CMD_PD_SCSI_IO and MFI_CMD_LD_SCSI_IO could have been              * issued either through an IO path or an IOCTL path. If it              * was via IOCTL, we will send it to internal completion.              */
if|if
condition|(
name|cmd
operator|->
name|sync_cmd
condition|)
block|{
name|cmd
operator|->
name|sync_cmd
operator|=
literal|0
expr_stmt|;
name|mrsas_wakeup
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MFI_CMD_SMP
case|:
case|case
name|MFI_CMD_STP
case|:
case|case
name|MFI_CMD_DCMD
case|:
comment|/* Check for LD map update */
if|if
condition|(
operator|(
name|cmd
operator|->
name|frame
operator|->
name|dcmd
operator|.
name|opcode
operator|==
name|MR_DCMD_LD_MAP_GET_INFO
operator|)
operator|&&
operator|(
name|cmd
operator|->
name|frame
operator|->
name|dcmd
operator|.
name|mbox
operator|.
name|b
index|[
literal|1
index|]
operator|==
literal|1
operator|)
condition|)
block|{
name|sc
operator|->
name|fast_path_io
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cmd_status
operator|!=
name|MFI_STAT_NOT_FOUND
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"map sync failed, status=%x\n"
argument_list|,
name|cmd_status
argument_list|)
expr_stmt|;
else|else
block|{
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|sc
operator|->
name|map_id
operator|++
expr_stmt|;
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|MR_ValidateMapInfo
argument_list|(
name|sc
argument_list|)
condition|)
name|sc
operator|->
name|fast_path_io
operator|=
literal|0
expr_stmt|;
else|else
name|sc
operator|->
name|fast_path_io
operator|=
literal|1
expr_stmt|;
name|mrsas_sync_map_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|raidmap_lock
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
comment|//currently not supporting event handling, so commenting out
block|if (cmd->frame->dcmd.opcode == MR_DCMD_CTRL_EVENT_GET_INFO ||                     cmd->frame->dcmd.opcode == MR_DCMD_CTRL_EVENT_GET) {                 mrsas_poll_wait_aen = 0;             }
endif|#
directive|endif
comment|/* See if got an event notification */
if|if
condition|(
name|cmd
operator|->
name|frame
operator|->
name|dcmd
operator|.
name|opcode
operator|==
name|MR_DCMD_CTRL_EVENT_WAIT
condition|)
name|mrsas_complete_aen
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|else
name|mrsas_wakeup
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFI_CMD_ABORT
case|:
comment|/* Command issued to abort another cmd return */
name|mrsas_complete_abort
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Unknown command completed! [0x%X]\n"
argument_list|,
name|hdr
operator|->
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * mrsas_wakeup -         Completes an internal command  * input:                 Adapter soft state  *                        Command to be completed  *  * In mrsas_issue_blocked_cmd(), after a command is issued to Firmware,   * a wait timer is started.  This function is called from    * mrsas_complete_mptmfi_passthru() as it completes the command,  * to wake up from the command wait.  */
end_comment

begin_function
name|void
name|mrsas_wakeup
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|cmd
operator|->
name|cmd_status
operator|=
name|cmd
operator|->
name|frame
operator|->
name|io
operator|.
name|cmd_status
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|cmd_status
operator|==
name|ECONNREFUSED
condition|)
name|cmd
operator|->
name|cmd_status
operator|=
literal|0
expr_stmt|;
comment|/* For debug only ... */
comment|//device_printf(sc->mrsas_dev,"DCMD rec'd for wakeup, sc->chan=%p\n", sc->chan);
name|sc
operator|->
name|chan
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|cmd
expr_stmt|;
name|wakeup_one
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|chan
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * mrsas_shutdown_ctlr:       Instructs FW to shutdown the controller  * input:                     Adapter soft state  *                            Shutdown/Hibernate  *  * This function issues a DCMD internal command to Firmware to initiate  * shutdown of the controller.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_shutdown_ctlr
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|opcode
parameter_list|)
block|{
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mrsas_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|adprecovery
operator|==
name|MRSAS_HW_CRITICAL_ERROR
condition|)
return|return;
name|cmd
operator|=
name|mrsas_get_mfi_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate for shutdown cmd.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|aen_cmd
condition|)
name|mrsas_issue_blocked_abort_cmd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|aen_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|map_update_cmd
condition|)
name|mrsas_issue_blocked_abort_cmd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|map_update_cmd
argument_list|)
expr_stmt|;
name|dcmd
operator|=
operator|&
name|cmd
operator|->
name|frame
operator|->
name|dcmd
expr_stmt|;
name|memset
argument_list|(
name|dcmd
operator|->
name|mbox
operator|.
name|b
argument_list|,
literal|0
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|cmd_status
operator|=
literal|0x0
expr_stmt|;
name|dcmd
operator|->
name|sge_count
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|flags
operator|=
name|MFI_FRAME_DIR_NONE
expr_stmt|;
name|dcmd
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|pad_0
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|data_xfer_len
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Preparing to shut down controller.\n"
argument_list|)
expr_stmt|;
name|mrsas_issue_blocked_cmd
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * mrsas_flush_cache:         Requests FW to flush all its caches   * input:                     Adapter soft state  *  * This function is issues a DCMD internal command to Firmware to initiate  * flushing of all caches.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_flush_cache
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mrsas_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|adprecovery
operator|==
name|MRSAS_HW_CRITICAL_ERROR
condition|)
return|return;
name|cmd
operator|=
name|mrsas_get_mfi_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate for flush cache cmd.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dcmd
operator|=
operator|&
name|cmd
operator|->
name|frame
operator|->
name|dcmd
expr_stmt|;
name|memset
argument_list|(
name|dcmd
operator|->
name|mbox
operator|.
name|b
argument_list|,
literal|0
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|cmd_status
operator|=
literal|0x0
expr_stmt|;
name|dcmd
operator|->
name|sge_count
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|flags
operator|=
name|MFI_FRAME_DIR_NONE
expr_stmt|;
name|dcmd
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|pad_0
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|data_xfer_len
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MR_DCMD_CTRL_CACHE_FLUSH
expr_stmt|;
name|dcmd
operator|->
name|mbox
operator|.
name|b
index|[
literal|0
index|]
operator|=
name|MR_FLUSH_CTRL_CACHE
operator||
name|MR_FLUSH_DISK_CACHE
expr_stmt|;
name|mrsas_issue_blocked_cmd
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * mrsas_get_map_info:        Load and validate RAID map   * input:                     Adapter instance soft state  *  * This function calls mrsas_get_ld_map_info() and MR_ValidateMapInfo()  * to load and validate RAID map.  It returns 0 if successful, 1 other-  * wise.   */
end_comment

begin_function
specifier|static
name|int
name|mrsas_get_map_info
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|retcode
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|fast_path_io
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mrsas_get_ld_map_info
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|retcode
operator|=
name|MR_ValidateMapInfo
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|fast_path_io
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_get_ld_map_info:      Get FW's ld_map structure  * input:                      Adapter instance soft state  *  * Issues an internal command (DCMD) to get the FW's controller PD  * list structure.    */
end_comment

begin_function
specifier|static
name|int
name|mrsas_get_ld_map_info
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mrsas_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|void
modifier|*
name|map
decl_stmt|;
name|bus_addr_t
name|map_phys_addr
init|=
literal|0
decl_stmt|;
name|cmd
operator|=
name|mrsas_get_mfi_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc for ld map info cmd.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|dcmd
operator|=
operator|&
name|cmd
operator|->
name|frame
operator|->
name|dcmd
expr_stmt|;
name|map
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|raidmap_mem
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
expr_stmt|;
name|map_phys_addr
operator|=
name|sc
operator|->
name|raidmap_phys_addr
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|map
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Failed to alloc mem for ld map info.\n"
argument_list|)
expr_stmt|;
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|max_map_sz
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dcmd
operator|->
name|mbox
operator|.
name|b
argument_list|,
literal|0
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|cmd_status
operator|=
literal|0xFF
expr_stmt|;
name|dcmd
operator|->
name|sge_count
operator|=
literal|1
expr_stmt|;
name|dcmd
operator|->
name|flags
operator|=
name|MFI_FRAME_DIR_READ
expr_stmt|;
name|dcmd
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|pad_0
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|data_xfer_len
operator|=
name|sc
operator|->
name|current_map_sz
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MR_DCMD_LD_MAP_GET_INFO
expr_stmt|;
name|dcmd
operator|->
name|sgl
operator|.
name|sge32
index|[
literal|0
index|]
operator|.
name|phys_addr
operator|=
name|map_phys_addr
expr_stmt|;
name|dcmd
operator|->
name|sgl
operator|.
name|sge32
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|sc
operator|->
name|current_map_sz
expr_stmt|;
if|if
condition|(
operator|!
name|mrsas_issue_polled
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
condition|)
name|retcode
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Fail to send get LD map info cmd.\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
block|}
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_sync_map_info:        Get FW's ld_map structure  * input:                      Adapter instance soft state  *  * Issues an internal command (DCMD) to get the FW's controller PD  * list structure.    */
end_comment

begin_function
specifier|static
name|int
name|mrsas_sync_map_info
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|retcode
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mrsas_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|uint32_t
name|size_sync_info
decl_stmt|,
name|num_lds
decl_stmt|;
name|MR_LD_TARGET_SYNC
modifier|*
name|target_map
init|=
name|NULL
decl_stmt|;
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
decl_stmt|;
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
name|MR_LD_TARGET_SYNC
modifier|*
name|ld_sync
decl_stmt|;
name|bus_addr_t
name|map_phys_addr
init|=
literal|0
decl_stmt|;
name|cmd
operator|=
name|mrsas_get_mfi_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc for sync map info cmd\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|map
operator|=
name|sc
operator|->
name|ld_drv_map
index|[
name|sc
operator|->
name|map_id
operator|&
literal|1
index|]
expr_stmt|;
name|num_lds
operator|=
name|map
operator|->
name|raidMap
operator|.
name|ldCount
expr_stmt|;
name|dcmd
operator|=
operator|&
name|cmd
operator|->
name|frame
operator|->
name|dcmd
expr_stmt|;
name|size_sync_info
operator|=
sizeof|sizeof
argument_list|(
name|MR_LD_TARGET_SYNC
argument_list|)
operator|*
name|num_lds
expr_stmt|;
name|memset
argument_list|(
name|dcmd
operator|->
name|mbox
operator|.
name|b
argument_list|,
literal|0
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|target_map
operator|=
operator|(
name|MR_LD_TARGET_SYNC
operator|*
operator|)
name|sc
operator|->
name|raidmap_mem
index|[
operator|(
name|sc
operator|->
name|map_id
operator|-
literal|1
operator|)
operator|&
literal|1
index|]
expr_stmt|;
name|memset
argument_list|(
name|target_map
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|max_map_sz
argument_list|)
expr_stmt|;
name|map_phys_addr
operator|=
name|sc
operator|->
name|raidmap_phys_addr
index|[
operator|(
name|sc
operator|->
name|map_id
operator|-
literal|1
operator|)
operator|&
literal|1
index|]
expr_stmt|;
name|ld_sync
operator|=
operator|(
name|MR_LD_TARGET_SYNC
operator|*
operator|)
name|target_map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_lds
condition|;
name|i
operator|++
operator|,
name|ld_sync
operator|++
control|)
block|{
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|i
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|ld_sync
operator|->
name|targetId
operator|=
name|MR_GetLDTgtId
argument_list|(
name|i
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|ld_sync
operator|->
name|seqNum
operator|=
name|raid
operator|->
name|seqNum
expr_stmt|;
block|}
name|dcmd
operator|->
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|cmd_status
operator|=
literal|0xFF
expr_stmt|;
name|dcmd
operator|->
name|sge_count
operator|=
literal|1
expr_stmt|;
name|dcmd
operator|->
name|flags
operator|=
name|MFI_FRAME_DIR_WRITE
expr_stmt|;
name|dcmd
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|pad_0
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|data_xfer_len
operator|=
name|sc
operator|->
name|current_map_sz
expr_stmt|;
name|dcmd
operator|->
name|mbox
operator|.
name|b
index|[
literal|0
index|]
operator|=
name|num_lds
expr_stmt|;
name|dcmd
operator|->
name|mbox
operator|.
name|b
index|[
literal|1
index|]
operator|=
name|MRSAS_DCMD_MBOX_PEND_FLAG
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MR_DCMD_LD_MAP_GET_INFO
expr_stmt|;
name|dcmd
operator|->
name|sgl
operator|.
name|sge32
index|[
literal|0
index|]
operator|.
name|phys_addr
operator|=
name|map_phys_addr
expr_stmt|;
name|dcmd
operator|->
name|sgl
operator|.
name|sge32
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|sc
operator|->
name|current_map_sz
expr_stmt|;
name|sc
operator|->
name|map_update_cmd
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|mrsas_issue_dcmd
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Fail to send sync map info command.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_get_pd_list:           Returns FW's PD list structure  * input:                       Adapter soft state  *  * Issues an internal command (DCMD) to get the FW's controller PD  * list structure.  This information is mainly used to find out about   * system supported by Firmware.  */
end_comment

begin_function
specifier|static
name|int
name|mrsas_get_pd_list
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|retcode
init|=
literal|0
decl_stmt|,
name|pd_index
init|=
literal|0
decl_stmt|,
name|pd_count
init|=
literal|0
decl_stmt|,
name|pd_list_size
decl_stmt|;
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mrsas_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|struct
name|MR_PD_LIST
modifier|*
name|pd_list_mem
decl_stmt|;
name|struct
name|MR_PD_ADDRESS
modifier|*
name|pd_addr
decl_stmt|;
name|bus_addr_t
name|pd_list_phys_addr
init|=
literal|0
decl_stmt|;
name|struct
name|mrsas_tmp_dcmd
modifier|*
name|tcmd
decl_stmt|;
name|cmd
operator|=
name|mrsas_get_mfi_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc for get PD list cmd\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|dcmd
operator|=
operator|&
name|cmd
operator|->
name|frame
operator|->
name|dcmd
expr_stmt|;
name|tcmd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_tmp_dcmd
argument_list|)
argument_list|,
name|M_MRSAS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|pd_list_size
operator|=
name|MRSAS_MAX_PD
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|MR_PD_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrsas_alloc_tmp_dcmd
argument_list|(
name|sc
argument_list|,
name|tcmd
argument_list|,
name|pd_list_size
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc dmamap for get PD list cmd\n"
argument_list|)
expr_stmt|;
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
else|else
block|{
name|pd_list_mem
operator|=
name|tcmd
operator|->
name|tmp_dcmd_mem
expr_stmt|;
name|pd_list_phys_addr
operator|=
name|tcmd
operator|->
name|tmp_dcmd_phys_addr
expr_stmt|;
block|}
name|memset
argument_list|(
name|dcmd
operator|->
name|mbox
operator|.
name|b
argument_list|,
literal|0
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|mbox
operator|.
name|b
index|[
literal|0
index|]
operator|=
name|MR_PD_QUERY_TYPE_EXPOSED_TO_HOST
expr_stmt|;
name|dcmd
operator|->
name|mbox
operator|.
name|b
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|cmd_status
operator|=
literal|0xFF
expr_stmt|;
name|dcmd
operator|->
name|sge_count
operator|=
literal|1
expr_stmt|;
name|dcmd
operator|->
name|flags
operator|=
name|MFI_FRAME_DIR_READ
expr_stmt|;
name|dcmd
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|pad_0
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|data_xfer_len
operator|=
name|MRSAS_MAX_PD
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|MR_PD_LIST
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MR_DCMD_PD_LIST_QUERY
expr_stmt|;
name|dcmd
operator|->
name|sgl
operator|.
name|sge32
index|[
literal|0
index|]
operator|.
name|phys_addr
operator|=
name|pd_list_phys_addr
expr_stmt|;
name|dcmd
operator|->
name|sgl
operator|.
name|sge32
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|MRSAS_MAX_PD
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|MR_PD_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mrsas_issue_polled
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
condition|)
name|retcode
operator|=
literal|0
expr_stmt|;
else|else
name|retcode
operator|=
literal|1
expr_stmt|;
comment|/* Get the instance PD list */
name|pd_count
operator|=
name|MRSAS_MAX_PD
expr_stmt|;
name|pd_addr
operator|=
name|pd_list_mem
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
literal|0
operator|&&
name|pd_list_mem
operator|->
name|count
operator|<
name|pd_count
condition|)
block|{
name|memset
argument_list|(
name|sc
operator|->
name|local_pd_list
argument_list|,
literal|0
argument_list|,
name|MRSAS_MAX_PD
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_pd_list
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pd_index
operator|=
literal|0
init|;
name|pd_index
operator|<
name|pd_list_mem
operator|->
name|count
condition|;
name|pd_index
operator|++
control|)
block|{
name|sc
operator|->
name|local_pd_list
index|[
name|pd_addr
operator|->
name|deviceId
index|]
operator|.
name|tid
operator|=
name|pd_addr
operator|->
name|deviceId
expr_stmt|;
name|sc
operator|->
name|local_pd_list
index|[
name|pd_addr
operator|->
name|deviceId
index|]
operator|.
name|driveType
operator|=
name|pd_addr
operator|->
name|scsiDevType
expr_stmt|;
name|sc
operator|->
name|local_pd_list
index|[
name|pd_addr
operator|->
name|deviceId
index|]
operator|.
name|driveState
operator|=
name|MR_PD_STATE_SYSTEM
expr_stmt|;
name|pd_addr
operator|++
expr_stmt|;
block|}
block|}
comment|/* Use mutext/spinlock if pd_list component size increase more than 32 bit. */
name|memcpy
argument_list|(
name|sc
operator|->
name|pd_list
argument_list|,
name|sc
operator|->
name|local_pd_list
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|local_pd_list
argument_list|)
argument_list|)
expr_stmt|;
name|mrsas_free_tmp_dcmd
argument_list|(
name|tcmd
argument_list|)
expr_stmt|;
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tcmd
argument_list|,
name|M_MRSAS
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_get_ld_list:           Returns FW's LD list structure  * input:                       Adapter soft state  *  * Issues an internal command (DCMD) to get the FW's controller PD  * list structure.  This information is mainly used to find out about  * supported by the FW.  */
end_comment

begin_function
specifier|static
name|int
name|mrsas_get_ld_list
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ld_list_size
decl_stmt|,
name|retcode
init|=
literal|0
decl_stmt|,
name|ld_index
init|=
literal|0
decl_stmt|,
name|ids
init|=
literal|0
decl_stmt|;
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mrsas_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|struct
name|MR_LD_LIST
modifier|*
name|ld_list_mem
decl_stmt|;
name|bus_addr_t
name|ld_list_phys_addr
init|=
literal|0
decl_stmt|;
name|struct
name|mrsas_tmp_dcmd
modifier|*
name|tcmd
decl_stmt|;
name|cmd
operator|=
name|mrsas_get_mfi_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc for get LD list cmd\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|dcmd
operator|=
operator|&
name|cmd
operator|->
name|frame
operator|->
name|dcmd
expr_stmt|;
name|tcmd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_tmp_dcmd
argument_list|)
argument_list|,
name|M_MRSAS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|ld_list_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|MR_LD_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrsas_alloc_tmp_dcmd
argument_list|(
name|sc
argument_list|,
name|tcmd
argument_list|,
name|ld_list_size
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc dmamap for get LD list cmd\n"
argument_list|)
expr_stmt|;
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
else|else
block|{
name|ld_list_mem
operator|=
name|tcmd
operator|->
name|tmp_dcmd_mem
expr_stmt|;
name|ld_list_phys_addr
operator|=
name|tcmd
operator|->
name|tmp_dcmd_phys_addr
expr_stmt|;
block|}
name|memset
argument_list|(
name|dcmd
operator|->
name|mbox
operator|.
name|b
argument_list|,
literal|0
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|max256vdSupport
condition|)
name|dcmd
operator|->
name|mbox
operator|.
name|b
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|dcmd
operator|->
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|cmd_status
operator|=
literal|0xFF
expr_stmt|;
name|dcmd
operator|->
name|sge_count
operator|=
literal|1
expr_stmt|;
name|dcmd
operator|->
name|flags
operator|=
name|MFI_FRAME_DIR_READ
expr_stmt|;
name|dcmd
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|data_xfer_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|MR_LD_LIST
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MR_DCMD_LD_GET_LIST
expr_stmt|;
name|dcmd
operator|->
name|sgl
operator|.
name|sge32
index|[
literal|0
index|]
operator|.
name|phys_addr
operator|=
name|ld_list_phys_addr
expr_stmt|;
name|dcmd
operator|->
name|sgl
operator|.
name|sge32
index|[
literal|0
index|]
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|MR_LD_LIST
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|pad_0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mrsas_issue_polled
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
condition|)
name|retcode
operator|=
literal|0
expr_stmt|;
else|else
name|retcode
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|VD_EXT_DEBUG
name|printf
argument_list|(
literal|"Number of LDs %d\n"
argument_list|,
name|ld_list_mem
operator|->
name|ldCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Get the instance LD list */
if|if
condition|(
operator|(
name|retcode
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ld_list_mem
operator|->
name|ldCount
operator|<=
name|sc
operator|->
name|fw_supported_vd_count
operator|)
condition|)
block|{
name|sc
operator|->
name|CurLdCount
operator|=
name|ld_list_mem
operator|->
name|ldCount
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|ld_ids
argument_list|,
literal|0xff
argument_list|,
name|MAX_LOGICAL_DRIVES_EXT
argument_list|)
expr_stmt|;
for|for
control|(
name|ld_index
operator|=
literal|0
init|;
name|ld_index
operator|<
name|ld_list_mem
operator|->
name|ldCount
condition|;
name|ld_index
operator|++
control|)
block|{
if|if
condition|(
name|ld_list_mem
operator|->
name|ldList
index|[
name|ld_index
index|]
operator|.
name|state
operator|!=
literal|0
condition|)
block|{
name|ids
operator|=
name|ld_list_mem
operator|->
name|ldList
index|[
name|ld_index
index|]
operator|.
name|ref
operator|.
name|ld_context
operator|.
name|targetId
expr_stmt|;
name|sc
operator|->
name|ld_ids
index|[
name|ids
index|]
operator|=
name|ld_list_mem
operator|->
name|ldList
index|[
name|ld_index
index|]
operator|.
name|ref
operator|.
name|ld_context
operator|.
name|targetId
expr_stmt|;
block|}
block|}
block|}
name|mrsas_free_tmp_dcmd
argument_list|(
name|tcmd
argument_list|)
expr_stmt|;
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tcmd
argument_list|,
name|M_MRSAS
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_alloc_tmp_dcmd:       Allocates memory for temporary command  * input:                      Adapter soft state  *                             Temp command  *                             Size of alloction  *  * Allocates DMAable memory for a temporary internal command. The allocated  * memory is initialized to all zeros upon successful loading of the dma   * mapped memory.  */
end_comment

begin_function
name|int
name|mrsas_alloc_tmp_dcmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_tmp_dcmd
modifier|*
name|tcmd
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
comment|// parent
literal|1
argument_list|,
literal|0
argument_list|,
comment|// algnmnt, boundary
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// filter, filterarg
name|size
argument_list|,
comment|// maxsize
literal|1
argument_list|,
comment|// msegments
name|size
argument_list|,
comment|// maxsegsize
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|// flags
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|// lockfunc, lockarg
operator|&
name|tcmd
operator|->
name|tmp_dcmd_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate tmp dcmd tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|tcmd
operator|->
name|tmp_dcmd_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|tcmd
operator|->
name|tmp_dcmd_mem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|tcmd
operator|->
name|tmp_dcmd_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate tmp dcmd mem\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|tcmd
operator|->
name|tmp_dcmd_tag
argument_list|,
name|tcmd
operator|->
name|tmp_dcmd_dmamap
argument_list|,
name|tcmd
operator|->
name|tmp_dcmd_mem
argument_list|,
name|size
argument_list|,
name|mrsas_addr_cb
argument_list|,
operator|&
name|tcmd
operator|->
name|tmp_dcmd_phys_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot load tmp dcmd mem\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|tcmd
operator|->
name|tmp_dcmd_mem
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_free_tmp_dcmd:      Free memory for temporary command   * input:                    temporary dcmd pointer   *  * Deallocates memory of the temporary command for use in the construction  * of the internal DCMD.  */
end_comment

begin_function
name|void
name|mrsas_free_tmp_dcmd
parameter_list|(
name|struct
name|mrsas_tmp_dcmd
modifier|*
name|tmp
parameter_list|)
block|{
if|if
condition|(
name|tmp
operator|->
name|tmp_dcmd_phys_addr
condition|)
name|bus_dmamap_unload
argument_list|(
name|tmp
operator|->
name|tmp_dcmd_tag
argument_list|,
name|tmp
operator|->
name|tmp_dcmd_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|tmp_dcmd_mem
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|tmp
operator|->
name|tmp_dcmd_tag
argument_list|,
name|tmp
operator|->
name|tmp_dcmd_mem
argument_list|,
name|tmp
operator|->
name|tmp_dcmd_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|tmp_dcmd_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|tmp
operator|->
name|tmp_dcmd_tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_issue_blocked_abort_cmd:       Aborts previously issued cmd  * input:                               Adapter soft state  *                                      Previously issued cmd to be aborted  *  * This function is used to abort previously issued commands, such as AEN and   * RAID map sync map commands.  The abort command is sent as a DCMD internal   * command and subsequently the driver will wait for a return status.  The   * max wait time is MRSAS_INTERNAL_CMD_WAIT_TIME seconds.   */
end_comment

begin_function
specifier|static
name|int
name|mrsas_issue_blocked_abort_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd_to_abort
parameter_list|)
block|{
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mrsas_abort_frame
modifier|*
name|abort_fr
decl_stmt|;
name|u_int8_t
name|retcode
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|total_time
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|max_wait
init|=
name|MRSAS_INTERNAL_CMD_WAIT_TIME
decl_stmt|;
name|cmd
operator|=
name|mrsas_get_mfi_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc for abort cmd\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|abort_fr
operator|=
operator|&
name|cmd
operator|->
name|frame
operator|->
name|abort
expr_stmt|;
comment|/* Prepare and issue the abort frame */
name|abort_fr
operator|->
name|cmd
operator|=
name|MFI_CMD_ABORT
expr_stmt|;
name|abort_fr
operator|->
name|cmd_status
operator|=
literal|0xFF
expr_stmt|;
name|abort_fr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|abort_fr
operator|->
name|abort_context
operator|=
name|cmd_to_abort
operator|->
name|index
expr_stmt|;
name|abort_fr
operator|->
name|abort_mfi_phys_addr_lo
operator|=
name|cmd_to_abort
operator|->
name|frame_phys_addr
expr_stmt|;
name|abort_fr
operator|->
name|abort_mfi_phys_addr_hi
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|sync_cmd
operator|=
literal|1
expr_stmt|;
name|cmd
operator|->
name|cmd_status
operator|=
literal|0xFF
expr_stmt|;
if|if
condition|(
name|mrsas_issue_dcmd
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Fail to send abort command.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Wait for this cmd to complete */
name|sc
operator|->
name|chan
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|cmd
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|cmd_status
operator|==
literal|0xFF
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|chan
argument_list|,
literal|0
argument_list|,
literal|"mrsas_sleep"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
name|total_time
operator|++
expr_stmt|;
if|if
condition|(
name|total_time
operator|>=
name|max_wait
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Abort cmd timed out after %d sec.\n"
argument_list|,
name|max_wait
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|cmd
operator|->
name|sync_cmd
operator|=
literal|0
expr_stmt|;
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_complete_abort:      Completes aborting a command  * input:                     Adapter soft state  *                            Cmd that was issued to abort another cmd  *  * The mrsas_issue_blocked_abort_cmd() function waits for the command status  * to change after sending the command.  This function is called from   * mrsas_complete_mptmfi_passthru() to wake up the sleep thread associated.  */
end_comment

begin_function
name|void
name|mrsas_complete_abort
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|->
name|sync_cmd
condition|)
block|{
name|cmd
operator|->
name|sync_cmd
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|cmd_status
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|chan
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|cmd
expr_stmt|;
name|wakeup_one
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|chan
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * mrsas_aen_handler:		Callback function for AEN processing from thread context.  * input:					Adapter soft state  *  */
end_comment

begin_function
name|void
name|mrsas_aen_handler
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|union
name|mrsas_evt_class_locale
name|class_locale
decl_stmt|;
name|int
name|doscan
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|seq_num
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"invalid instance!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|evt_detail_mem
condition|)
block|{
switch|switch
condition|(
name|sc
operator|->
name|evt_detail_mem
operator|->
name|code
condition|)
block|{
case|case
name|MR_EVT_PD_INSERTED
case|:
name|mrsas_get_pd_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_bus_scan_sim
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sim_1
argument_list|)
expr_stmt|;
name|doscan
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MR_EVT_PD_REMOVED
case|:
name|mrsas_get_pd_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_bus_scan_sim
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sim_1
argument_list|)
expr_stmt|;
name|doscan
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MR_EVT_LD_OFFLINE
case|:
case|case
name|MR_EVT_CFG_CLEARED
case|:
case|case
name|MR_EVT_LD_DELETED
case|:
name|mrsas_bus_scan_sim
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sim_0
argument_list|)
expr_stmt|;
name|doscan
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MR_EVT_LD_CREATED
case|:
name|mrsas_get_ld_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_bus_scan_sim
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sim_0
argument_list|)
expr_stmt|;
name|doscan
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MR_EVT_CTRL_HOST_BUS_SCAN_REQUESTED
case|:
case|case
name|MR_EVT_FOREIGN_CFG_IMPORTED
case|:
case|case
name|MR_EVT_LD_STATE_CHANGE
case|:
name|doscan
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|doscan
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"invalid evt_detail\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|doscan
condition|)
block|{
name|mrsas_get_pd_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_AEN
argument_list|,
literal|"scanning ...sim 1\n"
argument_list|)
expr_stmt|;
name|mrsas_bus_scan_sim
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sim_1
argument_list|)
expr_stmt|;
name|mrsas_get_ld_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_AEN
argument_list|,
literal|"scanning ...sim 0\n"
argument_list|)
expr_stmt|;
name|mrsas_bus_scan_sim
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sim_0
argument_list|)
expr_stmt|;
block|}
name|seq_num
operator|=
name|sc
operator|->
name|evt_detail_mem
operator|->
name|seq_num
operator|+
literal|1
expr_stmt|;
comment|// Register AEN with FW for latest sequence number plus 1
name|class_locale
operator|.
name|members
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|locale
operator|=
name|MR_EVT_LOCALE_ALL
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|class
operator|=
name|MR_EVT_CLASS_DEBUG
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aen_cmd
operator|!=
name|NULL
condition|)
return|return ;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aen_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|mrsas_register_aen
argument_list|(
name|sc
argument_list|,
name|seq_num
argument_list|,
name|class_locale
operator|.
name|word
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aen_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"register aen failed error %x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mrsas_complete_aen:        	Completes AEN command  * input:                     	Adapter soft state  *                            	Cmd that was issued to abort another cmd  *  * 								This function will be called from ISR and will continue   * 								event processing from thread context by enqueuing task  * 								in ev_tq (callback function "mrsas_aen_handler").  */
end_comment

begin_function
name|void
name|mrsas_complete_aen
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
block|{
comment|/* 	* Don't signal app if it is just an aborted previously registered aen 	*/
if|if
condition|(
operator|(
operator|!
name|cmd
operator|->
name|abort_aen
operator|)
operator|&&
operator|(
name|sc
operator|->
name|remove_in_progress
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* TO DO (?) */
block|}
else|else
name|cmd
operator|->
name|abort_aen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|aen_cmd
operator|=
name|NULL
expr_stmt|;
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|remove_in_progress
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|ev_tq
argument_list|,
operator|&
name|sc
operator|->
name|ev_task
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|mrsas_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|mrsas_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|mrsas_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|mrsas_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|mrsas_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|mrsas_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|mrsas_driver
init|=
block|{
literal|"mrsas"
block|,
name|mrsas_methods
block|,
expr|sizeof
operator|(
expr|struct
name|mrsas_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|mrsas_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|mrsas
argument_list|,
name|pci
argument_list|,
name|mrsas_driver
argument_list|,
name|mrsas_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|mrsas
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

