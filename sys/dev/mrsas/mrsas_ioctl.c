begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2014, LSI Corp. All rights reserved. Author: Marian Choy  * Support: freebsdraid@lsi.com  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  * 1. Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer. 2. Redistributions  * in binary form must reproduce the above copyright notice, this list of  * conditions and the following disclaimer in the documentation and/or other  * materials provided with the distribution. 3. Neither the name of the  *<ORGANIZATION> nor the names of its contributors may be used to endorse or  * promote products derived from this software without specific prior written  * permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing  * official policies,either expressed or implied, of the FreeBSD Project.  *  * Send feedback to:<megaraidfbsd@lsi.com> Mail to: LSI Corporation, 1621  * Barber Lane, Milpitas, CA 95035 ATTN: MegaRaid FreeBSD  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/mrsas/mrsas.h>
end_include

begin_include
include|#
directive|include
file|<dev/mrsas/mrsas_ioctl.h>
end_include

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
name|int
name|mrsas_alloc_mfi_cmds
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mrsas_passthru
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|u_long
name|ioctlCmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_free_ioc_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_free_frame
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|mrsas_alloc_frame
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mrsas_create_frame_pool
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrsas_alloc_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|mrsas_mfi_cmd
modifier|*
name|mrsas_get_mfi_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mrsas_release_mfi_cmd
parameter_list|(
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|mrsas_issue_blocked_cmd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * mrsas_passthru:	Handle pass-through commands  * input:			Adapter instance soft state argument pointer  *  * This function is called from mrsas_ioctl() to handle pass-through and ioctl  * commands to Firmware.  */
end_comment

begin_function
name|int
name|mrsas_passthru
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|u_long
name|ioctlCmd
parameter_list|)
block|{
name|struct
name|mrsas_iocpacket
modifier|*
name|user_ioc
init|=
operator|(
expr|struct
name|mrsas_iocpacket
operator|*
operator|)
name|arg
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
name|struct
name|mrsas_iocpacket32
modifier|*
name|user_ioc32
init|=
operator|(
expr|struct
name|mrsas_iocpacket32
operator|*
operator|)
name|arg
decl_stmt|;
endif|#
directive|endif
name|union
name|mrsas_frame
modifier|*
name|in_cmd
init|=
operator|(
expr|union
name|mrsas_frame
operator|*
operator|)
operator|&
operator|(
name|user_ioc
operator|->
name|frame
operator|.
name|raw
operator|)
decl_stmt|;
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
init|=
name|NULL
decl_stmt|;
name|bus_dma_tag_t
name|ioctl_data_tag
index|[
name|MAX_IOCTL_SGE
index|]
decl_stmt|;
name|bus_dmamap_t
name|ioctl_data_dmamap
index|[
name|MAX_IOCTL_SGE
index|]
decl_stmt|;
name|void
modifier|*
name|ioctl_data_mem
index|[
name|MAX_IOCTL_SGE
index|]
decl_stmt|;
name|bus_addr_t
name|ioctl_data_phys_addr
index|[
name|MAX_IOCTL_SGE
index|]
decl_stmt|;
name|bus_dma_tag_t
name|ioctl_sense_tag
init|=
literal|0
decl_stmt|;
name|bus_dmamap_t
name|ioctl_sense_dmamap
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|ioctl_sense_mem
init|=
literal|0
decl_stmt|;
name|bus_addr_t
name|ioctl_sense_phys_addr
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ioctl_data_size
init|=
literal|0
decl_stmt|,
name|ioctl_sense_size
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|mrsas_sge32
modifier|*
name|kern_sge32
decl_stmt|;
name|unsigned
name|long
modifier|*
name|sense_ptr
decl_stmt|;
name|uint8_t
modifier|*
name|iov_base_ptrin
init|=
name|NULL
decl_stmt|;
name|size_t
name|iov_len
init|=
literal|0
decl_stmt|;
comment|/* 	 * Check for NOP from MegaCli... MegaCli can issue a DCMD of 0.  In 	 * this case do nothing and return 0 to it as status. 	 */
if|if
condition|(
name|in_cmd
operator|->
name|dcmd
operator|.
name|opcode
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"In %s() Got a NOP\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|user_ioc
operator|->
name|frame
operator|.
name|hdr
operator|.
name|cmd_status
operator|=
name|MFI_STAT_OK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Validate SGL length */
if|if
condition|(
name|user_ioc
operator|->
name|sge_count
operator|>
name|MAX_IOCTL_SGE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"In %s() SGL is too long (%d> 8).\n"
argument_list|,
name|__func__
argument_list|,
name|user_ioc
operator|->
name|sge_count
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Get a command */
name|cmd
operator|=
name|mrsas_get_mfi_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Failed to get a free cmd for IOCTL\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * User's IOCTL packet has 2 frames (maximum). Copy those two frames 	 * into our cmd's frames. cmd->frame's context will get overwritten 	 * when we copy from user's frames. So set that value alone 	 * separately 	 */
name|memcpy
argument_list|(
name|cmd
operator|->
name|frame
argument_list|,
name|user_ioc
operator|->
name|frame
operator|.
name|raw
argument_list|,
literal|2
operator|*
name|MEGAMFI_FRAME_SIZE
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|frame
operator|->
name|hdr
operator|.
name|context
operator|=
name|cmd
operator|->
name|index
expr_stmt|;
name|cmd
operator|->
name|frame
operator|->
name|hdr
operator|.
name|pad_0
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|frame
operator|->
name|hdr
operator|.
name|flags
operator|&=
operator|~
operator|(
name|MFI_FRAME_IEEE
operator||
name|MFI_FRAME_SGL64
operator||
name|MFI_FRAME_SENSE64
operator|)
expr_stmt|;
comment|/* 	 * The management interface between applications and the fw uses MFI 	 * frames. E.g, RAID configuration changes, LD property changes etc 	 * are accomplishes through different kinds of MFI frames. The driver 	 * needs to care only about substituting user buffers with kernel 	 * buffers in SGLs. The location of SGL is embedded in the struct 	 * iocpacket itself. 	 */
name|kern_sge32
operator|=
operator|(
expr|struct
name|mrsas_sge32
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|cmd
operator|->
name|frame
operator|+
name|user_ioc
operator|->
name|sgl_off
operator|)
expr_stmt|;
comment|/* 	 * For each user buffer, create a mirror buffer and copy in 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|user_ioc
operator|->
name|sge_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ioctlCmd
operator|==
name|MRSAS_IOC_FIRMWARE_PASS_THROUGH64
condition|)
block|{
if|if
condition|(
operator|!
name|user_ioc
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_len
condition|)
continue|continue;
name|ioctl_data_size
operator|=
name|user_ioc
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
block|}
else|else
block|{
if|if
condition|(
operator|!
name|user_ioc32
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_len
condition|)
continue|continue;
name|ioctl_data_size
operator|=
name|user_ioc32
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ioctl_data_size
argument_list|,
literal|1
argument_list|,
name|ioctl_data_size
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ioctl_data_tag
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate ioctl data tag\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|ioctl_data_tag
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ioctl_data_mem
index|[
name|i
index|]
argument_list|,
operator|(
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator|)
argument_list|,
operator|&
name|ioctl_data_dmamap
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate ioctl data mem\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|ioctl_data_tag
index|[
name|i
index|]
argument_list|,
name|ioctl_data_dmamap
index|[
name|i
index|]
argument_list|,
name|ioctl_data_mem
index|[
name|i
index|]
argument_list|,
name|ioctl_data_size
argument_list|,
name|mrsas_alloc_cb
argument_list|,
operator|&
name|ioctl_data_phys_addr
index|[
name|i
index|]
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot load ioctl data mem\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Save the physical address and length */
name|kern_sge32
index|[
name|i
index|]
operator|.
name|phys_addr
operator|=
operator|(
name|u_int32_t
operator|)
name|ioctl_data_phys_addr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ioctlCmd
operator|==
name|MRSAS_IOC_FIRMWARE_PASS_THROUGH64
condition|)
block|{
name|kern_sge32
index|[
name|i
index|]
operator|.
name|length
operator|=
name|user_ioc
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
name|iov_base_ptrin
operator|=
name|user_ioc
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_base
expr_stmt|;
name|iov_len
operator|=
name|user_ioc
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
block|}
else|else
block|{
name|kern_sge32
index|[
name|i
index|]
operator|.
name|length
operator|=
name|user_ioc32
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
name|iov_base_ptrin
operator|=
name|PTRIN
argument_list|(
name|user_ioc32
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|iov_len
operator|=
name|user_ioc32
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Copy in data from user space */
name|ret
operator|=
name|copyin
argument_list|(
name|iov_base_ptrin
argument_list|,
name|ioctl_data_mem
index|[
name|i
index|]
argument_list|,
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"IOCTL copyin failed!\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ioctl_sense_size
operator|=
name|user_ioc
operator|->
name|sense_len
expr_stmt|;
if|if
condition|(
name|user_ioc
operator|->
name|sense_len
condition|)
block|{
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ioctl_sense_size
argument_list|,
literal|1
argument_list|,
name|ioctl_sense_size
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ioctl_sense_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate ioctl sense tag\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|ioctl_sense_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ioctl_sense_mem
argument_list|,
operator|(
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator|)
argument_list|,
operator|&
name|ioctl_sense_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate ioctl sense mem\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|ioctl_sense_tag
argument_list|,
name|ioctl_sense_dmamap
argument_list|,
name|ioctl_sense_mem
argument_list|,
name|ioctl_sense_size
argument_list|,
name|mrsas_alloc_cb
argument_list|,
operator|&
name|ioctl_sense_phys_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot load ioctl sense mem\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sense_ptr
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|cmd
operator|->
name|frame
operator|+
name|user_ioc
operator|->
name|sense_off
operator|)
expr_stmt|;
name|sense_ptr
operator|=
name|ioctl_sense_mem
expr_stmt|;
block|}
comment|/* 	 * Set the sync_cmd flag so that the ISR knows not to complete this 	 * cmd to the SCSI mid-layer 	 */
name|cmd
operator|->
name|sync_cmd
operator|=
literal|1
expr_stmt|;
name|mrsas_issue_blocked_cmd
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|sync_cmd
operator|=
literal|0
expr_stmt|;
comment|/* 	 * copy out the kernel buffers to user buffers 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|user_ioc
operator|->
name|sge_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ioctlCmd
operator|==
name|MRSAS_IOC_FIRMWARE_PASS_THROUGH64
condition|)
block|{
name|iov_base_ptrin
operator|=
name|user_ioc
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_base
expr_stmt|;
name|iov_len
operator|=
name|user_ioc
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
block|}
else|else
block|{
name|iov_base_ptrin
operator|=
name|PTRIN
argument_list|(
name|user_ioc32
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|iov_len
operator|=
name|user_ioc32
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
endif|#
directive|endif
block|}
name|ret
operator|=
name|copyout
argument_list|(
name|ioctl_data_mem
index|[
name|i
index|]
argument_list|,
name|iov_base_ptrin
argument_list|,
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"IOCTL copyout failed!\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * copy out the sense 	 */
if|if
condition|(
name|user_ioc
operator|->
name|sense_len
condition|)
block|{
comment|/* 		 * sense_buff points to the location that has the user sense 		 * buffer address 		 */
name|sense_ptr
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|user_ioc
operator|->
name|frame
operator|.
name|raw
operator|+
name|user_ioc
operator|->
name|sense_off
operator|)
expr_stmt|;
name|ret
operator|=
name|copyout
argument_list|(
name|ioctl_sense_mem
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|*
name|sense_ptr
argument_list|,
name|user_ioc
operator|->
name|sense_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"IOCTL sense copyout failed!\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Return command status to user space 	 */
name|memcpy
argument_list|(
operator|&
name|user_ioc
operator|->
name|frame
operator|.
name|hdr
operator|.
name|cmd_status
argument_list|,
operator|&
name|cmd
operator|->
name|frame
operator|->
name|hdr
operator|.
name|cmd_status
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* 	 * Release sense buffer 	 */
if|if
condition|(
name|ioctl_sense_phys_addr
condition|)
name|bus_dmamap_unload
argument_list|(
name|ioctl_sense_tag
argument_list|,
name|ioctl_sense_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl_sense_mem
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|ioctl_sense_tag
argument_list|,
name|ioctl_sense_mem
argument_list|,
name|ioctl_sense_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl_sense_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|ioctl_sense_tag
argument_list|)
expr_stmt|;
comment|/* 	 * Release data buffers 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|user_ioc
operator|->
name|sge_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ioctlCmd
operator|==
name|MRSAS_IOC_FIRMWARE_PASS_THROUGH64
condition|)
block|{
if|if
condition|(
operator|!
name|user_ioc
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_len
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
block|}
else|else
block|{
if|if
condition|(
operator|!
name|user_ioc32
operator|->
name|sgl
index|[
name|i
index|]
operator|.
name|iov_len
condition|)
continue|continue;
endif|#
directive|endif
block|}
if|if
condition|(
name|ioctl_data_phys_addr
index|[
name|i
index|]
condition|)
name|bus_dmamap_unload
argument_list|(
name|ioctl_data_tag
index|[
name|i
index|]
argument_list|,
name|ioctl_data_dmamap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl_data_mem
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|ioctl_data_tag
index|[
name|i
index|]
argument_list|,
name|ioctl_data_mem
index|[
name|i
index|]
argument_list|,
name|ioctl_data_dmamap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl_data_tag
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|ioctl_data_tag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Free command */
name|mrsas_release_mfi_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_alloc_mfi_cmds:	Allocates the command packets  * input:					Adapter instance soft state  *  * Each IOCTL or passthru command that is issued to the FW are wrapped in a  * local data structure called mrsas_mfi_cmd.  The frame embedded in this  * mrsas_mfi is issued to FW. The array is used only to look up the  * mrsas_mfi_cmd given the context. The free commands are maintained in a  * linked list.  */
end_comment

begin_function
name|int
name|mrsas_alloc_mfi_cmds
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int32_t
name|max_cmd
decl_stmt|;
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
decl_stmt|;
name|max_cmd
operator|=
name|MRSAS_MAX_MFI_CMDS
expr_stmt|;
comment|/* 	 * sc->mfi_cmd_list is an array of struct mrsas_mfi_cmd pointers. 	 * Allocate the dynamic array first and then allocate individual 	 * commands. 	 */
name|sc
operator|->
name|mfi_cmd_list
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_mfi_cmd
operator|*
argument_list|)
operator|*
name|max_cmd
argument_list|,
name|M_MRSAS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mfi_cmd_list
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc memory for mfi_cmd cmd_list.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|sc
operator|->
name|mfi_cmd_list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_mfi_cmd
operator|*
argument_list|)
operator|*
name|max_cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_cmd
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|mfi_cmd_list
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_mfi_cmd
argument_list|)
argument_list|,
name|M_MRSAS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mfi_cmd_list
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|free
argument_list|(
name|sc
operator|->
name|mfi_cmd_list
index|[
name|j
index|]
argument_list|,
name|M_MRSAS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|mfi_cmd_list
argument_list|,
name|M_MRSAS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_cmd_list
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_cmd
condition|;
name|i
operator|++
control|)
block|{
name|cmd
operator|=
name|sc
operator|->
name|mfi_cmd_list
index|[
name|i
index|]
expr_stmt|;
name|memset
argument_list|(
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mrsas_mfi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|cmd
operator|->
name|ccb_ptr
operator|=
name|NULL
expr_stmt|;
name|cmd
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|mrsas_mfi_cmd_list_head
operator|)
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* create a frame pool and assign one frame to each command */
if|if
condition|(
name|mrsas_create_frame_pool
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot allocate DMA frame pool.\n"
argument_list|)
expr_stmt|;
comment|/* Free the frames */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MRSAS_MAX_MFI_CMDS
condition|;
name|i
operator|++
control|)
block|{
name|cmd
operator|=
name|sc
operator|->
name|mfi_cmd_list
index|[
name|i
index|]
expr_stmt|;
name|mrsas_free_frame
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mficmd_frame_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mficmd_frame_tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_create_frame_pool:	Creates DMA pool for cmd frames  * input:					Adapter soft state  *  * Each command packet has an embedded DMA memory buffer that is used for  * filling MFI frame and the SG list that immediately follows the frame. This  * function creates those DMA memory buffers for each command packet by using  * PCI pool facility. pad_0 is initialized to 0 to prevent corrupting value  * of context and could cause FW crash.  */
end_comment

begin_function
specifier|static
name|int
name|mrsas_create_frame_pool
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
decl_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mrsas_parent_tag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MRSAS_MFI_FRAME_SIZE
argument_list|,
literal|1
argument_list|,
name|MRSAS_MFI_FRAME_SIZE
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|mficmd_frame_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot create MFI frame tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MRSAS_MAX_MFI_CMDS
condition|;
name|i
operator|++
control|)
block|{
name|cmd
operator|=
name|sc
operator|->
name|mfi_cmd_list
index|[
name|i
index|]
expr_stmt|;
name|cmd
operator|->
name|frame
operator|=
name|mrsas_alloc_frame
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|frame
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc MFI frame memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|cmd
operator|->
name|frame
argument_list|,
literal|0
argument_list|,
name|MRSAS_MFI_FRAME_SIZE
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|frame
operator|->
name|io
operator|.
name|context
operator|=
name|cmd
operator|->
name|index
expr_stmt|;
name|cmd
operator|->
name|frame
operator|->
name|io
operator|.
name|pad_0
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_alloc_frame:	Allocates MFI Frames  * input:				Adapter soft state  *  * Create bus DMA memory tag and dmamap and load memory for MFI frames. Returns  * virtual memory pointer to allocated region.  */
end_comment

begin_function
name|void
modifier|*
name|mrsas_alloc_frame
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|u_int32_t
name|frame_size
init|=
name|MRSAS_MFI_FRAME_SIZE
decl_stmt|;
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mficmd_frame_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cmd
operator|->
name|frame_mem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|cmd
operator|->
name|frame_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot alloc MFI frame memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mficmd_frame_tag
argument_list|,
name|cmd
operator|->
name|frame_dmamap
argument_list|,
name|cmd
operator|->
name|frame_mem
argument_list|,
name|frame_size
argument_list|,
name|mrsas_alloc_cb
argument_list|,
operator|&
name|cmd
operator|->
name|frame_phys_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Cannot load IO request memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|cmd
operator|->
name|frame_mem
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_alloc_cb:	Callback function of bus_dmamap_load()  * input:			callback argument,  * 					machine dependent type that describes DMA segments,  * 					number of segments,  * 					error code.  *  * This function is for the driver to receive mapping information resultant of  * the bus_dmamap_load(). The information is actually not being used, but the  * address is saved anyway.  */
end_comment

begin_function
specifier|static
name|void
name|mrsas_alloc_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mrsas_free_frames:	Frees memory for  MFI frames  * input:				Adapter soft state  *  * Deallocates MFI frames memory.  Called from mrsas_free_mem() during detach  * and error case during creation of frame pool.  */
end_comment

begin_function
name|void
name|mrsas_free_frame
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mrsas_mfi_cmd
modifier|*
name|cmd
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|->
name|frame_phys_addr
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mficmd_frame_tag
argument_list|,
name|cmd
operator|->
name|frame_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|frame_mem
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mficmd_frame_tag
argument_list|,
name|cmd
operator|->
name|frame_mem
argument_list|,
name|cmd
operator|->
name|frame_dmamap
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

