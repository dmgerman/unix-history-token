begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2014, LSI Corp.  * All rights reserved.  * Author: Marian Choy  * Support: freebsdraid@lsi.com  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  * 3. Neither the name of the<ORGANIZATION> nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation  * are those of the authors and should not be interpreted as representing  * official policies,either expressed or implied, of the FreeBSD Project.  *  * Send feedback to:<megaraidfbsd@lsi.com>  * Mail to: LSI Corporation, 1621 Barber Lane, Milpitas, CA 95035  *    ATTN: MegaRaid FreeBSD  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/mrsas/mrsas.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
name|u_int8_t
name|MR_ValidateMapInfo
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int8_t
name|mrsas_get_best_arm
parameter_list|(
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|,
name|u_int8_t
name|arm
parameter_list|,
name|u_int64_t
name|block
parameter_list|,
name|u_int32_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int8_t
name|MR_BuildRaidContext
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|RAID_CONTEXT
modifier|*
name|pRAID_Context
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int8_t
name|MR_GetPhyParams
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|stripRow
parameter_list|,
name|u_int16_t
name|stripRef
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|RAID_CONTEXT
modifier|*
name|pRAID_Context
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int16_t
name|MR_TargetIdToLdGet
parameter_list|(
name|u_int32_t
name|ldTgtId
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int32_t
name|MR_LdBlockSizeGet
parameter_list|(
name|u_int32_t
name|ldTgtId
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int16_t
name|MR_GetLDTgtId
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int16_t
name|mrsas_get_updated_dev_handle
parameter_list|(
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int32_t
name|mega_mod64
parameter_list|(
name|u_int64_t
name|dividend
parameter_list|,
name|u_int32_t
name|divisor
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int32_t
name|MR_GetSpanBlock
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|row
parameter_list|,
name|u_int64_t
modifier|*
name|span_blk
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|int
modifier|*
name|div_error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int64_t
name|mega_div64_32
parameter_list|(
name|u_int64_t
name|dividend
parameter_list|,
name|u_int32_t
name|divisor
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_update_load_balance_params
parameter_list|(
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_set_pd_lba
parameter_list|(
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
parameter_list|,
name|u_int8_t
name|cdb_len
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|local_map_ptr
parameter_list|,
name|u_int32_t
name|ref_tag
parameter_list|,
name|u_int32_t
name|ld_block_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|MR_LdSpanArrayGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int32_t
name|span
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|MR_PdDevHandleGet
parameter_list|(
name|u_int32_t
name|pd
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|MR_ArPdGet
parameter_list|(
name|u_int32_t
name|ar
parameter_list|,
name|u_int32_t
name|arm
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MR_LD_SPAN
modifier|*
name|MR_LdSpanPtrGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int32_t
name|span
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|MR_LdDataArmGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int32_t
name|armIdx
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MR_SPAN_BLOCK_INFO
modifier|*
name|MR_LdSpanInfoGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|MR_LD_RAID
modifier|*
name|MR_LdRaidGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|MR_PopulateDrvRaidMap
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Spanset related function prototypes  * Added for PRL11 configuration (Uneven span support)  */
end_comment

begin_function_decl
name|void
name|mr_update_span_set
parameter_list|(
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|PLD_SPAN_INFO
name|ldSpanInfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|mr_spanset_get_phy_params
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|stripRow
parameter_list|,
name|u_int16_t
name|stripRef
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|RAID_CONTEXT
modifier|*
name|pRAID_Context
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int64_t
name|get_row_from_strip
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|strip
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|mr_spanset_get_span_block
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|row
parameter_list|,
name|u_int64_t
modifier|*
name|span_blk
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|int
modifier|*
name|div_error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|get_arm
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int8_t
name|span
parameter_list|,
name|u_int64_t
name|stripe
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Spanset related defines  * Added for PRL11 configuration(Uneven span support)  */
end_comment

begin_define
define|#
directive|define
name|SPAN_ROW_SIZE
parameter_list|(
name|map
parameter_list|,
name|ld
parameter_list|,
name|index_
parameter_list|)
value|MR_LdSpanPtrGet(ld, index_, map)->spanRowSize
end_define

begin_define
define|#
directive|define
name|SPAN_ROW_DATA_SIZE
parameter_list|(
name|map_
parameter_list|,
name|ld
parameter_list|,
name|index_
parameter_list|)
value|MR_LdSpanPtrGet(ld, index_, map)->spanRowDataSize
end_define

begin_define
define|#
directive|define
name|SPAN_INVALID
value|0xff
end_define

begin_define
define|#
directive|define
name|SPAN_DEBUG
value|0
end_define

begin_comment
comment|/*  * Related Defines  */
end_comment

begin_typedef
typedef|typedef
name|u_int64_t
name|REGION_KEY
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|u_int32_t
name|REGION_LEN
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MR_LD_STATE_OPTIMAL
value|3
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_comment
comment|/*  * Related Macros  */
end_comment

begin_define
define|#
directive|define
name|ABS_DIFF
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|( ((a)> (b)) ? ((a) - (b)) : ((b) - (a)) )
end_define

begin_define
define|#
directive|define
name|swap32
parameter_list|(
name|x
parameter_list|)
define|\
value|((unsigned int)( \     (((unsigned int)(x)& (unsigned int)0x000000ffUL)<< 24) | \     (((unsigned int)(x)& (unsigned int)0x0000ff00UL)<<  8) | \     (((unsigned int)(x)& (unsigned int)0x00ff0000UL)>>  8) | \     (((unsigned int)(x)& (unsigned int)0xff000000UL)>> 24) ))
end_define

begin_comment
comment|/*  * In-line functions for mod and divide of 64-bit dividend and 32-bit divisor.  * Assumes a check for a divisor of zero is not possible.   *   * @param dividend   : Dividend  * @param divisor    : Divisor  * @return remainder  */
end_comment

begin_define
define|#
directive|define
name|mega_mod64
parameter_list|(
name|dividend
parameter_list|,
name|divisor
parameter_list|)
value|({ \ int remainder; \ remainder = ((u_int64_t) (dividend)) % (u_int32_t) (divisor); \ remainder;})
end_define

begin_define
define|#
directive|define
name|mega_div64_32
parameter_list|(
name|dividend
parameter_list|,
name|divisor
parameter_list|)
value|({ \ int quotient; \ quotient = ((u_int64_t) (dividend)) / (u_int32_t) (divisor); \ quotient;})
end_define

begin_comment
comment|/*  * Various RAID map access functions.  These functions access the various  * parts of the RAID map and returns the appropriate parameters.   */
end_comment

begin_function
name|MR_LD_RAID
modifier|*
name|MR_LdRaidGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
operator|(
operator|&
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|ldRaid
operator|)
return|;
block|}
end_function

begin_function
name|u_int16_t
name|MR_GetLDTgtId
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
operator|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|ldRaid
operator|.
name|targetId
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|MR_LdSpanArrayGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int32_t
name|span
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|span
operator|.
name|arrayRef
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|MR_LdDataArmGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int32_t
name|armIdx
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|dataArmMap
index|[
name|armIdx
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|MR_PdDevHandleGet
parameter_list|(
name|u_int32_t
name|pd
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
name|map
operator|->
name|raidMap
operator|.
name|devHndlInfo
index|[
name|pd
index|]
operator|.
name|curDevHdl
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|MR_ArPdGet
parameter_list|(
name|u_int32_t
name|ar
parameter_list|,
name|u_int32_t
name|arm
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
name|map
operator|->
name|raidMap
operator|.
name|arMapInfo
index|[
name|ar
index|]
operator|.
name|pd
index|[
name|arm
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|MR_LD_SPAN
modifier|*
name|MR_LdSpanPtrGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int32_t
name|span
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
operator|&
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|span
return|;
block|}
end_function

begin_function
specifier|static
name|MR_SPAN_BLOCK_INFO
modifier|*
name|MR_LdSpanInfoGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
operator|&
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|u_int16_t
name|MR_TargetIdToLdGet
parameter_list|(
name|u_int32_t
name|ldTgtId
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
name|map
operator|->
name|raidMap
operator|.
name|ldTgtIdToLd
index|[
name|ldTgtId
index|]
return|;
block|}
end_function

begin_function
name|u_int32_t
name|MR_LdBlockSizeGet
parameter_list|(
name|u_int32_t
name|ldTgtId
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
name|u_int32_t
name|ld
decl_stmt|,
name|ldBlockSize
init|=
name|MRSAS_SCSIBLOCKSIZE
decl_stmt|;
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|ldTgtId
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/*      * Check if logical drive was removed.      */
if|if
condition|(
name|ld
operator|>=
name|MAX_LOGICAL_DRIVES
condition|)
return|return
name|ldBlockSize
return|;
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|ldBlockSize
operator|=
name|raid
operator|->
name|logicalBlockLength
expr_stmt|;
if|if
condition|(
operator|!
name|ldBlockSize
condition|)
name|ldBlockSize
operator|=
name|MRSAS_SCSIBLOCKSIZE
expr_stmt|;
return|return
name|ldBlockSize
return|;
block|}
end_function

begin_comment
comment|/*  * This function will Populate Driver Map using firmware raid map  */
end_comment

begin_function
name|void
name|MR_PopulateDrvRaidMap
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|MR_FW_RAID_MAP_ALL
modifier|*
name|fw_map_old
init|=
name|NULL
decl_stmt|;
name|MR_FW_RAID_MAP
modifier|*
name|pFwRaidMap
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|drv_map
init|=
name|sc
operator|->
name|ld_drv_map
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
decl_stmt|;
name|MR_DRV_RAID_MAP
modifier|*
name|pDrvRaidMap
init|=
operator|&
name|drv_map
operator|->
name|raidMap
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|max256vdSupport
condition|)
block|{
name|memcpy
argument_list|(
name|sc
operator|->
name|ld_drv_map
index|[
name|sc
operator|->
name|map_id
operator|&
literal|1
index|]
argument_list|,
name|sc
operator|->
name|raidmap_mem
index|[
name|sc
operator|->
name|map_id
operator|&
literal|1
index|]
argument_list|,
name|sc
operator|->
name|current_map_sz
argument_list|)
expr_stmt|;
comment|/* New Raid map will not set totalSize, so keep expected value 		 * for legacy code in ValidateMapInfo 		 */
name|pDrvRaidMap
operator|->
name|totalSize
operator|=
sizeof|sizeof
argument_list|(
name|MR_FW_RAID_MAP_EXT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fw_map_old
operator|=
operator|(
name|MR_FW_RAID_MAP_ALL
operator|*
operator|)
name|sc
operator|->
name|raidmap_mem
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
expr_stmt|;
name|pFwRaidMap
operator|=
operator|&
name|fw_map_old
operator|->
name|raidMap
expr_stmt|;
if|#
directive|if
name|VD_EXT_DEBUG
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pFwRaidMap
operator|->
name|ldCount
condition|;
name|i
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Index 0x%x Target Id 0x%x Seq Num 0x%x Size 0/%lx\n"
argument_list|,
name|i
argument_list|,
name|fw_map_old
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|targetId
argument_list|,
name|fw_map_old
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|seqNum
argument_list|,
name|fw_map_old
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|memset
argument_list|(
name|drv_map
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|drv_map_sz
argument_list|)
expr_stmt|;
name|pDrvRaidMap
operator|->
name|totalSize
operator|=
name|pFwRaidMap
operator|->
name|totalSize
expr_stmt|;
name|pDrvRaidMap
operator|->
name|ldCount
operator|=
name|pFwRaidMap
operator|->
name|ldCount
expr_stmt|;
name|pDrvRaidMap
operator|->
name|fpPdIoTimeoutSec
operator|=
name|pFwRaidMap
operator|->
name|fpPdIoTimeoutSec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_RAIDMAP_LOGICAL_DRIVES
operator|+
name|MAX_RAIDMAP_VIEWS
condition|;
name|i
operator|++
control|)
block|{
name|pDrvRaidMap
operator|->
name|ldTgtIdToLd
index|[
name|i
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|pFwRaidMap
operator|->
name|ldTgtIdToLd
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pDrvRaidMap
operator|->
name|ldCount
condition|;
name|i
operator|++
control|)
block|{
name|pDrvRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|=
name|pFwRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
expr_stmt|;
if|#
directive|if
name|VD_EXT_DEBUG
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"pFwRaidMap->ldSpanMap[%d].ldRaid.targetId 0x%x "
literal|"pFwRaidMap->ldSpanMap[%d].ldRaid.seqNum 0x%x size 0x%x\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|pFwRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|targetId
argument_list|,
name|pFwRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|seqNum
argument_list|,
operator|(
name|u_int32_t
operator|)
name|pFwRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|rowSize
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"pDrvRaidMap->ldSpanMap[%d].ldRaid.targetId 0x%x"
literal|"pDrvRaidMap->ldSpanMap[%d].ldRaid.seqNum 0x%x size 0x%x\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|pDrvRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|targetId
argument_list|,
name|pDrvRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|seqNum
argument_list|,
operator|(
name|u_int32_t
operator|)
name|pDrvRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|rowSize
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"drv raid map all %p raid map %p LD RAID MAP %p/%p\n"
argument_list|,
name|drv_map
argument_list|,
name|pDrvRaidMap
argument_list|,
operator|&
name|pFwRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
argument_list|,
operator|&
name|pDrvRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|memcpy
argument_list|(
name|pDrvRaidMap
operator|->
name|arMapInfo
argument_list|,
name|pFwRaidMap
operator|->
name|arMapInfo
argument_list|,
sizeof|sizeof
argument_list|(
name|MR_ARRAY_INFO
argument_list|)
operator|*
name|MAX_RAIDMAP_ARRAYS
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pDrvRaidMap
operator|->
name|devHndlInfo
argument_list|,
name|pFwRaidMap
operator|->
name|devHndlInfo
argument_list|,
sizeof|sizeof
argument_list|(
name|MR_DEV_HANDLE_INFO
argument_list|)
operator|*
name|MAX_RAIDMAP_PHYSICAL_DEVICES
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * MR_ValidateMapInfo:        Validate RAID map  * input:                     Adapter instance soft state  *  * This function checks and validates the loaded RAID map. It returns 0 if   * successful, and 1 otherwise.  */
end_comment

begin_function
name|u_int8_t
name|MR_ValidateMapInfo
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sc
condition|)
block|{
return|return
literal|1
return|;
block|}
name|MR_PopulateDrvRaidMap
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|drv_map
init|=
name|sc
operator|->
name|ld_drv_map
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
decl_stmt|;
name|MR_DRV_RAID_MAP
modifier|*
name|pDrvRaidMap
init|=
operator|&
name|drv_map
operator|->
name|raidMap
decl_stmt|;
name|u_int32_t
name|expected_map_size
decl_stmt|;
name|drv_map
operator|=
name|sc
operator|->
name|ld_drv_map
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
expr_stmt|;
name|pDrvRaidMap
operator|=
operator|&
name|drv_map
operator|->
name|raidMap
expr_stmt|;
name|PLD_SPAN_INFO
name|ldSpanInfo
init|=
operator|(
name|PLD_SPAN_INFO
operator|)
operator|&
name|sc
operator|->
name|log_to_span
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|max256vdSupport
condition|)
name|expected_map_size
operator|=
sizeof|sizeof
argument_list|(
name|MR_FW_RAID_MAP_EXT
argument_list|)
expr_stmt|;
else|else
name|expected_map_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|MR_FW_RAID_MAP
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|MR_LD_SPAN_MAP
argument_list|)
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|MR_LD_SPAN_MAP
argument_list|)
operator|*
name|pDrvRaidMap
operator|->
name|ldCount
operator|)
expr_stmt|;
if|if
condition|(
name|pDrvRaidMap
operator|->
name|totalSize
operator|!=
name|expected_map_size
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"map size %x not matching ld count\n"
argument_list|,
name|expected_map_size
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"span map= %x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
sizeof|sizeof
argument_list|(
name|MR_LD_SPAN_MAP
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"pDrvRaidMap->totalSize=%x\n"
argument_list|,
name|pDrvRaidMap
operator|->
name|totalSize
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|UnevenSpanSupport
condition|)
block|{
name|printf
argument_list|(
literal|"Updating span set\n\n"
argument_list|)
expr_stmt|;
name|mr_update_span_set
argument_list|(
name|drv_map
argument_list|,
name|ldSpanInfo
argument_list|)
expr_stmt|;
block|}
name|mrsas_update_load_balance_params
argument_list|(
name|drv_map
argument_list|,
name|sc
operator|->
name|load_balance_info
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ******************************************************************************  *   *  Function to print info about span set created in driver from FW raid map  *   *  Inputs :  *  map    - LD map  *  ldSpanInfo - ldSpanInfo per HBA instance  *   *   * */
end_comment

begin_if
if|#
directive|if
name|SPAN_DEBUG
end_if

begin_function
specifier|static
name|int
name|getSpanInfo
parameter_list|(
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|PLD_SPAN_INFO
name|ldSpanInfo
parameter_list|)
block|{
name|u_int8_t
name|span
decl_stmt|;
name|u_int32_t
name|element
decl_stmt|;
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
name|LD_SPAN_SET
modifier|*
name|span_set
decl_stmt|;
name|MR_QUAD_ELEMENT
modifier|*
name|quad
decl_stmt|;
name|int
name|ldCount
decl_stmt|;
name|u_int16_t
name|ld
decl_stmt|;
for|for
control|(
name|ldCount
operator|=
literal|0
init|;
name|ldCount
operator|<
name|MAX_LOGICAL_DRIVES
condition|;
name|ldCount
operator|++
control|)
block|{
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|ldCount
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|>=
name|MAX_LOGICAL_DRIVES
condition|)
block|{
continue|continue;
block|}
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LD %x: span_depth=%x\n"
argument_list|,
name|ld
argument_list|,
name|raid
operator|->
name|spanDepth
argument_list|)
expr_stmt|;
for|for
control|(
name|span
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
control|)
name|printf
argument_list|(
literal|"Span=%x, number of quads=%x\n"
argument_list|,
name|span
argument_list|,
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|noElements
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
literal|0
init|;
name|element
operator|<
name|MAX_QUAD_DEPTH
condition|;
name|element
operator|++
control|)
block|{
name|span_set
operator|=
operator|&
operator|(
name|ldSpanInfo
index|[
name|ld
index|]
operator|.
name|span_set
index|[
name|element
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|span_set
operator|->
name|span_row_data_width
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"  Span Set %x: width=%x, diff=%x\n"
argument_list|,
name|element
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|span_row_data_width
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|diff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    logical LBA start=0x%08lx, end=0x%08lx\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|log_start_lba
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|log_end_lba
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       span row start=0x%08lx, end=0x%08lx\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|span_row_start
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|span_row_end
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       data row start=0x%08lx, end=0x%08lx\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|data_row_start
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|data_row_end
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       data strip start=0x%08lx, end=0x%08lx\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|data_strip_start
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|data_strip_end
argument_list|)
expr_stmt|;
for|for
control|(
name|span
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
control|)
block|{
if|if
condition|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|noElements
operator|>=
name|element
operator|+
literal|1
condition|)
block|{
name|quad
operator|=
operator|&
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|quad
index|[
name|element
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"  Span=%x, Quad=%x, diff=%x\n"
argument_list|,
name|span
argument_list|,
name|element
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    offset_in_span=0x%08lx\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|quad
operator|->
name|offsetInSpan
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     logical start=0x%08lx, end=0x%08lx\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|quad
operator|->
name|logStart
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|quad
operator|->
name|logEnd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ****************************************************************************** * * This routine calculates the Span block for given row using spanset. * * Inputs : *    instance - HBA instance *    ld   - Logical drive number *    row        - Row number *    map    - LD map * * Outputs : * *    span          - Span number *    block         - Absolute Block number in the physical disk *    div_error    - Devide error code. */
end_comment

begin_function
name|u_int32_t
name|mr_spanset_get_span_block
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|row
parameter_list|,
name|u_int64_t
modifier|*
name|span_blk
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|int
modifier|*
name|div_error
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|LD_SPAN_SET
modifier|*
name|span_set
decl_stmt|;
name|MR_QUAD_ELEMENT
modifier|*
name|quad
decl_stmt|;
name|u_int32_t
name|span
decl_stmt|,
name|info
decl_stmt|;
name|PLD_SPAN_INFO
name|ldSpanInfo
init|=
name|sc
operator|->
name|log_to_span
decl_stmt|;
for|for
control|(
name|info
operator|=
literal|0
init|;
name|info
operator|<
name|MAX_QUAD_DEPTH
condition|;
name|info
operator|++
control|)
block|{
name|span_set
operator|=
operator|&
operator|(
name|ldSpanInfo
index|[
name|ld
index|]
operator|.
name|span_set
index|[
name|info
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|span_set
operator|->
name|span_row_data_width
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|row
operator|>
name|span_set
operator|->
name|data_row_end
condition|)
continue|continue;
for|for
control|(
name|span
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
control|)
if|if
condition|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|noElements
operator|>=
name|info
operator|+
literal|1
condition|)
block|{
name|quad
operator|=
operator|&
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|quad
index|[
name|info
index|]
expr_stmt|;
if|if
condition|(
name|quad
operator|->
name|diff
operator|==
literal|0
condition|)
block|{
operator|*
name|div_error
operator|=
literal|1
expr_stmt|;
return|return
name|span
return|;
block|}
if|if
condition|(
name|quad
operator|->
name|logStart
operator|<=
name|row
operator|&&
name|row
operator|<=
name|quad
operator|->
name|logEnd
operator|&&
operator|(
name|mega_mod64
argument_list|(
name|row
operator|-
name|quad
operator|->
name|logStart
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|span_blk
operator|!=
name|NULL
condition|)
block|{
name|u_int64_t
name|blk
decl_stmt|;
name|blk
operator|=
name|mega_div64_32
argument_list|(
operator|(
name|row
operator|-
name|quad
operator|->
name|logStart
operator|)
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
expr_stmt|;
name|blk
operator|=
operator|(
name|blk
operator|+
name|quad
operator|->
name|offsetInSpan
operator|)
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
operator|*
name|span_blk
operator|=
name|blk
expr_stmt|;
block|}
return|return
name|span
return|;
block|}
block|}
block|}
return|return
name|SPAN_INVALID
return|;
block|}
end_function

begin_comment
comment|/* ****************************************************************************** * * This routine calculates the row for given strip using spanset. * * Inputs : *    instance - HBA instance *    ld   - Logical drive number *    Strip        - Strip *    map    - LD map * * Outputs : * *    row         - row associated with strip */
end_comment

begin_function
specifier|static
name|u_int64_t
name|get_row_from_strip
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|strip
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|LD_SPAN_SET
modifier|*
name|span_set
decl_stmt|;
name|PLD_SPAN_INFO
name|ldSpanInfo
init|=
name|sc
operator|->
name|log_to_span
decl_stmt|;
name|u_int32_t
name|info
decl_stmt|,
name|strip_offset
decl_stmt|,
name|span
decl_stmt|,
name|span_offset
decl_stmt|;
name|u_int64_t
name|span_set_Strip
decl_stmt|,
name|span_set_Row
decl_stmt|;
for|for
control|(
name|info
operator|=
literal|0
init|;
name|info
operator|<
name|MAX_QUAD_DEPTH
condition|;
name|info
operator|++
control|)
block|{
name|span_set
operator|=
operator|&
operator|(
name|ldSpanInfo
index|[
name|ld
index|]
operator|.
name|span_set
index|[
name|info
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|span_set
operator|->
name|span_row_data_width
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strip
operator|>
name|span_set
operator|->
name|data_strip_end
condition|)
continue|continue;
name|span_set_Strip
operator|=
name|strip
operator|-
name|span_set
operator|->
name|data_strip_start
expr_stmt|;
name|strip_offset
operator|=
name|mega_mod64
argument_list|(
name|span_set_Strip
argument_list|,
name|span_set
operator|->
name|span_row_data_width
argument_list|)
expr_stmt|;
name|span_set_Row
operator|=
name|mega_div64_32
argument_list|(
name|span_set_Strip
argument_list|,
name|span_set
operator|->
name|span_row_data_width
argument_list|)
operator|*
name|span_set
operator|->
name|diff
expr_stmt|;
for|for
control|(
name|span
operator|=
literal|0
operator|,
name|span_offset
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
control|)
if|if
condition|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|noElements
operator|>=
name|info
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|strip_offset
operator|>=
name|span_set
operator|->
name|strip_offset
index|[
name|span
index|]
condition|)
name|span_offset
operator|++
expr_stmt|;
else|else
break|break;
block|}
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug : Strip 0x%llx, span_set_Strip 0x%llx, span_set_Row 0x%llx "
literal|"data width 0x%llx span offset 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|strip
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|span_set_Strip
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|span_set_Row
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|span_set
operator|->
name|span_row_data_width
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|span_offset
argument_list|)
expr_stmt|;
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug : For strip 0x%llx row is 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|strip
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|span_set
operator|->
name|data_row_start
operator|+
operator|(
name|unsigned
name|long
name|long
operator|)
name|span_set_Row
operator|+
operator|(
name|span_offset
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|span_set
operator|->
name|data_row_start
operator|+
name|span_set_Row
operator|+
operator|(
name|span_offset
operator|-
literal|1
operator|)
operator|)
return|;
block|}
return|return
operator|-
literal|1LLU
return|;
block|}
end_function

begin_comment
comment|/* ****************************************************************************** * * This routine calculates the Start Strip for given row using spanset. * * Inputs : *    instance - HBA instance *    ld   - Logical drive number *    row        - Row number *    map    - LD map * * Outputs : * *    Strip         - Start strip associated with row */
end_comment

begin_function
specifier|static
name|u_int64_t
name|get_strip_from_row
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|row
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|LD_SPAN_SET
modifier|*
name|span_set
decl_stmt|;
name|MR_QUAD_ELEMENT
modifier|*
name|quad
decl_stmt|;
name|PLD_SPAN_INFO
name|ldSpanInfo
init|=
name|sc
operator|->
name|log_to_span
decl_stmt|;
name|u_int32_t
name|span
decl_stmt|,
name|info
decl_stmt|;
name|u_int64_t
name|strip
decl_stmt|;
for|for
control|(
name|info
operator|=
literal|0
init|;
name|info
operator|<
name|MAX_QUAD_DEPTH
condition|;
name|info
operator|++
control|)
block|{
name|span_set
operator|=
operator|&
operator|(
name|ldSpanInfo
index|[
name|ld
index|]
operator|.
name|span_set
index|[
name|info
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|span_set
operator|->
name|span_row_data_width
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|row
operator|>
name|span_set
operator|->
name|data_row_end
condition|)
continue|continue;
for|for
control|(
name|span
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
control|)
if|if
condition|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|noElements
operator|>=
name|info
operator|+
literal|1
condition|)
block|{
name|quad
operator|=
operator|&
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|quad
index|[
name|info
index|]
expr_stmt|;
if|if
condition|(
name|quad
operator|->
name|logStart
operator|<=
name|row
operator|&&
name|row
operator|<=
name|quad
operator|->
name|logEnd
operator|&&
name|mega_mod64
argument_list|(
operator|(
name|row
operator|-
name|quad
operator|->
name|logStart
operator|)
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strip
operator|=
name|mega_div64_32
argument_list|(
operator|(
operator|(
name|row
operator|-
name|span_set
operator|->
name|data_row_start
operator|)
operator|-
name|quad
operator|->
name|logStart
operator|)
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
expr_stmt|;
name|strip
operator|*=
name|span_set
operator|->
name|span_row_data_width
expr_stmt|;
name|strip
operator|+=
name|span_set
operator|->
name|data_strip_start
expr_stmt|;
name|strip
operator|+=
name|span_set
operator|->
name|strip_offset
index|[
name|span
index|]
expr_stmt|;
return|return
name|strip
return|;
block|}
block|}
block|}
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug - get_strip_from_row: returns invalid "
literal|"strip for ld=%x, row=%lx\n"
argument_list|,
name|ld
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|row
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ****************************************************************************** * * This routine calculates the Physical Arm for given strip using spanset. * * Inputs : *    instance - HBA instance *    ld   - Logical drive number *    strip      - Strip *    map    - LD map * * Outputs : * *    Phys Arm         - Phys Arm associated with strip */
end_comment

begin_function
specifier|static
name|u_int32_t
name|get_arm_from_strip
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|strip
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|LD_SPAN_SET
modifier|*
name|span_set
decl_stmt|;
name|PLD_SPAN_INFO
name|ldSpanInfo
init|=
name|sc
operator|->
name|log_to_span
decl_stmt|;
name|u_int32_t
name|info
decl_stmt|,
name|strip_offset
decl_stmt|,
name|span
decl_stmt|,
name|span_offset
decl_stmt|;
for|for
control|(
name|info
operator|=
literal|0
init|;
name|info
operator|<
name|MAX_QUAD_DEPTH
condition|;
name|info
operator|++
control|)
block|{
name|span_set
operator|=
operator|&
operator|(
name|ldSpanInfo
index|[
name|ld
index|]
operator|.
name|span_set
index|[
name|info
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|span_set
operator|->
name|span_row_data_width
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strip
operator|>
name|span_set
operator|->
name|data_strip_end
condition|)
continue|continue;
name|strip_offset
operator|=
operator|(
name|u_int32_t
operator|)
name|mega_mod64
argument_list|(
operator|(
name|strip
operator|-
name|span_set
operator|->
name|data_strip_start
operator|)
argument_list|,
name|span_set
operator|->
name|span_row_data_width
argument_list|)
expr_stmt|;
for|for
control|(
name|span
operator|=
literal|0
operator|,
name|span_offset
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
control|)
if|if
condition|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|noElements
operator|>=
name|info
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|strip_offset
operator|>=
name|span_set
operator|->
name|strip_offset
index|[
name|span
index|]
condition|)
name|span_offset
operator|=
name|span_set
operator|->
name|strip_offset
index|[
name|span
index|]
expr_stmt|;
else|else
break|break;
block|}
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI PRL11: get_arm_from_strip: "
literal|" for ld=0x%x strip=0x%lx arm is  0x%x\n"
argument_list|,
name|ld
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|strip
argument_list|,
operator|(
name|strip_offset
operator|-
name|span_offset
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|strip_offset
operator|-
name|span_offset
operator|)
return|;
block|}
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug: - get_arm_from_strip: returns invalid arm"
literal|" for ld=%x strip=%lx\n"
argument_list|,
name|ld
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|strip
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This Function will return Phys arm */
end_comment

begin_function
name|u_int8_t
name|get_arm
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int8_t
name|span
parameter_list|,
name|u_int64_t
name|stripe
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
comment|/* Need to check correct default value */
name|u_int32_t
name|arm
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|raid
operator|->
name|level
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
name|arm
operator|=
name|mega_mod64
argument_list|(
name|stripe
argument_list|,
name|SPAN_ROW_SIZE
argument_list|(
name|map
argument_list|,
name|ld
argument_list|,
name|span
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|// start with logical arm
name|arm
operator|=
name|get_arm_from_strip
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|stripe
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|arm
operator|*=
literal|2
expr_stmt|;
break|break;
block|}
return|return
name|arm
return|;
block|}
end_function

begin_comment
comment|/* ****************************************************************************** * * This routine calculates the arm, span and block for the specified stripe and * reference in stripe using spanset * * Inputs : * *    ld   - Logical drive number *    stripRow        - Stripe number *    stripRef    - Reference in stripe * * Outputs : * *    span          - Span number *    block         - Absolute Block number in the physical disk */
end_comment

begin_function
specifier|static
name|u_int8_t
name|mr_spanset_get_phy_params
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|stripRow
parameter_list|,
name|u_int16_t
name|stripRef
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|RAID_CONTEXT
modifier|*
name|pRAID_Context
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|u_int32_t
name|pd
decl_stmt|,
name|arRef
decl_stmt|;
name|u_int8_t
name|physArm
decl_stmt|,
name|span
decl_stmt|;
name|u_int64_t
name|row
decl_stmt|;
name|u_int8_t
name|retval
init|=
name|TRUE
decl_stmt|;
name|u_int64_t
modifier|*
name|pdBlock
init|=
operator|&
name|io_info
operator|->
name|pdBlock
decl_stmt|;
name|u_int16_t
modifier|*
name|pDevHandle
init|=
operator|&
name|io_info
operator|->
name|devHandle
decl_stmt|;
name|u_int32_t
name|logArm
decl_stmt|,
name|rowMod
decl_stmt|,
name|armQ
decl_stmt|,
name|arm
decl_stmt|;
name|u_int8_t
name|do_invader
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_INVADER
operator|)
operator|||
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_FURY
operator|)
condition|)
name|do_invader
operator|=
literal|1
expr_stmt|;
comment|// Get row and span from io_info for Uneven Span IO.
name|row
operator|=
name|io_info
operator|->
name|start_row
expr_stmt|;
name|span
operator|=
name|io_info
operator|->
name|start_span
expr_stmt|;
if|if
condition|(
name|raid
operator|->
name|level
operator|==
literal|6
condition|)
block|{
name|logArm
operator|=
name|get_arm_from_strip
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|stripRow
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|rowMod
operator|=
name|mega_mod64
argument_list|(
name|row
argument_list|,
name|SPAN_ROW_SIZE
argument_list|(
name|map
argument_list|,
name|ld
argument_list|,
name|span
argument_list|)
argument_list|)
expr_stmt|;
name|armQ
operator|=
name|SPAN_ROW_SIZE
argument_list|(
name|map
argument_list|,
name|ld
argument_list|,
name|span
argument_list|)
operator|-
literal|1
operator|-
name|rowMod
expr_stmt|;
name|arm
operator|=
name|armQ
operator|+
literal|1
operator|+
name|logArm
expr_stmt|;
if|if
condition|(
name|arm
operator|>=
name|SPAN_ROW_SIZE
argument_list|(
name|map
argument_list|,
name|ld
argument_list|,
name|span
argument_list|)
condition|)
name|arm
operator|-=
name|SPAN_ROW_SIZE
argument_list|(
name|map
argument_list|,
name|ld
argument_list|,
name|span
argument_list|)
expr_stmt|;
name|physArm
operator|=
operator|(
name|u_int8_t
operator|)
name|arm
expr_stmt|;
block|}
else|else
comment|// Calculate the arm
name|physArm
operator|=
name|get_arm
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|span
argument_list|,
name|stripRow
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|arRef
operator|=
name|MR_LdSpanArrayGet
argument_list|(
name|ld
argument_list|,
name|span
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|pd
operator|=
name|MR_ArPdGet
argument_list|(
name|arRef
argument_list|,
name|physArm
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|!=
name|MR_PD_INVALID
condition|)
operator|*
name|pDevHandle
operator|=
name|MR_PdDevHandleGet
argument_list|(
name|pd
argument_list|,
name|map
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|pDevHandle
operator|=
name|MR_PD_INVALID
expr_stmt|;
if|if
condition|(
operator|(
name|raid
operator|->
name|level
operator|>=
literal|5
operator|)
operator|&&
operator|(
operator|(
operator|!
name|do_invader
operator|)
operator|||
operator|(
name|do_invader
operator|&&
name|raid
operator|->
name|regTypeReqOnRead
operator|!=
name|REGION_TYPE_UNUSED
operator|)
operator|)
condition|)
name|pRAID_Context
operator|->
name|regLockFlags
operator|=
name|REGION_TYPE_EXCLUSIVE
expr_stmt|;
elseif|else
if|if
condition|(
name|raid
operator|->
name|level
operator|==
literal|1
condition|)
block|{
name|pd
operator|=
name|MR_ArPdGet
argument_list|(
name|arRef
argument_list|,
name|physArm
operator|+
literal|1
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|!=
name|MR_PD_INVALID
condition|)
operator|*
name|pDevHandle
operator|=
name|MR_PdDevHandleGet
argument_list|(
name|pd
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|pdBlock
operator|+=
name|stripRef
operator|+
name|MR_LdSpanPtrGet
argument_list|(
name|ld
argument_list|,
name|span
argument_list|,
name|map
argument_list|)
operator|->
name|startBlk
expr_stmt|;
name|pRAID_Context
operator|->
name|spanArm
operator|=
operator|(
name|span
operator|<<
name|RAID_CTX_SPANARM_SPAN_SHIFT
operator|)
operator||
name|physArm
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/** * MR_BuildRaidContext:           Set up Fast path RAID context * * This function will initiate command processing.  The start/end row  * and strip information is calculated then the lock is acquired. * This function will return 0 if region lock was acquired OR return  * num strips. */
end_comment

begin_function
name|u_int8_t
name|MR_BuildRaidContext
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|RAID_CONTEXT
modifier|*
name|pRAID_Context
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
name|u_int32_t
name|ld
decl_stmt|,
name|stripSize
decl_stmt|,
name|stripe_mask
decl_stmt|;
name|u_int64_t
name|endLba
decl_stmt|,
name|endStrip
decl_stmt|,
name|endRow
decl_stmt|,
name|start_row
decl_stmt|,
name|start_strip
decl_stmt|;
name|REGION_KEY
name|regStart
decl_stmt|;
name|REGION_LEN
name|regSize
decl_stmt|;
name|u_int8_t
name|num_strips
decl_stmt|,
name|numRows
decl_stmt|;
name|u_int16_t
name|ref_in_start_stripe
decl_stmt|,
name|ref_in_end_stripe
decl_stmt|;
name|u_int64_t
name|ldStartBlock
decl_stmt|;
name|u_int32_t
name|numBlocks
decl_stmt|,
name|ldTgtId
decl_stmt|;
name|u_int8_t
name|isRead
decl_stmt|,
name|stripIdx
decl_stmt|;
name|u_int8_t
name|retval
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|startlba_span
init|=
name|SPAN_INVALID
decl_stmt|;
name|u_int64_t
modifier|*
name|pdBlock
init|=
operator|&
name|io_info
operator|->
name|pdBlock
decl_stmt|;
name|int
name|error_code
init|=
literal|0
decl_stmt|;
name|ldStartBlock
operator|=
name|io_info
operator|->
name|ldStartBlock
expr_stmt|;
name|numBlocks
operator|=
name|io_info
operator|->
name|numBlocks
expr_stmt|;
name|ldTgtId
operator|=
name|io_info
operator|->
name|ldTgtId
expr_stmt|;
name|isRead
operator|=
name|io_info
operator|->
name|isRead
expr_stmt|;
name|io_info
operator|->
name|IoforUnevenSpan
operator|=
literal|0
expr_stmt|;
name|io_info
operator|->
name|start_span
operator|=
name|SPAN_INVALID
expr_stmt|;
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|ldTgtId
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/*   	* if rowDataSize @RAID map and spanRowDataSize @SPAN INFO are zero      * return FALSE     */
if|if
condition|(
name|raid
operator|->
name|rowDataSize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|MR_LdSpanPtrGet
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|,
name|map
argument_list|)
operator|->
name|spanRowDataSize
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|UnevenSpanSupport
condition|)
block|{
name|io_info
operator|->
name|IoforUnevenSpan
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug: raid->rowDataSize is 0, but has SPAN[0] rowDataSize = 0x%0x,"
literal|" but there is _NO_ UnevenSpanSupport\n"
argument_list|,
name|MR_LdSpanPtrGet
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|,
name|map
argument_list|)
operator|->
name|spanRowDataSize
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|stripSize
operator|=
literal|1
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
name|stripe_mask
operator|=
name|stripSize
operator|-
literal|1
expr_stmt|;
comment|/*      * calculate starting row and stripe, and number of strips and rows      */
name|start_strip
operator|=
name|ldStartBlock
operator|>>
name|raid
operator|->
name|stripeShift
expr_stmt|;
name|ref_in_start_stripe
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|ldStartBlock
operator|&
name|stripe_mask
argument_list|)
expr_stmt|;
name|endLba
operator|=
name|ldStartBlock
operator|+
name|numBlocks
operator|-
literal|1
expr_stmt|;
name|ref_in_end_stripe
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|endLba
operator|&
name|stripe_mask
argument_list|)
expr_stmt|;
name|endStrip
operator|=
name|endLba
operator|>>
name|raid
operator|->
name|stripeShift
expr_stmt|;
name|num_strips
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|endStrip
operator|-
name|start_strip
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// End strip
if|if
condition|(
name|io_info
operator|->
name|IoforUnevenSpan
condition|)
block|{
name|start_row
operator|=
name|get_row_from_strip
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_strip
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|endRow
operator|=
name|get_row_from_strip
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|endStrip
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|raid
operator|->
name|spanDepth
operator|==
literal|1
condition|)
block|{
name|startlba_span
operator|=
literal|0
expr_stmt|;
operator|*
name|pdBlock
operator|=
name|start_row
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
block|}
else|else
block|{
name|startlba_span
operator|=
operator|(
name|u_int8_t
operator|)
name|mr_spanset_get_span_block
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_row
argument_list|,
name|pdBlock
argument_list|,
name|map
argument_list|,
operator|&
name|error_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_code
operator|==
literal|1
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug: return from %s %d. Send IO w/o region lock.\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|startlba_span
operator|==
name|SPAN_INVALID
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug: return from %s %d for row 0x%llx,"
literal|"start strip %llx endSrip %llx\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|start_row
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|start_strip
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|endStrip
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|io_info
operator|->
name|start_span
operator|=
name|startlba_span
expr_stmt|;
name|io_info
operator|->
name|start_row
operator|=
name|start_row
expr_stmt|;
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug: Check Span number from %s %d for row 0x%llx, "
literal|" start strip 0x%llx endSrip 0x%llx span 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|start_row
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|start_strip
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|endStrip
argument_list|,
name|startlba_span
argument_list|)
expr_stmt|;
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug : 1. start_row 0x%llx endRow 0x%llx Start span 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|start_row
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|endRow
argument_list|,
name|startlba_span
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start_row
operator|=
name|mega_div64_32
argument_list|(
name|start_strip
argument_list|,
name|raid
operator|->
name|rowDataSize
argument_list|)
expr_stmt|;
comment|// Start Row
name|endRow
operator|=
name|mega_div64_32
argument_list|(
name|endStrip
argument_list|,
name|raid
operator|->
name|rowDataSize
argument_list|)
expr_stmt|;
block|}
name|numRows
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|endRow
operator|-
name|start_row
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// get the row count
comment|/*      * Calculate region info.  (Assume region at start of first row, and       * assume this IO needs the full row - will adjust if not true.)      */
name|regStart
operator|=
name|start_row
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
name|regSize
operator|=
name|stripSize
expr_stmt|;
comment|/* Check if we can send this I/O via FastPath */
if|if
condition|(
name|raid
operator|->
name|capability
operator|.
name|fpCapable
condition|)
block|{
if|if
condition|(
name|isRead
condition|)
name|io_info
operator|->
name|fpOkForIo
operator|=
operator|(
name|raid
operator|->
name|capability
operator|.
name|fpReadCapable
operator|&&
operator|(
operator|(
name|num_strips
operator|==
literal|1
operator|)
operator|||
name|raid
operator|->
name|capability
operator|.
name|fpReadAcrossStripe
operator|)
operator|)
expr_stmt|;
else|else
name|io_info
operator|->
name|fpOkForIo
operator|=
operator|(
name|raid
operator|->
name|capability
operator|.
name|fpWriteCapable
operator|&&
operator|(
operator|(
name|num_strips
operator|==
literal|1
operator|)
operator|||
name|raid
operator|->
name|capability
operator|.
name|fpWriteAcrossStripe
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|io_info
operator|->
name|fpOkForIo
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|numRows
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|num_strips
operator|==
literal|1
condition|)
block|{
comment|/* single-strip IOs can always lock only the data needed,                multi-strip IOs always need to full stripe locked */
name|regStart
operator|+=
name|ref_in_start_stripe
expr_stmt|;
name|regSize
operator|=
name|numBlocks
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|io_info
operator|->
name|IoforUnevenSpan
operator|==
literal|0
condition|)
block|{
comment|// For Even span region lock optimization.
comment|// If the start strip is the last in the start row
if|if
condition|(
name|start_strip
operator|==
operator|(
name|start_row
operator|+
literal|1
operator|)
operator|*
name|raid
operator|->
name|rowDataSize
operator|-
literal|1
condition|)
block|{
name|regStart
operator|+=
name|ref_in_start_stripe
expr_stmt|;
comment|// initialize count to sectors from startRef to end of strip
name|regSize
operator|=
name|stripSize
operator|-
name|ref_in_start_stripe
expr_stmt|;
block|}
comment|// add complete rows in the middle of the transfer
if|if
condition|(
name|numRows
operator|>
literal|2
condition|)
name|regSize
operator|+=
operator|(
name|numRows
operator|-
literal|2
operator|)
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
comment|// if IO ends within first strip of last row
if|if
condition|(
name|endStrip
operator|==
name|endRow
operator|*
name|raid
operator|->
name|rowDataSize
condition|)
name|regSize
operator|+=
name|ref_in_end_stripe
operator|+
literal|1
expr_stmt|;
else|else
name|regSize
operator|+=
name|stripSize
expr_stmt|;
block|}
else|else
block|{
comment|//For Uneven span region lock optimization.
comment|// If the start strip is the last in the start row
if|if
condition|(
name|start_strip
operator|==
operator|(
name|get_strip_from_row
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_row
argument_list|,
name|map
argument_list|)
operator|+
name|SPAN_ROW_DATA_SIZE
argument_list|(
name|map
argument_list|,
name|ld
argument_list|,
name|startlba_span
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|regStart
operator|+=
name|ref_in_start_stripe
expr_stmt|;
comment|// initialize count to sectors from startRef to end of strip
name|regSize
operator|=
name|stripSize
operator|-
name|ref_in_start_stripe
expr_stmt|;
block|}
comment|// add complete rows in the middle of the transfer
if|if
condition|(
name|numRows
operator|>
literal|2
condition|)
name|regSize
operator|+=
operator|(
name|numRows
operator|-
literal|2
operator|)
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
comment|// if IO ends within first strip of last row
if|if
condition|(
name|endStrip
operator|==
name|get_strip_from_row
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|endRow
argument_list|,
name|map
argument_list|)
condition|)
name|regSize
operator|+=
name|ref_in_end_stripe
operator|+
literal|1
expr_stmt|;
else|else
name|regSize
operator|+=
name|stripSize
expr_stmt|;
block|}
name|pRAID_Context
operator|->
name|timeoutValue
operator|=
name|map
operator|->
name|raidMap
operator|.
name|fpPdIoTimeoutSec
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_INVADER
operator|)
operator|||
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_FURY
operator|)
condition|)
name|pRAID_Context
operator|->
name|regLockFlags
operator|=
operator|(
name|isRead
operator|)
condition|?
name|raid
operator|->
name|regTypeReqOnRead
else|:
name|raid
operator|->
name|regTypeReqOnWrite
expr_stmt|;
else|else
name|pRAID_Context
operator|->
name|regLockFlags
operator|=
operator|(
name|isRead
operator|)
condition|?
name|REGION_TYPE_SHARED_READ
else|:
name|raid
operator|->
name|regTypeReqOnWrite
expr_stmt|;
name|pRAID_Context
operator|->
name|VirtualDiskTgtId
operator|=
name|raid
operator|->
name|targetId
expr_stmt|;
name|pRAID_Context
operator|->
name|regLockRowLBA
operator|=
name|regStart
expr_stmt|;
name|pRAID_Context
operator|->
name|regLockLength
operator|=
name|regSize
expr_stmt|;
name|pRAID_Context
operator|->
name|configSeqNum
operator|=
name|raid
operator|->
name|seqNum
expr_stmt|;
comment|/*      * Get Phy Params only if FP capable, or else leave it to MR firmware       * to do the calculation.      */
if|if
condition|(
name|io_info
operator|->
name|fpOkForIo
condition|)
block|{
name|retval
operator|=
name|io_info
operator|->
name|IoforUnevenSpan
condition|?
name|mr_spanset_get_phy_params
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_strip
argument_list|,
name|ref_in_start_stripe
argument_list|,
name|io_info
argument_list|,
name|pRAID_Context
argument_list|,
name|map
argument_list|)
else|:
name|MR_GetPhyParams
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_strip
argument_list|,
name|ref_in_start_stripe
argument_list|,
name|io_info
argument_list|,
name|pRAID_Context
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* If IO on an invalid Pd, then FP is not possible */
if|if
condition|(
name|io_info
operator|->
name|devHandle
operator|==
name|MR_PD_INVALID
condition|)
name|io_info
operator|->
name|fpOkForIo
operator|=
name|FALSE
expr_stmt|;
return|return
name|retval
return|;
block|}
elseif|else
if|if
condition|(
name|isRead
condition|)
block|{
for|for
control|(
name|stripIdx
operator|=
literal|0
init|;
name|stripIdx
operator|<
name|num_strips
condition|;
name|stripIdx
operator|++
control|)
block|{
name|retval
operator|=
name|io_info
operator|->
name|IoforUnevenSpan
condition|?
name|mr_spanset_get_phy_params
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_strip
operator|+
name|stripIdx
argument_list|,
name|ref_in_start_stripe
argument_list|,
name|io_info
argument_list|,
name|pRAID_Context
argument_list|,
name|map
argument_list|)
else|:
name|MR_GetPhyParams
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_strip
operator|+
name|stripIdx
argument_list|,
name|ref_in_start_stripe
argument_list|,
name|io_info
argument_list|,
name|pRAID_Context
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
return|return
name|TRUE
return|;
block|}
block|}
if|#
directive|if
name|SPAN_DEBUG
comment|// Just for testing what arm we get for strip.
name|get_arm_from_strip
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_strip
argument_list|,
name|map
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ****************************************************************************** * * This routine pepare spanset info from Valid Raid map and store it into * local copy of ldSpanInfo per instance data structure. * * Inputs : *    map    - LD map *    ldSpanInfo - ldSpanInfo per HBA instance * */
end_comment

begin_function
name|void
name|mr_update_span_set
parameter_list|(
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|PLD_SPAN_INFO
name|ldSpanInfo
parameter_list|)
block|{
name|u_int8_t
name|span
decl_stmt|,
name|count
decl_stmt|;
name|u_int32_t
name|element
decl_stmt|,
name|span_row_width
decl_stmt|;
name|u_int64_t
name|span_row
decl_stmt|;
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
name|LD_SPAN_SET
modifier|*
name|span_set
decl_stmt|,
modifier|*
name|span_set_prev
decl_stmt|;
name|MR_QUAD_ELEMENT
modifier|*
name|quad
decl_stmt|;
name|int
name|ldCount
decl_stmt|;
name|u_int16_t
name|ld
decl_stmt|;
for|for
control|(
name|ldCount
operator|=
literal|0
init|;
name|ldCount
operator|<
name|MAX_LOGICAL_DRIVES
condition|;
name|ldCount
operator|++
control|)
block|{
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|ldCount
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ld = %d\n\n"
argument_list|,
name|ld
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|>=
name|MAX_LOGICAL_DRIVES
condition|)
continue|continue;
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
literal|0
init|;
name|element
operator|<
name|MAX_QUAD_DEPTH
condition|;
name|element
operator|++
control|)
block|{
for|for
control|(
name|span
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
control|)
block|{
if|if
condition|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|noElements
operator|<
name|element
operator|+
literal|1
condition|)
continue|continue;
comment|// TO-DO
name|span_set
operator|=
operator|&
operator|(
name|ldSpanInfo
index|[
name|ld
index|]
operator|.
name|span_set
index|[
name|element
index|]
operator|)
expr_stmt|;
name|quad
operator|=
operator|&
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|quad
index|[
name|element
index|]
expr_stmt|;
name|span_set
operator|->
name|diff
operator|=
name|quad
operator|->
name|diff
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|span_row_width
operator|=
literal|0
init|;
name|count
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|count
index|]
operator|.
name|block_span_info
operator|.
name|noElements
operator|>=
name|element
operator|+
literal|1
condition|)
block|{
name|span_set
operator|->
name|strip_offset
index|[
name|count
index|]
operator|=
name|span_row_width
expr_stmt|;
name|span_row_width
operator|+=
name|MR_LdSpanPtrGet
argument_list|(
name|ld
argument_list|,
name|count
argument_list|,
name|map
argument_list|)
operator|->
name|spanRowDataSize
expr_stmt|;
if|#
directive|if
name|SPAN_DEBUG
name|printf
argument_list|(
literal|"LSI Debug span %x rowDataSize %x\n"
argument_list|,
name|count
argument_list|,
name|MR_LdSpanPtrGet
argument_list|(
name|ld
argument_list|,
name|count
argument_list|,
name|map
argument_list|)
operator|->
name|spanRowDataSize
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|span_set
operator|->
name|span_row_data_width
operator|=
name|span_row_width
expr_stmt|;
name|span_row
operator|=
name|mega_div64_32
argument_list|(
operator|(
operator|(
name|quad
operator|->
name|logEnd
operator|-
name|quad
operator|->
name|logStart
operator|)
operator|+
name|quad
operator|->
name|diff
operator|)
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
literal|0
condition|)
block|{
name|span_set
operator|->
name|log_start_lba
operator|=
literal|0
expr_stmt|;
name|span_set
operator|->
name|log_end_lba
operator|=
operator|(
operator|(
name|span_row
operator|<<
name|raid
operator|->
name|stripeShift
operator|)
operator|*
name|span_row_width
operator|)
operator|-
literal|1
expr_stmt|;
name|span_set
operator|->
name|span_row_start
operator|=
literal|0
expr_stmt|;
name|span_set
operator|->
name|span_row_end
operator|=
name|span_row
operator|-
literal|1
expr_stmt|;
name|span_set
operator|->
name|data_strip_start
operator|=
literal|0
expr_stmt|;
name|span_set
operator|->
name|data_strip_end
operator|=
operator|(
name|span_row
operator|*
name|span_row_width
operator|)
operator|-
literal|1
expr_stmt|;
name|span_set
operator|->
name|data_row_start
operator|=
literal|0
expr_stmt|;
name|span_set
operator|->
name|data_row_end
operator|=
operator|(
name|span_row
operator|*
name|quad
operator|->
name|diff
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|span_set_prev
operator|=
operator|&
operator|(
name|ldSpanInfo
index|[
name|ld
index|]
operator|.
name|span_set
index|[
name|element
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|span_set
operator|->
name|log_start_lba
operator|=
name|span_set_prev
operator|->
name|log_end_lba
operator|+
literal|1
expr_stmt|;
name|span_set
operator|->
name|log_end_lba
operator|=
name|span_set
operator|->
name|log_start_lba
operator|+
operator|(
operator|(
name|span_row
operator|<<
name|raid
operator|->
name|stripeShift
operator|)
operator|*
name|span_row_width
operator|)
operator|-
literal|1
expr_stmt|;
name|span_set
operator|->
name|span_row_start
operator|=
name|span_set_prev
operator|->
name|span_row_end
operator|+
literal|1
expr_stmt|;
name|span_set
operator|->
name|span_row_end
operator|=
name|span_set
operator|->
name|span_row_start
operator|+
name|span_row
operator|-
literal|1
expr_stmt|;
name|span_set
operator|->
name|data_strip_start
operator|=
name|span_set_prev
operator|->
name|data_strip_end
operator|+
literal|1
expr_stmt|;
name|span_set
operator|->
name|data_strip_end
operator|=
name|span_set
operator|->
name|data_strip_start
operator|+
operator|(
name|span_row
operator|*
name|span_row_width
operator|)
operator|-
literal|1
expr_stmt|;
name|span_set
operator|->
name|data_row_start
operator|=
name|span_set_prev
operator|->
name|data_row_end
operator|+
literal|1
expr_stmt|;
name|span_set
operator|->
name|data_row_end
operator|=
name|span_set
operator|->
name|data_row_start
operator|+
operator|(
name|span_row
operator|*
name|quad
operator|->
name|diff
operator|)
operator|-
literal|1
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|span
operator|==
name|raid
operator|->
name|spanDepth
condition|)
break|break;
comment|// no quads remain
block|}
block|}
if|#
directive|if
name|SPAN_DEBUG
name|getSpanInfo
argument_list|(
name|map
argument_list|,
name|ldSpanInfo
argument_list|)
expr_stmt|;
comment|//to get span set info
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * mrsas_update_load_balance_params:  Update load balance parmas    * Inputs:                         map pointer   *                                 Load balance info   *                                 io_info pointer  *  * This function updates the load balance parameters for the LD config  * of a two drive optimal RAID-1.    */
end_comment

begin_function
name|void
name|mrsas_update_load_balance_params
parameter_list|(
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|)
block|{
name|int
name|ldCount
decl_stmt|;
name|u_int16_t
name|ld
decl_stmt|;
name|u_int32_t
name|pd
decl_stmt|,
name|arRef
decl_stmt|;
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
for|for
control|(
name|ldCount
operator|=
literal|0
init|;
name|ldCount
operator|<
name|MAX_LOGICAL_DRIVES
condition|;
name|ldCount
operator|++
control|)
block|{
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|ldCount
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|>=
name|MAX_LOGICAL_DRIVES
condition|)
block|{
name|lbInfo
index|[
name|ldCount
index|]
operator|.
name|loadBalanceFlag
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Two drive Optimal RAID 1 */
if|if
condition|(
operator|(
name|raid
operator|->
name|level
operator|==
literal|1
operator|)
operator|&&
operator|(
name|raid
operator|->
name|rowSize
operator|==
literal|2
operator|)
operator|&&
operator|(
name|raid
operator|->
name|spanDepth
operator|==
literal|1
operator|)
operator|&&
name|raid
operator|->
name|ldState
operator|==
name|MR_LD_STATE_OPTIMAL
condition|)
block|{
name|lbInfo
index|[
name|ldCount
index|]
operator|.
name|loadBalanceFlag
operator|=
literal|1
expr_stmt|;
comment|/* Get the array on which this span is present */
name|arRef
operator|=
name|MR_LdSpanArrayGet
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Get the PD */
name|pd
operator|=
name|MR_ArPdGet
argument_list|(
name|arRef
argument_list|,
literal|0
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Get dev handle from PD */
name|lbInfo
index|[
name|ldCount
index|]
operator|.
name|raid1DevHandle
index|[
literal|0
index|]
operator|=
name|MR_PdDevHandleGet
argument_list|(
name|pd
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|pd
operator|=
name|MR_ArPdGet
argument_list|(
name|arRef
argument_list|,
literal|1
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|lbInfo
index|[
name|ldCount
index|]
operator|.
name|raid1DevHandle
index|[
literal|1
index|]
operator|=
name|MR_PdDevHandleGet
argument_list|(
name|pd
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
else|else
name|lbInfo
index|[
name|ldCount
index|]
operator|.
name|loadBalanceFlag
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * mrsas_set_pd_lba:    Sets PD LBA  * input:               io_request pointer  *                      CDB length  *                      io_info pointer  *                      Pointer to CCB  *                      Local RAID map pointer  *                      Start block of IO  *                      Block Size  *  * Used to set the PD logical block address in CDB for FP IOs.  */
end_comment

begin_function
name|void
name|mrsas_set_pd_lba
parameter_list|(
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
parameter_list|,
name|u_int8_t
name|cdb_len
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|local_map_ptr
parameter_list|,
name|u_int32_t
name|ref_tag
parameter_list|,
name|u_int32_t
name|ld_block_size
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
name|u_int32_t
name|ld
decl_stmt|;
name|u_int64_t
name|start_blk
init|=
name|io_info
operator|->
name|pdBlock
decl_stmt|;
name|u_int8_t
modifier|*
name|cdb
init|=
name|io_request
operator|->
name|CDB
operator|.
name|CDB32
decl_stmt|;
name|u_int32_t
name|num_blocks
init|=
name|io_info
operator|->
name|numBlocks
decl_stmt|;
name|u_int8_t
name|opcode
init|=
literal|0
decl_stmt|,
name|flagvals
init|=
literal|0
decl_stmt|,
name|groupnum
init|=
literal|0
decl_stmt|,
name|control
init|=
literal|0
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
decl_stmt|;
comment|/* Check if T10 PI (DIF) is enabled for this LD */
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|io_info
operator|->
name|ldTgtId
argument_list|,
name|local_map_ptr
argument_list|)
expr_stmt|;
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|local_map_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|raid
operator|->
name|capability
operator|.
name|ldPiMode
operator|==
name|MR_PROT_INFO_TYPE_CONTROLLER
condition|)
block|{
name|memset
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|io_request
operator|->
name|CDB
operator|.
name|CDB32
argument_list|)
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
name|MRSAS_SCSI_VARIABLE_LENGTH_CMD
expr_stmt|;
name|cdb
index|[
literal|7
index|]
operator|=
name|MRSAS_SCSI_ADDL_CDB_LEN
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|flags
operator|==
name|CAM_DIR_OUT
condition|)
name|cdb
index|[
literal|9
index|]
operator|=
name|MRSAS_SCSI_SERVICE_ACTION_READ32
expr_stmt|;
else|else
name|cdb
index|[
literal|9
index|]
operator|=
name|MRSAS_SCSI_SERVICE_ACTION_WRITE32
expr_stmt|;
name|cdb
index|[
literal|10
index|]
operator|=
name|MRSAS_RD_WR_PROTECT_CHECK_ALL
expr_stmt|;
comment|/* LBA */
name|cdb
index|[
literal|12
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|56
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|13
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|48
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|14
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|40
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|15
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|32
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|16
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|17
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|18
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|19
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|start_blk
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Logical block reference tag */
name|io_request
operator|->
name|CDB
operator|.
name|EEDP32
operator|.
name|PrimaryReferenceTag
operator|=
name|swap32
argument_list|(
name|ref_tag
argument_list|)
expr_stmt|;
name|io_request
operator|->
name|CDB
operator|.
name|EEDP32
operator|.
name|PrimaryApplicationTagMask
operator|=
literal|0xffff
expr_stmt|;
name|io_request
operator|->
name|IoFlags
operator|=
literal|32
expr_stmt|;
comment|/* Specify 32-byte cdb */
comment|/* Transfer length */
name|cdb
index|[
literal|28
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|29
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|30
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|31
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|num_blocks
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* set SCSI IO EEDP Flags */
if|if
condition|(
name|ccb_h
operator|->
name|flags
operator|==
name|CAM_DIR_OUT
condition|)
block|{
name|io_request
operator|->
name|EEDPFlags
operator|=
name|MPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG
operator||
name|MPI2_SCSIIO_EEDPFLAGS_CHECK_REFTAG
operator||
name|MPI2_SCSIIO_EEDPFLAGS_CHECK_REMOVE_OP
operator||
name|MPI2_SCSIIO_EEDPFLAGS_CHECK_APPTAG
operator||
name|MPI2_SCSIIO_EEDPFLAGS_CHECK_GUARD
expr_stmt|;
block|}
else|else
block|{
name|io_request
operator|->
name|EEDPFlags
operator|=
name|MPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG
operator||
name|MPI2_SCSIIO_EEDPFLAGS_INSERT_OP
expr_stmt|;
block|}
name|io_request
operator|->
name|Control
operator||=
operator|(
literal|0x4
operator|<<
literal|26
operator|)
expr_stmt|;
name|io_request
operator|->
name|EEDPBlockSize
operator|=
name|ld_block_size
expr_stmt|;
block|}
else|else
block|{
comment|/* Some drives don't support 16/12 byte CDB's, convert to 10 */
if|if
condition|(
operator|(
operator|(
name|cdb_len
operator|==
literal|12
operator|)
operator|||
operator|(
name|cdb_len
operator|==
literal|16
operator|)
operator|)
operator|&&
operator|(
name|start_blk
operator|<=
literal|0xffffffff
operator|)
condition|)
block|{
if|if
condition|(
name|cdb_len
operator|==
literal|16
condition|)
block|{
name|opcode
operator|=
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_16
condition|?
name|READ_10
else|:
name|WRITE_10
expr_stmt|;
name|flagvals
operator|=
name|cdb
index|[
literal|1
index|]
expr_stmt|;
name|groupnum
operator|=
name|cdb
index|[
literal|14
index|]
expr_stmt|;
name|control
operator|=
name|cdb
index|[
literal|15
index|]
expr_stmt|;
block|}
else|else
block|{
name|opcode
operator|=
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_12
condition|?
name|READ_10
else|:
name|WRITE_10
expr_stmt|;
name|flagvals
operator|=
name|cdb
index|[
literal|1
index|]
expr_stmt|;
name|groupnum
operator|=
name|cdb
index|[
literal|10
index|]
expr_stmt|;
name|control
operator|=
name|cdb
index|[
literal|11
index|]
expr_stmt|;
block|}
name|memset
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|io_request
operator|->
name|CDB
operator|.
name|CDB32
argument_list|)
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
name|opcode
expr_stmt|;
name|cdb
index|[
literal|1
index|]
operator|=
name|flagvals
expr_stmt|;
name|cdb
index|[
literal|6
index|]
operator|=
name|groupnum
expr_stmt|;
name|cdb
index|[
literal|9
index|]
operator|=
name|control
expr_stmt|;
comment|/* Transfer length */
name|cdb
index|[
literal|8
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|num_blocks
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|7
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|io_request
operator|->
name|IoFlags
operator|=
literal|10
expr_stmt|;
comment|/* Specify 10-byte cdb */
name|cdb_len
operator|=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cdb_len
operator|<
literal|16
operator|)
operator|&&
operator|(
name|start_blk
operator|>
literal|0xffffffff
operator|)
condition|)
block|{
comment|/* Convert to 16 byte CDB for large LBA's */
switch|switch
condition|(
name|cdb_len
condition|)
block|{
case|case
literal|6
case|:
name|opcode
operator|=
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_6
condition|?
name|READ_16
else|:
name|WRITE_16
expr_stmt|;
name|control
operator|=
name|cdb
index|[
literal|5
index|]
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|opcode
operator|=
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_10
condition|?
name|READ_16
else|:
name|WRITE_16
expr_stmt|;
name|flagvals
operator|=
name|cdb
index|[
literal|1
index|]
expr_stmt|;
name|groupnum
operator|=
name|cdb
index|[
literal|6
index|]
expr_stmt|;
name|control
operator|=
name|cdb
index|[
literal|9
index|]
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|opcode
operator|=
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_12
condition|?
name|READ_16
else|:
name|WRITE_16
expr_stmt|;
name|flagvals
operator|=
name|cdb
index|[
literal|1
index|]
expr_stmt|;
name|groupnum
operator|=
name|cdb
index|[
literal|10
index|]
expr_stmt|;
name|control
operator|=
name|cdb
index|[
literal|11
index|]
expr_stmt|;
break|break;
block|}
name|memset
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|io_request
operator|->
name|CDB
operator|.
name|CDB32
argument_list|)
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
name|opcode
expr_stmt|;
name|cdb
index|[
literal|1
index|]
operator|=
name|flagvals
expr_stmt|;
name|cdb
index|[
literal|14
index|]
operator|=
name|groupnum
expr_stmt|;
name|cdb
index|[
literal|15
index|]
operator|=
name|control
expr_stmt|;
comment|/* Transfer length */
name|cdb
index|[
literal|13
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|num_blocks
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|12
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|11
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|10
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|io_request
operator|->
name|IoFlags
operator|=
literal|16
expr_stmt|;
comment|/* Specify 16-byte cdb */
name|cdb_len
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cdb_len
operator|==
literal|6
operator|)
operator|&&
operator|(
name|start_blk
operator|>
literal|0x1fffff
operator|)
condition|)
block|{
comment|/* convert to 10 byte CDB */
name|opcode
operator|=
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_6
condition|?
name|READ_10
else|:
name|WRITE_10
expr_stmt|;
name|control
operator|=
name|cdb
index|[
literal|5
index|]
expr_stmt|;
name|memset
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|io_request
operator|->
name|CDB
operator|.
name|CDB32
argument_list|)
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
name|opcode
expr_stmt|;
name|cdb
index|[
literal|9
index|]
operator|=
name|control
expr_stmt|;
comment|/* Set transfer length */
name|cdb
index|[
literal|8
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|num_blocks
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|7
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Specify 10-byte cdb */
name|cdb_len
operator|=
literal|10
expr_stmt|;
block|}
comment|/* Fall through normal case, just load LBA here */
switch|switch
condition|(
name|cdb_len
condition|)
block|{
case|case
literal|6
case|:
block|{
name|u_int8_t
name|val
init|=
name|cdb
index|[
literal|1
index|]
operator|&
literal|0xE0
decl_stmt|;
name|cdb
index|[
literal|3
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|start_blk
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|2
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|1
index|]
operator|=
name|val
operator||
operator|(
call|(
name|u_int8_t
call|)
argument_list|(
name|start_blk
operator|>>
literal|16
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
break|break;
block|}
case|case
literal|10
case|:
name|cdb
index|[
literal|5
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|start_blk
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|4
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|3
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|2
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|cdb
index|[
literal|5
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|start_blk
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|4
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|3
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|2
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|cdb
index|[
literal|9
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|start_blk
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|8
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|7
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|6
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|5
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|32
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|4
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|40
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|3
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|48
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|2
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|56
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * mrsas_get_best_arm         Determine the best spindle arm    * Inputs:                    Load balance info   *  * This function determines and returns the best arm by looking at the  * parameters of the last PD access.  */
end_comment

begin_function
name|u_int8_t
name|mrsas_get_best_arm
parameter_list|(
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|,
name|u_int8_t
name|arm
parameter_list|,
name|u_int64_t
name|block
parameter_list|,
name|u_int32_t
name|count
parameter_list|)
block|{
name|u_int16_t
name|pend0
decl_stmt|,
name|pend1
decl_stmt|;
name|u_int64_t
name|diff0
decl_stmt|,
name|diff1
decl_stmt|;
name|u_int8_t
name|bestArm
decl_stmt|;
comment|/* get the pending cmds for the data and mirror arms */
name|pend0
operator|=
name|atomic_read
argument_list|(
operator|&
name|lbInfo
operator|->
name|scsi_pending_cmds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pend1
operator|=
name|atomic_read
argument_list|(
operator|&
name|lbInfo
operator|->
name|scsi_pending_cmds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Determine the disk whose head is nearer to the req. block */
name|diff0
operator|=
name|ABS_DIFF
argument_list|(
name|block
argument_list|,
name|lbInfo
operator|->
name|last_accessed_block
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|diff1
operator|=
name|ABS_DIFF
argument_list|(
name|block
argument_list|,
name|lbInfo
operator|->
name|last_accessed_block
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bestArm
operator|=
operator|(
name|diff0
operator|<=
name|diff1
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bestArm
operator|==
name|arm
operator|&&
name|pend0
operator|>
name|pend1
operator|+
literal|16
operator|)
operator|||
operator|(
name|bestArm
operator|!=
name|arm
operator|&&
name|pend1
operator|>
name|pend0
operator|+
literal|16
operator|)
condition|)
name|bestArm
operator|^=
literal|1
expr_stmt|;
comment|/* Update the last accessed block on the correct pd */
name|lbInfo
operator|->
name|last_accessed_block
index|[
name|bestArm
index|]
operator|=
name|block
operator|+
name|count
operator|-
literal|1
expr_stmt|;
return|return
name|bestArm
return|;
block|}
end_function

begin_comment
comment|/**  * mrsas_get_updated_dev_handle    Get the update dev handle    * Inputs:                         Load balance info   *                                 io_info pointer  *  * This function determines and returns the updated dev handle.  */
end_comment

begin_function
name|u_int16_t
name|mrsas_get_updated_dev_handle
parameter_list|(
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|)
block|{
name|u_int8_t
name|arm
decl_stmt|,
name|old_arm
decl_stmt|;
name|u_int16_t
name|devHandle
decl_stmt|;
name|old_arm
operator|=
name|lbInfo
operator|->
name|raid1DevHandle
index|[
literal|0
index|]
operator|==
name|io_info
operator|->
name|devHandle
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/* get best new arm */
name|arm
operator|=
name|mrsas_get_best_arm
argument_list|(
name|lbInfo
argument_list|,
name|old_arm
argument_list|,
name|io_info
operator|->
name|ldStartBlock
argument_list|,
name|io_info
operator|->
name|numBlocks
argument_list|)
expr_stmt|;
name|devHandle
operator|=
name|lbInfo
operator|->
name|raid1DevHandle
index|[
name|arm
index|]
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|lbInfo
operator|->
name|scsi_pending_cmds
index|[
name|arm
index|]
argument_list|)
expr_stmt|;
return|return
name|devHandle
return|;
block|}
end_function

begin_comment
comment|/**  * MR_GetPhyParams     Calculates arm, span, and block  * Inputs:             Adapter instance soft state   *                     Logical drive number (LD)   *                     Stripe number (stripRow)  *                     Reference in stripe (stripRef)  * Outputs:            Span number  *                     Absolute Block number in the physical disk   *  * This routine calculates the arm, span and block for the specified stripe  * and reference in stripe.  */
end_comment

begin_function
name|u_int8_t
name|MR_GetPhyParams
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|stripRow
parameter_list|,
name|u_int16_t
name|stripRef
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|RAID_CONTEXT
modifier|*
name|pRAID_Context
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|u_int32_t
name|pd
decl_stmt|,
name|arRef
decl_stmt|;
name|u_int8_t
name|physArm
decl_stmt|,
name|span
decl_stmt|;
name|u_int64_t
name|row
decl_stmt|;
name|u_int8_t
name|retval
init|=
name|TRUE
decl_stmt|;
name|int
name|error_code
init|=
literal|0
decl_stmt|;
name|u_int64_t
modifier|*
name|pdBlock
init|=
operator|&
name|io_info
operator|->
name|pdBlock
decl_stmt|;
name|u_int16_t
modifier|*
name|pDevHandle
init|=
operator|&
name|io_info
operator|->
name|devHandle
decl_stmt|;
name|u_int32_t
name|rowMod
decl_stmt|,
name|armQ
decl_stmt|,
name|arm
decl_stmt|,
name|logArm
decl_stmt|;
name|u_int8_t
name|do_invader
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_INVADER
operator|)
operator|||
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_FURY
operator|)
condition|)
name|do_invader
operator|=
literal|1
expr_stmt|;
name|row
operator|=
name|mega_div64_32
argument_list|(
name|stripRow
argument_list|,
name|raid
operator|->
name|rowDataSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|raid
operator|->
name|level
operator|==
literal|6
condition|)
block|{
name|logArm
operator|=
name|mega_mod64
argument_list|(
name|stripRow
argument_list|,
name|raid
operator|->
name|rowDataSize
argument_list|)
expr_stmt|;
comment|// logical arm within row
if|if
condition|(
name|raid
operator|->
name|rowSize
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|rowMod
operator|=
name|mega_mod64
argument_list|(
name|row
argument_list|,
name|raid
operator|->
name|rowSize
argument_list|)
expr_stmt|;
comment|// get logical row mod
name|armQ
operator|=
name|raid
operator|->
name|rowSize
operator|-
literal|1
operator|-
name|rowMod
expr_stmt|;
comment|// index of Q drive
name|arm
operator|=
name|armQ
operator|+
literal|1
operator|+
name|logArm
expr_stmt|;
comment|// data always logically follows Q
if|if
condition|(
name|arm
operator|>=
name|raid
operator|->
name|rowSize
condition|)
comment|// handle wrap condition
name|arm
operator|-=
name|raid
operator|->
name|rowSize
expr_stmt|;
name|physArm
operator|=
operator|(
name|u_int8_t
operator|)
name|arm
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|raid
operator|->
name|modFactor
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|physArm
operator|=
name|MR_LdDataArmGet
argument_list|(
name|ld
argument_list|,
name|mega_mod64
argument_list|(
name|stripRow
argument_list|,
name|raid
operator|->
name|modFactor
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|raid
operator|->
name|spanDepth
operator|==
literal|1
condition|)
block|{
name|span
operator|=
literal|0
expr_stmt|;
operator|*
name|pdBlock
operator|=
name|row
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
block|}
else|else
block|{
name|span
operator|=
operator|(
name|u_int8_t
operator|)
name|MR_GetSpanBlock
argument_list|(
name|ld
argument_list|,
name|row
argument_list|,
name|pdBlock
argument_list|,
name|map
argument_list|,
operator|&
name|error_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_code
operator|==
literal|1
condition|)
return|return
name|FALSE
return|;
block|}
comment|/*  Get the array on which this span is present */
name|arRef
operator|=
name|MR_LdSpanArrayGet
argument_list|(
name|ld
argument_list|,
name|span
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|pd
operator|=
name|MR_ArPdGet
argument_list|(
name|arRef
argument_list|,
name|physArm
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|// Get the Pd.
if|if
condition|(
name|pd
operator|!=
name|MR_PD_INVALID
condition|)
operator|*
name|pDevHandle
operator|=
name|MR_PdDevHandleGet
argument_list|(
name|pd
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|// Get dev handle from Pd.
else|else
block|{
operator|*
name|pDevHandle
operator|=
name|MR_PD_INVALID
expr_stmt|;
comment|// set dev handle as invalid.
if|if
condition|(
operator|(
name|raid
operator|->
name|level
operator|>=
literal|5
operator|)
operator|&&
operator|(
operator|(
operator|!
name|do_invader
operator|)
operator|||
operator|(
name|do_invader
operator|&&
name|raid
operator|->
name|regTypeReqOnRead
operator|!=
name|REGION_TYPE_UNUSED
operator|)
operator|)
condition|)
name|pRAID_Context
operator|->
name|regLockFlags
operator|=
name|REGION_TYPE_EXCLUSIVE
expr_stmt|;
elseif|else
if|if
condition|(
name|raid
operator|->
name|level
operator|==
literal|1
condition|)
block|{
name|pd
operator|=
name|MR_ArPdGet
argument_list|(
name|arRef
argument_list|,
name|physArm
operator|+
literal|1
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|// Get Alternate Pd.
if|if
condition|(
name|pd
operator|!=
name|MR_PD_INVALID
condition|)
operator|*
name|pDevHandle
operator|=
name|MR_PdDevHandleGet
argument_list|(
name|pd
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|//Get dev handle from Pd.
block|}
block|}
operator|*
name|pdBlock
operator|+=
name|stripRef
operator|+
name|MR_LdSpanPtrGet
argument_list|(
name|ld
argument_list|,
name|span
argument_list|,
name|map
argument_list|)
operator|->
name|startBlk
expr_stmt|;
name|pRAID_Context
operator|->
name|spanArm
operator|=
operator|(
name|span
operator|<<
name|RAID_CTX_SPANARM_SPAN_SHIFT
operator|)
operator||
name|physArm
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/**  * MR_GetSpanBlock     Calculates span block  * Inputs:             LD   *                     row  *                     PD span block  *                     RAID map pointer  * Outputs:            Span number  *                     Error code   *  * This routine calculates the span from the span block info.    */
end_comment

begin_function
name|u_int32_t
name|MR_GetSpanBlock
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|row
parameter_list|,
name|u_int64_t
modifier|*
name|span_blk
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|int
modifier|*
name|div_error
parameter_list|)
block|{
name|MR_SPAN_BLOCK_INFO
modifier|*
name|pSpanBlock
init|=
name|MR_LdSpanInfoGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|MR_QUAD_ELEMENT
modifier|*
name|quad
decl_stmt|;
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|u_int32_t
name|span
decl_stmt|,
name|j
decl_stmt|;
name|u_int64_t
name|blk
decl_stmt|,
name|debugBlk
decl_stmt|;
for|for
control|(
name|span
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
operator|,
name|pSpanBlock
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pSpanBlock
operator|->
name|block_span_info
operator|.
name|noElements
condition|;
name|j
operator|++
control|)
block|{
name|quad
operator|=
operator|&
name|pSpanBlock
operator|->
name|block_span_info
operator|.
name|quad
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|quad
operator|->
name|diff
operator|==
literal|0
condition|)
block|{
operator|*
name|div_error
operator|=
literal|1
expr_stmt|;
return|return
name|span
return|;
block|}
if|if
condition|(
name|quad
operator|->
name|logStart
operator|<=
name|row
operator|&&
name|row
operator|<=
name|quad
operator|->
name|logEnd
operator|&&
operator|(
name|mega_mod64
argument_list|(
name|row
operator|-
name|quad
operator|->
name|logStart
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|span_blk
operator|!=
name|NULL
condition|)
block|{
name|blk
operator|=
name|mega_div64_32
argument_list|(
operator|(
name|row
operator|-
name|quad
operator|->
name|logStart
operator|)
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
expr_stmt|;
name|debugBlk
operator|=
name|blk
expr_stmt|;
name|blk
operator|=
operator|(
name|blk
operator|+
name|quad
operator|->
name|offsetInSpan
operator|)
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
operator|*
name|span_blk
operator|=
name|blk
expr_stmt|;
block|}
return|return
name|span
return|;
block|}
block|}
block|}
return|return
name|span
return|;
block|}
end_function

end_unit

