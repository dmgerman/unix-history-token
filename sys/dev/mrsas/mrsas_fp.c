begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2014, LSI Corp. All rights reserved. Author: Marian Choy  * Support: freebsdraid@lsi.com  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  * 1. Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer. 2. Redistributions  * in binary form must reproduce the above copyright notice, this list of  * conditions and the following disclaimer in the documentation and/or other  * materials provided with the distribution. 3. Neither the name of the  *<ORGANIZATION> nor the names of its contributors may be used to endorse or  * promote products derived from this software without specific prior written  * permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing  * official policies,either expressed or implied, of the FreeBSD Project.  *  * Send feedback to:<megaraidfbsd@lsi.com> Mail to: LSI Corporation, 1621  * Barber Lane, Milpitas, CA 95035 ATTN: MegaRaid FreeBSD  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/mrsas/mrsas.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
name|u_int8_t
name|MR_ValidateMapInfo
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int8_t
name|mrsas_get_best_arm_pd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int8_t
name|MR_BuildRaidContext
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|RAID_CONTEXT
modifier|*
name|pRAID_Context
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int8_t
name|MR_GetPhyParams
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|stripRow
parameter_list|,
name|u_int16_t
name|stripRef
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|RAID_CONTEXT
modifier|*
name|pRAID_Context
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int16_t
name|MR_TargetIdToLdGet
parameter_list|(
name|u_int32_t
name|ldTgtId
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int32_t
name|MR_LdBlockSizeGet
parameter_list|(
name|u_int32_t
name|ldTgtId
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int16_t
name|MR_GetLDTgtId
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int16_t
name|mrsas_get_updated_dev_handle
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int32_t
name|mega_mod64
parameter_list|(
name|u_int64_t
name|dividend
parameter_list|,
name|u_int32_t
name|divisor
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int32_t
name|MR_GetSpanBlock
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|row
parameter_list|,
name|u_int64_t
modifier|*
name|span_blk
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|int
modifier|*
name|div_error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int64_t
name|mega_div64_32
parameter_list|(
name|u_int64_t
name|dividend
parameter_list|,
name|u_int32_t
name|divisor
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_update_load_balance_params
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mrsas_set_pd_lba
parameter_list|(
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
parameter_list|,
name|u_int8_t
name|cdb_len
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|local_map_ptr
parameter_list|,
name|u_int32_t
name|ref_tag
parameter_list|,
name|u_int32_t
name|ld_block_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|MR_LdSpanArrayGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int32_t
name|span
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|MR_PdDevHandleGet
parameter_list|(
name|u_int32_t
name|pd
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|MR_ArPdGet
parameter_list|(
name|u_int32_t
name|ar
parameter_list|,
name|u_int32_t
name|arm
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MR_LD_SPAN
modifier|*
name|MR_LdSpanPtrGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int32_t
name|span
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|MR_LdDataArmGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int32_t
name|armIdx
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MR_SPAN_BLOCK_INFO
modifier|*
name|MR_LdSpanInfoGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|MR_LD_RAID
modifier|*
name|MR_LdRaidGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|MR_PopulateDrvRaidMap
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Spanset related function prototypes Added for PRL11 configuration (Uneven  * span support)  */
end_comment

begin_function_decl
name|void
name|mr_update_span_set
parameter_list|(
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|PLD_SPAN_INFO
name|ldSpanInfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|mr_spanset_get_phy_params
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|stripRow
parameter_list|,
name|u_int16_t
name|stripRef
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|RAID_CONTEXT
modifier|*
name|pRAID_Context
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int64_t
name|get_row_from_strip
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|strip
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|mr_spanset_get_span_block
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|row
parameter_list|,
name|u_int64_t
modifier|*
name|span_blk
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|int
modifier|*
name|div_error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|get_arm
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int8_t
name|span
parameter_list|,
name|u_int64_t
name|stripe
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Spanset related defines Added for PRL11 configuration(Uneven span support)  */
end_comment

begin_define
define|#
directive|define
name|SPAN_ROW_SIZE
parameter_list|(
name|map
parameter_list|,
name|ld
parameter_list|,
name|index_
parameter_list|)
value|MR_LdSpanPtrGet(ld, index_, map)->spanRowSize
end_define

begin_define
define|#
directive|define
name|SPAN_ROW_DATA_SIZE
parameter_list|(
name|map_
parameter_list|,
name|ld
parameter_list|,
name|index_
parameter_list|)
define|\
value|MR_LdSpanPtrGet(ld, index_, map)->spanRowDataSize
end_define

begin_define
define|#
directive|define
name|SPAN_INVALID
value|0xff
end_define

begin_define
define|#
directive|define
name|SPAN_DEBUG
value|0
end_define

begin_comment
comment|/*  * Related Defines  */
end_comment

begin_typedef
typedef|typedef
name|u_int64_t
name|REGION_KEY
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|u_int32_t
name|REGION_LEN
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MR_LD_STATE_OPTIMAL
value|3
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|LB_PENDING_CMDS_DEFAULT
value|4
end_define

begin_comment
comment|/*  * Related Macros  */
end_comment

begin_define
define|#
directive|define
name|ABS_DIFF
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|( ((a)> (b)) ? ((a) - (b)) : ((b) - (a)) )
end_define

begin_define
define|#
directive|define
name|swap32
parameter_list|(
name|x
parameter_list|)
define|\
value|((unsigned int)( \     (((unsigned int)(x)& (unsigned int)0x000000ffUL)<< 24) | \     (((unsigned int)(x)& (unsigned int)0x0000ff00UL)<<  8) | \     (((unsigned int)(x)& (unsigned int)0x00ff0000UL)>>  8) | \     (((unsigned int)(x)& (unsigned int)0xff000000UL)>> 24) ))
end_define

begin_comment
comment|/*  * In-line functions for mod and divide of 64-bit dividend and 32-bit  * divisor. Assumes a check for a divisor of zero is not possible.  *  * @param dividend:	Dividend  * @param divisor:	Divisor  * @return			remainder  */
end_comment

begin_define
define|#
directive|define
name|mega_mod64
parameter_list|(
name|dividend
parameter_list|,
name|divisor
parameter_list|)
value|({ \ int remainder; \ remainder = ((u_int64_t) (dividend)) % (u_int32_t) (divisor); \ remainder;})
end_define

begin_define
define|#
directive|define
name|mega_div64_32
parameter_list|(
name|dividend
parameter_list|,
name|divisor
parameter_list|)
value|({ \ int quotient; \ quotient = ((u_int64_t) (dividend)) / (u_int32_t) (divisor); \ quotient;})
end_define

begin_comment
comment|/*  * Various RAID map access functions.  These functions access the various  * parts of the RAID map and returns the appropriate parameters.  */
end_comment

begin_function
name|MR_LD_RAID
modifier|*
name|MR_LdRaidGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
operator|(
operator|&
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|ldRaid
operator|)
return|;
block|}
end_function

begin_function
name|u_int16_t
name|MR_GetLDTgtId
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
operator|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|ldRaid
operator|.
name|targetId
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|MR_LdSpanArrayGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int32_t
name|span
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|span
operator|.
name|arrayRef
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|MR_LdDataArmGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int32_t
name|armIdx
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|dataArmMap
index|[
name|armIdx
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|MR_PdDevHandleGet
parameter_list|(
name|u_int32_t
name|pd
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
name|map
operator|->
name|raidMap
operator|.
name|devHndlInfo
index|[
name|pd
index|]
operator|.
name|curDevHdl
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|MR_ArPdGet
parameter_list|(
name|u_int32_t
name|ar
parameter_list|,
name|u_int32_t
name|arm
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
name|map
operator|->
name|raidMap
operator|.
name|arMapInfo
index|[
name|ar
index|]
operator|.
name|pd
index|[
name|arm
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|MR_LD_SPAN
modifier|*
name|MR_LdSpanPtrGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int32_t
name|span
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
operator|&
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|span
return|;
block|}
end_function

begin_function
specifier|static
name|MR_SPAN_BLOCK_INFO
modifier|*
name|MR_LdSpanInfoGet
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
operator|&
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|u_int16_t
name|MR_TargetIdToLdGet
parameter_list|(
name|u_int32_t
name|ldTgtId
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
return|return
name|map
operator|->
name|raidMap
operator|.
name|ldTgtIdToLd
index|[
name|ldTgtId
index|]
return|;
block|}
end_function

begin_function
name|u_int32_t
name|MR_LdBlockSizeGet
parameter_list|(
name|u_int32_t
name|ldTgtId
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
name|u_int32_t
name|ld
decl_stmt|,
name|ldBlockSize
init|=
name|MRSAS_SCSIBLOCKSIZE
decl_stmt|;
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|ldTgtId
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* 	 * Check if logical drive was removed. 	 */
if|if
condition|(
name|ld
operator|>=
name|MAX_LOGICAL_DRIVES
condition|)
return|return
name|ldBlockSize
return|;
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|ldBlockSize
operator|=
name|raid
operator|->
name|logicalBlockLength
expr_stmt|;
if|if
condition|(
operator|!
name|ldBlockSize
condition|)
name|ldBlockSize
operator|=
name|MRSAS_SCSIBLOCKSIZE
expr_stmt|;
return|return
name|ldBlockSize
return|;
block|}
end_function

begin_comment
comment|/*  * This function will Populate Driver Map using firmware raid map  */
end_comment

begin_function
name|void
name|MR_PopulateDrvRaidMap
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|MR_FW_RAID_MAP_ALL
modifier|*
name|fw_map_old
init|=
name|NULL
decl_stmt|;
name|MR_FW_RAID_MAP
modifier|*
name|pFwRaidMap
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|drv_map
init|=
name|sc
operator|->
name|ld_drv_map
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
decl_stmt|;
name|MR_DRV_RAID_MAP
modifier|*
name|pDrvRaidMap
init|=
operator|&
name|drv_map
operator|->
name|raidMap
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|max256vdSupport
condition|)
block|{
name|memcpy
argument_list|(
name|sc
operator|->
name|ld_drv_map
index|[
name|sc
operator|->
name|map_id
operator|&
literal|1
index|]
argument_list|,
name|sc
operator|->
name|raidmap_mem
index|[
name|sc
operator|->
name|map_id
operator|&
literal|1
index|]
argument_list|,
name|sc
operator|->
name|current_map_sz
argument_list|)
expr_stmt|;
comment|/* 		 * New Raid map will not set totalSize, so keep expected 		 * value for legacy code in ValidateMapInfo 		 */
name|pDrvRaidMap
operator|->
name|totalSize
operator|=
sizeof|sizeof
argument_list|(
name|MR_FW_RAID_MAP_EXT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fw_map_old
operator|=
operator|(
name|MR_FW_RAID_MAP_ALL
operator|*
operator|)
name|sc
operator|->
name|raidmap_mem
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
expr_stmt|;
name|pFwRaidMap
operator|=
operator|&
name|fw_map_old
operator|->
name|raidMap
expr_stmt|;
if|#
directive|if
name|VD_EXT_DEBUG
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pFwRaidMap
operator|->
name|ldCount
condition|;
name|i
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"Index 0x%x Target Id 0x%x Seq Num 0x%x Size 0/%lx\n"
argument_list|,
name|i
argument_list|,
name|fw_map_old
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|targetId
argument_list|,
name|fw_map_old
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|seqNum
argument_list|,
name|fw_map_old
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|memset
argument_list|(
name|drv_map
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|drv_map_sz
argument_list|)
expr_stmt|;
name|pDrvRaidMap
operator|->
name|totalSize
operator|=
name|pFwRaidMap
operator|->
name|totalSize
expr_stmt|;
name|pDrvRaidMap
operator|->
name|ldCount
operator|=
name|pFwRaidMap
operator|->
name|ldCount
expr_stmt|;
name|pDrvRaidMap
operator|->
name|fpPdIoTimeoutSec
operator|=
name|pFwRaidMap
operator|->
name|fpPdIoTimeoutSec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_RAIDMAP_LOGICAL_DRIVES
operator|+
name|MAX_RAIDMAP_VIEWS
condition|;
name|i
operator|++
control|)
block|{
name|pDrvRaidMap
operator|->
name|ldTgtIdToLd
index|[
name|i
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|pFwRaidMap
operator|->
name|ldTgtIdToLd
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pDrvRaidMap
operator|->
name|ldCount
condition|;
name|i
operator|++
control|)
block|{
name|pDrvRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|=
name|pFwRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
expr_stmt|;
if|#
directive|if
name|VD_EXT_DEBUG
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"pFwRaidMap->ldSpanMap[%d].ldRaid.targetId 0x%x "
literal|"pFwRaidMap->ldSpanMap[%d].ldRaid.seqNum 0x%x size 0x%x\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|pFwRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|targetId
argument_list|,
name|pFwRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|seqNum
argument_list|,
operator|(
name|u_int32_t
operator|)
name|pFwRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|rowSize
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"pDrvRaidMap->ldSpanMap[%d].ldRaid.targetId 0x%x"
literal|"pDrvRaidMap->ldSpanMap[%d].ldRaid.seqNum 0x%x size 0x%x\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|pDrvRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|targetId
argument_list|,
name|pDrvRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|seqNum
argument_list|,
operator|(
name|u_int32_t
operator|)
name|pDrvRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
operator|.
name|rowSize
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"drv raid map all %p raid map %p LD RAID MAP %p/%p\n"
argument_list|,
name|drv_map
argument_list|,
name|pDrvRaidMap
argument_list|,
operator|&
name|pFwRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
argument_list|,
operator|&
name|pDrvRaidMap
operator|->
name|ldSpanMap
index|[
name|i
index|]
operator|.
name|ldRaid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|memcpy
argument_list|(
name|pDrvRaidMap
operator|->
name|arMapInfo
argument_list|,
name|pFwRaidMap
operator|->
name|arMapInfo
argument_list|,
sizeof|sizeof
argument_list|(
name|MR_ARRAY_INFO
argument_list|)
operator|*
name|MAX_RAIDMAP_ARRAYS
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pDrvRaidMap
operator|->
name|devHndlInfo
argument_list|,
name|pFwRaidMap
operator|->
name|devHndlInfo
argument_list|,
sizeof|sizeof
argument_list|(
name|MR_DEV_HANDLE_INFO
argument_list|)
operator|*
name|MAX_RAIDMAP_PHYSICAL_DEVICES
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * MR_ValidateMapInfo:	Validate RAID map  * input:				Adapter instance soft state  *  * This function checks and validates the loaded RAID map. It returns 0 if  * successful, and 1 otherwise.  */
end_comment

begin_function
name|u_int8_t
name|MR_ValidateMapInfo
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sc
condition|)
block|{
return|return
literal|1
return|;
block|}
name|MR_PopulateDrvRaidMap
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|drv_map
init|=
name|sc
operator|->
name|ld_drv_map
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
decl_stmt|;
name|MR_DRV_RAID_MAP
modifier|*
name|pDrvRaidMap
init|=
operator|&
name|drv_map
operator|->
name|raidMap
decl_stmt|;
name|u_int32_t
name|expected_map_size
decl_stmt|;
name|drv_map
operator|=
name|sc
operator|->
name|ld_drv_map
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
expr_stmt|;
name|pDrvRaidMap
operator|=
operator|&
name|drv_map
operator|->
name|raidMap
expr_stmt|;
name|PLD_SPAN_INFO
name|ldSpanInfo
init|=
operator|(
name|PLD_SPAN_INFO
operator|)
operator|&
name|sc
operator|->
name|log_to_span
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|max256vdSupport
condition|)
name|expected_map_size
operator|=
sizeof|sizeof
argument_list|(
name|MR_FW_RAID_MAP_EXT
argument_list|)
expr_stmt|;
else|else
name|expected_map_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|MR_FW_RAID_MAP
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|MR_LD_SPAN_MAP
argument_list|)
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|MR_LD_SPAN_MAP
argument_list|)
operator|*
name|pDrvRaidMap
operator|->
name|ldCount
operator|)
expr_stmt|;
if|if
condition|(
name|pDrvRaidMap
operator|->
name|totalSize
operator|!=
name|expected_map_size
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"map size %x not matching ld count\n"
argument_list|,
name|expected_map_size
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"span map= %x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
sizeof|sizeof
argument_list|(
name|MR_LD_SPAN_MAP
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mrsas_dev
argument_list|,
literal|"pDrvRaidMap->totalSize=%x\n"
argument_list|,
name|pDrvRaidMap
operator|->
name|totalSize
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|UnevenSpanSupport
condition|)
block|{
name|printf
argument_list|(
literal|"Updating span set\n\n"
argument_list|)
expr_stmt|;
name|mr_update_span_set
argument_list|(
name|drv_map
argument_list|,
name|ldSpanInfo
argument_list|)
expr_stmt|;
block|}
name|mrsas_update_load_balance_params
argument_list|(
name|sc
argument_list|,
name|drv_map
argument_list|,
name|sc
operator|->
name|load_balance_info
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  * Function to print info about span set created in driver from FW raid map  *  * Inputs:		map  * ldSpanInfo:	ld map span info per HBA instance  *  *  */
end_comment

begin_if
if|#
directive|if
name|SPAN_DEBUG
end_if

begin_function
specifier|static
name|int
name|getSpanInfo
parameter_list|(
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|PLD_SPAN_INFO
name|ldSpanInfo
parameter_list|)
block|{
name|u_int8_t
name|span
decl_stmt|;
name|u_int32_t
name|element
decl_stmt|;
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
name|LD_SPAN_SET
modifier|*
name|span_set
decl_stmt|;
name|MR_QUAD_ELEMENT
modifier|*
name|quad
decl_stmt|;
name|int
name|ldCount
decl_stmt|;
name|u_int16_t
name|ld
decl_stmt|;
for|for
control|(
name|ldCount
operator|=
literal|0
init|;
name|ldCount
operator|<
name|MAX_LOGICAL_DRIVES
condition|;
name|ldCount
operator|++
control|)
block|{
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|ldCount
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|>=
name|MAX_LOGICAL_DRIVES
condition|)
block|{
continue|continue;
block|}
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LD %x: span_depth=%x\n"
argument_list|,
name|ld
argument_list|,
name|raid
operator|->
name|spanDepth
argument_list|)
expr_stmt|;
for|for
control|(
name|span
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
control|)
name|printf
argument_list|(
literal|"Span=%x, number of quads=%x\n"
argument_list|,
name|span
argument_list|,
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|noElements
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
literal|0
init|;
name|element
operator|<
name|MAX_QUAD_DEPTH
condition|;
name|element
operator|++
control|)
block|{
name|span_set
operator|=
operator|&
operator|(
name|ldSpanInfo
index|[
name|ld
index|]
operator|.
name|span_set
index|[
name|element
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|span_set
operator|->
name|span_row_data_width
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"Span Set %x: width=%x, diff=%x\n"
argument_list|,
name|element
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|span_row_data_width
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|diff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"logical LBA start=0x%08lx, end=0x%08lx\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|log_start_lba
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|log_end_lba
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"span row start=0x%08lx, end=0x%08lx\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|span_row_start
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|span_row_end
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"data row start=0x%08lx, end=0x%08lx\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|data_row_start
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|data_row_end
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"data strip start=0x%08lx, end=0x%08lx\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|data_strip_start
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|span_set
operator|->
name|data_strip_end
argument_list|)
expr_stmt|;
for|for
control|(
name|span
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
control|)
block|{
if|if
condition|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|noElements
operator|>=
name|element
operator|+
literal|1
condition|)
block|{
name|quad
operator|=
operator|&
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|quad
index|[
name|element
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"Span=%x, Quad=%x, diff=%x\n"
argument_list|,
name|span
argument_list|,
name|element
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"offset_in_span=0x%08lx\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|quad
operator|->
name|offsetInSpan
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"logical start=0x%08lx, end=0x%08lx\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|quad
operator|->
name|logStart
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|quad
operator|->
name|logEnd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  * This routine calculates the Span block for given row using spanset.  *  * Inputs :	HBA instance  * ld:		Logical drive number  * row:		Row number  * map:		LD map  *  * Outputs :	span	- Span number block  * 						- Absolute Block number in the physical disk  * 				div_error    - Devide error code.  */
end_comment

begin_function
name|u_int32_t
name|mr_spanset_get_span_block
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|row
parameter_list|,
name|u_int64_t
modifier|*
name|span_blk
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|int
modifier|*
name|div_error
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|LD_SPAN_SET
modifier|*
name|span_set
decl_stmt|;
name|MR_QUAD_ELEMENT
modifier|*
name|quad
decl_stmt|;
name|u_int32_t
name|span
decl_stmt|,
name|info
decl_stmt|;
name|PLD_SPAN_INFO
name|ldSpanInfo
init|=
name|sc
operator|->
name|log_to_span
decl_stmt|;
for|for
control|(
name|info
operator|=
literal|0
init|;
name|info
operator|<
name|MAX_QUAD_DEPTH
condition|;
name|info
operator|++
control|)
block|{
name|span_set
operator|=
operator|&
operator|(
name|ldSpanInfo
index|[
name|ld
index|]
operator|.
name|span_set
index|[
name|info
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|span_set
operator|->
name|span_row_data_width
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|row
operator|>
name|span_set
operator|->
name|data_row_end
condition|)
continue|continue;
for|for
control|(
name|span
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
control|)
if|if
condition|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|noElements
operator|>=
name|info
operator|+
literal|1
condition|)
block|{
name|quad
operator|=
operator|&
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|quad
index|[
name|info
index|]
expr_stmt|;
if|if
condition|(
name|quad
operator|->
name|diff
operator|==
literal|0
condition|)
block|{
operator|*
name|div_error
operator|=
literal|1
expr_stmt|;
return|return
name|span
return|;
block|}
if|if
condition|(
name|quad
operator|->
name|logStart
operator|<=
name|row
operator|&&
name|row
operator|<=
name|quad
operator|->
name|logEnd
operator|&&
operator|(
name|mega_mod64
argument_list|(
name|row
operator|-
name|quad
operator|->
name|logStart
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|span_blk
operator|!=
name|NULL
condition|)
block|{
name|u_int64_t
name|blk
decl_stmt|;
name|blk
operator|=
name|mega_div64_32
argument_list|(
operator|(
name|row
operator|-
name|quad
operator|->
name|logStart
operator|)
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
expr_stmt|;
name|blk
operator|=
operator|(
name|blk
operator|+
name|quad
operator|->
name|offsetInSpan
operator|)
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
operator|*
name|span_blk
operator|=
name|blk
expr_stmt|;
block|}
return|return
name|span
return|;
block|}
block|}
block|}
return|return
name|SPAN_INVALID
return|;
block|}
end_function

begin_comment
comment|/*  *  * This routine calculates the row for given strip using spanset.  *  * Inputs :	HBA instance  * ld:		Logical drive number  * Strip:	Strip  * map:		LD map  *  * Outputs :	row - row associated with strip  */
end_comment

begin_function
specifier|static
name|u_int64_t
name|get_row_from_strip
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|strip
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|LD_SPAN_SET
modifier|*
name|span_set
decl_stmt|;
name|PLD_SPAN_INFO
name|ldSpanInfo
init|=
name|sc
operator|->
name|log_to_span
decl_stmt|;
name|u_int32_t
name|info
decl_stmt|,
name|strip_offset
decl_stmt|,
name|span
decl_stmt|,
name|span_offset
decl_stmt|;
name|u_int64_t
name|span_set_Strip
decl_stmt|,
name|span_set_Row
decl_stmt|;
for|for
control|(
name|info
operator|=
literal|0
init|;
name|info
operator|<
name|MAX_QUAD_DEPTH
condition|;
name|info
operator|++
control|)
block|{
name|span_set
operator|=
operator|&
operator|(
name|ldSpanInfo
index|[
name|ld
index|]
operator|.
name|span_set
index|[
name|info
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|span_set
operator|->
name|span_row_data_width
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strip
operator|>
name|span_set
operator|->
name|data_strip_end
condition|)
continue|continue;
name|span_set_Strip
operator|=
name|strip
operator|-
name|span_set
operator|->
name|data_strip_start
expr_stmt|;
name|strip_offset
operator|=
name|mega_mod64
argument_list|(
name|span_set_Strip
argument_list|,
name|span_set
operator|->
name|span_row_data_width
argument_list|)
expr_stmt|;
name|span_set_Row
operator|=
name|mega_div64_32
argument_list|(
name|span_set_Strip
argument_list|,
name|span_set
operator|->
name|span_row_data_width
argument_list|)
operator|*
name|span_set
operator|->
name|diff
expr_stmt|;
for|for
control|(
name|span
operator|=
literal|0
operator|,
name|span_offset
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
control|)
if|if
condition|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|noElements
operator|>=
name|info
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|strip_offset
operator|>=
name|span_set
operator|->
name|strip_offset
index|[
name|span
index|]
condition|)
name|span_offset
operator|++
expr_stmt|;
else|else
break|break;
block|}
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug : Strip 0x%llx, span_set_Strip 0x%llx, span_set_Row 0x%llx "
literal|"data width 0x%llx span offset 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|strip
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|span_set_Strip
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|span_set_Row
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|span_set
operator|->
name|span_row_data_width
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|span_offset
argument_list|)
expr_stmt|;
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug : For strip 0x%llx row is 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|strip
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|span_set
operator|->
name|data_row_start
operator|+
operator|(
name|unsigned
name|long
name|long
operator|)
name|span_set_Row
operator|+
operator|(
name|span_offset
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|span_set
operator|->
name|data_row_start
operator|+
name|span_set_Row
operator|+
operator|(
name|span_offset
operator|-
literal|1
operator|)
operator|)
return|;
block|}
return|return
operator|-
literal|1LLU
return|;
block|}
end_function

begin_comment
comment|/*  *  * This routine calculates the Start Strip for given row using spanset.  *  * Inputs:	HBA instance  * ld:		Logical drive number  * row:		Row number  * map:		LD map  *  * Outputs :	Strip - Start strip associated with row  */
end_comment

begin_function
specifier|static
name|u_int64_t
name|get_strip_from_row
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|row
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|LD_SPAN_SET
modifier|*
name|span_set
decl_stmt|;
name|MR_QUAD_ELEMENT
modifier|*
name|quad
decl_stmt|;
name|PLD_SPAN_INFO
name|ldSpanInfo
init|=
name|sc
operator|->
name|log_to_span
decl_stmt|;
name|u_int32_t
name|span
decl_stmt|,
name|info
decl_stmt|;
name|u_int64_t
name|strip
decl_stmt|;
for|for
control|(
name|info
operator|=
literal|0
init|;
name|info
operator|<
name|MAX_QUAD_DEPTH
condition|;
name|info
operator|++
control|)
block|{
name|span_set
operator|=
operator|&
operator|(
name|ldSpanInfo
index|[
name|ld
index|]
operator|.
name|span_set
index|[
name|info
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|span_set
operator|->
name|span_row_data_width
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|row
operator|>
name|span_set
operator|->
name|data_row_end
condition|)
continue|continue;
for|for
control|(
name|span
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
control|)
if|if
condition|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|noElements
operator|>=
name|info
operator|+
literal|1
condition|)
block|{
name|quad
operator|=
operator|&
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|quad
index|[
name|info
index|]
expr_stmt|;
if|if
condition|(
name|quad
operator|->
name|logStart
operator|<=
name|row
operator|&&
name|row
operator|<=
name|quad
operator|->
name|logEnd
operator|&&
name|mega_mod64
argument_list|(
operator|(
name|row
operator|-
name|quad
operator|->
name|logStart
operator|)
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strip
operator|=
name|mega_div64_32
argument_list|(
operator|(
operator|(
name|row
operator|-
name|span_set
operator|->
name|data_row_start
operator|)
operator|-
name|quad
operator|->
name|logStart
operator|)
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
expr_stmt|;
name|strip
operator|*=
name|span_set
operator|->
name|span_row_data_width
expr_stmt|;
name|strip
operator|+=
name|span_set
operator|->
name|data_strip_start
expr_stmt|;
name|strip
operator|+=
name|span_set
operator|->
name|strip_offset
index|[
name|span
index|]
expr_stmt|;
return|return
name|strip
return|;
block|}
block|}
block|}
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug - get_strip_from_row: returns invalid "
literal|"strip for ld=%x, row=%lx\n"
argument_list|,
name|ld
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|row
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * *****************************************************************************  *  *  * This routine calculates the Physical Arm for given strip using spanset.  *  * Inputs :	HBA instance  * 			Logical drive number  * 			Strip  * 			LD map  *  * Outputs :	Phys Arm - Phys Arm associated with strip  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|get_arm_from_strip
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|strip
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|LD_SPAN_SET
modifier|*
name|span_set
decl_stmt|;
name|PLD_SPAN_INFO
name|ldSpanInfo
init|=
name|sc
operator|->
name|log_to_span
decl_stmt|;
name|u_int32_t
name|info
decl_stmt|,
name|strip_offset
decl_stmt|,
name|span
decl_stmt|,
name|span_offset
decl_stmt|;
for|for
control|(
name|info
operator|=
literal|0
init|;
name|info
operator|<
name|MAX_QUAD_DEPTH
condition|;
name|info
operator|++
control|)
block|{
name|span_set
operator|=
operator|&
operator|(
name|ldSpanInfo
index|[
name|ld
index|]
operator|.
name|span_set
index|[
name|info
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|span_set
operator|->
name|span_row_data_width
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strip
operator|>
name|span_set
operator|->
name|data_strip_end
condition|)
continue|continue;
name|strip_offset
operator|=
operator|(
name|u_int32_t
operator|)
name|mega_mod64
argument_list|(
operator|(
name|strip
operator|-
name|span_set
operator|->
name|data_strip_start
operator|)
argument_list|,
name|span_set
operator|->
name|span_row_data_width
argument_list|)
expr_stmt|;
for|for
control|(
name|span
operator|=
literal|0
operator|,
name|span_offset
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
control|)
if|if
condition|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|noElements
operator|>=
name|info
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|strip_offset
operator|>=
name|span_set
operator|->
name|strip_offset
index|[
name|span
index|]
condition|)
name|span_offset
operator|=
name|span_set
operator|->
name|strip_offset
index|[
name|span
index|]
expr_stmt|;
else|else
break|break;
block|}
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI PRL11: get_arm_from_strip: "
literal|"for ld=0x%x strip=0x%lx arm is  0x%x\n"
argument_list|,
name|ld
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|strip
argument_list|,
operator|(
name|strip_offset
operator|-
name|span_offset
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|strip_offset
operator|-
name|span_offset
operator|)
return|;
block|}
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug: - get_arm_from_strip: returns invalid arm"
literal|" for ld=%x strip=%lx\n"
argument_list|,
name|ld
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|strip
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This Function will return Phys arm */
end_comment

begin_function
name|u_int8_t
name|get_arm
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int8_t
name|span
parameter_list|,
name|u_int64_t
name|stripe
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
comment|/* Need to check correct default value */
name|u_int32_t
name|arm
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|raid
operator|->
name|level
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
name|arm
operator|=
name|mega_mod64
argument_list|(
name|stripe
argument_list|,
name|SPAN_ROW_SIZE
argument_list|(
name|map
argument_list|,
name|ld
argument_list|,
name|span
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* start with logical arm */
name|arm
operator|=
name|get_arm_from_strip
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|stripe
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|arm
operator|*=
literal|2
expr_stmt|;
break|break;
block|}
return|return
name|arm
return|;
block|}
end_function

begin_comment
comment|/*  *  * This routine calculates the arm, span and block for the specified stripe and  * reference in stripe using spanset  *  * Inputs :  * sc - HBA instance  * ld - Logical drive number  * stripRow: Stripe number  * stripRef: Reference in stripe  *  * Outputs :	span - Span number block - Absolute Block  * number in the physical disk  */
end_comment

begin_function
specifier|static
name|u_int8_t
name|mr_spanset_get_phy_params
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|stripRow
parameter_list|,
name|u_int16_t
name|stripRef
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|RAID_CONTEXT
modifier|*
name|pRAID_Context
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|u_int32_t
name|pd
decl_stmt|,
name|arRef
decl_stmt|;
name|u_int8_t
name|physArm
decl_stmt|,
name|span
decl_stmt|;
name|u_int64_t
name|row
decl_stmt|;
name|u_int8_t
name|retval
init|=
name|TRUE
decl_stmt|;
name|u_int64_t
modifier|*
name|pdBlock
init|=
operator|&
name|io_info
operator|->
name|pdBlock
decl_stmt|;
name|u_int16_t
modifier|*
name|pDevHandle
init|=
operator|&
name|io_info
operator|->
name|devHandle
decl_stmt|;
name|u_int32_t
name|logArm
decl_stmt|,
name|rowMod
decl_stmt|,
name|armQ
decl_stmt|,
name|arm
decl_stmt|;
name|u_int8_t
name|do_invader
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_INVADER
operator|)
operator|||
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_FURY
operator|)
condition|)
name|do_invader
operator|=
literal|1
expr_stmt|;
comment|/* Get row and span from io_info for Uneven Span IO. */
name|row
operator|=
name|io_info
operator|->
name|start_row
expr_stmt|;
name|span
operator|=
name|io_info
operator|->
name|start_span
expr_stmt|;
if|if
condition|(
name|raid
operator|->
name|level
operator|==
literal|6
condition|)
block|{
name|logArm
operator|=
name|get_arm_from_strip
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|stripRow
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|rowMod
operator|=
name|mega_mod64
argument_list|(
name|row
argument_list|,
name|SPAN_ROW_SIZE
argument_list|(
name|map
argument_list|,
name|ld
argument_list|,
name|span
argument_list|)
argument_list|)
expr_stmt|;
name|armQ
operator|=
name|SPAN_ROW_SIZE
argument_list|(
name|map
argument_list|,
name|ld
argument_list|,
name|span
argument_list|)
operator|-
literal|1
operator|-
name|rowMod
expr_stmt|;
name|arm
operator|=
name|armQ
operator|+
literal|1
operator|+
name|logArm
expr_stmt|;
if|if
condition|(
name|arm
operator|>=
name|SPAN_ROW_SIZE
argument_list|(
name|map
argument_list|,
name|ld
argument_list|,
name|span
argument_list|)
condition|)
name|arm
operator|-=
name|SPAN_ROW_SIZE
argument_list|(
name|map
argument_list|,
name|ld
argument_list|,
name|span
argument_list|)
expr_stmt|;
name|physArm
operator|=
operator|(
name|u_int8_t
operator|)
name|arm
expr_stmt|;
block|}
else|else
comment|/* Calculate the arm */
name|physArm
operator|=
name|get_arm
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|span
argument_list|,
name|stripRow
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|arRef
operator|=
name|MR_LdSpanArrayGet
argument_list|(
name|ld
argument_list|,
name|span
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|pd
operator|=
name|MR_ArPdGet
argument_list|(
name|arRef
argument_list|,
name|physArm
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|!=
name|MR_PD_INVALID
condition|)
operator|*
name|pDevHandle
operator|=
name|MR_PdDevHandleGet
argument_list|(
name|pd
argument_list|,
name|map
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|pDevHandle
operator|=
name|MR_PD_INVALID
expr_stmt|;
if|if
condition|(
operator|(
name|raid
operator|->
name|level
operator|>=
literal|5
operator|)
operator|&&
operator|(
operator|(
operator|!
name|do_invader
operator|)
operator|||
operator|(
name|do_invader
operator|&&
name|raid
operator|->
name|regTypeReqOnRead
operator|!=
name|REGION_TYPE_UNUSED
operator|)
operator|)
condition|)
name|pRAID_Context
operator|->
name|regLockFlags
operator|=
name|REGION_TYPE_EXCLUSIVE
expr_stmt|;
elseif|else
if|if
condition|(
name|raid
operator|->
name|level
operator|==
literal|1
condition|)
block|{
name|pd
operator|=
name|MR_ArPdGet
argument_list|(
name|arRef
argument_list|,
name|physArm
operator|+
literal|1
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|!=
name|MR_PD_INVALID
condition|)
operator|*
name|pDevHandle
operator|=
name|MR_PdDevHandleGet
argument_list|(
name|pd
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|pdBlock
operator|+=
name|stripRef
operator|+
name|MR_LdSpanPtrGet
argument_list|(
name|ld
argument_list|,
name|span
argument_list|,
name|map
argument_list|)
operator|->
name|startBlk
expr_stmt|;
name|pRAID_Context
operator|->
name|spanArm
operator|=
operator|(
name|span
operator|<<
name|RAID_CTX_SPANARM_SPAN_SHIFT
operator|)
operator||
name|physArm
expr_stmt|;
name|io_info
operator|->
name|span_arm
operator|=
name|pRAID_Context
operator|->
name|spanArm
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * MR_BuildRaidContext:	Set up Fast path RAID context  *  * This function will initiate command processing.  The start/end row and strip  * information is calculated then the lock is acquired. This function will  * return 0 if region lock was acquired OR return num strips.  */
end_comment

begin_function
name|u_int8_t
name|MR_BuildRaidContext
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|RAID_CONTEXT
modifier|*
name|pRAID_Context
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
name|u_int32_t
name|ld
decl_stmt|,
name|stripSize
decl_stmt|,
name|stripe_mask
decl_stmt|;
name|u_int64_t
name|endLba
decl_stmt|,
name|endStrip
decl_stmt|,
name|endRow
decl_stmt|,
name|start_row
decl_stmt|,
name|start_strip
decl_stmt|;
name|REGION_KEY
name|regStart
decl_stmt|;
name|REGION_LEN
name|regSize
decl_stmt|;
name|u_int8_t
name|num_strips
decl_stmt|,
name|numRows
decl_stmt|;
name|u_int16_t
name|ref_in_start_stripe
decl_stmt|,
name|ref_in_end_stripe
decl_stmt|;
name|u_int64_t
name|ldStartBlock
decl_stmt|;
name|u_int32_t
name|numBlocks
decl_stmt|,
name|ldTgtId
decl_stmt|;
name|u_int8_t
name|isRead
decl_stmt|,
name|stripIdx
decl_stmt|;
name|u_int8_t
name|retval
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|startlba_span
init|=
name|SPAN_INVALID
decl_stmt|;
name|u_int64_t
modifier|*
name|pdBlock
init|=
operator|&
name|io_info
operator|->
name|pdBlock
decl_stmt|;
name|int
name|error_code
init|=
literal|0
decl_stmt|;
name|ldStartBlock
operator|=
name|io_info
operator|->
name|ldStartBlock
expr_stmt|;
name|numBlocks
operator|=
name|io_info
operator|->
name|numBlocks
expr_stmt|;
name|ldTgtId
operator|=
name|io_info
operator|->
name|ldTgtId
expr_stmt|;
name|isRead
operator|=
name|io_info
operator|->
name|isRead
expr_stmt|;
name|io_info
operator|->
name|IoforUnevenSpan
operator|=
literal|0
expr_stmt|;
name|io_info
operator|->
name|start_span
operator|=
name|SPAN_INVALID
expr_stmt|;
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|ldTgtId
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|raid
operator|->
name|rowDataSize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|MR_LdSpanPtrGet
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|,
name|map
argument_list|)
operator|->
name|spanRowDataSize
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|UnevenSpanSupport
condition|)
block|{
name|io_info
operator|->
name|IoforUnevenSpan
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug: raid->rowDataSize is 0, but has SPAN[0] rowDataSize = 0x%0x,"
literal|" but there is _NO_ UnevenSpanSupport\n"
argument_list|,
name|MR_LdSpanPtrGet
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|,
name|map
argument_list|)
operator|->
name|spanRowDataSize
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|stripSize
operator|=
literal|1
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
name|stripe_mask
operator|=
name|stripSize
operator|-
literal|1
expr_stmt|;
comment|/* 	 * calculate starting row and stripe, and number of strips and rows 	 */
name|start_strip
operator|=
name|ldStartBlock
operator|>>
name|raid
operator|->
name|stripeShift
expr_stmt|;
name|ref_in_start_stripe
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|ldStartBlock
operator|&
name|stripe_mask
argument_list|)
expr_stmt|;
name|endLba
operator|=
name|ldStartBlock
operator|+
name|numBlocks
operator|-
literal|1
expr_stmt|;
name|ref_in_end_stripe
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|endLba
operator|&
name|stripe_mask
argument_list|)
expr_stmt|;
name|endStrip
operator|=
name|endLba
operator|>>
name|raid
operator|->
name|stripeShift
expr_stmt|;
name|num_strips
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|endStrip
operator|-
name|start_strip
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* End strip */
if|if
condition|(
name|io_info
operator|->
name|IoforUnevenSpan
condition|)
block|{
name|start_row
operator|=
name|get_row_from_strip
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_strip
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|endRow
operator|=
name|get_row_from_strip
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|endStrip
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|raid
operator|->
name|spanDepth
operator|==
literal|1
condition|)
block|{
name|startlba_span
operator|=
literal|0
expr_stmt|;
operator|*
name|pdBlock
operator|=
name|start_row
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
block|}
else|else
block|{
name|startlba_span
operator|=
operator|(
name|u_int8_t
operator|)
name|mr_spanset_get_span_block
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_row
argument_list|,
name|pdBlock
argument_list|,
name|map
argument_list|,
operator|&
name|error_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_code
operator|==
literal|1
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug: return from %s %d. Send IO w/o region lock.\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|startlba_span
operator|==
name|SPAN_INVALID
condition|)
block|{
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug: return from %s %d for row 0x%llx,"
literal|"start strip %llx endSrip %llx\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|start_row
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|start_strip
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|endStrip
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|io_info
operator|->
name|start_span
operator|=
name|startlba_span
expr_stmt|;
name|io_info
operator|->
name|start_row
operator|=
name|start_row
expr_stmt|;
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug: Check Span number from %s %d for row 0x%llx, "
literal|" start strip 0x%llx endSrip 0x%llx span 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|start_row
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|start_strip
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|endStrip
argument_list|,
name|startlba_span
argument_list|)
expr_stmt|;
name|mrsas_dprint
argument_list|(
name|sc
argument_list|,
name|MRSAS_PRL11
argument_list|,
literal|"LSI Debug : 1. start_row 0x%llx endRow 0x%llx Start span 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|start_row
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|endRow
argument_list|,
name|startlba_span
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start_row
operator|=
name|mega_div64_32
argument_list|(
name|start_strip
argument_list|,
name|raid
operator|->
name|rowDataSize
argument_list|)
expr_stmt|;
name|endRow
operator|=
name|mega_div64_32
argument_list|(
name|endStrip
argument_list|,
name|raid
operator|->
name|rowDataSize
argument_list|)
expr_stmt|;
block|}
name|numRows
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|endRow
operator|-
name|start_row
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* get the row count */
comment|/* 	 * Calculate region info.  (Assume region at start of first row, and 	 * assume this IO needs the full row - will adjust if not true.) 	 */
name|regStart
operator|=
name|start_row
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
name|regSize
operator|=
name|stripSize
expr_stmt|;
comment|/* Check if we can send this I/O via FastPath */
if|if
condition|(
name|raid
operator|->
name|capability
operator|.
name|fpCapable
condition|)
block|{
if|if
condition|(
name|isRead
condition|)
name|io_info
operator|->
name|fpOkForIo
operator|=
operator|(
name|raid
operator|->
name|capability
operator|.
name|fpReadCapable
operator|&&
operator|(
operator|(
name|num_strips
operator|==
literal|1
operator|)
operator|||
name|raid
operator|->
name|capability
operator|.
name|fpReadAcrossStripe
operator|)
operator|)
expr_stmt|;
else|else
name|io_info
operator|->
name|fpOkForIo
operator|=
operator|(
name|raid
operator|->
name|capability
operator|.
name|fpWriteCapable
operator|&&
operator|(
operator|(
name|num_strips
operator|==
literal|1
operator|)
operator|||
name|raid
operator|->
name|capability
operator|.
name|fpWriteAcrossStripe
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|io_info
operator|->
name|fpOkForIo
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|numRows
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|num_strips
operator|==
literal|1
condition|)
block|{
name|regStart
operator|+=
name|ref_in_start_stripe
expr_stmt|;
name|regSize
operator|=
name|numBlocks
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|io_info
operator|->
name|IoforUnevenSpan
operator|==
literal|0
condition|)
block|{
comment|/* 		 * For Even span region lock optimization. If the start strip 		 * is the last in the start row 		 */
if|if
condition|(
name|start_strip
operator|==
operator|(
name|start_row
operator|+
literal|1
operator|)
operator|*
name|raid
operator|->
name|rowDataSize
operator|-
literal|1
condition|)
block|{
name|regStart
operator|+=
name|ref_in_start_stripe
expr_stmt|;
comment|/* 			 * initialize count to sectors from startRef to end 			 * of strip 			 */
name|regSize
operator|=
name|stripSize
operator|-
name|ref_in_start_stripe
expr_stmt|;
block|}
comment|/* add complete rows in the middle of the transfer */
if|if
condition|(
name|numRows
operator|>
literal|2
condition|)
name|regSize
operator|+=
operator|(
name|numRows
operator|-
literal|2
operator|)
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
comment|/* if IO ends within first strip of last row */
if|if
condition|(
name|endStrip
operator|==
name|endRow
operator|*
name|raid
operator|->
name|rowDataSize
condition|)
name|regSize
operator|+=
name|ref_in_end_stripe
operator|+
literal|1
expr_stmt|;
else|else
name|regSize
operator|+=
name|stripSize
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|start_strip
operator|==
operator|(
name|get_strip_from_row
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_row
argument_list|,
name|map
argument_list|)
operator|+
name|SPAN_ROW_DATA_SIZE
argument_list|(
name|map
argument_list|,
name|ld
argument_list|,
name|startlba_span
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|regStart
operator|+=
name|ref_in_start_stripe
expr_stmt|;
comment|/* 			 * initialize count to sectors from startRef to end 			 * of strip 			 */
name|regSize
operator|=
name|stripSize
operator|-
name|ref_in_start_stripe
expr_stmt|;
block|}
comment|/* add complete rows in the middle of the transfer */
if|if
condition|(
name|numRows
operator|>
literal|2
condition|)
name|regSize
operator|+=
operator|(
name|numRows
operator|-
literal|2
operator|)
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
comment|/* if IO ends within first strip of last row */
if|if
condition|(
name|endStrip
operator|==
name|get_strip_from_row
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|endRow
argument_list|,
name|map
argument_list|)
condition|)
name|regSize
operator|+=
name|ref_in_end_stripe
operator|+
literal|1
expr_stmt|;
else|else
name|regSize
operator|+=
name|stripSize
expr_stmt|;
block|}
name|pRAID_Context
operator|->
name|timeoutValue
operator|=
name|map
operator|->
name|raidMap
operator|.
name|fpPdIoTimeoutSec
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_INVADER
operator|)
operator|||
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_FURY
operator|)
condition|)
name|pRAID_Context
operator|->
name|regLockFlags
operator|=
operator|(
name|isRead
operator|)
condition|?
name|raid
operator|->
name|regTypeReqOnRead
else|:
name|raid
operator|->
name|regTypeReqOnWrite
expr_stmt|;
else|else
name|pRAID_Context
operator|->
name|regLockFlags
operator|=
operator|(
name|isRead
operator|)
condition|?
name|REGION_TYPE_SHARED_READ
else|:
name|raid
operator|->
name|regTypeReqOnWrite
expr_stmt|;
name|pRAID_Context
operator|->
name|VirtualDiskTgtId
operator|=
name|raid
operator|->
name|targetId
expr_stmt|;
name|pRAID_Context
operator|->
name|regLockRowLBA
operator|=
name|regStart
expr_stmt|;
name|pRAID_Context
operator|->
name|regLockLength
operator|=
name|regSize
expr_stmt|;
name|pRAID_Context
operator|->
name|configSeqNum
operator|=
name|raid
operator|->
name|seqNum
expr_stmt|;
comment|/* 	 * Get Phy Params only if FP capable, or else leave it to MR firmware 	 * to do the calculation. 	 */
if|if
condition|(
name|io_info
operator|->
name|fpOkForIo
condition|)
block|{
name|retval
operator|=
name|io_info
operator|->
name|IoforUnevenSpan
condition|?
name|mr_spanset_get_phy_params
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_strip
argument_list|,
name|ref_in_start_stripe
argument_list|,
name|io_info
argument_list|,
name|pRAID_Context
argument_list|,
name|map
argument_list|)
else|:
name|MR_GetPhyParams
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_strip
argument_list|,
name|ref_in_start_stripe
argument_list|,
name|io_info
argument_list|,
name|pRAID_Context
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* If IO on an invalid Pd, then FP is not possible */
if|if
condition|(
name|io_info
operator|->
name|devHandle
operator|==
name|MR_PD_INVALID
condition|)
name|io_info
operator|->
name|fpOkForIo
operator|=
name|FALSE
expr_stmt|;
return|return
name|retval
return|;
block|}
elseif|else
if|if
condition|(
name|isRead
condition|)
block|{
for|for
control|(
name|stripIdx
operator|=
literal|0
init|;
name|stripIdx
operator|<
name|num_strips
condition|;
name|stripIdx
operator|++
control|)
block|{
name|retval
operator|=
name|io_info
operator|->
name|IoforUnevenSpan
condition|?
name|mr_spanset_get_phy_params
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_strip
operator|+
name|stripIdx
argument_list|,
name|ref_in_start_stripe
argument_list|,
name|io_info
argument_list|,
name|pRAID_Context
argument_list|,
name|map
argument_list|)
else|:
name|MR_GetPhyParams
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_strip
operator|+
name|stripIdx
argument_list|,
name|ref_in_start_stripe
argument_list|,
name|io_info
argument_list|,
name|pRAID_Context
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
return|return
name|TRUE
return|;
block|}
block|}
if|#
directive|if
name|SPAN_DEBUG
comment|/* Just for testing what arm we get for strip. */
name|get_arm_from_strip
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|,
name|start_strip
argument_list|,
name|map
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  *  * This routine pepare spanset info from Valid Raid map and store it into local  * copy of ldSpanInfo per instance data structure.  *  * Inputs :	LD map  * 			ldSpanInfo per HBA instance  *  */
end_comment

begin_function
name|void
name|mr_update_span_set
parameter_list|(
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|PLD_SPAN_INFO
name|ldSpanInfo
parameter_list|)
block|{
name|u_int8_t
name|span
decl_stmt|,
name|count
decl_stmt|;
name|u_int32_t
name|element
decl_stmt|,
name|span_row_width
decl_stmt|;
name|u_int64_t
name|span_row
decl_stmt|;
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
name|LD_SPAN_SET
modifier|*
name|span_set
decl_stmt|,
modifier|*
name|span_set_prev
decl_stmt|;
name|MR_QUAD_ELEMENT
modifier|*
name|quad
decl_stmt|;
name|int
name|ldCount
decl_stmt|;
name|u_int16_t
name|ld
decl_stmt|;
for|for
control|(
name|ldCount
operator|=
literal|0
init|;
name|ldCount
operator|<
name|MAX_LOGICAL_DRIVES
condition|;
name|ldCount
operator|++
control|)
block|{
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|ldCount
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|>=
name|MAX_LOGICAL_DRIVES
condition|)
continue|continue;
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
literal|0
init|;
name|element
operator|<
name|MAX_QUAD_DEPTH
condition|;
name|element
operator|++
control|)
block|{
for|for
control|(
name|span
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
control|)
block|{
if|if
condition|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|noElements
operator|<
name|element
operator|+
literal|1
condition|)
continue|continue;
comment|/* TO-DO */
name|span_set
operator|=
operator|&
operator|(
name|ldSpanInfo
index|[
name|ld
index|]
operator|.
name|span_set
index|[
name|element
index|]
operator|)
expr_stmt|;
name|quad
operator|=
operator|&
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|span
index|]
operator|.
name|block_span_info
operator|.
name|quad
index|[
name|element
index|]
expr_stmt|;
name|span_set
operator|->
name|diff
operator|=
name|quad
operator|->
name|diff
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|span_row_width
operator|=
literal|0
init|;
name|count
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|map
operator|->
name|raidMap
operator|.
name|ldSpanMap
index|[
name|ld
index|]
operator|.
name|spanBlock
index|[
name|count
index|]
operator|.
name|block_span_info
operator|.
name|noElements
operator|>=
name|element
operator|+
literal|1
condition|)
block|{
name|span_set
operator|->
name|strip_offset
index|[
name|count
index|]
operator|=
name|span_row_width
expr_stmt|;
name|span_row_width
operator|+=
name|MR_LdSpanPtrGet
argument_list|(
name|ld
argument_list|,
name|count
argument_list|,
name|map
argument_list|)
operator|->
name|spanRowDataSize
expr_stmt|;
if|#
directive|if
name|SPAN_DEBUG
name|printf
argument_list|(
literal|"LSI Debug span %x rowDataSize %x\n"
argument_list|,
name|count
argument_list|,
name|MR_LdSpanPtrGet
argument_list|(
name|ld
argument_list|,
name|count
argument_list|,
name|map
argument_list|)
operator|->
name|spanRowDataSize
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|span_set
operator|->
name|span_row_data_width
operator|=
name|span_row_width
expr_stmt|;
name|span_row
operator|=
name|mega_div64_32
argument_list|(
operator|(
operator|(
name|quad
operator|->
name|logEnd
operator|-
name|quad
operator|->
name|logStart
operator|)
operator|+
name|quad
operator|->
name|diff
operator|)
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
literal|0
condition|)
block|{
name|span_set
operator|->
name|log_start_lba
operator|=
literal|0
expr_stmt|;
name|span_set
operator|->
name|log_end_lba
operator|=
operator|(
operator|(
name|span_row
operator|<<
name|raid
operator|->
name|stripeShift
operator|)
operator|*
name|span_row_width
operator|)
operator|-
literal|1
expr_stmt|;
name|span_set
operator|->
name|span_row_start
operator|=
literal|0
expr_stmt|;
name|span_set
operator|->
name|span_row_end
operator|=
name|span_row
operator|-
literal|1
expr_stmt|;
name|span_set
operator|->
name|data_strip_start
operator|=
literal|0
expr_stmt|;
name|span_set
operator|->
name|data_strip_end
operator|=
operator|(
name|span_row
operator|*
name|span_row_width
operator|)
operator|-
literal|1
expr_stmt|;
name|span_set
operator|->
name|data_row_start
operator|=
literal|0
expr_stmt|;
name|span_set
operator|->
name|data_row_end
operator|=
operator|(
name|span_row
operator|*
name|quad
operator|->
name|diff
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|span_set_prev
operator|=
operator|&
operator|(
name|ldSpanInfo
index|[
name|ld
index|]
operator|.
name|span_set
index|[
name|element
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|span_set
operator|->
name|log_start_lba
operator|=
name|span_set_prev
operator|->
name|log_end_lba
operator|+
literal|1
expr_stmt|;
name|span_set
operator|->
name|log_end_lba
operator|=
name|span_set
operator|->
name|log_start_lba
operator|+
operator|(
operator|(
name|span_row
operator|<<
name|raid
operator|->
name|stripeShift
operator|)
operator|*
name|span_row_width
operator|)
operator|-
literal|1
expr_stmt|;
name|span_set
operator|->
name|span_row_start
operator|=
name|span_set_prev
operator|->
name|span_row_end
operator|+
literal|1
expr_stmt|;
name|span_set
operator|->
name|span_row_end
operator|=
name|span_set
operator|->
name|span_row_start
operator|+
name|span_row
operator|-
literal|1
expr_stmt|;
name|span_set
operator|->
name|data_strip_start
operator|=
name|span_set_prev
operator|->
name|data_strip_end
operator|+
literal|1
expr_stmt|;
name|span_set
operator|->
name|data_strip_end
operator|=
name|span_set
operator|->
name|data_strip_start
operator|+
operator|(
name|span_row
operator|*
name|span_row_width
operator|)
operator|-
literal|1
expr_stmt|;
name|span_set
operator|->
name|data_row_start
operator|=
name|span_set_prev
operator|->
name|data_row_end
operator|+
literal|1
expr_stmt|;
name|span_set
operator|->
name|data_row_end
operator|=
name|span_set
operator|->
name|data_row_start
operator|+
operator|(
name|span_row
operator|*
name|quad
operator|->
name|diff
operator|)
operator|-
literal|1
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|span
operator|==
name|raid
operator|->
name|spanDepth
condition|)
break|break;
comment|/* no quads remain */
block|}
block|}
if|#
directive|if
name|SPAN_DEBUG
name|getSpanInfo
argument_list|(
name|map
argument_list|,
name|ldSpanInfo
argument_list|)
expr_stmt|;
comment|/* to get span set info */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * mrsas_update_load_balance_params:	Update load balance parmas  * Inputs:  * sc - driver softc instance  * drv_map - driver RAID map  * lbInfo - Load balance info  *  * This function updates the load balance parameters for the LD config of a two  * drive optimal RAID-1.  */
end_comment

begin_function
name|void
name|mrsas_update_load_balance_params
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|drv_map
parameter_list|,
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|)
block|{
name|int
name|ldCount
decl_stmt|;
name|u_int16_t
name|ld
decl_stmt|;
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|lb_pending_cmds
operator|>
literal|128
operator|||
name|sc
operator|->
name|lb_pending_cmds
operator|<
literal|1
condition|)
name|sc
operator|->
name|lb_pending_cmds
operator|=
name|LB_PENDING_CMDS_DEFAULT
expr_stmt|;
for|for
control|(
name|ldCount
operator|=
literal|0
init|;
name|ldCount
operator|<
name|MAX_LOGICAL_DRIVES_EXT
condition|;
name|ldCount
operator|++
control|)
block|{
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|ldCount
argument_list|,
name|drv_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|>=
name|MAX_LOGICAL_DRIVES_EXT
condition|)
block|{
name|lbInfo
index|[
name|ldCount
index|]
operator|.
name|loadBalanceFlag
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|drv_map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|raid
operator|->
name|level
operator|!=
literal|1
operator|)
operator|||
operator|(
name|raid
operator|->
name|ldState
operator|!=
name|MR_LD_STATE_OPTIMAL
operator|)
condition|)
block|{
name|lbInfo
index|[
name|ldCount
index|]
operator|.
name|loadBalanceFlag
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|lbInfo
index|[
name|ldCount
index|]
operator|.
name|loadBalanceFlag
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * mrsas_set_pd_lba:	Sets PD LBA  * input:				io_request pointer  * 						CDB length  * 						io_info pointer  * 						Pointer to CCB  * 						Local RAID map pointer  * 						Start block of IO Block Size  *  * Used to set the PD logical block address in CDB for FP IOs.  */
end_comment

begin_function
name|void
name|mrsas_set_pd_lba
parameter_list|(
name|MRSAS_RAID_SCSI_IO_REQUEST
modifier|*
name|io_request
parameter_list|,
name|u_int8_t
name|cdb_len
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|local_map_ptr
parameter_list|,
name|u_int32_t
name|ref_tag
parameter_list|,
name|u_int32_t
name|ld_block_size
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
name|u_int32_t
name|ld
decl_stmt|;
name|u_int64_t
name|start_blk
init|=
name|io_info
operator|->
name|pdBlock
decl_stmt|;
name|u_int8_t
modifier|*
name|cdb
init|=
name|io_request
operator|->
name|CDB
operator|.
name|CDB32
decl_stmt|;
name|u_int32_t
name|num_blocks
init|=
name|io_info
operator|->
name|numBlocks
decl_stmt|;
name|u_int8_t
name|opcode
init|=
literal|0
decl_stmt|,
name|flagvals
init|=
literal|0
decl_stmt|,
name|groupnum
init|=
literal|0
decl_stmt|,
name|control
init|=
literal|0
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
decl_stmt|;
comment|/* Check if T10 PI (DIF) is enabled for this LD */
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|io_info
operator|->
name|ldTgtId
argument_list|,
name|local_map_ptr
argument_list|)
expr_stmt|;
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|local_map_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|raid
operator|->
name|capability
operator|.
name|ldPiMode
operator|==
name|MR_PROT_INFO_TYPE_CONTROLLER
condition|)
block|{
name|memset
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|io_request
operator|->
name|CDB
operator|.
name|CDB32
argument_list|)
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
name|MRSAS_SCSI_VARIABLE_LENGTH_CMD
expr_stmt|;
name|cdb
index|[
literal|7
index|]
operator|=
name|MRSAS_SCSI_ADDL_CDB_LEN
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|flags
operator|==
name|CAM_DIR_OUT
condition|)
name|cdb
index|[
literal|9
index|]
operator|=
name|MRSAS_SCSI_SERVICE_ACTION_READ32
expr_stmt|;
else|else
name|cdb
index|[
literal|9
index|]
operator|=
name|MRSAS_SCSI_SERVICE_ACTION_WRITE32
expr_stmt|;
name|cdb
index|[
literal|10
index|]
operator|=
name|MRSAS_RD_WR_PROTECT_CHECK_ALL
expr_stmt|;
comment|/* LBA */
name|cdb
index|[
literal|12
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|56
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|13
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|48
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|14
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|40
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|15
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|32
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|16
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|17
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|18
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|19
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|start_blk
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Logical block reference tag */
name|io_request
operator|->
name|CDB
operator|.
name|EEDP32
operator|.
name|PrimaryReferenceTag
operator|=
name|swap32
argument_list|(
name|ref_tag
argument_list|)
expr_stmt|;
name|io_request
operator|->
name|CDB
operator|.
name|EEDP32
operator|.
name|PrimaryApplicationTagMask
operator|=
literal|0xffff
expr_stmt|;
name|io_request
operator|->
name|IoFlags
operator|=
literal|32
expr_stmt|;
comment|/* Specify 32-byte cdb */
comment|/* Transfer length */
name|cdb
index|[
literal|28
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|29
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|30
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|31
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|num_blocks
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* set SCSI IO EEDP Flags */
if|if
condition|(
name|ccb_h
operator|->
name|flags
operator|==
name|CAM_DIR_OUT
condition|)
block|{
name|io_request
operator|->
name|EEDPFlags
operator|=
name|MPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG
operator||
name|MPI2_SCSIIO_EEDPFLAGS_CHECK_REFTAG
operator||
name|MPI2_SCSIIO_EEDPFLAGS_CHECK_REMOVE_OP
operator||
name|MPI2_SCSIIO_EEDPFLAGS_CHECK_APPTAG
operator||
name|MPI2_SCSIIO_EEDPFLAGS_CHECK_GUARD
expr_stmt|;
block|}
else|else
block|{
name|io_request
operator|->
name|EEDPFlags
operator|=
name|MPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG
operator||
name|MPI2_SCSIIO_EEDPFLAGS_INSERT_OP
expr_stmt|;
block|}
name|io_request
operator|->
name|Control
operator||=
operator|(
literal|0x4
operator|<<
literal|26
operator|)
expr_stmt|;
name|io_request
operator|->
name|EEDPBlockSize
operator|=
name|ld_block_size
expr_stmt|;
block|}
else|else
block|{
comment|/* Some drives don't support 16/12 byte CDB's, convert to 10 */
if|if
condition|(
operator|(
operator|(
name|cdb_len
operator|==
literal|12
operator|)
operator|||
operator|(
name|cdb_len
operator|==
literal|16
operator|)
operator|)
operator|&&
operator|(
name|start_blk
operator|<=
literal|0xffffffff
operator|)
condition|)
block|{
if|if
condition|(
name|cdb_len
operator|==
literal|16
condition|)
block|{
name|opcode
operator|=
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_16
condition|?
name|READ_10
else|:
name|WRITE_10
expr_stmt|;
name|flagvals
operator|=
name|cdb
index|[
literal|1
index|]
expr_stmt|;
name|groupnum
operator|=
name|cdb
index|[
literal|14
index|]
expr_stmt|;
name|control
operator|=
name|cdb
index|[
literal|15
index|]
expr_stmt|;
block|}
else|else
block|{
name|opcode
operator|=
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_12
condition|?
name|READ_10
else|:
name|WRITE_10
expr_stmt|;
name|flagvals
operator|=
name|cdb
index|[
literal|1
index|]
expr_stmt|;
name|groupnum
operator|=
name|cdb
index|[
literal|10
index|]
expr_stmt|;
name|control
operator|=
name|cdb
index|[
literal|11
index|]
expr_stmt|;
block|}
name|memset
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|io_request
operator|->
name|CDB
operator|.
name|CDB32
argument_list|)
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
name|opcode
expr_stmt|;
name|cdb
index|[
literal|1
index|]
operator|=
name|flagvals
expr_stmt|;
name|cdb
index|[
literal|6
index|]
operator|=
name|groupnum
expr_stmt|;
name|cdb
index|[
literal|9
index|]
operator|=
name|control
expr_stmt|;
comment|/* Transfer length */
name|cdb
index|[
literal|8
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|num_blocks
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|7
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|io_request
operator|->
name|IoFlags
operator|=
literal|10
expr_stmt|;
comment|/* Specify 10-byte cdb */
name|cdb_len
operator|=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cdb_len
operator|<
literal|16
operator|)
operator|&&
operator|(
name|start_blk
operator|>
literal|0xffffffff
operator|)
condition|)
block|{
comment|/* Convert to 16 byte CDB for large LBA's */
switch|switch
condition|(
name|cdb_len
condition|)
block|{
case|case
literal|6
case|:
name|opcode
operator|=
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_6
condition|?
name|READ_16
else|:
name|WRITE_16
expr_stmt|;
name|control
operator|=
name|cdb
index|[
literal|5
index|]
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|opcode
operator|=
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_10
condition|?
name|READ_16
else|:
name|WRITE_16
expr_stmt|;
name|flagvals
operator|=
name|cdb
index|[
literal|1
index|]
expr_stmt|;
name|groupnum
operator|=
name|cdb
index|[
literal|6
index|]
expr_stmt|;
name|control
operator|=
name|cdb
index|[
literal|9
index|]
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|opcode
operator|=
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_12
condition|?
name|READ_16
else|:
name|WRITE_16
expr_stmt|;
name|flagvals
operator|=
name|cdb
index|[
literal|1
index|]
expr_stmt|;
name|groupnum
operator|=
name|cdb
index|[
literal|10
index|]
expr_stmt|;
name|control
operator|=
name|cdb
index|[
literal|11
index|]
expr_stmt|;
break|break;
block|}
name|memset
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|io_request
operator|->
name|CDB
operator|.
name|CDB32
argument_list|)
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
name|opcode
expr_stmt|;
name|cdb
index|[
literal|1
index|]
operator|=
name|flagvals
expr_stmt|;
name|cdb
index|[
literal|14
index|]
operator|=
name|groupnum
expr_stmt|;
name|cdb
index|[
literal|15
index|]
operator|=
name|control
expr_stmt|;
comment|/* Transfer length */
name|cdb
index|[
literal|13
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|num_blocks
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|12
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|11
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|10
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|io_request
operator|->
name|IoFlags
operator|=
literal|16
expr_stmt|;
comment|/* Specify 16-byte cdb */
name|cdb_len
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cdb_len
operator|==
literal|6
operator|)
operator|&&
operator|(
name|start_blk
operator|>
literal|0x1fffff
operator|)
condition|)
block|{
comment|/* convert to 10 byte CDB */
name|opcode
operator|=
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_6
condition|?
name|READ_10
else|:
name|WRITE_10
expr_stmt|;
name|control
operator|=
name|cdb
index|[
literal|5
index|]
expr_stmt|;
name|memset
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|io_request
operator|->
name|CDB
operator|.
name|CDB32
argument_list|)
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
name|opcode
expr_stmt|;
name|cdb
index|[
literal|9
index|]
operator|=
name|control
expr_stmt|;
comment|/* Set transfer length */
name|cdb
index|[
literal|8
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|num_blocks
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|7
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|num_blocks
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Specify 10-byte cdb */
name|cdb_len
operator|=
literal|10
expr_stmt|;
block|}
comment|/* Fall through normal case, just load LBA here */
name|u_int8_t
name|val
init|=
name|cdb
index|[
literal|1
index|]
operator|&
literal|0xE0
decl_stmt|;
switch|switch
condition|(
name|cdb_len
condition|)
block|{
case|case
literal|6
case|:
name|cdb
index|[
literal|3
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|start_blk
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|2
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|1
index|]
operator|=
name|val
operator||
operator|(
call|(
name|u_int8_t
call|)
argument_list|(
name|start_blk
operator|>>
literal|16
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|cdb
index|[
literal|5
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|start_blk
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|4
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|3
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|2
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|cdb
index|[
literal|5
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|start_blk
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|4
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|3
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|2
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|cdb
index|[
literal|9
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|start_blk
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|8
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|7
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|6
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|5
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|32
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|4
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|40
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|3
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|48
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|2
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|start_blk
operator|>>
literal|56
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * mrsas_get_best_arm_pd:	Determine the best spindle arm  * Inputs:  *    sc - HBA instance  *    lbInfo - Load balance info  *    io_info - IO request info  *  * This function determines and returns the best arm by looking at the  * parameters of the last PD access.  */
end_comment

begin_function
name|u_int8_t
name|mrsas_get_best_arm_pd
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
decl_stmt|;
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|drv_map
decl_stmt|;
name|u_int16_t
name|pend0
decl_stmt|,
name|pend1
decl_stmt|,
name|ld
decl_stmt|;
name|u_int64_t
name|diff0
decl_stmt|,
name|diff1
decl_stmt|;
name|u_int8_t
name|bestArm
decl_stmt|,
name|pd0
decl_stmt|,
name|pd1
decl_stmt|,
name|span
decl_stmt|,
name|arm
decl_stmt|;
name|u_int32_t
name|arRef
decl_stmt|,
name|span_row_size
decl_stmt|;
name|u_int64_t
name|block
init|=
name|io_info
operator|->
name|ldStartBlock
decl_stmt|;
name|u_int32_t
name|count
init|=
name|io_info
operator|->
name|numBlocks
decl_stmt|;
name|span
operator|=
operator|(
operator|(
name|io_info
operator|->
name|span_arm
operator|&
name|RAID_CTX_SPANARM_SPAN_MASK
operator|)
operator|>>
name|RAID_CTX_SPANARM_SPAN_SHIFT
operator|)
expr_stmt|;
name|arm
operator|=
operator|(
name|io_info
operator|->
name|span_arm
operator|&
name|RAID_CTX_SPANARM_ARM_MASK
operator|)
expr_stmt|;
name|drv_map
operator|=
name|sc
operator|->
name|ld_drv_map
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
expr_stmt|;
name|ld
operator|=
name|MR_TargetIdToLdGet
argument_list|(
name|io_info
operator|->
name|ldTgtId
argument_list|,
name|drv_map
argument_list|)
expr_stmt|;
name|raid
operator|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|drv_map
argument_list|)
expr_stmt|;
name|span_row_size
operator|=
name|sc
operator|->
name|UnevenSpanSupport
condition|?
name|SPAN_ROW_SIZE
argument_list|(
name|drv_map
argument_list|,
name|ld
argument_list|,
name|span
argument_list|)
else|:
name|raid
operator|->
name|rowSize
expr_stmt|;
name|arRef
operator|=
name|MR_LdSpanArrayGet
argument_list|(
name|ld
argument_list|,
name|span
argument_list|,
name|drv_map
argument_list|)
expr_stmt|;
name|pd0
operator|=
name|MR_ArPdGet
argument_list|(
name|arRef
argument_list|,
name|arm
argument_list|,
name|drv_map
argument_list|)
expr_stmt|;
name|pd1
operator|=
name|MR_ArPdGet
argument_list|(
name|arRef
argument_list|,
operator|(
name|arm
operator|+
literal|1
operator|)
operator|>=
name|span_row_size
condition|?
operator|(
name|arm
operator|+
literal|1
operator|-
name|span_row_size
operator|)
else|:
name|arm
operator|+
literal|1
argument_list|,
name|drv_map
argument_list|)
expr_stmt|;
comment|/* get the pending cmds for the data and mirror arms */
name|pend0
operator|=
name|mrsas_atomic_read
argument_list|(
operator|&
name|lbInfo
operator|->
name|scsi_pending_cmds
index|[
name|pd0
index|]
argument_list|)
expr_stmt|;
name|pend1
operator|=
name|mrsas_atomic_read
argument_list|(
operator|&
name|lbInfo
operator|->
name|scsi_pending_cmds
index|[
name|pd1
index|]
argument_list|)
expr_stmt|;
comment|/* Determine the disk whose head is nearer to the req. block */
name|diff0
operator|=
name|ABS_DIFF
argument_list|(
name|block
argument_list|,
name|lbInfo
operator|->
name|last_accessed_block
index|[
name|pd0
index|]
argument_list|)
expr_stmt|;
name|diff1
operator|=
name|ABS_DIFF
argument_list|(
name|block
argument_list|,
name|lbInfo
operator|->
name|last_accessed_block
index|[
name|pd1
index|]
argument_list|)
expr_stmt|;
name|bestArm
operator|=
operator|(
name|diff0
operator|<=
name|diff1
condition|?
name|arm
else|:
name|arm
operator|^
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bestArm
operator|==
name|arm
operator|&&
name|pend0
operator|>
name|pend1
operator|+
name|sc
operator|->
name|lb_pending_cmds
operator|)
operator|||
operator|(
name|bestArm
operator|!=
name|arm
operator|&&
name|pend1
operator|>
name|pend0
operator|+
name|sc
operator|->
name|lb_pending_cmds
operator|)
condition|)
name|bestArm
operator|^=
literal|1
expr_stmt|;
comment|/* Update the last accessed block on the correct pd */
name|lbInfo
operator|->
name|last_accessed_block
index|[
name|bestArm
operator|==
name|arm
condition|?
name|pd0
else|:
name|pd1
index|]
operator|=
name|block
operator|+
name|count
operator|-
literal|1
expr_stmt|;
name|io_info
operator|->
name|span_arm
operator|=
operator|(
name|span
operator|<<
name|RAID_CTX_SPANARM_SPAN_SHIFT
operator|)
operator||
name|bestArm
expr_stmt|;
name|io_info
operator|->
name|pd_after_lb
operator|=
operator|(
name|bestArm
operator|==
name|arm
operator|)
condition|?
name|pd0
else|:
name|pd1
expr_stmt|;
if|#
directive|if
name|SPAN_DEBUG
if|if
condition|(
name|arm
operator|!=
name|bestArm
condition|)
name|printf
argument_list|(
literal|"LSI Debug R1 Load balance occur - span 0x%x arm 0x%x bestArm 0x%x "
literal|"io_info->span_arm 0x%x\n"
argument_list|,
name|span
argument_list|,
name|arm
argument_list|,
name|bestArm
argument_list|,
name|io_info
operator|->
name|span_arm
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|io_info
operator|->
name|pd_after_lb
return|;
block|}
end_function

begin_comment
comment|/*  * mrsas_get_updated_dev_handle:	Get the update dev handle  * Inputs:  *	sc - Adapter instance soft state  *	lbInfo - Load balance info  *	io_info - io_info pointer  *  * This function determines and returns the updated dev handle.  */
end_comment

begin_function
name|u_int16_t
name|mrsas_get_updated_dev_handle
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|PLD_LOAD_BALANCE_INFO
name|lbInfo
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|)
block|{
name|u_int8_t
name|arm_pd
decl_stmt|;
name|u_int16_t
name|devHandle
decl_stmt|;
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|drv_map
decl_stmt|;
name|drv_map
operator|=
name|sc
operator|->
name|ld_drv_map
index|[
operator|(
name|sc
operator|->
name|map_id
operator|&
literal|1
operator|)
index|]
expr_stmt|;
comment|/* get best new arm */
name|arm_pd
operator|=
name|mrsas_get_best_arm_pd
argument_list|(
name|sc
argument_list|,
name|lbInfo
argument_list|,
name|io_info
argument_list|)
expr_stmt|;
name|devHandle
operator|=
name|MR_PdDevHandleGet
argument_list|(
name|arm_pd
argument_list|,
name|drv_map
argument_list|)
expr_stmt|;
name|mrsas_atomic_inc
argument_list|(
operator|&
name|lbInfo
operator|->
name|scsi_pending_cmds
index|[
name|arm_pd
index|]
argument_list|)
expr_stmt|;
return|return
name|devHandle
return|;
block|}
end_function

begin_comment
comment|/*  * MR_GetPhyParams:	Calculates arm, span, and block  * Inputs:			Adapter soft state  * 					Logical drive number (LD)  * 					Stripe number(stripRow)  * 					Reference in stripe (stripRef)  *  * Outputs:			Absolute Block number in the physical disk  *  * This routine calculates the arm, span and block for the specified stripe and  * reference in stripe.  */
end_comment

begin_function
name|u_int8_t
name|MR_GetPhyParams
parameter_list|(
name|struct
name|mrsas_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|stripRow
parameter_list|,
name|u_int16_t
name|stripRef
parameter_list|,
name|struct
name|IO_REQUEST_INFO
modifier|*
name|io_info
parameter_list|,
name|RAID_CONTEXT
modifier|*
name|pRAID_Context
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|)
block|{
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|u_int32_t
name|pd
decl_stmt|,
name|arRef
decl_stmt|;
name|u_int8_t
name|physArm
decl_stmt|,
name|span
decl_stmt|;
name|u_int64_t
name|row
decl_stmt|;
name|u_int8_t
name|retval
init|=
name|TRUE
decl_stmt|;
name|int
name|error_code
init|=
literal|0
decl_stmt|;
name|u_int64_t
modifier|*
name|pdBlock
init|=
operator|&
name|io_info
operator|->
name|pdBlock
decl_stmt|;
name|u_int16_t
modifier|*
name|pDevHandle
init|=
operator|&
name|io_info
operator|->
name|devHandle
decl_stmt|;
name|u_int32_t
name|rowMod
decl_stmt|,
name|armQ
decl_stmt|,
name|arm
decl_stmt|,
name|logArm
decl_stmt|;
name|u_int8_t
name|do_invader
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_INVADER
operator|)
operator|||
operator|(
name|sc
operator|->
name|device_id
operator|==
name|MRSAS_FURY
operator|)
condition|)
name|do_invader
operator|=
literal|1
expr_stmt|;
name|row
operator|=
name|mega_div64_32
argument_list|(
name|stripRow
argument_list|,
name|raid
operator|->
name|rowDataSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|raid
operator|->
name|level
operator|==
literal|6
condition|)
block|{
comment|/* logical arm within row */
name|logArm
operator|=
name|mega_mod64
argument_list|(
name|stripRow
argument_list|,
name|raid
operator|->
name|rowDataSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|raid
operator|->
name|rowSize
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|rowMod
operator|=
name|mega_mod64
argument_list|(
name|row
argument_list|,
name|raid
operator|->
name|rowSize
argument_list|)
expr_stmt|;
comment|/* get logical row mod */
name|armQ
operator|=
name|raid
operator|->
name|rowSize
operator|-
literal|1
operator|-
name|rowMod
expr_stmt|;
comment|/* index of Q drive */
name|arm
operator|=
name|armQ
operator|+
literal|1
operator|+
name|logArm
expr_stmt|;
comment|/* data always logically follows Q */
if|if
condition|(
name|arm
operator|>=
name|raid
operator|->
name|rowSize
condition|)
comment|/* handle wrap condition */
name|arm
operator|-=
name|raid
operator|->
name|rowSize
expr_stmt|;
name|physArm
operator|=
operator|(
name|u_int8_t
operator|)
name|arm
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|raid
operator|->
name|modFactor
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|physArm
operator|=
name|MR_LdDataArmGet
argument_list|(
name|ld
argument_list|,
name|mega_mod64
argument_list|(
name|stripRow
argument_list|,
name|raid
operator|->
name|modFactor
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|raid
operator|->
name|spanDepth
operator|==
literal|1
condition|)
block|{
name|span
operator|=
literal|0
expr_stmt|;
operator|*
name|pdBlock
operator|=
name|row
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
block|}
else|else
block|{
name|span
operator|=
operator|(
name|u_int8_t
operator|)
name|MR_GetSpanBlock
argument_list|(
name|ld
argument_list|,
name|row
argument_list|,
name|pdBlock
argument_list|,
name|map
argument_list|,
operator|&
name|error_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_code
operator|==
literal|1
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Get the array on which this span is present */
name|arRef
operator|=
name|MR_LdSpanArrayGet
argument_list|(
name|ld
argument_list|,
name|span
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|pd
operator|=
name|MR_ArPdGet
argument_list|(
name|arRef
argument_list|,
name|physArm
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Get the Pd. */
if|if
condition|(
name|pd
operator|!=
name|MR_PD_INVALID
condition|)
comment|/* Get dev handle from Pd */
operator|*
name|pDevHandle
operator|=
name|MR_PdDevHandleGet
argument_list|(
name|pd
argument_list|,
name|map
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|pDevHandle
operator|=
name|MR_PD_INVALID
expr_stmt|;
comment|/* set dev handle as invalid. */
if|if
condition|(
operator|(
name|raid
operator|->
name|level
operator|>=
literal|5
operator|)
operator|&&
operator|(
operator|(
operator|!
name|do_invader
operator|)
operator|||
operator|(
name|do_invader
operator|&&
name|raid
operator|->
name|regTypeReqOnRead
operator|!=
name|REGION_TYPE_UNUSED
operator|)
operator|)
condition|)
name|pRAID_Context
operator|->
name|regLockFlags
operator|=
name|REGION_TYPE_EXCLUSIVE
expr_stmt|;
elseif|else
if|if
condition|(
name|raid
operator|->
name|level
operator|==
literal|1
condition|)
block|{
comment|/* Get Alternate Pd. */
name|pd
operator|=
name|MR_ArPdGet
argument_list|(
name|arRef
argument_list|,
name|physArm
operator|+
literal|1
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|!=
name|MR_PD_INVALID
condition|)
comment|/* Get dev handle from Pd. */
operator|*
name|pDevHandle
operator|=
name|MR_PdDevHandleGet
argument_list|(
name|pd
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|pdBlock
operator|+=
name|stripRef
operator|+
name|MR_LdSpanPtrGet
argument_list|(
name|ld
argument_list|,
name|span
argument_list|,
name|map
argument_list|)
operator|->
name|startBlk
expr_stmt|;
name|pRAID_Context
operator|->
name|spanArm
operator|=
operator|(
name|span
operator|<<
name|RAID_CTX_SPANARM_SPAN_SHIFT
operator|)
operator||
name|physArm
expr_stmt|;
name|io_info
operator|->
name|span_arm
operator|=
name|pRAID_Context
operator|->
name|spanArm
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * MR_GetSpanBlock:	Calculates span block  * Inputs:			LD  * 					row PD  * 					span block  * 					RAID map pointer  *  * Outputs:			Span number Error code  *  * This routine calculates the span from the span block info.  */
end_comment

begin_function
name|u_int32_t
name|MR_GetSpanBlock
parameter_list|(
name|u_int32_t
name|ld
parameter_list|,
name|u_int64_t
name|row
parameter_list|,
name|u_int64_t
modifier|*
name|span_blk
parameter_list|,
name|MR_DRV_RAID_MAP_ALL
modifier|*
name|map
parameter_list|,
name|int
modifier|*
name|div_error
parameter_list|)
block|{
name|MR_SPAN_BLOCK_INFO
modifier|*
name|pSpanBlock
init|=
name|MR_LdSpanInfoGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|MR_QUAD_ELEMENT
modifier|*
name|quad
decl_stmt|;
name|MR_LD_RAID
modifier|*
name|raid
init|=
name|MR_LdRaidGet
argument_list|(
name|ld
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|u_int32_t
name|span
decl_stmt|,
name|j
decl_stmt|;
name|u_int64_t
name|blk
decl_stmt|,
name|debugBlk
decl_stmt|;
for|for
control|(
name|span
operator|=
literal|0
init|;
name|span
operator|<
name|raid
operator|->
name|spanDepth
condition|;
name|span
operator|++
operator|,
name|pSpanBlock
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pSpanBlock
operator|->
name|block_span_info
operator|.
name|noElements
condition|;
name|j
operator|++
control|)
block|{
name|quad
operator|=
operator|&
name|pSpanBlock
operator|->
name|block_span_info
operator|.
name|quad
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|quad
operator|->
name|diff
operator|==
literal|0
condition|)
block|{
operator|*
name|div_error
operator|=
literal|1
expr_stmt|;
return|return
name|span
return|;
block|}
if|if
condition|(
name|quad
operator|->
name|logStart
operator|<=
name|row
operator|&&
name|row
operator|<=
name|quad
operator|->
name|logEnd
operator|&&
operator|(
name|mega_mod64
argument_list|(
name|row
operator|-
name|quad
operator|->
name|logStart
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|span_blk
operator|!=
name|NULL
condition|)
block|{
name|blk
operator|=
name|mega_div64_32
argument_list|(
operator|(
name|row
operator|-
name|quad
operator|->
name|logStart
operator|)
argument_list|,
name|quad
operator|->
name|diff
argument_list|)
expr_stmt|;
name|debugBlk
operator|=
name|blk
expr_stmt|;
name|blk
operator|=
operator|(
name|blk
operator|+
name|quad
operator|->
name|offsetInSpan
operator|)
operator|<<
name|raid
operator|->
name|stripeShift
expr_stmt|;
operator|*
name|span_blk
operator|=
name|blk
expr_stmt|;
block|}
return|return
name|span
return|;
block|}
block|}
block|}
return|return
name|span
return|;
block|}
end_function

end_unit

