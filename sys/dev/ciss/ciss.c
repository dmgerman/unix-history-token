begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Michael Smith  * Copyright (c) 2004 Paul Saab  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_comment
comment|/*  * Common Interface for SCSI-3 Support driver.  *  * CISS claims to provide a common interface between a generic SCSI  * transport and an intelligent host adapter.  *  * This driver supports CISS as defined in the document "CISS Command  * Interface for SCSI-3 Support Open Specification", Version 1.04,  * Valence Number 1, dated 20001127, produced by Compaq Computer  * Corporation.  This document appears to be a hastily and somewhat  * arbitrarlily cut-down version of a larger (and probably even more  * chaotic and inconsistent) Compaq internal document.  Various  * details were also gleaned from Compaq's "cciss" driver for Linux.  *  * We provide a shim layer between the CISS interface and CAM,  * offloading most of the queueing and being-a-disk chores onto CAM.  * Entry to the driver is via the PCI bus attachment (ciss_probe,  * ciss_attach, etc) and via the CAM interface (ciss_cam_action,  * ciss_cam_poll).  The Compaq CISS adapters are, however, poor SCSI  * citizens and we have to fake up some responses to get reasonable  * behaviour out of them.  In addition, the CISS command set is by no  * means adequate to support the functionality of a RAID controller,  * and thus the supported Compaq adapters utilise portions of the  * control protocol from earlier Compaq adapter families.  *  * Note that we only support the "simple" transport layer over PCI.  * This interface (ab)uses the I2O register set (specifically the post  * queues) to exchange commands with the adapter.  Other interfaces  * are available, but we aren't supposed to know about them, and it is  * dubious whether they would provide major performance improvements  * except under extreme load.  *  * Currently the only supported CISS adapters are the Compaq Smart  * Array 5* series (5300, 5i, 532).  Even with only three adapters,  * Compaq still manage to have interface variations.  *  *  * Thanks must go to Fred Harris and Darryl DeVinney at Compaq, as  * well as Paul Saab at Yahoo! for their assistance in making this  * driver happen.  *  * More thanks must go to John Cagle at HP for the countless hours  * spent making this driver "work" with the MSA* series storage  * enclosures.  Without his help (and nagging), this driver could not  * be used with these enclosures.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/endian.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ciss/cissreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ciss/cissvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ciss/cissio.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|CISS_MALLOC_CLASS
argument_list|,
literal|"ciss_data"
argument_list|,
literal|"ciss internal data buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* pci interface */
end_comment

begin_function_decl
specifier|static
name|int
name|ciss_lookup
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* (de)initialisation functions, control wrappers */
end_comment

begin_function_decl
specifier|static
name|int
name|ciss_init_pci
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_wait_adapter
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_flush_adapter
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_init_requests
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_command_map_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_identify_adapter
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_init_logical
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_init_physical
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_filter_physical
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_lun_report
modifier|*
name|cll
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_identify_logical
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_ldrive
modifier|*
name|ld
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_get_ldrive_status
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_ldrive
modifier|*
name|ld
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_update_config
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_accept_media
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_ldrive
modifier|*
name|ld
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_init_sysctl
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_soft_reset
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_free
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_spawn_notify_thread
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_kill_notify_thread
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* request submission/completion */
end_comment

begin_function_decl
specifier|static
name|int
name|ciss_start
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_done
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_complete
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_report_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|,
name|int
modifier|*
name|command_status
parameter_list|,
name|int
modifier|*
name|scsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_synch_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_poll_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_wait_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int	ciss_abort_request(struct ciss_request *cr);
endif|#
directive|endif
end_endif

begin_comment
comment|/* request queueing */
end_comment

begin_function_decl
specifier|static
name|int
name|ciss_get_request
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_request
modifier|*
modifier|*
name|crp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_preen_command
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_release_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* request helpers */
end_comment

begin_function_decl
specifier|static
name|int
name|ciss_get_bmic_request
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_request
modifier|*
modifier|*
name|crp
parameter_list|,
name|int
name|opcode
parameter_list|,
name|void
modifier|*
modifier|*
name|bufp
parameter_list|,
name|size_t
name|bufsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_user_command
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|IOCTL_Command_struct
modifier|*
name|ioc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* DMA map/unmap */
end_comment

begin_function_decl
specifier|static
name|int
name|ciss_map_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_request_map_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_unmap_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* CAM interface */
end_comment

begin_function_decl
specifier|static
name|int
name|ciss_cam_init
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_cam_rescan_target
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_cam_rescan_all
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_cam_rescan_callback
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_cam_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_cam_action_io
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_cam_emulate
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_cam_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_cam_complete
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_cam_complete_fixup
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cam_periph
modifier|*
name|ciss_find_periph
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_name_device
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* periodic status monitoring */
end_comment

begin_function_decl
specifier|static
name|void
name|ciss_periodic
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_notify_event
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_notify_complete
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_notify_abort
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_notify_abort_bmic
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_notify_hotplug
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_notify
modifier|*
name|cn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_notify_logical
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_notify
modifier|*
name|cn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_notify_physical
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_notify
modifier|*
name|cn
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* debugging output */
end_comment

begin_function_decl
specifier|static
name|void
name|ciss_print_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ciss_print_ldrive
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_ldrive
modifier|*
name|ld
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ciss_name_ldrive_status
parameter_list|(
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciss_decode_ldrive_status
parameter_list|(
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ciss_name_ldrive_org
parameter_list|(
name|int
name|org
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ciss_name_command_status
parameter_list|(
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * PCI bus interface.  */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|ciss_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ciss_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ciss_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ciss_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ciss_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ciss_pci_driver
init|=
block|{
literal|"ciss"
block|,
name|ciss_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ciss_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ciss_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ciss
argument_list|,
name|pci
argument_list|,
name|ciss_pci_driver
argument_list|,
name|ciss_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ciss
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ciss
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Control device interface.  */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|ciss_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|ciss_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|ciss_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ciss_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|ciss_open
block|,
operator|.
name|d_close
operator|=
name|ciss_close
block|,
operator|.
name|d_ioctl
operator|=
name|ciss_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"ciss"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This tunable can be set at boot time and controls whether physical devices  * that are marked hidden by the firmware should be exposed anyways.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|ciss_expose_hidden_physical
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ciss.expose_hidden_physical"
argument_list|,
operator|&
name|ciss_expose_hidden_physical
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/************************************************************************  * CISS adapters amazingly don't have a defined programming interface  * value.  (One could say some very despairing things about PCI and  * people just not getting the general idea.)  So we are forced to  * stick with matching against subvendor/subdevice, and thus have to  * be updated for every new CISS adapter that appears.  */
end_comment

begin_define
define|#
directive|define
name|CISS_BOARD_SA5
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|CISS_BOARD_SA5B
value|(1<<1)
end_define

begin_struct
specifier|static
struct|struct
block|{
name|u_int16_t
name|subvendor
decl_stmt|;
name|u_int16_t
name|subdevice
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|ciss_vendor_data
index|[]
init|=
block|{
block|{
literal|0x0e11
block|,
literal|0x4070
block|,
name|CISS_BOARD_SA5
block|,
literal|"Compaq Smart Array 5300"
block|}
block|,
block|{
literal|0x0e11
block|,
literal|0x4080
block|,
name|CISS_BOARD_SA5B
block|,
literal|"Compaq Smart Array 5i"
block|}
block|,
block|{
literal|0x0e11
block|,
literal|0x4082
block|,
name|CISS_BOARD_SA5B
block|,
literal|"Compaq Smart Array 532"
block|}
block|,
block|{
literal|0x0e11
block|,
literal|0x4083
block|,
name|CISS_BOARD_SA5B
block|,
literal|"HP Smart Array 5312"
block|}
block|,
block|{
literal|0x0e11
block|,
literal|0x4091
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array 6i"
block|}
block|,
block|{
literal|0x0e11
block|,
literal|0x409A
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array 641"
block|}
block|,
block|{
literal|0x0e11
block|,
literal|0x409B
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array 642"
block|}
block|,
block|{
literal|0x0e11
block|,
literal|0x409C
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array 6400"
block|}
block|,
block|{
literal|0x0e11
block|,
literal|0x409D
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array 6400 EM"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3211
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array E200i"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3212
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array E200"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3213
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array E200i"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3214
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array E200i"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3215
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array E200i"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3220
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3222
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3223
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array P800"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3225
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array P600"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3230
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3231
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3232
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3233
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3234
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array P400"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3235
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array P400i"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3236
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3237
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3238
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x3239
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x323A
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x323B
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array"
block|}
block|,
block|{
literal|0x103C
block|,
literal|0x323C
block|,
name|CISS_BOARD_SA5
block|,
literal|"HP Smart Array"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_comment
comment|/************************************************************************  * Find a match for the device in our list of known adapters.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_lookup
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ciss_vendor_data
index|[
name|i
index|]
operator|.
name|desc
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
operator|==
name|ciss_vendor_data
index|[
name|i
index|]
operator|.
name|subvendor
operator|)
operator|&&
operator|(
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
operator|==
name|ciss_vendor_data
index|[
name|i
index|]
operator|.
name|subdevice
operator|)
condition|)
block|{
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Match a known CISS adapter.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|ciss_lookup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|ciss_vendor_data
index|[
name|i
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Attach the driver to this adapter.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CISS_DEBUG
comment|/* print structure/union sizes */
name|debug_struct
argument_list|(
name|ciss_command
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_header
argument_list|)
expr_stmt|;
name|debug_union
argument_list|(
name|ciss_device_address
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_cdb
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_report_cdb
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_notify_cdb
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_notify
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_message_cdb
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_error_info_pointer
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_error_info
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_sg_entry
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_config_table
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_bmic_cdb
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_bmic_id_ldrive
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_bmic_id_lstatus
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_bmic_id_table
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_bmic_id_pdrive
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_bmic_blink_pdrive
argument_list|)
expr_stmt|;
name|debug_struct
argument_list|(
name|ciss_bmic_flush_cache
argument_list|)
expr_stmt|;
name|debug_const
argument_list|(
name|CISS_MAX_REQUESTS
argument_list|)
expr_stmt|;
name|debug_const
argument_list|(
name|CISS_MAX_LOGICAL
argument_list|)
expr_stmt|;
name|debug_const
argument_list|(
name|CISS_INTERRUPT_COALESCE_DELAY
argument_list|)
expr_stmt|;
name|debug_const
argument_list|(
name|CISS_INTERRUPT_COALESCE_COUNT
argument_list|)
expr_stmt|;
name|debug_const
argument_list|(
name|CISS_COMMAND_ALLOC_SIZE
argument_list|)
expr_stmt|;
name|debug_const
argument_list|(
name|CISS_COMMAND_SG_LENGTH
argument_list|)
expr_stmt|;
name|debug_type
argument_list|(
name|cciss_pci_info_struct
argument_list|)
expr_stmt|;
name|debug_type
argument_list|(
name|cciss_coalint_struct
argument_list|)
expr_stmt|;
name|debug_type
argument_list|(
name|cciss_coalint_struct
argument_list|)
expr_stmt|;
name|debug_type
argument_list|(
name|NodeName_type
argument_list|)
expr_stmt|;
name|debug_type
argument_list|(
name|NodeName_type
argument_list|)
expr_stmt|;
name|debug_type
argument_list|(
name|Heartbeat_type
argument_list|)
expr_stmt|;
name|debug_type
argument_list|(
name|BusTypes_type
argument_list|)
expr_stmt|;
name|debug_type
argument_list|(
name|FirmwareVer_type
argument_list|)
expr_stmt|;
name|debug_type
argument_list|(
name|DriverVer_type
argument_list|)
expr_stmt|;
name|debug_type
argument_list|(
name|IOCTL_Command_struct
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ciss_dev
operator|=
name|dev
expr_stmt|;
comment|/*      * Work out adapter type.      */
name|i
operator|=
name|ciss_lookup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"unknown adapter type\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ciss_vendor_data
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CISS_BOARD_SA5
condition|)
block|{
name|sc
operator|->
name|ciss_interrupt_mask
operator|=
name|CISS_TL_SIMPLE_INTR_OPQ_SA5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ciss_vendor_data
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CISS_BOARD_SA5B
condition|)
block|{
name|sc
operator|->
name|ciss_interrupt_mask
operator|=
name|CISS_TL_SIMPLE_INTR_OPQ_SA5B
expr_stmt|;
block|}
else|else
block|{
comment|/* really an error on our part */
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"unable to determine hardware type\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Do PCI-specific init.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_init_pci
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*      * Initialise driver queues.      */
name|ciss_initq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ciss_initq_busy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ciss_initq_complete
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ciss_initq_notify
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Initalize device sysctls.      */
name|ciss_init_sysctl
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Initialise command/request pool.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_init_requests
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*      * Get adapter information.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_identify_adapter
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*      * Find all the physical devices.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_init_physical
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*      * Build our private table of logical devices.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_init_logical
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*      * Enable interrupts so that the CAM scan can complete.      */
name|CISS_TL_SIMPLE_ENABLE_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Initialise the CAM interface.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_cam_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*      * Start the heartbeat routine and event chain.      */
name|ciss_periodic
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Create the control device.      */
name|sc
operator|->
name|ciss_dev_t
operator|=
name|make_dev
argument_list|(
operator|&
name|ciss_cdevsw
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|,
literal|"ciss%d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ciss_dev_t
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
comment|/*      * The adapter is running; synchronous commands can now sleep      * waiting for an interrupt to signal completion.      */
name|sc
operator|->
name|ciss_flags
operator||=
name|CISS_FLAG_RUNNING
expr_stmt|;
name|ciss_spawn_notify_thread
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|ciss_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Detach the driver from this adapter.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_flags
operator|&
name|CISS_FLAG_CONTROL_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* flush adapter cache */
name|ciss_flush_adapter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* release all resources */
name|ciss_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Prepare adapter for system shutdown.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* flush adapter cache */
name|ciss_flush_adapter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_soft_reset
condition|)
name|ciss_soft_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ciss_init_sysctl
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"soft_reset"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|ciss_soft_reset
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Perform PCI-specific attachment actions.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_init_pci
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uintptr_t
name|cbase
decl_stmt|,
name|csize
decl_stmt|,
name|cofs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Allocate register window first (we need this to find the config      * struct).      */
name|error
operator|=
name|ENXIO
expr_stmt|;
name|sc
operator|->
name|ciss_regs_rid
operator|=
name|CISS_TL_SIMPLE_BAR_REGS
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ciss_regs_resource
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|ciss_regs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't allocate register window\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|ciss_regs_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|ciss_regs_resource
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ciss_regs_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|ciss_regs_resource
argument_list|)
expr_stmt|;
comment|/*      * Find the BAR holding the config structure.  If it's not the one      * we already mapped for registers, map it too.      */
name|sc
operator|->
name|ciss_cfg_rid
operator|=
name|CISS_TL_SIMPLE_READ
argument_list|(
name|sc
argument_list|,
name|CISS_TL_SIMPLE_CFG_BAR
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_cfg_rid
operator|!=
name|sc
operator|->
name|ciss_regs_rid
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|ciss_cfg_resource
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|ciss_cfg_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't allocate config window\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|cbase
operator|=
operator|(
name|uintptr_t
operator|)
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|ciss_cfg_resource
argument_list|)
expr_stmt|;
name|csize
operator|=
name|rman_get_end
argument_list|(
name|sc
operator|->
name|ciss_cfg_resource
argument_list|)
operator|-
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ciss_cfg_resource
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cbase
operator|=
operator|(
name|uintptr_t
operator|)
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|ciss_regs_resource
argument_list|)
expr_stmt|;
name|csize
operator|=
name|rman_get_end
argument_list|(
name|sc
operator|->
name|ciss_regs_resource
argument_list|)
operator|-
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ciss_regs_resource
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|cofs
operator|=
name|CISS_TL_SIMPLE_READ
argument_list|(
name|sc
argument_list|,
name|CISS_TL_SIMPLE_CFG_OFF
argument_list|)
expr_stmt|;
comment|/*      * Use the base/size/offset values we just calculated to      * sanity-check the config structure.  If it's OK, point to it.      */
if|if
condition|(
operator|(
name|cofs
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ciss_config_table
argument_list|)
operator|)
operator|>
name|csize
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"config table outside window\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|ciss_cfg
operator|=
operator|(
expr|struct
name|ciss_config_table
operator|*
operator|)
operator|(
name|cbase
operator|+
name|cofs
operator|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"config struct at %p"
argument_list|,
name|sc
operator|->
name|ciss_cfg
argument_list|)
expr_stmt|;
comment|/*      * Validate the config structure.  If we supported other transport      * methods, we could select amongst them at this point in time.      */
if|if
condition|(
name|strncmp
argument_list|(
name|sc
operator|->
name|ciss_cfg
operator|->
name|signature
argument_list|,
literal|"CISS"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"config signature mismatch (got '%c%c%c%c')\n"
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|signature
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|signature
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|signature
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|signature
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*      * Put the board into simple mode, and tell it we're using the low      * 4GB of RAM.  Set the default interrupt coalescing options.      */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ciss_cfg
operator|->
name|supported_methods
operator|&
name|CISS_TRANSPORT_METHOD_SIMPLE
operator|)
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"adapter does not support 'simple' transport layer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|ciss_cfg
operator|->
name|requested_method
operator|=
name|CISS_TRANSPORT_METHOD_SIMPLE
expr_stmt|;
name|sc
operator|->
name|ciss_cfg
operator|->
name|command_physlimit
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ciss_cfg
operator|->
name|interrupt_coalesce_delay
operator|=
name|CISS_INTERRUPT_COALESCE_DELAY
expr_stmt|;
name|sc
operator|->
name|ciss_cfg
operator|->
name|interrupt_coalesce_count
operator|=
name|CISS_INTERRUPT_COALESCE_COUNT
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
name|sc
operator|->
name|ciss_cfg
operator|->
name|host_driver
operator||=
name|CISS_DRIVER_SCSI_PREFETCH
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ciss_update_config
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"adapter refuses to accept config update (IDBR 0x%x)\n"
argument_list|,
name|CISS_TL_SIMPLE_READ
argument_list|(
name|sc
argument_list|,
name|CISS_TL_SIMPLE_IDBR
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ciss_cfg
operator|->
name|active_method
operator|!=
name|CISS_TRANSPORT_METHOD_SIMPLE
operator|)
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"adapter refuses to go into 'simple' transport mode (0x%x, 0x%x)\n"
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|supported_methods
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|active_method
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*      * Wait for the adapter to come ready.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_wait_adapter
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/*      * Turn off interrupts before we go routing anything.      */
name|CISS_TL_SIMPLE_DISABLE_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Allocate and set up our interrupt.      */
name|sc
operator|->
name|ciss_irq_rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ciss_irq_resource
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|ciss_irq_rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't allocate interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|,
name|sc
operator|->
name|ciss_irq_resource
argument_list|,
name|INTR_TYPE_CAM
operator||
name|INTR_ENTROPY
argument_list|,
name|NULL
argument_list|,
name|ciss_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ciss_intr
argument_list|)
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't set up interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*      * Allocate the parent bus DMA tag appropriate for our PCI      * interface.      *      * Note that "simple" adapters can only address within a 32-bit      * span.      */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
name|CISS_COMMAND_SG_LENGTH
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|ciss_parent_dmat
argument_list|)
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't allocate parent DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*      * Create DMA tag for mapping buffers into adapter-addressable      * space.      */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|ciss_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MAXBSIZE
argument_list|,
name|CISS_COMMAND_SG_LENGTH
argument_list|,
comment|/* maxsize, nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|busdma_lock_mutex
argument_list|,
operator|&
name|Giant
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|ciss_buffer_dmat
argument_list|)
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't allocate buffer DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Wait for the adapter to come ready.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_wait_adapter
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Wait for the adapter to come ready.      */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ciss_cfg
operator|->
name|active_method
operator|&
name|CISS_TRANSPORT_METHOD_READY
operator|)
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"waiting for adapter to come ready...\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
operator|(
name|sc
operator|->
name|ciss_cfg
operator|->
name|active_method
operator|&
name|CISS_TRANSPORT_METHOD_READY
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
comment|/* one second */
if|if
condition|(
name|i
operator|>
literal|30
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"timed out waiting for adapter to come ready\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Flush the adapter cache.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_flush_adapter
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|ciss_bmic_flush_cache
modifier|*
name|cbfc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|command_status
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cr
operator|=
name|NULL
expr_stmt|;
name|cbfc
operator|=
name|NULL
expr_stmt|;
comment|/*      * Build a BMIC request to flush the cache.  We don't disable      * it, as we may be going to do more I/O (eg. we are emulating      * the Synchronise Cache command).      */
if|if
condition|(
operator|(
name|cbfc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cbfc
argument_list|)
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_bmic_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|,
name|CISS_BMIC_FLUSH_CACHE
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cbfc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cbfc
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*      * Submit the request and wait for it to complete.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_synch_request
argument_list|(
name|cr
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error sending BMIC FLUSH_CACHE command (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Check response.      */
name|ciss_report_request
argument_list|(
name|cr
argument_list|,
operator|&
name|command_status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command_status
condition|)
block|{
case|case
name|CISS_CMD_STATUS_SUCCESS
case|:
break|break;
default|default:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error flushing cache (%s)\n"
argument_list|,
name|ciss_name_command_status
argument_list|(
name|command_status
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|cbfc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cbfc
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ciss_soft_reset
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
init|=
name|NULL
decl_stmt|;
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ciss_max_logical_bus
condition|;
name|i
operator|++
control|)
block|{
comment|/* only reset proxy controllers */
if|if
condition|(
name|sc
operator|->
name|ciss_controllers
index|[
name|i
index|]
operator|.
name|physical
operator|.
name|bus
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_bmic_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|,
name|CISS_BMIC_SOFT_RESET
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|=
name|sc
operator|->
name|ciss_controllers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_synch_request
argument_list|(
name|cr
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error resetting controller (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Allocate memory for the adapter command structures, initialise  * the request structures.  *  * Note that the entire set of commands are allocated in a single  * contiguous slab.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_init_requests
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Calculate the number of request structures/commands we are      * going to provide for this adapter.      */
name|sc
operator|->
name|ciss_max_requests
operator|=
name|min
argument_list|(
name|CISS_MAX_REQUESTS
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|max_outstanding_commands
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"using %d of %d available commands\n"
argument_list|,
name|sc
operator|->
name|ciss_max_requests
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|max_outstanding_commands
argument_list|)
expr_stmt|;
comment|/*      * Create the DMA tag for commands.      */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|ciss_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|CISS_COMMAND_ALLOC_SIZE
operator|*
name|sc
operator|->
name|ciss_max_requests
argument_list|,
literal|1
argument_list|,
comment|/* maxsize, nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|ciss_command_dmat
argument_list|)
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't allocate command DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*      * Allocate memory and make it available for DMA.      */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|ciss_command_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|ciss_command
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|ciss_command_map
argument_list|)
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't allocate command memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|ciss_command_dmat
argument_list|,
name|sc
operator|->
name|ciss_command_map
argument_list|,
name|sc
operator|->
name|ciss_command
argument_list|,
name|CISS_COMMAND_ALLOC_SIZE
operator|*
name|sc
operator|->
name|ciss_max_requests
argument_list|,
name|ciss_command_map_helper
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|ciss_command
argument_list|,
name|CISS_COMMAND_ALLOC_SIZE
operator|*
name|sc
operator|->
name|ciss_max_requests
argument_list|)
expr_stmt|;
comment|/*      * Set up the request and command structures, push requests onto      * the free queue.      */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|ciss_max_requests
condition|;
name|i
operator|++
control|)
block|{
name|cr
operator|=
operator|&
name|sc
operator|->
name|ciss_request
index|[
name|i
index|]
expr_stmt|;
name|cr
operator|->
name|cr_sc
operator|=
name|sc
expr_stmt|;
name|cr
operator|->
name|cr_tag
operator|=
name|i
expr_stmt|;
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|ciss_buffer_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|cr
operator|->
name|cr_datamap
argument_list|)
expr_stmt|;
name|ciss_enqueue_free
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ciss_command_map_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ciss_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|sc
operator|->
name|ciss_command_phys
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Identify the adapter, print some information about it.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_identify_adapter
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|command_status
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cr
operator|=
name|NULL
expr_stmt|;
comment|/*      * Get a request, allocate storage for the adapter data.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_bmic_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|,
name|CISS_BMIC_ID_CTLR
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|ciss_id
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|ciss_id
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*      * Submit the request and wait for it to complete.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_synch_request
argument_list|(
name|cr
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error sending BMIC ID_CTLR command (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Check response.      */
name|ciss_report_request
argument_list|(
name|cr
argument_list|,
operator|&
name|command_status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command_status
condition|)
block|{
case|case
name|CISS_CMD_STATUS_SUCCESS
case|:
comment|/* buffer right size */
break|break;
case|case
name|CISS_CMD_STATUS_DATA_UNDERRUN
case|:
case|case
name|CISS_CMD_STATUS_DATA_OVERRUN
case|:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"data over/underrun reading adapter information\n"
argument_list|)
expr_stmt|;
default|default:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error reading adapter information (%s)\n"
argument_list|,
name|ciss_name_command_status
argument_list|(
name|command_status
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* sanity-check reply */
if|if
condition|(
operator|!
name|sc
operator|->
name|ciss_id
operator|->
name|big_map_supported
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"adapter does not support BIG_MAP\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|#
directive|if
literal|0
comment|/* XXX later revisions may not need this */
block|sc->ciss_flags |= CISS_FLAG_FAKE_SYNCH;
endif|#
directive|endif
comment|/* XXX only really required for old 5300 adapters? */
name|sc
operator|->
name|ciss_flags
operator||=
name|CISS_FLAG_BMIC_ABORT
expr_stmt|;
comment|/* print information */
if|if
condition|(
name|bootverbose
condition|)
block|{
if|#
directive|if
literal|0
comment|/* XXX proxy volumes??? */
block|ciss_printf(sc, "  %d logical drive%s configured\n", 		    sc->ciss_id->configured_logical_drives, 		    (sc->ciss_id->configured_logical_drives == 1) ? "" : "s");
endif|#
directive|endif
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  firmware %4.4s\n"
argument_list|,
name|sc
operator|->
name|ciss_id
operator|->
name|running_firmware_revision
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  %d SCSI channels\n"
argument_list|,
name|sc
operator|->
name|ciss_id
operator|->
name|scsi_bus_count
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  signature '%.4s'\n"
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|signature
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  valence %d\n"
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|valence
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  supported I/O methods 0x%b\n"
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|supported_methods
argument_list|,
literal|"\20\1READY\2simple\3performant\4MEMQ\n"
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  active I/O method 0x%b\n"
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|active_method
argument_list|,
literal|"\20\2simple\3performant\4MEMQ\n"
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  4G page base 0x%08x\n"
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|command_physlimit
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  interrupt coalesce delay %dus\n"
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|interrupt_coalesce_delay
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  interrupt coalesce count %d\n"
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|interrupt_coalesce_count
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  max outstanding commands %d\n"
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|max_outstanding_commands
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  bus types 0x%b\n"
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|bus_types
argument_list|,
literal|"\20\1ultra2\2ultra3\10fibre1\11fibre2\n"
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  server name '%.16s'\n"
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|server_name
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  heartbeat 0x%x\n"
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|heartbeat
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ciss_id
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|ciss_id
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ciss_id
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Helper routine for generating a list of logical and physical luns.  */
end_comment

begin_function
specifier|static
name|struct
name|ciss_lun_report
modifier|*
name|ciss_report_luns
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|int
name|opcode
parameter_list|,
name|int
name|nunits
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|struct
name|ciss_report_cdb
modifier|*
name|crc
decl_stmt|;
name|struct
name|ciss_lun_report
modifier|*
name|cll
decl_stmt|;
name|int
name|command_status
decl_stmt|;
name|int
name|report_size
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cr
operator|=
name|NULL
expr_stmt|;
name|cll
operator|=
name|NULL
expr_stmt|;
comment|/*      * Get a request, allocate storage for the address list.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|report_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|cll
argument_list|)
operator|+
name|nunits
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ciss_device_address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cll
operator|=
name|malloc
argument_list|(
name|report_size
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't allocate memory for lun report\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Build the Report Logical/Physical LUNs command.      */
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_data
operator|=
name|cll
expr_stmt|;
name|cr
operator|->
name|cr_length
operator|=
name|report_size
expr_stmt|;
name|cr
operator|->
name|cr_flags
operator|=
name|CISS_REQ_DATAIN
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|physical
operator|.
name|mode
operator|=
name|CISS_HDR_ADDRESS_MODE_PERIPHERAL
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|physical
operator|.
name|bus
operator|=
literal|0
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|physical
operator|.
name|target
operator|=
literal|0
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|cdb_length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|crc
argument_list|)
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|type
operator|=
name|CISS_CDB_TYPE_COMMAND
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|attribute
operator|=
name|CISS_CDB_ATTRIBUTE_SIMPLE
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|direction
operator|=
name|CISS_CDB_DIRECTION_READ
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|timeout
operator|=
literal|30
expr_stmt|;
comment|/* XXX better suggestions? */
name|crc
operator|=
operator|(
expr|struct
name|ciss_report_cdb
operator|*
operator|)
operator|&
operator|(
name|cc
operator|->
name|cdb
operator|.
name|cdb
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|crc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|crc
argument_list|)
argument_list|)
expr_stmt|;
name|crc
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|crc
operator|->
name|length
operator|=
name|htonl
argument_list|(
name|report_size
argument_list|)
expr_stmt|;
comment|/* big-endian field */
name|cll
operator|->
name|list_size
operator|=
name|htonl
argument_list|(
name|report_size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|cll
argument_list|)
argument_list|)
expr_stmt|;
comment|/* big-endian field */
comment|/*      * Submit the request and wait for it to complete.  (timeout      * here should be much greater than above)      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_synch_request
argument_list|(
name|cr
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error sending %d LUN command (%d)\n"
argument_list|,
name|opcode
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Check response.  Note that data over/underrun is OK.      */
name|ciss_report_request
argument_list|(
name|cr
argument_list|,
operator|&
name|command_status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command_status
condition|)
block|{
case|case
name|CISS_CMD_STATUS_SUCCESS
case|:
comment|/* buffer right size */
case|case
name|CISS_CMD_STATUS_DATA_UNDERRUN
case|:
comment|/* buffer too large, not bad */
break|break;
case|case
name|CISS_CMD_STATUS_DATA_OVERRUN
case|:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"WARNING: more units than driver limit (%d)\n"
argument_list|,
name|CISS_MAX_LOGICAL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error detecting logical drive configuration (%s)\n"
argument_list|,
name|ciss_name_command_status
argument_list|(
name|command_status
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cr
operator|=
name|NULL
expr_stmt|;
name|out
label|:
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|cll
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cll
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
name|cll
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|cll
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Find logical drives on the adapter.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_init_logical
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ciss_lun_report
modifier|*
name|cll
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|ndrives
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cll
operator|=
name|ciss_report_luns
argument_list|(
name|sc
argument_list|,
name|CISS_OPCODE_REPORT_LOGICAL_LUNS
argument_list|,
name|CISS_MAX_LOGICAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cll
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* sanity-check reply */
name|ndrives
operator|=
operator|(
name|ntohl
argument_list|(
name|cll
operator|->
name|list_size
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|ciss_device_address
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ndrives
operator|<
literal|0
operator|)
operator|||
operator|(
name|ndrives
operator|>=
name|CISS_MAX_LOGICAL
operator|)
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"adapter claims to report absurd number of logical drives (%d> %d)\n"
argument_list|,
name|ndrives
argument_list|,
name|CISS_MAX_LOGICAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Save logical drive information.      */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"%d logical drive%s\n"
argument_list|,
name|ndrives
argument_list|,
operator|(
name|ndrives
operator|>
literal|1
operator|||
name|ndrives
operator|==
literal|0
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|ciss_logical
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|ciss_max_logical_bus
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ciss_ldrive
operator|*
argument_list|)
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_logical
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sc
operator|->
name|ciss_max_logical_bus
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ciss_logical
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|CISS_MAX_LOGICAL
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ciss_ldrive
argument_list|)
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_logical
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CISS_MAX_LOGICAL
condition|;
name|j
operator|++
control|)
name|sc
operator|->
name|ciss_logical
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|cl_status
operator|=
name|CISS_LD_NONEXISTENT
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CISS_MAX_LOGICAL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|ndrives
condition|)
block|{
name|struct
name|ciss_ldrive
modifier|*
name|ld
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|;
name|bus
operator|=
name|CISS_LUN_TO_BUS
argument_list|(
name|cll
operator|->
name|lun
index|[
name|i
index|]
operator|.
name|logical
operator|.
name|lun
argument_list|)
expr_stmt|;
name|target
operator|=
name|CISS_LUN_TO_TARGET
argument_list|(
name|cll
operator|->
name|lun
index|[
name|i
index|]
operator|.
name|logical
operator|.
name|lun
argument_list|)
expr_stmt|;
name|ld
operator|=
operator|&
name|sc
operator|->
name|ciss_logical
index|[
name|bus
index|]
index|[
name|target
index|]
expr_stmt|;
name|ld
operator|->
name|cl_address
operator|=
name|cll
operator|->
name|lun
index|[
name|i
index|]
expr_stmt|;
name|ld
operator|->
name|cl_controller
operator|=
operator|&
name|sc
operator|->
name|ciss_controllers
index|[
name|bus
index|]
expr_stmt|;
if|if
condition|(
name|ciss_identify_logical
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* 	     * If the drive has had media exchanged, we should bring it online. 	     */
if|if
condition|(
name|ld
operator|->
name|cl_lstatus
operator|->
name|media_exchanged
condition|)
name|ciss_accept_media
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|cll
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cll
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ciss_init_physical
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ciss_lun_report
modifier|*
name|cll
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|int
name|nphys
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bus
operator|=
literal|0
expr_stmt|;
name|target
operator|=
literal|0
expr_stmt|;
name|cll
operator|=
name|ciss_report_luns
argument_list|(
name|sc
argument_list|,
name|CISS_OPCODE_REPORT_PHYSICAL_LUNS
argument_list|,
name|CISS_MAX_PHYSICAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cll
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|nphys
operator|=
operator|(
name|ntohl
argument_list|(
name|cll
operator|->
name|list_size
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|ciss_device_address
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"%d physical device%s\n"
argument_list|,
name|nphys
argument_list|,
operator|(
name|nphys
operator|>
literal|1
operator|||
name|nphys
operator|==
literal|0
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/*      * Figure out the bus mapping.      * Logical buses include both the local logical bus for local arrays and      * proxy buses for remote arrays.  Physical buses are numbered by the      * controller and represent physical buses that hold physical devices.      * We shift these bus numbers so that everything fits into a single flat      * numbering space for CAM.  Logical buses occupy the first 32 CAM bus      * numbers, and the physical bus numbers are shifted to be above that.      * This results in the various driver arrays being indexed as follows:      *      * ciss_controllers[] - indexed by logical bus      * ciss_cam_sim[]     - indexed by both logical and physical, with physical      *                      being shifted by 32.      * ciss_logical[][]   - indexed by logical bus      * ciss_physical[][]  - indexed by physical bus      *      * XXX This is getting more and more hackish.  CISS really doesn't play      *     well with a standard SCSI model; devices are addressed via magic      *     cookies, not via b/t/l addresses.  Since there is no way to store      *     the cookie in the CAM device object, we have to keep these lookup      *     tables handy so that the devices can be found quickly at the cost      *     of wasting memory and having a convoluted lookup scheme.  This      *     driver should probably be converted to block interface.      */
comment|/*      * If the L2 and L3 SCSI addresses are 0, this signifies a proxy      * controller. A proxy controller is another physical controller      * behind the primary PCI controller. We need to know about this      * so that BMIC commands can be properly targeted.  There can be      * proxy controllers attached to a single PCI controller, so      * find the highest numbered one so the array can be properly      * sized.      */
name|sc
operator|->
name|ciss_max_logical_bus
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nphys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cll
operator|->
name|lun
index|[
name|i
index|]
operator|.
name|physical
operator|.
name|extra_address
operator|==
literal|0
condition|)
block|{
name|bus
operator|=
name|cll
operator|->
name|lun
index|[
name|i
index|]
operator|.
name|physical
operator|.
name|bus
expr_stmt|;
name|sc
operator|->
name|ciss_max_logical_bus
operator|=
name|max
argument_list|(
name|sc
operator|->
name|ciss_max_logical_bus
argument_list|,
name|bus
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bus
operator|=
name|CISS_EXTRA_BUS2
argument_list|(
name|cll
operator|->
name|lun
index|[
name|i
index|]
operator|.
name|physical
operator|.
name|extra_address
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ciss_max_physical_bus
operator|=
name|max
argument_list|(
name|sc
operator|->
name|ciss_max_physical_bus
argument_list|,
name|bus
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|ciss_controllers
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|ciss_max_logical_bus
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ciss_device_address
argument_list|)
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_controllers
operator|==
name|NULL
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"Could not allocate memory for controller map\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* setup a map of controller addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nphys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cll
operator|->
name|lun
index|[
name|i
index|]
operator|.
name|physical
operator|.
name|extra_address
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|ciss_controllers
index|[
name|cll
operator|->
name|lun
index|[
name|i
index|]
operator|.
name|physical
operator|.
name|bus
index|]
operator|=
name|cll
operator|->
name|lun
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|ciss_physical
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|ciss_max_physical_bus
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ciss_pdrive
operator|*
argument_list|)
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_physical
operator|==
name|NULL
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"Could not allocate memory for physical device map\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ciss_max_physical_bus
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ciss_physical
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ciss_pdrive
argument_list|)
operator|*
name|CISS_MAX_PHYSTGT
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_physical
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"Could not allocate memory for target map\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ciss_filter_physical
argument_list|(
name|sc
argument_list|,
name|cll
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|cll
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cll
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ciss_filter_physical
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_lun_report
modifier|*
name|cll
parameter_list|)
block|{
name|u_int32_t
name|ea
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nphys
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|;
name|nphys
operator|=
operator|(
name|ntohl
argument_list|(
name|cll
operator|->
name|list_size
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|ciss_device_address
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nphys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cll
operator|->
name|lun
index|[
name|i
index|]
operator|.
name|physical
operator|.
name|extra_address
operator|==
literal|0
condition|)
continue|continue;
comment|/* 	 * Filter out devices that we don't want.  Level 3 LUNs could 	 * probably be supported, but the docs don't give enough of a 	 * hint to know how. 	 * 	 * The mode field of the physical address is likely set to have 	 * hard disks masked out.  Honor it unless the user has overridden 	 * us with the tunable.  We also munge the inquiry data for these 	 * disks so that they only show up as passthrough devices.  Keeping 	 * them visible in this fashion is useful for doing things like 	 * flashing firmware. 	 */
name|ea
operator|=
name|cll
operator|->
name|lun
index|[
name|i
index|]
operator|.
name|physical
operator|.
name|extra_address
expr_stmt|;
if|if
condition|(
operator|(
name|CISS_EXTRA_BUS3
argument_list|(
name|ea
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|CISS_EXTRA_TARGET3
argument_list|(
name|ea
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|CISS_EXTRA_MODE2
argument_list|(
name|ea
argument_list|)
operator|==
literal|0x3
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ciss_expose_hidden_physical
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cll
operator|->
name|lun
index|[
name|i
index|]
operator|.
name|physical
operator|.
name|mode
operator|==
name|CISS_HDR_ADDRESS_MODE_MASK_PERIPHERAL
operator|)
condition|)
continue|continue;
comment|/* 	 * Note: CISS firmware numbers physical busses starting at '1', not 	 *       '0'.  This numbering is internal to the firmware and is only 	 *       used as a hint here. 	 */
name|bus
operator|=
name|CISS_EXTRA_BUS2
argument_list|(
name|ea
argument_list|)
operator|-
literal|1
expr_stmt|;
name|target
operator|=
name|CISS_EXTRA_TARGET2
argument_list|(
name|ea
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ciss_physical
index|[
name|bus
index|]
index|[
name|target
index|]
operator|.
name|cp_address
operator|=
name|cll
operator|->
name|lun
index|[
name|i
index|]
expr_stmt|;
name|sc
operator|->
name|ciss_physical
index|[
name|bus
index|]
index|[
name|target
index|]
operator|.
name|cp_online
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ciss_inquiry_logical
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_ldrive
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|struct
name|scsi_inquiry
modifier|*
name|inq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|command_status
decl_stmt|;
name|cr
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ld
operator|->
name|cl_geometry
argument_list|,
sizeof|sizeof
argument_list|(
name|ld
operator|->
name|cl_geometry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_data
operator|=
operator|&
name|ld
operator|->
name|cl_geometry
expr_stmt|;
name|cr
operator|->
name|cr_length
operator|=
sizeof|sizeof
argument_list|(
name|ld
operator|->
name|cl_geometry
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_flags
operator|=
name|CISS_REQ_DATAIN
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|=
name|ld
operator|->
name|cl_address
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|cdb_length
operator|=
literal|6
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|type
operator|=
name|CISS_CDB_TYPE_COMMAND
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|attribute
operator|=
name|CISS_CDB_ATTRIBUTE_SIMPLE
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|direction
operator|=
name|CISS_CDB_DIRECTION_READ
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|timeout
operator|=
literal|30
expr_stmt|;
name|inq
operator|=
operator|(
expr|struct
name|scsi_inquiry
operator|*
operator|)
operator|&
operator|(
name|cc
operator|->
name|cdb
operator|.
name|cdb
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|inq
operator|->
name|opcode
operator|=
name|INQUIRY
expr_stmt|;
name|inq
operator|->
name|byte2
operator|=
name|SI_EVPD
expr_stmt|;
name|inq
operator|->
name|page_code
operator|=
name|CISS_VPD_LOGICAL_DRIVE_GEOMETRY
expr_stmt|;
name|inq
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
name|ld
operator|->
name|cl_geometry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_synch_request
argument_list|(
name|cr
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error getting geometry (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ciss_report_request
argument_list|(
name|cr
argument_list|,
operator|&
name|command_status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command_status
condition|)
block|{
case|case
name|CISS_CMD_STATUS_SUCCESS
case|:
case|case
name|CISS_CMD_STATUS_DATA_UNDERRUN
case|:
break|break;
case|case
name|CISS_CMD_STATUS_DATA_OVERRUN
case|:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"WARNING: Data overrun\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"Error detecting logical drive geometry (%s)\n"
argument_list|,
name|ciss_name_command_status
argument_list|(
name|command_status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Identify a logical drive, initialise state related to it.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_identify_logical
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_ldrive
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|struct
name|ciss_bmic_cdb
modifier|*
name|cbc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|command_status
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cr
operator|=
name|NULL
expr_stmt|;
comment|/*      * Build a BMIC request to fetch the drive ID.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_bmic_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|,
name|CISS_BMIC_ID_LDRIVE
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ld
operator|->
name|cl_ldrive
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ld
operator|->
name|cl_ldrive
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|=
operator|*
name|ld
operator|->
name|cl_controller
expr_stmt|;
comment|/* target controller */
name|cbc
operator|=
operator|(
expr|struct
name|ciss_bmic_cdb
operator|*
operator|)
operator|&
operator|(
name|cc
operator|->
name|cdb
operator|.
name|cdb
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|cbc
operator|->
name|log_drive
operator|=
name|CISS_LUN_TO_TARGET
argument_list|(
name|ld
operator|->
name|cl_address
operator|.
name|logical
operator|.
name|lun
argument_list|)
expr_stmt|;
comment|/*      * Submit the request and wait for it to complete.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_synch_request
argument_list|(
name|cr
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error sending BMIC LDRIVE command (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Check response.      */
name|ciss_report_request
argument_list|(
name|cr
argument_list|,
operator|&
name|command_status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command_status
condition|)
block|{
case|case
name|CISS_CMD_STATUS_SUCCESS
case|:
comment|/* buffer right size */
break|break;
case|case
name|CISS_CMD_STATUS_DATA_UNDERRUN
case|:
case|case
name|CISS_CMD_STATUS_DATA_OVERRUN
case|:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"data over/underrun reading logical drive ID\n"
argument_list|)
expr_stmt|;
default|default:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error reading logical drive ID (%s)\n"
argument_list|,
name|ciss_name_command_status
argument_list|(
name|command_status
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cr
operator|=
name|NULL
expr_stmt|;
comment|/*      * Build a CISS BMIC command to get the logical drive status.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_ldrive_status
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*      * Get the logical drive geometry.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_inquiry_logical
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*      * Print the drive's basic characteristics.      */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"logical drive (b%dt%d): %s, %dMB "
argument_list|,
name|CISS_LUN_TO_BUS
argument_list|(
name|ld
operator|->
name|cl_address
operator|.
name|logical
operator|.
name|lun
argument_list|)
argument_list|,
name|CISS_LUN_TO_TARGET
argument_list|(
name|ld
operator|->
name|cl_address
operator|.
name|logical
operator|.
name|lun
argument_list|)
argument_list|,
name|ciss_name_ldrive_org
argument_list|(
name|ld
operator|->
name|cl_ldrive
operator|->
name|fault_tolerance
argument_list|)
argument_list|,
operator|(
operator|(
name|ld
operator|->
name|cl_ldrive
operator|->
name|blocks_available
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
operator|)
operator|*
name|ld
operator|->
name|cl_ldrive
operator|->
name|block_size
operator|)
argument_list|)
expr_stmt|;
name|ciss_print_ldrive
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* make the drive not-exist */
name|ld
operator|->
name|cl_status
operator|=
name|CISS_LD_NONEXISTENT
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|cl_ldrive
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ld
operator|->
name|cl_ldrive
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
name|ld
operator|->
name|cl_ldrive
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ld
operator|->
name|cl_lstatus
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ld
operator|->
name|cl_lstatus
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
name|ld
operator|->
name|cl_lstatus
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Get status for a logical drive.  *  * XXX should we also do this in response to Test Unit Ready?  */
end_comment

begin_function
specifier|static
name|int
name|ciss_get_ldrive_status
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_ldrive
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|struct
name|ciss_bmic_cdb
modifier|*
name|cbc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|command_status
decl_stmt|;
comment|/*      * Build a CISS BMIC command to get the logical drive status.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_bmic_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|,
name|CISS_BMIC_ID_LSTATUS
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ld
operator|->
name|cl_lstatus
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ld
operator|->
name|cl_lstatus
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|=
operator|*
name|ld
operator|->
name|cl_controller
expr_stmt|;
comment|/* target controller */
name|cbc
operator|=
operator|(
expr|struct
name|ciss_bmic_cdb
operator|*
operator|)
operator|&
operator|(
name|cc
operator|->
name|cdb
operator|.
name|cdb
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|cbc
operator|->
name|log_drive
operator|=
name|CISS_LUN_TO_TARGET
argument_list|(
name|ld
operator|->
name|cl_address
operator|.
name|logical
operator|.
name|lun
argument_list|)
expr_stmt|;
comment|/*      * Submit the request and wait for it to complete.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_synch_request
argument_list|(
name|cr
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error sending BMIC LSTATUS command (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Check response.      */
name|ciss_report_request
argument_list|(
name|cr
argument_list|,
operator|&
name|command_status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command_status
condition|)
block|{
case|case
name|CISS_CMD_STATUS_SUCCESS
case|:
comment|/* buffer right size */
break|break;
case|case
name|CISS_CMD_STATUS_DATA_UNDERRUN
case|:
case|case
name|CISS_CMD_STATUS_DATA_OVERRUN
case|:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"data over/underrun reading logical drive status\n"
argument_list|)
expr_stmt|;
default|default:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error reading logical drive status (%s)\n"
argument_list|,
name|ciss_name_command_status
argument_list|(
name|command_status
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Set the drive's summary status based on the returned status.      *      * XXX testing shows that a failed JBOD drive comes back at next      * boot in "queued for expansion" mode.  WTF?      */
name|ld
operator|->
name|cl_status
operator|=
name|ciss_decode_ldrive_status
argument_list|(
name|ld
operator|->
name|cl_lstatus
operator|->
name|status
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Notify the adapter of a config update.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_update_config
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CISS_TL_SIMPLE_WRITE
argument_list|(
name|sc
argument_list|,
name|CISS_TL_SIMPLE_IDBR
argument_list|,
name|CISS_TL_SIMPLE_IDBR_CFG_TABLE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|CISS_TL_SIMPLE_READ
argument_list|(
name|sc
argument_list|,
name|CISS_TL_SIMPLE_IDBR
argument_list|)
operator|&
name|CISS_TL_SIMPLE_IDBR_CFG_TABLE
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Accept new media into a logical drive.  *  * XXX The drive has previously been offline; it would be good if we  *     could make sure it's not open right now.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_accept_media
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_ldrive
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|struct
name|ciss_bmic_cdb
modifier|*
name|cbc
decl_stmt|;
name|int
name|command_status
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|ldrive
decl_stmt|;
name|ldrive
operator|=
name|CISS_LUN_TO_TARGET
argument_list|(
name|ld
operator|->
name|cl_address
operator|.
name|logical
operator|.
name|lun
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|0
argument_list|,
literal|"bringing logical drive %d back online"
argument_list|)
expr_stmt|;
comment|/*      * Build a CISS BMIC command to bring the drive back online.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_bmic_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|,
name|CISS_BMIC_ACCEPT_MEDIA
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|=
operator|*
name|ld
operator|->
name|cl_controller
expr_stmt|;
comment|/* target controller */
name|cbc
operator|=
operator|(
expr|struct
name|ciss_bmic_cdb
operator|*
operator|)
operator|&
operator|(
name|cc
operator|->
name|cdb
operator|.
name|cdb
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|cbc
operator|->
name|log_drive
operator|=
name|ldrive
expr_stmt|;
comment|/*      * Submit the request and wait for it to complete.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_synch_request
argument_list|(
name|cr
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error sending BMIC ACCEPT MEDIA command (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Check response.      */
name|ciss_report_request
argument_list|(
name|cr
argument_list|,
operator|&
name|command_status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command_status
condition|)
block|{
case|case
name|CISS_CMD_STATUS_SUCCESS
case|:
comment|/* all OK */
comment|/* we should get a logical drive status changed event here */
break|break;
default|default:
name|ciss_printf
argument_list|(
name|cr
operator|->
name|cr_sc
argument_list|,
literal|"error accepting media into failed logical drive (%s)\n"
argument_list|,
name|ciss_name_command_status
argument_list|(
name|command_status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Release adapter resources.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_free
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* we're going away */
name|sc
operator|->
name|ciss_flags
operator||=
name|CISS_FLAG_ABORTING
expr_stmt|;
comment|/* terminate the periodic heartbeat routine */
name|untimeout
argument_list|(
name|ciss_periodic
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|ciss_periodic
argument_list|)
expr_stmt|;
comment|/* cancel the Event Notify chain */
name|ciss_notify_abort
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ciss_kill_notify_thread
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* remove the control device */
if|if
condition|(
name|sc
operator|->
name|ciss_dev_t
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|sc
operator|->
name|ciss_dev_t
argument_list|)
expr_stmt|;
comment|/* free the controller data */
if|if
condition|(
name|sc
operator|->
name|ciss_id
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|ciss_id
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
comment|/* release I/O resources */
if|if
condition|(
name|sc
operator|->
name|ciss_regs_resource
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|ciss_regs_rid
argument_list|,
name|sc
operator|->
name|ciss_regs_resource
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_cfg_resource
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|ciss_cfg_rid
argument_list|,
name|sc
operator|->
name|ciss_cfg_resource
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_intr
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|,
name|sc
operator|->
name|ciss_irq_resource
argument_list|,
name|sc
operator|->
name|ciss_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_irq_resource
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|ciss_irq_rid
argument_list|,
name|sc
operator|->
name|ciss_irq_resource
argument_list|)
expr_stmt|;
comment|/* destroy DMA tags */
if|if
condition|(
name|sc
operator|->
name|ciss_parent_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|ciss_parent_dmat
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cr
operator|=
name|ciss_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|ciss_buffer_dmat
argument_list|,
name|cr
operator|->
name|cr_datamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_buffer_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|ciss_buffer_dmat
argument_list|)
expr_stmt|;
comment|/* destroy command memory and DMA tag */
if|if
condition|(
name|sc
operator|->
name|ciss_command
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|ciss_command_dmat
argument_list|,
name|sc
operator|->
name|ciss_command_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|ciss_command_dmat
argument_list|,
name|sc
operator|->
name|ciss_command
argument_list|,
name|sc
operator|->
name|ciss_command_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ciss_command_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|ciss_command_dmat
argument_list|)
expr_stmt|;
comment|/* disconnect from CAM */
if|if
condition|(
name|sc
operator|->
name|ciss_cam_sim
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ciss_max_logical_bus
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|ciss_cam_sim
index|[
name|i
index|]
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|ciss_cam_sim
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|ciss_cam_sim
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|CISS_PHYSICAL_BASE
init|;
name|i
operator|<
name|sc
operator|->
name|ciss_max_physical_bus
operator|+
name|CISS_PHYSICAL_BASE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|ciss_cam_sim
index|[
name|i
index|]
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|ciss_cam_sim
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|ciss_cam_sim
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sc
operator|->
name|ciss_cam_sim
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ciss_cam_devq
condition|)
name|cam_simq_free
argument_list|(
name|sc
operator|->
name|ciss_cam_devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_logical
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sc
operator|->
name|ciss_max_logical_bus
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CISS_MAX_LOGICAL
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|ciss_logical
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|cl_ldrive
condition|)
name|free
argument_list|(
name|sc
operator|->
name|ciss_logical
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|cl_ldrive
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_logical
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|cl_lstatus
condition|)
name|free
argument_list|(
name|sc
operator|->
name|ciss_logical
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|cl_lstatus
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|ciss_logical
index|[
name|i
index|]
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|ciss_logical
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ciss_physical
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ciss_max_physical_bus
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|sc
operator|->
name|ciss_physical
index|[
name|i
index|]
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|ciss_physical
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ciss_controllers
condition|)
name|free
argument_list|(
name|sc
operator|->
name|ciss_controllers
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Give a command to the adapter.  *  * Note that this uses the simple transport layer directly.  If we  * want to add support for other layers, we'll need a switch of some  * sort.  *  * Note that the simple transport layer has no way of refusing a  * command; we only have as many request structures as the adapter  * supports commands, so we don't have to check (this presumes that  * the adapter can handle commands as fast as we throw them at it).  */
end_comment

begin_function
specifier|static
name|int
name|ciss_start
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
block|{
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
comment|/* XXX debugging only */
name|int
name|error
decl_stmt|;
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"post command %d tag %d "
argument_list|,
name|cr
operator|->
name|cr_tag
argument_list|,
name|cc
operator|->
name|header
operator|.
name|host_tag
argument_list|)
expr_stmt|;
comment|/*      * Map the request's data.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_map_request
argument_list|(
name|cr
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|#
directive|if
literal|0
block|ciss_print_request(cr);
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Fetch completed request(s) from the adapter, queue them for  * completion handling.  *  * Note that this uses the simple transport layer directly.  If we  * want to add support for other layers, we'll need a switch of some  * sort.  *  * Note that the simple transport mechanism does not require any  * reentrancy protection; the OPQ read is atomic.  If there is a  * chance of a race with something else that might move the request  * off the busy list, then we will have to lock against that  * (eg. timeouts, etc.)  */
end_comment

begin_function
specifier|static
name|void
name|ciss_done
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|u_int32_t
name|tag
decl_stmt|,
name|index
decl_stmt|;
name|int
name|complete
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/*      * Loop quickly taking requests from the adapter and moving them      * from the busy queue to the completed queue.      */
name|complete
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* see if the OPQ contains anything */
if|if
condition|(
operator|!
name|CISS_TL_SIMPLE_OPQ_INTERRUPT
argument_list|(
name|sc
argument_list|)
condition|)
break|break;
name|tag
operator|=
name|CISS_TL_SIMPLE_FETCH_CMD
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|CISS_TL_SIMPLE_OPQ_EMPTY
condition|)
break|break;
name|index
operator|=
name|tag
operator|>>
literal|2
expr_stmt|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"completed command %d%s"
argument_list|,
name|index
argument_list|,
operator|(
name|tag
operator|&
name|CISS_HDR_HOST_TAG_ERROR
operator|)
condition|?
literal|" with error"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|sc
operator|->
name|ciss_max_requests
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"completed invalid request %d (0x%x)\n"
argument_list|,
name|index
argument_list|,
name|tag
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cr
operator|=
operator|&
operator|(
name|sc
operator|->
name|ciss_request
index|[
name|index
index|]
operator|)
expr_stmt|;
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|host_tag
operator|=
name|tag
expr_stmt|;
comment|/* not updated by adapter */
if|if
condition|(
name|ciss_remove_busy
argument_list|(
name|cr
argument_list|)
condition|)
block|{
comment|/* assume this is garbage out of the adapter */
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"completed nonbusy request %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ciss_enqueue_complete
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
name|complete
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * Invoke completion processing.  If we can defer this out of      * interrupt context, that'd be good.      */
if|if
condition|(
name|complete
condition|)
name|ciss_complete
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Take an interrupt from the adapter.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ciss_softc
operator|*
operator|)
name|arg
decl_stmt|;
comment|/*      * The only interrupt we recognise indicates that there are      * entries in the outbound post queue.      */
name|ciss_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Process completed requests.  *  * Requests can be completed in three fashions:  *  * - by invoking a callback function (cr_complete is non-null)  * - by waking up a sleeper (cr_flags has CISS_REQ_SLEEP set)  * - by clearing the CISS_REQ_POLL flag in interrupt/timeout context  */
end_comment

begin_function
specifier|static
name|void
name|ciss_complete
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/*      * Loop taking requests off the completed queue and performing      * completion processing on them.      */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|cr
operator|=
name|ciss_dequeue_complete
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|ciss_unmap_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
comment|/* 	 * If the request has a callback, invoke it. 	 */
if|if
condition|(
name|cr
operator|->
name|cr_complete
operator|!=
name|NULL
condition|)
block|{
name|cr
operator|->
name|cr_complete
argument_list|(
name|cr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * If someone is sleeping on this request, wake them up. 	 */
if|if
condition|(
name|cr
operator|->
name|cr_flags
operator|&
name|CISS_REQ_SLEEP
condition|)
block|{
name|cr
operator|->
name|cr_flags
operator|&=
operator|~
name|CISS_REQ_SLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|cr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * If someone is polling this request for completion, signal. 	 */
if|if
condition|(
name|cr
operator|->
name|cr_flags
operator|&
name|CISS_REQ_POLL
condition|)
block|{
name|cr
operator|->
name|cr_flags
operator|&=
operator|~
name|CISS_REQ_POLL
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * Give up and throw the request back on the free queue.  This 	 * should never happen; resources will probably be lost. 	 */
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"WARNING: completed command with no submitter\n"
argument_list|)
expr_stmt|;
name|ciss_enqueue_free
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************************  * Report on the completion status of a request, and pass back SCSI  * and command status values.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_report_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|,
name|int
modifier|*
name|command_status
parameter_list|,
name|int
modifier|*
name|scsi_status
parameter_list|)
block|{
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|struct
name|ciss_error_info
modifier|*
name|ce
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|ce
operator|=
operator|(
expr|struct
name|ciss_error_info
operator|*
operator|)
operator|&
operator|(
name|cc
operator|->
name|sg
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/*      * We don't consider data under/overrun an error for the Report      * Logical/Physical LUNs commands.      */
if|if
condition|(
operator|(
name|cc
operator|->
name|header
operator|.
name|host_tag
operator|&
name|CISS_HDR_HOST_TAG_ERROR
operator|)
operator|&&
operator|(
operator|(
name|ce
operator|->
name|command_status
operator|==
name|CISS_CMD_STATUS_DATA_OVERRUN
operator|)
operator|||
operator|(
name|ce
operator|->
name|command_status
operator|==
name|CISS_CMD_STATUS_DATA_UNDERRUN
operator|)
operator|)
operator|&&
operator|(
operator|(
name|cc
operator|->
name|cdb
operator|.
name|cdb
index|[
literal|0
index|]
operator|==
name|CISS_OPCODE_REPORT_LOGICAL_LUNS
operator|)
operator|||
operator|(
name|cc
operator|->
name|cdb
operator|.
name|cdb
index|[
literal|0
index|]
operator|==
name|CISS_OPCODE_REPORT_PHYSICAL_LUNS
operator|)
operator|||
operator|(
name|cc
operator|->
name|cdb
operator|.
name|cdb
index|[
literal|0
index|]
operator|==
name|INQUIRY
operator|)
operator|)
condition|)
block|{
name|cc
operator|->
name|header
operator|.
name|host_tag
operator|&=
operator|~
name|CISS_HDR_HOST_TAG_ERROR
expr_stmt|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"ignoring irrelevant under/overrun error"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Check the command's error bit, if clear, there's no status and      * everything is OK.      */
if|if
condition|(
operator|!
operator|(
name|cc
operator|->
name|header
operator|.
name|host_tag
operator|&
name|CISS_HDR_HOST_TAG_ERROR
operator|)
condition|)
block|{
if|if
condition|(
name|scsi_status
operator|!=
name|NULL
condition|)
operator|*
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
if|if
condition|(
name|command_status
operator|!=
name|NULL
condition|)
operator|*
name|command_status
operator|=
name|CISS_CMD_STATUS_SUCCESS
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|command_status
operator|!=
name|NULL
condition|)
operator|*
name|command_status
operator|=
name|ce
operator|->
name|command_status
expr_stmt|;
if|if
condition|(
name|scsi_status
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ce
operator|->
name|command_status
operator|==
name|CISS_CMD_STATUS_TARGET_STATUS
condition|)
block|{
operator|*
name|scsi_status
operator|=
name|ce
operator|->
name|scsi_status
expr_stmt|;
block|}
else|else
block|{
operator|*
name|scsi_status
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bootverbose
condition|)
name|ciss_printf
argument_list|(
name|cr
operator|->
name|cr_sc
argument_list|,
literal|"command status 0x%x (%s) scsi status 0x%x\n"
argument_list|,
name|ce
operator|->
name|command_status
argument_list|,
name|ciss_name_command_status
argument_list|(
name|ce
operator|->
name|command_status
argument_list|)
argument_list|,
name|ce
operator|->
name|scsi_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|->
name|command_status
operator|==
name|CISS_CMD_STATUS_INVALID_COMMAND
condition|)
block|{
name|ciss_printf
argument_list|(
name|cr
operator|->
name|cr_sc
argument_list|,
literal|"invalid command, offense size %d at %d, value 0x%x\n"
argument_list|,
name|ce
operator|->
name|additional_error_info
operator|.
name|invalid_command
operator|.
name|offense_size
argument_list|,
name|ce
operator|->
name|additional_error_info
operator|.
name|invalid_command
operator|.
name|offense_offset
argument_list|,
name|ce
operator|->
name|additional_error_info
operator|.
name|invalid_command
operator|.
name|offense_value
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|ciss_print_request(cr);
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Issue a request and don't return until it's completed.  *  * Depending on adapter status, we may poll or sleep waiting for  * completion.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_synch_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
if|if
condition|(
name|cr
operator|->
name|cr_sc
operator|->
name|ciss_flags
operator|&
name|CISS_FLAG_RUNNING
condition|)
block|{
return|return
operator|(
name|ciss_wait_request
argument_list|(
name|cr
argument_list|,
name|timeout
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ciss_poll_request
argument_list|(
name|cr
argument_list|,
name|timeout
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************************  * Issue a request and poll for completion.  *  * Timeout in milliseconds.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_poll_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_flags
operator||=
name|CISS_REQ_POLL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_start
argument_list|(
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
do|do
block|{
name|ciss_done
argument_list|(
name|cr
operator|->
name|cr_sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cr
operator|->
name|cr_flags
operator|&
name|CISS_REQ_POLL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|timeout
operator|--
operator|>=
literal|0
condition|)
do|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Issue a request and sleep waiting for completion.  *  * Timeout in milliseconds.  Note that a spurious wakeup will reset  * the timeout.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_wait_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_flags
operator||=
name|CISS_REQ_SLEEP
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_start
argument_list|(
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|cr
operator|->
name|cr_flags
operator|&
name|CISS_REQ_SLEEP
operator|)
operator|&&
operator|(
name|error
operator|!=
name|EWOULDBLOCK
operator|)
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
name|cr
argument_list|,
name|PRIBIO
argument_list|,
literal|"cissREQ"
argument_list|,
operator|(
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/************************************************************************  * Abort a request.  Note that a potential exists here to race the  * request being completed; the caller must deal with this.  */
end_comment

begin_comment
unit|static int ciss_abort_request(struct ciss_request *ar) {     struct ciss_request		*cr;     struct ciss_command		*cc;     struct ciss_message_cdb	*cmc;     int				error;      debug_called(1);
comment|/* get a request */
end_comment

begin_comment
unit|if ((error = ciss_get_request(ar->cr_sc,&cr)) != 0) 	return(error);
comment|/* build the abort command */
end_comment

begin_comment
unit|cc = CISS_FIND_COMMAND(cr);     cc->header.address.mode.mode = CISS_HDR_ADDRESS_MODE_PERIPHERAL;
comment|/* addressing? */
end_comment

begin_comment
unit|cc->header.address.physical.target = 0;     cc->header.address.physical.bus = 0;     cc->cdb.cdb_length = sizeof(*cmc);     cc->cdb.type = CISS_CDB_TYPE_MESSAGE;     cc->cdb.attribute = CISS_CDB_ATTRIBUTE_SIMPLE;     cc->cdb.direction = CISS_CDB_DIRECTION_NONE;     cc->cdb.timeout = 30;      cmc = (struct ciss_message_cdb *)&(cc->cdb.cdb[0]);     cmc->opcode = CISS_OPCODE_MESSAGE_ABORT;     cmc->type = CISS_MESSAGE_ABORT_TASK;     cmc->abort_tag = ar->cr_tag;
comment|/* endianness?? */
end_comment

begin_comment
comment|/*      * Send the request and wait for a response.  If we believe we      * aborted the request OK, clear the flag that indicates it's      * running.      */
end_comment

begin_endif
unit|error = ciss_synch_request(cr, 35 * 1000);     if (!error) 	error = ciss_report_request(cr, NULL, NULL);     ciss_release_request(cr);      return(error); }
endif|#
directive|endif
end_endif

begin_comment
comment|/************************************************************************  * Fetch and initialise a request  */
end_comment

begin_function
specifier|static
name|int
name|ciss_get_request
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_request
modifier|*
modifier|*
name|crp
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/*      * Get a request and clean it up.      */
if|if
condition|(
operator|(
name|cr
operator|=
name|ciss_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|cr
operator|->
name|cr_data
operator|=
name|NULL
expr_stmt|;
name|cr
operator|->
name|cr_flags
operator|=
literal|0
expr_stmt|;
name|cr
operator|->
name|cr_complete
operator|=
name|NULL
expr_stmt|;
name|cr
operator|->
name|cr_private
operator|=
name|NULL
expr_stmt|;
name|ciss_preen_command
argument_list|(
name|cr
argument_list|)
expr_stmt|;
operator|*
name|crp
operator|=
name|cr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ciss_preen_command
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
block|{
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|u_int32_t
name|cmdphys
decl_stmt|;
comment|/*      * Clean up the command structure.      *      * Note that we set up the error_info structure here, since the      * length can be overwritten by any command.      */
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|sg_in_list
operator|=
literal|0
expr_stmt|;
comment|/* kinda inefficient this way */
name|cc
operator|->
name|header
operator|.
name|sg_total
operator|=
literal|0
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|host_tag
operator|=
name|cr
operator|->
name|cr_tag
operator|<<
literal|2
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|host_tag_zeroes
operator|=
literal|0
expr_stmt|;
name|cmdphys
operator|=
name|CISS_FIND_COMMANDPHYS
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cc
operator|->
name|error_info
operator|.
name|error_info_address
operator|=
name|cmdphys
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ciss_command
argument_list|)
expr_stmt|;
name|cc
operator|->
name|error_info
operator|.
name|error_info_length
operator|=
name|CISS_COMMAND_ALLOC_SIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ciss_command
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Release a request to the free list.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_release_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
name|cr
operator|->
name|cr_sc
expr_stmt|;
comment|/* release the request to the free queue */
name|ciss_requeue_free
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Allocate a request that will be used to send a BMIC command.  Do some  * of the common setup here to avoid duplicating it everywhere else.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_get_bmic_request
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_request
modifier|*
modifier|*
name|crp
parameter_list|,
name|int
name|opcode
parameter_list|,
name|void
modifier|*
modifier|*
name|bufp
parameter_list|,
name|size_t
name|bufsize
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|struct
name|ciss_bmic_cdb
modifier|*
name|cbc
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|dataout
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|cr
operator|=
name|NULL
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
comment|/*      * Get a request.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*      * Allocate data storage if requested, determine the data direction.      */
name|dataout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bufsize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|bufp
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|bufp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|bufsize
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|buf
operator|=
operator|*
name|bufp
expr_stmt|;
name|dataout
operator|=
literal|1
expr_stmt|;
comment|/* we are given a buffer, so we are writing */
block|}
block|}
comment|/*      * Build a CISS BMIC command to get the logical drive ID.      */
name|cr
operator|->
name|cr_data
operator|=
name|buf
expr_stmt|;
name|cr
operator|->
name|cr_length
operator|=
name|bufsize
expr_stmt|;
if|if
condition|(
operator|!
name|dataout
condition|)
name|cr
operator|->
name|cr_flags
operator|=
name|CISS_REQ_DATAIN
expr_stmt|;
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|physical
operator|.
name|mode
operator|=
name|CISS_HDR_ADDRESS_MODE_PERIPHERAL
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|physical
operator|.
name|bus
operator|=
literal|0
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|physical
operator|.
name|target
operator|=
literal|0
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|cdb_length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|cbc
argument_list|)
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|type
operator|=
name|CISS_CDB_TYPE_COMMAND
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|attribute
operator|=
name|CISS_CDB_ATTRIBUTE_SIMPLE
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|direction
operator|=
name|dataout
condition|?
name|CISS_CDB_DIRECTION_WRITE
else|:
name|CISS_CDB_DIRECTION_READ
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|cbc
operator|=
operator|(
expr|struct
name|ciss_bmic_cdb
operator|*
operator|)
operator|&
operator|(
name|cc
operator|->
name|cdb
operator|.
name|cdb
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|cbc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cbc
argument_list|)
argument_list|)
expr_stmt|;
name|cbc
operator|->
name|opcode
operator|=
name|dataout
condition|?
name|CISS_ARRAY_CONTROLLER_WRITE
else|:
name|CISS_ARRAY_CONTROLLER_READ
expr_stmt|;
name|cbc
operator|->
name|bmic_opcode
operator|=
name|opcode
expr_stmt|;
name|cbc
operator|->
name|size
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|bufsize
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|crp
operator|=
name|cr
expr_stmt|;
if|if
condition|(
operator|(
name|bufp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|bufp
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|buf
operator|!=
name|NULL
operator|)
condition|)
operator|*
name|bufp
operator|=
name|buf
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Handle a command passed in from userspace.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_user_command
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|IOCTL_Command_struct
modifier|*
name|ioc
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|struct
name|ciss_error_info
modifier|*
name|ce
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cr
operator|=
name|NULL
expr_stmt|;
comment|/*      * Get a request.      */
while|while
condition|(
name|ciss_get_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|)
operator|!=
literal|0
condition|)
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PPAUSE
argument_list|,
literal|"cissREQ"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
comment|/*      * Allocate an in-kernel databuffer if required, copy in user data.      */
name|cr
operator|->
name|cr_length
operator|=
name|ioc
operator|->
name|buf_size
expr_stmt|;
if|if
condition|(
name|ioc
operator|->
name|buf_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cr
operator|->
name|cr_data
operator|=
name|malloc
argument_list|(
name|ioc
operator|->
name|buf_size
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ioc
operator|->
name|buf
argument_list|,
name|cr
operator|->
name|cr_data
argument_list|,
name|ioc
operator|->
name|buf_size
argument_list|)
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|0
argument_list|,
literal|"copyin: bad data buffer %p/%d"
argument_list|,
name|ioc
operator|->
name|buf
argument_list|,
name|ioc
operator|->
name|buf_size
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/*      * Build the request based on the user command.      */
name|bcopy
argument_list|(
operator|&
name|ioc
operator|->
name|LUN_info
argument_list|,
operator|&
name|cc
operator|->
name|header
operator|.
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|cc
operator|->
name|header
operator|.
name|address
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ioc
operator|->
name|Request
argument_list|,
operator|&
name|cc
operator|->
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cc
operator|->
name|cdb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX anything else to populate here? */
comment|/*      * Run the command.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_synch_request
argument_list|(
name|cr
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|0
argument_list|,
literal|"request failed - %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Check to see if the command succeeded.      */
name|ce
operator|=
operator|(
expr|struct
name|ciss_error_info
operator|*
operator|)
operator|&
operator|(
name|cc
operator|->
name|sg
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|->
name|header
operator|.
name|host_tag
operator|&
name|CISS_HDR_HOST_TAG_ERROR
operator|)
operator|==
literal|0
condition|)
name|bzero
argument_list|(
name|ce
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ce
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Copy the results back to the user.      */
name|bcopy
argument_list|(
name|ce
argument_list|,
operator|&
name|ioc
operator|->
name|error_info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ce
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ioc
operator|->
name|buf_size
operator|>
literal|0
operator|)
operator|&&
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|cr
operator|->
name|cr_data
argument_list|,
name|ioc
operator|->
name|buf
argument_list|,
name|ioc
operator|->
name|buf_size
argument_list|)
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|0
argument_list|,
literal|"copyout: bad data buffer %p/%d"
argument_list|,
name|ioc
operator|->
name|buf
argument_list|,
name|ioc
operator|->
name|buf_size
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* done OK */
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
operator|(
name|cr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|cr
operator|->
name|cr_data
operator|!=
name|NULL
operator|)
condition|)
name|free
argument_list|(
name|cr
operator|->
name|cr_data
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Map a request into bus-visible space, initialise the scatter/gather  * list.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_map_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
name|cr
operator|->
name|cr_sc
expr_stmt|;
comment|/* check that mapping is necessary */
if|if
condition|(
name|cr
operator|->
name|cr_flags
operator|&
name|CISS_REQ_MAPPED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cr
operator|->
name|cr_flags
operator||=
name|CISS_REQ_MAPPED
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|ciss_command_dmat
argument_list|,
name|sc
operator|->
name|ciss_command_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_data
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|ciss_buffer_dmat
argument_list|,
name|cr
operator|->
name|cr_datamap
argument_list|,
name|cr
operator|->
name|cr_data
argument_list|,
name|cr
operator|->
name|cr_length
argument_list|,
name|ciss_request_map_helper
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
comment|/* 	 * Post the command to the adapter. 	 */
name|ciss_enqueue_busy
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|CISS_TL_SIMPLE_POST_CMD
argument_list|(
name|cr
operator|->
name|cr_sc
argument_list|,
name|CISS_FIND_COMMANDPHYS
argument_list|(
name|cr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ciss_request_map_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|cr
operator|=
operator|(
expr|struct
name|ciss_request
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|cr
operator|->
name|cr_sc
expr_stmt|;
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|cc
operator|->
name|sg
index|[
name|i
index|]
operator|.
name|address
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|cc
operator|->
name|sg
index|[
name|i
index|]
operator|.
name|length
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
name|cc
operator|->
name|sg
index|[
name|i
index|]
operator|.
name|extension
operator|=
literal|0
expr_stmt|;
block|}
comment|/* we leave the s/g table entirely within the command */
name|cc
operator|->
name|header
operator|.
name|sg_in_list
operator|=
name|nseg
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|sg_total
operator|=
name|nseg
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_flags
operator|&
name|CISS_REQ_DATAIN
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|ciss_buffer_dmat
argument_list|,
name|cr
operator|->
name|cr_datamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_flags
operator|&
name|CISS_REQ_DATAOUT
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|ciss_buffer_dmat
argument_list|,
name|cr
operator|->
name|cr_datamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/*      * Post the command to the adapter.      */
name|ciss_enqueue_busy
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|CISS_TL_SIMPLE_POST_CMD
argument_list|(
name|cr
operator|->
name|cr_sc
argument_list|,
name|CISS_FIND_COMMANDPHYS
argument_list|(
name|cr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Unmap a request from bus-visible space.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_unmap_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
name|cr
operator|->
name|cr_sc
expr_stmt|;
comment|/* check that unmapping is necessary */
if|if
condition|(
operator|(
name|cr
operator|->
name|cr_flags
operator|&
name|CISS_REQ_MAPPED
operator|)
operator|==
literal|0
condition|)
return|return;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|ciss_command_dmat
argument_list|,
name|sc
operator|->
name|ciss_command_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_data
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|cr
operator|->
name|cr_flags
operator|&
name|CISS_REQ_DATAIN
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|ciss_buffer_dmat
argument_list|,
name|cr
operator|->
name|cr_datamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_flags
operator|&
name|CISS_REQ_DATAOUT
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|ciss_buffer_dmat
argument_list|,
name|cr
operator|->
name|cr_datamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|ciss_buffer_dmat
argument_list|,
name|cr
operator|->
name|cr_datamap
argument_list|)
expr_stmt|;
name|out
label|:
name|cr
operator|->
name|cr_flags
operator|&=
operator|~
name|CISS_REQ_MAPPED
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Attach the driver to CAM.  *  * We put all the logical drives on a single SCSI bus.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_cam_init
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|maxbus
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Allocate a devq.  We can reuse this for the masked physical      * devices if we decide to export these as well.      */
if|if
condition|(
operator|(
name|sc
operator|->
name|ciss_cam_devq
operator|=
name|cam_simq_alloc
argument_list|(
name|sc
operator|->
name|ciss_max_requests
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't allocate CAM SIM queue\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*      * Create a SIM.      *      * This naturally wastes a bit of memory.  The alternative is to allocate      * and register each bus as it is found, and then track them on a linked      * list.  Unfortunately, the driver has a few places where it needs to      * look up the SIM based solely on bus number, and it's unclear whether      * a list traversal would work for these situations.      */
name|maxbus
operator|=
name|max
argument_list|(
name|sc
operator|->
name|ciss_max_logical_bus
argument_list|,
name|sc
operator|->
name|ciss_max_physical_bus
operator|+
name|CISS_PHYSICAL_BASE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ciss_cam_sim
operator|=
name|malloc
argument_list|(
name|maxbus
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cam_sim
operator|*
argument_list|)
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_cam_sim
operator|==
name|NULL
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't allocate memory for controller SIM\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ciss_max_logical_bus
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|ciss_cam_sim
index|[
name|i
index|]
operator|=
name|cam_sim_alloc
argument_list|(
name|ciss_cam_action
argument_list|,
name|ciss_cam_poll
argument_list|,
literal|"ciss"
argument_list|,
name|sc
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|)
argument_list|,
operator|&
name|Giant
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|ciss_max_requests
operator|-
literal|2
argument_list|,
name|sc
operator|->
name|ciss_cam_devq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't allocate CAM SIM for controller %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Register bus with this SIM. 	 */
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|sc
operator|->
name|ciss_controllers
index|[
name|i
index|]
operator|.
name|physical
operator|.
name|bus
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sc
operator|->
name|ciss_cam_sim
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't register SCSI bus %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
name|CISS_PHYSICAL_BASE
init|;
name|i
operator|<
name|sc
operator|->
name|ciss_max_physical_bus
operator|+
name|CISS_PHYSICAL_BASE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|ciss_cam_sim
index|[
name|i
index|]
operator|=
name|cam_sim_alloc
argument_list|(
name|ciss_cam_action
argument_list|,
name|ciss_cam_poll
argument_list|,
literal|"ciss"
argument_list|,
name|sc
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|)
argument_list|,
operator|&
name|Giant
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|ciss_max_requests
operator|-
literal|2
argument_list|,
name|sc
operator|->
name|ciss_cam_devq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't allocate CAM SIM for controller %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sc
operator|->
name|ciss_cam_sim
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"can't register SCSI bus %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/*      * Initiate a rescan of the bus.      */
name|ciss_cam_rescan_all
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Initiate a rescan of the 'logical devices' SIM  */
end_comment

begin_function
specifier|static
name|void
name|ciss_cam_rescan_target
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"rescan failed (can't allocate CCB)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|ciss_cam_sim
index|[
name|bus
index|]
argument_list|)
argument_list|,
name|target
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"rescan failed (can't create path)\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ccb
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|path
argument_list|,
literal|5
comment|/*priority (low)*/
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_BUS
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|ciss_cam_rescan_callback
expr_stmt|;
name|ccb
operator|->
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* scan is now in progress */
block|}
end_function

begin_function
specifier|static
name|void
name|ciss_cam_rescan_all
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Rescan the logical buses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ciss_max_logical_bus
condition|;
name|i
operator|++
control|)
name|ciss_cam_rescan_target
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|)
expr_stmt|;
comment|/* Rescan the physical buses */
for|for
control|(
name|i
operator|=
name|CISS_PHYSICAL_BASE
init|;
name|i
operator|<
name|sc
operator|->
name|ciss_max_physical_bus
operator|+
name|CISS_PHYSICAL_BASE
condition|;
name|i
operator|++
control|)
name|ciss_cam_rescan_target
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ciss_cam_rescan_callback
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|xpt_free_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ccb
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Handle requests coming from CAM  */
end_comment

begin_function
specifier|static
name|void
name|ciss_cam_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|;
name|int
name|physical
decl_stmt|;
name|sc
operator|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|bus
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|(
expr|struct
name|ccb_scsiio
operator|*
operator|)
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|target
operator|=
name|csio
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|physical
operator|=
name|CISS_IS_PHYSICAL
argument_list|(
name|bus
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* perform SCSI I/O */
case|case
name|XPT_SCSI_IO
case|:
if|if
condition|(
operator|!
name|ciss_cam_action_io
argument_list|(
name|sim
argument_list|,
name|csio
argument_list|)
condition|)
return|return;
break|break;
comment|/* perform geometry calculations */
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
init|=
operator|&
name|ccb
operator|->
name|ccg
decl_stmt|;
name|struct
name|ciss_ldrive
modifier|*
name|ld
decl_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"XPT_CALC_GEOMETRY %d:%d:%d"
argument_list|,
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|ld
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|physical
condition|)
name|ld
operator|=
operator|&
name|sc
operator|->
name|ciss_logical
index|[
name|bus
index|]
index|[
name|target
index|]
expr_stmt|;
comment|/* 	 * Use the cached geometry settings unless the fault tolerance 	 * is invalid. 	 */
if|if
condition|(
name|physical
operator|||
name|ld
operator|->
name|cl_geometry
operator|.
name|fault_tolerance
operator|==
literal|0xFF
condition|)
block|{
name|u_int32_t
name|secs_per_cylinder
decl_stmt|;
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
name|ld
operator|->
name|cl_geometry
operator|.
name|heads
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
name|ld
operator|->
name|cl_geometry
operator|.
name|sectors
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ntohs
argument_list|(
name|ld
operator|->
name|cl_geometry
operator|.
name|cylinders
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
comment|/* handle path attribute inquiry */
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"XPT_PATH_INQ %d:%d:%d"
argument_list|,
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_TAG_ABLE
expr_stmt|;
comment|/* XXX is this correct? */
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|CISS_MAX_LOGICAL
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|0
expr_stmt|;
comment|/* 'logical drive' channel only */
name|cpi
operator|->
name|initiator_id
operator|=
name|CISS_MAX_LOGICAL
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"msmith@freebsd.org"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|132
operator|*
literal|1024
expr_stmt|;
comment|/* XXX what to set this to? */
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
name|bus
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|target
operator|=
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"XPT_GET_TRAN_SETTINGS %d:%d"
argument_list|,
name|bus
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* disconnect always OK */
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|spi
operator|->
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|cts
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
default|default:
comment|/* we can't do this */
name|debug
argument_list|(
literal|1
argument_list|,
literal|"unspported func_code = 0x%x"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Handle a CAM SCSI I/O request.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_cam_action_io
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|;
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|bus
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|target
operator|=
name|csio
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"XPT_SCSI_IO %d:%d:%d"
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
comment|/* firmware does not support commands> 10 bytes */
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|>
literal|12
comment|/*CISS_CDB_BUFFER_SIZE*/
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"  command too large (%d> %d)"
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|,
name|CISS_CDB_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
comment|/* check that the CDB pointer is not to a physical address */
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|&&
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"  CDB pointer is to physical address"
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
comment|/* if there is data transfer, it must be to/from a virtual address */
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
condition|)
block|{
comment|/* we can't map it */
name|debug
argument_list|(
literal|3
argument_list|,
literal|"  data pointer is to physical address"
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
condition|)
block|{
comment|/* we want to do the s/g setup */
name|debug
argument_list|(
literal|3
argument_list|,
literal|"  data has premature s/g setup"
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
block|}
comment|/* abandon aborted ccbs or those that have failed validation */
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"abandoning CCB due to abort/validation failure"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* handle emulation of some SCSI commands ourself */
if|if
condition|(
name|ciss_cam_emulate
argument_list|(
name|sc
argument_list|,
name|csio
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*      * Get a request to manage this command.  If we can't, return the      * ccb, freeze the queue and flag so that we unfreeze it when a      * request completes.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*      * Build the command.      */
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_data
operator|=
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|cr
operator|->
name|cr_length
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|cr
operator|->
name|cr_complete
operator|=
name|ciss_cam_complete
expr_stmt|;
name|cr
operator|->
name|cr_private
operator|=
name|csio
expr_stmt|;
comment|/*      * Target the right logical volume.      */
if|if
condition|(
name|CISS_IS_PHYSICAL
argument_list|(
name|bus
argument_list|)
condition|)
name|cc
operator|->
name|header
operator|.
name|address
operator|=
name|sc
operator|->
name|ciss_physical
index|[
name|CISS_CAM_TO_PBUS
argument_list|(
name|bus
argument_list|)
index|]
index|[
name|target
index|]
operator|.
name|cp_address
expr_stmt|;
else|else
name|cc
operator|->
name|header
operator|.
name|address
operator|=
name|sc
operator|->
name|ciss_logical
index|[
name|bus
index|]
index|[
name|target
index|]
operator|.
name|cl_address
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|cdb_length
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|type
operator|=
name|CISS_CDB_TYPE_COMMAND
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|attribute
operator|=
name|CISS_CDB_ATTRIBUTE_SIMPLE
expr_stmt|;
comment|/* XXX ordered tags? */
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
block|{
name|cr
operator|->
name|cr_flags
operator|=
name|CISS_REQ_DATAOUT
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|direction
operator|=
name|CISS_CDB_DIRECTION_WRITE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|cr
operator|->
name|cr_flags
operator|=
name|CISS_REQ_DATAIN
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|direction
operator|=
name|CISS_CDB_DIRECTION_READ
expr_stmt|;
block|}
else|else
block|{
name|cr
operator|->
name|cr_flags
operator|=
literal|0
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|direction
operator|=
name|CISS_CDB_DIRECTION_NONE
expr_stmt|;
block|}
name|cc
operator|->
name|cdb
operator|.
name|timeout
operator|=
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|timeout
operator|/
literal|1000
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
operator|&
name|cc
operator|->
name|cdb
operator|.
name|cdb
index|[
literal|0
index|]
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
operator|&
name|cc
operator|->
name|cdb
operator|.
name|cdb
index|[
literal|0
index|]
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
comment|/*      * Submit the request to the adapter.      *      * Note that this may fail if we're unable to map the request (and      * if we ever learn a transport layer other than simple, may fail      * if the adapter rejects the command).      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_start
argument_list|(
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Emulate SCSI commands the adapter doesn't handle as we might like.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_cam_emulate
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|)
block|{
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|;
name|u_int8_t
name|opcode
decl_stmt|;
name|target
operator|=
name|csio
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|bus
operator|=
name|cam_sim_bus
argument_list|(
name|xpt_path_sim
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|opcode
operator|=
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
condition|?
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
else|:
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|CISS_IS_PHYSICAL
argument_list|(
name|bus
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ciss_physical
index|[
name|CISS_CAM_TO_PBUS
argument_list|(
name|bus
argument_list|)
index|]
index|[
name|target
index|]
operator|.
name|cp_online
operator|!=
literal|1
condition|)
block|{
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * Handle requests for volumes that don't exist or are not online.      * A selection timeout is slightly better than an illegal request.      * Other errors might be better.      */
if|if
condition|(
name|sc
operator|->
name|ciss_logical
index|[
name|bus
index|]
index|[
name|target
index|]
operator|.
name|cl_status
operator|!=
name|CISS_LD_ONLINE
condition|)
block|{
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* if we have to fake Synchronise Cache */
if|if
condition|(
name|sc
operator|->
name|ciss_flags
operator|&
name|CISS_FLAG_FAKE_SYNCH
condition|)
block|{
comment|/* 	 * If this is a Synchronise Cache command, typically issued when 	 * a device is closed, flush the adapter and complete now. 	 */
if|if
condition|(
operator|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
condition|?
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
else|:
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|)
operator|==
name|SYNCHRONIZE_CACHE
condition|)
block|{
name|ciss_flush_adapter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Check for possibly-completed commands.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_cam_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
init|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ciss_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Handle completion of a command - pass results back through the CCB  */
end_comment

begin_function
specifier|static
name|void
name|ciss_cam_complete
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|struct
name|ciss_error_info
modifier|*
name|ce
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|int
name|scsi_status
decl_stmt|;
name|int
name|command_status
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
name|cr
operator|->
name|cr_sc
expr_stmt|;
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|ce
operator|=
operator|(
expr|struct
name|ciss_error_info
operator|*
operator|)
operator|&
operator|(
name|cc
operator|->
name|sg
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|csio
operator|=
operator|(
expr|struct
name|ccb_scsiio
operator|*
operator|)
name|cr
operator|->
name|cr_private
expr_stmt|;
comment|/*      * Extract status values from request.      */
name|ciss_report_request
argument_list|(
name|cr
argument_list|,
operator|&
name|command_status
argument_list|,
operator|&
name|scsi_status
argument_list|)
expr_stmt|;
name|csio
operator|->
name|scsi_status
operator|=
name|scsi_status
expr_stmt|;
comment|/*      * Handle specific SCSI status values.      */
switch|switch
condition|(
name|scsi_status
condition|)
block|{
comment|/* no status due to adapter error */
case|case
operator|-
literal|1
case|:
name|debug
argument_list|(
literal|0
argument_list|,
literal|"adapter error"
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
break|break;
comment|/* no status due to command completed OK */
case|case
name|SCSI_STATUS_OK
case|:
comment|/* CISS_SCSI_STATUS_GOOD */
name|debug
argument_list|(
literal|2
argument_list|,
literal|"SCSI_STATUS_OK"
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
comment|/* check condition, sense data included */
case|case
name|SCSI_STATUS_CHECK_COND
case|:
comment|/* CISS_SCSI_STATUS_CHECK_CONDITION */
name|debug
argument_list|(
literal|0
argument_list|,
literal|"SCSI_STATUS_CHECK_COND  sense size %d  resid %d\n"
argument_list|,
name|ce
operator|->
name|sense_length
argument_list|,
name|ce
operator|->
name|residual_count
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
name|SSD_FULL_SIZE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ce
operator|->
name|sense_info
index|[
literal|0
index|]
argument_list|,
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
name|ce
operator|->
name|sense_length
argument_list|)
expr_stmt|;
name|csio
operator|->
name|sense_len
operator|=
name|ce
operator|->
name|sense_length
expr_stmt|;
name|csio
operator|->
name|resid
operator|=
name|ce
operator|->
name|residual_count
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
ifdef|#
directive|ifdef
name|CISS_DEBUG
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sns
init|=
operator|(
expr|struct
name|scsi_sense_data
operator|*
operator|)
operator|&
name|ce
operator|->
name|sense_info
index|[
literal|0
index|]
decl_stmt|;
name|debug
argument_list|(
literal|0
argument_list|,
literal|"sense key %x"
argument_list|,
name|sns
operator|->
name|flags
operator|&
name|SSD_KEY
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|SCSI_STATUS_BUSY
case|:
comment|/* CISS_SCSI_STATUS_BUSY */
name|debug
argument_list|(
literal|0
argument_list|,
literal|"SCSI_STATUS_BUSY"
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_BUSY
expr_stmt|;
break|break;
default|default:
name|debug
argument_list|(
literal|0
argument_list|,
literal|"unknown status 0x%x"
argument_list|,
name|csio
operator|->
name|scsi_status
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
break|break;
block|}
comment|/* handle post-command fixup */
name|ciss_cam_complete_fixup
argument_list|(
name|sc
argument_list|,
name|csio
argument_list|)
expr_stmt|;
comment|/* tell CAM we're ready for more commands */
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Fix up the result of some commands here.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_cam_complete_fixup
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|)
block|{
name|struct
name|scsi_inquiry_data
modifier|*
name|inq
decl_stmt|;
name|struct
name|ciss_ldrive
modifier|*
name|cl
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
condition|?
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
else|:
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|)
operator|==
name|INQUIRY
condition|)
block|{
name|inq
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|target
operator|=
name|csio
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|bus
operator|=
name|cam_sim_bus
argument_list|(
name|xpt_path_sim
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Don't let hard drives be seen by the DA driver.  They will still be 	 * attached by the PASS driver. 	 */
if|if
condition|(
name|CISS_IS_PHYSICAL
argument_list|(
name|bus
argument_list|)
condition|)
block|{
if|if
condition|(
name|SID_TYPE
argument_list|(
name|inq
argument_list|)
operator|==
name|T_DIRECT
condition|)
name|inq
operator|->
name|device
operator|=
operator|(
name|inq
operator|->
name|device
operator|&
literal|0xe0
operator|)
operator||
name|T_NODEVICE
expr_stmt|;
return|return;
block|}
name|cl
operator|=
operator|&
name|sc
operator|->
name|ciss_logical
index|[
name|bus
index|]
index|[
name|target
index|]
expr_stmt|;
name|padstr
argument_list|(
name|inq
operator|->
name|vendor
argument_list|,
literal|"COMPAQ"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|padstr
argument_list|(
name|inq
operator|->
name|product
argument_list|,
name|ciss_name_ldrive_org
argument_list|(
name|cl
operator|->
name|cl_ldrive
operator|->
name|fault_tolerance
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|padstr
argument_list|(
name|inq
operator|->
name|revision
argument_list|,
name|ciss_name_ldrive_status
argument_list|(
name|cl
operator|->
name|cl_lstatus
operator|->
name|status
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/********************************************************************************  * Find a peripheral attached at (target)  */
end_comment

begin_function
specifier|static
name|struct
name|cam_periph
modifier|*
name|ciss_find_periph
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|int
name|status
decl_stmt|;
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|ciss_cam_sim
index|[
name|bus
index|]
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|periph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|periph
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|periph
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Name the device at (target)  *  * XXX is this strictly correct?  */
end_comment

begin_function
specifier|static
name|int
name|ciss_name_device
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
if|if
condition|(
name|CISS_IS_PHYSICAL
argument_list|(
name|bus
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|periph
operator|=
name|ciss_find_periph
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|sc
operator|->
name|ciss_logical
index|[
name|bus
index|]
index|[
name|target
index|]
operator|.
name|cl_name
argument_list|,
literal|"%s%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|ciss_logical
index|[
name|bus
index|]
index|[
name|target
index|]
operator|.
name|cl_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Periodic status monitoring.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_periodic
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|ciss_softc
operator|*
operator|)
name|arg
expr_stmt|;
comment|/*      * Check the adapter heartbeat.      */
if|if
condition|(
name|sc
operator|->
name|ciss_cfg
operator|->
name|heartbeat
operator|==
name|sc
operator|->
name|ciss_heartbeat
condition|)
block|{
name|sc
operator|->
name|ciss_heart_attack
operator|++
expr_stmt|;
name|debug
argument_list|(
literal|0
argument_list|,
literal|"adapter heart attack in progress 0x%x/%d"
argument_list|,
name|sc
operator|->
name|ciss_heartbeat
argument_list|,
name|sc
operator|->
name|ciss_heart_attack
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ciss_heart_attack
operator|==
literal|3
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"ADAPTER HEARTBEAT FAILED\n"
argument_list|)
expr_stmt|;
comment|/* XXX should reset adapter here */
block|}
block|}
else|else
block|{
name|sc
operator|->
name|ciss_heartbeat
operator|=
name|sc
operator|->
name|ciss_cfg
operator|->
name|heartbeat
expr_stmt|;
name|sc
operator|->
name|ciss_heart_attack
operator|=
literal|0
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"new heartbeat 0x%x"
argument_list|,
name|sc
operator|->
name|ciss_heartbeat
argument_list|)
expr_stmt|;
block|}
comment|/*      * If the notify event request has died for some reason, or has      * not started yet, restart it.      */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ciss_flags
operator|&
name|CISS_FLAG_NOTIFY_OK
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|0
argument_list|,
literal|"(re)starting Event Notify chain"
argument_list|)
expr_stmt|;
name|ciss_notify_event
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/*      * Reschedule.      */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ciss_flags
operator|&
name|CISS_FLAG_ABORTING
operator|)
condition|)
name|sc
operator|->
name|ciss_periodic
operator|=
name|timeout
argument_list|(
name|ciss_periodic
argument_list|,
name|sc
argument_list|,
name|CISS_HEARTBEAT_RATE
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Request a notification response from the adapter.  *  * If (cr) is NULL, this is the first request of the adapter, so  * reset the adapter's message pointer and start with the oldest  * message available.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_notify_event
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|struct
name|ciss_notify_cdb
modifier|*
name|cnc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cr
operator|=
name|sc
operator|->
name|ciss_periodic_notify
expr_stmt|;
comment|/* get a request if we don't already have one */
if|if
condition|(
name|cr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|0
argument_list|,
literal|"can't get notify event request"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|ciss_periodic_notify
operator|=
name|cr
expr_stmt|;
name|cr
operator|->
name|cr_complete
operator|=
name|ciss_notify_complete
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"acquired request %d"
argument_list|,
name|cr
operator|->
name|cr_tag
argument_list|)
expr_stmt|;
block|}
comment|/*      * Get a databuffer if we don't already have one, note that the      * adapter command wants a larger buffer than the actual      * structure.      */
if|if
condition|(
name|cr
operator|->
name|cr_data
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cr
operator|->
name|cr_data
operator|=
name|malloc
argument_list|(
name|CISS_NOTIFY_DATA_SIZE
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|0
argument_list|,
literal|"can't get notify event request buffer"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cr
operator|->
name|cr_length
operator|=
name|CISS_NOTIFY_DATA_SIZE
expr_stmt|;
block|}
comment|/* re-setup the request's command (since we never release it) XXX overkill*/
name|ciss_preen_command
argument_list|(
name|cr
argument_list|)
expr_stmt|;
comment|/* (re)build the notify event command */
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|physical
operator|.
name|mode
operator|=
name|CISS_HDR_ADDRESS_MODE_PERIPHERAL
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|physical
operator|.
name|bus
operator|=
literal|0
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|physical
operator|.
name|target
operator|=
literal|0
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|cdb_length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|cnc
argument_list|)
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|type
operator|=
name|CISS_CDB_TYPE_COMMAND
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|attribute
operator|=
name|CISS_CDB_ATTRIBUTE_SIMPLE
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|direction
operator|=
name|CISS_CDB_DIRECTION_READ
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* no timeout, we hope */
name|cnc
operator|=
operator|(
expr|struct
name|ciss_notify_cdb
operator|*
operator|)
operator|&
operator|(
name|cc
operator|->
name|cdb
operator|.
name|cdb
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|cr
operator|->
name|cr_data
argument_list|,
name|CISS_NOTIFY_DATA_SIZE
argument_list|)
expr_stmt|;
name|cnc
operator|->
name|opcode
operator|=
name|CISS_OPCODE_READ
expr_stmt|;
name|cnc
operator|->
name|command
operator|=
name|CISS_COMMAND_NOTIFY_ON_EVENT
expr_stmt|;
name|cnc
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* no timeout, we hope */
name|cnc
operator|->
name|synchronous
operator|=
literal|0
expr_stmt|;
name|cnc
operator|->
name|ordered
operator|=
literal|0
expr_stmt|;
name|cnc
operator|->
name|seek_to_oldest
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ciss_flags
operator|&
name|CISS_FLAG_RUNNING
operator|)
operator|==
literal|0
condition|)
name|cnc
operator|->
name|new_only
operator|=
literal|1
expr_stmt|;
else|else
name|cnc
operator|->
name|new_only
operator|=
literal|0
expr_stmt|;
name|cnc
operator|->
name|length
operator|=
name|htonl
argument_list|(
name|CISS_NOTIFY_DATA_SIZE
argument_list|)
expr_stmt|;
comment|/* submit the request */
name|error
operator|=
name|ciss_start
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cr
operator|->
name|cr_data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cr
operator|->
name|cr_data
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|ciss_periodic_notify
operator|=
name|NULL
expr_stmt|;
name|debug
argument_list|(
literal|0
argument_list|,
literal|"can't submit notify event request"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ciss_flags
operator|&=
operator|~
name|CISS_FLAG_NOTIFY_OK
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|1
argument_list|,
literal|"notify event submitted"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ciss_flags
operator||=
name|CISS_FLAG_NOTIFY_OK
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ciss_notify_complete
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
block|{
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|struct
name|ciss_notify
modifier|*
name|cn
decl_stmt|;
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|scsi_status
decl_stmt|;
name|int
name|command_status
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cn
operator|=
operator|(
expr|struct
name|ciss_notify
operator|*
operator|)
name|cr
operator|->
name|cr_data
expr_stmt|;
name|sc
operator|=
name|cr
operator|->
name|cr_sc
expr_stmt|;
comment|/*      * Report request results, decode status.      */
name|ciss_report_request
argument_list|(
name|cr
argument_list|,
operator|&
name|command_status
argument_list|,
operator|&
name|scsi_status
argument_list|)
expr_stmt|;
comment|/*      * Abort the chain on a fatal error.      *      * XXX which of these are actually errors?      */
if|if
condition|(
operator|(
name|command_status
operator|!=
name|CISS_CMD_STATUS_SUCCESS
operator|)
operator|&&
operator|(
name|command_status
operator|!=
name|CISS_CMD_STATUS_TARGET_STATUS
operator|)
operator|&&
operator|(
name|command_status
operator|!=
name|CISS_CMD_STATUS_TIMEOUT
operator|)
condition|)
block|{
comment|/* XXX timeout? */
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"fatal error in Notify Event request (%s)\n"
argument_list|,
name|ciss_name_command_status
argument_list|(
name|command_status
argument_list|)
argument_list|)
expr_stmt|;
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ciss_flags
operator|&=
operator|~
name|CISS_FLAG_NOTIFY_OK
expr_stmt|;
return|return;
block|}
comment|/*      * If the adapter gave us a text message, print it.      */
if|if
condition|(
name|cn
operator|->
name|message
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"*** %.80s\n"
argument_list|,
name|cn
operator|->
name|message
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|0
argument_list|,
literal|"notify event class %d subclass %d detail %d"
argument_list|,
name|cn
operator|->
name|class
argument_list|,
name|cn
operator|->
name|subclass
argument_list|,
name|cn
operator|->
name|detail
argument_list|)
expr_stmt|;
comment|/*      * If the response indicates that the notifier has been aborted,      * release the notifier command.      */
if|if
condition|(
operator|(
name|cn
operator|->
name|class
operator|==
name|CISS_NOTIFY_NOTIFIER
operator|)
operator|&&
operator|(
name|cn
operator|->
name|subclass
operator|==
name|CISS_NOTIFY_NOTIFIER_STATUS
operator|)
operator|&&
operator|(
name|cn
operator|->
name|detail
operator|==
literal|1
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|0
argument_list|,
literal|"notifier exiting"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ciss_flags
operator|&=
operator|~
name|CISS_FLAG_NOTIFY_OK
expr_stmt|;
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ciss_periodic_notify
operator|=
name|NULL
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|ciss_periodic_notify
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle notify events in a kernel thread */
name|ciss_enqueue_notify
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ciss_periodic_notify
operator|=
name|NULL
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|ciss_periodic_notify
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|ciss_notify
argument_list|)
expr_stmt|;
block|}
comment|/*      * Send a new notify event command, if we're not aborting.      */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ciss_flags
operator|&
name|CISS_FLAG_ABORTING
operator|)
condition|)
block|{
name|ciss_notify_event
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************************  * Abort the Notify Event chain.  *  * Note that we can't just abort the command in progress; we have to  * explicitly issue an Abort Notify Event command in order for the  * adapter to clean up correctly.  *  * If we are called with CISS_FLAG_ABORTING set in the adapter softc,  * the chain will not restart itself.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_notify_abort
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|struct
name|ciss_notify_cdb
modifier|*
name|cnc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|,
name|command_status
decl_stmt|,
name|scsi_status
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cr
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* verify that there's an outstanding command */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ciss_flags
operator|&
name|CISS_FLAG_NOTIFY_OK
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* get a command to issue the abort with */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* get a buffer for the result */
if|if
condition|(
operator|(
name|cr
operator|->
name|cr_data
operator|=
name|malloc
argument_list|(
name|CISS_NOTIFY_DATA_SIZE
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|0
argument_list|,
literal|"can't get notify event request buffer"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cr
operator|->
name|cr_length
operator|=
name|CISS_NOTIFY_DATA_SIZE
expr_stmt|;
comment|/* build the CDB */
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|physical
operator|.
name|mode
operator|=
name|CISS_HDR_ADDRESS_MODE_PERIPHERAL
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|physical
operator|.
name|bus
operator|=
literal|0
expr_stmt|;
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|physical
operator|.
name|target
operator|=
literal|0
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|cdb_length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|cnc
argument_list|)
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|type
operator|=
name|CISS_CDB_TYPE_COMMAND
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|attribute
operator|=
name|CISS_CDB_ATTRIBUTE_SIMPLE
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|direction
operator|=
name|CISS_CDB_DIRECTION_READ
expr_stmt|;
name|cc
operator|->
name|cdb
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* no timeout, we hope */
name|cnc
operator|=
operator|(
expr|struct
name|ciss_notify_cdb
operator|*
operator|)
operator|&
operator|(
name|cc
operator|->
name|cdb
operator|.
name|cdb
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|cnc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cnc
argument_list|)
argument_list|)
expr_stmt|;
name|cnc
operator|->
name|opcode
operator|=
name|CISS_OPCODE_WRITE
expr_stmt|;
name|cnc
operator|->
name|command
operator|=
name|CISS_COMMAND_ABORT_NOTIFY
expr_stmt|;
name|cnc
operator|->
name|length
operator|=
name|htonl
argument_list|(
name|CISS_NOTIFY_DATA_SIZE
argument_list|)
expr_stmt|;
name|ciss_print_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
comment|/*      * Submit the request and wait for it to complete.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_synch_request
argument_list|(
name|cr
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"Abort Notify Event command failed (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Check response.      */
name|ciss_report_request
argument_list|(
name|cr
argument_list|,
operator|&
name|command_status
argument_list|,
operator|&
name|scsi_status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command_status
condition|)
block|{
case|case
name|CISS_CMD_STATUS_SUCCESS
case|:
break|break;
case|case
name|CISS_CMD_STATUS_INVALID_COMMAND
case|:
comment|/* 	 * Some older adapters don't support the CISS version of this 	 * command.  Fall back to using the BMIC version. 	 */
name|error
operator|=
name|ciss_notify_abort_bmic
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|CISS_CMD_STATUS_TARGET_STATUS
case|:
comment|/* 	 * This can happen if the adapter thinks there wasn't an outstanding 	 * Notify Event command but we did.  We clean up here. 	 */
if|if
condition|(
name|scsi_status
operator|==
name|CISS_SCSI_STATUS_CHECK_CONDITION
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ciss_periodic_notify
operator|!=
name|NULL
condition|)
name|ciss_release_request
argument_list|(
name|sc
operator|->
name|ciss_periodic_notify
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* FALLTHROUGH */
default|default:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"Abort Notify Event command failed (%s)\n"
argument_list|,
name|ciss_name_command_status
argument_list|(
name|command_status
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Sleep waiting for the notifier command to complete.  Note      * that if it doesn't, we may end up in a bad situation, since      * the adapter may deliver it later.  Also note that the adapter      * requires the Notify Event command to be cancelled in order to      * maintain internal bookkeeping.      */
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|ciss_periodic_notify
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|ciss_periodic_notify
argument_list|,
literal|0
argument_list|,
literal|"cissNEA"
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"Notify Event command failed to abort, adapter may wedge.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* release the cancel request */
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cr
operator|->
name|cr_data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cr
operator|->
name|cr_data
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|sc
operator|->
name|ciss_flags
operator|&=
operator|~
name|CISS_FLAG_NOTIFY_OK
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Abort the Notify Event chain using a BMIC command.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_notify_abort_bmic
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|command_status
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cr
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* verify that there's an outstanding command */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ciss_flags
operator|&
name|CISS_FLAG_NOTIFY_OK
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/*      * Build a BMIC command to cancel the Notify on Event command.      *      * Note that we are sending a CISS opcode here.  Odd.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_get_bmic_request
argument_list|(
name|sc
argument_list|,
operator|&
name|cr
argument_list|,
name|CISS_COMMAND_ABORT_NOTIFY
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*      * Submit the request and wait for it to complete.      */
if|if
condition|(
operator|(
name|error
operator|=
name|ciss_synch_request
argument_list|(
name|cr
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error sending BMIC Cancel Notify on Event command (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Check response.      */
name|ciss_report_request
argument_list|(
name|cr
argument_list|,
operator|&
name|command_status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command_status
condition|)
block|{
case|case
name|CISS_CMD_STATUS_SUCCESS
case|:
break|break;
default|default:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"error cancelling Notify on Event (%s)\n"
argument_list|,
name|ciss_name_command_status
argument_list|(
name|command_status
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Handle rescanning all the logical volumes when a notify event  * causes the drives to come online or offline.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_notify_rescan_logical
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ciss_lun_report
modifier|*
name|cll
decl_stmt|;
name|struct
name|ciss_ldrive
modifier|*
name|ld
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ndrives
decl_stmt|;
comment|/*      * We must rescan all logical volumes to get the right logical      * drive address.      */
name|cll
operator|=
name|ciss_report_luns
argument_list|(
name|sc
argument_list|,
name|CISS_OPCODE_REPORT_LOGICAL_LUNS
argument_list|,
name|CISS_MAX_LOGICAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cll
operator|==
name|NULL
condition|)
return|return;
name|ndrives
operator|=
operator|(
name|ntohl
argument_list|(
name|cll
operator|->
name|list_size
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|ciss_device_address
argument_list|)
operator|)
expr_stmt|;
comment|/*      * Delete any of the drives which were destroyed by the      * firmware.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ciss_max_logical_bus
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CISS_MAX_LOGICAL
condition|;
name|j
operator|++
control|)
block|{
name|ld
operator|=
operator|&
name|sc
operator|->
name|ciss_logical
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|cl_update
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ld
operator|->
name|cl_status
operator|!=
name|CISS_LD_ONLINE
condition|)
block|{
name|ciss_cam_rescan_target
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ld
operator|->
name|cl_update
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|cl_ldrive
condition|)
name|free
argument_list|(
name|ld
operator|->
name|cl_ldrive
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|cl_lstatus
condition|)
name|free
argument_list|(
name|ld
operator|->
name|cl_lstatus
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
name|ld
operator|->
name|cl_ldrive
operator|=
name|NULL
expr_stmt|;
name|ld
operator|->
name|cl_lstatus
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Scan for new drives.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndrives
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|;
name|bus
operator|=
name|CISS_LUN_TO_BUS
argument_list|(
name|cll
operator|->
name|lun
index|[
name|i
index|]
operator|.
name|logical
operator|.
name|lun
argument_list|)
expr_stmt|;
name|target
operator|=
name|CISS_LUN_TO_TARGET
argument_list|(
name|cll
operator|->
name|lun
index|[
name|i
index|]
operator|.
name|logical
operator|.
name|lun
argument_list|)
expr_stmt|;
name|ld
operator|=
operator|&
name|sc
operator|->
name|ciss_logical
index|[
name|bus
index|]
index|[
name|target
index|]
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|cl_update
operator|==
literal|0
condition|)
continue|continue;
name|ld
operator|->
name|cl_update
operator|=
literal|0
expr_stmt|;
name|ld
operator|->
name|cl_address
operator|=
name|cll
operator|->
name|lun
index|[
name|i
index|]
expr_stmt|;
name|ld
operator|->
name|cl_controller
operator|=
operator|&
name|sc
operator|->
name|ciss_controllers
index|[
name|bus
index|]
expr_stmt|;
if|if
condition|(
name|ciss_identify_logical
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ciss_cam_rescan_target
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cll
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Handle a notify event relating to the status of a logical drive.  *  * XXX need to be able to defer some of these to properly handle  *     calling the "ID Physical drive" command, unless the 'extended'  *     drive IDs are always in BIG_MAP format.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_notify_logical
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_notify
modifier|*
name|cn
parameter_list|)
block|{
name|struct
name|ciss_ldrive
modifier|*
name|ld
decl_stmt|;
name|int
name|ostatus
decl_stmt|,
name|bus
decl_stmt|,
name|target
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|bus
operator|=
name|cn
operator|->
name|device
operator|.
name|physical
operator|.
name|bus
expr_stmt|;
name|target
operator|=
name|cn
operator|->
name|data
operator|.
name|logical_status
operator|.
name|logical_drive
expr_stmt|;
name|ld
operator|=
operator|&
name|sc
operator|->
name|ciss_logical
index|[
name|bus
index|]
index|[
name|target
index|]
expr_stmt|;
switch|switch
condition|(
name|cn
operator|->
name|subclass
condition|)
block|{
case|case
name|CISS_NOTIFY_LOGICAL_STATUS
case|:
switch|switch
condition|(
name|cn
operator|->
name|detail
condition|)
block|{
case|case
literal|0
case|:
name|ciss_name_device
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"logical drive %d (%s) changed status %s->%s, spare status 0x%b\n"
argument_list|,
name|cn
operator|->
name|data
operator|.
name|logical_status
operator|.
name|logical_drive
argument_list|,
name|ld
operator|->
name|cl_name
argument_list|,
name|ciss_name_ldrive_status
argument_list|(
name|cn
operator|->
name|data
operator|.
name|logical_status
operator|.
name|previous_state
argument_list|)
argument_list|,
name|ciss_name_ldrive_status
argument_list|(
name|cn
operator|->
name|data
operator|.
name|logical_status
operator|.
name|new_state
argument_list|)
argument_list|,
name|cn
operator|->
name|data
operator|.
name|logical_status
operator|.
name|spare_state
argument_list|,
literal|"\20\1configured\2rebuilding\3failed\4in use\5available\n"
argument_list|)
expr_stmt|;
comment|/* 	     * Update our idea of the drive's status. 	     */
name|ostatus
operator|=
name|ciss_decode_ldrive_status
argument_list|(
name|cn
operator|->
name|data
operator|.
name|logical_status
operator|.
name|previous_state
argument_list|)
expr_stmt|;
name|ld
operator|->
name|cl_status
operator|=
name|ciss_decode_ldrive_status
argument_list|(
name|cn
operator|->
name|data
operator|.
name|logical_status
operator|.
name|new_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|cl_lstatus
operator|!=
name|NULL
condition|)
name|ld
operator|->
name|cl_lstatus
operator|->
name|status
operator|=
name|cn
operator|->
name|data
operator|.
name|logical_status
operator|.
name|new_state
expr_stmt|;
comment|/* 	     * Have CAM rescan the drive if its status has changed. 	     */
if|if
condition|(
name|ostatus
operator|!=
name|ld
operator|->
name|cl_status
condition|)
block|{
name|ld
operator|->
name|cl_update
operator|=
literal|1
expr_stmt|;
name|ciss_notify_rescan_logical
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* logical drive has recognised new media, needs Accept Media Exchange */
name|ciss_name_device
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"logical drive %d (%s) media exchanged, ready to go online\n"
argument_list|,
name|cn
operator|->
name|data
operator|.
name|logical_status
operator|.
name|logical_drive
argument_list|,
name|ld
operator|->
name|cl_name
argument_list|)
expr_stmt|;
name|ciss_accept_media
argument_list|(
name|sc
argument_list|,
name|ld
argument_list|)
expr_stmt|;
name|ld
operator|->
name|cl_update
operator|=
literal|1
expr_stmt|;
name|ld
operator|->
name|cl_status
operator|=
name|ciss_decode_ldrive_status
argument_list|(
name|cn
operator|->
name|data
operator|.
name|logical_status
operator|.
name|new_state
argument_list|)
expr_stmt|;
name|ciss_notify_rescan_logical
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"rebuild of logical drive %d (%s) failed due to %s error\n"
argument_list|,
name|cn
operator|->
name|data
operator|.
name|rebuild_aborted
operator|.
name|logical_drive
argument_list|,
name|ld
operator|->
name|cl_name
argument_list|,
operator|(
name|cn
operator|->
name|detail
operator|==
literal|2
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CISS_NOTIFY_LOGICAL_ERROR
case|:
if|if
condition|(
name|cn
operator|->
name|detail
operator|==
literal|0
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"FATAL I/O ERROR on logical drive %d (%s), SCSI port %d ID %d\n"
argument_list|,
name|cn
operator|->
name|data
operator|.
name|io_error
operator|.
name|logical_drive
argument_list|,
name|ld
operator|->
name|cl_name
argument_list|,
name|cn
operator|->
name|data
operator|.
name|io_error
operator|.
name|failure_bus
argument_list|,
name|cn
operator|->
name|data
operator|.
name|io_error
operator|.
name|failure_drive
argument_list|)
expr_stmt|;
comment|/* XXX should we take the drive down at this point, or will we be told? */
block|}
break|break;
case|case
name|CISS_NOTIFY_LOGICAL_SURFACE
case|:
if|if
condition|(
name|cn
operator|->
name|detail
operator|==
literal|0
condition|)
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"logical drive %d (%s) completed consistency initialisation\n"
argument_list|,
name|cn
operator|->
name|data
operator|.
name|consistency_completed
operator|.
name|logical_drive
argument_list|,
name|ld
operator|->
name|cl_name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/************************************************************************  * Handle a notify event relating to the status of a physical drive.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_notify_physical
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_notify
modifier|*
name|cn
parameter_list|)
block|{ }
end_function

begin_comment
comment|/************************************************************************  * Handle a notify event relating to the status of a physical drive.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_notify_hotplug
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_notify
modifier|*
name|cn
parameter_list|)
block|{
name|struct
name|ciss_lun_report
modifier|*
name|cll
init|=
name|NULL
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|;
name|int
name|s
decl_stmt|;
switch|switch
condition|(
name|cn
operator|->
name|subclass
condition|)
block|{
case|case
name|CISS_NOTIFY_HOTPLUG_PHYSICAL
case|:
case|case
name|CISS_NOTIFY_HOTPLUG_NONDISK
case|:
name|bus
operator|=
name|CISS_BIG_MAP_BUS
argument_list|(
name|sc
argument_list|,
name|cn
operator|->
name|data
operator|.
name|drive
operator|.
name|big_physical_drive_number
argument_list|)
expr_stmt|;
name|target
operator|=
name|CISS_BIG_MAP_TARGET
argument_list|(
name|sc
argument_list|,
name|cn
operator|->
name|data
operator|.
name|drive
operator|.
name|big_physical_drive_number
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|cn
operator|->
name|detail
operator|==
literal|0
condition|)
block|{
comment|/* 	     * Mark the device offline so that it'll start producing selection 	     * timeouts to the upper layer. 	     */
if|if
condition|(
operator|(
name|bus
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|target
operator|>=
literal|0
operator|)
condition|)
name|sc
operator|->
name|ciss_physical
index|[
name|bus
index|]
index|[
name|target
index|]
operator|.
name|cp_online
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Rescan the physical lun list for new items 	     */
name|cll
operator|=
name|ciss_report_luns
argument_list|(
name|sc
argument_list|,
name|CISS_OPCODE_REPORT_PHYSICAL_LUNS
argument_list|,
name|CISS_MAX_PHYSICAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cll
operator|==
name|NULL
condition|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"Warning, cannot get physical lun list\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ciss_filter_physical
argument_list|(
name|sc
argument_list|,
name|cll
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"Unknown hotplug event %d\n"
argument_list|,
name|cn
operator|->
name|subclass
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cll
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cll
argument_list|,
name|CISS_MALLOC_CLASS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Handle deferred processing of notify events.  Notify events may need  * sleep which is unsafe during an interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_notify_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ciss_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|ciss_notify
modifier|*
name|cn
decl_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|=
operator|(
expr|struct
name|ciss_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|ciss_notify
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|sc
operator|->
name|ciss_flags
operator|&
name|CISS_FLAG_THREAD_SHUT
operator|)
operator|==
literal|0
condition|)
block|{
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|ciss_notify
argument_list|,
name|PUSER
argument_list|,
literal|"idle"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ciss_flags
operator|&
name|CISS_FLAG_THREAD_SHUT
condition|)
break|break;
name|cr
operator|=
name|ciss_dequeue_notify
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"cr null"
argument_list|)
expr_stmt|;
name|cn
operator|=
operator|(
expr|struct
name|ciss_notify
operator|*
operator|)
name|cr
operator|->
name|cr_data
expr_stmt|;
switch|switch
condition|(
name|cn
operator|->
name|class
condition|)
block|{
case|case
name|CISS_NOTIFY_HOTPLUG
case|:
name|ciss_notify_hotplug
argument_list|(
name|sc
argument_list|,
name|cn
argument_list|)
expr_stmt|;
break|break;
case|case
name|CISS_NOTIFY_LOGICAL
case|:
name|ciss_notify_logical
argument_list|(
name|sc
argument_list|,
name|cn
argument_list|)
expr_stmt|;
break|break;
case|case
name|CISS_NOTIFY_PHYSICAL
case|:
name|ciss_notify_physical
argument_list|(
name|sc
argument_list|,
name|cn
argument_list|)
expr_stmt|;
break|break;
block|}
name|ciss_release_request
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
block|}
name|sc
operator|->
name|ciss_notify_thread
operator|=
name|NULL
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|ciss_notify_thread
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Start the notification kernel thread.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_spawn_notify_thread
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500005
if|if
condition|(
name|kthread_create
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|ciss_notify_thread
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ciss_notify_thread
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ciss_notify%d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|)
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|kthread_create
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|ciss_notify_thread
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ciss_notify_thread
argument_list|,
literal|"ciss_notify%d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|)
argument_list|)
condition|)
endif|#
directive|endif
name|panic
argument_list|(
literal|"Could not create notify thread\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Kill the notification kernel thread.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_kill_notify_thread
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|ciss_notify_thread
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|->
name|ciss_flags
operator||=
name|CISS_FLAG_THREAD_SHUT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|ciss_notify
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|ciss_notify_thread
argument_list|,
name|PUSER
argument_list|,
literal|"thtrm"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Print a request.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_print_request
parameter_list|(
name|struct
name|ciss_request
modifier|*
name|cr
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ciss_command
modifier|*
name|cc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|cr
operator|->
name|cr_sc
expr_stmt|;
name|cc
operator|=
name|CISS_FIND_COMMAND
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"REQUEST @ %p\n"
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  data %p/%d  tag %d  flags %b\n"
argument_list|,
name|cr
operator|->
name|cr_data
argument_list|,
name|cr
operator|->
name|cr_length
argument_list|,
name|cr
operator|->
name|cr_tag
argument_list|,
name|cr
operator|->
name|cr_flags
argument_list|,
literal|"\20\1mapped\2sleep\3poll\4dataout\5datain\n"
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  sg list/total %d/%d  host tag 0x%x\n"
argument_list|,
name|cc
operator|->
name|header
operator|.
name|sg_in_list
argument_list|,
name|cc
operator|->
name|header
operator|.
name|sg_total
argument_list|,
name|cc
operator|->
name|header
operator|.
name|host_tag
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|mode
operator|.
name|mode
condition|)
block|{
case|case
name|CISS_HDR_ADDRESS_MODE_PERIPHERAL
case|:
case|case
name|CISS_HDR_ADDRESS_MODE_MASK_PERIPHERAL
case|:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  physical bus %d target %d\n"
argument_list|,
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|physical
operator|.
name|bus
argument_list|,
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|physical
operator|.
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|CISS_HDR_ADDRESS_MODE_LOGICAL
case|:
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  logical unit %d\n"
argument_list|,
name|cc
operator|->
name|header
operator|.
name|address
operator|.
name|logical
operator|.
name|lun
argument_list|)
expr_stmt|;
break|break;
block|}
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  %s cdb length %d type %s attribute %s\n"
argument_list|,
operator|(
name|cc
operator|->
name|cdb
operator|.
name|direction
operator|==
name|CISS_CDB_DIRECTION_NONE
operator|)
condition|?
literal|"no-I/O"
else|:
operator|(
name|cc
operator|->
name|cdb
operator|.
name|direction
operator|==
name|CISS_CDB_DIRECTION_READ
operator|)
condition|?
literal|"READ"
else|:
operator|(
name|cc
operator|->
name|cdb
operator|.
name|direction
operator|==
name|CISS_CDB_DIRECTION_WRITE
operator|)
condition|?
literal|"WRITE"
else|:
literal|"??"
argument_list|,
name|cc
operator|->
name|cdb
operator|.
name|cdb_length
argument_list|,
operator|(
name|cc
operator|->
name|cdb
operator|.
name|type
operator|==
name|CISS_CDB_TYPE_COMMAND
operator|)
condition|?
literal|"command"
else|:
operator|(
name|cc
operator|->
name|cdb
operator|.
name|type
operator|==
name|CISS_CDB_TYPE_MESSAGE
operator|)
condition|?
literal|"message"
else|:
literal|"??"
argument_list|,
operator|(
name|cc
operator|->
name|cdb
operator|.
name|attribute
operator|==
name|CISS_CDB_ATTRIBUTE_UNTAGGED
operator|)
condition|?
literal|"untagged"
else|:
operator|(
name|cc
operator|->
name|cdb
operator|.
name|attribute
operator|==
name|CISS_CDB_ATTRIBUTE_SIMPLE
operator|)
condition|?
literal|"simple"
else|:
operator|(
name|cc
operator|->
name|cdb
operator|.
name|attribute
operator|==
name|CISS_CDB_ATTRIBUTE_HEAD_OF_QUEUE
operator|)
condition|?
literal|"head-of-queue"
else|:
operator|(
name|cc
operator|->
name|cdb
operator|.
name|attribute
operator|==
name|CISS_CDB_ATTRIBUTE_ORDERED
operator|)
condition|?
literal|"ordered"
else|:
operator|(
name|cc
operator|->
name|cdb
operator|.
name|attribute
operator|==
name|CISS_CDB_ATTRIBUTE_AUTO_CONTINGENT
operator|)
condition|?
literal|"auto-contingent"
else|:
literal|"??"
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"  %*D\n"
argument_list|,
name|cc
operator|->
name|cdb
operator|.
name|cdb_length
argument_list|,
operator|&
name|cc
operator|->
name|cdb
operator|.
name|cdb
index|[
literal|0
index|]
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|->
name|header
operator|.
name|host_tag
operator|&
name|CISS_HDR_HOST_TAG_ERROR
condition|)
block|{
comment|/* XXX print error info */
block|}
else|else
block|{
comment|/* since we don't use chained s/g, don't support it here */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
operator|->
name|header
operator|.
name|sg_in_list
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|4
operator|)
operator|==
literal|0
condition|)
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%08x/%d "
argument_list|,
operator|(
name|u_int32_t
operator|)
name|cc
operator|->
name|sg
index|[
name|i
index|]
operator|.
name|address
argument_list|,
name|cc
operator|->
name|sg
index|[
name|i
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|4
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|i
operator|==
operator|(
name|cc
operator|->
name|header
operator|.
name|sg_in_list
operator|-
literal|1
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/************************************************************************  * Print information about the status of a logical drive.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_print_ldrive
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ciss_ldrive
modifier|*
name|ld
parameter_list|)
block|{
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|ld
operator|->
name|cl_lstatus
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"does not exist\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* print drive status */
switch|switch
condition|(
name|ld
operator|->
name|cl_lstatus
operator|->
name|status
condition|)
block|{
case|case
name|CISS_LSTATUS_OK
case|:
name|printf
argument_list|(
literal|"online\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CISS_LSTATUS_INTERIM_RECOVERY
case|:
name|printf
argument_list|(
literal|"in interim recovery mode\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CISS_LSTATUS_READY_RECOVERY
case|:
name|printf
argument_list|(
literal|"ready to begin recovery\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CISS_LSTATUS_RECOVERING
case|:
name|bus
operator|=
name|CISS_BIG_MAP_BUS
argument_list|(
name|sc
argument_list|,
name|ld
operator|->
name|cl_lstatus
operator|->
name|drive_rebuilding
argument_list|)
expr_stmt|;
name|target
operator|=
name|CISS_BIG_MAP_BUS
argument_list|(
name|sc
argument_list|,
name|ld
operator|->
name|cl_lstatus
operator|->
name|drive_rebuilding
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"being recovered, working on physical drive %d.%d, %u blocks remaining\n"
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|ld
operator|->
name|cl_lstatus
operator|->
name|blocks_to_recover
argument_list|)
expr_stmt|;
break|break;
case|case
name|CISS_LSTATUS_EXPANDING
case|:
name|printf
argument_list|(
literal|"being expanded, %u blocks remaining\n"
argument_list|,
name|ld
operator|->
name|cl_lstatus
operator|->
name|blocks_to_recover
argument_list|)
expr_stmt|;
break|break;
case|case
name|CISS_LSTATUS_QUEUED_FOR_EXPANSION
case|:
name|printf
argument_list|(
literal|"queued for expansion\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CISS_LSTATUS_FAILED
case|:
name|printf
argument_list|(
literal|"queued for expansion\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CISS_LSTATUS_WRONG_PDRIVE
case|:
name|printf
argument_list|(
literal|"wrong physical drive inserted\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CISS_LSTATUS_MISSING_PDRIVE
case|:
name|printf
argument_list|(
literal|"missing a needed physical drive\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CISS_LSTATUS_BECOMING_READY
case|:
name|printf
argument_list|(
literal|"becoming ready\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* print failed physical drives */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CISS_BIG_MAP_ENTRIES
operator|/
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|bus
operator|=
name|CISS_BIG_MAP_BUS
argument_list|(
name|sc
argument_list|,
name|ld
operator|->
name|cl_lstatus
operator|->
name|drive_failure_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|target
operator|=
name|CISS_BIG_MAP_TARGET
argument_list|(
name|sc
argument_list|,
name|ld
operator|->
name|cl_lstatus
operator|->
name|drive_failure_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"physical drive %d:%d (%x) failed\n"
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|ld
operator|->
name|cl_lstatus
operator|->
name|drive_failure_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CISS_DEBUG
end_ifdef

begin_comment
comment|/************************************************************************  * Print information about the controller/driver.  */
end_comment

begin_function
specifier|static
name|void
name|ciss_print_adapter
parameter_list|(
name|struct
name|ciss_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"ADAPTER:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CISSQ_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"%s     %d/%d\n"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|"free"
else|:
name|i
operator|==
literal|1
condition|?
literal|"busy"
else|:
literal|"complete"
argument_list|,
name|sc
operator|->
name|ciss_qstat
index|[
name|i
index|]
operator|.
name|q_length
argument_list|,
name|sc
operator|->
name|ciss_qstat
index|[
name|i
index|]
operator|.
name|q_max
argument_list|)
expr_stmt|;
block|}
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"max_requests %d\n"
argument_list|,
name|sc
operator|->
name|ciss_max_requests
argument_list|)
expr_stmt|;
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"flags %b\n"
argument_list|,
name|sc
operator|->
name|ciss_flags
argument_list|,
literal|"\20\1notify_ok\2control_open\3aborting\4running\21fake_synch\22bmic_abort\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ciss_max_logical_bus
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CISS_MAX_LOGICAL
condition|;
name|j
operator|++
control|)
block|{
name|ciss_printf
argument_list|(
name|sc
argument_list|,
literal|"LOGICAL DRIVE %d:  "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ciss_print_ldrive
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ciss_logical
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* XXX Should physical drives be printed out here? */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|ciss_max_requests
condition|;
name|i
operator|++
control|)
name|ciss_print_request
argument_list|(
name|sc
operator|->
name|ciss_request
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DDB hook */
end_comment

begin_function
specifier|static
name|void
name|ciss_print0
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|devclass_find
argument_list|(
literal|"ciss"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"no ciss controllers\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ciss_print_adapter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/************************************************************************  * Return a name for a logical drive status value.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ciss_name_ldrive_status
parameter_list|(
name|int
name|status
parameter_list|)
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CISS_LSTATUS_OK
case|:
return|return
operator|(
literal|"OK"
operator|)
return|;
case|case
name|CISS_LSTATUS_FAILED
case|:
return|return
operator|(
literal|"failed"
operator|)
return|;
case|case
name|CISS_LSTATUS_NOT_CONFIGURED
case|:
return|return
operator|(
literal|"not configured"
operator|)
return|;
case|case
name|CISS_LSTATUS_INTERIM_RECOVERY
case|:
return|return
operator|(
literal|"interim recovery"
operator|)
return|;
case|case
name|CISS_LSTATUS_READY_RECOVERY
case|:
return|return
operator|(
literal|"ready for recovery"
operator|)
return|;
case|case
name|CISS_LSTATUS_RECOVERING
case|:
return|return
operator|(
literal|"recovering"
operator|)
return|;
case|case
name|CISS_LSTATUS_WRONG_PDRIVE
case|:
return|return
operator|(
literal|"wrong physical drive inserted"
operator|)
return|;
case|case
name|CISS_LSTATUS_MISSING_PDRIVE
case|:
return|return
operator|(
literal|"missing physical drive"
operator|)
return|;
case|case
name|CISS_LSTATUS_EXPANDING
case|:
return|return
operator|(
literal|"expanding"
operator|)
return|;
case|case
name|CISS_LSTATUS_BECOMING_READY
case|:
return|return
operator|(
literal|"becoming ready"
operator|)
return|;
case|case
name|CISS_LSTATUS_QUEUED_FOR_EXPANSION
case|:
return|return
operator|(
literal|"queued for expansion"
operator|)
return|;
block|}
return|return
operator|(
literal|"unknown status"
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Return an online/offline/nonexistent value for a logical drive  * status value.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_decode_ldrive_status
parameter_list|(
name|int
name|status
parameter_list|)
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CISS_LSTATUS_NOT_CONFIGURED
case|:
return|return
operator|(
name|CISS_LD_NONEXISTENT
operator|)
return|;
case|case
name|CISS_LSTATUS_OK
case|:
case|case
name|CISS_LSTATUS_INTERIM_RECOVERY
case|:
case|case
name|CISS_LSTATUS_READY_RECOVERY
case|:
case|case
name|CISS_LSTATUS_RECOVERING
case|:
case|case
name|CISS_LSTATUS_EXPANDING
case|:
case|case
name|CISS_LSTATUS_QUEUED_FOR_EXPANSION
case|:
return|return
operator|(
name|CISS_LD_ONLINE
operator|)
return|;
case|case
name|CISS_LSTATUS_FAILED
case|:
case|case
name|CISS_LSTATUS_WRONG_PDRIVE
case|:
case|case
name|CISS_LSTATUS_MISSING_PDRIVE
case|:
case|case
name|CISS_LSTATUS_BECOMING_READY
case|:
default|default:
return|return
operator|(
name|CISS_LD_OFFLINE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************************  * Return a name for a logical drive's organisation.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ciss_name_ldrive_org
parameter_list|(
name|int
name|org
parameter_list|)
block|{
switch|switch
condition|(
name|org
condition|)
block|{
case|case
name|CISS_LDRIVE_RAID0
case|:
return|return
operator|(
literal|"RAID 0"
operator|)
return|;
case|case
name|CISS_LDRIVE_RAID1
case|:
return|return
operator|(
literal|"RAID 1"
operator|)
return|;
case|case
name|CISS_LDRIVE_RAID4
case|:
return|return
operator|(
literal|"RAID 4"
operator|)
return|;
case|case
name|CISS_LDRIVE_RAID5
case|:
return|return
operator|(
literal|"RAID 5"
operator|)
return|;
case|case
name|CISS_LDRIVE_RAID51
case|:
return|return
operator|(
literal|"RAID 5+1"
operator|)
return|;
case|case
name|CISS_LDRIVE_RAIDADG
case|:
return|return
operator|(
literal|"RAID ADG"
operator|)
return|;
block|}
return|return
operator|(
literal|"unkown"
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Return a name for a command status value.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ciss_name_command_status
parameter_list|(
name|int
name|status
parameter_list|)
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CISS_CMD_STATUS_SUCCESS
case|:
return|return
operator|(
literal|"success"
operator|)
return|;
case|case
name|CISS_CMD_STATUS_TARGET_STATUS
case|:
return|return
operator|(
literal|"target status"
operator|)
return|;
case|case
name|CISS_CMD_STATUS_DATA_UNDERRUN
case|:
return|return
operator|(
literal|"data underrun"
operator|)
return|;
case|case
name|CISS_CMD_STATUS_DATA_OVERRUN
case|:
return|return
operator|(
literal|"data overrun"
operator|)
return|;
case|case
name|CISS_CMD_STATUS_INVALID_COMMAND
case|:
return|return
operator|(
literal|"invalid command"
operator|)
return|;
case|case
name|CISS_CMD_STATUS_PROTOCOL_ERROR
case|:
return|return
operator|(
literal|"protocol error"
operator|)
return|;
case|case
name|CISS_CMD_STATUS_HARDWARE_ERROR
case|:
return|return
operator|(
literal|"hardware error"
operator|)
return|;
case|case
name|CISS_CMD_STATUS_CONNECTION_LOST
case|:
return|return
operator|(
literal|"connection lost"
operator|)
return|;
case|case
name|CISS_CMD_STATUS_ABORTED
case|:
return|return
operator|(
literal|"aborted"
operator|)
return|;
case|case
name|CISS_CMD_STATUS_ABORT_FAILED
case|:
return|return
operator|(
literal|"abort failed"
operator|)
return|;
case|case
name|CISS_CMD_STATUS_UNSOLICITED_ABORT
case|:
return|return
operator|(
literal|"unsolicited abort"
operator|)
return|;
case|case
name|CISS_CMD_STATUS_TIMEOUT
case|:
return|return
operator|(
literal|"timeout"
operator|)
return|;
case|case
name|CISS_CMD_STATUS_UNABORTABLE
case|:
return|return
operator|(
literal|"unabortable"
operator|)
return|;
block|}
return|return
operator|(
literal|"unknown status"
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Handle an open on the control device.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|d_thread_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|ciss_softc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
comment|/* we might want to veto if someone already has us open */
name|sc
operator|->
name|ciss_flags
operator||=
name|CISS_FLAG_CONTROL_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  * Handle the last close on the control device.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|d_thread_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|ciss_softc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|sc
operator|->
name|ciss_flags
operator|&=
operator|~
name|CISS_FLAG_CONTROL_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Handle adapter-specific control operations.  *  * Note that the API here is compatible with the Linux driver, in order to  * simplify the porting of Compaq's userland tools.  */
end_comment

begin_function
specifier|static
name|int
name|ciss_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int32_t
name|flag
parameter_list|,
name|d_thread_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ciss_softc
modifier|*
name|sc
decl_stmt|;
name|IOCTL_Command_struct
modifier|*
name|ioc
init|=
operator|(
name|IOCTL_Command_struct
operator|*
operator|)
name|addr
decl_stmt|;
ifdef|#
directive|ifdef
name|__amd64__
name|IOCTL_Command_struct32
modifier|*
name|ioc32
init|=
operator|(
name|IOCTL_Command_struct32
operator|*
operator|)
name|addr
decl_stmt|;
name|IOCTL_Command_struct
name|ioc_swab
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|ciss_softc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CCISS_GETPCIINFO
case|:
block|{
name|cciss_pci_info_struct
modifier|*
name|pis
init|=
operator|(
name|cciss_pci_info_struct
operator|*
operator|)
name|addr
decl_stmt|;
name|pis
operator|->
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|)
expr_stmt|;
name|pis
operator|->
name|dev_fn
operator|=
name|pci_get_slot
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|)
expr_stmt|;
name|pis
operator|->
name|board_id
operator|=
name|pci_get_devid
argument_list|(
name|sc
operator|->
name|ciss_dev
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CCISS_GETINTINFO
case|:
block|{
name|cciss_coalint_struct
modifier|*
name|cis
init|=
operator|(
name|cciss_coalint_struct
operator|*
operator|)
name|addr
decl_stmt|;
name|cis
operator|->
name|delay
operator|=
name|sc
operator|->
name|ciss_cfg
operator|->
name|interrupt_coalesce_delay
expr_stmt|;
name|cis
operator|->
name|count
operator|=
name|sc
operator|->
name|ciss_cfg
operator|->
name|interrupt_coalesce_count
expr_stmt|;
break|break;
block|}
case|case
name|CCISS_SETINTINFO
case|:
block|{
name|cciss_coalint_struct
modifier|*
name|cis
init|=
operator|(
name|cciss_coalint_struct
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
operator|(
name|cis
operator|->
name|delay
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cis
operator|->
name|count
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 	 * XXX apparently this is only safe if the controller is idle, 	 *     we should suspend it before doing this. 	 */
name|sc
operator|->
name|ciss_cfg
operator|->
name|interrupt_coalesce_delay
operator|=
name|cis
operator|->
name|delay
expr_stmt|;
name|sc
operator|->
name|ciss_cfg
operator|->
name|interrupt_coalesce_count
operator|=
name|cis
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|ciss_update_config
argument_list|(
name|sc
argument_list|)
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX resume the controller here */
break|break;
block|}
case|case
name|CCISS_GETNODENAME
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|ciss_cfg
operator|->
name|server_name
argument_list|,
operator|(
name|NodeName_type
operator|*
operator|)
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|NodeName_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CCISS_SETNODENAME
case|:
name|bcopy
argument_list|(
operator|(
name|NodeName_type
operator|*
operator|)
name|addr
argument_list|,
name|sc
operator|->
name|ciss_cfg
operator|->
name|server_name
argument_list|,
sizeof|sizeof
argument_list|(
name|NodeName_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ciss_update_config
argument_list|(
name|sc
argument_list|)
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|CCISS_GETHEARTBEAT
case|:
operator|*
operator|(
name|Heartbeat_type
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|ciss_cfg
operator|->
name|heartbeat
expr_stmt|;
break|break;
case|case
name|CCISS_GETBUSTYPES
case|:
operator|*
operator|(
name|BusTypes_type
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|ciss_cfg
operator|->
name|bus_types
expr_stmt|;
break|break;
case|case
name|CCISS_GETFIRMVER
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|ciss_id
operator|->
name|running_firmware_revision
argument_list|,
operator|(
name|FirmwareVer_type
operator|*
operator|)
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|FirmwareVer_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CCISS_GETDRIVERVER
case|:
operator|*
operator|(
name|DriverVer_type
operator|*
operator|)
name|addr
operator|=
name|CISS_DRIVER_VERSION
expr_stmt|;
break|break;
case|case
name|CCISS_REVALIDVOLS
case|:
comment|/* 	 * This is a bit ugly; to do it "right" we really need 	 * to find any disks that have changed, kick CAM off them, 	 * then rescan only these disks.  It'd be nice if they 	 * a) told us which disk(s) they were going to play with, 	 * and b) which ones had arrived. 8( 	 */
break|break;
ifdef|#
directive|ifdef
name|__amd64__
case|case
name|CCISS_PASSTHRU32
case|:
name|ioc_swab
operator|.
name|LUN_info
operator|=
name|ioc32
operator|->
name|LUN_info
expr_stmt|;
name|ioc_swab
operator|.
name|Request
operator|=
name|ioc32
operator|->
name|Request
expr_stmt|;
name|ioc_swab
operator|.
name|error_info
operator|=
name|ioc32
operator|->
name|error_info
expr_stmt|;
name|ioc_swab
operator|.
name|buf_size
operator|=
name|ioc32
operator|->
name|buf_size
expr_stmt|;
name|ioc_swab
operator|.
name|buf
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|ioc32
operator|->
name|buf
expr_stmt|;
name|ioc
operator|=
operator|&
name|ioc_swab
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|CCISS_PASSTHRU
case|:
name|error
operator|=
name|ciss_user_command
argument_list|(
name|sc
argument_list|,
name|ioc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|debug
argument_list|(
literal|0
argument_list|,
literal|"unknown ioctl 0x%lx"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"CCISS_GETPCIINFO:   0x%lx"
argument_list|,
name|CCISS_GETPCIINFO
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"CCISS_GETINTINFO:   0x%lx"
argument_list|,
name|CCISS_GETINTINFO
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"CCISS_SETINTINFO:   0x%lx"
argument_list|,
name|CCISS_SETINTINFO
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"CCISS_GETNODENAME:  0x%lx"
argument_list|,
name|CCISS_GETNODENAME
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"CCISS_SETNODENAME:  0x%lx"
argument_list|,
name|CCISS_SETNODENAME
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"CCISS_GETHEARTBEAT: 0x%lx"
argument_list|,
name|CCISS_GETHEARTBEAT
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"CCISS_GETBUSTYPES:  0x%lx"
argument_list|,
name|CCISS_GETBUSTYPES
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"CCISS_GETFIRMVER:   0x%lx"
argument_list|,
name|CCISS_GETFIRMVER
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"CCISS_GETDRIVERVER: 0x%lx"
argument_list|,
name|CCISS_GETDRIVERVER
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"CCISS_REVALIDVOLS:  0x%lx"
argument_list|,
name|CCISS_REVALIDVOLS
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"CCISS_PASSTHRU:     0x%lx"
argument_list|,
name|CCISS_PASSTHRU
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOIOCTL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

